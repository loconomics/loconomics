@using WebMatrix.WebData;
@**
        Lead Generation: Referral API.

        It lets anonymous users to refer service professionals, in a process of three steps:
        - Subscribe itsefs to Loconomics newsletter just with email, getting registered as a user without enabled account.
        - Optionally provide first and last name (as independent step --updates profile created at first step)
        - Refer professionals with first name and maybe phone, email, lastName

        # Referral - Step 1: Subscribe client with email

        ## REST API
        POST /lead-generation/referral/subscribe
        - email:string
        - isServiceProfessional:boolean

        ## Restrictions
        - Only available to anonymous users (UI should prevent allowing this request to logged users)
        - All input data is required
        - Validate email format
        - Email does not exists

        ## Storage
        At [userprofile]:
        - userID: [auto]
        - email: data.email

        At [users]:
        - userID: userprofile.userID
        - isServiceProfessional: data.isServiceProfessional
        - isClient: true
        - accountStatusID: -1
        - loconomicsMarketingCampaigns: true
        - firstName: ''
        - middleIn: ''
        - lastName: ''
        - secondLastName: ''
        - marketingSource: context.url.queryString + '&lead-generation=referral'
        - preferredLanguageID: context.locale.languageID
        - preferredCountryID: context.locale.countryID
        - createdDate: DateTime.Now
        - updatedDate: DateTime.Now
        - active: true

        ## Result
        - userID:int

        ## Triggers
        - Send e-mail "Subscribed to Loconomics newsletter"

        # Referral - Step 2: Update client with name

        ## REST API
        PUT /lead-generation/referral/subscribe
        - userID:int [Required for anonymous user]
        - email:string [Required for anonymous user]
        - firstName:string
        - lastName:string

        ## Restrictions
        - Only available to anonymous users (UI should prevent allowing this request to logged users)
        - All input data is required
        - **For anonymous users:** Check that userID and email exists and matches the same user (it prevents from sending random IDs in the request, since this calls are anonymous, and we cannot validate a user session for the subscribed client because is not an active and
          password enabled  account still).
        - **For logged users:** values userID and email are not required and not used on this case, we use the the userID of the logged user.

        ## Storage
        Update [users] Where
        - userID = [when anonymous] data.userID [when logged user] context.user.userID
        Set:
        - isServiceProfessional: data.isServiceProfessional
        - firstName: data.firstName
        - lastName: data.lastName
        - updatedDate: DateTime.Now

        ## Result
        "OK"

        # Referral - Step 3: Refer service professional

        ## REST API
        POST /lead-generation/referral/refer
        - email:string [Optional]
        - firstName:string
        - lastName:string [Optional]
        - phone:string [Optional]
        - referredByUserID:int [Required for anonymous user]
        - referredByEmail:string [Required for anonymous user]

        ## Restrictions
        - Validate email format
        - Email does not exists
        - Despite that 'email' and 'phone' are optional, almost one of them is required.
        - **For anonymous users:** Check that referredByUserID and referredByEmail exists and matches the same user (it prevents from sending random IDs in the request, since this calls are anonymous, and we cannot validate a user session for the subscribed client because is not an active and password enabled account still).
        - **For logged users:** values referredByUserID and referredByEmail are not required and not used on this case, we use the the userID of the logged user.

        ## Storage
        At [userprofile]:
        - userID: [auto]
        - email: data.email or [autogenerated non-email (a value is required and must be unique)]

        At [users]:
        - userID: userprofile.userID
        - isServiceProfessional: true
        - isClient: true
        - accountStatusID: -1
        - referredByUserID: [when anonymous] data.referredByUserID [when logged user] context.user.userID
        - loconomicsMarketingCampaigns: true
        - firstName: data.firstName
        - middleIn: ''
        - lastName: data.lastName
        - secondLastNme: ''
        - mobilePhone: data.phone
        - marketingSource: context.url.queryString + '&lead-generation=referral'
        - preferredLanguageID: context.locale.languageID
        - preferredCountryID: context.locale.countryID
        - createdDate: DateTime.Now
        - updatedDate: DateTime.Now
        - active: true

        ## Result
        "OK"

        ## Triggers
        - Send e-mail "Thank you! You have referred [service professional.firstName]" *disabled for now until email templates are implemented*


        ## EXAMPLES {
            "Lead Generation: subscribe to provide referrals": {
                "url": "/api/v1/en-US/lead-generation/referral/subscribe",
                "post": {
                    "email": "user@test.one",
                    "isServiceProfessional": true
                },
                "put": {
                    "userID": 123,
                    "email": "user@test.one",
                    "firstName": "User",
                    "lastName": "Test"
                }
            },
            "Lead Generation: refer a professional": {
                "url": "/api/v1/en-US/lead-generation/referral/refer",
                "post": {
                    "email": "service@professional.test",
                    "firstName": "Service",
                    "lastname": "Professional",
                    "phone": "123456789",
                    "referredByUserID": 123,
                    "referredByEmail": "user@test.one"
                }
            }
        }
**@
@functions{
    public class RestLeadGenerationNewsletter : RestWebPage
    {
        public override dynamic Post()
        {
            if (UrlData.Count == 1)
            {
                switch (UrlData[0])
                {
                    case "subscribe":
                        return Subscribe();
                    case "refer":
                        return Refer();
                }
            }
            return base.Post();
        }

        public override dynamic Put()
        {
            if (UrlData.Count == 1 && UrlData[0] == "subscribe")
            {
                return UpdateSubscription();
            }
            return base.Put();
        }

        private dynamic Refer()
        {
            Validation.RequireField("firstName", LcRessources.RequiredField("First name"));
            Validation.Add("email",
                Validator.Regex(LcValidators.EmailAddressRegexPattern, "[[[The email is not valid.]]]"));
            // It requires almost one of email and phone
            if (Request.Form["email"].IsEmpty() &&
                Request.Form["phone"].IsEmpty())
            {
                ModelState.AddFormError("[[[An email or phone number is required]]]");
            }
            var referredByUserID = 0;
            var referredByEmail = "";
            if (WebSecurity.IsAuthenticated)
            {
                referredByUserID = WebSecurity.CurrentUserId;
                referredByEmail = WebSecurity.CurrentUserName;
            }
            else
            {
                // For anonymous, referred* fields are required and must match the same user
                referredByUserID = Request.Form["referredByUserID"].AsInt(-1);
                referredByEmail = Request.Form["referredByEmail"];
                if (referredByUserID != LcRest.Client.CheckEmailAvailability(referredByEmail))
                {
                    ModelState.AddFormError("[[[Only registered users can refer professionals]]]");
                }
            }

            if (Validation.IsValid() && ModelState.IsValid)
            {
                var email = Request.Form["email"];
                var firstName = Request.Form["firstName"];
                var lastName = Request.Form["lastName"];
                var phone = Request.Form["phone"];
                var marketingSource = (Request.Url.Query ?? "") + "&lead-generation=referral";

                var serviceProfessionalUserID = LcRest.LeadGeneration.ReferServiceProfessional(email, firstName, lastName, phone,
                    referredByUserID, marketingSource, LcRest.Locale.Current);
                if (serviceProfessionalUserID > 0)
                {
                    //LcMessaging.SendReferralThanks(referrerUserID, referrerEmail, serviceProfessionalUserID, firstName);
                    //LcMessaging.SendNoticeToReferredServiceProfessional(serviceProfessionalUserID, email, referredByUserID);
                    return "OK";
                }
                else
                {
                    throw new HttpException(500, "[[[Referral failed]]]");
                }
            }
            else
            {
                throw new HttpException(400, LcRessources.ValidationSummaryTitle);
            }
        }

        private dynamic Subscribe()
        {
            if (WebSecurity.IsAuthenticated)
            {
                throw new HttpException(400, "[[[You are already logged in!]]]");
            }
            Validation.RequireField("email", LcRessources.RequiredField("E-mail"));
            Validation.Add("email",
                Validator.Regex(LcValidators.EmailAddressRegexPattern, "[[[The email is not valid.]]]"));
            if (!Request.Form["isServiceProfessional"].IsBool())
            {
                ModelState.AddError("isServiceProfessional", "[[[Is required to indicate whether is service professional or not]]]");
            }
            if (Validation.IsValid() && ModelState.IsValid)
            {
                var email = Request.Form["email"];
                var isServiceProfessional = Request.Form["isServiceProfessional"].AsBool();
                var marketingSource = Request.Url.Query;
                var additionalSource = "&lead-generation=referral";
                marketingSource = (marketingSource ?? "") + additionalSource;
                var userID = LcRest.LeadGeneration.SubscribeNewUser(email, isServiceProfessional, marketingSource, LcRest.Locale.Current);
                if (userID > 0)
                {
                    var token = LcAuthHelper.GenerateNotEnabledAccountActivationToken(userID, email);
                    LcMessaging.SendCreateAccountProposal(userID, email, token);
                    return new
                    {
                        userID = userID
                    };
                }
                else
                {
                    throw new HttpException(500, "[[[Subscription failed]]]");
                }
            }
            else
            {
                throw new HttpException(400, LcRessources.ValidationSummaryTitle);
            }
        }

        private dynamic UpdateSubscription()
        {
            if (!WebSecurity.IsAuthenticated)
            {
                Validation.RequireField("userID", LcRessources.RequiredField("User identification"));
                // Only validate if email is given, here we don't need format validation since the proposal is to compare if the value
                // exists and matches same record as userID
                Validation.RequireField("email", LcRessources.RequiredField("E-mail"));
            }
            Validation.RequireField("firstName", LcRessources.RequiredField("First name"));
            Validation.RequireField("lastName", LcRessources.RequiredField("Second name"));

            if (Validation.IsValid() && ModelState.IsValid)
            {
                var userID = 0;
                var email = "";
                if (WebSecurity.IsAuthenticated)
                {
                    userID = WebSecurity.CurrentUserId;
                    email = WebSecurity.CurrentUserName;
                }
                else
                {
                    userID = Request.Form["userID"].AsInt();
                    email = Request.Form["email"];
                }
                var firstName = Request.Form["firstName"];
                var lastName = Request.Form["lastName"];

                LcRest.LeadGeneration.UpdateSubscription(userID, email, firstName, lastName);
                return "OK";
            }
            else
            {
                throw new HttpException(400, LcRessources.ValidationSummaryTitle);
            }
        }
    }
    }
@{
    // Public access
    new RestLeadGenerationNewsletter().JsonResponse(this);
}