;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
    Account activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function AccountActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Account');
});

exports.init = A.init;

},{"../components/Activity":45}],2:[function(require,module,exports){
/**
    AddJobTitles activity
**/
'use strict';

var Activity = require('../components/Activity');
var $ = require('jquery');
require('jquery-ui');

var A = Activity.extends(function AddJobTitlesActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Scheduling');
    
    // Setup autocomplete
    var ac = this.$activity.find('#addJobTitles-search');
    var vw = this.viewModel;
    // Autocomplete positions and add to the list
    ac.autocomplete({
        source: function(request, response) {
            vw.searchBy(request.term)
            .then(function(results) {
                response(results);
            });
        },
        autoFocus: false,
        minLength: 0,
        select: function (event, ui) {
            // No value, no action :(
            if (!ui || !ui.item || !ui.item.value) return;

            vw.addItem(ui.item);

            return false;
        },
        focus: function (event, ui) {
            if (!ui || !ui.item || !ui.item.positionSingular);
            // We want the label in textbox, not the value
            $(this).val(ui.item.positionSingular);
            return false;
        }
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {

    Activity.prototype.show.call(this, options);
    
    // Reset
    this.viewModel.searchText('');
    this.viewModel.jobTitles.removeAll();
};

var ko = require('knockout');
function ViewModel(app) {
    
    this.isSearching = ko.observable(false);
    this.isSaving = ko.observable(false);
    this.isLocked = this.isSaving;
    this.searchText = ko.observable('');
    this.jobTitles = ko.observableArray([]);
    this.submitText = ko.observable('Save');
    
    this.unsavedChanges = ko.pureComputed(function() {
        return !!this.jobTitles().length;
    }, this);

    this.searchBy = function searchBy(text) {
        return app.model.rest.get('job-titles/autocomplete', { search: text })
        .catch(function (err) {
            app.modals.showError({ error: err });
        });
    }.bind(this);
    
    this.search = function search() {
        this.searchBy(this.searchText());
    }.bind(this);
    
    this.addItem = function addItem(item) {
        // Add to the list, if is not already in it
        var foundIndex = this.findItem(item);
        if (foundIndex === -1) {
            this.jobTitles.push(item);
        }
    }.bind(this);
    
    this.add = function add() {
        var s = this.searchText();
        if (s) {
            this.addItem({
                value: 0,
                label: s
            });
            this.searchText('');
        }
    }.bind(this);
    
    /**
        Look for an item in the current list, returning
        its index in the list or -1 if nothing.
    **/
    this.findItem = function findItem(jobTitle) {
        var foundIndex = -1;
        this.jobTitles().some(function(item, index) {
            if (jobTitle.value !== 0 &&
                item.value === jobTitle.value ||
                item.label === jobTitle.label) {
                foundIndex = index;
                return true;
            }
        });
        return foundIndex;
    };
    
    this.remove = function remove(jobTitle) {
        var removeIndex = this.findItem(jobTitle);
        if (removeIndex > -1) {
            this.jobTitles.splice(removeIndex, 1);
        }
    }.bind(this);
    
    this.save = function save() {
        this.isSaving(true);
        this.submitText('Saving');

        Promise.all(this.jobTitles().map(function(jobTitle) {
            return app.model.userJobProfile.createUserJobTitle({
                jobTitleID: jobTitle.value,
                jobTitleName: jobTitle.label
            });
        }))
        .then(function(/*results*/) {
            this.submitText('Done');
            this.searchText('');
            this.isSaving(false);
            // Reset list
            this.jobTitles.removeAll();
        }.bind(this))
        .catch(function(error) {
            this.submitText('Save');
            this.searchText('');
            this.isSaving(false);
            app.modals.showError({
                title: 'Impossible to add one or more job titles',
                error: error
            });
        }.bind(this));
    }.bind(this);
}

},{"../components/Activity":45,"knockout":false}],3:[function(require,module,exports){
/**
    AddressEditor activity
    
    TODO: ModelVersion is NOT being used, so no getting updates if server updates
    the data after load (data load is requested but get first from cache). Use
    version and get sync'ed data when ready, and additionally notification to
    override changes if server data is different that any local change.

    TODO: The URL structure and how params are read is ready to allow
    edition of different kind of addresses, but actually only service addresses
    are fully supported, since 'home address' is edited in contactInfo and
    'billing addresses' are not used currently, but when needed, the support for this
    last will need to be completed. All the API calls right now are
    for model.serviceAdddresses for example.
**/
'use strict';
var ko = require('knockout'),
    Address = require('../models/Address'),
    Activity = require('../components/Activity');

var A = Activity.extends(function AddressEditorActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Locations');
    
    // Remote postal code look-up
    // NOTE: copied the code inside the postalCode computed handler in contactInfo.js with slight changes
    var app = this.app,
        viewModel = this.viewModel;
    this.registerHandler({
        target: this.viewModel.address,
        handler: function(address) {
            if (address &&
               !address.postalCode._hasLookup) {
                address.postalCode._hasLookup = true;
                
                // On change to a valid code, do remote look-up
                ko.computed(function() {
                    var postalCode = this.postalCode();
                    
                    if (postalCode && !/^\s*$/.test(postalCode)) {
                        app.model.postalCodes.getItem(postalCode)
                        .then(function(info) {
                            if (info) {
                                address.city(info.city);
                                address.stateProvinceCode(info.stateProvinceCode);
                                address.stateProvinceName(info.stateProvinceName);
                                viewModel.errorMessages.postalCode('');
                            }
                        })
                        .catch(function(err) {
                            address.city('');
                            address.stateProvinceCode('');
                            address.stateProvinceName('');
                            // Expected errors, a single message, set
                            // on the observable
                            var msg = typeof(err) === 'string' ? err : null;
                            if (msg || err && err.responseJSON && err.responseJSON.errorMessage) {
                                viewModel.errorMessages.postalCode(msg || err.responseJSON.errorMessage);
                            }
                            else {
                                // Log to console for debugging purposes, on regular use an error on the
                                // postal code is not critical and can be transparent; if there are 
                                // connectivity or authentification errors will throw on saving the address
                                console.error('Server error validating Zip Code', err);
                            }
                        });
                    }
                }, address)
                // Avoid excessive requests by setting a timeout since the latest change
                .extend({ rateLimit: { timeout: 200, method: 'notifyWhenChangesStop' } });
            }
        }
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    //jshint maxcomplexity:10    
    Activity.prototype.show.call(this, options);
    
    // Reset
    this.viewModel.wasRemoved(false);
    
    // Params    
    var params = options && options.route && options.route.segments || [];

    var kind = params[0] || '',
        isService = kind === Address.kind.service,
        jobTitleID = isService ? params[1] |0 : 0,
        addressID = isService ? params[2] |0 : params[1] |0,
        // Only used on service address creation, instead an ID we get
        // a string for 'serviceArea' or 'serviceLocation')
        serviceType = params[2] || '';
    
    this.viewModel.jobTitleID(jobTitleID);
    this.viewModel.addressID(addressID);

    if (addressID) {
        // Get the address
        this.app.model.serviceAddresses.getItemVersion(jobTitleID, addressID)
        .then(function (addressVersion) {
            if (addressVersion) {
                this.viewModel.addressVersion(addressVersion);
                this.viewModel.header('Edit Location');
            } else {
                this.viewModel.addressVersion(null);
                this.viewModel.header('Unknow location or was deleted');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            });
        }.bind(this));
    }
    else {
        // New address
        this.viewModel.addressVersion(this.app.model.serviceAddresses.newItemVersion({
            jobTitleID: jobTitleID
        }));

        switch (serviceType) {
            case 'serviceArea':
                this.viewModel.address().isServiceArea(true);
                this.viewModel.address().isServiceLocation(false);
                this.viewModel.header('Add a service area');
                break;
            case 'serviceLocation':
                this.viewModel.address().isServiceArea(false);
                this.viewModel.address().isServiceLocation(true);
                this.viewModel.header('Add a service location');
                break;
            default:
                this.viewModel.address().isServiceArea(true);
                this.viewModel.address().isServiceLocation(true);
                this.viewModel.header('Add a location');
                break;
        }
    }
};

function ViewModel(app) {

    this.header = ko.observable('Edit Location');
    
    // List of possible error messages registered
    // by name
    this.errorMessages = {
        postalCode: ko.observable('')
    };
    
    this.jobTitleID = ko.observable(0);
    this.addressID = ko.observable(0);
    
    this.addressVersion = ko.observable(null);
    this.address = ko.pureComputed(function() {
        var v = this.addressVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    this.isLoading = app.model.serviceAddresses.state.isLoading;
    this.isSaving = app.model.serviceAddresses.state.isSaving;
    this.isDeleting = app.model.serviceAddresses.state.isDeleting;

    this.wasRemoved = ko.observable(false);
    
    this.isLocked = ko.computed(function() {
        return this.isDeleting() || app.model.serviceAddresses.state.isLocked();
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        return !this.address().updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.addressVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        'Save changes' :
                        'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.addressVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {

        app.model.serviceAddresses.setItem(this.address().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.address().model.updateWith(serverData);
            // Push version so it appears as saved
            this.addressVersion().push({ evenIfObsolete: true });
            
            // On save, auto go back
            // NOTE: if auto go back is disabled, the URL must update to match the new ID
            app.successSave();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        app.modals.confirm({
            title: 'Delete location',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.serviceAddresses.delItem(this.jobTitleID(), this.addressID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    /**
        Typed value binding rather than html binding allow to avoid
        problems because the data in html are string values while
        the actual data from the model is a number.
        Cause problems on some edge cases matching values and with
        detection of changes in the data (because the binding coming from the
        control assigning a string to the value).
    **/
    this.serviceRadiusOptions = ko.observableArray([
        { value: 0.5, label: '0.5 miles' },
        { value: 1.0, label: '1 mile' },
        { value: 2.0, label: '2 miles' },
        { value: 3.0, label: '3 miles' },
        { value: 4.0, label: '4 miles' },
        { value: 5.0, label: '5 miles' },
        { value: 10, label: '10 miles' },
        { value: 25, label: '25 miles' },
        { value: 50, label: '50 miles' },
    ]);
}

},{"../components/Activity":45,"../models/Address":49,"knockout":false}],4:[function(require,module,exports){
/** Calendar activity **/
'use strict';

var $ = require('jquery'),
    moment = require('moment'),
    ko = require('knockout');
require('../components/DatePicker');

var Activity = require('../components/Activity');

var A = Activity.extends(function AppointmentActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;    
    this.menuItem = 'calendar';
    
    // Create a specific backAction that shows current date
    // and return to calendar in current date.
    // Later some more changes are applied, with viewmodel ready
    var backAction = new Activity.NavAction({
        link: 'calendar/', // Preserve last slash, for later use
        icon: Activity.NavAction.goBack.icon(),
        isTitle: true,
        text: 'Calendar'
    });
    this.navBar = new Activity.NavBar({
        title: '',
        leftAction: backAction,
        rightAction: Activity.NavAction.goHelpIndex
    });
    
    this.$appointmentView = this.$activity.find('#calendarAppointmentView');
    this.$chooseNew = $('#calendarChooseNew');
    
    this.viewModel = new ViewModel(this.app);
    
    // This title text is dynamic, we need to replace it by a computed observable
    // showing the current date
    var defBackText = backAction.text._initialValue;
    backAction.text = ko.computed(function() {

        var d = this.viewModel.currentDate();
        if (!d)
            // Fallback to the default title
            return defBackText;

        var m = moment(d);
        var t = m.format('dddd [(]M/D[)]');
        return t;
    }, this);
    // And the link is dynamic too, to allow return to the date
    // that matches current appointment
    var defLink = backAction.link._initialValue;
    backAction.link = ko.computed(function() {

        var d = this.viewModel.currentDate();
        if (!d)
            // Fallback to the default link
            return defLink;

        return defLink + d.toISOString();
    }, this);
    
    // Just update URL to match the appointment currently showed
    this.registerHandler({
        target: this.viewModel.currentAppointment,
        handler: function (apt) {
            
            if (!apt)
                return;
            
            // Update URL to match the appointment ID and
            // track it state
            // Get ID from URL, to avoid do anything if the same.
            var aptId = apt.id(),
                found = /appointment\/([^\/]+)\/(\-?\d+)/i.exec(window.location),
                urlId = found && found[2] |0,
                urlDate = found && found[1],
                curDateStr = getDateWithoutTime(this.viewModel.currentDate()).toISOString();

            if (!found ||
                urlId !== aptId.toString() ||
                urlDate !== curDateStr) {
                
                // If was an incomplete URL, just replace current state
                if (urlId === '')
                    this.app.shell.history.replaceState(null, null, 'appointment/' + curDateStr + '/' + aptId);
                else
                    this.app.shell.history.pushState(null, null, 'appointment/' + curDateStr + '/' + aptId);
            }
        }.bind(this)._delayed(10)
        // IMPORTANT: delayed REQUIRED to avoid triple loading (activity.show) on first load triggered by a click/tap event.
    });

    this.registerHandler({
        target: this.viewModel.editMode,
        handler: function(isEdit) {
            this.$activity.toggleClass('in-edit', isEdit);
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    /* jshint maxcomplexity:10 */
    Activity.prototype.show.call(this, options);
    
    var s1 = options && options.route && options.route.segments[0],
        s2 = options && options.route && options.route.segments[1],
        date,
        id;

    if (/^\-?\d+$/.test(s1)) {
        // first parameter is an ID
        id = s1 |0;
    }
    else {
        date = getDateWithoutTime(s1);
        id = s2 |0;
    }

    this.viewModel.setCurrent(date, id)
    .then(function() {
        // The card component needs to be updated on load
        // with any option passed to the activity since the component
        // is able to to interact with other activities it has requested
        // (to request information edition)
        var cardApi = this.viewModel.appointmentCardView();
        if (cardApi) {
            cardApi.passIn(this.requestData);
        }
    }.bind(this));
};

var Appointment = require('../models/Appointment');

var getDateWithoutTime = require('../utils/getDateWithoutTime');

function findAppointmentInList(list, id) {
    var found = null,
        index = -1;
    list.some(function(apt, i) {
        if (apt.id() === id) {
            found = apt;
            index = i;
            return true;
        }
    });
    return {
        item: found,
        index: index
    };
}

var CalendarEvent = require('../models/CalendarEvent'),
    Booking = require('../models/Booking');

function ViewModel(app) {
    this.app = app;
    this.appointments = ko.observableArray([]);
    this.currentDate = ko.observable(new Date());
    this.currentID = ko.observable(0);
    this.currentIndex = ko.observable(0);
    this.editMode = ko.observable(false);
    this.isLoading = ko.observable(false);
    this.isSaving = ko.observable(false);
    
    // To access the component API we use next observable,
    // updated by the component with its view
    this.appointmentCardView = ko.observable(null);

    var loadingAppointment = new Appointment({
        id: 0,
        summary: 'Loading...'
    });
    var newEmptyDateAppointment = function newEmptyDateAppointment() {
        return new Appointment({
            id: -1,
            summary: 'There are no appointments on this date',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newFreeAppointment = function newFreeAppointment() {
        return new Appointment({
            id: -2,
            summary: 'Free',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newEventAppointment = function newEventAppointment() {
        return new Appointment({
            id: -3,
            summary: 'New event...',
            sourceEvent: new CalendarEvent()
        });
    };
    var newBookingAppointment = function newBookingAppointment() {
        return new Appointment({
            id: -4,
            summary: 'New booking...',
            sourceEvent: new CalendarEvent(),
            sourceBooking: new Booking()
        });
    };
    
    this.currentAppointment = ko.observable(loadingAppointment);

    this.goPrevious = function goPrevious() {
        if (this.editMode()) return;

        var index = this.currentIndex() - 1;

        if (index < 0) {
            // Go previous date
            var m = moment(this.currentDate());
            if (!m.isValid()) {
                m = moment(new Date());
            }
            var prevDate = m.subtract(1, 'days').toDate();
            this.setCurrent(prevDate);
        }
        else {
            // Go previous item in the list, by changing currentID
            index = index % this.appointments().length;
            var apt = this.appointments()[index];
            this.currentIndex(index);
            this.currentID(apt.id());
            this.currentAppointment(apt);
            // Complete load-double check: this.setCurrent(apt.startTime(), apt.id());
        }
    };

    this.goNext = function goNext() {
        if (this.editMode()) return;
        var index = this.currentIndex() + 1;

        if (index >= this.appointments().length) {
            // Go next date
            var m = moment(this.currentDate());
            if (!m.isValid()) {
                m = moment(new Date());
            }
            var nextDate = m.add(1, 'days').toDate();
            this.setCurrent(nextDate);
        }
        else {
            // Go next item in the list, by changing currentID
            index = index % this.appointments().length;
            var apt = this.appointments()[index];
            this.currentIndex(index);
            this.currentID(apt.id());
            this.currentAppointment(apt);
            // Complete load-double check: this.setCurrent(apt.startTime(), apt.id());
        }
    };

    /**
        Changing the current viewed data by date and id
    **/

    this.setList = function (list) {
        list = list || [];
        this.appointments(list);
    };
    this.getSpecialItem = function (id) {
        switch (id) {
            default:
            //case -1:
                return newEmptyDateAppointment();
            case -2:
                return newFreeAppointment();
            case -3:
                return newEventAppointment();
            case -4:
                return newBookingAppointment();
            case -5:
                return loadingAppointment;
        }
    };
    this.setItemFromCurrentList = function (id) {
        /*jshint maxdepth:6*/
        var list = this.appointments(),
            index,
            item;

        // First, respect special IDs, except the 'no appts':
        if (id < -1) {
            item = this.getSpecialItem(id);
            index = -1;
        }
        else if (list.length === 0) {
            // No item ID, empty list:
            index = -1;
            item = newEmptyDateAppointment();
        }
        else {
            // Start getting the first item in the list
            item = list[0];
            index = 0;
            
            // With any ID value
            if (id) {
                // Search the ID
                if (id > 0) {
                    // search item in cached list
                    var found = findAppointmentInList(list, id);

                    if (found.item) {
                        item = found.item;
                        index = found.index;
                    }
                    // Else, the first item will be used
                }
                else {
                    item = this.getSpecialItem(id);
                    index = -1;
                }
            }   
        }

        this.currentID(item.id());
        this.currentIndex(index);
        this.currentAppointment(item);
    };
    
    var _setCurrent = function setCurrent(date, id) {    
        // IMPORTANT: the date to use must be ever
        // a new object rather than the referenced one to
        // avoid some edge cases where the same object is mutated
        // and comparisions can fail. 
        // getDateWithoutTime ensure to create a new instance ever.
        date = date && getDateWithoutTime(date) || null;
        if (date)
            this.currentDate(date);
        
        if (!date) {
            if (id > 0) {
                // remote search for id
                this.isLoading(true);

                var notFound = function notFound() {
                    this.isLoading(false);
                    return _setCurrent(new Date());
                }.bind(this);

                return app.model.appointments.getAppointment(id)
                .then(function (item) {
                    if (item) {
                        // Force a load for the item date.
                        var itDate = getDateWithoutTime(item.startTime());
                        this.isLoading(false);
                        return _setCurrent(itDate, item.id());
                    }
                    else {
                        return notFound();
                    }
                }.bind(this))
                .catch(notFound);
            }
            else if (id < 0) {
                // Special IDs
                return _setCurrent(new Date(), id);
            }
            else {
                // No date, no ID, load today
                return _setCurrent(new Date());
            }
        }
        else {
            this.isLoading(true);
            return app.model.appointments.getAppointmentsByDate(date)
            .then(function (list) {
                this.isLoading(false);
                this.setList(list);
                this.setItemFromCurrentList(id);
            }.bind(this))
            .catch(function(err) {

                this.isLoading(false);

                var msg = 'Error loading calendar events.';
                app.modals.showError({
                    title: msg,
                    error: err && err.error || err
                });

            }.bind(this));
        }
    }.bind(this);

    var promiseSetCurrent = Promise.resolve();
    this.setCurrent = function setCurrent(date, id) {
        // NOTE: Do nothing if is already in loading process
        // TODO: review if is better to cancel current and continue or
        // just the current queue for when it's finish.
        // If set as 'allow concurrent'
        // the isLoading may be not enough to control the several loadings
        promiseSetCurrent = promiseSetCurrent.then(function() {
            return _setCurrent(date, id);
        });
        return promiseSetCurrent;
    };
}

},{"../components/Activity":45,"../components/DatePicker":46,"../models/Appointment":50,"../models/Booking":51,"../models/CalendarEvent":54,"../utils/getDateWithoutTime":97,"knockout":false,"moment":false}],5:[function(require,module,exports){
/**
    BookMeButton activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout'),
    $ = require('jquery');

var A = Activity.extends(function BookMeButtonActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling');
    
    // Auto select text on textarea, for better 'copy'
    // NOTE: the 'select' must happen on click, not tap, not focus,
    // only 'click' is reliable and bug-free.
    this.registerHandler({
        target: this.$activity,
        event: 'click',
        selector: 'textarea',
        handler: function() {
            $(this).select();
        }
    });
    
    this.registerHandler({
        target: this.app.model.marketplaceProfile,
        event: 'error',
        handler: function(err) {
            if (err && err.task === 'save') return;
            var msg = 'Error loading data to build the Button.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.marketplaceProfile.sync();
    
    // Set the job title
    var jobID = state.route.segments[0] |0;
    this.viewModel.jobTitleID(jobID);
};

function ViewModel(app) {

    var marketplaceProfile = app.model.marketplaceProfile;
    
    // Actual data for the form:
    
    // Read-only bookCode
    this.bookCode = ko.computed(function() {
        return marketplaceProfile.data.bookCode();
    });
    
    this.jobTitleID = ko.observable(0);
    
    // Button type, can be: 'small', 'medium', 'large', 'link'
    this.type = ko.observable('medium');

    this.isLocked = marketplaceProfile.isLocked;
    
    // Generation of the button code
    
    var buttonTemplate =
        '<!-- begin Loconomics book-me-button -->' +
        '<a style="display:inline-block"><img alt="" style="border:none" /></a>' + 
        '<!-- end Loconomics book-me-button -->';
    
    var linkTemplate =
        '<!-- begin Loconomics book-me-button -->' +
        '<a><span></span></a>' +
        '<!-- end Loconomics book-me-button -->';

    this.buttonHtmlCode = ko.pureComputed(function() {
        
        if (marketplaceProfile.isLoading()) {
            return 'loading...';
        }
        else {
            var type = this.type(),
                tpl = buttonTemplate;

            if (type === 'link')
                tpl = linkTemplate;

            var siteUrl = $('html').attr('data-site-url'),
                linkUrl = siteUrl + '/book/' + this.bookCode() + '/' + this.jobTitleID() + '/',
                imgUrl = siteUrl + '/img/extern/book-me-button-' + type + '.png';

            var code = generateButtonCode({
                tpl: tpl,
                label: 'Click here to book me now (on loconomics.com)',
                linkUrl: linkUrl,
                imgUrl: imgUrl
            });

            return code;
        }
    }, this);
    
    // TODO Copy feature; will need a native plugin
    this.copyCode = function() { };
    
    this.sendByEmail = function() {
        // TODO Send by email, with window.open('mailto:&body=code');
    };
}

function generateButtonCode(options) {

    var $btn = $($.parseHTML('<div>' + options.tpl + '</div>'));

    $btn
    .find('a')
    .attr('href', options.linkUrl)
    .find('span')
    .text(options.label);
    $btn
    .find('img')
    .attr('src', options.imgUrl)
    .attr('alt', options.label);

    return $btn.html();
}

},{"../components/Activity":45,"knockout":false}],6:[function(require,module,exports){
/**
    bookingConfirmation activity
    
    TODO: To replaced by a modal
**/
'use strict';

var ko = require('knockout');
    
var singleton = null;

exports.init = function initClients($activity, app) {

    if (singleton === null)
        singleton = new BookingConfirmationActivity($activity, app);
    
    return singleton;
};

function BookingConfirmationActivity($activity, app) {

    this.accessLevel = app.UserType.LoggedUser;
    
    this.$activity = $activity;
    this.app = app;

    this.dataView = new ViewModel();
    ko.applyBindings(this.dataView, $activity.get(0));
}

BookingConfirmationActivity.prototype.show = function show(options) {

    if (options && options.booking)
        this.dataView.booking(options.booking);
};

function ViewModel() {

    // :Appointment
    this.booking = ko.observable(null);
}

},{"knockout":false}],7:[function(require,module,exports){
/** Calendar activity **/
'use strict';

var $ = require('jquery'),
    moment = require('moment'),
    ko = require('knockout');
    //CalendarSlot = require('../models/CalendarSlot');

require('../components/DatePicker');

var Activity = require('../components/Activity');

var A = Activity.extends(function CalendarActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Calendar');

    /* Getting elements */
    this.$datepicker = this.$activity.find('#calendarDatePicker');
    this.$dailyView = this.$activity.find('#calendarDailyView');
    this.$dateHeader = this.$activity.find('#calendarDateHeader');
    this.$dateTitle = this.$dateHeader.children('.CalendarDateHeader-date');
    this.$chooseNew = $('#calendarChooseNew');
    
    /* Init components */
    this.$datepicker.show().datepicker();
    
    /* Event handlers */
    // Changes on currentDate
    this.registerHandler({
        target: this.viewModel.currentDate,
        handler: function(date) {
            // Trigger a layout update, required by the full-height feature
            $(window).trigger('layoutUpdate');

            if (date) {
                var mdate = moment(date);

                if (mdate.isValid()) {

                    var isoDate = mdate.toISOString();

                    // Update datepicker selected date on date change (from 
                    // a different source than the datepicker itself
                    this.$datepicker.removeClass('is-visible');
                    // Change not from the widget?
                    if (this.$datepicker.datepicker('getValue').toISOString() !== isoDate)
                        this.$datepicker.datepicker('setValue', date, true);

                    // On currentDate changes, update the URL
                    // TODO: save a useful state
                    // DOUBT: push or replace state? (more history entries or the same?)
                    this.app.shell.history.pushState(null, null, 'calendar/' + isoDate);

                    // DONE
                    return;
                }
            }

            // Something fail, bad date or not date at all
            // Set the current 
            this.viewModel.currentDate(getDateWithoutTime());

        }.bind(this)
    });

    // Swipe date on gesture
    this.registerHandler({
        target: this.$dailyView,
        event: 'swipeleft swiperight',
        handler: function(e) {
            e.preventDefault();

            var dir = e.type === 'swipeleft' ? 'next' : 'prev';

            // Hack to solve the freezy-swipe and tap-after bug on JQM:
            $(document).trigger('touchend');
            // Change date
            this.$datepicker.datepicker('moveValue', dir, 'date');

        }.bind(this)
    });

    // Changing date with buttons:
    this.registerHandler({
        target: this.$dateHeader,
        event: 'tap',
        selector: '.CalendarDateHeader-switch',
        handler: function(e) {
            switch (e.currentTarget.getAttribute('href')) {
                case '#prev':
                    this.$datepicker.datepicker('moveValue', 'prev', 'date');
                    break;
                case '#next':
                    this.$datepicker.datepicker('moveValue', 'next', 'date');
                    break;
                default:
                    // Lets default:
                    return;
            }
            e.preventDefault();
            e.stopPropagation();
        }.bind(this)
    });

    // Showing datepicker when pressing the title
    this.registerHandler({
        target: this.$dateTitle,
        event: 'tap',
        handler: function(e) {
            this.$datepicker.toggleClass('is-visible');
            e.preventDefault();
            e.stopPropagation();
        }.bind(this)
    });

    // Updating view date when picked another one
    this.registerHandler({
        target: this.$datepicker,
        event: 'changeDate',
        handler: function(e) {
            if (e.viewMode === 'days') {
                this.viewModel.currentDate(getDateWithoutTime(e.date));
            }
        }.bind(this)
    });

    // Set date to today
    this.viewModel.currentDate(getDateWithoutTime());
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    // Date from the parameter, fallback to today
    var sdate = options.route && options.route.segments && options.route.segments[0],
        date;
    if (sdate) {
        // Parsing date from ISO format
        var mdate = moment(sdate);
        // Check is valid, and ensure is date at 12AM
        date = mdate.isValid() ? getDateWithoutTime(mdate.toDate()) : null;
    }
    
    if (!date)
        // Today:
        date = getDateWithoutTime();
    
    this.viewModel.currentDate(date);
};

function getDateWithoutTime(date) {
    date = date || new Date();
    return new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        0, 0, 0
    );
}

var Appointment = require('../models/Appointment'),
    TimeSlotViewModel = require('../viewmodels/TimeSlot');

function ViewModel(app) {

    this.currentDate = ko.observable(getDateWithoutTime());
    var fullDayFree = [Appointment.newFreeSlot({ date: this.currentDate() })];
    // The 'free' event must update with any change in currentDate
    this.currentDate.subscribe(function(date) {
        if (date) {
            fullDayFree[0].startTime(date);
            fullDayFree[0].endTime(date);
        }
    }, this);

    // slotsSource save the data as processed by a request of 
    // data because a date change.
    // It's updated by changes on currentDate that performs the remote loading
    this.slotsSource = ko.observable(fullDayFree);
    // slots computed, using slotsSource.
    // As computed in order to allow any other observable change
    // from trigger the creation of a new value
    this.slots = ko.computed(function() {
    
        var slots = this.slotsSource();
        
        return app.model.appointments
            .fillWithFreeSlots(slots)
            .map(TimeSlotViewModel.fromAppointment);

    }, this);
    
    this.isLoading = ko.observable(false);

    // Update current slots on date change
    var previousDate = this.currentDate().toISOString();
    this.currentDate.subscribe(function (date) {
        
        // IMPORTANT: The date object may be reused and mutated between calls
        // (mostly because the widget I think), so is better to create
        // a clone and avoid getting race-conditions in the data downloading.
        date = new Date(Date.parse(date.toISOString()));

        // Avoid duplicated notification, un-changed date
        if (date.toISOString() === previousDate) {
            return;
        }
        previousDate = date.toISOString();

        this.isLoading(true);
        
        app.model.appointments.getAppointmentsByDate(date)
        .then(function(appointmentsList) {
            
            // IMPORTANT: First, we need to check that we are
            // in the same date still, because several loadings
            // can happen at a time (changing quickly from date to date
            // without wait for finish), avoiding a race-condition
            // that create flickering effects or replace the date events
            // by the events from other date, because it tooks more an changed.
            // TODO: still this has the minor bug of losing the isLoading
            // if a previous triggered load still didn't finished; its minor
            // because is very rare that happens, moving this stuff
            // to a special appModel for mixed bookings and events with 
            // per date cache that includes a view object with isLoading will
            // fix it and reduce this complexity.
            if (date.toISOString() !== this.currentDate().toISOString()) {
                // Race condition, not the same!! out:
                return;
            }
        
            if (appointmentsList && appointmentsList.length) {
                // Update the source:
                this.slotsSource(appointmentsList);
                this.isLoading(false);
            }
            else {
                this.slotsSource(fullDayFree);
                this.isLoading(false);
            }

        }.bind(this))
        .catch(function(err) {
            
            // Show free on error
            this.slotsSource(fullDayFree);
            this.isLoading(false);
            
            var msg = 'Error loading calendar events.';
            app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
            
        }.bind(this));

    }.bind(this));
}

},{"../components/Activity":45,"../components/DatePicker":46,"../models/Appointment":50,"../viewmodels/TimeSlot":138,"knockout":false,"moment":false}],8:[function(require,module,exports){
/**
    CalendarSyncing activity
**/
'use strict';

var Activity = require('../components/Activity'),
    $ = require('jquery'),
    ko = require('knockout');

var A = Activity.extends(function CalendarSyncingActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    
    // Adding auto-select behavior to the export URL
    this.registerHandler({
        target: this.$activity.find('#calendarSync-icalExportUrl'),
        event: 'click',
        handler: function() {
            $(this).select();
        }
    });
    
    this.registerHandler({
        target: this.app.model.calendarSyncing,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving calendar syncing settings.' : 'Error loading calendar syncing settings.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.calendarSyncing.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var calendarSyncing = app.model.calendarSyncing;

    var syncVersion = calendarSyncing.newVersion();
    syncVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            syncVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.sync = syncVersion.version;

    this.isLocked = ko.pureComputed(function() {
        return this.isLocked() || this.isReseting();
    }, calendarSyncing);

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, calendarSyncing);
    
    this.resetText = ko.pureComputed(function() {
        return (
            this.isReseting() ? 
                'reseting...' : 
                'Reset Private URL'
        );
    }, calendarSyncing);
    
    this.discard = function discard() {
        syncVersion.pull({ evenIfNewer: true });
    };

    this.save = function save() {
        // Force to save, even if there was remote updates
        syncVersion.push({ evenIfObsolete: true });
        
        app.successSave();
    };
    
    this.reset = function reset() {
        calendarSyncing.resetExportUrl();
    };
}

},{"../components/Activity":45,"knockout":false}],9:[function(require,module,exports){
/**
    ClientEdition activity
**/
'use strict';

var Activity = require('../components/Activity');
var is = require('is_js');

var A = Activity.extends(function ClientEditionActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('clients', {
        backLink: 'clients'
    });
    
    // If there is a change on the clientID, the updates must match
    // that (if is not already that)
    this.registerHandler({
        target: this.viewModel.clientID,
        handler: function (clientID) {
            if (!clientID)
                return;

            var found = /clientEditor\/(\-?\d+)/i.exec(window.location),
                urlID = found && found[1] |0;

            // If is different URL and current ID
            if (!found ||
                urlID !== clientID) {
                // Replace URL
                this.app.shell.history.replaceState(null, null, 'clientEditor/' + clientID);
            }
        }.bind(this)
    });
    
    // Special treatment of the save operation
    this.viewModel.onSave = function(clientID) {
        if (this.requestData.returnNewAsSelected === true) {
            // Go to previous activity that required
            // to select a client
            this.requestData.clientID = clientID;
            this.app.shell.goBack(this.requestData);
        }
        else {
            // Regular save
            this.app.successSave();
        }
    }.bind(this);
});

exports.init = A.init;

var ko = require('knockout');

A.prototype.show = function show(state) {
    /*jshint maxcomplexity: 8*/
    Activity.prototype.show.call(this, state);
    
    // reset
    this.viewModel.clientID(0);

    // params
    var params = state && state.route && state.route.segments || [];
    
    var clientID = params[0] |0;
    
    if (clientID) {
        this.viewModel.clientID(clientID);
        
        /*this.viewModel.client.sync(clientID)
        .catch(function (err) {
            this.app.modals.showError({
                title: 'Error loading client data',
                error: err
            });
        }.bind(this));*/

        this.app.model.customers.createItemVersion(clientID)
        .then(function (clientVersion) {
            if (clientVersion) {
                this.viewModel.clientVersion(clientVersion);
                this.viewModel.header('Edit Client');
            } else {
                this.viewModel.clientVersion(null);
                this.viewModel.header('Unknow client or was deleted');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'Error loading client data',
                error: err
            });
        }.bind(this));
    }
    else {
        
        // Check request parameters that allow preset customer information
        // (used when the customer is created based on an existent marketplace user)
        var presetData = this.requestData.presetData || {};
        // If there is not set an explicit 'false' value on editable
        // field (as when there is not data given), set to true so can be edited
        // NOTE: This is because a given marketplace user will come with editable:false
        // and need to be preserved, while on regular 'new client' all data is set by 
        // the freelancer.
        if (presetData.editable !== false) {
            presetData.editable = true;
        }

        /*this.viewModel.client.newItem(presetData);*/
        // New client
        this.viewModel.clientVersion(this.app.model.customers.newItem(presetData));
        this.viewModel.header('Add a Client');
        
        // Extra preset data
        if (this.requestData.newForSearchText) {
            clientDataFromSearchText(this.requestData.newForSearchText || '', this.viewModel.client());
        }
    }
};

/**
    Small utility that just returns true if the given
    string seems a possible phone number, false otherwise.
    NOTE: Is NOT an exaustive phone validation check, just
    checks is there are several numbers so there is a chance
    to be a phone. There are stricker checks (annotated) but
    can fail on some situations (switchboard numbers) or in
    different locales.
**/
function seemsAPhoneNumber(str) {
    // Possible stricker comparision
    // return is.nanpPhone(str) || is.eppPhone(str);
    
    // Just if there are more than three consecutive numbers,
    // then 'may' be a phone number (may be anything else, but
    // since some special phone numbers can have letters or signs,
    // this is just a very lax and conservative (to avoid false negatives) check.
    return (/\d{3,}/).test(str || '');
}

/**
    Use the provided search text as the initial value
    for: name, email or phone (what fits better)
**/
function clientDataFromSearchText(txt, client) {
    if (is.email(txt)) {
        client.email(txt);
    }
    else if (seemsAPhoneNumber(txt)) {
        client.phone(txt);
    }
    else {
        // Otherwise, think is the fullname, spliting by white space
        var nameParts = txt.split(' ', 2);
        client.firstName(nameParts[0]);
        if (nameParts.length > 1) {
            client.lastName(nameParts[1]);
            // TODO For spanish (or any locale with secondLastName)
            // must try to detect the second last name?
        }
    }
}

function ViewModel(app) {
    /*jshint maxstatements:80 */
    
    this.clientID = ko.observable(0);
    
    this.clientVersion = ko.observable(null);
    this.client = ko.pureComputed(function() {
        var v = this.clientVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    //this.client = app.model.customers.createWildcardItem();

    this.header = ko.observable('');
    
    this.isLoading = app.model.customers.state.isLoading;
    this.isSyncing = app.model.customers.state.isSyncing;
    this.isSaving = app.model.customers.state.isSaving;
    this.isLocked = ko.pureComputed(function() {
        return (
            app.model.customers.state.isLocked() ||
            this.isDeleting()
        );
    }, this);
    this.isReadOnly = ko.pureComputed(function() {
        var c = this.client();
        return c && !c.editable();
    }, this);

    this.isDeleting = app.model.customers.state.isDeleting;

    this.wasRemoved = ko.observable(false);

    this.isNew = ko.pureComputed(function() {
        var c = this.client();
        return !c || !c.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.clientVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    this.isNew() ?
                        'Add client' :
                        v && v.areDifferent() ?
                            'Save changes' :
                            'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.clientVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {

        app.model.customers.setItem(this.client().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.client().model.updateWith(serverData);
            // Push version so it appears as saved
            this.clientVersion().push({ evenIfObsolete: true });
          
            // Special save, function provided by the activity on set-up
            this.onSave(serverData.customerUserID);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        app.modals.confirm({
            title: 'Delete client',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.customers.delItem(this.clientID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    // Birth month day
    // TODO l10n
    this.months = ko.observableArray([
        { id: 1, name: 'January'},
        { id: 2, name: 'February'},
        { id: 3, name: 'March'},
        { id: 4, name: 'April'},
        { id: 5, name: 'May'},
        { id: 6, name: 'June'},
        { id: 7, name: 'July'},
        { id: 8, name: 'August'},
        { id: 9, name: 'September'},
        { id: 10, name: 'October'},
        { id: 11, name: 'November'},
        { id: 12, name: 'December'}
    ]);
    // We need to use a special observable in the form, that will
    // update the back-end profile.birthMonth
    this.selectedBirthMonth = ko.computed({
        read: function() {
            var c = this.client();
            if (c) {
                var birthMonth = c.birthMonth();
                return birthMonth ? this.months()[birthMonth - 1] : null;
            }
            return null;
        },
        write: function(month) {
            var c = this.client();
            if (c)
                c.birthMonth(month && month.id || null);
        },
        owner: this
    });
    
    this.monthDays = ko.observableArray([]);
    for (var iday = 1; iday <= 31; iday++) {
        this.monthDays.push(iday);
    }
    
    // Extra for button addons
    this.validEmail = ko.pureComputed(function() {
        var c = this.client();
        if (c) {
            var e = c.email();
            return is.email(e) ? e : '';
        }
        return '';
    }, this);

    this.validPhone = ko.pureComputed(function() {
        var c = this.client();
        if (c) {
            var e = c.phone();
            return seemsAPhoneNumber(e) ? e : '';
        }
        return '';
    }, this);
    
    // Public Search
    
    var foundPublicUser = function foundPublicUser(user) {
        // Only if still matches current view data
        var c = this.client();
        if (!c) return;
        
        // Don't offer if is already that user!
        if (c.customerUserID() === user.customerUserID) return;
        
        // NOTE: avoiding use fullName because it can make more than one conflicting
        // results, being not enough the name to confirm the user (use the search for that)
        //  c.fullName() === user.fullName ||
        if (c.email() === user.email ||
            c.phone() === user.phone) {

            // Notify user
            var msg = 'We`ve found an existing record for {0}. Would you like to add him to your clients?'.replace(/\{0\}/g, user.firstName);
            app.modals.confirm({
                title: 'Customer found at loconomics.com',
                message: msg
            })
            .then(function() {
                // Acepted
                // Replace current user data
                // but keep notesAboutCustomer
                var notes = c.notesAboutCustomer();
                c.model.updateWith(user);
                c.notesAboutCustomer(notes);
                this.clientID(user.customerUserID);
            }.bind(this))
            .catch(function() {
                // Discarded, do nothing
            });
        }
        
    }.bind(this);
    
    // When filering has no results:
    ko.computed(function() {
        var c = this.client();
        if (!c) return;
        
        // NOTE: discarded the fullName because several results can be retrieved,
        // better use the search for that and double check entries
        
        var email = c.email(),
            //fullName = c.fullName(),
            phone = c.phone();
        if (!email && !phone /*!fullName && */) return;

        app.model.customers.publicSearch({
            //fullName: fullName,
            email: email,
            phone: phone
        })
        .then(function(r) {
            if (r && r[0]) foundPublicUser(r[0]);
        }.bind(this))
        .catch(function() {
            // Doesn't matters
        });
    }, this)
    // Avoid excessive request by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 400, method: 'notifyWhenChangesStop' } });
}

},{"../components/Activity":45,"is_js":false,"knockout":false}],10:[function(require,module,exports){
/**
    clients activity
**/
'use strict';

var $ = require('jquery'),
    ko = require('knockout'),
    Activity = require('../components/Activity'),
    textSearch = require('../utils/textSearch');

var A = Activity.extends(function ClientsActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);    
    this.navBar = Activity.createSubsectionNavBar('Clients', {
        backLink: 'cms'
    });
    
    // Getting elements
    this.$index = this.$activity.find('#clientsIndex');
    this.$listView = this.$activity.find('#clientsListView');
    
    // Handler to update header based on a mode change:
    this.registerHandler({
        target: this.viewModel.isSelectionMode,
        handler: function (itIs) {
            this.viewModel.headerText(itIs ? 'Select a client' : '');
        }.bind(this)
    });

    // Handler to go back with the selected client when 
    // there is one selected and requestData is for
    // 'select mode'
    this.registerHandler({
        target: this.viewModel.selectedClient,
        handler: function (theSelectedClient) {
            // We have a request and
            // it requested to select a client,
            // and a selected client
            if (this.requestData &&
                this.requestData.selectClient === true &&
                theSelectedClient) {

                // Pass the selected client in the info
                this.requestData.selectedClientID = theSelectedClient.customerUserID();
                // And go back
                this.app.shell.goBack(this.requestData);
                // Last, clear requestData
                this.requestData = null;
            }
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // On every show, search gets reseted
    this.viewModel.searchText('');
    this.viewModel.requestData = this.requestData;
    
    // Check if it comes from a clientEditor that
    // received the flag 'returnNewAsSelected' and a 
    // clientID: we were in selection mode->creating client->must
    // return the just created client to the previous page
    if (state.returnNewAsSelected === true &&
        state.clientID) {
        
        // perform an activity change but allow the current
        // to stop first
        setTimeout(function() {
            this.requestData.selectedClientID = state.clientID;
            // And go back
            this.app.shell.goBack(this.requestData);
        }.bind(this), 1);
        
        // avoid the rest operations
        return;
    }
    
    // Set selection:
    this.viewModel.isSelectionMode(state.selectClient === true);
    
    // Keep data updated:
    this.app.model.customers.sync()
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading the clients list',
            error: err
        });
    }.bind(this));
};

function ViewModel(app) {

    this.headerText = ko.observable('');

    // Especial mode when instead of pick and edit we are just selecting
    // (when editing an appointment)
    this.isSelectionMode = ko.observable(false);

    // Full list of clients
    this.clients = app.model.customers.list;
    this.isLoading = app.model.customers.state.isLoading;
    this.isSyncing = app.model.customers.state.isSyncing;
    
    // Search text, used to filter 'clients'
    this.searchText = ko.observable('');
    
    // Utility to get a filtered list of clients based on clients
    this.getFilteredList = function getFilteredList() {
        var s = (this.searchText() || '').toLowerCase();
        // Search the client by:
        // - full name
        // - (else) email
        // - (else) phone
        return this.clients().filter(function(client) {
            if (!client) return false;
            var found = textSearch(s, client.fullName());
            if (found) return true;
            found = textSearch(s, client.email());
            if (found) return true;
            found = textSearch(s, client.phone());
            return found;
        });
    };

    // Filtered list of clients
    this.filteredClients = ko.computed(function() {
        return this.getFilteredList();
    }, this);
    
    // Grouped list of filtered clients
    this.groupedClients = ko.computed(function(){

        var clients = this.filteredClients().sort(function(clientA, clientB) {
            return clientA.firstName().toLowerCase() > clientB.firstName().toLowerCase();
        });
        
        var groups = [],
            latestGroup = null,
            latestLetter = null;

        clients.forEach(function(client) {
            var letter = (client.firstName()[0] || '').toUpperCase();
            if (letter !== latestLetter) {
                latestGroup = {
                    letter: letter,
                    clients: [client]
                };
                groups.push(latestGroup);
                latestLetter = letter;
            }
            else {
                latestGroup.clients.push(client);
            }
        });

        return groups;

    }, this);
    
    
    /// Public search
    this.publicSearchResults = ko.observableArray([]);
    this.publicSearchRunning = ko.observable(null);
    // When filering has no results:
    ko.computed(function() {    
        var filtered = this.filteredClients(),
            searchText = this.searchText(),
            request = null;

        // If there is search text and no results from local filtering
        if (filtered.length === 0 && searchText) {
            
            // Remove previous results
            this.publicSearchResults([]);
            
            request = app.model.customers.publicSearch({
                fullName: searchText,
                email: searchText,
                phone: searchText
            });
            this.publicSearchRunning(request);
            request.then(function(r) {
                this.publicSearchResults(r);
            }.bind(this))
            .catch(function(err) {
                app.modals.showError({
                    title: 'There was an error when on remote clients search',
                    error: err
                });
            })
            .then(function() {
                // Always:
                // if still the same, it ended then remove
                if (this.publicSearchRunning() === request)
                    this.publicSearchRunning(null);
            }.bind(this));
        }
        else {
            this.publicSearchResults([]);
            // Cancelling any pending request, to avoid
            // anwanted results when finish
            request = this.publicSearchRunning();
            if (request &&
                request.xhr &&
                request.xhr.abort) {
                request.xhr.abort();
                this.publicSearchRunning(null);
            }
        }
    }, this)
    // Avoid excessive request by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 400, method: 'notifyWhenChangesStop' } });
    
    /**
        Add a client from the public/remote search results
    **/
    this.addRemoteClient = function(client) {
        var data = client.model && client.model.toPlainObject() || client;
        var request = $.extend({}, this.requestData, {
            presetData: data,
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go('clientEditor', request);
        return false;
    }.bind(this);
    
    /**
        Call the activity to add a new client, passing the current
        search text so can be used as initial name/email/phone
    **/
    this.addNew = function() {
        var request = $.extend({}, this.requestData, {
            newForSearchText: this.searchText(),
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go('clientEditor', request);
        return false;
    }.bind(this);

    /// Selections
    
    this.selectedClient = ko.observable(null);
    
    this.selectClient = function(selectedClient) {
        
        this.selectedClient(selectedClient);
    }.bind(this);
}

},{"../components/Activity":45,"../utils/textSearch":112,"knockout":false}],11:[function(require,module,exports){
/**
    CMS activity
    (Client Management System)
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function CmsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Client management');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Keep data updated:
    this.app.model.customers.sync()
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading the clients list',
            error: err
        });
    }.bind(this));
};

var numeral = require('numeral');

function ViewModel(app) {
    
    this.clients = app.model.customers.list;

    this.clientsCount = ko.pureComputed(function() {
        var cs = this.clients();
        
        if (cs <= 0)
            return '0 clients';
        else if (cs === 1)
            return '1 client';
        else
            return numeral(cs.length |0).format('0,0') + ' clients';
    }, this);
}

},{"../components/Activity":45,"knockout":false,"numeral":false}],12:[function(require,module,exports){
/**
    ContactForm activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function ContactFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel();
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
});

exports.init = A.init;

var ko = require('knockout');
function ViewModel() {
    
    this.message = ko.observable('');
    this.wasSent = ko.observable(false);

    var updateWasSent = function() {
        this.wasSent(false);
    }.bind(this);
    this.message.subscribe(updateWasSent);
    
    this.send = function send() {
        // TODO: Send
        
        // Reset after being sent
        this.message('');
        this.wasSent(true);

    }.bind(this);
}

},{"../components/Activity":45,"knockout":false}],13:[function(require,module,exports){
/**
    ContactInfo activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function ContactInfoActivity() {
    
    Activity.apply(this, arguments);

    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Owner information', {
        backLink: 'ownerInfo'
    });
    
    // Update navBar for onboarding mode when the onboardingStep
    // in the current model changes:
    this.registerHandler({
        target: this.viewModel.profile.onboardingStep,
        handler: function (step) {
            if (step) {
                // TODO Set navbar step index
                // Setting navbar for Onboarding/wizard mode
                this.navBar.leftAction().text('');
                // Setting header
                this.viewModel.headerText('How can we reach you?');
                this.viewModel.buttonText('Save and continue');
            }
            else {
                // TODO Remove step index
                // Setting navbar to default
                this.navBar.leftAction().text('Account');
                // Setting header to default
                this.viewModel.headerText('Contact information');
                this.viewModel.buttonText('Save');
            }
        }.bind(this)
    });
    //this.viewModel.profile.onboardingStep.subscribe();
    
    this.registerHandler({
        target: this.app.model.userProfile,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving contact data.' : 'Error loading contact data.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
    
    this.registerHandler({
        target: this.app.model.homeAddress,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving address details.' : 'Error loading address details.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
    
    // On change to a valid code, do remote look-up
    // NOTE: using directly a computed rather than the registerHandler to use
    // the rateLimit extender that avoids excesive request being performed on changes.
    // NOTE: the code inside the handler is mostly the same as in addressEditor for the same look-up.
    var app = this.app,
        viewModel = this.viewModel;
    ko.computed(function() {
        var postalCode = this.postalCode(),
            address = this;

        if (postalCode && !/^\s*$/.test(postalCode)) {
            app.model.postalCodes.getItem(postalCode)
            .then(function(info) {
                if (info) {
                    address.city(info.city);
                    address.stateProvinceCode(info.stateProvinceCode);
                    address.stateProvinceName(info.stateProvinceName);
                    viewModel.errorMessages.postalCode('');
                }
            })
            .catch(function(err) {
                address.city('');
                address.stateProvinceCode('');
                address.stateProvinceName('');
                // Expected errors, a single message, set
                // on the observable
                var msg = typeof(err) === 'string' ? err : null;
                if (msg || err && err.responseJSON && err.responseJSON.errorMessage) {
                    viewModel.errorMessages.postalCode(msg || err.responseJSON.errorMessage);
                }
                else {
                    // Log to console for debugging purposes, on regular use an error on the
                    // postal code is not critical and can be transparent; if there are 
                    // connectivity or authentification errors will throw on saving the address
                    console.error('Server error validating Zip Code', err);
                }
            });
        }
    }, this.viewModel.address)
    // Avoid excessive requests by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 200, method: 'notifyWhenChangesStop' } });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Discard any previous unsaved edit
    this.viewModel.discard();
    
    // Keep data updated:
    this.app.model.userProfile.sync();
    this.app.model.homeAddress.sync();
};

var ko = require('knockout');

function ViewModel(app) {

    this.headerText = ko.observable('Contact information');
    this.buttonText = ko.observable('Save');
    
    // List of possible error messages registered
    // by name
    this.errorMessages = {
        postalCode: ko.observable('')
    };
    
    // User Profile
    var userProfile = app.model.userProfile;
    var profileVersion = userProfile.newVersion();
    profileVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            profileVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.profile = profileVersion.version;
    
    // TODO l10n
    this.months = ko.observableArray([
        { id: 1, name: 'January'},
        { id: 2, name: 'February'},
        { id: 3, name: 'March'},
        { id: 4, name: 'April'},
        { id: 5, name: 'May'},
        { id: 6, name: 'June'},
        { id: 7, name: 'July'},
        { id: 8, name: 'August'},
        { id: 9, name: 'September'},
        { id: 10, name: 'October'},
        { id: 11, name: 'November'},
        { id: 12, name: 'December'}
    ]);
    // We need to use a special observable in the form, that will
    // update the back-end profile.birthMonth
    this.selectedBirthMonth = ko.computed({
        read: function() {
            var birthMonth = this.profile.birthMonth();
            return birthMonth ? this.months()[birthMonth - 1] : null;
        },
        write: function(month) {
            this.profile.birthMonth(month && month.id || null);
        },
        owner: this
    });
    
    this.monthDays = ko.observableArray([]);
    for (var iday = 1; iday <= 31; iday++) {
        this.monthDays.push(iday);
    }
    
    // Home Address
    var homeAddress = app.model.homeAddress;
    var homeAddressVersion = homeAddress.newVersion();
    homeAddressVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            homeAddressVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.address = homeAddressVersion.version;

    // Control observables: special because must a mix
    // of the both remote models used in this viewmodel
    this.isLocked = ko.computed(function() {
        return userProfile.isLocked() || homeAddress.isLocked();
    }, this);
    this.isLoading = ko.computed(function() {
        return userProfile.isLoading() || homeAddress.isLoading();
    }, this);
    this.isSaving = ko.computed(function() {
        return userProfile.isSaving() || homeAddress.isSaving();
    }, this);

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, this);
    
    // Actions

    this.discard = function discard() {
        profileVersion.pull({ evenIfNewer: true });
        homeAddressVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        // Force to save, even if there was remote updates
        profileVersion.push({ evenIfObsolete: true });
        homeAddressVersion.push({ evenIfObsolete: true });
        
        app.successSave();
    }.bind(this);
}

},{"../components/Activity":45,"knockout":false}],14:[function(require,module,exports){
/**
    Conversation activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function ConversationActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Inbox', {
        backLink: 'inbox'
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Reset
    this.viewModel.threadID(0);
    this.viewModel.thread(null);

    // Params
    var params = state && state.route && state.route.segments || [],
        threadID = params[0] |0;

    this.viewModel.threadID(threadID);
    
    // Load the data
    if (threadID) {
        this.viewModel.thread.sync(threadID)
        .catch(function(err) {
            this.app.modals.showError({
                title: 'Error loading conversation',
                error: err
            }).then(function() {
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));
    }
    else {
        this.app.modals.showError({
            title: 'Conversation Not Found'
        }).then(function() {
            this.app.shell.goBack();
        }.bind(this));
    }
};

var ko = require('knockout');

function ViewModel(app) {

    this.isLoading = app.model.messaging.state.isLoading;
    this.isSyncing = app.model.messaging.state.isSyncing;
    this.isSaving = app.model.messaging.state.isSaving;

    this.threadID = ko.observable(null);
    this.thread = app.model.messaging.createWildcardItem();

    this.subject = ko.pureComputed(function() {
        var m = this.thread();
        return (
            this.isLoading() ?
                'Loading...' :
                m && (m.subject() || '').replace(/^\s+|\s+$/g, '') || 'Conversation without subject'
        );
    }, this);
    
    // If the last message reference a booking, is
    // accessed with:
    this.bookingID = ko.pureComputed(function() {
        var msg = this.thread() && this.thread().messages()[0];
        if (msg &&
            (msg.auxT() || '').toLowerCase() === 'booking' &&
            msg.auxID()) {
            return msg.auxID();
        }
        else {
            return null;
        }
    }, this);
}

},{"../components/Activity":45,"knockout":false}],15:[function(require,module,exports){
/**
    datetimePicker activity
**/
'use strict';

var moment = require('moment'),
    ko = require('knockout'),
    Time = require('../utils/Time');
require('../components/DatePicker');

var Activity = require('../components/Activity');

var A = Activity.extends(function DatetimePickerActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('');
    
    // Getting elements
    this.$datePicker = this.$activity.find('#datetimePickerDatePicker');
    this.$timePicker = this.$activity.find('#datetimePickerTimePicker');
    
    /* Init components */
    this.$datePicker.show().datepicker();
    
    this.registerHandler({
        target: this.$datePicker,
        event: 'changeDate',
        handler: function(e) {
            if (e.viewMode === 'days') {
                this.viewModel.selectedDate(e.date);
            }
        }.bind(this)
    });
    
    this.registerHandler({
        target: this.viewModel.selectedDate,
        handler: function(date) {
            this.bindDateData(date);
        }.bind(this)
    });
    
    // Handler to go back with the selected date-time when
    // that selection is done (could be to null)
    this.registerHandler({
        target: this.viewModel.selectedDatetime,
        handler: function (datetime) {
            if (!this.requestData ||
                !datetime) {
                return;
            }
            // Pass the selected datetime in the info
            this.requestData.selectedDatetime = datetime;
            // And go back
            this.app.shell.goBack(this.requestData);
            // Last, clear requestData
            this.requestData = null;
        }.bind(this)
    });
    
    // TestingData
    this.viewModel.slotsData = require('../testdata/timeSlots').timeSlots;
    
    this.bindDateData(new Date());
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    var header = this.requestData.headerText;
    this.viewModel.headerText(header || 'Select date and time');
};

A.prototype.bindDateData = function bindDateData(date) {

    var sdate = moment(date).format('YYYY-MM-DD');
    var slotsData = this.viewModel.slotsData;

    if (slotsData.hasOwnProperty(sdate)) {
        this.viewModel.slots(slotsData[sdate]);
    } else {
        this.viewModel.slots(slotsData['default']);
    }
};

function ViewModel() {

    this.headerText = ko.observable('Select a time');
    this.selectedDate = ko.observable(new Date());
    this.slotsData = {};
    this.slots = ko.observableArray([]);
    this.groupedSlots = ko.computed(function(){
        /*
          before 12:00pm (noon) = morning
          afternoon: 12:00pm until 5:00pm
          evening: 5:00pm - 11:59pm
        */
        // Since slots must be for the same date,
        // to define the groups ranges use the first date
        var datePart = this.slots() && this.slots()[0] || new Date();
        var groups = [
            {
                group: 'Morning',
                slots: [],
                starts: new Time(datePart, 0, 0),
                ends: new Time(datePart, 12, 0)
            },
            {
                group: 'Afternoon',
                slots: [],
                starts: new Time(datePart, 12, 0),
                ends: new Time(datePart, 17, 0)
            },
            {
                group: 'Evening',
                slots: [],
                starts: new Time(datePart, 17, 0),
                ends: new Time(datePart, 24, 0)
            }
        ];
        // TODO Empty slots must appear with
        // 'empty' message rather than excluded
        var slots = this.slots().sort();
        slots.forEach(function(slot) {
            groups.forEach(function(group) {
                if (slot >= group.starts &&
                    slot < group.ends) {
                    group.slots.push(slot);
                }
            });
        });

        return groups;

    }, this);
    
    this.selectedDatetime = ko.observable(null);
    
    this.selectDatetime = function(selectedDatetime) {
        
        this.selectedDatetime(selectedDatetime);

    }.bind(this);

}

},{"../components/Activity":45,"../components/DatePicker":46,"../testdata/timeSlots":79,"../utils/Time":91,"knockout":false,"moment":false}],16:[function(require,module,exports){
/**
    Faqs activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function FaqsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel();
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
    
    // TestingData
    setSomeTestingData(this.viewModel);
});

exports.init = A.init;

A.prototype.show = function show(state) {
    
    Activity.prototype.show.call(this, state);
    
    this.viewModel.searchText('');
};

var ko = require('knockout');

function ViewModel() {

    this.faqs = ko.observableArray([]);
    this.searchText = ko.observable('');
    
    this.filteredFaqs = ko.pureComputed(function() {
        var s = this.searchText().toLowerCase();
        return this.faqs().filter(function(v) {
            var n = v && v.title() || '';
            n += v && v.description() || '';
            n = n.toLowerCase();
            return n.indexOf(s) > -1;
        });
    }, this);
}

var Model = require('../models/Model');
function Faq(values) {
    
    Model(this);

    this.model.defProperties({
        id: 0,
        title: '',
        description: ''
    }, values);
}

/** TESTING DATA **/
function setSomeTestingData(viewModel) {
    
    var testdata = [
        new Faq({
            id: 1,
            title: 'How do I set up a marketplace profile?',
            description: 'Description about how I set up a marketplace profile'
        }),
        new Faq({
            id: 2,
            title: 'Another faq',
            description: 'Another description'
        })
    ];
    viewModel.faqs(testdata);
}

},{"../components/Activity":45,"../models/Model":66,"knockout":false}],17:[function(require,module,exports){
/**
    Feedback activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function FeedbackActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Talk to us');
});

exports.init = A.init;

},{"../components/Activity":45}],18:[function(require,module,exports){
/**
    FeedbackForm activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function FeedbackFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel();
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
});

exports.init = A.init;

var ko = require('knockout');
function ViewModel() {
    
    this.message = ko.observable('');
    this.becomeCollaborator = ko.observable(false);
    this.wasSent = ko.observable(false);

    var updateWasSent = function() {
        this.wasSent(false);
    }.bind(this);
    this.message.subscribe(updateWasSent);
    this.becomeCollaborator.subscribe(updateWasSent);
    
    this.send = function send() {
        // TODO: Send
        
        // Reset after being sent
        this.message('');
        this.becomeCollaborator(false);
        this.wasSent(true);

    }.bind(this);
}

},{"../components/Activity":45,"knockout":false}],19:[function(require,module,exports){
/**
    Freelancer Pricing activity
**/
'use strict';

var ko = require('knockout'),
    _ = require('lodash'),
    Activity = require('../components/Activity');

var A = Activity.extends(function FreelancerPricingActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Job Title');

    // On changing jobTitleID:
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID and pricing types.
                // They are essential data
                Promise.all([
                    this.app.model.jobTitles.getJobTitle(jobTitleID),
                    this.app.model.pricingTypes.getList()
                ])
                .then(function(data) {
                    var jobTitle = data[0];
                    if (!this.viewModel.isSelectionMode()) {
                        // Fill in job title name
                        this.navBar.leftAction().text(jobTitle.singularName());
                    }
                    // Save for use in the view
                    this.viewModel.jobTitle(jobTitle);

                    // Get pricing
                    return this.app.model.freelancerPricing.getList(jobTitleID);
                }.bind(this))
                .then(function(list) {

                    list = this.app.model.freelancerPricing.asModel(list);
                    
                    // Read presets selection from requestData
                    var preset = this.requestData.selectedPricing || [],
                        selection = this.viewModel.selectedPricing;
                    
                    // Add the isSelected property to each item
                    list.forEach(function(item) {
                        var preSelected = preset.some(function(pr) {
                            if (pr.freelancerPricingID === item.freelancerPricingID())
                                return true;
                        }) || false;
                        
                        item.isSelected = ko.observable(preSelected);
                        
                        if (preSelected) {
                            selection.push(item);
                        }
                    });
                    this.viewModel.list(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.list([]);
                this.viewModel.jobTitle(null);
                this.navBar.leftAction().text('Job Title');
            }
        }.bind(this)
    });
    
    // Handler to update header based on a mode change:
    this.registerHandler({
        target: this.viewModel.isSelectionMode,
        handler: function (itIs) {
            this.viewModel.headerText(itIs ? 'Select services' : 'Services');

            // Update navbar too
            // TODO: Can be other than 'scheduling', like marketplace profile or the job-title?
            this.navBar.leftAction().text(itIs ? 'Booking' : 'Scheduling');

            if (this.requestData.progressStep) {
                // Replace title by process step if required
                this.navBar.title(this.requestData.progressStep);
                this.navBar.leftAction().text('');
            }
            else {
                // Title must be empty
                this.navBar.title('');
            }            
        }.bind(this)
    });

    // Go back with the selected pricing when triggered in the form/view
    this.viewModel.returnSelected = function(pricing, jobTitleID) {
        // Pass the selected client in the info
        this.requestData.selectedPricing = pricing;
        this.requestData.selectedJobTitleID = jobTitleID;
        // And go back
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);
    this.viewModel.isSelectionMode(false);
    this.viewModel.selectedPricing.removeAll();

    if (this.requestData.selectPricing === true) {
        this.viewModel.isSelectionMode(true);
    }
    
    // Params
    var params = options && options.route && options.route.segments;
    var jobTitleID = params[0] |0;
    
    this.viewModel.jobTitleID(jobTitleID);
    
    if (jobTitleID === 0) {
        this.viewModel.jobTitles.sync();
    }
};

var UserJobProfile = require('../viewmodels/UserJobProfile');

function ViewModel(app) {

    this.headerText = ko.observable('Services');
    
    this.jobTitleID = ko.observable(0);
    this.jobTitle = ko.observable(null);
    
    this.jobTitles = new UserJobProfile(app);
    this.jobTitles.baseUrl('/freelancerPricing');
    this.jobTitles.selectJobTitle = function(jobTitle) {
        
        this.jobTitleID(jobTitle.jobTitleID());
        
        return false;
    }.bind(this);

    this.list = ko.observableArray([]);

    this.isLoading = ko.computed(function() {
        return (
            app.model.freelancerPricing.state.isLoading() ||
            app.model.pricingTypes.state.isLoading() ||
            app.model.jobTitles.state.isLoading()
        );
    });
    this.isLocked = this.isLoading;

    // Especial mode when instead of pick and edit we are just selecting
    this.isSelectionMode = ko.observable(false);

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSelectionMode() ? 
                    'Save and continue' :
                    ''
        );
    }, this);
    
    // Grouped list of pricings:
    // Defined groups by pricing type
    this.groupedPricing = ko.computed(function(){

        var list = this.list();
        var isSelection = this.isSelectionMode();
        var groupNamePrefix = isSelection ? 'Select ' : '';

        var groups = _.groupBy(list, function(pricingItem) {
            return pricingItem.pricingTypeID();
        });
        
        // Convert the indexed object into an array with some meta-data
        var groupsList = Object.keys(groups).map(function(key) {
            var gr = {
                pricing: groups[key],
                // Load the pricing information
                type: app.model.pricingTypes.getObservableItem(key)
            };
            gr.group = ko.computed(function() {
                return groupNamePrefix + (
                    this.type() && this.type().pluralName() ||
                    'Services'
                );
            }, gr);
            return gr;
        });
        
        // Since the groupsList is built from the existent pricing items
        // if there are no records for some pricing type (or nothing when
        // just created the job title), that types/groups are not included,
        // so review and include now.
        // NOTE: as a good side effect of this approach, pricing types with
        // some pricing will appear first in the list (nearest to the top)
        var pricingTypes = this.jobTitle() && this.jobTitle().pricingTypes();
        if (pricingTypes && pricingTypes.length) {
            pricingTypes.forEach(function (jobType) {
                
                var typeID = jobType.pricingTypeID();
                // Not if already in the list
                if (groups.hasOwnProperty(typeID))
                    return;

                var gr = {
                    pricing: [],
                    type: app.model.pricingTypes.getObservableItem(typeID)
                };
                gr.group = ko.computed(function() {
                    return groupNamePrefix + (
                        this.type() && this.type().pluralName() ||
                        'Services'
                    );
                }, gr);

                groupsList.push(gr);
            });
        }

        return groupsList;

    }, this);

    this.selectedPricing = ko.observableArray([]);
    /**
        Toggle the selection status of a pricing, adding
        or removing it from the 'selectedPricing' array.
    **/
    this.togglePricingSelection = function(pricing) {

        var inIndex = -1,
            isSelected = this.selectedPricing().some(function(selectedPricing, index) {
            if (selectedPricing === pricing) {
                inIndex = index;
                return true;
            }
        });

        pricing.isSelected(!isSelected);

        if (isSelected)
            this.selectedPricing.splice(inIndex, 1);
        else
            this.selectedPricing.push(pricing);

    }.bind(this);
    
    /**
        Ends the selection process, ready to collect selection
        and passing it to the requester activity
    **/
    this.endSelection = function() {
        
        this.isSelectionMode(false);
        // Run method injected by the activity to return a 
        // selected address:
        this.returnSelected(
            this.selectedPricing().map(function(pricing) {
                return {
                    freelancerPricingID: ko.unwrap(pricing.freelancerPricingID),
                    totalPrice: ko.unwrap(pricing.price)
                };
            }),
            this.jobTitleID()
        );
    }.bind(this);
    
    this.editPricing = function(pricing) {
        app.shell.go('freelancerPricingEditor/' + this.jobTitleID() + '/' + pricing.freelancerPricingID());
    }.bind(this);
    
    /**
        Handler for the listview items, managing edition and selection depending on current mode
    **/
    this.tapPricing = function(pricing) {
        if (this.isSelectionMode()) {
            this.togglePricingSelection(pricing);
        }
        else {
            this.editPricing(pricing);
        }
    }.bind(this);
}

},{"../components/Activity":45,"../viewmodels/UserJobProfile":139,"knockout":false,"lodash":false}],20:[function(require,module,exports){
/**
    FreelancerPricingEditor activity
    
    TODO: ModelVersion is NOT being used, so no getting updates if server updates
    the data after load (data load is requested but get first from cache). Use
    version and get sync'ed data when ready, and additionally notification to
    override changes if server data is different that any local change.
**/
'use strict';
var ko = require('knockout'),
    Activity = require('../components/Activity'),
    PricingType = require('../models/PricingType');

var A = Activity.extends(function FreelancerPricingEditorActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Services');
});

exports.init = A.init;

A.prototype.show = function show(options) {
    //jshint maxcomplexity:10    
    Activity.prototype.show.call(this, options);

    // Reset
    this.viewModel.wasRemoved(false);
    this.viewModel.freelancerPricingVersion(null);
    this.viewModel.pricingType(null);

    // Params
    var params = options && options.route && options.route.segments || [];

    var jobTitleID = params[0] |0,
        // Parameter [1] can be 'new' followed by a pricingTypeID as [2]
        pricingTypeID = params[1] === 'new' ? params[2] |0 : 0,
        // Or a pricingID
        freelancerPricingID = params[1] |0;

    this.viewModel.jobTitleID(jobTitleID);
    this.viewModel.freelancerPricingID(freelancerPricingID);
    
    /**
        The pricing record needs some special set-up after creation/loading and before
        being presented to the user, because special value-rules.
    **/
    var pricingSetup = function pricingSetup() {
        // Pricing fields that has a special initial value
        var c = this.viewModel.current();
        if (c) {
            // Name: must be the PricingType.fixedName ever if any, or
            //   the name saved in the pricing or
            //   the suggestedName as last fallback
            c.pricing.name(c.type.fixedName() || c.pricing.name() || c.type.suggestedName());
            // Required call after loading a pricing to reflect data correctly (cannot be automated)
            c.pricing.refreshNoPriceRate();
        }
        this.viewModel.isLoading(false);
    }.bind(this);
    
    var showInvalidRequestError = function() {
        this.viewModel.isLoading(false);
        this.app.modals.showError({
            title: 'Invalid request',
            error: { jobTitleID: jobTitleID, pricingTypeID: pricingTypeID, freelancerPricingID: freelancerPricingID }
        })
        .then(function() {
            // On close modal, go back
            this.app.shell.goBack();
        }.bind(this));
    }.bind(this);

    this.viewModel.isLoading(true);
    if (pricingTypeID) {
        // Load the pricing Type
        this.app.model.pricingTypes.getItem(pricingTypeID)
        .then(function(type) {
            if (type) {
                this.viewModel.pricingType(type);
                // New pricing
                this.viewModel.freelancerPricingVersion(this.app.model.freelancerPricing.newItemVersion({
                    jobTitleID: jobTitleID,
                    pricingTypeID: pricingTypeID
                }));
                pricingSetup();
            }
            else {
                showInvalidRequestError();
            }
        }.bind(this));
    }
    else if (freelancerPricingID) {
        // Get the pricing
        this.app.model.freelancerPricing.getItemVersion(jobTitleID, freelancerPricingID)
        .then(function (freelancerPricingVersion) {
            if (freelancerPricingVersion) {
                // Load the pricing type before put the version
                // returns to let the 'catch' to get any error
                return this.app.model.pricingTypes.getItem(freelancerPricingVersion.version.pricingTypeID())
                .then(function(type) {
                    if (type) {
                        this.viewModel.pricingType(type);
                        this.viewModel.freelancerPricingVersion(freelancerPricingVersion);
                        pricingSetup();
                    }
                    else {
                        showInvalidRequestError();
                    }
                }.bind(this));
            } else {
                showInvalidRequestError();
            }

        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            })
            .then(function() {
                // On close modal, go back
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));
    }
    else {
        showInvalidRequestError();
    }
};

function ViewModel(app) {
    /*jshint maxstatements: 35*/

    this.isLoading = ko.observable(false);
    // managed manually instead of
    //app.model.freelancerPricing.state.isLoading;
    this.isSaving = app.model.freelancerPricing.state.isSaving;
    this.isSyncing = app.model.freelancerPricing.state.isSyncing;
    this.isDeleting = app.model.freelancerPricing.state.isDeleting;
    this.jobTitleID = ko.observable(0);
    this.freelancerPricingID = ko.observable(0);
    // L10N
    this.moneySymbol = ko.observable('$');
    
    this.pricingType = ko.observable(new PricingType());

    this.freelancerPricingVersion = ko.observable(null);
    this.freelancerPricing = ko.pureComputed(function() {
        var v = this.freelancerPricingVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);

    this.header = ko.pureComputed(function() {
        if (this.isLoading()) {
            return 'Loading...';
        }
        else if (this.freelancerPricingVersion()) {
            var t = this.pricingType();
            return t && t.singularName() || 'Service';
        }
        else {
            return 'Unknow service or was deleted';
        }

    }, this);
    
    // Quicker access in form, under a 'with'
    this.current = ko.pureComputed(function() {
        var t = this.pricingType(),
            p = this.freelancerPricing();
        
        if (t && p) {
            return {
                type: t,
                pricing: p
            };
        }
        return null;
    }, this);

    this.wasRemoved = ko.observable(false);
    
    this.isLocked = ko.computed(function() {
        return this.isDeleting() || app.model.freelancerPricing.state.isLocked();
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        var p = this.freelancerPricing();
        return p && !p.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.freelancerPricingVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        'Save changes' :
                        'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.freelancerPricingVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {
        
        app.model.freelancerPricing.setItem(this.freelancerPricing().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.freelancerPricing().model.updateWith(serverData);
            // Push version so it appears as saved
            this.freelancerPricingVersion().push({ evenIfObsolete: true });
            
            // On save, auto go back
            // NOTE: if auto go back is disabled, the URL must update to match the new ID
            app.successSave();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        // TODO Better l10n or replace by a new preset field on pricingType.deleteLabel
        var p = this.pricingType();
        app.modals.confirm({
            title: 'Delete ' + (p && p.singularName()),
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.freelancerPricing.delItem(this.jobTitleID(), this.freelancerPricingID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
}

},{"../components/Activity":45,"../models/PricingType":71,"knockout":false}],21:[function(require,module,exports){
/**
    Home activity
**/
'use strict';

var ko = require('knockout');

var Activity = require('../components/Activity');

var A = Activity.extends(function HomeActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
    
    // Getting elements
    this.$nextBooking = this.$activity.find('#homeNextBooking');
    this.$upcomingBookings = this.$activity.find('#homeUpcomingBookings');
    this.$inbox = this.$activity.find('#homeInbox');
    this.$performance = this.$activity.find('#homePerformance');
    this.$getMore = this.$activity.find('#homeGetMore');
    
    // TestingData
    setSomeTestingData(this.viewModel);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    var v = this.viewModel,
        appModel = this.app.model;
    
    var preapareShowErrorFor = function preapareShowErrorFor(title) {
        return function(err) {
            this.app.modals.showError({
                title: title,
                error: err
            });
        }.bind(this);
    }.bind(this);
    
    // Update data
    if (v.upcomingBookings.items().length) {
        v.upcomingBookings.isSyncing(true);
    }
    else {
        v.upcomingBookings.isLoading(true);
    }
    appModel.bookings.getUpcomingBookings()
    .then(function(upcoming) {

        if (upcoming.nextBookingID) {
            var previousID = v.nextBooking() && v.nextBooking().sourceBooking().bookingID();
            if (upcoming.nextBookingID !== previousID) {
                if (v.nextBooking()) {
                    v.nextBooking.isSyncing(true);
                }
                else {
                    v.nextBooking.isLoading(true);
                }
                appModel.appointments.getAppointment({ bookingID: upcoming.nextBookingID })
                .then(function(apt) {
                    v.nextBooking(apt);
                })
                .catch(preapareShowErrorFor('Error loading next booking'))
                .then(function() {
                    // Finally
                    v.nextBooking.isLoading(false);
                    v.nextBooking.isSyncing(false);
                });
            }
        }
        else {
            v.nextBooking(null);
        }

        v.upcomingBookings.today.quantity(upcoming.today.quantity);
        v.upcomingBookings.today.time(upcoming.today.time && new Date(upcoming.today.time));
        v.upcomingBookings.tomorrow.quantity(upcoming.tomorrow.quantity);
        v.upcomingBookings.tomorrow.time(upcoming.tomorrow.time && new Date(upcoming.tomorrow.time));
        v.upcomingBookings.nextWeek.quantity(upcoming.nextWeek.quantity);
        v.upcomingBookings.nextWeek.time(upcoming.nextWeek.time && new Date(upcoming.nextWeek.time));
    })
    .catch(preapareShowErrorFor('Error loading upcoming bookings'))
    .then(function() {
        // Finally
        v.upcomingBookings.isLoading(false);
        v.upcomingBookings.isSyncing(false);
    });
    
    // Messages
    var MessageView = require('../models/MessageView');
    if (v.inbox.messages().length)
        v.inbox.isSyncing(true);
    else
        v.inbox.isLoading(true);
    appModel.messaging.getList()
    .then(function(threads) {
        v.inbox.messages(threads().map(MessageView.fromThread));
    })
    .catch(preapareShowErrorFor('Error loading latest messages'))
    .then(function() {
        // Finally
        v.inbox.isLoading(false);
        v.inbox.isSyncing(false);
    });
};


var UpcomingBookingsSummary = require('../models/UpcomingBookingsSummary'),
    MailFolder = require('../models/MailFolder'),
    PerformanceSummary = require('../models/PerformanceSummary'),
    GetMore = require('../models/GetMore');

function ViewModel() {

    this.upcomingBookings = new UpcomingBookingsSummary();
    this.upcomingBookings.isLoading = ko.observable(false);
    this.upcomingBookings.isSyncing = ko.observable(false);

    this.nextBooking = ko.observable(null);
    this.nextBooking.isLoading = ko.observable(false);
    this.nextBooking.isSyncing = ko.observable(false);
    
    this.inbox = new MailFolder({
        topNumber: 4
    });
    this.inbox.isLoading = ko.observable(false);
    this.inbox.isSyncing = ko.observable(false);
    
    this.performance = new PerformanceSummary();
    
    this.getMore = new GetMore();
}

/** TESTING DATA **/
function setSomeTestingData(viewModel) {
    
    viewModel.performance.earnings.currentAmount(2400);
    viewModel.performance.earnings.nextAmount(6200.54);
    viewModel.performance.timeBooked.percent(0.93);
    
    viewModel.getMore.model.updateWith({
        availability: true,
        payments: true,
        profile: true,
        coop: true
    });
}

},{"../components/Activity":45,"../models/GetMore":58,"../models/MailFolder":62,"../models/MessageView":65,"../models/PerformanceSummary":67,"../models/UpcomingBookingsSummary":76,"knockout":false}],22:[function(require,module,exports){
/**
    Inbox activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout'),
    MessageView = require('../models/MessageView'),
    textSearch = require('../utils/textSearch');

var A = Activity.extends(function InboxActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Inbox');
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Messages
    this.app.model.messaging.getList()
    .then(function(threads) {
        this.viewModel.sourceThreads(threads());
    }.bind(this))
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading messages',
            error: err
        });
    }.bind(this));
};

function ViewModel(app) {
    
    this.isLoading = app.model.messaging.state.isLoading;
    this.isSyncing = app.model.messaging.state.isSyncing;

    this.sourceThreads = ko.observableArray([]);
    
    this.searchText = ko.observable('');
    
    // NOTE: since current API-connection implementation only gets
    // the latest message with getList, the search is done in the
    // bodyText of the last message (additionally to the thread subject)
    // even if this implementation try to iterate all messages.
    this.threads = ko.pureComputed(function() {
        var t = this.sourceThreads(),
            s = this.searchText();

        if (!t)
            return [];
        else if (!s)
            return t.map(MessageView.fromThread);
        else        
            return t.filter(function(thread) {
                var found = false;
                
                // Check subject
                found = textSearch(s, thread.subject());
                
                if (!found) {
                    // Try content of messages
                    // It stops on first 'true' result
                    thread.messages().some(function(msg) {
                        found = textSearch(s, msg.bodyText());
                        return found;
                    });
                }
                
                return found;
            }).map(MessageView.fromThread);
    }, this);
}

},{"../components/Activity":45,"../models/MessageView":65,"../utils/textSearch":112,"knockout":false}],23:[function(require,module,exports){
/**
    Index activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function IndexActivity() {
    
    Activity.apply(this, arguments);

    // Any user can access this
    this.accessLevel = null;
    
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // It checks if the user is logged so then 
    // their 'logged index' is the dashboard not this
    // page that is focused on anonymous users
    if (!this.app.model.user().isAnonymous()) {
        this.app.goDashboard();
    }
};

},{"../components/Activity":45}],24:[function(require,module,exports){
/**
    Jobtitles activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout');

var A = Activity.extends(function JobtitlesActivity() {
    
    Activity.apply(this, arguments);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Scheduling');
    
    // On changing jobTitleID:
    // - load addresses
    // - load job title information
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {

            if (jobTitleID) {
                ////////////
                // Addresses
                this.app.model.serviceAddresses.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.serviceAddresses.asModel(list);
                    this.viewModel.addresses(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading addresses.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Pricing/Services
                this.app.model.freelancerPricing.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.freelancerPricing.asModel(list);
                    this.viewModel.pricing(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading services.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Job Title
                // Get data for the Job title ID
                this.app.model.jobTitles.getJobTitle(jobTitleID)
                .then(function(jobTitle) {

                    // Fill in job title name
                    this.viewModel.jobTitleName(jobTitle.singularName());
                }.bind(this))
                .catch(function(err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading the job title.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.addresses([]);
                this.viewModel.pricing([]);
                this.viewModel.jobTitleName('Job Title');
            }
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);

    // Parameters
    var params = state && state.route && state.route.segments || {};
    
    // Set the job title
    var jobID = params[0] |0;
    this.viewModel.jobTitleID(jobID);
};

function ViewModel(app) {
    
    this.jobTitleID = ko.observable(0);
    this.jobTitleName = ko.observable('Job Title');
    
    this.addresses = ko.observable([]);
    this.pricing = ko.observable([]);

    // Computed since it can check several externa loadings
    this.isLoading = ko.pureComputed(function() {
        return (
            app.model.serviceAddresses.state.isLoading() ||
            app.model.freelancerPricing.state.isLoading()
        );
        
    }, this);
    
    this.addressesCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.addresses().length,
            one = '1 location',
            more = ' locations';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
    this.pricingCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.pricing().length,
            one = '1 service',
            more = ' services';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
}

},{"../components/Activity":45,"knockout":false}],25:[function(require,module,exports){
/**
    LearnMore activity
**/
'use strict';
var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function LearnMoreActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    if (options && options.route &&
        options.route.segments &&
        options.route.segments.length) {
        this.viewModel.profile(options.route.segments[0]);
    }
};

function ViewModel() {
    this.profile = ko.observable('customer');
}

},{"../components/Activity":45,"knockout":false}],26:[function(require,module,exports){
/**
    Login activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function LoginActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Anonymous;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Log in');
    
    // Perform log-in request when is requested by the form:
    this.registerHandler({
        target: this.viewModel.isLogingIn,
        handler: function(v) {
            if (v === true) {

                // Perform loging

                // Notify state:
                var $btn = this.$activity.find('[type="submit"]');
                $btn.button('loading');

                // Clear previous error so makes clear we
                // are attempting
                this.viewModel.loginError('');

                var ended = function ended() {
                    this.viewModel.isLogingIn(false);
                    $btn.button('reset');
                }.bind(this);

                // After clean-up error (to force some view updates),
                // validate and abort on error
                // Manually checking error on each field
                if (this.viewModel.username.error() ||
                    this.viewModel.password.error()) {
                    this.viewModel.loginError('Review your data');
                    ended();
                    return;
                }

                this.app.model.login(
                    this.viewModel.username(),
                    this.viewModel.password()
                ).then(function(/*loginData*/) {

                    this.viewModel.loginError('');
                    ended();

                    // Remove form data
                    this.viewModel.username('');
                    this.viewModel.password('');

                    this.app.goDashboard();

                }.bind(this)).catch(function(err) {

                    var msg = err && err.responseJSON && err.responseJSON.errorMessage ||
                        err && err.statusText ||
                        'Invalid username or password';

                    this.viewModel.loginError(msg);
                    ended();
                }.bind(this));
            }
        }.bind(this)
    });
    
    // Focus first bad field on error
    this.registerHandler({
        target: this.viewModel.loginError,
        handler: function(err) {
            // Login is easy since we mark both unique fields
            // as error on loginError (its a general form error)
            var input = this.$activity.find(':input').get(0);
            if (err)
                input.focus();
            else
                input.blur();
        }.bind(this)
    });
});

exports.init = A.init;

var FormCredentials = require('../viewmodels/FormCredentials');

function ViewModel() {

    var credentials = new FormCredentials();    
    this.username = credentials.username;
    this.password = credentials.password;

    this.loginError = ko.observable('');
    
    this.isLogingIn = ko.observable(false);
    
    this.performLogin = function performLogin() {

        this.isLogingIn(true);        
    }.bind(this);
}

},{"../components/Activity":45,"../viewmodels/FormCredentials":135,"knockout":false}],27:[function(require,module,exports){
/**
    Logout activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function LogoutActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    this.app.model.logout().then(function() {
        // Anonymous user again
        var newAnon = this.app.model.user().constructor.newAnonymous();
        this.app.model.user().model.updateWith(newAnon);

        // Go index
        this.app.shell.go('/');
        
    }.bind(this));
};

},{"../components/Activity":45}],28:[function(require,module,exports){
/**
    OnboardingComplete activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function OnboardingCompleteActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar(null);
});

exports.init = A.init;

},{"../components/Activity":45}],29:[function(require,module,exports){
/**
    OnboardingHome activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function OnboardingHomeActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    // null for Logo
    this.navBar = Activity.createSectionNavBar(null);
});

exports.init = A.init;

},{"../components/Activity":45}],30:[function(require,module,exports){
/**
    Onboarding Positions activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function OnboardingPositionsActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Job Titles');

    // TestingData
    setSomeTestingData(this.viewModel);
});

exports.init = A.init;

function ViewModel() {

    // Full list of positions
    this.positions = ko.observableArray([]);
}

var Position = require('../models/Position');
// UserPosition model
function setSomeTestingData(viewModel) {
    
    viewModel.positions.push(new Position({
        positionSingular: 'Massage Therapist'
    }));
    viewModel.positions.push(new Position({
        positionSingular: 'Housekeeper'
    }));
}
},{"../components/Activity":45,"../models/Position":68,"knockout":false}],31:[function(require,module,exports){
/**
    OwnerInfo activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function OwnerInfoActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Account', {
        backLink: 'account'
    });
});

exports.init = A.init;

},{"../components/Activity":45}],32:[function(require,module,exports){
/**
    PrivacySettings activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function PrivacySettingsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.LoggedUser;

    this.navBar = Activity.createSubsectionNavBar('Account', {
        backLink: 'account'
    });
    
    this.registerHandler({
        target: this.app.model.privacySettings,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving privacy settings.' : 'Error loading privacy settings.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
        // Keep data updated:
    this.app.model.privacySettings.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var privacySettings = app.model.privacySettings;

    var settingsVersion = privacySettings.newVersion();
    settingsVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            settingsVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.settings = settingsVersion.version;

    this.isLocked = privacySettings.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, privacySettings);
    
    this.discard = function discard() {
        settingsVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        // Force to save, even if there was remote updates
        settingsVersion.push({ evenIfObsolete: true });
        
        app.successSave();
    }.bind(this);
}

},{"../components/Activity":45,"knockout":false}],33:[function(require,module,exports){
/**
    Scheduling activity
**/
'use strict';

var Activity = require('../components/Activity'),
    UserJobProfileViewModel = require('../viewmodels/UserJobProfile');

var A = Activity.extends(function SchedulingActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new UserJobProfileViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Scheduling');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    this.viewModel.sync();
};

},{"../components/Activity":45,"../viewmodels/UserJobProfile":139}],34:[function(require,module,exports){
/**
    SchedulingPreferences activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');
var moment = require('moment');

var A = Activity.extends(function SchedulingPreferencesActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    
    this.registerHandler({
        target: this.app.model.schedulingPreferences,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving scheduling preferences.' : 'Error loading scheduling preferences.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
        // Keep data updated:
    this.app.model.schedulingPreferences.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var schedulingPreferences = app.model.schedulingPreferences;

    var prefsVersion = schedulingPreferences.newVersion();
    prefsVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            prefsVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.prefs = prefsVersion.version;

    this.isLocked = schedulingPreferences.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, schedulingPreferences);
    
    this.discard = function discard() {
        prefsVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        // Force to save, even if there was remote updates
        prefsVersion.push({ evenIfObsolete: true });
        
        app.successSave();
    }.bind(this);
    
    this.incrementsExample = ko.pureComputed(function() {
        
        var str = 'e.g. ',
            incSize = this.incrementsSizeInMinutes(),
            m = moment({ hour: 10, minute: 0 }),
            hours = [m.format('HH:mm')];
        
        for (var i = 1; i < 4; i++) {
            hours.push(
                m.add(incSize, 'minutes')
                .format('HH:mm')
            );
        }
        str += hours.join(', ');
        
        return str;
        
    }, this.prefs);
}

},{"../components/Activity":45,"knockout":false,"moment":false}],35:[function(require,module,exports){
/**
    Service Addresses activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function ServiceAddressesActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Job Title');
    
    // Getting elements
    this.$listView = this.$activity.find('#addressesListView');

    // On changing jobTitleID:
    // - load addresses
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID
                this.app.model.jobTitles.getJobTitle(jobTitleID)
                .then(function(jobTitle) {
                    if (!this.viewModel.isSelectionMode()) {
                        // Fill in job title name
                        this.navBar.leftAction().text(jobTitle.singularName());
                    }
                    
                    // Get addresses
                    return this.app.model.serviceAddresses.getList(jobTitleID);
                }.bind(this))
                .then(function(list) {

                    list = this.app.model.serviceAddresses.asModel(list);
                    this.viewModel.addresses(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.addresses([]);
                this.navBar.leftAction().text('Job Title');
            }
        }.bind(this)
    });
    
    // Handler to update header based on a mode change:
    this.registerHandler({
        target: this.viewModel.isSelectionMode,
        handler: function (itIs) {
            this.viewModel.headerText(itIs ? 'Select or add a service location' : 'Locations');

            // Update navbar too
            // TODO: Can be other than 'scheduling', like marketplace profile or the job-title?
            this.navBar.leftAction().text(itIs ? 'Booking' : 'Scheduling');

            if (this.requestData.progressStep) {
                // Replace title by process step if required
                this.navBar.title(this.requestData.progressStep);
                this.navBar.leftAction().text('');
            }
            else {
                // Title must be empty
                this.navBar.title('');
            }

        }.bind(this)
    });

    // Go back with the selected address when triggered in the form/view
    this.viewModel.returnSelected = function(addressID, jobTitleID) {
        // Pass the selected client in the info
        this.requestData.selectedAddressID = addressID;
        this.requestData.selectedJobTitleID = jobTitleID;
        // And go back
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);
    this.viewModel.isSelectionMode(false);

    if (options.selectAddress === true) {
        this.viewModel.isSelectionMode(true);
    }

    var params = options && options.route && options.route.segments;
    var jobTitleID = params[0] |0;

    this.viewModel.jobTitleID(jobTitleID);
    
    if (jobTitleID === 0) {
        this.viewModel.jobTitles.sync();
    }
};

var UserJobProfile = require('../viewmodels/UserJobProfile');

function ViewModel(app) {

    this.headerText = ko.observable('Locations');
    
    this.jobTitleID = ko.observable(0);
    
    this.jobTitles = new UserJobProfile(app);
    this.jobTitles.baseUrl('/serviceAddress');
    this.jobTitles.selectJobTitle = function(jobTitle) {
        
        this.jobTitleID(jobTitle.jobTitleID());
        
        return false;
    }.bind(this);

    // List of addresses
    this.addresses = ko.observableArray([]);
    
    this.isSyncing = app.model.serviceAddresses.state.isSyncing();
    this.isLoading = ko.computed(function() {
        var add = app.model.serviceAddresses.state.isLoading(),
            jobs = this.jobTitles.isLoading();
        return add || jobs;
    }, this);

    // Especial mode when instead of pick and edit we are just selecting
    // (when editing an appointment)
    this.isSelectionMode = ko.observable(false);

    this.selectAddress = function(selectedAddress) {
        
        if (this.isSelectionMode() === true) {
            this.isSelectionMode(false);
            // Run method injected by the activity to return a 
            // selected address:
            this.returnSelected(
                selectedAddress.addressID(),
                selectedAddress.jobTitleID()
            );
        }
        else {
            app.shell.go('addressEditor/service/' +
                this.jobTitleID() +
                '/' + selectedAddress.addressID()
            );
        }

    }.bind(this);
}

},{"../components/Activity":45,"../viewmodels/UserJobProfile":139,"knockout":false}],36:[function(require,module,exports){
/**
    Signup activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function SignupActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Anonymous;
    this.viewModel = new ViewModel(this.app);
    // null for Logo
    this.navBar = Activity.createSectionNavBar(null);
    
    // Perform sign-up request when is requested by the form:
    this.registerHandler({
        target: this.viewModel.isSigningUp,
        handler: function(v) {
            if (v === true) {

                // Perform signup

                // Notify state:
                var $btn = this.$activity.find('[type="submit"]');
                $btn.button('loading');

                // Clear previous error so makes clear we
                // are attempting
                this.viewModel.signupError('');

                var ended = function ended() {
                    this.viewModel.isSigningUp(false);
                    $btn.button('reset');
                }.bind(this);

                // After clean-up error (to force some view updates),
                // validate and abort on error
                // Manually checking error on each field
                if (this.viewModel.username.error() ||
                    this.viewModel.password.error()) {
                    this.viewModel.signupError('Review your data');
                    ended();
                    return;
                }

                this.app.model.signup(
                    this.viewModel.username(),
                    this.viewModel.password(),
                    this.viewModel.profile()
                ).then(function(/*signupData*/) {

                    this.viewModel.signupError('');
                    ended();

                    // Remove form data
                    this.viewModel.username('');
                    this.viewModel.password('');

                    this.app.goDashboard();

                }.bind(this)).catch(function(err) {

                    var msg = err && err.responseJSON && err.responseJSON.errorMessage ||
                        err && err.statusText ||
                        'Invalid username or password';

                    this.viewModel.signupError(msg);
                    ended();
                }.bind(this));
            }
        }.bind(this)
    });
    
    // Focus first bad field on error
    this.registerHandler({
        target: this.viewModel.signupError,
        handler: function(err) {
            // Signup is easy since we mark both unique fields
            // as error on signupError (its a general form error)
            var input = this.$activity.find(':input').get(0);
            if (err)
                input.focus();
            else
                input.blur();
        }
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    if (options && options.route &&
        options.route.segments &&
        options.route.segments.length) {
        this.viewModel.profile(options.route.segments[0]);
    }
};


var FormCredentials = require('../viewmodels/FormCredentials');

function ViewModel() {

    var credentials = new FormCredentials();    
    this.username = credentials.username;
    this.password = credentials.password;

    this.signupError = ko.observable('');
    
    this.isSigningUp = ko.observable(false);
    
    this.performSignup = function performSignup() {

        this.isSigningUp(true);
    }.bind(this);

    this.profile = ko.observable('customer');
}

},{"../components/Activity":45,"../viewmodels/FormCredentials":135,"knockout":false}],37:[function(require,module,exports){
/**
    textEditor activity
**/
'use strict';

var ko = require('knockout'),
    EventEmitter = require('events').EventEmitter,
    Activity = require('../components/Activity');

var A = Activity.extends(function TextEditorActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    // Title is empty ever, since we are in 'go back' mode all the time here
    this.navBar = Activity.createSubsectionNavBar('');
    
    // Getting elements
    this.$textarea = this.$activity.find('textarea');
    this.textarea = this.$textarea.get(0);
    
    // Handler for the 'saved' event so the activity
    // returns back to the requester activity giving it
    // the new text
    this.registerHandler({
        target: this.viewModel,
        event: 'saved',
        handler: function() {
            // Update the info with the new text
            this.requestData.text = this.viewModel.text();
            // and pass it back
            this.app.shell.goBack(this.requestData);
        }.bind(this)
    });
    
    // Handler the cancel event
    this.registerHandler({
        target: this.viewModel,
        event: 'cancel',
        handler: function() {
            // return, nothing changed
            this.app.shell.goBack(this.requestData);
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Set navigation title or nothing
    this.navBar.leftAction().text(this.requestData.title || '');
    
    // Field header
    this.viewModel.headerText(this.requestData.header);
    this.viewModel.text(this.requestData.text);
    if (this.requestData.rowsNumber)
        this.viewModel.rowsNumber(this.requestData.rowsNumber);
        
    // Inmediate focus to the textarea for better usability
    this.textarea.focus();
    this.$textarea.click();
};

function ViewModel() {

    this.headerText = ko.observable('Text');

    // Text to edit
    this.text = ko.observable('');
    
    // Number of rows for the textarea
    this.rowsNumber = ko.observable(2);

    this.cancel = function cancel() {
        this.emit('cancel');
    };
    
    this.save = function save() {
        this.emit('saved');
    };
}

ViewModel._inherits(EventEmitter);

},{"../components/Activity":45,"events":false,"knockout":false}],38:[function(require,module,exports){
/**
    WeeklySchedule activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function WeeklyScheduleActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    
    this.registerHandler({
        target: this.app.model.simplifiedWeeklySchedule,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving your weekly schedule.' : 'Error loading your weekly schedule.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.simplifiedWeeklySchedule.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var simplifiedWeeklySchedule = app.model.simplifiedWeeklySchedule;

    var scheduleVersion = simplifiedWeeklySchedule.newVersion();
    scheduleVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            scheduleVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.schedule = scheduleVersion.version;

    this.isLocked = simplifiedWeeklySchedule.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, simplifiedWeeklySchedule);
    
    this.discard = function discard() {
        scheduleVersion.pull({ evenIfNewer: true });
    };

    this.save = function save() {
        // Force to save, even if there was remote updates
        scheduleVersion.push({ evenIfObsolete: true });
        
        app.successSave();
    };
}

},{"../components/Activity":45,"knockout":false}],39:[function(require,module,exports){
/**
    Registration of custom html components used by the App.
    All with 'app-' as prefix.
    
    Some definitions may be included on-line rather than on separated
    files (viewmodels), templates are linked so need to be 
    included in the html file with the same ID that referenced here,
    usually using as DOM ID the same name as the component with sufix '-template'.
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    propTools = require('./utils/jsPropertiesTools'),
    getObservable = require('./utils/getObservable');

exports.registerAll = function() {
    
    /// navbar-action
    ko.components.register('app-navbar-action', {
        template: { element: 'navbar-action-template' },
        viewModel: function(params) {

            propTools.defineGetter(this, 'action', function() {
                return (
                    params.action && params.navBar() ?
                    params.navBar()[params.action]() :
                    null
                );
            });
        }
    });
    
    /// unlabeled-input
    ko.components.register('app-unlabeled-input', {
        template: { element: 'unlabeled-input-template' },
        viewModel: function(params) {

            this.value = getObservable(params.value);
            this.placeholder = getObservable(params.placeholder);
            this.disable = getObservable(params.disable);
            
            var userAttr = getObservable(params.attr);
            this.attr = ko.pureComputed(function() {
                var attr = userAttr() || {};
                return $.extend({}, attr, {
                    'aria-label': this.placeholder(),
                    placeholder: this.placeholder(),
                    type: this.type()
                });
            }, this);
            
            var type = getObservable(params.type);            
            this.type = ko.computed(function() {
                return type() || 'text';
            }, this);
        }
    });
    
    /// feedback-entry
    ko.components.register('app-feedback-entry', {
        template: { element: 'feedback-entry-template' },
        viewModel: function(params) {

            this.section = getObservable(params.section || '');
            this.url = ko.pureComputed(function() {
                return '/feedback/' + this.section();
            }, this);
        }
    });
    
    /// feedback-entry
    ko.components.register('app-time-slot-tile', {
        template: { element: 'time-slot-tile-template' },
        viewModel: require('./viewmodels/TimeSlot')
    });
    
    /// loading-spinner
    ko.components.register('app-loading-spinner', {
        template: { element: 'loading-spinner-template' },
        viewModel: function(params) {
            var base = 'loadingSpinner';
            this.mod = getObservable(params.mod || '');
            this.cssClass = ko.pureComputed(function() {
                var c = base,
                    mods = (this.mod() || '').split(' ');
                if (mods.length)
                    c += ' ' + base + '--' + mods.join(' ' + base + '--');
                return c;
            }, this);
        }
    });
    
    /// appointment-card
    ko.components.register('app-appointment-card', {
        template: { element: 'appointment-card-template' },
        viewModel: require('./viewmodels/AppointmentCard')
    });
};

},{"./utils/getObservable":98,"./utils/jsPropertiesTools":101,"./viewmodels/AppointmentCard":133,"./viewmodels/TimeSlot":138,"knockout":false}],40:[function(require,module,exports){
/**
    Navbar extension of the App,
    adds the elements to manage a view model
    for the NavBar and automatic changes
    under some model changes like user login/logout
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    NavBar = require('./viewmodels/NavBar'),
    NavAction = require('./viewmodels/NavAction');

exports.extends = function (app) {
    
    // REVIEW: still needed? Maybe the per activity navBar means
    // this is not needed. Some previous logic was already removed
    // because was useless.
    //
    // Adjust the navbar setup depending on current user,
    // since different things are need for logged-in/out.
    function adjustUserBar() {

        var user = app.model.user();

        if (user.isAnonymous()) {
            app.navBar().rightAction(NavAction.menuOut);
        }
    }
    // Commented lines, used previously but unused now, it must be enough with the update
    // per activity change
    //app.model.user().isAnonymous.subscribe(updateStatesOnUserChange);
    //app.model.user().onboardingStep.subscribe(updateStatesOnUserChange);
    
    app.navBar = ko.observable(null);
    
    var refreshNav = function refreshNav() {
        // Trigger event to force a component update
        $('.AppNav').trigger('contentChange');
    };
    var autoRefreshNav = function autoRefreshNav(action) {
        if (action) {
            action.text.subscribe(refreshNav);
            action.isTitle.subscribe(refreshNav);
            action.icon.subscribe(refreshNav);
            action.isMenu.subscribe(refreshNav);
        }
    };

    /**
        Update the nav model using the Activity defaults
    **/
    app.updateAppNav = function updateAppNav(activity) {

        // if the activity has its own
        if ('navBar' in activity) {
            // Use specializied activity bar data
            app.navBar(activity.navBar);
        }
        else {
            // Use default one
            app.navBar(new NavBar());
        }

        // TODO Double check if needed.
        // Latest changes, when needed
        adjustUserBar();
        
        refreshNav();
        autoRefreshNav(app.navBar().leftAction());
        autoRefreshNav(app.navBar().rightAction());
    };
    
    
    /**
        Update the app menu to highlight the
        given link name
    **/
    app.updateMenu = function updateMenu(name) {
        
        var $menu = $('.App-menus .navbar-collapse');
        
        // Remove any active
        $menu
        .find('li')
        .removeClass('active');
        // Add active
        $menu
        .find('.go-' + name)
        .closest('li')
        .addClass('active');
        // Hide menu
        $menu
        .filter(':visible')
        .collapse('hide');
    };
    
    app.setupNavBarBinding = function setupNavBarBinding() {
        // Set model for the AppNav
        ko.applyBindings({
            navBar: app.navBar
        }, $('.AppNav').get(0));
    };
    
    /**
        Performs the 'back' task from the navbar link, if any.
        That is, trigger the left action.
        Fallback to shell goBack
    **/
    app.performsNavBarBack = function performsNavBarBack() {
        var nav = this.navBar(),
            left = nav && nav.leftAction(),
            $btn = $('.SmartNavBar-edge.left > .SmartNavBar-btn');

        // There is an action, trigger like a click so all the handlers
        // attached on spare places do their work:
        if (left) {
            $btn.trigger('tap').trigger('click');
        }
        else if (this.shell) {
            this.shell.goBack();
        }
    };
    
    /**
        It shows an unobtrusive notification on the navbar place, that
        hides after a short timeout
    **/
    var lastNotificationTimer = null;
    app.showNavBarNotification = function showNavBarNotification(settings) {
        var msg = settings && settings.message || 'Hello World!',
            duration = settings && settings.duration || 2000,
            transitionDuration = settings && settings.transitionDuration || 400,
            $el = $('.AppNav .SmartNavBar-notification');

        $el.text(msg);
        $el.fadeIn(transitionDuration)
        .queue(function() {
            
            // Manual hide on tapping
            $el
            .off('tap.manualHide')
            .on('tap.manualHide', function() {
                $el.fadeOut(transitionDuration);
            });
            
            // Auto hide after timeout
            clearTimeout(lastNotificationTimer);
            lastNotificationTimer = setTimeout(function() {
                $el.fadeOut(transitionDuration);
            }, duration);
            
            $(this).dequeue();
        });
    };
};

},{"./viewmodels/NavAction":136,"./viewmodels/NavBar":137,"knockout":false}],41:[function(require,module,exports){
/**
    List of activities loaded in the App,
    as an object with the activity name as the key
    and the controller as value.
**/
'use strict';

module.exports = {
    'calendar': require('./activities/calendar'),
    'datetimePicker': require('./activities/datetimePicker'),
    'clients': require('./activities/clients'),
    'freelancerPricing': require('./activities/freelancerPricing'),
    'serviceAddresses': require('./activities/serviceAddresses'),
    'textEditor': require('./activities/textEditor'),
    'home': require('./activities/home'),
    'appointment': require('./activities/appointment'),
    'bookingConfirmation': require('./activities/bookingConfirmation'),
    'index': require('./activities/index'),
    'login': require('./activities/login'),
    'logout': require('./activities/logout'),
    'learnMore': require('./activities/learnMore'),
    'signup': require('./activities/signup'),
    'contactInfo': require('./activities/contactInfo'),
    'onboardingPositions': require('./activities/onboardingPositions'),
    'onboardingHome': require('./activities/onboardingHome'),
    'addressEditor': require('./activities/addressEditor'),
    'onboardingComplete': require('./activities/onboardingComplete'),
    'account': require('./activities/account'),
    'inbox': require('./activities/inbox'),
    'conversation': require('./activities/conversation'),
    'scheduling': require('./activities/scheduling'),
    'jobtitles': require('./activities/jobtitles'),
    'feedback': require('./activities/feedback'),
    'faqs': require('./activities/faqs'),
    'feedbackForm': require('./activities/feedbackForm'),
    'contactForm': require('./activities/contactForm'),
    'cms': require('./activities/cms'),
    'clientEditor': require('./activities/clientEditor'),
    'schedulingPreferences': require('./activities/schedulingPreferences'),
    'calendarSyncing': require('./activities/calendarSyncing'),
    'weeklySchedule': require('./activities/weeklySchedule'),
    'bookMeButton': require('./activities/bookMeButton'),
    'ownerInfo': require('./activities/ownerInfo'),
    'privacySettings': require('./activities/privacySettings'),
    'addJobTitles': require('./activities/addJobTitles'),
    'freelancerPricingEditor': require('./activities/freelancerPricingEditor')
};

},{"./activities/account":1,"./activities/addJobTitles":2,"./activities/addressEditor":3,"./activities/appointment":4,"./activities/bookMeButton":5,"./activities/bookingConfirmation":6,"./activities/calendar":7,"./activities/calendarSyncing":8,"./activities/clientEditor":9,"./activities/clients":10,"./activities/cms":11,"./activities/contactForm":12,"./activities/contactInfo":13,"./activities/conversation":14,"./activities/datetimePicker":15,"./activities/faqs":16,"./activities/feedback":17,"./activities/feedbackForm":18,"./activities/freelancerPricing":19,"./activities/freelancerPricingEditor":20,"./activities/home":21,"./activities/inbox":22,"./activities/index":23,"./activities/jobtitles":24,"./activities/learnMore":25,"./activities/login":26,"./activities/logout":27,"./activities/onboardingComplete":28,"./activities/onboardingHome":29,"./activities/onboardingPositions":30,"./activities/ownerInfo":31,"./activities/privacySettings":32,"./activities/scheduling":33,"./activities/schedulingPreferences":34,"./activities/serviceAddresses":35,"./activities/signup":36,"./activities/textEditor":37,"./activities/weeklySchedule":38}],42:[function(require,module,exports){
'use strict';

/** Global dependencies **/
var $ = require('jquery');
require('jquery-mobile');
require('./utils/jquery.multiline');
var ko = require('knockout');
ko.bindingHandlers.format = require('ko/formatBinding').formatBinding;
var bootknock = require('./utils/bootknockBindingHelpers');
require('./utils/Function.prototype._inherits');
require('./utils/Function.prototype._delayed');
// Polyfill for useful non-standard feature Function.name for IE9+
// (feature used to simplify creation of Activities and Models)
require('./utils/Function.prototype.name-polyfill');
// Promise polyfill, so its not 'require'd per module:
require('es6-promise').polyfill();

var layoutUpdateEvent = require('layoutUpdateEvent');
var AppModel = require('./viewmodels/AppModel');

// Register the special locale
require('./locales/en-US-LC');

/**
    A set of fixes/workarounds for Bootstrap behavior/plugins
    to be executed before Bootstrap is included/executed.
    For example, because of data-binding removing/creating elements,
    some old references to removed items may get alive and need update,
    or re-enabling some behaviors.
**/
function preBootstrapWorkarounds() {
    // Internal Bootstrap source utility
    function getTargetFromTrigger($trigger) {
        var href,
            target = $trigger.attr('data-target') ||
            (href = $trigger.attr('href')) && 
            href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

        return $(target);
    }
    
    // Bug: navbar-collapse elements hold a reference to their original
    // $trigger, but that trigger can change on different 'clicks' or
    // get removed the original, so it must reference the new one
    // (the latests clicked, and not the cached one under the 'data' API).    
    // NOTE: handler must execute before the Bootstrap handler for the same
    // event in order to work.
    $(document).on('click.bs.collapse.data-api.workaround', '[data-toggle="collapse"]', function() {
        var $t = $(this),
            $target = getTargetFromTrigger($t),
            data = $target && $target.data('bs.collapse');
        
        // If any
        if (data) {
            // Replace the trigger in the data reference:
            data.$trigger = $t;
        }
        // On else, nothing to do, a new Collapse instance will be created
        // with the correct target, the first time
    });
}

/**
    App static class
**/
var app = {
    shell: require('./app.shell'),
    
    // New app model, that starts with anonymous user
    model: new AppModel(),
    
    /** Load activities controllers (not initialized) **/
    activities: require('./app.activities'),
    
    modals: require('./app.modals'),
    
    /**
        Just redirect the better place for current user and state.
        NOTE: Its a delayed function, since on many contexts need to
        wait for the current 'routing' from end before do the new
        history change.
        TODO: Maybe, rather than delay it, can stop current routing
        (changes on Shell required) and perform the new.
        TODO: Maybe alternative to previous, to provide a 'replace'
        in shell rather than a go, to avoid append redirect entries
        in the history, that create the problem of 'broken back button'
    **/
    goDashboard: function goDashboard() {
        
        // To avoid infinite loops if we already are performing 
        // a goDashboard task, we flag the execution
        // being care of the delay introduced in the execution
        if (goDashboard._going === true) {
            return;
        }
        else {
            // Delayed to avoid collisions with in-the-middle
            // tasks: just allowing current routing to finish
            // before perform the 'redirect'
            // TODO: change by a real redirect that is able to
            // cancel the current app.shell routing process.
            setTimeout(function() {
        
                goDashboard._going = true;

                var onboarding = this.model.user().onboardingStep();

                if (onboarding) {
                    this.shell.go('onboardingHome/' + onboarding);
                }
                else {
                    this.shell.go('home');
                }

                // Just because is delayed, needs
                // to be set off after an inmediate to 
                // ensure is set off after any other attempt
                // to add a delayed goDashboard:
                setTimeout(function() {
                    goDashboard._going = false;
                }, 1);
            }.bind(this), 1);
        }
    }
};

/** Continue app creation with things that need a reference to the app **/

require('./app-navbar').extends(app);

require('./app-components').registerAll();

app.getActivity = function getActivity(name) {
    var activity = this.activities[name];
    if (activity) {
        var $act = this.shell.items.find(name);
        if ($act && $act.length)
            return activity.init($act, this);
    }
    return null;
};

app.getActivityControllerByRoute = function getActivityControllerByRoute(route) {
    // From the route object, the important piece is route.name
    // that contains the activity name except if is the root
    var actName = route.name || this.shell.indexName;
    
    return this.getActivity(actName);
};

// accessControl setup: cannot be specified on Shell creation because
// depends on the app instance
app.shell.accessControl = require('./utils/accessControl')(app);

// Shortcut to UserType enumeration used to set permissions
app.UserType = require('./models/User').UserType;

// New method for common forms behavior after a successful save operation,
// the activity goes back (following the navbar back-link or shell.goBack())
// and notifying with a temporary unobtrusive navbar notification
app.successSave = function successSave(settings) {
    // defaults
    settings = $.extend({
        message: 'Your changes have been saved'
    }, settings);
    // go back
    this.performsNavBarBack();
    // show notification
    this.showNavBarNotification(settings);
};

/** App Init **/
var appInit = function appInit() {
    /*jshint maxstatements:50,maxcomplexity:16 */
    
    // Enabling the 'layoutUpdate' jQuery Window event that happens on resize and transitionend,
    // and can be triggered manually by any script to notify changes on layout that
    // may require adjustments on other scripts that listen to it.
    // The event is throttle, guaranting that the minor handlers are executed rather
    // than a lot of them in short time frames (as happen with 'resize' events).
    layoutUpdateEvent.layoutUpdateEvent += ' orientationchange';
    layoutUpdateEvent.on();
    
    // Keyboard plugin events are not compatible with jQuery events, but needed to
    // trigger a layoutUpdate, so here are connected, mainly fixing bugs on iOS when the keyboard
    // is hidding.
    var trigLayout = function trigLayout() {
        $(window).trigger('layoutUpdate');
    };
    window.addEventListener('native.keyboardshow', trigLayout);
    window.addEventListener('native.keyboardhide', trigLayout);

    // iOS-7+ status bar fix. Apply on plugin loaded (cordova/phonegap environment)
    // and in any system, so any other systems fix its solved too if needed 
    // just updating the plugin (future proof) and ensure homogeneous cross plaftform behavior.
    if (window.StatusBar) {
        // Fix iOS-7+ overlay problem
        // Is in config.xml too, but seems not to work without next call:
        window.StatusBar.overlaysWebView(false);
    }

    // Because of the iOS7+8 bugs with height calculation,
    // a different way of apply content height to fill all the available height (as minimum)
    // is required.
    // For that, the 'full-height' class was added, to be used in elements inside the 
    // activity that needs all the available height, here the calculation is applied for
    // all platforms for this homogeneous approach to solve the problemm.
    (function() {
        var $b = $('body');
        var fullHeight = function fullHeight() {
            var h = $b.height();
            $('.full-height')
            // Let browser to compute
            .css('height', 'auto')
            // As minimum
            .css('min-height', h)
            // Set explicit the automatic computed height
            .css('height', function() {
                // we use box-sizing:border-box, so needs to be outerHeight without margin:
                return $(this).outerHeight(false);
            });
        };
        
        fullHeight();
        $(window).on('layoutUpdate', function() {
            fullHeight();
        });
    })();
    
    // Force an update delayed to ensure update after some things did additional work
    setTimeout(function() {
        $(window).trigger('layoutUpdate');
    }, 200);
    
    // Bootstrap
    preBootstrapWorkarounds();
    require('bootstrap');
    
    // Load Knockout binding helpers
    bootknock.plugIn(ko);
    require('./utils/bootstrapSwitchBinding').plugIn(ko);
    
    // Plugins setup
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
        // Explicitely, we WANT auto scroll on keyboard show up.
        // Can be disabled only if there is a javascript solution to autoscroll
        // on input focus, else a bug will happen specially on iOS where input
        // fields gets hidden by the on screen keyboard.
        window.cordova.plugins.Keyboard.disableScroll(false);
    }
    
    // Easy links to shell actions, like goBack, in html elements
    // Example: <button data-shell="goBack 2">Go 2 times back</button>
    // NOTE: Important, registered before the shell.run to be executed
    // before its 'catch all links' handler
    $(document).on('tap', '[data-shell]', function(e) {
        // Using attr rather than the 'data' API to get updated
        // DOM values
        var cmdline = $(this).attr('data-shell') || '',
            args = cmdline.split(' '),
            cmd = args[0];

        if (cmd && typeof(app.shell[cmd]) === 'function') {
            app.shell[cmd].apply(app.shell, args.slice(1));
            
            // Cancel any other action on the link, to avoid double linking results
            e.stopImmediatePropagation();
            e.preventDefault();
        }
    });
    
    // On Cordova/Phonegap app, special targets must be called using the window.open
    // API to ensure is correctly opened on the InAppBrowser (_blank) or system default
    // browser (_system).
    if (window.cordova) {
        $(document).on('tap', '[target="_blank"], [target="_system"]', function(e) {
            window.open(this.getAttribute('href'), this.getAttribute('target'));
            e.preventDefault();
        });
    }
    
    // When an activity is ready in the Shell:
    app.shell.on(app.shell.events.itemReady, function($act, state) {
        
        // Connect the 'activities' controllers to their views
        // Get initialized activity for the DOM element
        var actName = $act.data('activity');
        var activity = app.getActivity(actName);
        // Trigger the 'show' logic of the activity controller:
        activity.show(state);

        // Update menu
        var menuItem = activity.menuItem || actName;
        app.updateMenu(menuItem);
        
        // Update app navigation
        app.updateAppNav(activity);
    });
    // When an activity is hidden
    app.shell.on(app.shell.events.closed, function($act) {
        
        // Connect the 'activities' controllers to their views
        var actName = $act.data('activity');
        var activity = app.getActivity(actName);
        // Trigger the 'hide' logic of the activity controller:
        if (activity.hide)
            activity.hide();
    });
    // Catch errors on item/page loading, showing..
    app.shell.on('error', function(err) {
        app.modals.showError({ error: err });
    });
    
    // Attempt scroll on clicking a usual fragment link
    // TODO: there is some kind of problem sometimes and
    // does not get correclty aligned, investigate
    // WORKAROUND a fixed value as offset to avoid for now
    var scrollTo = function scrollTo(el) {
        var parent = el.parent();

        while(parent.get(0) !== document.documentElement) {
            var t = el.offset().top - parent.offset().top;
            var st = parent.scrollTop() + t;
            // WORKAROUND CONSTANT OFFSET
            st -= 45;
            parent.scrollTop(st);
            
            parent = parent.parent();
        }
    };
    app.shell.on('fragmentNavigation', function(href) {
        // Locate target
        // (href comes with the initial hash ever)
        var target = $(href);
        if (target.length) {
            scrollTo(target);
        }
    });
    
    // Navbar binding
    app.setupNavBarBinding();
    
    var SmartNavBar = require('./components/SmartNavBar');
    var navBars = SmartNavBar.getAll();
    // Creates an event by listening to it, so other scripts can trigger
    // a 'contentChange' event to force a refresh of the navbar (to 
    // calculate and apply a new size); expected from dynamic navbars
    // that change it content based on observables.
    navBars.forEach(function(navbar) {
        $(navbar.el).on('contentChange', function() {
            navbar.refresh();
        });
    });
    
    // Listen for menu events (collapse in SmartNavBar)
    // to apply the backdrop
    var togglingBackdrop = false;
    $(document).on('show.bs.collapse hide.bs.collapse', '.AppNav .navbar-collapse', function(e) {
        if (!togglingBackdrop) {
            togglingBackdrop = true;
            var enabled = e.type === 'show';
            $('body').toggleClass('use-backdrop', enabled);
            // Hide any other opened collapse
            $('.collapsing, .collapse.in').collapse('hide');
            togglingBackdrop = false;
        }
    });

    // Catch uncatch model errors
    app.model.on('error', function(err) {
        app.modals.showError({
            error: err
        });
    });
    
    // Additional form elements attribute and behavior: data-autoselect=true
    // sets to automatically select the text content of an input text control
    // when gets the focus
    $(document).on('focus', '[data-autoselect="true"]', function() {
        $(this).select();
    });
    
    // App init:
    var alertError = function(err) {
        app.modals.showError({
            title: 'There was an error loading',
            error: err
        });
    };

    app.model.init()
    .then(app.shell.run.bind(app.shell), alertError)
    .then(function() {
        // Mark the page as ready
        $('html').addClass('is-ready');
        // As app, hides splash screen
        if (window.navigator && window.navigator.splashscreen) {
            window.navigator.splashscreen.hide();
        }
    }, alertError);

    // DEBUG
    window.app = app;
};

// App init on page ready and phonegap ready
if (window.cordova) {
    // On DOM-Ready first
    $(function() {
        // Page is ready, device is too?
        // Note: Cordova ensures to call the handler even if the
        // event was already fired, so is good to do it inside
        // the dom-ready and we are ensuring that everything is
        // ready.
        $(document).on('deviceready', appInit);
    });
} else {
    // Only on DOM-Ready, for in browser development
    $(appInit);
}

},{"./app-components":39,"./app-navbar":40,"./app.activities":41,"./app.modals":43,"./app.shell":44,"./components/SmartNavBar":47,"./locales/en-US-LC":48,"./models/User":77,"./utils/Function.prototype._delayed":81,"./utils/Function.prototype._inherits":82,"./utils/Function.prototype.name-polyfill":83,"./utils/accessControl":92,"./utils/bootknockBindingHelpers":93,"./utils/bootstrapSwitchBinding":94,"./utils/jquery.multiline":100,"./viewmodels/AppModel":122,"es6-promise":false,"knockout":false}],43:[function(require,module,exports){
/**
    Access to use global App Modals
**/
'use strict';

var $ = require('jquery');

/**
    Generates a text message, with newlines if needed, describing the error
    object passed.
    @param err:any As a string, is returned 'as is'; as falsy, it return a generic
    message for 'unknow error'; as object, it investigate what type of error is to
    provide the more meaninful result, with fallback to JSON.stringify prefixed
    with 'Technical details:'.
    Objects recognized:
    - XHR/jQuery for JSON responses: just objects with responseJSON property, is
      used as the 'err' object and passed to the other object tests.
    - Object with 'errorMessage' (server-side formatted error).
    - Object with 'message' property, like the standard Error class and Exception objects.
    - Object with 'name' property, like the standard Exception objects. The name, if any,
      is set as prefix for the 'message' property value.
    - Object with 'errors' property. Each element in the array or object own keys
      is appended to the errorMessage or message separated by newline.
**/
exports.getErrorMessageFrom = function getErrorMessageFrom(err, defaultText) {
    /*jshint maxcomplexity:14, maxdepth:5*/

    defaultText = defaultText || 'Unknow error';
    
    if (!err) {
        return defaultText;
    }
    else if (typeof(err) === 'string') {
        return err || defaultText;
    }
    else {
        // If is a XHR object, use its response as the error.
        err = err.responseJSON || err;

        var msg = err.name && (err.name + ': ') || '';
        msg += err.errorMessage || err.message || '';

        if (err.errors) {
            msg += '\n' + exports.stringifyErrorsList(err.errors);
        }
        else {
            // Avoiding that en error converting the object (circular references)
            // breaks the error control!
            try {
                var jserr = JSON.stringify(err);
                // Avoiding that empty results (empty string or empty object when there
                // is no details to show) makes us to show an annoying 'technical details'
                var hasMoreInfo = jserr && jserr !== '{}';
                // Too if there is no more information than the one extracted to build the
                // message, since on that cases the 'technical details' will be just a 
                // json formatted of the same displayed message
                if (hasMoreInfo) {
                    // Reset initially, re-enabled only if there are more properties
                    // than the ones from the list
                    hasMoreInfo = false;
                    var messagePropertiesList = ['name', 'errorMessage', 'message', 'errors'];
                    Object.keys(err).forEach(function(key) {
                        if (messagePropertiesList.indexOf(key) === -1)
                            hasMoreInfo = true;
                    });
                }

                if (hasMoreInfo)
                    msg += '\n\nTechnical details: ' + jserr;
            }
            catch (ex) {
                console.log('Impossible to stringify JSON error', err, ex);
            }
        }

        return msg || defaultText;
    }
};

exports.stringifyErrorsList = function (errors) {
    var msg = '';
    if (Array.isArray(errors)) {
        msg = errors.join('\n');
    }
    else {
        msg = Object.keys(errors).map(function(key) {
            return errors[key].join('\n');
        }).join('\n');
    }
    return msg;
};

/**
    Show an error modal to notify the user.
    @param options:Object {
        message:string DEPRECATED. Optional. Informative error message.
        error:string Optional. Error/Exception/XHR object, used to auto
            generate the error message. It takes precedence over 'message'
            option, discarding an error object/string is passed.
            It replaces 'message' since can do the same and more.
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when the modal is dismissed/closed.
    No formal rejection happens.
**/
exports.showError = function showErrorModal(options) {
    
    var modal = $('#errorModal'),
        header = modal.find('#errorModal-label'),
        body = modal.find('#errorModal-body');
    
    options = options || {};
    
    // Fallback error message
    var msg = body.data('default-text');

    // Error message from given error object, with fallback to default one.
    // DEPRECATED temporarly using the 'message' option.
    msg = exports.getErrorMessageFrom(options.error || options.message, msg);

    body.multiline(msg);

    header.text(options.title || header.data('default-text'));
    
    return new Promise(function(resolve) {
        modal.modal('show');
        modal.on('hide.bs.modal', function() {
            resolve();
        });
    });
};

/**
    Show confirmation modal with two buttons.
    @param options:object {
        title:string Header title text
        message:string Message text
        yes:string Yes button label
        no:string No button label
    }
    @returns Promise. It resolves if button 'yes' pressed
    and reject on button 'no' pressed or modal dismissed/closed.
**/
exports.confirm = function confirm(options) {
    
    var modal = $('#confirmModal'),
        header = modal.find('#confirmModal-label'),
        body = modal.find('#confirmModal-body'),
        yesBtn = modal.find('#confirmModal-yesBtn'),
        noBtn = modal.find('#confirmModal-noBtn');

    options = options || {};

    // Fallback error message
    var title = header.data('default-text'),
        msg = body.data('default-text'),
        yes = yesBtn.data('default-text'),
        no = noBtn.data('default-text');

    body.multiline(options.message || msg);
    header.text(options.title || title);
    yesBtn.text(options.yes || yes);
    noBtn.text(options.no || no);

    return new Promise(function(resolve, reject) {
        modal.modal('show');
        yesBtn.on('tap click', function() {
            resolve();
        });
        noBtn.on('tap click', function() {
            reject();
        });
        modal.on('hide.bs.modal', function() {
            reject();
        });
    });
};


},{}],44:[function(require,module,exports){
/**
    Setup of the shell object used by the app
**/
'use strict';

var baseUrl = window.location.pathname;

//var History = require('./app-shell-history').create(baseUrl);
var History = require('./utils/shell/hashbangHistory');

// Shell dependencies
var shell = require('./utils/shell/index'),
    Shell = shell.Shell,
    DomItemsManager = shell.DomItemsManager;

var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );

// Creating the shell:
var shell = new Shell({

    // Selector, DOM element or jQuery object pointing
    // the root or container for the shell items
    root: 'body',

    // If is not in the site root, the base URL is required:
    baseUrl: baseUrl,
    
    forceHashbang: true,

    indexName: 'index',

    // WORKAROUND: Using the 'tap' event for faster mobile experience
    // (from jquery-mobile event) on iOS devices with fallback to 'click'
    // (the shell is ready to manage multiple events but firing once), but left
    // 'click' on others since they has not the slow-click problem
    // thanks to the meta-viewport.
    linkEvent: iOS ? 'tap click' : 'click',

    // No need for loader, everything comes bundled
    loader: null,

    // History Polyfill:
    history: History,

    // A DomItemsManager or equivalent object instance needs to
    // be provided:
    domItemsManager: new DomItemsManager({
        idAttributeName: 'data-activity'
    })
});

module.exports = shell;

},{"./utils/shell/hashbangHistory":107,"./utils/shell/index":108}],45:[function(require,module,exports){
/**
    Activity base class
**/
'use strict';

var ko = require('knockout'),
    NavAction = require('../viewmodels/NavAction'),
    NavBar = require('../viewmodels/NavBar');

require('../utils/Function.prototype._inherits');

/**
    Activity class definition
**/
function Activity($activity, app) {

    this.$activity = $activity;
    this.app = app;

    // Default access level: anyone
    this.accessLevel = app.UserType.None;
    
    // TODO: Future use of a viewState, plain object representation
    // of part of the viewModel to be used as the state passed to the
    // history and between activities calls.
    this.viewState = {};
    
    // Object to hold the options passed on 'show' as a result
    // of a request from another activity
    this.requestData = null;

    // Default navBar object.
    this.navBar = new NavBar({
        title: null, // null for logo
        leftAction: null,
        rightAction: null
    });
    
    // Delayed bindings to allow for further constructor set-up 
    // on subclasses.
    setTimeout(function ActivityConstructorDelayed() {
        // A view model and bindings being applied is ever required
        // even on Activities without need for a view model, since
        // the use of components and templates, or any other data-bind
        // syntax, requires to be in a context with binding enabled:
        ko.applyBindings(this.viewModel || {}, $activity.get(0));
    }.bind(this), 1);
}

module.exports = Activity;

/**
    Set-up visualization of the view with the given options/state,
    with a reset of current state.
    Must be executed every time the activity is put in the current view.
**/
Activity.prototype.show = function show(options) {
    // TODO: must keep viewState up to date using options/state.
    
    options = options || {};
    this.requestData = options;
    
    // Enable registered handlers
    // Validation of each settings object is performed
    // on registered, avoided here.
    if (this._handlers &&
        this._handlersAreConnected !== true) {
        this._handlers.forEach(function(settings) {
            // Check if is an observable subscription
            if (!settings.event && settings.target.subscribe) {
                var subscription = settings.target.subscribe(settings.handler);
                // Observables has not a 'unsubscribe' function,
                // they return an object that must be 'disposed'.
                // Saving that with settings to allow 'unsubscribe' later.
                settings._subscription = subscription;

                // Inmediate execution: if current observable value is different
                // than previous one, execute the handler:
                // (this avoid that a changed state get omitted because happened
                // when subscription was off; it means a first time execution too).
                // NOTE: 'undefined' value on observable may cause this to fall
                if (settings._latestSubscribedValue !== settings.target()) {
                    settings.handler.call(settings.target, settings.target());
                }
            }
            else if (settings.selector) {
                settings.target.on(settings.event, settings.selector, settings.handler);
            }
            else if (settings.target.on) {
                settings.target.on(settings.event, settings.handler);
            }
            else {
                console.error('Activity.show: Bad registered handler', settings);
            }
        });
        // To avoid double connections:
        // NOTE: may happen that 'show' gets called several times without a 'hide'
        // in between, because 'show' acts as a refresher right now even from segment
        // changes from the same activity.
        this._handlersAreConnected = true;
    }
};

/**
    Perform tasks to stop anything running or stop handlers from listening.
    Must be executed every time the activity is hidden/removed 
    from the current view.
**/
Activity.prototype.hide = function hide() {
    
    // Disable registered handlers
    if (this._handlers) {
        this._handlers.forEach(function(settings) {
            // Check if is an observable subscription
            if (settings._subscription) {
                settings._subscription.dispose();
                // Save latest observable value to make a comparision
                // next time is enabled to ensure is executed if there was
                // a change while disabled:
                settings._latestSubscribedValue = settings.target();
            }
            else if (settings.target.off) {
                if (settings.selector)
                    settings.target.off(settings.event, settings.selector, settings.handler);
                else
                    settings.target.off(settings.event, settings.handler);
            }
            else if (settings.target.removeListener) {
                settings.target.removeListener(settings.event, settings.handler);
            }
            else {
                console.error('Activity.hide: Bad registered handler', settings);
            }
        });
        
        this._handlersAreConnected = false;
    }
};

/**
    Register a handler that acts on an event or subscription notification,
    that will be enabled on Activity.show and disabled on Activity.hide.

    @param settings:object {
        target: jQuery, EventEmitter, Knockout.observable. Required
        event: string. Event name (can have namespaces, several events allowed). Its required except when the target is an observable, there must
            be omitted.
        handler: Function. Required,
        selector: string. Optional. For jQuery events only, passed as the
            selector for delegated handlers.
    }
**/
Activity.prototype.registerHandler = function registerHandler(settings) {
    /*jshint maxcomplexity:8 */
    
    if (!settings)
        throw new Error('Register require a settings object');
    
    if (!settings.target || (!settings.target.on && !settings.target.subscribe))
        throw new Error('Target is null or not a jQuery, EventEmmiter or Observable object');
    
    if (typeof(settings.handler) !== 'function') {
        throw new Error('Handler must be a function.');
    }
    
    if (!settings.event && !settings.target.subscribe) {
        throw new Error('Event is null; it\'s required for non observable objects');
    }

    this._handlers = this._handlers || [];

    this._handlers.push(settings);
};

/**
    Static utilities
**/
// For commodity, common classes are exposed as static properties
Activity.NavBar = NavBar;
Activity.NavAction = NavAction;

// Quick creation of common types of NavBar
Activity.createSectionNavBar = function createSectionNavBar(title) {
    return new NavBar({
        title: title,
        leftAction: NavAction.menuNewItem,
        rightAction: NavAction.menuIn
    });
};

Activity.createSubsectionNavBar = function createSubsectionNavBar(title, options) {
    
    options = options || {};
    
    var goBackOptions = {
        text: title,
        isTitle: true
    };

    if (options.backLink) {
        goBackOptions.link = options.backLink;
        goBackOptions.isShell = false;
    }

    return new NavBar({
        title: '', // No title
        leftAction: NavAction.goBack.model.clone(goBackOptions),
        rightAction: options.helpId ?
            NavAction.goHelpIndex.model.clone({
                link: '#' + options.helpId
            }) :
            NavAction.goHelpIndex
    });
};

/**
    Singleton helper
**/
var singlentonInstances = {};
var createSingleton = function createSingleton(ActivityClass, $activity, app) {
    
    if (singlentonInstances[ActivityClass.name] instanceof ActivityClass) {
        return singlentonInstances[ActivityClass.name];
    }
    else {
        var s = new ActivityClass($activity, app);
        singlentonInstances[ActivityClass.name] = s;
        return s;
    }
};
// Example of use
//exports.init = createSingleton.bind(null, ActivityClass);

/**
    Static method extends to help inheritance.
    Additionally, it adds a static init method ready for the new class
    that generates/retrieves the singleton.
**/
Activity.extends = function extendsActivity(ClassFn) {
    
    ClassFn._inherits(Activity);
    
    ClassFn.init = createSingleton.bind(null, ClassFn);
    
    return ClassFn;
};

},{"../utils/Function.prototype._inherits":82,"../viewmodels/NavAction":136,"../viewmodels/NavBar":137,"knockout":false}],46:[function(require,module,exports){
/* =========================================================
 * DatePicker JS Component, with several
 * modes and optional inline-permanent visualization.
 *
 * Copyright 2014 Loconomics Coop.
 *
 * Based on:
 * bootstrap-datepicker.js 
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

var $ = require('jquery'); 

var classes = {
    component: 'DatePicker',
    months: 'DatePicker-months',
    days: 'DatePicker-days',
    monthDay: 'day',
    month: 'month',
    year: 'year',
    years: 'DatePicker-years'
};

// Picker object
var DatePicker = function(element, options) {
    /*jshint maxstatements:32,maxcomplexity:24*/
    this.element = $(element);
    this.format = DPGlobal.parseFormat(options.format||this.element.data('date-format')||'mm/dd/yyyy');
    
    this.isInput = this.element.is('input');
    this.component = this.element.is('.date') ? this.element.find('.add-on') : false;
    this.isPlaceholder = this.element.is('.calendar-placeholder');
    
    this.picker = $(DPGlobal.template)
                        .appendTo(this.isPlaceholder ? this.element : 'body')
                        .on('click tap', $.proxy(this.click, this));
    this.picker.addClass(this.isPlaceholder ? '' : 'dropdown-menu');
    
    if (this.isPlaceholder) {
        this.picker.show();
        if (this.element.data('date') == 'today') {
            this.date = new Date();
            this.set();
        }
        this.element.trigger({
            type: 'show',
            date: this.date
        });
    }
    else if (this.isInput) {
        this.element.on({
            focus: $.proxy(this.show, this),
            //blur: $.proxy(this.hide, this),
            keyup: $.proxy(this.update, this)
        });
    } else {
        if (this.component){
            this.component.on('click tap', $.proxy(this.show, this));
        } else {
            this.element.on('click tap', $.proxy(this.show, this));
        }
    }
    
    /* Touch events to swipe dates */
    this.element
    .on('swipeleft', function(e) {
        e.preventDefault();
        this.moveDate('next');
    }.bind(this))
    .on('swiperight', function(e) {
        e.preventDefault();
        this.moveDate('prev');
    }.bind(this));

    /* Set-up view mode */
    this.minViewMode = options.minViewMode||this.element.data('date-minviewmode')||0;
    if (typeof this.minViewMode === 'string') {
        switch (this.minViewMode) {
            case 'months':
                this.minViewMode = 1;
                break;
            case 'years':
                this.minViewMode = 2;
                break;
            default:
                this.minViewMode = 0;
                break;
        }
    }
    this.viewMode = options.viewMode||this.element.data('date-viewmode')||0;
    if (typeof this.viewMode === 'string') {
        switch (this.viewMode) {
            case 'months':
                this.viewMode = 1;
                break;
            case 'years':
                this.viewMode = 2;
                break;
            default:
                this.viewMode = 0;
                break;
        }
    }
    this.startViewMode = this.viewMode;
    this.weekStart = options.weekStart||this.element.data('date-weekstart')||0;
    this.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;
    this.onRender = options.onRender;
    this.fillDow();
    this.fillMonths();
    this.update();
    this.showMode();
};

DatePicker.prototype = {
    constructor: DatePicker,
    
    show: function(e) {
        this.picker.show();
        this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
        this.place();
        $(window).on('resize', $.proxy(this.place, this));
        if (e ) {
            e.stopPropagation();
            e.preventDefault();
        }
        if (!this.isInput) {
        }
        var that = this;
        $(document).on('mousedown', function(ev){
            if ($(ev.target).closest('.' + classes.component).length === 0) {
                that.hide();
            }
        });
        this.element.trigger({
            type: 'show',
            date: this.date
        });
    },
    
    hide: function(){
        this.picker.hide();
        $(window).off('resize', this.place);
        this.viewMode = this.startViewMode;
        this.showMode();
        if (!this.isInput) {
            $(document).off('mousedown', this.hide);
        }
        //this.set();
        this.element.trigger({
            type: 'hide',
            date: this.date
        });
    },
    
    set: function() {
        var formated = DPGlobal.formatDate(this.date, this.format);
        if (!this.isInput) {
            if (this.component){
                this.element.find('input').prop('value', formated);
            }
            this.element.data('date', formated);
        } else {
            this.element.prop('value', formated);
        }
    },
    
    /**
        Sets a date as value and notify with an event.
        Parameter dontNotify is only for cases where the calendar or
        some related component gets already updated but the highlighted
        date needs to be updated without create infinite recursion 
        because of notification. In other case, dont use.
    **/
    setValue: function(newDate, dontNotify) {
        if (typeof newDate === 'string') {
            this.date = DPGlobal.parseDate(newDate, this.format);
        } else {
            this.date = new Date(newDate);
        }
        this.set();
        this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
        this.fill();
        
        if (dontNotify !== true) {
            // Notify:
            this.element.trigger({
                type: 'changeDate',
                date: this.date,
                viewMode: DPGlobal.modes[this.viewMode].clsName
            });
        }
    },
    
    getValue: function() {
        return this.date;
    },
    
    moveValue: function(dir, mode) {
        // dir can be: 'prev', 'next'
        if (['prev', 'next'].indexOf(dir && dir.toLowerCase()) == -1)
            // No valid option:
            return;

        // default mode is the current one
        mode = mode ?
            DPGlobal.modesSet[mode] :
            DPGlobal.modes[this.viewMode];

        this.date['set' + mode.navFnc].call(
            this.date,
            this.date['get' + mode.navFnc].call(this.date) + 
            mode.navStep * (dir === 'prev' ? -1 : 1)
        );
        this.setValue(this.date);
        return this.date;
    },
    
    place: function(){
        var offset = this.component ? this.component.offset() : this.element.offset();
        this.picker.css({
            top: offset.top + this.height,
            left: offset.left
        });
    },
    
    update: function(newDate){
        this.date = DPGlobal.parseDate(
            typeof newDate === 'string' ? newDate : (this.isInput ? this.element.prop('value') : this.element.data('date')),
            this.format
        );
        this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
        this.fill();
    },
    
    fillDow: function(){
        var dowCnt = this.weekStart;
        var html = '<tr>';
        while (dowCnt < this.weekStart + 7) {
            html += '<th class="dow">'+DPGlobal.dates.daysMin[(dowCnt++)%7]+'</th>';
        }
        html += '</tr>';
        this.picker.find('.' + classes.days + ' thead').append(html);
    },
    
    fillMonths: function(){
        var html = '';
        var i = 0;
        while (i < 12) {
            html += '<span class="' + classes.month + '">'+DPGlobal.dates.monthsShort[i++]+'</span>';
        }
        this.picker.find('.' + classes.months + ' td').append(html);
    },
    
    fill: function() {
        /*jshint maxstatements:66, maxcomplexity:28*/
        var d = new Date(this.viewDate),
            year = d.getFullYear(),
            month = d.getMonth(),
            currentDate = this.date.valueOf();
        this.picker
        .find('.' + classes.days + ' th:eq(1)')
        .html(DPGlobal.dates.months[month] + ' ' + year);
        var prevMonth = new Date(year, month-1, 28,0,0,0,0),
            day = DPGlobal.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
        prevMonth.setDate(day);
        prevMonth.setDate(day - (prevMonth.getDay() - this.weekStart + 7)%7);
        var nextMonth = new Date(prevMonth);
        nextMonth.setDate(nextMonth.getDate() + 42);
        nextMonth = nextMonth.valueOf();
        var html = [];
        var clsName,
            prevY,
            prevM;
            
        if (this._daysCreated !== true) {
            // Create html (first time only)
       
            while(prevMonth.valueOf() < nextMonth) {
                if (prevMonth.getDay() === this.weekStart) {
                    html.push('<tr>');
                }
                clsName = this.onRender(prevMonth);
                prevY = prevMonth.getFullYear();
                prevM = prevMonth.getMonth();
                if ((prevM < month &&  prevY === year) ||  prevY < year) {
                    clsName += ' old';
                } else if ((prevM > month && prevY === year) || prevY > year) {
                    clsName += ' new';
                }
                if (prevMonth.valueOf() === currentDate) {
                    clsName += ' active';
                }
                html.push('<td class="' + classes.monthDay + ' ' + clsName+'">'+prevMonth.getDate() + '</td>');
                if (prevMonth.getDay() === this.weekEnd) {
                    html.push('</tr>');
                }
                prevMonth.setDate(prevMonth.getDate()+1);
            }
            
            this.picker.find('.' + classes.days + ' tbody').empty().append(html.join(''));
            this._daysCreated = true;
        }
        else {
            // Update days values
            
            var weekTr = this.picker.find('.' + classes.days + ' tbody tr:first-child()');
            var dayTd = null;
            while(prevMonth.valueOf() < nextMonth) {
                var currentWeekDayIndex = prevMonth.getDay() - this.weekStart;

                clsName = this.onRender(prevMonth);
                prevY = prevMonth.getFullYear();
                prevM = prevMonth.getMonth();
                if ((prevM < month &&  prevY === year) ||  prevY < year) {
                    clsName += ' old';
                } else if ((prevM > month && prevY === year) || prevY > year) {
                    clsName += ' new';
                }
                if (prevMonth.valueOf() === currentDate) {
                    clsName += ' active';
                }
                //html.push('<td class="day '+clsName+'">'+prevMonth.getDate() + '</td>');
                dayTd = weekTr.find('td:eq(' + currentWeekDayIndex + ')');
                dayTd
                .attr('class', 'day ' + clsName)
                .text(prevMonth.getDate());
                
                // Next week?
                if (prevMonth.getDay() === this.weekEnd) {
                    weekTr = weekTr.next('tr');
                }
                prevMonth.setDate(prevMonth.getDate()+1);
            }
        }

        var currentYear = this.date.getFullYear();
        
        var months = this.picker.find('.' + classes.months)
                    .find('th:eq(1)')
                        .html(year)
                        .end()
                    .find('span').removeClass('active');
        if (currentYear === year) {
            months.eq(this.date.getMonth()).addClass('active');
        }
        
        html = '';
        year = parseInt(year/10, 10) * 10;
        var yearCont = this.picker.find('.' + classes.years)
                            .find('th:eq(1)')
                                .text(year + '-' + (year + 9))
                                .end()
                            .find('td');
        
        year -= 1;
        var i;
        if (this._yearsCreated !== true) {

            for (i = -1; i < 11; i++) {
                html += '<span class="' + classes.year + (i === -1 || i === 10 ? ' old' : '')+(currentYear === year ? ' active' : '')+'">'+year+'</span>';
                year += 1;
            }
            
            yearCont.html(html);
            this._yearsCreated = true;
        }
        else {
            
            var yearSpan = yearCont.find('span:first-child()');
            for (i = -1; i < 11; i++) {
                //html += '<span class="year'+(i === -1 || i === 10 ? ' old' : '')+(currentYear === year ? ' active' : '')+'">'+year+'</span>';
                yearSpan
                .text(year)
                .attr('class', 'year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : ''));
                year += 1;
                yearSpan = yearSpan.next();
            }
        }
    },
    
    moveDate: function(dir, mode) {
        // dir can be: 'prev', 'next'
        if (['prev', 'next'].indexOf(dir && dir.toLowerCase()) == -1)
            // No valid option:
            return;
            
        // default mode is the current one
        mode = mode || this.viewMode;

        this.viewDate['set'+DPGlobal.modes[mode].navFnc].call(
            this.viewDate,
            this.viewDate['get'+DPGlobal.modes[mode].navFnc].call(this.viewDate) + 
            DPGlobal.modes[mode].navStep * (dir === 'prev' ? -1 : 1)
        );
        this.fill();
        this.set();
    },

    click: function(e) {
        /*jshint maxcomplexity:16*/
        e.stopPropagation();
        e.preventDefault();
        var target = $(e.target).closest('span, td, th');
        if (target.length === 1) {
            var month, year;
            switch(target[0].nodeName.toLowerCase()) {
                case 'th':
                    switch(target[0].className) {
                        case 'switch':
                            this.showMode(1);
                            break;
                        case 'prev':
                        case 'next':
                            this.moveDate(target[0].className);
                            break;
                    }
                    break;
                case 'span':
                    if (target.is('.' + classes.month)) {
                        month = target.parent().find('span').index(target);
                        this.viewDate.setMonth(month);
                    } else {
                        year = parseInt(target.text(), 10)||0;
                        this.viewDate.setFullYear(year);
                    }
                    if (this.viewMode !== 0) {
                        this.date = new Date(this.viewDate);
                        this.element.trigger({
                            type: 'changeDate',
                            date: this.date,
                            viewMode: DPGlobal.modes[this.viewMode].clsName
                        });
                    }
                    this.showMode(-1);
                    this.fill();
                    this.set();
                    break;
                case 'td':
                    if (target.is('.day') && !target.is('.disabled')){
                        var day = parseInt(target.text(), 10)||1;
                        month = this.viewDate.getMonth();
                        if (target.is('.old')) {
                            month -= 1;
                        } else if (target.is('.new')) {
                            month += 1;
                        }
                        year = this.viewDate.getFullYear();
                        this.date = new Date(year, month, day,0,0,0,0);
                        this.viewDate = new Date(year, month, Math.min(28, day),0,0,0,0);
                        this.fill();
                        this.set();
                        this.element.trigger({
                            type: 'changeDate',
                            date: this.date,
                            viewMode: DPGlobal.modes[this.viewMode].clsName
                        });
                    }
                    break;
            }
        }
    },
    
    mousedown: function(e){
        e.stopPropagation();
        e.preventDefault();
    },
    
    showMode: function(dir) {
        if (dir) {
            this.viewMode = Math.max(this.minViewMode, Math.min(2, this.viewMode + dir));
        }
        this.picker.find('>div').hide().filter('.' + classes.component + '-' + DPGlobal.modes[this.viewMode].clsName).show();
    }
};

$.fn.datepicker = function ( option ) {
    var vals = Array.prototype.slice.call(arguments, 1);
    var returned;
    this.each(function () {
        var $this = $(this),
            data = $this.data('datepicker'),
            options = typeof option === 'object' && option;
        if (!data) {
            $this.data('datepicker', (data = new DatePicker(this, $.extend({}, $.fn.datepicker.defaults,options))));
        }

        if (typeof option === 'string') {
            returned = data[option].apply(data, vals);
            // There is a value returned by the method?
            if (typeof(returned) !== 'undefined') {
                // Go out the loop to return the value from the first
                // element-method execution
                return false;
            }
            // Follow next loop item
        }
    });
    if (typeof(returned) !== 'undefined')
        return returned;
    else
        // chaining:
        return this;
};

$.fn.datepicker.defaults = {
    onRender: function(/*date*/) {
        return '';
    }
};
$.fn.datepicker.Constructor = DatePicker;

var DPGlobal = {
    modes: [
        {
            clsName: 'days',
            navFnc: 'Month',
            navStep: 1
        },
        {
            clsName: 'months',
            navFnc: 'FullYear',
            navStep: 1
        },
        {
            clsName: 'years',
            navFnc: 'FullYear',
            navStep: 10
        },
        {
            clsName: 'day',
            navFnc: 'Date',
            navStep: 1
        }
    ],
    dates:{
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
        daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    },
    isLeapYear: function (year) {
        return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
    },
    getDaysInMonth: function (year, month) {
        return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },
    parseFormat: function(format){
        var separator = format.match(/[.\/\-\s].*?/),
            parts = format.split(/\W+/);
        if (!separator || !parts || parts.length === 0){
            throw new Error("Invalid date format.");
        }
        return {separator: separator, parts: parts};
    },
    parseDate: function(date, format) {
        /*jshint maxcomplexity:11*/
        var parts = date.split(format.separator),
            val;
        date = new Date();
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        if (parts.length === format.parts.length) {
            var year = date.getFullYear(), day = date.getDate(), month = date.getMonth();
            for (var i=0, cnt = format.parts.length; i < cnt; i++) {
                val = parseInt(parts[i], 10)||1;
                switch(format.parts[i]) {
                    case 'dd':
                    case 'd':
                        day = val;
                        date.setDate(val);
                        break;
                    case 'mm':
                    case 'm':
                        month = val - 1;
                        date.setMonth(val - 1);
                        break;
                    case 'yy':
                        year = 2000 + val;
                        date.setFullYear(2000 + val);
                        break;
                    case 'yyyy':
                        year = val;
                        date.setFullYear(val);
                        break;
                }
            }
            date = new Date(year, month, day, 0 ,0 ,0);
        }
        return date;
    },
    formatDate: function(date, format){
        var val = {
            d: date.getDate(),
            m: date.getMonth() + 1,
            yy: date.getFullYear().toString().substring(2),
            yyyy: date.getFullYear()
        };
        val.dd = (val.d < 10 ? '0' : '') + val.d;
        val.mm = (val.m < 10 ? '0' : '') + val.m;
        date = [];
        for (var i=0, cnt = format.parts.length; i < cnt; i++) {
            date.push(val[format.parts[i]]);
        }
        return date.join(format.separator);
    },
    headTemplate: '<thead>'+
                        '<tr>'+
                            '<th class="prev">&lsaquo;</th>'+
                            '<th colspan="5" class="switch"></th>'+
                            '<th class="next">&rsaquo;</th>'+
                        '</tr>'+
                    '</thead>',
    contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
};
DPGlobal.template = '<div class="' + classes.component + '">'+
                        '<div class="' + classes.days + '">'+
                            '<table class=" table-condensed">'+
                                DPGlobal.headTemplate+
                                '<tbody></tbody>'+
                            '</table>'+
                        '</div>'+
                        '<div class="' + classes.months + '">'+
                            '<table class="table-condensed">'+
                                DPGlobal.headTemplate+
                                DPGlobal.contTemplate+
                            '</table>'+
                        '</div>'+
                        '<div class="' + classes.years + '">'+
                            '<table class="table-condensed">'+
                                DPGlobal.headTemplate+
                                DPGlobal.contTemplate+
                            '</table>'+
                        '</div>'+
                    '</div>';
DPGlobal.modesSet = {
    'date': DPGlobal.modes[3],
    'month': DPGlobal.modes[0],
    'year': DPGlobal.modes[1],
    'decade': DPGlobal.modes[2]
};

/** Public API **/
exports.DatePicker = DatePicker;
exports.defaults = DPGlobal;
exports.utils = DPGlobal;

},{}],47:[function(require,module,exports){
/**
    SmartNavBar component.
    Requires its CSS counterpart.
    
    Created based on the project:
    
    Project-Tyson
    Website: https://github.com/c2prods/Project-Tyson
    Author: c2prods
    License:
    The MIT License (MIT)
    Copyright (c) 2013 c2prods
    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**/
var $ = require('jquery');

/**
    Internal utility.
    Removes all children for a DOM node
**/
var clearNode = function (node) {
    while(node.firstChild){
        node.removeChild(node.firstChild);
    }
};

/**
    Calculates and applies the best sizing and distribution for the title
    depending on content and buttons.
    Pass in the title element, buttons must be found as siblings of it.
**/
var textboxResize = function textboxResize(el) {
    /* jshint maxstatements: 28, maxcomplexity:11 */
    
    var leftbtn = el.parentNode.querySelectorAll('.SmartNavBar-edge.left')[0];
    var rightbtn = el.parentNode.querySelectorAll('.SmartNavBar-edge.right')[0];
    if (typeof leftbtn === 'undefined') {
        leftbtn = {
            offsetWidth: 0,
            className: ''
        };
    }
    if (typeof rightbtn === 'undefined') {
        rightbtn = {
            offsetWidth: 0,
            className: ''
        };
    }
    
    var margin = Math.max(leftbtn.offsetWidth, rightbtn.offsetWidth);
    el.style.marginLeft = margin + 'px';
    el.style.marginRight = margin + 'px';
    var tooLong = (el.offsetWidth < el.scrollWidth) ? true : false;
    if (tooLong) {
        if (leftbtn.offsetWidth < rightbtn.offsetWidth) {
            el.style.marginLeft = leftbtn.offsetWidth + 'px';
            el.style.textAlign = 'right';
        } else {
            el.style.marginRight = rightbtn.offsetWidth + 'px';
            el.style.textAlign = 'left';
        }
        tooLong = (el.offsetWidth<el.scrollWidth) ? true : false;
        if (tooLong) {
            if (new RegExp('arrow').test(leftbtn.className)) {
                clearNode(leftbtn.childNodes[1]);
                el.style.marginLeft = '26px';
            }
            if (new RegExp('arrow').test(rightbtn.className)) {
                clearNode(rightbtn.childNodes[1]);
                el.style.marginRight = '26px';
            }
        }
    }
};

exports.textboxResize = textboxResize;

/**
    SmartNavBar class, instantiate with a DOM element
    representing a navbar.
    API:
    - refresh: updates the control taking care of the needed
        width for title and buttons
**/
var SmartNavBar = function SmartNavBar(el) {
    this.el = el;
    
    this.refresh = function refresh() {
        var h = $(el).children('h1').get(0);
        if (h)
            textboxResize(h);
    };

    this.refresh(); 
};

exports.SmartNavBar = SmartNavBar;

/**
    Get instances for all the SmartNavBar elements in the DOM
**/
exports.getAll = function getAll() {
    var all = $('.SmartNavBar');
    return $.map(all, function(item) { return new SmartNavBar(item); });
};

/**
    Refresh all SmartNavBar found in the document.
**/
exports.refreshAll = function refreshAll() {
    $('.SmartNavBar > h1').each(function() { textboxResize(this); });
};

},{}],48:[function(require,module,exports){
/**
    Custom Loconomics 'locale' styles for date/times.
    Its a bit more 'cool' rendering dates ;-)
**/
'use strict';

var moment = require('moment');
// Since the task of define a locale changes
// the current global locale, we save a reference
// and restore it later so nothing changed.
var current = moment.locale();

moment.locale('en-US-LC', {
    meridiemParse : /[ap]\.?\.?/i,
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'p' : 'P';
        } else {
            return isLower ? 'a' : 'A';
        }
    },
    calendar : {
        lastDay : '[Yesterday]',
        sameDay : '[Today]',
        nextDay : '[Tomorrow]',
        lastWeek : '[last] dddd',
        nextWeek : 'dddd',
        sameElse : 'M/D'
    },
    longDateFormat : {
        LT: 'h:mma',
        LTS: 'h:mm:ssa',
        L: 'MM/DD/YYYY',
        l: 'M/D/YYYY',
        LL: 'MMMM Do YYYY',
        ll: 'MMM D YYYY',
        LLL: 'MMMM Do YYYY LT',
        lll: 'MMM D YYYY LT',
        LLLL: 'dddd, MMMM Do YYYY LT',
        llll: 'ddd, MMM D YYYY LT'
    }
});

// Restore locale
moment.locale(current);

},{"moment":false}],49:[function(require,module,exports){
/** Address model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

function Address(values) {

    Model(this);
    
    this.model.defProperties({
        addressID: 0,
        addressName: '',
        jobTitleID: 0,
        userID: 0,
        addressLine1: null,
        addressLine2: null,
        postalCode: null,
        city: null, // Autofilled by server
        stateProvinceCode: null, // Autofilled by server
        stateProvinceName: null, // Autofilled by server
        countryCode: null, // ISO Alpha-2 code, Ex.: 'US'
        latitude: null,
        longitude: null,
        specialInstructions: null,
        isServiceArea: false,
        isServiceLocation: false,
        serviceRadius: 0,
        createdDate: null, // Autofilled by server
        updatedDate: null, // Autofilled by server
        kind: '' // Autofilled by server
    }, values);
    
    this.singleLine = ko.computed(function() {
        
        var list = [
            this.addressLine1(),
            this.city(),
            this.postalCode(),
            this.stateProvinceCode()
        ];
        
        return list.filter(function(v) { return !!v; }).join(', ');
    }, this);
    
    // TODO: needed? l10n? must be provided by server side?
    var countries = {
        'US': 'United States',
        'ES': 'Spain'
    };
    this.countryName = ko.computed(function() {
        return countries[this.countryCode()] || 'unknow';
    }, this);

    // Useful GPS object with the format used by Google Maps
    this.latlng = ko.computed(function() {
        return {
            lat: this.latitude(),
            lng: this.longitude()
        };
    }, this);
}

module.exports = Address;

// Public Enumeration for the 'kind' property:
Address.kind = {
    home: 'home',
    billing: 'billing',
    service: 'service'
};

},{"./Model":66,"knockout":false}],50:[function(require,module,exports){
/** Appointment model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment'),
    PricingEstimateDetail = require('./PricingEstimateDetail'),
    CalendarEvent = require('./CalendarEvent'),
    Booking = require('./Booking');
   
function Appointment(values) {
    
    Model(this);

    this.model.defProperties({
        // An appointment ever references an event, and its 'id' is a CalendarEventID
        // even if other complementary object are used as 'source'
        id: null,
        
        startTime: null,
        endTime: null,
        
        // CommonEvent fields:
        summary: 'New booking',
        description: null,

        // Fields specific for bookings
        price: 0,
        // Actual bookings fields to use on post/put
        customerUserID: null,
        pricing: {
            Model: PricingEstimateDetail,
            isArray: true
        },
        addressID: null,
        preNotesToClient: null,
        postNotesToClient: null,
        preNotesToSelf: null,
        postNotesToSelf: null,
        
        jobTitleID: 0,
        
        sourceEvent: {
            Model: CalendarEvent,
            defaultValue: null
        },
        sourceBooking: {
            Model: Booking,
            defaultValue: null
        }
        //sourceBookingRequest, maybe future?
    }, values);

    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').calendar();
        
    }, this);
    
    this.displayedStartTime = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedEndTime = ko.pureComputed(function() {
        
        return moment(this.endTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedTimeRange = ko.pureComputed(function() {
        
        return this.displayedStartTime() + '-' + this.displayedEndTime();
        
    }, this);
    
    this.itStarted = ko.pureComputed(function() {
        return (this.startTime() && new Date() >= this.startTime());
    }, this);
    
    this.itEnded = ko.pureComputed(function() {
        return (this.endTime() && new Date() >= this.endTime());
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        return (!this.id());
    }, this);
    
    this.stateHeader = ko.pureComputed(function() {
        
        var text = '';
        if (!this.isNew()) {
            if (this.itStarted()) {
                if (this.itEnded()) {
                    text = 'Completed:';
                }
                else {
                    text = 'Now:';
                }
            }
            else {
                text = 'Upcoming:';
            }
        }

        return text;
        
    }, this);
}

module.exports = Appointment;

/**
    Creates an appointment instance from a CalendarEvent model instance
**/
Appointment.fromCalendarEvent = function fromCalendarEvent(event) {
    var apt = new Appointment();
    
    // Include event in apt
    apt.id(event.calendarEventID());
    apt.startTime(event.startTime());
    apt.endTime(event.endTime());
    apt.summary(event.summary());
    apt.sourceEvent(event);
    
    return apt;
};

/**
    Creates an appointment instance from a Booking and a CalendarEvent model instances
**/
Appointment.fromBooking = function fromBooking(booking, event) {
    // Include event in apt
    var apt = Appointment.fromCalendarEvent(event);
    
    // Include booking in apt
    apt.customerUserID(booking.bookingRequest().customerUserID());
    apt.addressID(booking.bookingRequest().addressID());
    apt.jobTitleID(booking.bookingRequest().jobTitleID());
    apt.pricing(booking.bookingRequest().pricingEstimate().details());
    apt.preNotesToClient(booking.preNotesToClient());
    apt.postNotesToClient(booking.postNotesToClient());
    apt.preNotesToSelf(booking.preNotesToSelf());
    apt.postNotesToSelf(booking.postNotesToSelf());

    var prices = booking.bookingRequest() && booking.bookingRequest().pricingEstimate();
    if (prices) {
        // TODO Setting freelancer price, for customers must be
        // just totalPrice()
        apt.price(prices.totalPrice() - prices.pFeePrice());
    }

    apt.sourceBooking(booking);

    return apt;
};

/**
    Creates a list of appointment instances from the list of events and bookings.
    The bookings list must contain every booking that belongs to the events of type
    'booking' from the list of events.
**/
Appointment.listFromCalendarEventsBookings = function listFromCalendarEventsBookings(events, bookings) {
    return events.map(function(event) {
        var booking = null;
        bookings.some(function(searchBooking) {
            var found = searchBooking.confirmedDateID() === event.calendarEventID();
            if (found) {
                booking = searchBooking;
                return true;
            }
        });

        if (booking)
            return Appointment.fromBooking(booking, event);
        else
            return Appointment.fromCalendarEvent(event);
    });
};

var Time = require('../utils/Time');
/**
    Creates an Appointment instance that represents a calendar slot of
    free/spare time, for the given time range, or the full given date.
    @param options:Object {
        date:Date. Optional. Used to create a full date slot or default for start/end
            to date start or date end
        start:Date. Optional. Beggining of the slot
        end:Date. Optional. Ending of the slot
        text:string. Optional ['Free']. To allow external localization of the text.
    }
**/
Appointment.newFreeSlot = function newFreeSlot(options) {
    
    var start = options.start || new Time(options.date, 0, 0, 0),
        end = options.end || new Time(options.date, 0, 0, 0);

    return new Appointment({
        id: -2,

        startTime: start,
        endTime: end,

        summary: options.text || 'Free',
        description: null
    });
};

},{"../utils/Time":91,"./Booking":51,"./CalendarEvent":54,"./Model":66,"./PricingEstimateDetail":70,"knockout":false,"moment":false}],51:[function(require,module,exports){
/** Booking model.

    Describes a booking with related BookingRequest 
    and PricingEstimate objects.
 **/
'use strict';

var Model = require('./Model'),
    BookingRequest = require('./BookingRequest');

function Booking(values) {
    
    Model(this);

    this.model.defProperties({
        bookingID: 0,
        bookingRequestID: 0,
        confirmedDateID: null,
        totalPricePaidByCustomer: null,
        totalServiceFeesPaidByCustomer: null,
        totalPaidToFreelancer: null,
        totalServiceFeesPaidByFreelancer: null,
        bookingStatusID: null,
        pricingAdjustmentApplied: false,
        
        preNotesToClient: null,
        postNotesToClient: null,
        preNotesToSelf: null,
        postNotesToSelf: null,
        
        reviewedByFreelancer: false,
        reviewedByCustomer: false,
        
        createdDate: null,
        updatedDate: null,
        
        bookingRequest: new BookingRequest()
    }, values);
}

module.exports = Booking;

},{"./BookingRequest":52,"./Model":66}],52:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model'),
    PricingEstimate = require('./PricingEstimate');

module.exports = function BookingRequest(values) {
    
    Model(this);

    this.model.defProperties({
        bookingRequestID: 0,
        bookingTypeID: 0,
        customerUserID: 0,
        freelancerUserID: 0,
        jobTitleID: 0,
        pricingEstimateID: 0,
        bookingRequestStatusID: 0,
        
        specialRequests: null,
        preferredDateID: null,
        alternativeDate1ID: null,
        alternativeDate2ID: null,
        addressID: null,
        cancellationPolicyID: null,
        instantBooking: false,
        
        createdDate: null,
        updatedDate: null,
        
        pricingEstimate: new PricingEstimate()
    }, values);
};

},{"./Model":66,"./PricingEstimate":69}],53:[function(require,module,exports){
/** BookingSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');
    
function BookingSummary(values) {
    
    Model(this);

    this.model.defProperties({
        quantity: 0,
        concept: '',
        time: null,
        timeFormat: ' [@] h:mma'
    }, values);

    this.phrase = ko.pureComputed(function(){
        var t = this.timeFormat() && 
            this.time() && 
            moment(this.time()).format(this.timeFormat()) ||
            '';        
        return this.concept() + t;
    }, this);

    this.url = ko.pureComputed(function() {
        var url = this.time() &&
            '/calendar/' + this.time().toISOString();
        
        return url;
    }, this);
}

module.exports = BookingSummary;

},{"./Model":66,"knockout":false,"moment":false}],54:[function(require,module,exports){
/**
    Event model
**/
'use strict';

/* Example JSON (returned by the REST API):
{
  "EventID": 353,
  "UserID": 141,
  "EventTypeID": 3,
  "Summary": "Housekeeper services for John D.",
  "AvailabilityTypeID": 3,
  "StartTime": "2014-03-25T08:00:00Z",
  "EndTime": "2014-03-25T18:00:00Z",
  "Kind": 0,
  "IsAllDay": false,
  "TimeZone": "01:00:00",
  "Location": "null",
  "UpdatedDate": "2014-10-30T15:44:49.653",
  "CreatedDate": null,
  "Description": "test description of a REST event",
  "RecurrenceRule": {
    "FrequencyTypeID": 502,
    "Interval": 1,
    "Until": "2014-07-01T00:00:00",
    "Count": null,
    "Ending": "date",
    "SelectedWeekDays": [
      1,
    ],
    "MonthlyWeekDay": false,
    "Incompatible": false,
    "TooMany": false
  },
  "RecurrenceOccurrences": null,
  "ReadOnly": false
}*/

function RecurrenceRule(values) {
    Model(this);
    
    this.model.defProperties({
        frequencyTypeID: 0,
        interval: 1, //:Integer
        until: null, //:Date
        count: null, //:Integer
        ending: null, // :string Possible values allowed: 'never', 'date', 'ocurrences'
        selectedWeekDays: [], // :integer[] 0:Sunday
        monthlyWeekDay: false,
        incompatible: false,
        tooMany: false
    }, values);
}

function RecurrenceOccurrence(values) {
    Model(this);
    
    this.model.defProperties({
        startTime: null, //:Date
        endTime: null //:Date
    }, values);
}

var ko = require('knockout'),
    Model = require('./Model');
   
function CalendarEvent(values) {
    
    Model(this);
    
    // Special values: dates must be converted
    // to a Date object. They come as ISO string
    // TODO: Make this something generic, or even in Model definitions,
    // and use for updated/createdDate around all the project
    if (values) {
        values.startTime = values.startTime && new Date(Date.parse(values.startTime)) || null;
        values.endTime = values.endTime && new Date(Date.parse(values.endTime)) || null;
    }

    this.model.defProperties({
        calendarEventID: 0,
        userID: 0,
        eventTypeID: 3,
        summary: '',
        availabilityTypeID: 0,
        startTime: null,
        endTime: null,
        kind: 0,
        isAllDay: false,
        timeZone: 'Z',
        location: null,
        updatedDate: null,
        createdDate: null,
        description: '',
        readOnly: false
    }, values);

    this.recurrenceRule = ko.observable(
        values && 
        values.recurrenceRule && 
        new RecurrenceRule(values.recurrenceRule)
    );
    this.recurrenceOccurrences = ko.observableArray([]); //:RecurrenceOccurrence[]
    if (values && values.recurrenceOccurrences) {
        values.recurrenceOccurrences.forEach(function(occurrence) {
            
            this.RecurrenceOccurrences.push(new RecurrenceOccurrence(occurrence));
            
        }.bind(this));
    }
}

module.exports = CalendarEvent;

CalendarEvent.RecurrenceRule = RecurrenceRule;
CalendarEvent.RecurrenceOccurrence = RecurrenceOccurrence;
},{"./Model":66,"knockout":false}],55:[function(require,module,exports){
/**
    CalendarSyncing model.
 **/
'use strict';

var Model = require('./Model');

function CalendarSyncing(values) {

    Model(this);

    this.model.defProperties({
        icalExportUrl: '',
        icalImportUrl: ''
    }, values);
}

module.exports = CalendarSyncing;

},{"./Model":66}],56:[function(require,module,exports){
/** Customer model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

function Customer(values) {
    
    Model(this);
    
    this.model.defProperties({
        customerUserID: 0,
        
        firstName: '',
        lastName: '',
        secondLastName: '',
        email: '',
        phone: null,
        canReceiveSms: false,
        birthMonthDay: null,
        birthMonth: null,
        
        notesAboutCustomer: null,
        
        createdDate: null,
        updatedDate: null,
        editable: false
    }, values);

    this.fullName = ko.pureComputed(function() {
        return ((this.firstName() || '') + ' ' + (this.lastName() || ''));
    }, this);
    
    this.birthDay = ko.pureComputed(function() {
        if (this.birthMonthDay() &&
            this.birthMonth()) {
            
            // TODO i10n
            return this.birthMonth() + '/' + this.birthMonthDay();
        }
        else {
            return null;
        }
    }, this);
}

module.exports = Customer;

},{"./Model":66,"knockout":false}],57:[function(require,module,exports){
/**
    Freelancer Pricing model: manages an individual
    pricing/package from the user and a specific job title.
**/
'use strict';

var Model = require('./Model'),
    ko = require('knockout'),
    numeral = require('numeral');

function FreelancerPricing(values) {
    
    Model(this);
    
    this.model.defProperties({
        freelancerPricingID: 0,
        freelancerUserID: 0,
        jobTitleID: 0,
        pricingTypeID: 0,
        name: '',
        description: null,
        price: null,
        serviceDurationMinutes: null,
        firstTimeClientsOnly: false,
        numberOfSessions: 1,
        priceRate: null,
        priceRateUnit: 'hour',
        // Special property, not in source data just only an explicit
        // way to avoid validation of priceRate if not explicit value set
        noPriceRate: false,
        isPhone: false,
        // Array of integers, IDs of serviceAttributes
        serviceAttributes: [],
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['freelancerPricingID']);
    
    // One way effect: set priceRate to null when setting on noPriceRate
    // But nothing on off and no other relations to avoid bad side effects.
    this.noPriceRate.subscribe(function(enabled) {
        if (enabled === true) {
            this.priceRate(null);
        }
    }, this);
    
    /**
        Ask for a refresh of the noPriceRate, that must be 'true' if the record exists and
        has no priceRate (to remember the previous value set by the user about noPriceRate).
        It ensure that the internal timestamp keep untouched.
        Cannot be automatic, so need to be called manually after a data load that does not
        want to reflect this change as a data change.
    **/
    this.refreshNoPriceRate = function refreshNoPriceRate() {
        // Not To State Price Rate: if is a saved pricing, mark the noPriceRate if price rate is
        // null or 0; cannot be done with a subscription on priceRate changes because will have
        // the bad side effect of auto mark noPriceRate on setting 0 on priceRate, breaking the
        // explicit purpose of the noPriceRate checkbox:
        if (this.freelancerPricingID() && (this.priceRate() |0) <= 0) {
            var ts = this.model.dataTimestamp();
            this.noPriceRate(true);
            // Set again timestamp so the model appear as untouched.
            this.model.dataTimestamp(ts);
        }
    };

    // Alternative edition of the serviceDurationMinutes fields:
    // Splited as hours and minutes
    var is = require('is_js');
    this.durationHoursPart = ko.pureComputed({
        read: function() {
            var fullMinutes = this.serviceDurationMinutes();
            
            if (is.not.number(fullMinutes))
                return null;

            return ((fullMinutes|0) / 60) |0;
        },
        write: function(hours) {
            var minutes = this.durationMinutesPart() |0;
            // Value comes from text
            hours = parseInt(hours, 10);
            if (is.not.number(hours))
                this.serviceDurationMinutes(null);
            else
                this.serviceDurationMinutes((hours|0) * 60 + minutes);
        },
        owner: this
    });
    this.durationMinutesPart = ko.pureComputed({
        read: function() {
            var fullMinutes = this.serviceDurationMinutes();

            if (is.not.number(fullMinutes))
                return null;

            return (fullMinutes|0) % 60;
        },
        write: function(minutes) {
            var hours = this.durationHoursPart() |0;
            // Value comes from text
            minutes = parseInt(minutes, 10);
            if (is.not.number(minutes))
                this.serviceDurationMinutes(null);
            else
                this.serviceDurationMinutes(hours * 60 + (minutes|0));
        },
        owner: this
    });
    
    
    /// Visual representation of several fields
    
    this.durationText = ko.pureComputed(function() {
        var minutes = this.serviceDurationMinutes() || 0;
        // TODO: l10n
        return minutes ? numeral(minutes).format('0,0') + ' minutes' : '';
    }, this);
    
    this.sessionsAndDuration = ko.pureComputed(function() {
        var sessions = this.numberOfSessions(),
            dur = this.durationText();
        if (sessions > 1)
            // TODO: l10n
            return sessions + ' sessions, ' + dur;
        else
            return dur;
    }, this);

    this.displayedPrice = ko.pureComputed(function() {
        var price = this.price(),
            rate = this.priceRate(),
            unit = this.priceRateUnit(),
            result = price || rate;
        // Formatting
        result = numeral(result).format('$0,0');
        // If is not price but rate, add unit
        if (!price && rate && unit) {
            result += '/' + unit;
        }
        return result;
    }, this);
}

module.exports = FreelancerPricing;

},{"./Model":66,"is_js":false,"knockout":false,"numeral":false}],58:[function(require,module,exports){
/** GetMore model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    ListViewItem = require('./ListViewItem');

function GetMore(values) {

    Model(this);

    this.model.defProperties({
        availability: false,
        payments: false,
        profile: false,
        coop: true
    }, values);
    
    var availableItems = {
        availability: new ListViewItem({
            contentLine1: 'Complete your availability to create a cleaner calendar',
            markerIcon: 'glyphicon glyphicon-calendar',
            actionIcon: 'glyphicon glyphicon-chevron-right'
        }),
        payments: new ListViewItem({
            contentLine1: 'Start accepting payments through Loconomics',
            markerIcon: 'glyphicon glyphicon-usd',
            actionIcon: 'glyphicon glyphicon-chevron-right'
        }),
        profile: new ListViewItem({
            contentLine1: 'Activate your profile in the marketplace',
            markerIcon: 'glyphicon glyphicon-user',
            actionIcon: 'glyphicon glyphicon-chevron-right'
        }),
        coop: new ListViewItem({
            contentLine1: 'Learn more about our cooperative',
            actionIcon: 'glyphicon glyphicon-chevron-right'
        })
    };

    this.items = ko.pureComputed(function() {
        var items = [];
        
        Object.keys(availableItems).forEach(function(key) {
            
            if (this[key]())
                items.push(availableItems[key]);
        }.bind(this));

        return items;
    }, this);
}

module.exports = GetMore;

},{"./ListViewItem":61,"./Model":66,"knockout":false}],59:[function(require,module,exports){
/** JobTitle model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    JobTitlePricingType = require('./JobTitlePricingType');

function JobTitle(values) {
    
    Model(this);
    
    this.model.defProperties({
        jobTitleID: 0,
        singularName: '',
        pluralName: '',
        aliases: '',
        description: null,
        searchDescription: null,
        createdDate: null,
        updatedDate: null
    }, values);

    this.model.defID(['jobTitleID']);

    // TODO: review if, not registered as a property, the list is updated
    // on syncs by using model.updateWith

    // Pricing Types relationship,
    // collection of JobTitlePricingType entities
    this.pricingTypes = ko.observableArray([]);
    if (values && values.pricingTypes) {
        values.pricingTypes.forEach(function(jobpricing) {
            this.pricingTypes.push(new JobTitlePricingType(jobpricing));
        }.bind(this));
    }
}

module.exports = JobTitle;

},{"./JobTitlePricingType":60,"./Model":66,"knockout":false}],60:[function(require,module,exports){
/**
    Defines the relationship between a JobTitle and a PricingType.
**/
'use strict';

var Model = require('./Model');

function JobTitlePricingType(values) {

    Model(this);
    
    this.model.defProperties({
        pricingTypeID: 0,
        // NOTE: Client Type is mostly unused today but exists
        // on all database records. It uses the default value
        // of 1 all the time for now.
        clientTypeID: 1,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['pricingTypeID', 'clientTypeID']);
}

module.exports = JobTitlePricingType;

},{"./Model":66}],61:[function(require,module,exports){
/** ListViewItem model.

    Describes a generic item of a
    ListView component.
 **/
'use strict';

var Model = require('./Model');

function ListViewItem(values) {
    
    Model(this);

    this.model.defProperties({
        markerLine1: null,
        markerLine2: null,
        markerIcon: null,
        
        contentLine1: '',
        contentLine2: null,
        link: '#',

        actionIcon: null,
        actionText: null,
        
        classNames: ''

    }, values);
}

module.exports = ListViewItem;

},{"./Model":66}],62:[function(require,module,exports){
/** MailFolder model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    _ = require('lodash');

function MailFolder(values) {

    Model(this);

    this.model.defProperties({
        messages: [],
        topNumber: 10
    }, values);
    
    this.top = ko.pureComputed(function top(num) {
        if (num) this.topNumber(num);
        return _.first(this.messages(), this.topNumber());
    }, this);
}

module.exports = MailFolder;

},{"./Model":66,"knockout":false,"lodash":false}],63:[function(require,module,exports){
/** MarketplaceProfile model **/
'use strict';

var Model = require('./Model');

function MarketplaceProfile(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        
        publicBio: '',
        freelancerProfileUrlSlug: '',
        // This is a server-side computed variable (read-only for the user) for a Loconomics address
        // created using the freelancerProfileUrlSlug if any or the fallback system URL.
        freelancerProfileUrl: '',
        // Specify an external website of the freelancer.
        freelancerWebsiteUrl: '',
        // Server-side generated code that allows to identificate special booking requests
        // from the book-me-now button. The server ensures that there is ever a value on this for freelancers.
        bookCode: '',

        createdDate: null,
        updatedDate: null
    }, values);
}

module.exports = MarketplaceProfile;

},{"./Model":66}],64:[function(require,module,exports){
/** Message model.

    Describes a message that belongs to a Thread.
    A message could be of different types,
    as inquiries, bookings, booking requests.
 **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');

function Message(values) {
    
    Model(this);

    this.model.defProperties({
        messageID: 0,
        threadID: 0,
        sentByUserID: null,
        typeID: null,
        auxT: null,
        auxID: null,
        bodyText: '',
        
        createdDate: null,
        updatedDate: null
    }, values);
    
    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        return moment(this.createdDate()).locale('en-US-LC').calendar();
    }, this);
    
    this.displayedTime = ko.pureComputed(function() {
        return moment(this.createdDate()).locale('en-US-LC').format('LT');
    }, this);
}

module.exports = Message;

},{"./Model":66,"knockout":false,"moment":false}],65:[function(require,module,exports){
/** Message model.

    Describes a message from a MailFolder.
    A message could be of different types,
    as inquiries, bookings, booking requests.
 **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');

function MessageView(values) {
    
    Model(this);

    this.model.defProperties({
        id: 0,
        createdDate: null,
        updatedDate: null,
        
        subject: '',
        content: null,
        link: '#',

        actionIcon: null,
        actionText: null,
        
        classNames: ''

    }, values);
    
    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        
        return moment(this.createdDate()).locale('en-US-LC').calendar();
        
    }, this);
    
    this.displayedTime = ko.pureComputed(function() {
        
        return moment(this.createdDate()).locale('en-US-LC').format('LT');
        
    }, this);
}

module.exports = MessageView;

/**
    Creates a MessageView instance from a Thread instance.
    It's better to have almost one message in the thread (the latest
    one first, or the one to highlight) to build a
    more detailed MessageView
**/
MessageView.fromThread = function(thread) {
    
    var msg = thread.messages();
    msg = msg && msg[0] || null;
    
    return new MessageView({
        id: thread.threadID(),
        createdDate: thread.createdDate(),
        updatedDate: thread.updatedDate(),
        subject: thread.subject(),
        content: msg && msg.bodyText() || '',
        link: '#!/conversation/' + thread.threadID(),
        actionIcon: 'glyphicon glyphicon-share-alt',
        actionText: '' // Example: 'ListView-item--tag-warning'
    });
};

},{"./Model":66,"knockout":false,"moment":false}],66:[function(require,module,exports){
/**
    Model class to help build models.

    Is not exactly an 'OOP base' class, but provides
    utilities to models and a model definition object
    when executed in their constructors as:
    
    '''
    function MyModel() {
        Model(this);
        // Now, there is a this.model property with
        // an instance of the Model class, with 
        // utilities and model settings.
    }
    '''
    
    That auto creation of 'model' property can be avoided
    when using the object instantiation syntax ('new' keyword):
    
    '''
    var model = new Model(obj);
    // There is no a 'obj.model' property, can be
    // assigned to whatever property or nothing.
    '''
**/
'use strict';
var ko = require('knockout');
ko.mapping = require('knockout.mapping');
var $ = require('jquery');
var clone = function(obj) { return $.extend(true, {}, obj); };
var cloneValue = function(val, deepCopy) {
    /*jshint maxcomplexity: 10*/
    if (typeof(val) === 'object') {
        // A Date object is a special case: even being
        // an object, treat as a basic type, being copied as
        // a new instance independent of the deepCopy option
        if (val instanceof Date) {
            // A date clone
            return new Date(val);
        }
        else if (deepCopy === true) {
            if (val instanceof Array) {
                return val.map(function(item) {
                    return cloneValue(item, true);
                });
            }
            else if (val === null) {
                return null;
            }
            else if (val && val.model instanceof Model) {
                // A model copy
                return val.model.toPlainObject(deepCopy);
            }
            else {
                // Plain 'standard' object clone
                return clone(val);
            }
        }
        else if (deepCopy === false) {
            // Shallow copy
            return val;
        }
        // On else, left undefined, no references, no clones,
        // discarded value
        return undefined;
    }
    else {
        // A basic type value is already copied/cloned by javascript
        // on every assignment
        return val;
    }
};

function Model(modelObject) {
    
    if (!(this instanceof Model)) {
        // Executed as a function, it must create
        // a Model instance
        var model = new Model(modelObject);
        // and register automatically as part
        // of the modelObject in 'model' property
        modelObject.model = model;
        
        // Returns the instance
        return model;
    }
 
    // It includes a reference to the object
    this.modelObject = modelObject;
    // It maintains a list of properties and fields
    this.propertiesList = [];
    this.fieldsList = [];
    this.propertiesDefs = {};
    this.fieldsDefs = {};
    // It allow setting the 'ko.mapping.fromJS' mapping options
    // to control conversions from plain JS objects when 
    // 'updateWith'.
    this.mappingOptions = {};
    
    // Timestamp with the date of last change
    // in the data (automatically updated when changes
    // happens on properties; fields or any other member
    // added to the model cannot be observed for changes,
    // requiring manual updating with a 'new Date()', but is
    // better to use properties.
    // Its rated to zero just to avoid that consecutive
    // synchronous changes emit lot of notifications, specially
    // with bulk tasks like 'updateWith'.
    this.dataTimestamp = ko.observable(new Date()).extend({ rateLimit: 0 });
}

module.exports = Model;

/**
    Internal utility to map a value given its property/field
    definition
**/
function prepareValueByDef(val, def) {
    if (def.isArray && 
        !Array.isArray(val)) {
        if (typeof(val) !== 'undefined')
            val = [val];
        else
            val = [];
    }
    if (def && def.Model) {
        if (Array.isArray(val)) {
            val = val.map(function(item) {
                if (item instanceof def.Model ||
                    item === null ||
                    typeof(item) === 'undefined') {
                    // 'as is'
                    return item;
                }
                else {
                    return new def.Model(item);
                }
            });
        }
        else {
            if (!(val instanceof def.Model) &&
                val !== null &&
                typeof(val) !== 'undefined') {
                val = new def.Model(val);
            }
        }
    }
    return val;
}

function createDef(givenVal, initialVal) {
    
    var def,
        isModel = givenVal && givenVal.model instanceof Model,
        isArray = Array.isArray(givenVal),
        isObject = typeof(givenVal) === 'object' && !(givenVal instanceof Date);

    if (givenVal !== null && !isModel && isObject && !isArray) {
        def = givenVal;
    }
    else {
        def = {
            defaultValue: givenVal,
            isArray: isArray
        };
        if (isModel)
            def.Model = givenVal.constructor;
    }
    
    initialVal = typeof(initialVal) === 'undefined' ? def.defaultValue : initialVal;
    def.initialValue = prepareValueByDef(initialVal, def);
    
    return def;
}

/**
    Define observable properties using the given
    properties object definition that includes de default values,
    and some optional initialValues (normally that is provided externally
    as a parameter to the model constructor, while default values are
    set in the constructor).
    That properties become members of the modelObject, simplifying 
    model definitions.
    
    It uses Knockout.observable and observableArray, so properties
    are funtions that reads the value when no arguments or sets when
    one argument is passed of.
**/
Model.prototype.defProperties = function defProperties(properties, initialValues) {

    initialValues = initialValues || {};

    var modelObject = this.modelObject,
        propertiesList = this.propertiesList,
        defs = this.propertiesDefs,
        dataTimestamp = this.dataTimestamp;

    Object.keys(properties).forEach(function(key) {
        
        // Create and register definition
        var def = createDef(properties[key], initialValues[key]);
        defs[key] = def;

        // Create the observable property
        modelObject[key] = Array.isArray(def.initialValue) ?
            ko.observableArray(def.initialValue) :
            ko.observable(def.initialValue);

        // Remember default
        modelObject[key]._defaultValue = def.defaultValue;
        // remember initial
        modelObject[key]._initialValue = def.initialValue;    
        
        // Add subscriber to update the timestamp on changes
        modelObject[key].subscribe(function() {
            dataTimestamp(new Date());
        });
        
        // Add to the internal registry
        propertiesList.push(key);
    });
    
    // Update timestamp after the bulk creation.
    dataTimestamp(new Date());
};

/**
    Define fields as plain members of the modelObject using
    the fields object definition that includes default values,
    and some optional initialValues.
    
    Its like defProperties, but for plain js values rather than observables.
**/
Model.prototype.defFields = function defFields(fields, initialValues) {

    initialValues = initialValues || {};

    var modelObject = this.modelObject,
        defs = this.fieldsDefs,
        fieldsList = this.fieldsList;

    Object.keys(fields).each(function(key) {
        
        // Create and register definition
        var def = createDef(fields[key], initialValues[key]);
        defs[key] = def;
        
        // Create field with initial value
        modelObject[key] = def.initialValue;
        
        // Add to the internal registry
        fieldsList.push(key);
    });
};

/**
    Store the list of fields that make the ID/primary key
    and create an alias 'id' property that returns the
    value for the ID field or array of values when multiple
    fields.
**/
Model.prototype.defID = function defID(fieldsNames) {
    
    // Store the list
    this.idFieldsNames = fieldsNames;
    
    // Define ID observable
    if (fieldsNames.length === 1) {
        // Returns single value
        var field = fieldsNames[0];
        this.modelObject.id = ko.pureComputed(function() {
            return this[field]();
        }, this.modelObject);
    }
    else {
        this.modelObject.id = ko.pureComputed(function() {
            return fieldsNames.map(function(fieldName) {
                return this[fieldName]();
            }.bind(this));
        }, this.modelObject);
    }
};

/**
    Allows to register a property (previously defined) as 
    the model timestamp, so gets updated on any data change
    (keep in sync with the internal dataTimestamp).
**/
Model.prototype.regTimestamp = function regTimestampProperty(propertyName) {

    var prop = this.modelObject[propertyName];
    if (typeof(prop) !== 'function') {
        throw new Error('There is no observable property with name [' + 
                        propertyName + 
                        '] to register as timestamp.'
       );
    }
    // Add subscriber on internal timestamp to keep
    // the property updated
    this.dataTimestamp.subscribe(function(timestamp) {
        prop(timestamp);
    });
};

/**
    Returns a plain object with the properties and fields
    of the model object, just values.
    
    @param deepCopy:bool If left undefined, do not copy objects in
    values and not references. If false, do a shallow copy, setting
    up references in the result. If true, to a deep copy of all objects.
**/
Model.prototype.toPlainObject = function toPlainObject(deepCopy) {

    var plain = {},
        modelObj = this.modelObject;

    function setValue(property, val) {
        var clonedValue = cloneValue(val, deepCopy);
        if (typeof(clonedValue) !== 'undefined') {
            plain[property] = clonedValue;
        }
    }

    this.propertiesList.forEach(function(property) {
        // Properties are observables, so functions without params:
        var val = modelObj[property]();

        setValue(property, val);
    });

    this.fieldsList.forEach(function(field) {
        // Fields are just plain object members for values, just copy:
        var val = modelObj[field];

        setValue(field, val);
    });

    return plain;
};

Model.prototype.updateWith = function updateWith(data, deepCopy) {
    
    // We need a plain object for 'fromJS'.
    // If is a model, extract their properties and fields from
    // the observables (fromJS), so we not get computed
    // or functions, just registered properties and fields
    var timestamp = null;
    if (data && data.model instanceof Model) {

        // We need to set the same timestamp, so
        // remember for after the fromJS
        timestamp = data.model.dataTimestamp();
        
        // Replace data with a plain copy of itself
        data = data.model.toPlainObject(deepCopy);
    }

    var target = this.modelObject,
        defs = this.propertiesDefs;
    this.propertiesList.forEach(function(property) {
        var val = data[property],
            def = defs[property];
        if (typeof(val) !== 'undefined') {
            target[property](prepareValueByDef(val, def));
        }
    });

    defs = this.fieldsDefs;
    this.fieldsList.forEach(function(field) {
        var val = data[field],
            def = defs[field];
        if (typeof(val) !== 'undefined') {
            target[field] = prepareValueByDef(val, def);
        }
    });

    // Same timestamp if any
    if (timestamp)
        this.modelObject.model.dataTimestamp(timestamp);
};

/**
    Given a plain object in a accepted import structure
    (never a Model instance), it maps
    the data to the object following a set of mapping options
    of ko.mapping.
    If the data is a representation of the model by 'toPlainObject'
    then use 'updateWith' better.
    
    TODO: Review, not used still, no sure if really useful to depend
    on ko.mapping and this.
**/
Model.prototype.mapData = function mapData(data, optionalMapping) {
    ko.mapping.fromJS(data, optionalMapping || this.mappingOptions, this.modelObject);
};

Model.prototype.clone = function clone(data, deepCopy) {
    // Get a plain object with the object data
    var plain = this.toPlainObject(deepCopy);
    // Create a new model instance, using the source plain object
    // as initial values
    var cloned = new this.modelObject.constructor(plain);
    if (data) {
        // Update the cloned with the provided plain data used
        // to replace values on the cloned one, for quick one-step creation
        // of derived objects.
        cloned.model.updateWith(data);
    }
    else {
        // Since there is no initial differential data, ensure the
        // same timestamp since the clone is still identical to the source
        cloned.model.dataTimestamp(this.modelObject.model.dataTimestamp());
    }
    // Cloned model ready:
    return cloned;
};

/**
    Updates the dataTimestamp to the current unique datetime,
    so the model appear as touched/updated, even if not data change.
    Useful sometimes to make a difference from a cloned instance
    so appear different.
    NOTE: the datetime set is not exactly the current one, is the current
    number of milliseconds plus one,
    to ensure that the timestamp is different on edge cases where this
    method is called just after a creation or clonation, because the way
    javascript works and the limited milliseconds precision of the Date object
    there is a chance that the 'touched' date will be the same as before,
    thats avoided with this simple trick, so remains 'unique' in the current execution.
**/
Model.prototype.touch = function touch() {
    // We use the function way to get milliseconds, add 1 and create instance
    this.dataTimestamp(new Date(Date() + 1));
};

/**
    Replaces all the properties and fields data in the model object
    with the default ones of the constructor, plus optional new preset data.
**/
Model.prototype.reset = function reset(presets) {
    
    var newInstance = new this.modelObject.constructor(presets);

    this.updateWith(newInstance, true);
};

},{"knockout":false,"knockout.mapping":false}],67:[function(require,module,exports){
/** PerformanceSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    ListViewItem = require('./ListViewItem'),
    moment = require('moment'),
    numeral = require('numeral');

function PerformanceSummary(values) {

    Model(this);

    values = values || {};
    
    // TODO: define earnings and timeBooking as properties with def.Model?

    this.earnings = new Earnings(values.earnings);
    
    var earningsLine = new ListViewItem();
    earningsLine.markerLine1 = ko.computed(function() {
        var num = numeral(this.currentAmount()).format('$0,0');
        return num;
    }, this.earnings);
    earningsLine.contentLine1 = ko.computed(function() {
        return this.currentConcept();
    }, this.earnings);
    earningsLine.markerLine2 = ko.computed(function() {
        var num = numeral(this.nextAmount()).format('$0,0');
        return num;
    }, this.earnings);
    earningsLine.contentLine2 = ko.computed(function() {
        return this.nextConcept();
    }, this.earnings);
    

    this.timeBooked = new TimeBooked(values.timeBooked);

    var timeBookedLine = new ListViewItem();
    timeBookedLine.markerLine1 = ko.computed(function() {
        var num = numeral(this.percent()).format('0%');
        return num;
    }, this.timeBooked);
    timeBookedLine.contentLine1 = ko.computed(function() {
        return this.concept();
    }, this.timeBooked);
    
    
    this.items = ko.pureComputed(function() {
        var items = [];
        
        items.push(earningsLine);
        items.push(timeBookedLine);

        return items;
    }, this);
}

module.exports = PerformanceSummary;

function Earnings(values) {

    Model(this);
    
    this.model.defProperties({
    
         currentAmount: 0,
         currentConceptTemplate: 'already paid this month',
         nextAmount: 0,
         nextConceptTemplate: 'projected {month} earnings'

    }, values);
    
    this.currentConcept = ko.pureComputed(function() {

        var month = moment().format('MMMM');
        return this.currentConceptTemplate().replace(/\{month\}/, month);

    }, this);

    this.nextConcept = ko.pureComputed(function() {

        var month = moment().add(1, 'month').format('MMMM');
        return this.nextConceptTemplate().replace(/\{month\}/, month);

    }, this);
}

function TimeBooked(values) {

    Model(this);
    
    this.model.defProperties({
    
        percent: 0,
        conceptTemplate: 'of available time booked in {month}'
    
    }, values);
    
    this.concept = ko.pureComputed(function() {

        var month = moment().add(1, 'month').format('MMMM');
        return this.conceptTemplate().replace(/\{month\}/, month);

    }, this);
}

},{"./ListViewItem":61,"./Model":66,"knockout":false,"moment":false,"numeral":false}],68:[function(require,module,exports){
/** Position model.
 **/
'use strict';

var Model = require('./Model');

function Position(values) {
    
    Model(this);

    this.model.defProperties({
        positionID: 0,
        positionSingular: '',
        positionPlural: '',
        description: '',
        active: true

    }, values);
}

module.exports = Position;

},{"./Model":66}],69:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model'),
    PricingEstimateDetail = require('./PricingEstimateDetail');

module.exports = function PricingEstimate(values) {
    
    Model(this);

    this.model.defProperties({
        pricingEstimateID: 0,
        pricingEstimateRevision: 0,
        serviceDurationHours: null,
        firstSessionDurationHours: null,
        subtotalPrice: null,
        feePrice: null,
        totalPrice: null,
        pFeePrice: null,
        subtotalRefunded: null,
        feeRefunded: null,
        totalRefunded: null,
        dateRefunded: null,
        
        createdDate: null,
        updatedDate: null,
        
        details: {
            Model: PricingEstimateDetail,
            isArray: true
        }
    }, values);
};

},{"./Model":66,"./PricingEstimateDetail":70}],70:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model');

module.exports = function PricingEstimateDetail(values) {
    
    Model(this);

    this.model.defProperties({
        freelancerPricingID: 0,
        freelancerPricingDataInput: null,
        customerPricingDataInput: null,
        hourlyPrice: null,
        subtotalPrice: null,
        feePrice: null,
        totalPrice: null,
        serviceDurationHours: null,
        firstSessionDurationHours: null,
        
        createdDate: null,
        updatedDate: null
    }, values);
};

},{"./Model":66}],71:[function(require,module,exports){
/**
    Pricing Type model
**/
'use strict';

var Model = require('./Model');

function PricingType(values) {
    
    Model(this);
    
    this.model.defProperties({
        pricingTypeID: 0,
        singularName: '',
        pluralName: '',
        slugName: '',
        addNewLabel: null,
        freelancerDescription: null,
        // PriceCalculationType enumeration value:
        priceCalculation: null,
        isAddon: false,
        
        // Form Texts
        namePlaceHolder: null,
        suggestedName: null,
        fixedName: null,
        durationLabel: null,
        priceLabel: null,
        priceNote: null,
        firstTimeClientsOnlyLabel: null,
        descriptionPlaceHolder: null,
        priceRateQuantityLabel: null,
        priceRateUnitLabel: null,
        noPriceRateLabel: null,
        numberOfSessionsLabel: null,
        inPersonPhoneLabel: null,
        
        // Action And Validation Texts
        successOnDelete: null,
        errorOnDelete: null,
        successOnSave: null,
        errorOnSave: null,
        priceRateIsRequiredValidationError: null,
        priceRateUnitIsRequiredValidationError: null,
        
        // Help Texts
        learnMoreLabel: null,
        learnMoreText: null,
        priceRateLearnMoreLabel: null,
        priceRateLearnMoreText: null,
        noPriceRateLearnMoreLabel: null,
        noPriceRateLearnMoreText: null,
        
        // Additional configuration
        requireDuration: false,
        includeServiceAttributes: false,
        includeSpecialPromotion: false,
        
        // List Texts
        /// SummaryFormat is the default format for summaries (required),
        /// other formats are good for better detail, but depends
        /// on other options configured per type.
        /// Wildcards:
        /// {0}: duration
        /// {1}: sessions
        /// {2}: inperson/phone
        summaryFormat: null,
        summaryFormatMultipleSessions: null,
        summaryFormatNoDuration: null,
        summaryFormatMultipleSessionsNoDuration: null,
        withoutServiceAttributesCustomerMessage: null,
        withoutServiceAttributesFreelancerMessage: null,
        firstTimeClientsOnlyListText: null,
        priceRateQuantityListLabel: null,
        priceRateUnitListLabel: null,
        noPriceRateListMessage: null,
        
        // Booking/PricingEstimate Texts
        /// NameAndSummaryFormat is the default format for summaries with package name (required),
        /// other formats are good for better detail, but depends
        /// on other options configured per type.
        /// Wildcards:
        /// {0}: package name
        /// {1}: duration
        /// {2}: sessions
        /// {3}: inperson/phone
        nameAndSummaryFormat: null,
        nameAndSummaryFormatMultipleSessions: null,
        nameAndSummaryFormatNoDuration: null,
        nameAndSummaryFormatMultipleSessionsNoDuration: null,
        
        // Record maintenance
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['pricingTypeID']);
}

module.exports = PricingType;

// Enumeration:
var PriceCalculationType = {
    FixedPrice: 1,
    HourlyPrice: 2
};

PricingType.PriceCalculationType = PriceCalculationType;

},{"./Model":66}],72:[function(require,module,exports){
/**
    PrivacySettings model
**/
'use strict';

var Model = require('./Model');

function PrivacySettings(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        smsBookingCommunication: false,
        phoneBookingCommunication: false,
        loconomicsCommunityCommunication: false,
        loconomicsDbmCampaigns: false,
        profileSeoPermission: false,
        loconomicsMarketingCampaigns: false,
        coBrandedPartnerPermissions: false,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['userID']);
}

module.exports = PrivacySettings;

},{"./Model":66}],73:[function(require,module,exports){
/**
    SchedulingPreferences model.
 **/
'use strict';

var Model = require('./Model');

function SchedulingPreferences(values) {
    
    Model(this);

    this.model.defProperties({
        advanceTime: 24,
        betweenTime: 0,
        incrementsSizeInMinutes: 15
    }, values);
}

module.exports = SchedulingPreferences;

},{"./Model":66}],74:[function(require,module,exports){
/**
    SimplifiedWeeklySchedule model.
    
    Its 'simplified' because it provides an API
    for simple time range per week day,
    a pair of from-to times.
    Good for current simple UI.
    
    The original weekly schedule defines the schedule
    in 15 minutes slots, so multiple time ranges can
    exists per week day, just marking each slot
    as available or unavailable. The AppModel
    will fill this model instances properly making
    any conversion from/to the source data.
 **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

/**
    Submodel that is used on the SimplifiedWeeklySchedule
    defining a single week day availability range.
    A full day must have values from:0 to:1440, never
    both as zero because thats considered as not available,
    so is better to use the isAllDay property.
**/
function WeekDaySchedule(values) {
    
    Model(this);

    // NOTE: from-to properies as numbers
    // for the minute of the day, from 0 (00:00) to 1439 (23:59)
    this.model.defProperties({
        from: 0,
        to: 0
    }, values);
    
    /**
        It allows to know if this week day is 
        enabled for weekly schedule, just it
        has from-to times.
        It allows to be set as true putting
        a default range (9a-5p) or false 
        setting both as 0p.
        
        Since on write two observables are being modified, and
        both are used in the read, a single change to the 
        value will trigger two notifications; to avoid that,
        the observable is rate limited with an inmediate value,
        son only one notification is received.
    **/
    this.isEnabled = ko.computed({
        read: function() {
            return (
                typeof(this.from()) === 'number' &&
                typeof(this.to()) === 'number' &&
                this.from() < this.to()
            );
        },
        write: function(val) {
            if (val === true) {
                // Default range 9a - 5p
                this.fromHour(9);
                this.toHour(17);
            }
            else {
                this.toHour(0);
                this.from(0);
            }
        },
        owner: this
    }).extend({ rateLimit: 0 });
    
    this.isAllDay = ko.computed({
        read: function() {
            return  (
                this.from() === 0 &&
                this.to() === 1440
            );
        },
        write: function(/*val*/) {
            this.from(0);
            this.to(1440);
        },
        owner: this
    }).extend({ rateLimit: 0 });
    
    // Additional interfaces to get/set the from/to times
    // by using a different data unit or format.
    
    // Integer, rounded-up, number of hours
    this.fromHour = ko.computed({
        read: function() {
            return Math.floor(this.from() / 60);
        },
        write: function(hours) {
            this.from((hours * 60) |0);
        },
        owner: this
    });
    this.toHour = ko.computed({
        read: function() {
            return Math.ceil(this.to() / 60);
        },
        write: function(hours) {
            this.to((hours * 60) |0);
        },
        owner: this
    });
    
    // String, time format ('hh:mm')
    this.fromTime = ko.computed({
        read: function() {
            return minutesToTimeString(this.from() |0);
        },
        write: function(time) {
            this.from(timeStringToMinutes(time));
        },
        owner: this
    });
    this.toTime = ko.computed({
        read: function() {
            return minutesToTimeString(this.to() |0);
        },
        write: function(time) {
            this.to(timeStringToMinutes(time));
        },
        owner: this
    });
}

/**
    Main model defining the week schedule
    per week date, or just set all days times
    as available with a single flag.
**/
function SimplifiedWeeklySchedule(values) {
    
    Model(this);

    this.model.defProperties({
        sunday: new WeekDaySchedule(),
        monday: new WeekDaySchedule(),
        tuesday: new WeekDaySchedule(),
        wednesday: new WeekDaySchedule(),
        thursday: new WeekDaySchedule(),
        friday: new WeekDaySchedule(),
        saturday: new WeekDaySchedule(),
        isAllTime: false
    }, values);
}

module.exports = SimplifiedWeeklySchedule;

//// UTILS,
// TODO Organize or externalize. some copied form appmodel..
/**
    internal utility function 'to string with two digits almost'
**/
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Convert a number of minutes
    in a string like: 00:00:00 (hours:minutes:seconds)
**/
function minutesToTimeString(minutes) {
    var d = moment.duration(minutes, 'minutes'),
        h = d.hours(),
        m = d.minutes(),
        s = d.seconds();
    
    return (
        twoDigits(h) + ':' +
        twoDigits(m) + ':' +
        twoDigits(s)
    );
}

var moment = require('moment');
function timeStringToMinutes(time) {
    return moment.duration(time).asMinutes() |0;
}
},{"./Model":66,"knockout":false,"moment":false}],75:[function(require,module,exports){
/** Thread model.

    Describes a thread of messages.
 **/
'use strict';

var Model = require('./Model'),
    Message = require('./Message');

function Thread(values) {
    
    Model(this);

    this.model.defProperties({
        threadID: 0,
        
        customerUserID: null,
        freelancerUserID: null,
        jobTitleID: null,
        statusID: null,
        subject: null,
        
        messages: {
            isArray: true,
            Model: Message
        },
        
        createdDate: null,
        updatedDate: null        
    }, values);
}

module.exports = Thread;

},{"./Message":64,"./Model":66}],76:[function(require,module,exports){
/** UpcomingBookingsSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    BookingSummary = require('./BookingSummary');

function UpcomingBookingsSummary() {

    Model(this);
    
    // TODO: define today, tomorrow and nextWeek as
    // properties with default Model?
    // Review how update happens on home/dashboard, it can helps
    // to simplify that

    this.today = new BookingSummary({
        concept: 'more today',
        timeFormat: ' [ending @] h:mma'
    });
    this.tomorrow = new BookingSummary({
        concept: 'tomorrow',
        timeFormat: ' [starting @] h:mma'
    });
    this.nextWeek = new BookingSummary({
        concept: 'next week',
        timeFormat: null
    });
    
    this.items = ko.pureComputed(function() {
        var items = [];
        
        //if (this.today.quantity())
        items.push(this.today);
        //if (this.tomorrow.quantity())
        items.push(this.tomorrow);
        //if (this.nextWeek.quantity())
        items.push(this.nextWeek);

        return items;
    }, this);
    
}

module.exports = UpcomingBookingsSummary;

},{"./BookingSummary":53,"./Model":66,"knockout":false}],77:[function(require,module,exports){
/** User model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

// Enum UserType
var UserType = {
    None: 0,
    Anonymous: 1,
    Customer: 2,
    Freelancer: 4,
    Admin: 8,
    LoggedUser: 14,
    User: 15,
    System: 16
};

function User(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        email: '',
        
        firstName: '',
        lastName: '',
        secondLastName: '',
        businessName: '',
        
        alternativeEmail: '',
        phone: '',
        canReceiveSms: '',
        birthMonthDay: null,
        birthMonth: null,
        
        isFreelancer: false,
        isCustomer: false,
        isMember: false,
        isAdmin: false,

        onboardingStep: null,
        accountStatusID: 0,
        createdDate: null,
        updatedDate: null
    }, values);

    this.fullName = ko.pureComputed(function() {
        var nameParts = [this.firstName()];
        if (this.lastName())
            nameParts.push(this.lastName());
        if (this.secondLastName())
            nameParts.push(this.secondLastName);
        
        return nameParts.join(' ');
    }, this);
    
    this.birthDay = ko.pureComputed(function() {
        if (this.birthMonthDay() &&
            this.birthMonth()) {
            
            // TODO i10n
            return this.birthMonth() + '/' + this.birthMonthDay();
        }
        else {
            return null;
        }
    }, this);
    
    this.userType = ko.pureComputed({
        read: function() {
            var c = this.isCustomer(),
                p = this.isFreelancer(),
                a = this.isAdmin();
            
            var userType = 0;
            
            if (this.isAnonymous())
                userType = userType | UserType.Anonymous;
            if (c)
                userType = userType | UserType.Customer;
            if (p)
                userType = userType | UserType.Freelancer;
            if (a)
                userType = userType | UserType.Admin;
            
            return userType;
        },
        /* NOTE: Not required for now:
        write: function(v) {
        },*/
        owner: this
    });
    
    this.isAnonymous = ko.pureComputed(function(){
        return this.userID() < 1;
    }, this);
    
    /**
        It matches a UserType from the enumeration?
    **/
    this.isUserType = function isUserType(type) {
        return (this.userType() & type);
    }.bind(this);
}

module.exports = User;

User.UserType = UserType;

/* Creatint an anonymous user with some pressets */
User.newAnonymous = function newAnonymous() {
    return new User({
        userID: 0,
        email: '',
        firstName: '',
        onboardingStep: null
    });
};

},{"./Model":66,"knockout":false}],78:[function(require,module,exports){
/**
    UserJobTitle model, relationship between an user and a
    job title and the main data attached to that relation.
**/
'use strict';

var Model = require('./Model');

function UserJobTitle(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        jobTitleID: 0,
        intro: null,
        statusID: 0,
        cancellationPolicyID: 0,
        instantBooking: false,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['userID', 'jobTitleID']);
}

module.exports = UserJobTitle;

},{"./Model":66}],79:[function(require,module,exports){
/** 
    timeSlots
    testing data
**/

var Time = require('../utils/Time');

var moment = require('moment');

var today = new Date(),
    tomorrow = new Date();
tomorrow.setDate(tomorrow.getDate() + 1);

var stoday = moment(today).format('YYYY-MM-DD'),
    stomorrow = moment(tomorrow).format('YYYY-MM-DD');

var testData1 = [
    Time(today, 9, 15),
    Time(today, 11, 30),
    Time(today, 12, 0),
    Time(today, 12, 30),
    Time(today, 16, 15),
    Time(today, 18, 0),
    Time(today, 18, 30),
    Time(today, 19, 0),
    Time(today, 19, 30),
    Time(today, 21, 30),
    Time(today, 22, 0)
];

var testData2 = [
    Time(tomorrow, 8, 0),
    Time(tomorrow, 10, 30),
    Time(tomorrow, 11, 0),
    Time(tomorrow, 11, 30),
    Time(tomorrow, 12, 0),
    Time(tomorrow, 12, 30),
    Time(tomorrow, 13, 0),
    Time(tomorrow, 13, 30),
    Time(tomorrow, 14, 45),
    Time(tomorrow, 16, 0),
    Time(tomorrow, 16, 30)
];

var testDataBusy = [
];

var testData = {
    'default': testDataBusy
};
testData[stoday] = testData1;
testData[stomorrow] = testData2;

exports.timeSlots = testData;

},{"../utils/Time":91,"moment":false}],80:[function(require,module,exports){
/**
    Utility to help track the state of cached data
    managing time, preference and if must be revalidated
    or not.
    
    Its just manages meta data, but not the data to be cached.
**/
'use strict';

var moment = require('moment');

function CacheControl(options) {
    
    options = options || {};

    // A number of milliseconds or
    // An object with desired units and amount, all optional,
    // any combination with almost one specified, sample:
    // { years: 0, months: 0, weeks: 0, 
    //   days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }
    this.ttl = moment.duration(options.ttl).asMilliseconds();
    this.latest = options.latest || null;

    this.mustRevalidate = function mustRevalidate() {
        var tdiff = this.latest && new Date() - this.latest || Number.POSITIVE_INFINITY;
        return tdiff > this.ttl;
    };
}

module.exports = CacheControl;

},{"moment":false}],81:[function(require,module,exports){
/**
    New Function method: '_delayed'.
    It returns a new function, wrapping the original one,
    that once its call will delay the execution the given milliseconds,
    using a setTimeout.
    The new function returns 'undefined' since it has not the result,
    because of that is only suitable with return-free functions 
    like event handlers.
    
    Why: sometimes, the handler for an event needs to be executed
    after a delay instead of instantly.
**/
Function.prototype._delayed = function delayed(milliseconds) {
    var fn = this;
    return function() {
        var context = this,
            args = arguments;
        setTimeout(function () {
            fn.apply(context, args);
        }, milliseconds);
    };
};

},{}],82:[function(require,module,exports){
/**
    Extending the Function class with an inherits method.
    
    The initial low dash is to mark it as no-standard.
**/
Function.prototype._inherits = function _inherits(superCtor) {
    this.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: this,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

},{}],83:[function(require,module,exports){
/**
    Fix Function#name on browsers that do not support it (IE9+):
    
    http://stackoverflow.com/a/17056530/1622346    
**/
'use strict';
/*jshint -W068 */
if (!(function f() {}).name) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function() {
            var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
            // For better performance only parse once, and then cache the
            // result through a new accessor for repeated access.
            Object.defineProperty(this, 'name', { value: name });
            return name;
        }
    });
}
},{}],84:[function(require,module,exports){
/**
    GroupListRemoteModel
    Utility class for common code for a data list entity from a remote source,
    with local copy and cache, where the full list is managed per groups,
    without paging/cursor, all the group data on each operation.
**/
'use strict';

var ko = require('knockout'),
    IndexedGroupListCache = require('./IndexedGroupListCache');

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function GroupListRemoteModel(settings) {
    /*jshint maxstatements:28*/
    
    settings = settings || {};
    settings.listTtl = required(settings.listTtl, 'listTtl is required');
    settings.groupIdField = required(settings.groupIdField, 'groupIdField is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    // For now, optional model
    settings.Model = settings.Model || null;
    // Required for API additions
    this.settings = settings;

    this.state = {
        isLoading: ko.observable(false),
        isSyncing: ko.observable(false),
        isSaving: ko.observable(false),
        isDeleting: ko.observable(false)
    };

    var cache = new IndexedGroupListCache({
        listTtl: settings.listTtl,
        groupIdField: settings.groupIdField,
        itemIdField: settings.itemIdField
    });
    
    this.clearCache = cache.clearCache;

    this.state.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving() || this.isDeleting();
    }, this.state);

    /** Data Stores Management: implementation must be replaced, with custom code or using
        the helpers added to the class (see addXxSupport prototype methods).
    **/
    function notImplemented() { throw new Error('Not Implemented'); }
    this.fetchGroupFromLocal = notImplemented;
    this.fetchGroupFromRemote = notImplemented;
    this.pushGroupToLocal = notImplemented;
    this.pushGroupToRemote = notImplemented;
    this.removeItemFromRemote = notImplemented;

    /** API definition **/
    var api = this;

    api.getList = function getList(groupID) {
        var cacheEntry = cache.getGroupCache(groupID);

        if (cacheEntry.control.mustRevalidate()) {
            // No cache data, is first load, try from local
            if (!cacheEntry.list) {
                api.state.isLoading(true);
                // From local
                return this.fetchGroupFromLocal(groupID)
                .then(function(data) {
                    // launch remote for sync
                    api.state.isSyncing(true);
                    var remotePromise = this.fetchGroupFromRemote(groupID)
                    .then(function(serverData) {
                        cache.setGroupCache(groupID, serverData);
                        this.pushGroupToLocal(groupID, serverData);
                        api.state.isSyncing(false);
                        return serverData;
                    }.bind(this));
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                }.bind(this))
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.setGroupCache(groupID, data);
                    this.pushGroupToLocal(groupID, data);
                    api.state.isLoading(false);

                    return data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            } else {
                api.state.isSyncing(true);
                // From remote
                return this.fetchGroupFromRemote(groupID)
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.setGroupCache(groupID, data);
                    this.pushGroupToLocal(groupID, data);
                    api.state.isLoading(false);
                    api.state.isSyncing(false);

                    return data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            }
        }
        else {
            // From cache
            return Promise.resolve(cacheEntry.list);
        }
    };
    
    api.getItem = function getItem(groupID, itemID) {
        // IMPORTANT: To simplify, load all the list (is a short list)
        // and look from its cached index
        // TODO Implement item server look-up. Be careful with cache update,
        // list sorting and state flags.
        return api.getList(groupID)
        .then(function() {
            // Get from cached index
            var cacheItem = cache.getItemCache(groupID, itemID);

            // TODO: Enhance on future with actual look-up by API itemID
            // if not cached, throwing not found from the server (just to avoid
            // minor cases when a new item is not still in the cache if linked
            // from other app data). And keep updated list cache with that
            // items lookup
            if (!cacheItem) {
                console.warn('GroupListRemoteModel Not found', groupID, itemID, settings.Model);
                throw new Error('Not Found');
            }
            return cacheItem.item;
        });
    };

    /**
        Save an item in cache, local and remote.
        Can be new or updated.
        The IDs goes with all the other data, being
        groupID required, itemID required for updates
        but falsy for insertions.
        @param data:object Plain object
    **/
    api.setItem = function setItem(data) {
        api.state.isSaving(true);
        // Send to remote first
        return this.pushGroupToRemote(data)
        .then(function(serverData) {
            // Success! update local copy with returned data
            // IMPORTANT: to use server data here so we get values set
            // by the server, as updates dates and itemID when creating
            // a new item.
            if (serverData) {
                var groupID = serverData[settings.groupIdField];
                // Save in cache
                cache.setItemCache(groupID, serverData[settings.itemIdField], serverData);
                // Save in local storage
                // In local need to be saved all the grouped data, not just
                // the item; since we have the cache list updated, use that
                // full list to save local
                this.pushGroupToLocal(groupID, cache.getGroupCache(groupID).list);
            }
            api.state.isSaving(false);

            return serverData;
        }.bind(this))
        .catch(function(err) {
            api.state.isSaving(false);
            // Rethrow error
            return err;
        });
    };
    
    api.delItem = function delItem(groupID, itemID) {
        
        api.state.isDeleting(true);
        
        // Remove in remote first
        return this.removeItemFromRemote(groupID, itemID)
        .then(function(removedData) {
            // Update cache
            cache.delItemCache(groupID, itemID);
            // Save in local storage
            // In local need to be saved all the grouped data;
            // since we have the cache list updated, use that
            // full list to save local
            this.pushGroupToLocal(groupID, cache.getGroupCache(groupID).list);
            
            api.state.isDeleting(false);
            
            return removedData;
        }.bind(this))
        .catch(function(err) {
            api.state.isDeleting(false);
            // Rethrow error
            return err;
        });
    };
    
    /** Some Utils **/
    
    /**
        Generates and returns an observable inmediately,
        with the cached value or undefined,
        launching an item load that will update the observable
        on ready if there is no cached value.
        A method 'sync' is added to the observable so can be requested
        a data sync/reload on demand.
    **/
    api.getObservableItem = function getObservableItem(groupID, itemID, asModel) {
        // Get first value
        var firstValue = cache.getItemCache(groupID, itemID);
        firstValue = firstValue && firstValue.item || undefined;
        var obs = ko.observable(asModel ? api.asModel(firstValue) : firstValue);
        // Create method 'sync'
        obs.sync = function syncObservableItem() {
            return api.getItem(groupID, itemID)
            .then(function(item) {
                if (asModel)
                    obs().model.updateWith(item);
                else
                    obs(item);
            });
        };
        // First load if no cached value
        if (!firstValue)
            obs.sync();
        // Return
        return obs;
    };
    
    api.asModel = function asModel(object) {
        var Model = this.settings.Model;
        // if is an array, return a list of models
        if (Array.isArray(object)) {
            return object.map(function(item) {
                return new Model(item);
            });
        }
        else {
            return new Model(object);
        }
    };
    
    api.getItemModel = function getItemModel(groupID, itemID) {
        return api.getItem(groupID, itemID)
        .then(function(data) {
            return data ? api.asModel(data) : null;
        });
    };
    
    var ModelVersion = require('../utils/ModelVersion');
    api.getItemVersion = function getItemVersion(groupID, itemID) {
        return api.getItemModel(groupID, itemID)
        .then(function(model) {
            return model ? new ModelVersion(model) : null;
        });
    };
    
    api.newItemVersion = function newItemVersion(values) {
        // New original and version for the model
        var version = new ModelVersion(new this.settings.Model(values));
        // To be sure that the version appear as something 'new', unsaved,
        // we update its timestamp to be different to the original.
        version.version.model.touch();
        return version;
    };
}

module.exports = GroupListRemoteModel;

GroupListRemoteModel.prototype.addLocalforageSupport = function addLocalforageSupport(baseName) {
    var localforage = require('localforage');

    this.fetchGroupFromLocal = function fetchFromLocal(groupID) {
        return localforage.getItem(baseName + groupID);
    };
    this.pushGroupToLocal = function pushToLocal(groupID, data) {
        return localforage.setItem(baseName + groupID, data);
    };
};

GroupListRemoteModel.prototype.addRestSupport = function addRestSupport(restClient, baseUrl) {
    
    this.fetchGroupFromRemote = function fetchFromRemote(groupID) {
        return restClient.get(baseUrl + groupID);
    };
    this.pushGroupToRemote = function pushToRemote(data) {

        var groupID = data[this.settings.groupIdField],
            itemID = data[this.settings.itemIdField],
            method = data[this.settings.itemIdField] ? 'put' : 'post';

        var url = baseUrl + groupID + (
            itemID ? '/' + itemID : ''
        );
        return restClient[method](url, data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(groupID, itemID) {
        return restClient.delete(baseUrl + groupID + '/' + itemID);
    };
};

},{"../utils/ModelVersion":88,"./IndexedGroupListCache":85,"knockout":false,"localforage":false}],85:[function(require,module,exports){
/**
    IndexedGroupListCache manages a in-memory cache for a list
    of objects, grouped by a field and with indexed access to groups
    and items, with cache control.
    
    Settings object as unique parameter:
    listTtl: ttl type constructor. TimeToLife for each group list cache.
    FUTURE: itemTtl: ttl type constructor. TimeToLife for each item cache.
    ttl: ttl type constructor. TimeToLife to use for list and item cache if there is no a more explicit one
    groupIdField: string Name of the field used to group objects
    itemIdField: string Name of the field used to uniquely identify each item
    FUTURE: Model: constructor of type Model.
    
    Note: 'ttl type constructor' can be a number of milliseconds or a value to pass to moment.duration constructor (momentjs module).
**/
'use strict';

var CacheControl = require('./CacheControl');

function createIndex(list, byField) {
    var index = {};
    
    list.forEach(function(item, itemIndex) {
        index[item[byField]] = {
            index: itemIndex,
            item: item
            // Direct referenc, could be a property too auto resolving as
            // something like get item() { return list[itemIndex[item[byField]]] || null; }
        };
    });

    return index;
}

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function IndexedGroupListCache(settings) {
    
    settings = settings || {};
    settings.ttl = settings.ttl || 0;
    settings.listTtl = settings.listTtl || settings.ttl || 0;
    //FUTURE: settings.itemTtl = settings.itemTtl || settings.ttl || 0;
    settings.groupIdField = required(settings.groupIdField, 'groupIdField is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    //FUTURE: settings.Model = settings.Model || throw new Error('A Model is required');
    
    var cache = {/*
        groupIdField: {
            control: CacheControl,
            list: Array,
            index: {
                itemIdField: {
                    index: Integer (index in the list array),
                    item: Object (reference to the item object in the array)
                    // Maybe future: control: CacheControl per item
                },
                ..
            }
        },
        ..
    */};
    
    this.clearCache = function clearCache() {
        cache = {};
    };

    function newCacheEntry(list) {
        return {
            control: new CacheControl({ ttl: settings.listTtl }),
            list: list || null,
            index: list && createIndex(list, settings.itemIdField) || {}
        };
    }

    function setGroupCache(groupID, list) {
        var cacheEntry = cache[groupID];
        if (cacheEntry) {
            cacheEntry.list = list || [];
            cacheEntry.index = createIndex(list || [], settings.itemIdField);
        }
        else {
            cacheEntry = cache[groupID] = newCacheEntry(list);
        }
        cacheEntry.control.latest = new Date();
    }
    
    this.setGroupCache = setGroupCache;

    /**
        Get the cache entry for the Group
    **/
    function getGroupCache(groupID) {
        var cacheEntry = cache[groupID];
        return cacheEntry || newCacheEntry();
    }
    
    this.getGroupCache = getGroupCache;

    /**
        Get the cache entry from the Item
    **/
    function getItemCache(groupID, itemID) {
        var cacheEntry = cache[groupID];
        if (cacheEntry) {
            return cacheEntry.index[itemID] || null;
        }
        else {
            return null;
        }
    }
    
    this.getItemCache = getItemCache;

    function setItemCache(groupID, itemID, item) {
        var cacheEntry = cache[groupID] || newCacheEntry([]);
        
        // Loof for the entry, to update or insert a new one
        var itemEntry = cacheEntry.index[itemID];
        if (itemEntry) {
            // Update entry
            cacheEntry.list[itemEntry.index] = item;
            // Update reference in the index too (is not computed right now)
            itemEntry.item = item;
        }
        else {
            // Add to the list
            var itemIndex = cacheEntry.list.push(item) - 1;
            cacheEntry.index[itemID] = {
                index: itemIndex,
                item: item
            };
        }
    }
    
    this.setItemCache = setItemCache;

    function delItemCache(groupID, itemID) {
        var groupEntry = cache[groupID] || null;
        if (groupEntry) {
            var itemEntry = groupEntry.index[itemID];
            if (itemEntry) {
                // Update list removing the element in place, without holes
                groupEntry.list.splice(itemEntry.index, 1);
                // Update index by:
                // - Remove itemID entry
                delete groupEntry.index[itemID];
                // - Update every entry with an ID greater than the updated,
                // since they are now one position less in the updated list
                Object.keys(groupEntry.index).forEach(function(key) {
                    if (groupEntry.index[key] > itemEntry.index)
                        groupEntry.index[key]--;
                });
            }
        }
    }
    
    this.delItemCache = delItemCache;
    
    function delGroupCache(groupID) {
        var groupEntry = cache[groupID] || null;
        if (groupEntry) {
            // Delete the entry/property
            delete cache[groupID];
        }
    }
    
    this.delGroupCache = delGroupCache;
}

module.exports = IndexedGroupListCache;

},{"./CacheControl":80}],86:[function(require,module,exports){
/**
    IndexedListCache manages a in-memory cache for a list
    of objects, with indexed access to items
    and cache control.
    
    Settings object as unique parameter:
    listTtl: ttl type constructor. TimeToLife for each group list cache.
    FUTURE: itemTtl: ttl type constructor. TimeToLife for each item cache.
    ttl: ttl type constructor. TimeToLife to use for list and item cache if there is no a more explicit one
    itemIdField: string Name of the field used to uniquely identify each item
    Model: constructor of type Model.
    
    Note: 'ttl type constructor' can be a number of milliseconds or a value to pass to moment.duration constructor (momentjs module).
**/
'use strict';

var CacheControl = require('./CacheControl'),
    jsPropertiesTools = require('./jsPropertiesTools'),
    ko = require('knockout');

function createItemIndexEntry(list, itemIndex) {
    return {
        index: itemIndex,
        get item() {
            return list[this.index];
        }
    };
}

function createIndex(list, byField) {
    var index = {};
    
    list.forEach(function(item, itemIndex) {
        index[ko.unwrap(item[byField])] = createItemIndexEntry(list, itemIndex);
    });

    return index;
}

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

/**
    An item adapter receives the old and the new item data and returns
    the item to hold in the list. The returning object can be a reference
    to the same existent object (oldItem) that gets updated with the 
    new values (newItem), or just the newItem or any conversion over the
    raw newItem data.
    This allows to perform changes, add properties, or keep references,
    like creating observables, Models.
    
    This default implementation just returns the newItem.
**/
function defaultItemAdapter(oldItem, newItem) {
    return newItem;
}

function IndexedListCache(settings) {
    
    settings = settings || {};
    settings.ttl = settings.ttl || 0;
    settings.listTtl = settings.listTtl || settings.ttl || 0;
    //FUTURE: settings.itemTtl = settings.itemTtl || settings.ttl || 0;
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    settings.itemAdapter = typeof(settings.itemAdapter) === 'function' ? settings.itemAdapter : defaultItemAdapter;

    // Internal flag to notify if the cache was not used still (no data set)
    // since its instantiation. On first setList will change to false and keep in that state.
    var unused = true;
    // Internal cache management
    var cache = {
        control: new CacheControl({ ttl: settings.listTtl }),
        list: ko.observableArray([]),
        index: {/*
            itemIdField: {
                index: Integer (index in the list array),
                item: Object (property referencing to the item object in the array by its index)
                // Maybe future: control: CacheControl per item
            },
            ..
        */}
    };
    
    this.clearCache = function clearCache() {
        cache.control.latest = null;
        cache.list([]);
        cache.index = {};
        unused = true;
    };

    /**
        Get the cache entry from the Item
    **/
    function getItemCache(itemID) {
        return cache.index[itemID] || null;
    }

    this.getItemCache = getItemCache;

    // Adapt a new item using the itemAdapter and getting the old reference.
    function adaptItem(newItem) {
        var oldItem = getItemCache(ko.unwrap(newItem[settings.itemIdField]));
        return settings.itemAdapter(oldItem, newItem);
    }
    
    // Adapt the each element in the list with the itemAdapter,
    // passing an old reference and the new item on each, and ensuring
    // to return ever an array, even if empty.
    function adaptList(list) {
        return (list || []).map(adaptItem);
    }

    function setList(list) {
        cache.list(adaptList(list));
        cache.index = createIndex(cache.list(), settings.itemIdField);
        cache.control.latest = new Date();
        unused = false;
    }

    // Public, read-only, access to cache info (objects are mutable, but almost the reference
    // cannot be broken; a change in the list instance updates the cache properly).
    jsPropertiesTools.defineGetter(this, 'control', function() { return cache.control; });
    jsPropertiesTools.defineGetter(this, 'list', function() { return cache.list; });
    jsPropertiesTools.defineSetter(this, 'list', function(list) { return setList(list); });
    jsPropertiesTools.defineGetter(this, 'index', function() { return cache.index; });
    jsPropertiesTools.defineGetter(this, 'unused', function() { return unused; });

    function setItemCache(item) {
        var itemID = ko.unwrap(item[settings.itemIdField]);
        // Look for the entry, to update or insert a new one
        var itemEntry = cache.index[itemID];
        if (itemEntry) {
            // Update entry
            cache.list()[itemEntry.index] = adaptItem(item);
        }
        else {
            // Add to the list
            var itemIndex = cache.list.push(adaptItem(item)) - 1;
            cache.index[itemID] = createItemIndexEntry(cache.list(), itemIndex);
        }
    }

    this.setItemCache = setItemCache;

    function delItemCache(itemID) {
        var itemEntry = cache.index[itemID];
        if (itemEntry) {
            // Update list removing the element in place, without holes
            cache.list.splice(itemEntry.index, 1);
            // Update index by:
            // - Remove itemID entry
            delete cache.index[itemID];
            // - Update every entry with an ID greater than the updated,
            // since they are now one position less in the updated list
            Object.keys(cache.index).forEach(function(key) {
                if (cache.index[key] > itemEntry.index)
                    cache.index[key]--;
            });
        }
    }
    
    this.delItemCache = delItemCache;
}

module.exports = IndexedListCache;

},{"./CacheControl":80,"./jsPropertiesTools":101,"knockout":false}],87:[function(require,module,exports){
/**
    ListRemoteModel
    Utility class for common code for a data list entity from a remote source,
    with local copy and cache, where the list is managed will all the data,
    without paging/cursor, with indexed access to each item by its ID.
    Is good for lists that keep small in the time.
**/
'use strict';

var ko = require('knockout'),
    IndexedListCache = require('./IndexedListCache');

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function ListRemoteModel(settings) {
    /*jshint maxstatements:50*/

    settings = settings || {};
    settings.listTtl = required(settings.listTtl, 'listTtl is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    // Optional model
    settings.Model = settings.Model || null;
    // Required for API additions
    this.settings = settings;

    this.state = {
        isLoading: ko.observable(false),
        isSyncing: ko.observable(false),
        isSaving: ko.observable(false),
        isDeleting: ko.observable(false)
    };
    
    // Items are managed as plain object by default, but as permanent, updated
    // model instances if the Model class was specified.
    // This adapter is passed to the cache constructor too keep the in-memory
    // objects up to date with the correct structure.
    function itemAdapter(oldItem, newItem) {
        if (settings.Model) {
            // If the model item already exists, update with new values
            if (oldItem && oldItem instanceof settings.Model) {
                oldItem.model.updateWith(newItem);
                return oldItem;
            }
            else {
                // New created item.
                // If there was a previous, no-model, value, they are discarded
                // (that situation can only happens if there are irregular modifications
                // of the internal behavior).
                return new settings.Model(newItem);
            }
        }
        else {
            return newItem;
        }
    }
    
    var cache = new IndexedListCache({
        listTtl: settings.listTtl,
        itemIdField: settings.itemIdField,
        itemAdapter: itemAdapter
    });
    
    this.clearCache = cache.clearCache;

    this.state.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving() || this.isDeleting();
    }, this.state);

    /** Data Stores Management: implementation must be replaced, with custom code or using
        the helpers added to the class (see addXxSupport prototype methods).
    **/
    function notImplemented() { throw new Error('Not Implemented'); }
    this.fetchListFromLocal = notImplemented;
    this.fetchListFromRemote = notImplemented;
    this.pushListToLocal = notImplemented;
    this.pushListToRemote = notImplemented;
    this.removeItemFromRemote = notImplemented;
    
    /**
        Retrieves a plain array-objects from the cached list
    **/
    function getPlainCachedList() {
        var arr = cache.list();
        return arr.map(function(item) {
            if (item && settings.Model && item instanceof settings.Model) {
                return item.model.toPlainObject();
            }
            else {
                return item;
            }
        });
    }

    /** API definition **/
    var api = this;
    
    // Direct access to the observable cached list.
    api.list = cache.list;

    // Currently, just a wrapper for getList.
    api.sync = function sync() {
        return api.getList();
    };

    /**
        Promise based request to get the list (from cache, local or remote).
        It updates the observable list if new data is fetched.
        A general approach is to use the observable list and call the 'sync' method
        rather than wait this promise to finish ('sync' performs this load really).
    **/
    api.getList = function getList() {

        if (cache.control.mustRevalidate()) {
            // Cache still not used, then is first load, try load from local
            if (cache.unused) {
                api.state.isLoading(true);
                // From local
                return this.fetchListFromLocal()
                .then(function(data) {
                    // launch remote for sync
                    api.state.isSyncing(true);
                    var remotePromise = this.fetchListFromRemote()
                    .then(function(serverData) {
                        cache.list = serverData;
                        this.pushListToLocal(serverData);
                        api.state.isSyncing(false);
                        return serverData;
                    }.bind(this))
                    .catch(function(err) {
                        // If there was local data, catch error and
                        // stop sync since this promise will not
                        // be available to any consumer
                        if (data) {
                            api.state.isSyncing(false);
                            // Log to console
                            console.error('ListRemoteModel: remote synchronization failed', err);
                        }
                        else {
                            // This promise is returned so will be consumed,
                            // just rethrow and let the other catch-blocks do the common stuff
                            return err;
                        }
                    });
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                }.bind(this))
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.list = data;
                    this.pushListToLocal(data);
                    api.state.isLoading(false);

                    return cache.list;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            } else {
                api.state.isSyncing(true);
                // From remote
                return this.fetchListFromRemote()
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.list = data;
                    this.pushListToLocal(data);
                    api.state.isLoading(false);
                    api.state.isSyncing(false);

                    return cache.list;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            }
        }
        else {
            // From cache
            return Promise.resolve(cache.list);
        }
    };
    
    api.getItem = function getItem(itemID) {
        // IMPORTANT: To simplify, load all the list (is a short list)
        // and look from its cached index
        // TODO Implement item server look-up. Be careful with cache update,
        // list sorting and state flags.
        return api.getList()
        .then(function() {
            // Get from cached index
            var cacheItem = cache.getItemCache(itemID);

            // TODO: Enhance on future with actual look-up by API itemID
            // if not cached, throwing not found from the server (just to avoid
            // minor cases when a new item is not still in the cache if linked
            // from other app data). And keep updated list cache with that
            // items lookup
            if (!cacheItem) {
                console.warn('ListRemoteModel Not found', itemID, settings.Model);
                throw new Error('Not Found');
            }
            return cacheItem.item;
        });
    };
    
    /**
        Generates and returns an observable inmediately,
        with the cached value or undefined,
        launching an item load that will update the observable
        on ready if there is no cached value.
        A method 'sync' is added to the observable so can be requested
        a data sync/reload on demand.
    **/
    api.getObservableItem = function getObservableItem(itemID) {
        // Get first value
        var firstValue = cache.getItemCache(itemID);
        firstValue = firstValue && firstValue.item || undefined;
        var obs = ko.observable(firstValue);
        // Create method 'sync'
        obs.sync = function syncObservableItem() {
            return api.getItem(itemID)
            .then(function(itemModel) {
                obs(itemModel);
            });
        };
        // First load if no cached value
        if (!firstValue)
            obs.sync();
        // Return
        return obs;
    };
    
    /**
        Similar to getObservableItem, it allows to get
        an observable to an item model synchronously that
        it triggers an item load when its method 'sync'
        is called. The itemID is passed to the sync item,
        since the observable is meant to hold any item/itemID
        (its a wildcard).
        This way, a reference to an observable can be get on initialization
        even if there is no data still, even no itemID, and load
        it later lazily, on demand, while keeping the content of the
        previous outdated or different item.

        NOTE: API alternative names: getLazyItem, createMutableItem
        NOTE: Maybe can get state observables (loading, syncing..)?
        NOTE: On update a same itemID, maybe update the model with updateWith
                rather than change the reference model?? (double check:
                since the model is the same in cache, already updated
                with 'updateWith', there is no need to re-apply and no
                need to change the item observable because is the same
                updated already, right?
    **/
    api.createWildcardItem = function createWildcardItem() {
        // Utility for reuse in 'sync'
        var hasID = function(id) {
            return id !== null && typeof(id) !== 'undefined';
        };
        
        // Create observable, with initial undefined value
        var obs = ko.observable(undefined);

        // Create method 'sync'
        var lastID;
        /**
            Sync method to load an item, from cache ASAP and
            from local or remote if required by the cache control.
            It returns the Promise for fetching the value (getItem)
            so load/sync ending and error can be catched.
        **/
        obs.sync = function syncObservableItem(itemID) {
            
            var idChanged = hasID(itemID) && itemID !== lastID;
            lastID = hasID(itemID) ? itemID : lastID;
            
            // ASAP Get from cache if any and requested item changed
            if (idChanged) {
                var cachedItem = cache.getItemCache(lastID);
                if (cachedItem && cachedItem.item)
                    obs(cachedItem.item);
            }

            // Request updated value
            return api.getItem(lastID)
            .then(function(itemModel) {
                obs(itemModel);
                return itemModel;
            });
        };
        
        /**
            Sets the observable value to a new item instance
        **/
        obs.newItem = function newItem(defaults) {
            if (settings.Model)
                obs(new settings.Model(defaults));
            else
                obs(defaults || {});
        };

        // Return
        return obs;
    };

    /**
        Save an item in cache, local and remote.
        Can be new or updated.
        The IDs goes with all the other data, being
        groupID required, itemID required for updates
        but falsy for insertions.
        @param data:object Plain object
    **/
    api.setItem = function setItem(data) {
        api.state.isSaving(true);
        // Send to remote first
        return this.pushListToRemote(data)
        .then(function(serverData) {
            // Success! update local copy with returned data
            // IMPORTANT: to use server data here so we get values set
            // by the server, as updates dates and itemID when creating
            // a new item.
            if (serverData) {
                // Save in cache
                cache.setItemCache(serverData);
                // Save in local storage
                // In local need to be saved all the list, not just
                // the item; since we have the cache list updated, use that
                // full list to save local
                this.pushListToLocal(getPlainCachedList());
            }
            api.state.isSaving(false);

            return serverData;
        }.bind(this))
        .catch(function(err) {
            api.state.isSaving(false);
            // Rethrow error
            return err;
        });
    };
    
    api.delItem = function delItem(itemID) {
        
        api.state.isDeleting(true);
        
        // Remove in remote first
        return this.removeItemFromRemote(itemID)
        .then(function(removedData) {
            // Update cache
            cache.delItemCache(itemID);
            // Save in local storage
            // In local need to be saved all the list;
            // since we have the cache list updated, use that
            // full list to save local
            this.pushListToLocal(getPlainCachedList());

            api.state.isDeleting(false);
            
            return removedData;
        }.bind(this))
        .catch(function(err) {
            api.state.isDeleting(false);
            // Rethrow error
            return err;
        });
    };
    
    /** Some Utils **/

    var ModelVersion = require('../utils/ModelVersion');
    /**
        It creates a new ModelVersion for the requested item ID
        after load the item.
        The promise returns the ModelVersion ready, or null
        if the item does not exists.
    **/
    api.createItemVersion = function createItemVersion(itemID) {
        return api.getItem(itemID)
        .then(function(model) {
            return model ? new ModelVersion(model) : null;
        });
    };

    /**
        It creates a new Model instance with the given initial values,
        returning a ModelVersion object.
        The versioning allows to track the initial
        state (if comes from a set of defaults or clone) with
        the changes done; the internal version notifies itself
        as 'unsaved' ever.
        Its useful to keep the same ModelVersion aware code for
        editions and additions.
    **/
    api.newItem = function newItem(values) {
        // New original and version for the model
        var version = new ModelVersion(new settings.Model(values));
        // To be sure that the version appear as something 'new', unsaved,
        // we update its timestamp to be different to the original.
        version.version.model.touch();
        return version;
    };
}

module.exports = ListRemoteModel;

ListRemoteModel.prototype.addLocalforageSupport = function addLocalforageSupport(baseName) {
    var localforage = require('localforage');

    this.fetchListFromLocal = function fetchListFromLocal() {
        return localforage.getItem(baseName);
    };
    this.pushListToLocal = function pushListToLocal(data) {
        return localforage.setItem(baseName, data);
    };
};

ListRemoteModel.prototype.addRestSupport = function addRestSupport(restClient, baseUrl) {
    
    this.fetchListFromRemote = function fetchListFromRemote() {
        return restClient.get(baseUrl);
    };
    this.pushListToRemote = function pushListToRemote(data) {

        var itemID = data[this.settings.itemIdField],
            method = itemID ? 'put' : 'post';

        var url = baseUrl + (
            itemID ? '/' + itemID : ''
        );
        return restClient[method](url, data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(itemID) {
        return restClient.delete(baseUrl + '/' + itemID);
    };
};

},{"../utils/ModelVersion":88,"./IndexedListCache":86,"knockout":false,"localforage":false}],88:[function(require,module,exports){
/**
    Utility that allows to keep an original model untouched
    while editing a version, helping synchronize both
    when desired by push/pull/sync-ing.
    
    Its the usual way to work on forms, where an in memory
    model can be used but in a copy so changes doesn't affects
    other uses of the in-memory model (and avoids remote syncing)
    until the copy want to be persisted by pushing it, or being
    discarded or refreshed with a remotely updated original model.
**/
'use strict';

var ko = require('knockout'),
    EventEmitter = require('events').EventEmitter;

function ModelVersion(original) {
    
    EventEmitter.call(this);
    
    this.original = original;
    
    // Create version
    // (updateWith takes care to set the same dataTimestamp)
    this.version = original.model.clone(null, true);
    
    // Computed that test equality, allowing being notified of changes
    // A rateLimit is used on each to avoid several syncrhonous notifications.
    
    /**
        Returns true when both versions has the same timestamp
    **/
    this.areDifferent = ko.pureComputed(function areDifferent() {
        return (
            this.original.model.dataTimestamp() !== 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
    /**
        Returns true when the version has newer changes than
        the original
    **/
    this.isNewer = ko.pureComputed(function isNewer() {
        return (
            this.original.model.dataTimestamp() < 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
    /**
        Returns true when the version has older changes than
        the original
    **/
    this.isObsolete = ko.pureComputed(function isComputed() {
        return (
            this.original.model.dataTimestamp() > 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
}

module.exports = ModelVersion;

ModelVersion._inherits(EventEmitter);

/**
    Sends the version changes to the original
    
    options: {
        evenIfNewer: false
    }
**/
ModelVersion.prototype.pull = function pull(options) {

    options = options || {};
    
    // By default, nothing to do, or avoid overwrite changes.
    var result = false,
        rollback = null;
    
    if (options.evenIfNewer || !this.isNewer()) {
        // Update version with the original data,
        // creating first a rollback function.
        rollback = createRollbackFunction(this.version);
        // Ever deepCopy, since only properties and fields from models
        // are copied and that must avoid circular references
        // The method updateWith takes care to set the same dataTimestamp:        
        this.version.model.updateWith(this.original, true);
        // Done
        result = true;
    }

    this.emit('pull', result, rollback);
    return result;
};

/**
    Discard the version changes getting the original
    data.
    
    options: {
        evenIfObsolete: false
    }
**/
ModelVersion.prototype.push = function push(options) {
    
    options = options || {};
    
    // By default, nothing to do, or avoid overwrite changes.
    var result = false,
        rollback = null;

    if (options.evenIfObsolete || !this.isObsolete()) {
        // Update original, creating first a rollback function.
        rollback = createRollbackFunction(this.original);
        // Ever deepCopy, since only properties and fields from models
        // are copied and that must avoid circular references
        // The method updateWith takes care to set the same dataTimestamp.
        this.original.model.updateWith(this.version, true);
        // Done
        result = true;
    }

    this.emit('push', result, rollback);
    return result;
};

/**
    Sets original and version on the same version
    by getting the newest one.
**/
ModelVersion.prototype.sync = function sync() {
    
    if (this.isNewer())
        return this.push();
    else if (this.isObsolete())
        return this.pull();
    else
        return false;
};

/**
    Utility that create a function able to 
    perform a data rollback on execution, useful
    to pass on the events to allow react upon changes
    or external synchronization failures.
**/
function createRollbackFunction(modelInstance) {
    // Previous function creation, get NOW the information to
    // be backed for later.
    var backedData = modelInstance.model.toPlainObject(true),
        backedTimestamp = modelInstance.model.dataTimestamp();

    // Create the function that *may* get executed later, after
    // changes were done in the modelInstance.
    return function rollback() {
        // Set the backed data
        modelInstance.model.updateWith(backedData, true);
        // And the timestamp
        modelInstance.model.dataTimestamp(backedTimestamp);
    };
}

},{"events":false,"knockout":false}],89:[function(require,module,exports){
/**
    RemoteModel class.
    
    It helps managing a model instance, model versions
    for in memory modification, and the process to 
    receive or send the model data
    to a remote sources, with glue code for the tasks
    and state properties.
    
    Every instance or subclass must implement
    the fetch and pull methods that knows the specifics
    of the remotes.
**/
'use strict';

var ModelVersion = require('../utils/ModelVersion'),
    CacheControl = require('../utils/CacheControl'),
    ko = require('knockout'),
    localforage = require('localforage'),
    EventEmitter = require('events').EventEmitter;

function RemoteModel(options) {

    EventEmitter.call(this);
    
    options = options || {};
    
    var firstTimeLoad = true;
    
    // Marks a lock loading is happening, any user code
    // must wait for it
    this.isLoading = ko.observable(false);
    // Marks a lock saving is happening, any user code
    // must wait for it
    this.isSaving = ko.observable(false);
    // Marks a background synchronization: load or save,
    // user code knows is happening but can continue
    // using cached data
    this.isSyncing = ko.observable(false);
    // Utility to know whether any locking operation is
    // happening.
    // Just loading or saving
    this.isLocked = ko.pureComputed(function(){
        return this.isLoading() || this.isSaving();
    }, this);
    
    if (!options.data)
        throw new Error('RemoteModel data must be set on constructor and no changed later');
    this.data = options.data;
    
    this.cache = new CacheControl({
        ttl: options.ttl
    });
    
    this.clearCache = function clearCache() {
        this.cache.latest = null;
        this.data.model.reset();
    };
    
    // Optional name used to persist a copy of the data as plain object
    // in the local storage on every successfully load/save operation.
    // With no name, no saved (default).
    // It uses 'localforage', so may be not saved using localStorage actually,
    // but any supported and initialized storage system, like WebSQL, IndexedDB or LocalStorage.
    // localforage must have a set-up previous use of this option.
    this.localStorageName = options.localStorageName || null;
    
    // Recommended way to get the instance data
    // since it ensures to launch a load of the
    // data each time is accessed this way.
    this.getData = function getData() {
        this.load();
        return this.data;
    };

    this.newVersion = function newVersion() {
        var v = new ModelVersion(this.data);
        
        // Update the version data with the original
        // after a lock load finish, like the first time,
        // since the UI to edit the version will be lock
        // in the middle.
        this.isLoading.subscribe(function (isIt) {
            if (!isIt) {
                v.pull({ evenIfNewer: true });
            }
        });
        
        // Save the remote when successfully pushed the new version
        v.on('push', function(success, rollback) {
            if (success) {
                this.save()
                .then(function() {
                    // Update the version data with the new one
                    // from the remote, that may include remote computed
                    // values:
                    v.pull({ evenIfNewer: true });
                })
                .catch(function() {
                    // To catch the error is important 
                    // to avoid 'unknow error's from being
                    // logged on the console.
                    // The error can be read by listening the 'error' event.
                    
                    // Performs a rollback of the original model
                    rollback();
                    // The version data keeps untouched, user may want to retry
                    // or made changes on its un-saved data.
                });
            }
        }.bind(this));

        return v;
    };
    
    this.fetch = options.fetch || function fetch() { throw new Error('Not implemented'); };
    this.push = options.push || function push() { throw new Error('Not implementd'); };

    var loadFromRemote = function loadFromRemote() {
        return this.fetch()
        .then(function (serverData) {
            if (serverData) {
                // Ever deepCopy, since plain data from the server (and any
                // in between conversion on 'fecth') cannot have circular
                // references:
                this.data.model.updateWith(serverData, true);

                // persistent local copy?
                if (this.localStorageName) {
                    localforage.setItem(this.localStorageName, serverData);
                }
            }
            else {
                throw new Error('Remote model did not returned data, response must be a "Not Found"');
            }

            // Event
            if (this.isLoading()) {
                this.emit('loaded', serverData);
            }
            else {
                this.emit('synced', serverData);
            }

            // Finally: common tasks on success or error
            this.isLoading(false);
            this.isSyncing(false);

            this.cache.latest = new Date();
            return this.data;
        }.bind(this))
        .catch(function(err) {

            var wasLoad = this.isLoading();

            // Finally: common tasks on success or error
            this.isLoading(false);
            this.isSyncing(false);

            // Event
            var errPkg = {
                task: wasLoad ? 'load' : 'sync',
                error: err
            };
            // Be careful with 'error' event, is special and stops execution on emit
            // if no listeners attached: overwritting that behavior by just
            // print on console when nothing, or emit if some listener:
            if (EventEmitter.listenerCount(this, 'error') > 0) {
                this.emit('error', errPkg);
            }
            else {
                // Log it when not handled (even if the promise error is handled)
                console.error('RemoteModel Error', errPkg);
            }

            // Rethrow error
            return err;
        }.bind(this));
    }.bind(this);
    
    this.load = function load() {
        if (this.cache.mustRevalidate()) {
            
            if (firstTimeLoad)
                this.isLoading(true);
            else
                this.isSyncing(true);
            
            var promise = null;
            
            // If local storage is set for this, load first
            // from local, then follow with syncing from remote
            if (firstTimeLoad &&
                this.localStorageName) {

                promise = localforage.getItem(this.localStorageName)
                .then(function(localData) {
                    if (localData) {
                        this.data.model.updateWith(localData, true);
                        
                        // Load done:
                        this.isLoading(false);
                        this.isSyncing(false);
                        
                        // Local load done, do a background
                        // remote load.
                        loadFromRemote()
                        // Catch any promise-error on the remote, to avoid
                        // unexpected errors being uncatch, they still can be
                        // catch using the 'error' event on the RemoteModel instance.
                        .catch(function() { });
                        // just don't wait, return current
                        // data
                        return this.data;
                    }
                    else {
                        // When no data, perform a remote
                        // load and wait for it:
                        return loadFromRemote();
                    }
                }.bind(this));
            }
            else {
                // Perform the remote load:
                promise = loadFromRemote();
            }
            
            // First time, blocking load:
            // it returns when the load returns
            if (firstTimeLoad) {
                firstTimeLoad = false;
                // Returns the promise and will wait for the first load:
                return promise;
            }
            else {
                // Background load: is loading still
                // but we have cached data so we use
                // that for now.
                // Catch any promise-error on the remote, to avoid
                // unexpected errors being uncatch, they still can be
                // catch using the 'error' event on the RemoteModel instance.
                promise.catch(function() { });
                // If anything new from outside
                // versions will get notified with isObsolete()
                return Promise.resolve(this.data);
            }
        }
        else {
            // Return cached data, no need to load again for now.
            return Promise.resolve(this.data);
        }
    };

    this.save = function save() {
        this.isSaving(true);
        
        // Preserve the timestamp after being saved
        // to avoid false 'obsolete' warnings with
        // the version that created the new original
        var ts = this.data.model.dataTimestamp();

        return this.push()
        .then(function (serverData) {
            // Ever deepCopy, since plain data from the server
            // cannot have circular references:
            this.data.model.updateWith(serverData, true);
            this.data.model.dataTimestamp(ts);
            
            // persistent local copy?
            if (this.localStorageName) {
                localforage.setItem(this.localStorageName, serverData);
            }
            
            // Event
            this.emit('saved', serverData);
            
            // Finally: common tasks on success or error
            this.isSaving(false);
            
            this.cache.latest = new Date();
            return this.data;
        }.bind(this))
        .catch(function(err) {
            // Finally: common tasks on success or error
            this.isSaving(false);
            
            // Event
            var errPkg = {
                task: 'save',
                error: err
            };
            // Be careful with 'error' event, is special and stops execution on emit
            // if no listeners attached: overwritting that behavior by just
            // print on console when nothing, or emit if some listener:
            if (EventEmitter.listenerCount(this, 'error') > 0) {
                this.emit('error', errPkg);
            }
            else {
                // Log it when not handled (even if the promise error is handled)
                console.error('RemoteModel Error', errPkg);
            }
            
            // Rethrow error
            return err;
        }.bind(this));
    };
    
    /**
        Launch a syncing request. Returns nothing, the
        way to track any result is with events or 
        the instance observables.
        IMPORTANT: right now is just a request for 'load'
        that avoids promise errors from throwing.
    **/
    this.sync = function sync() {
        // Call for a load, that will be treated as 'syncing' after the
        // first load
        this.load()
        // Avoid errors from throwing in the console,
        // the 'error' event is there to track anyone.
        .catch(function() {});
    };
}

module.exports = RemoteModel;

RemoteModel._inherits(EventEmitter);

},{"../utils/CacheControl":80,"../utils/ModelVersion":88,"events":false,"knockout":false,"localforage":false}],90:[function(require,module,exports){
/**
    REST API access
**/
'use strict';
var $ = require('jquery');

function lowerFirstLetter(n) {
    return n && n[0] && n[0].toLowerCase && (n[0].toLowerCase() + n.slice(1)) || n;
}

function lowerCamelizeObject(obj) {
    //jshint maxcomplexity:8
    
    if (!obj || typeof(obj) !== 'object') return obj;

    var ret = Array.isArray(obj) ? [] : {};
    for(var k in obj) {
        if (obj.hasOwnProperty(k)) {
            var newk = lowerFirstLetter(k);
            ret[newk] = typeof(obj[k]) === 'object' ?
                lowerCamelizeObject(obj[k]) :
                obj[k]
            ;
        }
    }
    return ret;
}

function Rest(optionsOrUrl) {
    
    var url = typeof(optionsOrUrl) === 'string' ?
        optionsOrUrl :
        optionsOrUrl && optionsOrUrl.url;

    this.baseUrl = url;
    // Optional extraHeaders for all requests,
    // usually for authentication tokens
    this.extraHeaders = null;
}

Rest.prototype.get = function get(apiUrl, data) {
    return this.request(apiUrl, 'get', data);
};

Rest.prototype.put = function get(apiUrl, data) {
    return this.request(apiUrl, 'put', data);
};

Rest.prototype.post = function get(apiUrl, data) {
    return this.request(apiUrl, 'post', data);
};

Rest.prototype.delete = function get(apiUrl, data) {
    return this.request(apiUrl, 'delete', data);
};

Rest.prototype.putFile = function putFile(apiUrl, data) {
    // NOTE basic putFile implementation, one file, use fileUpload?
    return this.request(apiUrl, 'delete', data, 'multipart/form-data');
};

Rest.prototype.request = function request(apiUrl, httpMethod, data, contentType) {
    
    var thisRest = this;
    var url = this.baseUrl + apiUrl;

    // Using a promise to avoid the differences and problems of the jQuery thenable
    // object, but attaching its original value as a new property 'xhr' of the promise
    // created for advanced use.
    var xhr = $.ajax({
        url: url,
        // Avoid cache for data.
        cache: false,
        dataType: 'json',
        method: httpMethod,
        headers: this.extraHeaders,
        // URLENCODED input:
        // Convert to JSON and back just to ensure the values are converted/encoded
        // properly to be sent, like Dates being converted to ISO format.
        data: data && JSON.parse(JSON.stringify(data)),
        contentType: contentType || 'application/x-www-form-urlencoded'
        // Alternate: JSON as input
        //data: JSON.stringify(data),
        //contentType: contentType || 'application/json'
    });

    var promiseXhr = Promise.resolve(xhr)
    .then(lowerCamelizeObject)
    .catch(function(err) {
        // On authorization error, give oportunity to retry the operation
        if (err.status === 401) {
            var retry = request.bind(this, apiUrl, httpMethod, data, contentType);
            var retryPromise = thisRest.onAuthorizationRequired(retry);
            if (retryPromise) {
                // It returned something, expecting is a promise:
                return Promise.resolve(retryPromise)
                .catch(function(){
                    // There is error on retry, just return the
                    // original call error
                    return err;
                });
            }
        }
        // by default, continue propagating the error
        return err;
    });
    
    promiseXhr.xhr = xhr;
    return promiseXhr;
};

Rest.prototype.onAuthorizationRequired = function onAuthorizationRequired(/*retry*/) {
    // To be implemented outside, if convenient executing:
    //retry();
    // by default don't wait for retry, just return nothing:
    return;
};

module.exports = Rest;

},{}],91:[function(require,module,exports){
/**
    Time class utility.
    Shorter way to create a Date instance
    specifying only the Time part,
    defaulting to current date or 
    another ready date instance.
**/
function Time(date, hour, minute, second) {
    if (!(date instanceof Date)) {
 
        second = minute;
        minute = hour;
        hour = date;
        
        date = new Date();   
    }

    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hour || 0, minute || 0, second || 0);
}
module.exports = Time;

},{}],92:[function(require,module,exports){
/**
    Create an Access Control for an app that just checks
    the activity property for allowed user level.
    To be provided to Shell.js and used by the app.js,
    very tied to that both classes.
    
    Activities can define on its object an accessLevel
    property like next examples
    
    this.accessLevel = app.Usertype.User; // anyone
    this.accessLevel = app.UserType.Anonymous; // anonymous users only
    this.accessLevel = app.UserType.LoggedUser; // authenticated users only
**/
'use strict';

// UserType enumeration is bit based, so several
// users can has access in a single property
//var UserType = require('../models/User').UserType;

module.exports = function createAccessControl(app) {
    
    return function accessControl(route) {

        var activity = app.getActivityControllerByRoute(route);

        var user = app.model.user();
        var currentType = user && user.userType();

        if (activity && activity.accessLevel) {

            var can = activity.accessLevel & currentType;
            
            if (!can) {
                // Notify error, why cannot access
                return {
                    requiredLevel: activity.accessLevel,
                    currentType: currentType
                };
            }
        }

        // Allow
        return null;
    };
};

},{}],93:[function(require,module,exports){
/**
    Bootknock: Set of Knockout Binding Helpers for Bootstrap js components (jquery plugins)
    
    Dependencies: jquery
    Injected dependencies: knockout
**/
'use strict';

// Dependencies
var $ = require('jquery');
// DI i18n library
exports.i18n = null;

function createHelpers(ko) {
    var helpers = {};

    /** Popover Binding **/
    helpers.popover = {
        update: function(element, valueAccessor) {
            var srcOptions = ko.unwrap(valueAccessor());

            // Duplicating options object to pass to popover without
            // overwrittng source configuration
            var options = $.extend(true, {}, srcOptions);
            
            // Unwrapping content text
            options.content = ko.unwrap(srcOptions.content);
            
            if (options.content) {
            
                // Localize:
                options.content = 
                    exports.i18n && exports.i18n.t(options.content) ||
                    options.content;
                
                // To get the new options, we need destroy it first:
                $(element).popover('destroy').popover(options);

                // Se muestra si el elemento tiene el foco
                if ($(element).is(':focus'))
                    $(element).popover('show');

            } else {
                $(element).popover('destroy');
            }
        }
    };
    
    return helpers;
}

/**
    Plug helpers in the provided Knockout instance
**/
function plugIn(ko, prefix) {
    var name,
        helpers = createHelpers(ko);
    
    for(var h in helpers) {
        if (helpers.hasOwnProperty && !helpers.hasOwnProperty(h))
            continue;

        name = prefix ? prefix + h[0].toUpperCase() + h.slice(1) : h;
        ko.bindingHandlers[name] = helpers[h];
    }
}

exports.plugIn = plugIn;
exports.createBindingHelpers = createHelpers;

},{}],94:[function(require,module,exports){
/**
    Knockout Binding Helper for the Bootstrap Switch plugin.
    
    Dependencies: jquery, bootstrap, bootstrap-switch
    Injected dependencies: knockout
    
    IMPORTANT NOTES:
    - A console error of type "object has not that property" will happen if specified
        a non existant option in the binding. The error looks strange when using the minified file.
    - The order of options in the binding matters when combining with disabled and readonly
        options: if the element is disabled:true or readonly:true, any attempt to change the
        value will fail silently, so if the same binding update changes disabled to false
        and the state, the 'disabled' change must happens before the 'state' change so both
        are successfully updated. For that, just specify 'disabled' before 'state' in the bindings
        definition.
**/
'use strict';

// Dependencies
var $ = require('jquery');
require('bootstrap');
require('bootstrap-switch');

/**
    Create and plug-in the Binding in the provided Knockout instance
**/
exports.plugIn = function plugIn(ko, prefix) {

    ko.bindingHandlers[prefix ? prefix + 'switch' : 'switch'] = {
        init: function(element, valueAccessor) {
            // Create plugin instance
            $(element).bootstrapSwitch();
            
            //console.log('switch init', ko.toJS(valueAccessor()));

            // Updating value on plugin changes
            $(element).on('switchChange.bootstrapSwitch', function (e, state) {
                var v = valueAccessor() || {};
                //console.log('switchChange', ko.toJS(v));
                
                // changed?
                var oldState = !!ko.unwrap(v.state),
                    newState = !!state;
                // Only update on change
                if (oldState !== newState) {
                    if (ko.isObservable(v.state)) {
                        if (ko.isWriteableObservable(v.state)) {
                            v.state(newState);
                        }
                    } else {
                        v.state = newState;
                    }
                }
            });
        },
        update: function(element, valueAccessor) {
            // Get options to be applied to the plugin instance
            var srcOptions = valueAccessor();
            
            var options = srcOptions || {};

            // Unwrapping every option value, getting a duplicated
            // plain object
            options = ko.toJS(options);
            //console.log('switch update', options);

            var $el = $(element);
            // Update every option in the plugin
            Object.keys(options).forEach(function(key) {
                $el.bootstrapSwitch(key, options[key]);
            });
        }
    };
};

},{}],95:[function(require,module,exports){
/**
    Espace a string for use on a RegExp.
    Usually, to look for a string in a text multiple times
    or with some expressions, some common are 
    look for a text 'in the beginning' (^)
    or 'at the end' ($).
    
    Author: http://stackoverflow.com/users/151312/coolaj86 and http://stackoverflow.com/users/9410/aristotle-pagaltzis
    Link: http://stackoverflow.com/a/6969486
**/
'use strict';

// Referring to the table here:
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
// these characters should be escaped
// \ ^ $ * + ? . ( ) | { } [ ]
// These characters only have special meaning inside of brackets
// they do not need to be escaped, but they MAY be escaped
// without any adverse effects (to the best of my knowledge and casual testing)
// : ! , = 
// my test "~!@#$%^&*(){}[]`/=?+\|-_;:'\",<.>".match(/[\#]/g)

var specials = [
    // order matters for these
      "-"
    , "["
    , "]"
    // order doesn't matter for any of these
    , "/"
    , "{"
    , "}"
    , "("
    , ")"
    , "*"
    , "+"
    , "?"
    , "."
    , "\\"
    , "^"
    , "$"
    , "|"
  ]

  // I choose to escape every character with '\'
  // even though only some strictly require it when inside of []
, regex = RegExp('[' + specials.join('\\') + ']', 'g')
;

var escapeRegExp = function (str) {
return str.replace(regex, "\\$&");
};

module.exports = escapeRegExp;

// test escapeRegExp("/path/to/res?search=this.that")

},{}],96:[function(require,module,exports){
/**
* escapeSelector
*
* source: http://kjvarga.blogspot.com.es/2009/06/jquery-plugin-to-escape-css-selector.html
*
* Escape all special jQuery CSS selector characters in *selector*.
* Useful when you have a class or id which contains special characters
* which you need to include in a selector.
*/
'use strict';

var specials = [
  '#', '&', '~', '=', '>', 
  "'", ':', '"', '!', ';', ','
];
var regexSpecials = [
  '.', '*', '+', '|', '[', ']', '(', ')', '/', '^', '$'
];
var sRE = new RegExp(
  '(' + specials.join('|') + '|\\' + regexSpecials.join('|\\') + ')', 'g'
);

module.exports = function(selector) {
  return selector.replace(sRE, '\\$1');
};

},{}],97:[function(require,module,exports){
/** getDateWithoutTime utility.
    Returns a new Date instance with time at zeroes
    and the same date as the input.
    It returns current date if no valid date or string passed.
**/
'use strict';

module.exports = function getDateWithoutTime(date) {
    if (!date) {
        date = new Date();
    }
    else if (!(date instanceof Date)) {
        date = new Date(date);
    }

    return new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        0, 0, 0
    );
};

},{}],98:[function(require,module,exports){
/**
    Get a given value wrapped in an observable or returns
    it if its already an observable or just a function.
**/
'use strict';
var ko = require('knockout');

module.exports = function getObservable(obsOrValue) {
    if (typeof(obsOrValue) === 'function')
        return obsOrValue;
    else
        return ko.observable(obsOrValue);
};

},{"knockout":false}],99:[function(require,module,exports){
/**
    Read a page's GET URL variables and return them as an associative array.
**/
'user strict';
//global window

module.exports = function getUrlQuery(url) {

    url = url || window.location.href;

    var vars = [], hash,
        queryIndex = url.indexOf('?');
    if (queryIndex > -1) {
        var hashes = url.slice(queryIndex + 1).split('&');
        for(var i = 0; i < hashes.length; i++)
        {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }
    }
    return vars;
};

},{}],100:[function(require,module,exports){
// jQuery plugin to set multiline text in an element,
// by replacing \n by <br/> with careful to avoid XSS attacks.
// http://stackoverflow.com/a/13082028
'use strict';

var $ = require('jquery');

$.fn.multiline = function(text) {
    this.text(text);
    this.html(this.html().replace(/\n/g,'<br/>'));
    return this;
};

},{}],101:[function(require,module,exports){
/**
    Set of utilities to define Javascript Properties
    independently of the browser.
    
    Allows to define getters and setters.
    
    Adapted code from the original created by Jeff Walden
    http://whereswalden.com/2010/04/16/more-spidermonkey-changes-ancient-esoteric-very-rarely-used-syntax-for-creating-getters-and-setters-is-being-removed/
**/
'use strict';

function accessorDescriptor(field, fun)
{
    var desc = { enumerable: true, configurable: true };
    desc[field] = fun;
    return desc;
}

function defineGetter(obj, prop, get)
{
    if (Object.defineProperty)
        return Object.defineProperty(obj, prop, accessorDescriptor("get", get));
    if (Object.prototype.__defineGetter__)
        return obj.__defineGetter__(prop, get);

    throw new Error("browser does not support getters");
}

function defineSetter(obj, prop, set)
{
    if (Object.defineProperty)
        return Object.defineProperty(obj, prop, accessorDescriptor("set", set));
    if (Object.prototype.__defineSetter__)
        return obj.__defineSetter__(prop, set);

    throw new Error("browser does not support setters");
}

module.exports = {
    defineGetter: defineGetter,
    defineSetter: defineSetter
};

},{}],102:[function(require,module,exports){
/**
    Remove the accent and special characters from a text
    replacing each character for its basic equivalent.
    Useful to performs punctuation-insensitive text searchs.
**/
'use strict';

var map = {'':'A','':'A','':'A','':'A','':'A','':'A','':'AE','':'C','':'E','':'E','':'E','':'E','':'I','':'I','':'I','':'I','':'D','':'N','':'O','':'O','':'O','':'O','':'O','':'O','':'U','':'U','':'U','':'U','':'Y','':'s','':'a','':'a','':'a','':'a','':'a','':'a','':'ae','':'c','':'e','':'e','':'e','':'e','':'i','':'i','':'i','':'i','':'n','':'o','':'o','':'o','':'o','':'o','':'o','':'u','':'u','':'u','':'u','':'y','':'y','':'A','':'a','':'A','':'a','':'A','':'a','':'C','':'c','':'C','':'c','':'C','':'c','':'C','':'c','':'D','':'d','':'D','':'d','':'E','':'e','':'E','':'e','':'E','':'e','':'E','':'e','':'E','':'e','':'G','':'g','':'G','':'g','':'G','':'g','':'G','':'g','':'H','':'h','':'H','':'h','':'I','':'i','':'I','':'i','':'I','':'i','':'I','':'i','':'I','':'i','':'IJ','':'ij','':'J','':'j','':'K','':'k','':'L','':'l','':'L','':'l','':'L','':'l','':'L','':'l','':'L','':'l','':'N','':'n','':'N','':'n','':'N','':'n','':'n','':'O','':'o','':'O','':'o','':'O','':'o','':'OE','':'oe','':'R','':'r','':'R','':'r','':'R','':'r','':'S','':'s','':'S','':'s','':'S','':'s','':'S','':'s','':'T','':'t','':'T','':'t','':'T','':'t','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'W','':'w','':'Y','':'y','':'Y','':'Z','':'z','':'Z','':'z','':'Z','':'z','':'s','':'f','':'O','':'o','':'U','':'u','':'A','':'a','':'I','':'i','':'O','':'o','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'A','':'a','':'AE','':'ae','':'O','':'o'};

module.exports = function removeAccent(str) {

    var res = '', c;
    for (var i = 0, l = str.length; i < l; i++) {
        c = str.charAt(i);
        res += map[c] || c;
    }
    return res;
};

},{}],103:[function(require,module,exports){
/**
    DomItemsManager class, that manage a collection 
    of HTML/DOM items under a root/container, where
    only one element at the time is visible, providing
    tools to uniquerly identify the items,
    to create or update new items (through 'inject'),
    get the current, find by the ID and more.
**/
'use strict';

var $ = require('jquery');
var escapeSelector = require('../escapeSelector');

function DomItemsManager(settings) {

    this.idAttributeName = settings.idAttributeName || 'id';
    this.allowDuplicates = !!settings.allowDuplicates || false;
    this.$root = null;
    // On page ready, get the root element:
    $(function() {
        this.$root = $(settings.root || 'body');
    }.bind(this));
}

module.exports = DomItemsManager;

DomItemsManager.prototype.find = function find(containerName, root) {
    var $root = $(root || this.$root);
    return $root.find('[' + this.idAttributeName + '="' + escapeSelector(containerName) + '"]');
};

DomItemsManager.prototype.getActive = function getActive() {
    return this.$root.find('[' + this.idAttributeName + ']:visible');
};

/**
    It adds the item in the html provided (can be only the element or 
    contained in another or a full html page).
    Replaces any existant if duplicates are not allowed.
**/
DomItemsManager.prototype.inject = function inject(name, html) {

    // Filtering input html (can be partial or full pages)
    // http://stackoverflow.com/a/12848798
    html = html.replace(/^[\s\S]*<body.*?>|<\/body>[\s\S]*$/g, '');

    // Creating a wrapper around the html
    // (can be provided the innerHtml or outerHtml, doesn't matters with next approach)
    var $html = $('<div/>', { html: html }),
        // We look for the container element (when the outerHtml is provided)
        $c = this.find(name, $html);

    if ($c.length === 0) {
        // Its innerHtml, so the wrapper becomes the container itself
        $c = $html.attr(this.idAttributeName, name);
    }

    if (!this.allowDuplicates) {
        // No more than one container instance can exists at the same time
        // We look for any existent one and its replaced with the new
        var $prev = this.find(name);
        if ($prev.length > 0) {
            $prev.replaceWith($c);
            $c = $prev;
        }
    }

    // Add to the document
    // (on the case of duplicated found, this will do nothing, no worry)
    $c.appendTo(this.$root);
};

/** 
    The switch method receive the items to interchange as active or current,
    the 'from' and 'to', and the shell instance that MUST be used
    to notify each event that involves the item:
    willClose, willOpen, ready, opened, closed.
    It receives as latest parameter the 'notification' object that must be
    passed with the event so handlers has context state information.
    
    It's designed to be able to manage transitions, but this default
    implementation is as simple as 'show the new and hide the old'.
**/
DomItemsManager.prototype.switch = function switchActiveItem($from, $to, shell, notification) {

    if (!$to.is(':visible')) {
        shell.emit(shell.events.willOpen, $to, notification);
        $to.show();
        // Its enough visible and in DOM to perform initialization tasks
        // that may involve layout information
        shell.emit(shell.events.itemReady, $to, notification);
        // When its completely opened
        shell.emit(shell.events.opened, $to, notification);
    } else {
        // Its ready; maybe it was but sub-location
        // or state change need to be communicated
        shell.emit(shell.events.itemReady, $to, notification);
    }

    if ($from.is(':visible')) {
        shell.emit(shell.events.willClose, $from, notification);
        // Do 'unfocus' on the hidden element after notify 'willClose'
        // for better UX: hidden elements are not reachable and has good
        // side effects like hidding the on-screen keyboard if an input was
        // focused
        $from.find(':focus').blur();
        // hide and notify it ended
        $from.hide();
        shell.emit(shell.events.closed, $from, notification);
    }
};

/**
    Initializes the list of items. No more than one
    must be opened/visible at the same time, so at the 
    init all the elements are closed waiting to set
    one as the active or the current one.
**/
DomItemsManager.prototype.init = function init() {
    this.getActive().hide();
};

},{"../escapeSelector":96}],104:[function(require,module,exports){
/**
    Javascritp Shell for SPAs.
**/
/*global window, document */
'use strict';

/** DI entry points for default builds. Most dependencies can be
    specified in the constructor settings for per-instance setup.
**/
var deps = require('./dependencies');

/** Constructor **/

function Shell(settings) {
    //jshint maxcomplexity:14
    
    deps.EventEmitter.call(this);

    this.$ = settings.jquery || deps.jquery;
    this.$root = this.$(settings.root);
    this.baseUrl = settings.baseUrl || '';
    // With forceHashbang=true:
    // - fragments URLs cannot be used to scroll to an element (default browser behavior),
    //   they are defaultPrevented to avoid confuse the routing mechanism and current URL.
    // - pressed links to fragments URLs are not routed, they are skipped silently
    //   except when they are a hashbang (#!). This way, special links
    //   that performn js actions doesn't conflits.
    // - all URLs routed through the shell includes a hashbang (#!), the shell ensures
    //   that happens by appending the hashbang to any URL passed in (except the standard hash
    //   that are skipt).
    this.forceHashbang = settings.forceHashbang || false;
    this.linkEvent = settings.linkEvent || 'click';
    this.parseUrl = (settings.parseUrl || deps.parseUrl).bind(this, this.baseUrl);
    this.absolutizeUrl = (settings.absolutizeUrl || deps.absolutizeUrl).bind(this, this.baseUrl);

    this.history = settings.history || window.history;

    this.indexName = settings.indexName || 'index';
    
    this.items = settings.domItemsManager;

    // loader can be disabled passing 'null', so we must
    // ensure to not use the default on that cases:
    this.loader = typeof(settings.loader) === 'undefined' ? deps.loader : settings.loader;
    // loader setup
    if (this.loader)
        this.loader.baseUrl = this.baseUrl;

    // Definition of events that this object can trigger,
    // its value can be customized but any listener needs
    // to keep updated to the correct event string-name used.
    // The items manipulation events MUST be triggered
    // by the 'items.switch' function
    this.events = {
        willOpen: 'shell-will-open',
        willClose: 'shell-will-close',
        itemReady: 'shell-item-ready',
        closed: 'shell-closed',
        opened: 'shell-opened'
    };
    
    /**
        A function to decide if the
        access is allowed (returns 'null')
        or not (return a state object with information
        that will be passed to the 'nonAccessName' item;
        the 'route' property on the state is automatically filled).
        
        The default buit-in just allow everything 
        by just returning 'null' all the time.
        
        It receives as parameter the state object,
        that almost contains the 'route' property with
        information about the URL.
    **/
    this.accessControl = settings.accessControl || deps.accessControl;
    // What item load on non access
    this.nonAccessName = settings.nonAccessName || 'index';
}

// Shell inherits from EventEmitter
Shell.prototype = Object.create(deps.EventEmitter.prototype, {
    constructor: {
        value: Shell,
        enumerable: false,
        writable: true,
        configurable: true
    }
});

module.exports = Shell;


/** API definition **/

Shell.prototype.go = function go(url, state) {

    if (this.forceHashbang) {
        if (!/^#!/.test(url)) {
            url = '#!' + url;
        }
    }
    else {
        url = this.absolutizeUrl(url);
    }
    this.history.pushState(state, undefined, url);
    // pushState do NOT trigger the popstate event, so
    return this.replace(state);
};

Shell.prototype.goBack = function goBack(state, steps) {
    steps = 0 - (steps || 1);
    // If there is nothing to go-back or not enought
    // 'back' steps, go to the index
    if (steps < 0 && Math.abs(steps) >= this.history.length) {
        this.go(this.indexName);
    }
    else {
        // On replace, the passed state is merged with
        // the one that comes from the saved history
        // entry (it 'pops' when doing the history.go())
        this._pendingStateUpdate = state;
        this.history.go(steps);
    }
};

/**
    Process the given state in order to get the current state
    based on that or the saved in history, merge it with
    any updated state pending and adds the route information,
    returning an state object suitable to use.
**/
Shell.prototype.getUpdatedState = function getUpdatedState(state) {
    /*jshint maxcomplexity: 8 */
    
    // For current uses, any pendingStateUpdate is used as
    // the state, rather than the provided one
    state = this._pendingStateUpdate || state || this.history.state || {};
    
    // TODO: more advanced uses must be to use the 'state' to
    // recover the UI state, with any message from other UI
    // passing in a way that allow update the state, not
    // replace it (from pendingStateUpdate).
    /*
    // State or default state
    state = state || this.history.state || {};
    // merge pending updated state
    this.$.extend(state, this._pendingStateUpdate);
    // discard the update
    */
    this._pendingStateUpdate = null;
    
    // Doesn't matters if state includes already 
    // 'route' information, need to be overwritten
    // to match the current one.
    // NOTE: previously, a check prevented this if
    // route property exists, creating infinite loops
    // on redirections from activity.show since 'route' doesn't
    // match the new desired location
    
    // Detect if is a hashbang URL or an standard one.
    // Except if the app is forced to use hashbang.
    var isHashBang = /#!/.test(location.href) || this.forceHashbang;
    
    var link = (
        isHashBang ?
        location.hash :
        location.pathname
    ) + (location.search || '');
    
    // Set the route
    state.route = this.parseUrl(link);
    
    return state;
};

Shell.prototype.replace = function replace(state) {
    
    state = this.getUpdatedState(state);

    // Use the index on root calls
    if (state.route.root === true) {
        state.route = this.parseUrl(this.indexName);
    }
    
    // Access control
    var accessError = this.accessControl(state.route);
    if (accessError) {
        return this.go(this.nonAccessName, accessError);
    }

    // Locating the container
    var $cont = this.items.find(state.route.name);
    var shell = this;
    var promise = null;

    if ($cont && $cont.length) {
        promise = new Promise(function(resolve, reject) {
            try {

                var $oldCont = shell.items.getActive();
                $oldCont = $oldCont.not($cont);
                shell.items.switch($oldCont, $cont, shell, state);

                resolve(); //? resolve(act);
            }
            catch (ex) {
                reject(ex);
            }
        });
    }
    else {
        if (this.loader) {
            // load and inject the content in the page
            // then try the replace again
            promise = this.loader.load(state.route).then(function(html) {
                // Add to the items (the manager takes care you
                // add only the item, if there is one)
                shell.items.inject(state.route.name, html);
                // Double check that the item was added and is ready
                // to avoid an infinite loop because a request not returning
                // the item and the 'replace' trying to load it again, and again, and..
                if (shell.items.find(state.route.name).length)
                    return shell.replace(state);
            });
        }
        else {
            var err = new Error('Page not found (' + state.route.name + ')');
            console.warn('Shell Page not found, state:', state);
            promise = Promise.reject(err);
            
            // To avoid being in an inexistant URL (generating inconsistency between
            // current view and URL, creating bad history entries),
            // a goBack is executed, just after the current pipe ends
            // TODO: implement redirect that cut current processing rather than execute delayed
            setTimeout(function() {
                this.goBack();
            }.bind(this), 1);
        }
    }
    
    var thisShell = this;
    promise.catch(function(err) {
        if (!(err instanceof Error))
            err = new Error(err);

        // Log error, 
        console.error('Shell, unexpected error.', err);
        // notify as an event
        thisShell.emit('error', err);
        // and continue propagating the error
        return err;
    });

    return promise;
};

Shell.prototype.run = function run() {

    var shell = this;

    // Catch popstate event to update shell replacing the active container.
    // Allows polyfills to provide a different but equivalent event name
    this.$(window).on(this.history.popstateEvent || 'popstate', function(event) {
        
        var state = event.state || 
            (event.originalEvent && event.originalEvent.state) || 
            shell.history.state;

        // get state for current. To support polyfills, we use the general getter
        // history.state as fallback (they must be the same on browsers supporting History API)
        shell.replace(state);
    });

    // Catch all links in the page (not only $root ones) and like-links.
    // IMPORTANT: the timeout and linkWorking is a kind of hack/workaround because of:
    // - iOS click delay: changing linkEvent to be 'tap click' (jqm tap event) or 
    //   more standard but simplistic 'touchend click', only on iOS if possible, the
    //   iOS click delay can be avoided, letting the touch event to trigger this Shell handler
    //   and preventing the click from happening to avoid double execution
    //   (thanks to linkWorking and setTimeout).
    //   A broken alternative would be to use only one event, like 'tap' or 'touchend', but
    //   they fall down when a touch gesture happens in the limit of a link/element because
    //   a touchstart happens out of our target link -failing touchend and tap since don't 
    //   get triggered in our link- but the browser/webview still executes (and inmediatly)
    //   the 'click' event on the link. It seems an edge case but is easier to make it happens
    //   than it seems. It's the bug that forced to implement this workaournd :-/
    // - And additionally: it prevents wo 'clicks' from happening excessive fast because
    //   some kind of a second unwanted touch happening very fast, making
    //   a click by mistake on a different link on the loaded new page.
    var linkWorking = null,
        // iOS 300ms delay, a bit increased to avoid problems.
        linkWorkingDelay = 340;
    //DEBUG var linkEvent = this.linkEvent;
    this.$(document).on(this.linkEvent, '[href], [data-href]', function(e) {
        //DEBUG console.log('Shell on event', e.type, linkWorking);
        // If working, avoid everything:
        if (linkWorking) return false;
        linkWorking = setTimeout(function() {
            linkWorking = null;
        }, linkWorkingDelay);

        var $t = shell.$(this),
            href = $t.attr('href') || $t.data('href');
        
        //DEBUG console.log('Shell on', linkEvent, e.type, 'href', href, 'element', $t);

        // Do nothing if the URL contains the protocol
        if (/^[a-z]+:/i.test(href)) {
            return;
        }
        else if (shell.forceHashbang && /^#([^!]|$)/.test(href)) {
            // Standard hash, but not hashbang: avoid routing and default behavior
            e.preventDefault();
            // Trigger special event on the shell, so external scripts can do
            // something, like trying to implement standard scroll behavior or any
            // Pass in: source fragment link, element that receive the original event and
            // the original event.
            shell.emit('fragmentNavigation', href, this, e);
            return;
        }

        e.preventDefault();

        // Executed delayed to avoid handler collisions, because
        // of the new page modifying the element and other handlers
        // reading it attributes and applying logic on the updated link
        // as if was the old one (example: shared links, like in a
        // global navbar, that modifies with the new page).
        setTimeout(function() {
            shell.go(href);
        }, 1);
    });

    // Initiallize state
    this.items.init();
    // Route to the current url/state
    this.replace();
};

},{"./dependencies":106}],105:[function(require,module,exports){
/**
    absolutizeUrl utility 
    that ensures the url provided
    being in the path of the given baseUrl
**/
'use strict';

var sanitizeUrl = require('./sanitizeUrl'),
    escapeRegExp = require('../escapeRegExp');

function absolutizeUrl(baseUrl, url) {

    // sanitize before check
    url = sanitizeUrl(url);

    // Check if use the base already
    var matchBase = new RegExp('^' + escapeRegExp(baseUrl), 'i');
    if (matchBase.test(url)) {
        return url;
    }

    // build and sanitize
    return sanitizeUrl(baseUrl + url);
}

module.exports = absolutizeUrl;

},{"../escapeRegExp":95,"./sanitizeUrl":111}],106:[function(require,module,exports){
/**
    External dependencies for Shell in a separate module
    to use as DI, needs setup before call the Shell.js
    module class
**/
'use strict';

module.exports = {
    parseUrl: null,
    absolutizeUrl: null,
    jquery: null,
    loader: null,
    accessControl: function allowAll(/*name*/) {
        // allow access by default
        return null;
    },
    EventEmitter: null
};

},{}],107:[function(require,module,exports){
/**
    Simple implementation of the History API using only hashbangs URLs,
    doesn't matters the browser support.
    Used to avoid from setting URLs that has not an end-point,
    like in local environments without a server doing url-rewriting,
    in phonegap apps, or to completely by-pass browser support because
    is buggy (like Android <= 4.1).
    
    NOTES:
    - Browser must support 'hashchange' event.
    - Browser must has support for standard JSON class.
    - Relies on sessionstorage for persistance, supported by all browsers and webviews 
      for a enough long time now.
    - Similar approach as History.js polyfill, but simplified, appending a fake query
      parameter '_suid=0' to the hash value (actual query goes before the hash, but
      we need it inside).
    - For simplification, only the state is persisted, the 'title' parameter is not
      used at all (the same as major browsers do, so is not a problem); in this line,
      only history entries with state are persisted.
**/
//global location
'use strict';
var $ = require('jquery'),
    sanitizeUrl = require('./sanitizeUrl'),
    getUrlQuery = require('../getUrlQuery');

// Init: Load saved copy from sessionStorage
var session = sessionStorage.getItem('hashbangHistory.store');
// Or create a new one
if (!session) {
    session = {
        // States array where each index is the SUID code and the
        // value is just the value passed as state on pushState/replaceState
        states: []
    };
}
else {
    session = JSON.parse(session);
}


/**
    Get the SUID number
    from a hash string
**/
function getSuid(hash) {
    
    var suid = +getUrlQuery(hash)._suid;
    if (isNaN(suid))
        return null;
    else
        return suid;
}

function setSuid(hash, suid) {
    
    // We need the query, since we need 
    // to replace the _suid (may exist)
    // and recreate the query in the
    // returned hash-url
    var qs = getUrlQuery(hash);
    qs.push('_suid');
    qs._suid = suid;

    var query = [];
    for(var i = 0; i < qs.length; i++) {
        query.push(qs[i] + '=' + encodeURIComponent(qs[qs[i]]));
    }
    query = query.join('&');
    
    if (query) {
        var index = hash.indexOf('?');
        if (index > -1)
            hash = hash.substr(0, index);
        hash += '?' + query;
    }

    return hash;
}

/**
    Ask to persist the session data.
    It is done with a timeout in order to avoid
    delay in the current task mainly any handler
    that acts after a History change.
**/
function persist() {
    // Enough time to allow routing tasks,
    // most animations from finish and the UI
    // being responsive.
    // Because sessionStorage is synchronous.
    setTimeout(function() {
        sessionStorage.setItem('hashbangHistory.store', JSON.stringify(session));
    }, 1500);
}

/**
    Returns the given state or null
    if is an empty object.
**/
function checkState(state) {
    
    if (state) {
        // is empty?
        if (Object.keys(state).length > 0) {
            // No
            return state;
        }
        // its empty
        return null;
    }
    // Anything else
    return state;
}

/**
    Get a canonical representation
    of the URL so can be compared
    with success.
**/
function cannonicalUrl(url) {
    
    // Avoid some bad or problematic syntax
    url = sanitizeUrl(url || '');
    
    // Get the hash part
    var ihash = url.indexOf('#');
    if (ihash > -1) {
        url = url.substr(ihash + 1);
    }
    // Maybe a hashbang URL, remove the
    // 'bang' (the hash was removed already)
    url = url.replace(/^!/, '');

    return url;
}

/**
    Tracks the latest URL
    being pushed or replaced by
    the API.
    This allows later to avoid
    trigger the popstate event,
    since must NOT be triggered
    as a result of that API methods
**/
var latestPushedReplacedUrl = null;

/**
    History Polyfill
**/
var hashbangHistory = {
    pushState: function pushState(state, title, url) {

        // cleanup url
        url = cannonicalUrl(url);
        
        // save new state for url
        state = checkState(state) || null;
        if (state !== null) {
            // save state
            session.states.push(state);
            var suid = session.states.length - 1;
            // update URL with the suid
            url = setSuid(url, suid);
            // call to persist the updated session
            persist();
        }
        
        latestPushedReplacedUrl = url;
        
        // update location to track history:
        location.hash = '#!' + url;
    },
    replaceState: function replaceState(state, title, url) {
        
        // cleanup url
        url = cannonicalUrl(url);
        
        // it has saved state?
        var suid = getSuid(url),
            hasOldState = suid !== null;

        // save new state for url
        state = checkState(state) || null;
        // its saved if there is something to save
        // or something to destroy
        if (state !== null || hasOldState) {
            // save state
            if (hasOldState) {
                // replace existing state
                session.states[suid] = state;
                // the url remains the same
            }
            else {
                // create state
                session.states.push(state);
                suid = session.states.length - 1;
                // update URL with the suid
                url = setSuid(url, suid);
            }
            // call to persist the updated session
            persist();
        }
        
        latestPushedReplacedUrl = url;

        // update location to track history:
        location.hash = '#!' + url;
    },
    get state() {
        
        var suid = getSuid(location.hash);
        return (
            suid !== null ?
            session.states[suid] :
            null
        );
    },
    get length() {
        return window.history.length;
    },
    go: function go(offset) {
        window.history.go(offset);
    },
    back: function back() {
        window.history.back();
    },
    forward: function forward() {
        window.history.forward();
    }
};

// Attach hashcange event to trigger History API event 'popstate'
var $w = $(window);
$w.on('hashchange', function(e) {
    
    var url = e.originalEvent.newURL;
    url = cannonicalUrl(url);
    
    // An URL being pushed or replaced
    // must NOT trigger popstate
    if (url === latestPushedReplacedUrl)
        return;
    
    // get state from history entry
    // for the updated URL, if any
    // (can have value when traversing
    // history).
    var suid = getSuid(url),
        state = null;
    
    if (suid !== null)
        state = session.states[suid];

    $w.trigger(new $.Event('popstate', {
        state: state
    }), 'hashbangHistory');
});

// For HistoryAPI capable browsers, we need
// to capture the native 'popstate' event that
// gets triggered on our push/replaceState because
// of the location change, but too on traversing
// the history (back/forward).
// We will lock the event except when is
// the one we trigger.
//
// NOTE: to this trick to work, this must
// be the first handler attached for this
// event, so can block all others.
// ALTERNATIVE: instead of this, on the
// push/replaceState methods detect if
// HistoryAPI is native supported and
// use replaceState there rather than
// a hash change.
$w.on('popstate', function(e, source) {
    
    // Ensuring is the one we trigger
    if (source === 'hashbangHistory')
        return;
    
    // In other case, block:
    e.preventDefault();
    e.stopImmediatePropagation();
});

// Expose API
module.exports = hashbangHistory;

},{"../getUrlQuery":99,"./sanitizeUrl":111}],108:[function(require,module,exports){
/**
    Default build of the Shell component.
    It returns the Shell class as a module property,
    setting up the built-in modules as its dependencies,
    and the external 'jquery' and 'events' (for the EventEmitter).
    It returns too the built-it DomItemsManager class as a property for convenience.
**/
'use strict';

var deps = require('./dependencies'),
    DomItemsManager = require('./DomItemsManager'),
    parseUrl = require('./parseUrl'),
    absolutizeUrl = require('./absolutizeUrl'),
    $ = require('jquery'),
    loader = require('./loader'),
    EventEmitter = require('events').EventEmitter;

$.extend(deps, {
    parseUrl: parseUrl,
    absolutizeUrl: absolutizeUrl,
    jquery: $,
    loader: loader,
    EventEmitter: EventEmitter
});

// Dependencies are ready, we can load the class:
var Shell = require('./Shell');

exports.Shell = Shell;
exports.DomItemsManager = DomItemsManager;

},{"./DomItemsManager":103,"./Shell":104,"./absolutizeUrl":105,"./dependencies":106,"./loader":109,"./parseUrl":110,"events":false}],109:[function(require,module,exports){
/**
    Loader utility to load Shell items on demand with AJAX
**/
'use strict';

var $ = require('jquery');

module.exports = {
    
    baseUrl: '/',
    
    load: function load(route) {
        return new Promise(function(resolve, reject) {
            console.log('Shell loading on demand', route.name, route);
            $.ajax({
                url: module.exports.baseUrl + route.name + '.html',
                cache: false
                // We are loading the program and no loader screen in place,
                // so any in between interaction will be problematic.
                //async: false
            }).then(resolve, reject);
        });
    }
};

},{}],110:[function(require,module,exports){
/**
    parseUrl function detecting
    the main parts of the URL in a
    convenience way for routing.
**/
'use strict';

var getUrlQuery = require('../getUrlQuery'),
    escapeRegExp = require('../escapeRegExp');

function parseUrl(baseUrl, link) {

    link = link || '';

    var rawUrl = link;

    // hashbang support: remove the #! or single # and use the rest as the link
    link = link.replace(/^#!/, '').replace(/^#/, '');
    
    // remove optional initial slash or dot-slash
    link = link.replace(/^\/|^\.\//, '');

    // URL Query as an object, empty object if no query
    var query = getUrlQuery(link || '?');

    // remove query from the rest of URL to parse
    link = link.replace(/\?.*$/, '');

    // Remove the baseUrl to get the app base.
    var path = link.replace(new RegExp('^' + escapeRegExp(baseUrl), 'i'), '');

    // Get first segment or page name (anything until a slash or extension beggining)
    var match = /^\/?([^\/\.]+)[^\/]*(\/.*)*$/.exec(path);

    var parsed = {
        root: true,
        name: null,
        segments: null,
        path: null,
        url: rawUrl,
        query: query
    };

    if (match) {
        parsed.root = false;
        if (match[1]) {
            parsed.name = match[1];

            if (match[2]) {
                parsed.path = match[2];
                parsed.segments = match[2].replace(/^\//, '').split('/');
            }
            else {
                parsed.path = '/';
                parsed.segments = [];
            }
        }
    }

    return parsed;
}

module.exports = parseUrl;
},{"../escapeRegExp":95,"../getUrlQuery":99}],111:[function(require,module,exports){
/**
    sanitizeUrl utility that ensures
    that problematic parts get removed.
    
    As for now it does:
    - removes parent directory syntax
    - removes duplicated slashes
**/
'use strict';

function sanitizeUrl(url) {
    return url.replace(/\.{2,}/g, '').replace(/\/{2,}/g, '/');
}

module.exports = sanitizeUrl;
},{}],112:[function(require,module,exports){
/**
    Small utility to search a text fragment using
    case insensitive, accent/symbol insensitive.
**/
'use strict';

var removeAccent = require('./removeAccent');

module.exports = function textSearch(search, text) {

    var s = removeAccent(search || '').toLowerCase(),
        t = removeAccent(text || '').toLowerCase();

    return t.indexOf(s) > -1;
};

},{"./removeAccent":102}],113:[function(require,module,exports){
/** 
    AppModel extension,
    focused on the Account related APIs:
    - login
    - logout
    - signup
**/
'use strict';

var localforage = require('localforage');

exports.plugIn = function (AppModel) {
    /**
        Try to perform an automatic login if there is a local
        copy of credentials to use on that,
        calling the login method that save the updated
        data and profile.
    **/
    AppModel.prototype.tryLogin = function tryLogin() {
        // Get saved credentials
        return localforage.getItem('credentials')
        .then(function(credentials) {
            // If we have ones, try to log-in
            if (credentials) {
                // Attempt login with that
                return this.login(
                    credentials.username,
                    credentials.password
                );
            } else {
                throw new Error('No saved credentials');
            }
        }.bind(this));
    };

    /**
        Performs a login attempt with the API by using
        the provided credentials.
    **/
    AppModel.prototype.login = function login(username, password) {

        // Reset the extra headers to attempt the login
        this.rest.extraHeaders = null;

        return this.rest.post('login', {
            username: username,
            password: password,
            returnProfile: true
        }).then(performLocalLogin(this, username, password));
    };

    /**
        Performs a logout, removing cached credentials
        and profile so the app can be filled up with
        new user information.
        It calls to the API logout call too, to remove
        any server-side session and notification
        (removes the cookie too, for browser environment
        that may use it).
    **/
    // FUTURE: TOREVIEW if the /logout call can be removed.
    AppModel.prototype.logout = function logout() {

        // Local app close session
        this.rest.extraHeaders = null;
        localforage.removeItem('credentials');
        localforage.removeItem('profile');
        
        // Local data clean-up!
        this.clearLocalData();

        // Don't need to wait the result of the REST operation
        this.rest.post('logout');

        return Promise.resolve();
    };

    /**
        Attempts to create a user account, getting logged
        if successfully like when doing a login call.
    **/
    AppModel.prototype.signup = function signup(username, password, profileType) {

        // Reset the extra headers to attempt the signup
        this.rest.extraHeadres = null;

        // The result is the same as in a login, and
        // we do the same as there to get the user logged
        // on the app on sign-up success.
        return this.rest.post('signup?utm_source=app', {
            username: username,
            password: password,
            profileType: profileType,
            returnProfile: true
        }).then(performLocalLogin(this, username, password));
    };
};

function performLocalLogin(thisAppModel, username, password) {

    return function(logged) {
        
        // Remove any previous local data if any:
        return thisAppModel.clearLocalData()
        .then(function() {

            // use authorization key for each
            // new Rest request
            thisAppModel.rest.extraHeaders = {
                alu: logged.userID,
                alk: logged.authKey
            };

            // async local save, don't wait
            localforage.setItem('credentials', {
                userID: logged.userID,
                username: username,
                password: password,
                authKey: logged.authKey
            });
            // IMPORTANT: Local name kept in sync with set-up at AppModel.userProfile
            localforage.setItem('profile', logged.profile);

            // Set user data
            thisAppModel.user().model.updateWith(logged.profile);

            return logged;
        });
    };
}

},{"localforage":false}],114:[function(require,module,exports){
/**
    Appointments is an abstraction around calendar events
    that behave as bookings or as events (where bookings are built
    on top of an event instance --a booking record must have ever a confirmedDateID event).
    
    With this appModel, the APIs to manage events&bookings are combined to offer related
    records easier in Appointments objects.
**/
'use strict';

var Appointment = require('../models/Appointment'),
    moment = require('moment');

exports.create = function create(appModel) {

    var api = {};
    
    var cache = {
        aptsByDate: {}
    };
    
    api.clearCache = function clearCache() {
        cache.aptsByDate = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Get a generic calendar appointment object, made of events and/or bookings,
        depending on the given ID in the ids object.
        
        TODO: Implement cache for the Appointment Models (the back-end models for
        bookings and events is already managed by its own API).
    **/
    api.getAppointment = function getAppointment(ids) {

        if (ids.calendarEventID) {
            return appModel.calendarEvents.getEvent(ids.calendarEventID)
            .then(Appointment.fromCalendarEvent);
        }
        else if (ids.bookingID) {
            return appModel.bookings.getBooking(ids.bookingID)
            .then(function(booking) {
                // An appointment for booking needs the confirmed event information
                return appModel.calendarEvents.getEvent(booking.confirmedDateID())
                .then(function(event) {
                    return Appointment.fromBooking(booking, event);
                });
            });
        }
        else {
            return Promise.reject('Unrecognized ID');
        }
    };
    
    api.setAppointment = function setAppointment(apt) {
        
        // If is a booking
        if (apt.sourceBooking()) {
            return appModel.bookings.setBooking(apt)
            .then(function(booking) {
                // We need the event information too
                return appModel.calendarEvents.getEvent(booking.confirmedDateID())
                .then(function(event) {
                    return Appointment.fromBooking(booking, event);
                });
            });
        }
        else if (apt.sourceEvent()) {
            return appModel.calendarEvents.setEvent(apt)
            .then(function(event) {
                return Appointment.fromEvent(event);
            });
        }
        else {
            return Promise.reject(new Error('Unrecognized appointment object'));
        }
    };
    
    /**
        Get a list of generic calendar appointment objects, made of events and/or bookings
        by Date.
        It's cached.
    **/
    api.getAppointmentsByDate = function getAppointmentsByDate(date) {
        var dateKey = moment(date).format('YYYYMMDD');
        if (cache.aptsByDate.hasOwnProperty(dateKey)) {
            
            return Promise.resolve(cache.aptsByDate[dateKey].data);

            // TODO lazy load, on background, for synchronization, depending on cache control
        }
        else {
            // TODO check localforage copy first?

            // Remote loading data
            return Promise.all([
                appModel.bookings.getBookingsByDate(date),
                appModel.calendarEvents.getEventsByDate(date)
            ]).then(function(group) {

                var events = group[1],
                    bookings = group[0],
                    apts = [];

                if (events && events().length) {
                    apts = Appointment.listFromCalendarEventsBookings(events(), bookings());
                }
                
                // TODO localforage copy of [dateKey]=bookings
                
                // Put in cache
                cache.aptsByDate[dateKey] = { data: apts };
                // Return the array
                return apts;
            });
        }
    };
    
    /**
        Introduce free slots wherever needed in the given
        array of Appointments, to fill any gap in a natural day
        (from Midnight to Midnight next date).
        A new array is returned, but the original gets sorted 
        by startTime.
    **/
    api.fillWithFreeSlots = function fillWithFreeSlots(appointmentsList) {

        // First, ensure list is sorted
        var slots = appointmentsList.sort(function(a, b) {
            return a.startTime() > b.startTime();
        });

        var filledSlots = [],
            zeroTime = '00:00:00',
            last = zeroTime,
            lastDateTime = null,
            timeFormat = 'HH:mm:ss';

        slots.forEach(function(slot) {
            var start = slot.startTime(),
                s = moment(start),
                end = slot.endTime(),
                e = moment(end);

            if (s.format(timeFormat) > last) {

                if (lastDateTime === null) {
                    // First slot of the date, 12AM=00:00
                    lastDateTime = new Date(
                        start.getFullYear(), start.getMonth(), start.getDate(),
                        0, 0, 0
                    );
                }

                // There is a gap, filled it
                filledSlots.push(Appointment.newFreeSlot({
                    start: lastDateTime,
                    end: start
                }));
            }

            filledSlots.push(slot);
            lastDateTime = end;
            last = e.format(timeFormat);
        });

        // Check latest to see a gap at the end:
        var lastEnd = lastDateTime && moment(lastDateTime).format(timeFormat);
        if (lastEnd !== zeroTime) {
            // There is a gap, filled it
            var nextMidnight = new Date(
                lastDateTime.getFullYear(),
                lastDateTime.getMonth(),
                // Next date!
                lastDateTime.getDate() + 1,
                // At zero hours!
                0, 0, 0
            );

            filledSlots.push(Appointment.newFreeSlot({
                start: lastDateTime,
                end: nextMidnight
            }));
        }

        return filledSlots;
    };
    
    return api;
};

},{"../models/Appointment":50,"moment":false}],115:[function(require,module,exports){
/** Bookings
**/
'use strict';

var Booking = require('../models/Booking'),
//  apiHelper = require('../utils/apiHelper'),
    moment = require('moment'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
        remote: {
            rest: appModel.rest,
            getBookings: function(filters) {
                return appModel.rest.get('bookings', filters)
                .then(function(rawItems) {
                    return rawItems && rawItems.map(function(rawItem) {
                        return new Booking(rawItem);
                    });
                });
            }
        }
    };
/*
    apiHelper.defineCrudApiForRest({
        extendedObject: api.remote,
        Model: Booking,
        modelName: 'Booking',
        modelListName: 'Bookings',
        modelUrl: 'bookings',
        idPropertyName: 'bookingID'
    });*/

    var cacheByDate = {};
    
    api.clearCache = function clearCache() {
        cacheByDate = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    api.getBookingsByDate = function getBookingsByDate(date) {
        var dateKey = moment(date).format('YYYYMMDD');
        if (cacheByDate.hasOwnProperty(dateKey)) {
            
            return Promise.resolve(cacheByDate[dateKey]);

            // TODO lazy load, on background, for synchronization
        }
        else {
            // TODO check localforage copy first

            // Remote loading data
            return api.remote.getBookings({
                start: date,
                end: moment(date).add(1, 'days').toDate()
            }).then(function(bookings) {
                // TODO localforage copy of [dateKey]=bookings

                // Put in cache (they are already model instances)
                var arr = ko.observableArray(bookings);
                cacheByDate[dateKey] = arr;
                // Return the observable array
                return arr;
            });
        }
    };
    
    /**
        Get upcoming bookings meta-information for dashboard page
        TODO: implement cache??
    **/
    api.getUpcomingBookings = function getUpcomingBookings() {
        return appModel.rest.get('upcoming-bookings');
    };

    /**
        Get a specific booking by ID
        TODO: Implement cache? reusing cacheByDate?
    **/
    api.getBooking = function getBooking(id) {
        if (!id) return Promise.reject('The bookingID is required to get a booking');
        return appModel.rest.get('bookings/' + id)
        .then(function(booking) {
            return new Booking(booking);
        });
    };
    
    /**
        Converts an Appointment model into a simplified
        booking plain object, suitable to REST API for edition
    **/
    api.appointmentToSimplifiedBooking = function(apt) {
        return {
            bookingID: apt.sourceBooking().bookingID(),
            customerUserID: apt.customerUserID(),
            addressID: apt.addressID(),
            startTime: apt.startTime(),
            pricing: apt.pricing().map(function(pricing) {
                // TODO: for now, the REST API allow only a list of IDs,
                // not objects, so next line is replaced:
                //return pricing.model.toPlainObject(true);
                return pricing.freelancerPricingID();
            }),
            preNotesToClient: apt.preNotesToClient(),
            preNotesToSelf: apt.preNotesToSelf(),
            postNotesToClient: apt.postNotesToClient(),
            postNotesToSelf: apt.postNotesToSelf()
        };
    };
    /**
        Converst a Booking model into a simplified
        booking plain object, suitable to REST API for edition
    **/
    api.bookingToSimplifiedBooking = function(booking) {
        return {
            bookingID: booking().bookingID(),
            customerUserID: booking.customerUserID(),
            addressID: booking.addressID(),
            startTime: booking.startTime(),
            pricing: booking.bookingRequest().pricingEstimate().details().pricing
            .map(function(pricing) {
                // TODO: for now, the REST API allow only a list of IDs,
                // not objects, so next line is replaced:
                //return pricing.model.toPlainObject(true);
                return pricing.freelancerPricingID();
            }),
            preNotesToClient: booking.preNotesToClient(),
            preNotesToSelf: booking.preNotesToSelf(),
            postNotesToClient: booking.postNotesToClient(),
            postNotesToSelf: booking.postNotesToSelf()
        };
    };
    
    /**
        Creates/updates a booking, given a simplified booking
        object or an Appointment model or a Booking model
    **/
    api.setBooking = function setBooking(booking) {    
        booking = booking.bookingID ?
            api.bookingToSimplifiedBooking(booking) :
            booking.sourceBooking ?
                api.appointmentToSimplifiedBooking(booking) :
                booking
        ;

        var id = booking.bookingID || '',
            method = id ? 'put' : 'post';

        return appModel.rest[method]('freelancer-bookings/' + id, booking)
        .then(function(serverBooking) {
            return new Booking(serverBooking);
        });
    };

    return api;
};

},{"../models/Booking":51,"knockout":false,"moment":false}],116:[function(require,module,exports){
/** Events
**/
'use strict';

var CalendarEvent = require('../models/CalendarEvent'),
//  apiHelper = require('../utils/apiHelper'),
    moment = require('moment'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
        remote: {
            rest: appModel.rest,
            getCalendarEvents: function(filters) {
                return appModel.rest.get('events', filters)
                .then(function(rawItems) {
                    return rawItems && rawItems.map(function(rawItem) {
                        return new CalendarEvent(rawItem);
                    });
                });
            }
        }
    };
    
    var cache = {
        eventsByDate: {}
    };
    
    api.clearCache = function clearCache() {
        cache.eventsByDate = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /*apiHelper.defineCrudApiForRest({
        extendedObject: api.remote,
        Model: CalendarEvent,
        modelName: 'CalendarEvent',
        modelListName: 'CalendarEvents',
        modelUrl: 'events',
        idPropertyName: 'calendarEventID'
    });*/

    api.getEventsByDate = function getEventsByDate(date) {
        var dateKey = moment(date).format('YYYYMMDD');
        if (cache.eventsByDate.hasOwnProperty(dateKey)) {
            
            return Promise.resolve(cache.eventsByDate[dateKey].data);

            // TODO lazy load, on background, for synchronization, based on cache control
        }
        else {
            // TODO check localforage copy first?

            // Remote loading data
            return api.remote.getCalendarEvents({
                start: date,
                end: moment(date).add(1, 'days').toDate()
            }).then(function(events) {
                // TODO localforage copy of [dateKey]=bookings

                // Put in cache (they are already model instances)
                var arr = ko.observableArray(events);
                cache.eventsByDate[dateKey] = { data: arr };
                // Return the observable array
                // TODO Review really if has sense to have an observable array, take care of its use (on appointments mainly)
                return arr;
            });
        }
    };
    
    /**
        Get a specific event by ID
        TODO: Implement cache. Reusing cacheByDate, re-index?
    **/
    api.getEvent = function getEvent(id) {
        if (!id) return Promise.reject('The calendarEventID is required to get an event');

        return appModel.rest.get('events/' + id)
        .then(function(event) {
            return new CalendarEvent(event);
        });
    };
    
    api.eventToSimplifiedEvent = function(/*event*/) {
        throw new Error('Not Implemented');
    };
    api.appointmentToSimplifiedEvent = function(/*event*/) {
        throw new Error('Not Implemented');
    };
    
    /**
        Creates/updates a booking, given a simplified booking
        object or an Appointment model or a Booking model
    **/
    api.setEvent = function setEvent(event) {

        event = event.calendarEventID ?
            api.eventToSimplifiedEvent(event) :
            event.sourceEvent ?
                api.appointmentToSimplifiedEvent(event) :
                event
        ;

        var id = event.calendarEventID || '',
            method = id ? 'put' : 'post';

        return appModel.rest[method]('events/' + id, event)
        .then(function(serverEvent) {
            return new CalendarEvent(serverEvent);
        });
    };

    return api;
};

},{"../models/CalendarEvent":54,"knockout":false,"moment":false}],117:[function(require,module,exports){
/** Calendar Syncing app model
**/
'use strict';

var ko = require('knockout'),
    CalendarSyncing = require('../models/CalendarSyncing'),
    RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new CalendarSyncing(),
        ttl: { minutes: 1 },
        localStorageName: 'calendarSyncing',
        fetch: function fetch() {
            return appModel.rest.get('calendar-syncing');
        },
        push: function push() {
            return appModel.rest.put('calendar-syncing', this.data.model.toPlainObject());
        }
    });
    
    // Extending with the special API method 'resetExportUrl'
    rem.isReseting = ko.observable(false);
    rem.resetExportUrl = function resetExportUrl() {
        
        rem.isReseting(true);

        return appModel.rest.post('calendar-syncing/reset-export-url')
        .then(function(updatedSyncSettings) {
            // Updating the cached data
            rem.data.model.updateWith(updatedSyncSettings);
            rem.isReseting(false);

            return updatedSyncSettings;
        });
    };
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });

    return rem;
};

},{"../models/CalendarSyncing":55,"../utils/RemoteModel":89,"knockout":false}],118:[function(require,module,exports){
/** Customers
**/
'use strict';

var Customer = require('../models/Customer');

var ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        listTtl: { minutes: 1 },
        itemIdField: 'customerUserID',
        Model: Customer
    });

    api.addLocalforageSupport('customers');
    api.addRestSupport(appModel.rest, 'customers');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    /**
        Public search of users, possible customers by well
        know fields, with full value match.
    **/
    var publicSearchRequest = null;
    api.publicSearch = function publicSearch(search) {

        // Only one request at a time
        if (publicSearchRequest &&
            publicSearchRequest.abort) {
            try {
                publicSearchRequest.abort();
            } catch (abortErr) {
                console.error('Error aborting request', abortErr);
            }
        }
        
        var request = appModel.rest.get('customers/public-search', search);
        publicSearchRequest = request.xhr;
        
        // Catch 'abort' to avoid communicate a fake error in the promise; the
        // promise will just solve as success with empty array.
        request = request.catch(function(err) {
            if (err && err.statusText === 'abort')
                return [];
            else
                // Rethrow only if is not an 'abort'
                return err;
        });
        // Set again, removed by the catch returned promise
        request.xhr = publicSearchRequest;

        return request;
    };

    return api;
};

},{"../models/Customer":56,"../utils/ListRemoteModel":87}],119:[function(require,module,exports){
/** Freelancer Pricing
**/
'use strict';

var FreelancerPricing = require('../models/FreelancerPricing'),
    GroupListRemoteModel = require('../utils/GroupListRemoteModel');

exports.create = function create(appModel) {

    var api = new GroupListRemoteModel({
        // Conservative cache, just 1 minute
        listTtl: { minutes: 1 },
        groupIdField: 'jobTitleID',
        itemIdField: 'freelancerPricingID',
        Model: FreelancerPricing
    });

    api.addLocalforageSupport('freelancer-pricing/');
    api.addRestSupport(appModel.rest, 'freelancer-pricing/');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/FreelancerPricing":57,"../utils/GroupListRemoteModel":84}],120:[function(require,module,exports){
/** Home Address
**/
'use strict';

var Address = require('../models/Address');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new Address(),
        ttl: { minutes: 1 },
        localStorageName: 'homeAddress',
        fetch: function fetch() {
            return appModel.rest.get('addresses/home');
        },
        push: function push() {
            return appModel.rest.put('addresses/home', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/Address":49,"../utils/RemoteModel":89}],121:[function(require,module,exports){
/** Fetch Job Titles and Pricing Types information
**/
'use strict';

var localforage = require('localforage'),
    JobTitle = require('../models/JobTitle'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
            state:  {
                isLoading: ko.observable(false)
            }
        },
        cache = {
            jobTitles: {}
        };
    
    api.clearCache = function clearCache() {
        cache.jobTitles = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Public API
        Get a Job Title information by ID
    **/
    api.getJobTitle = function getJobTitle(id) {
        if (!id) return Promise.reject('Needs an ID to get a Job Title');

        // First, in-memory cache
        if (cache.jobTitles[id]) {
            return Promise.resolve(cache.jobTitles[id]);
        }
        else {
            api.state.isLoading(true);
            // Second, local storage
            return localforage.getItem('jobTitles/' + id)
            .then(function(jobTitle) {
                if (jobTitle) {
                    // cache in memory as Model instance
                    cache.jobTitles[id] = new JobTitle(jobTitle);
                    api.state.isLoading(false);
                    // return it
                    return cache.jobTitles[id];
                }
                else {
                    // Third and last, remote loading
                    return appModel.rest.get('job-titles/' + id)
                    .then(function (raw) {
                        // Cache in local storage
                        localforage.setItem('jobTitles/' + id, raw);
                        // cache in memory as Model instance
                        cache.jobTitles[id] = new JobTitle(raw);
                        api.state.isLoading(false);
                        // return it
                        return cache.jobTitles[id];
                    });
                }
            })
            .catch(function(err) {
                api.state.isLoading(false);
                // Rethrow error
                return err;
            });
        }
    };

    return api;
};

},{"../models/JobTitle":59,"knockout":false,"localforage":false}],122:[function(require,module,exports){
/** AppModel, centralizes all the data for the app,
    caching and sharing data across activities and performing
    requests
**/
var ko = require('knockout'),
    $ = require('jquery'),
    Rest = require('../utils/Rest'),
    localforage = require('localforage'),
    EventEmitter = require('events').EventEmitter;

function AppModel() {
    EventEmitter.call(this);
    this.setMaxListeners(30);
}

AppModel._inherits(EventEmitter);

module.exports = AppModel;

require('./AppModel-account').plugIn(AppModel);

/**
    Load credentials from the local storage, without error if there is nothing
    saved. If load profile data too, performing an tryLogin if no local data.
**/
AppModel.prototype.loadLocalCredentials = function loadLocalCredentials() {
    return new Promise(function(resolve) { // Never rejects: , reject) {

        // Callback to just resolve without error (passing in the error
        // to the 'resolve' will make the process to fail),
        // since we don't need to create an error for the
        // app init, if there is not enough saved information
        // the app has code to request a login.
        var resolveAnyway = function(doesnMatter){        
            console.warning('App Model Init err', doesnMatter);
            resolve();
        };
        
        // If there are credentials saved
        localforage.getItem('credentials').then(function(credentials) {

            if (credentials &&
                credentials.userID &&
                credentials.username &&
                credentials.authKey) {

                // use authorization key for each
                // new Rest request
                this.rest.extraHeaders = {
                    alu: credentials.userID,
                    alk: credentials.authKey
                };
                
                // It has credentials! Has basic profile data?
                // NOTE: the userProfile will load from local storage on this first
                // attempt, and lazily request updated data from remote so we need
                // to catch remote errors with events
                this.userProfile.once('error', function(err) {
                    this.emit('error', {
                        message: 'Impossible to load your data. Please check your Internet connection',
                        error: err
                    });
                }.bind(this));
                
                this.userProfile.load().then(function(profile) {
                    if (profile) {
                        // There is a profile cached
                        // End succesfully
                        resolve();
                    }
                    else {
                        // No profile, we need to request it to be able
                        // to work correctly, so we
                        // attempt a login (the tryLogin process performs
                        // a login with the saved credentials and fetch
                        // the profile to save it in the local copy)
                        this.tryLogin().then(resolve, resolveAnyway);
                    }
                }.bind(this), resolveAnyway)
                // The error event catch any error if happens, so avoid uncaught exceptions
                // in the console by catching the promise error
                .catch(function() { });
            }
            else {
                // End successfully. Not loggin is not an error,
                // is just the first app start-up
                resolve();
            }
        }.bind(this), resolveAnyway);
    }.bind(this));
};

/** Initialize and wait for anything up **/
AppModel.prototype.init = function init() {
    
    // Local data
    // TODO Investigate why automatic selection an IndexedDB are
    // failing and we need to use the worse-performance localstorage back-end
    localforage.config({
        name: 'LoconomicsApp',
        version: 0.1,
        size : 4980736, // Size of database, in bytes. WebSQL-only for now.
        storeName : 'keyvaluepairs',
        description : 'Loconomics App',
        driver: localforage.LOCALSTORAGE
    });
    
    // First, get any saved local config
    // NOTE: for now, this is optional, to get a saved siteUrl rather than the
    // default one, if any.
    return localforage.getItem('config')
    .then(function(config) {
        // Optional config
        config = config || {};
        
        if (config.siteUrl) {
            // Update the html URL
            $('html').attr('data-site-url', config.siteUrl);
        }
        else {
            config.siteUrl = $('html').attr('data-site-url');
        }
        
        this.rest = new Rest(config.siteUrl + '/api/v1/en-US/');
        
        // Setup Rest authentication
        this.rest.onAuthorizationRequired = function(retry) {

            this.tryLogin()
            .then(function() {
                // Logged! Just retry
                retry();
            });
        }.bind(this);
        
        // With config loaded and REST ready, load all modules
        this.loadModules();
        
        // Initialize: check the user has login data and needed
        // cached data, return its promise
        return this.loadLocalCredentials();
    }.bind(this));
};

AppModel.prototype.loadModules = function loadModules() {

    this.userProfile = require('./AppModel.userProfile').create(this);
    // NOTE: Alias for the user data
    // TODO:TOREVIEW if continue to makes sense to keep this 'user()' alias, document
    // where is used and why is preferred to the canonical way.
    this.user = ko.computed(function() {
        return this.userProfile.data;
    }, this);

    this.schedulingPreferences = require('./AppModel.schedulingPreferences').create(this);
    this.calendarSyncing = require('./AppModel.calendarSyncing').create(this);
    this.simplifiedWeeklySchedule = require('./AppModel.simplifiedWeeklySchedule').create(this);
    this.marketplaceProfile = require('./AppModel.marketplaceProfile').create(this);
    this.homeAddress = require('./AppModel.homeAddress').create(this);
    this.privacySettings = require('./AppModel.privacySettings').create(this);
    this.bookings = require('./AppModel.bookings').create(this);
    this.calendarEvents = require('./AppModel.calendarEvents').create(this);
    this.jobTitles = require('./AppModel.jobTitles').create(this);
    this.userJobProfile = require('./AppModel.userJobProfile').create(this);
    this.appointments = require('./AppModel.appointments').create(this);
    this.serviceAddresses = require('./AppModel.serviceAddresses').create(this);
    this.freelancerPricing = require('./AppModel.freelancerPricing').create(this);
    this.pricingTypes = require('./AppModel.pricingTypes').create(this);
    this.messaging = require('./AppModel.messaging').create(this);
    this.customers = require('./AppModel.customers').create(this);
    this.postalCodes = require('./AppModel.postalCodes').create(this);
};

/**
    Clear the local stored data, but with careful for the special
    config data that is kept.
**/
AppModel.prototype.clearLocalData = function clearLocalData() {
    // Get config
    return localforage.getItem('config')
    .then(function(config) {
        // Clear all
        localforage.clear();

        if (config) {
            // Set config again
            localforage.setItem('config', config);
        }
        
        // Trigger notification, so other components
        // can make further clean-up or try synchronizations,
        // for example to clean-up in-memory cache.
        this.emit('clearLocalData');
    }.bind(this));
};

// TODO Review removal, maybe too the utility internally used, since now there
// is an (incomplete still) AppModel.calendarEvents
// Class splited in different files to mitigate size and organization
// but keeping access to the common set of methods and objects easy with
// the same class.
// Loading extensions:
//require('./AppModel-events').plugIn(AppModel);


},{"../utils/Rest":90,"./AppModel-account":113,"./AppModel.appointments":114,"./AppModel.bookings":115,"./AppModel.calendarEvents":116,"./AppModel.calendarSyncing":117,"./AppModel.customers":118,"./AppModel.freelancerPricing":119,"./AppModel.homeAddress":120,"./AppModel.jobTitles":121,"./AppModel.marketplaceProfile":123,"./AppModel.messaging":124,"./AppModel.postalCodes":125,"./AppModel.pricingTypes":126,"./AppModel.privacySettings":127,"./AppModel.schedulingPreferences":128,"./AppModel.serviceAddresses":129,"./AppModel.simplifiedWeeklySchedule":130,"./AppModel.userJobProfile":131,"./AppModel.userProfile":132,"events":false,"knockout":false,"localforage":false}],123:[function(require,module,exports){
/** MarketplaceProfile
**/
'use strict';

var MarketplaceProfile = require('../models/MarketplaceProfile');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new MarketplaceProfile(),
        ttl: { minutes: 1 },
        localStorageName: 'marketplaceProfile',
        fetch: function fetch() {
            return appModel.rest.get('marketplace-profile');
        },
        push: function push() {
            return appModel.rest.put('marketplace-profile', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/MarketplaceProfile":63,"../utils/RemoteModel":89}],124:[function(require,module,exports){
/** AppModel for messaging: threads and messages

    NOTE: Initial basic implementation
    TODO: Require advanced implementation, loading a limited
        amount of records for threads and messages per thread
        using the cursor parameters of the REST API to manage
        paging load.
**/
'use strict';

var Thread = require('../models/Thread'),
    CacheControl = require('../utils/CacheControl'),
    ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        listTtl: { minutes: 1 },
        itemIdField: 'threadID',
        Model: Thread
    });

    api.addLocalforageSupport('messaging');
    api.addRestSupport(appModel.rest, 'messaging');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    // Basic support is fetching all threads with the latest message of each one.
    // Replace getItem built-in to do non locally saved, fetch for all messages in
    // a thread (the thread is the item)
    var fullThreadsCache = {/*
        threadID: { control: CacheControl, thread: Thread }
    */};
    var fetchThreadRemote = function(threadID) {
        return appModel.rest.get('messaging/' + threadID, {
            limit: 1000 /* max messages in the thread */
        })
        .then(function(thread) {
            if (thread) {
                thread = new Thread(thread);
                var cached = fullThreadsCache[threadID];
                if (cached) {
                    cached.control.latest = new Date();
                    cached.thread = thread;
                } else {
                    fullThreadsCache[threadID] = {
                        control: new CacheControl({ ttl: { minutes: 1 } }),
                        thread: thread
                    };
                    fullThreadsCache[threadID].control.latest = new Date();
                }
                return thread;
            }
            else {
                throw new Error('Not Found');
            }
        });
    };
    var markAsEndedAndFollowUp = function(any) {
        api.state.isSyncing(false);
        api.state.isLoading(false);
        return any;
    };
    api.getItem = function getItem(threadID) {
        var cached = fullThreadsCache[threadID];
        if (cached && cached.thread) {
            if (cached.control.mustRevalidate()) {
                api.state.isSyncing(true);
                return fetchThreadRemote(threadID)
                .then(markAsEndedAndFollowUp, markAsEndedAndFollowUp);
            }
            else
                return Promise.resolve(cached.thread);
        } else {
            api.state.isLoading(true);
            return fetchThreadRemote(threadID)
            .then(markAsEndedAndFollowUp, markAsEndedAndFollowUp);
        }
    };

    return api;
};

},{"../models/Thread":75,"../utils/CacheControl":80,"../utils/ListRemoteModel":87}],125:[function(require,module,exports){
/** Postal Code.

    Access the API to validate and retrieve information for a 
    given postal code.
    
    It just offers a 'get postal code info' method returning
    a plain object from the REST endpoint.
    
    Creates an in-memory cache for frequently used postal codes
**/
'use strict';

exports.create = function create(appModel) {

    var api = {},
        cache = {};
    
    api.getItem = function getItem(postalCode) {
        
        postalCode = postalCode || '';
        if (/^\s*$/.test(postalCode)) {
            return Promise.reject('Postal Code Not Valid');
        }
        
        // Check cache
        if (cache.hasOwnProperty(postalCode)) {
            return Promise.resolve(cache[postalCode]);
        }
        
        return appModel.rest.get('postal-codes/' + postalCode)
        .then(function(info) {
            // Save cache
            if (info) {
                cache[postalCode] = info;
            }
            // return
            return info;
        });
    };

    appModel.on('clearLocalData', function() {
        cache = {};
    });
    
    return api;
};

},{}],126:[function(require,module,exports){
/** Pricing Types
**/
'use strict';

var PricingType = require('../models/PricingType');

var ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        // Types does not changes usually, so big ttl
        listTtl: { days: 1 },
        itemIdField: 'pricingTypeID',
        Model: PricingType
    });

    api.addLocalforageSupport('pricing-types');
    api.addRestSupport(appModel.rest, 'pricing-types');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    return api;
};

},{"../models/PricingType":71,"../utils/ListRemoteModel":87}],127:[function(require,module,exports){
/** Privacy Settings
**/
'use strict';

var PrivacySettings = require('../models/PrivacySettings');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new PrivacySettings(),
        ttl: { minutes: 1 },
        localStorageName: 'privacySettings',
        fetch: function fetch() {
            return appModel.rest.get('privacy-settings');
        },
        push: function push() {
            return appModel.rest.put('privacy-settings', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/PrivacySettings":72,"../utils/RemoteModel":89}],128:[function(require,module,exports){
/**
**/
'use strict';

var SchedulingPreferences = require('../models/SchedulingPreferences');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new SchedulingPreferences(),
        ttl: { minutes: 1 },
        localStorageName: 'schedulingPreferences',
        fetch: function fetch() {
            return appModel.rest.get('scheduling-preferences');
        },
        push: function push() {
            return appModel.rest.put('scheduling-preferences', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/SchedulingPreferences":73,"../utils/RemoteModel":89}],129:[function(require,module,exports){
/** Service Addresses
**/
'use strict';

var Address = require('../models/Address'),
    GroupListRemoteModel = require('../utils/GroupListRemoteModel');

exports.create = function create(appModel) {

    var api = new GroupListRemoteModel({
        // Conservative cache, just 1 minute
        listTtl: { minutes: 1 },
        groupIdField: 'jobTitleID',
        itemIdField: 'addressID',
        Model: Address
    });
    
    api.addLocalforageSupport('addresses/service/');
    api.addRestSupport(appModel.rest, 'addresses/service/');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/Address":49,"../utils/GroupListRemoteModel":84}],130:[function(require,module,exports){
/**
**/
'use strict';

var SimplifiedWeeklySchedule = require('../models/SimplifiedWeeklySchedule'),
    RemoteModel = require('../utils/RemoteModel'),
    moment = require('moment');

// The slot size is fixed to 15 minutes by default.
// NOTE: currently, the API only allows 15 minutes slots,
// being that implicit, but part of the code is ready for explicit slotSize.
var defaultSlotSize = 15;
// A list of week day properties names allowed
// to be part of the objects describing weekly schedule
// (simplified or complete/slot based)
// Just lowecased english names
var weekDayProperties = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new SimplifiedWeeklySchedule(),
        ttl: { minutes: 1 },
        localStorageName: 'weeklySchedule',
        fetch: function fetch() {
            return appModel.rest.get('availability/weekly-schedule')
            .then(fromWeeklySchedule);
        },
        push: function push() {
            var plainData = {
                'all-time': false,
                'json-data': {}
            };
            if (this.data.isAllTime() === true) {
                plainData['all-time'] = true;
            }
            else {
                plainData['json-data'] = JSON.stringify(toWeeklySchedule(this.data.model.toPlainObject(true)));
            }

            return appModel.rest.put('availability/weekly-schedule', plainData)
            .then(fromWeeklySchedule);
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

function fromWeeklySchedule(weeklySchedule) {
    
    // New simplified object, as a plain object with
    // weekdays properties and from-to properties like:
    // { sunday: { from: 0, to: 60 } }
    // Since this is expected to be consumed by fetch-push
    // operations, and later by an 'model.updateWith' operation,
    // so plain is simple and better on performance; can be
    // converted easily to the SimplifiedWeeklySchedule object.
    var simpleWS = {};
    
    // Only supports 'available' status with default 'unavailable'
    if (weeklySchedule.defaultStatus !== 'unavailable' ||
        weeklySchedule.status !== 'available') {
        throw {
            name: 'input-format',
            message: 'Weekly schedule, given statuses not supported, status: ' +
            weeklySchedule.status + ', defaultStatus: ' + 
            weeklySchedule.defaultStatus
          };
    }
    
    // given slotSize or default
    var slotSize = (weeklySchedule.slotSize || defaultSlotSize) |0;

    // Read slots per week-day ({ slots: { "sunday": [] } })
    Object.keys(weeklySchedule.slots)
    .forEach(function(weekday) {
        
        // Verify is a weekday property, or exit early
        if (weekDayProperties.indexOf(weekday) === -1) {
            return;
        }
        
        var dayslots = weeklySchedule.slots[weekday];
        
        // We get the first available slot and the last consecutive
        // to make the range
        var from = null,
            to = null,
            previous = null;

        // times are ordered in ascending
        // and with format "00:00:00" that we convert to minutes
        // (enough precision for simplified weekly schedule)
        // using moment.duration
        // NOTE: using 'some' rather than 'forEach' to be able
        // to exit early from the iteration by returning 'true'
        // when the end is reached.
        dayslots.some(function(slot) {
            var minutes = moment.duration(slot).asMinutes() |0;
            // We have not still a 'from' time:
            if (from === null) {
                from = minutes;
                previous = minutes;
            }
            else {
                // We have a beggining, check if this is consecutive
                // to previous, by checking previous plus slotSize
                if (previous + slotSize === minutes) {
                    // New end
                    to = minutes;
                    // Next iteration
                    previous = minutes;
                }
                else {
                    // No consecutive, we already has a range, any
                    // additional slot is discarded, out of the
                    // precision of the simplified weekly schedule,
                    // so we can go out the iteration:
                    return true;
                    
                    // NOTE: If in a future a more complete schedule
                    // need to be wroten using multiple ranges rather
                    // individual slots, this is the place to continue
                    // coding, populating an array of [{from, to}] :-)
                }
            }
        });
        
        // Slots checked, check the result
        if (from !== null) {
            
            var simpleDay = {
                from: from,
                to: 0
            };
            simpleWS[weekday] = simpleDay;

            // We have a range!
            if (to !== null) {
                // and has an end!
                // add the slot size to the ending
                simpleDay.to = to + slotSize;
            }
            else {
                // smaller range, just one slot,
                // add the slot size to the begining
                simpleDay.to = from + slotSize;
            }
        }
    });

    // Done!
    return simpleWS;
}

/**
    Pass in a plain object, not a model,
    getting an object suitable for the API endpoint.
**/
function toWeeklySchedule(simplifiedWeeklySchedule) {

    var slotSize = defaultSlotSize;
    
    // It's build with 'available' as explicit status:
    var weeklySchedule = {
        status: 'available',
        defaultAvailability: 'unavailable',
        slots: {},
        slotSize: slotSize
    };

    // Per weekday
    Object.keys(simplifiedWeeklySchedule)
    .forEach(function(weekday) {

        // Verify is a weekday property, or exit early
        if (weekDayProperties.indexOf(weekday) === -1) {
            return;
        }

        var simpleDay = simplifiedWeeklySchedule[weekday];

        // We need to expand the simplified time ranges 
        // in slots of the slotSize
        // The end time will be excluded, since slots
        // define only the start, being implicit the slotSize.
        var from = simpleDay.from |0,
            to = simpleDay.to |0;

        // Create the slot array
        weeklySchedule.slots[weekday] = [];

        // Integrity verification
        if (to > from) {
            // Iterate by the slotSize until we reach
            // the end, not including the 'to' since
            // slots indicate only the start of the slot
            // that is assumed to fill a slotSize starting
            // on that slot-time
            var previous = from;
            while (previous < to) {
                weeklySchedule.slots[weekday].push(minutesToTimeString(previous));
                previous += slotSize;
            }
        }
    });

    // Done!
    return weeklySchedule;
}

/**
    internal utility function 'to string with two digits almost'
**/
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Convert a number of minutes
    in a string like: 00:00:00 (hours:minutes:seconds)
**/
function minutesToTimeString(minutes) {
    var d = moment.duration(minutes, 'minutes'),
        h = d.hours(),
        m = d.minutes(),
        s = d.seconds();
    
    return (
        twoDigits(h) + ':' +
        twoDigits(m) + ':' +
        twoDigits(s)
    );
}

},{"../models/SimplifiedWeeklySchedule":74,"../utils/RemoteModel":89,"moment":false}],131:[function(require,module,exports){
/**
    Model API to manage the collection of Job Titles assigned
    to the current user and its working data.
**/
'use strict';

var UserJobTitle = require('../models/UserJobTitle'),
    CacheControl = require('../utils/CacheControl'),
    localforage = require('localforage'),
    ko = require('knockout'),
    $ = require('jquery');

exports.create = function create(appModel) {

    var api = {},
        defaultTtl = { minutes: 1 },
        cache = {
            // Array of user job titles making
            // its profile
            userJobProfile: {
                cache: new CacheControl({ ttl: defaultTtl }),
                list: null
            },
            // Indexed list by jobTitleID to the user job titles models
            // in the list and cache information
            userJobTitles: {/*
                jobTitleID: { model: object, cache: CacheControl }
            */}
        };
    
    // Observable list
    api.list = ko.observableArray([]);
    // NOTE: Basic implementation, to enhance
    api.syncList = function syncList() {
        return api.getUserJobProfile().then(function(list) {
            api.list(list);
            return list;
        });
    };
    
    api.clearCache = function clearCache() {
        cache.userJobProfile.cache.latest = null;
        cache.userJobProfile.list = [];
        cache.userJobTitles = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Convert raw array of job titles records into
        an indexed array of models, actually an object
        with ID numbers as properties,
        and cache it in memory.
    **/
    function mapToUserJobProfile(rawItems) {
        cache.userJobProfile.list = [];
        cache.userJobTitles = {};

        if (rawItems) {
            rawItems.forEach(function(rawItem) {
                var m = new UserJobTitle(rawItem);
                cache.userJobProfile.list.push(m);
                // Saving and indexed copy and per item cache info
                setGetUserJobTitleToCache(rawItem);
            });
        }
        // Update observable
        api.list(cache.userJobProfile.list);

        // Update cache state
        cache.userJobProfile.cache.latest = new Date();
        
        return cache.userJobProfile.list;
    }
    
    /**
        Get the full jobProfile from local copy, throwing a Promise reject exception if nothing
    **/
    function getUserJobProfileFromLocal() {
        return localforage.getItem('userJobProfile')
        .then(function(userJobProfile) {
            if (userJobProfile) {
                return mapToUserJobProfile(userJobProfile);
            }
            // Return null since there is no data, the promise can catch
            // there is no data and attempt a remote
            return null;
        });
    }
    
    /**
        Set a raw userJobProfile record (from server) and set it in the
        cache, creating or updating the model (so all the time the same model instance
        is used) and cache control information.
        Returns the model instance.
    **/
    function setGetUserJobTitleToCache(rawItem) {
        var c = cache.userJobTitles[rawItem.jobTitleID] || {};
        // Update the model if exists, so get reflected to anyone consuming it
        if (c.model) {
            c.model.model.updateWith(rawItem);
        }
        else {
            // First time, create model
            c.model = new UserJobTitle(rawItem);
        }
        // Update cache control
        if (c.cache) {
            c.cache.latest = new Date();
        }
        else {
            c.cache = new CacheControl({ ttl: defaultTtl });
        }
        
        // If there is a profile list, add or update:
        var fullList =  cache.userJobProfile.list;
        if (fullList) {
            var found = null;
            fullList.some(function(it) {
                if (it.jobTitleID() === rawItem.jobTitleID) {
                    found = it;
                    return true;
                }
            });
            if (found) {
                found.model.updateWith(rawItem);
            }
            else {
                fullList.push(c.model);
            }
        }
        
        // Return the model, updated or just created
        return c.model;
    }
    
    /**
        Get the content from the cache, for full profile
        and save it in local storage
        NOTE It has no sense in current implementation (problem of fetch
        job title without a full job profile in cache/local)
    **/
    /*function saveCacheInLocal() {
        var plain = cache.userJobProfile.list.map(function(item) {
            // Each item is a model, get it in plain:
            return item.model.toPlainObject();
        });
        localforage.setItem('userJobProfile', plain);
    }*/
    
    // Private, fetch from remote
    var fetchUserJobProfile = function () {
        // Third and last, remote loading
        return appModel.rest.get('user-job-profile')
        .then(function (raw) {
            // Cache in local storage
            localforage.setItem('userJobProfile', raw);
            return mapToUserJobProfile(raw);
        });
    };
    
    /**
        Public API
        Get the complete list of UserJobTitle for
        all the JobTitles assigned to the current user
    **/
    api.getUserJobProfile = function () {
        // If no cache or must revalidate, go remote
        // (the first loading is ever 'must revalidate')
        if (cache.userJobProfile.cache.mustRevalidate()) {
            // If no cache, is first load, so try local
            if (!cache.userJobProfile.list) {
                // Local storage
                return getUserJobProfileFromLocal()
                .then(function(data) {
                    // launch remote for sync
                    var remotePromise = fetchUserJobProfile();
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                });
            }
            else {
                // No cache, no local, or obsolete, go remote:
                return fetchUserJobProfile();
            }
        }
        else {
            // There is cache and is still valid:
            return Promise.resolve(cache.userJobProfile.list);
        }
    };
    
    // Private, fetch from remote
    var fetchUserJobTitle = function(jobTitleID) {
        return appModel.rest.get('user-job-profile/' + jobTitleID)
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            
            // TODO implement cache saving for single job-titles, currently
            // it needs to save the profile cache, that may not exists if
            // the first request is for a single job title.
            // Next lines are to save full profile, not valid here.
            // Save in local
            //saveCacheInLocal();
            
            // Return model
            return m;
        });
    };
    
    var pushNewUserJobTitle = function(values) {
        // Create job title in remote
        return appModel.rest.post('user-job-profile', $.extend({
            jobTitleID: 0,
            jobTitleName: '',
            intro: '',
            cancellationPolicyID: null,
            instantBooking: false
        }, values))
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            
            // TODO implement cache saving for single job-titles, currently
            // it needs to save the profile cache, that may not exists if
            // the first request is for a single job title.
            // Next lines are to save full profile, not valid here.
            // Save in local
            //saveCacheInLocal();
            
            // Return model
            return m;
        });
    };
    
    /**
        Public API
        Get a UserJobTitle record for the given
        JobTitleID and the current user.
    **/
    api.getUserJobTitle = function (jobTitleID) {
        // Quick error
        if (!jobTitleID) return Promise.reject('Job Title ID required');
        
        // If no cache or must revalidate, go remote
        if (!cache.userJobTitles[jobTitleID] ||
            cache.userJobTitles[jobTitleID].cache.mustRevalidate()) {
            return fetchUserJobTitle(jobTitleID);
        }
        else {
            // First, try cache
            if (cache.userJobTitles[jobTitleID] &&
                cache.userJobTitles[jobTitleID].model) {
                return Promise.resolve(cache.userJobTitles[jobTitleID].model);
            }
            else {
                // Second, local storage, where we have the full job profile
                return getUserJobProfileFromLocal()
                .then(function(/*userJobProfile*/) {
                    // Not need for the parameter, the data is
                    // in memory and indexed, look for the job title
                    return cache.userJobTitles[jobTitleID].model;
                })
                // If no local copy (error on promise),
                // or that does not contains the job title (error on 'then'):
                // Third and last, remote loading
                .catch(fetchUserJobTitle.bind(null, jobTitleID));
            }
        }
    };
    
    api.createUserJobTitle = function (values) {
        return pushNewUserJobTitle(values);
    };
    
    /*************************/
    /** ADITIONAL UTILITIES **/
    api.getUserJobTitleAndJobTitle = function getUserJobTitleAndJobTitle(jobTitleID) {
        return api.getUserJobTitle(jobTitleID)
        .then(function(userJobTitle) {
            // Very unlikely error
            if (!userJobTitle) {
                throw {
                    name: 'Not Found',
                    message:
                        // LJDI:
                        'You have not this job title in your profile. ' + 
                        'Maybe was deleted from your profile recently.'
                };
            }

            // Get job title info too
            return Promise.all([
                userJobTitle,
                appModel.jobTitles.getJobTitle(jobTitleID)
            ]);
        })
        .then(function(all) {
            var jobTitle = all[1];
            // Very unlikely error
            if (!jobTitle) {
                throw {
                    name: 'Not Found',
                    // LJDI:
                    message: 'The job title does not exist.'
                };
            }
        
            return {
                jobTitleID: jobTitleID,
                userJobTitle: all[0],
                jobTitle: jobTitle
            };
        });
    };
    
    return api;
};

},{"../models/UserJobTitle":78,"../utils/CacheControl":80,"knockout":false,"localforage":false}],132:[function(require,module,exports){
/** UserProfile
**/
'use strict';

var User = require('../models/User');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: User.newAnonymous(),
        ttl: { minutes: 1 },
        // IMPORTANT: Keep the name in sync with set-up at AppModel-account
        localStorageName: 'profile',
        fetch: function fetch() {
            return appModel.rest.get('profile');
        },
        push: function push() {
            return appModel.rest.put('profile', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/User":77,"../utils/RemoteModel":89}],133:[function(require,module,exports){
/** AppointmentCard view model.
    It provides data and method to visualize and 
    edit and appointment card, with booking, event
    or placeholder information
**/

var ko = require('knockout'),
    moment = require('moment'),
    getObservable = require('../utils/getObservable'),
    AppointmentView = require('../viewmodels/AppointmentView'),
    ModelVersion = require('../utils/ModelVersion'),
    getDateWithoutTime = require('../utils/getDateWithoutTime'),
    PricingEstimateDetail = require('../models/PricingEstimateDetail');

function AppointmentCardViewModel(params) {
    /*jshint maxstatements: 30*/

    this.sourceItem = getObservable(params.sourceItem);
    var app = this.app = ko.unwrap(params.app);

    this.editMode = getObservable(params.editMode);
    this.editedVersion = ko.observable(null);
    
    this.isSaving = ko.observable(false);
    
    this.item = ko.observable(AppointmentView(this.sourceItem(), app));
    
    this.currentID = ko.pureComputed(function() {
        var it = this.item();
        return it && it.id() || 0;
    }, this);
    
    this.currentDate = ko.pureComputed(function() {
        return getDateWithoutTime(this.item() && this.item().startTime());
    }, this);
    
    this.isNew = ko.computed(function() {
        var id = this.currentID();
        return id === -3 || id === -4;
    }, this);
    
    this.isBooking = ko.computed(function() {
        return this.item() && this.item().sourceBooking();
    }, this);
    
    /* Return true if is an event object but not a booking */
    this.isEvent = ko.computed(function() {
        return this.item() && this.item().sourceEvent() && !this.item().sourceBooking();
    }, this);

    /**
        If the sourceItem changes, is set as the item value
        discarding any model version and reverting
        editMode to false
    **/
    this.sourceItem.subscribe(function(sourceItem) {
        this.item(AppointmentView(sourceItem, app));
        this.editedVersion(null);
        this.editMode(false);

        // If the new item is a new one, set edit mode
        if (this.isNew()) {
            this.editMode(true);
        }
    }, this);

    /**
        Enter and finish edit:
        Create version and save data
    **/
    this.editMode.subscribe(function(isEdit) {
        if (this.currentID() <= 0) {
            return;
        }

        var version;

        if (isEdit) {
            // Create and set a version to be edited
            version = new ModelVersion(this.sourceItem());
            version.version.sourceEvent(this.sourceItem().sourceEvent());
            version.version.sourceBooking(this.sourceItem().sourceBooking());
            this.editedVersion(version);
            this.item(AppointmentView(version.version, app));

            // Setup auto-saving
            version.on('push', function(success) {
                if (success) {
                    this.isSaving(true);
                    app.model.appointments.setAppointment(version.version)
                    .then(function(savedApt) {
                        //var wasNew = version.original.id() < 1;
                        // Update with remote data, the original appointment in the version,
                        // not the currentAppointment or in the index in the list to avoid
                        // race-conditions
                        version.original.model.updateWith(savedApt);

                        // TODO: wasNew:true: add to the list and sort it??
                        // There is a wizard for bookings, so may be different on that case
                    })
                    .catch(function(err) {
                        // Show error
                        app.modals.showError({
                            title: 'There was an error saving the data.',
                            error: err
                        });
                        // Don't replicate error, allow always
                    })
                    .then(function() {
                        // ALWAYS:
                        this.isSaving(false);
                    }.bind(this));
                }
            }.bind(this));
        }
        else {
            // There is a version? Push changes!
            version = this.editedVersion();

            if (version && version.areDifferent()) {
                // Push version to original, will launch a remote update 
                // if anithing changed
                // TODO: ask for confirmation if version isObsolete
                version.push({ evenIfObsolete: true });
            }
        }
    }, this);

    this.edit = function edit() {
        // A subscribed handler ensure to do the needed tasks
        this.editMode(true);
    }.bind(this);
    
    this.save = function save() {
        // A subscribed handler ensure to do the needed tasks
        this.editMode(false);
    }.bind(this);

    this.cancel = function cancel() {

        if (this.editedVersion()) {
            // Discard previous version
            this.editedVersion().pull({ evenIfNewer: true });
        }
        // Out of edit mode
        this.editMode(false);
    }.bind(this);

    /**
        External actions
    **/
    var editFieldOn = function editFieldOn(activity, data) {

        // Include appointment to recover state on return:
        data.appointment = this.item().model.toPlainObject(true);

        app.shell.go(activity, data);
    }.bind(this);

    this.pickDateTime = function pickDateTime() {

        editFieldOn('datetimePicker', {
            selectedDatetime: this.item().startTime(),
            headerText: 'Select the start time'
        });
    }.bind(this);

    this.pickClient = function pickClient() {

        editFieldOn('clients', {
            selectClient: true,
            selectedClientID: this.item().sourceBooking().bookingRequest().customerUserID()
        });
    }.bind(this);

    this.pickService = function pickService() {

        editFieldOn('freelancerPricing/' + this.item().jobTitleID(), {
            selectPricing: true,
            selectedPricing: this.item().pricing()
            .map(function(pricing) {
                return {
                    freelancerPricingID: ko.unwrap(pricing.freelancerPricingID),
                    totalPrice: ko.unwrap(pricing.totalPrice)
                };
            })
        });
    }.bind(this);

    this.changePrice = function changePrice() {
        // TODO
    }.bind(this);

    this.pickLocation = function pickLocation() {

        editFieldOn('serviceAddresses/' + this.item().jobTitleID(), {
            selectAddress: true,
            selectedAddressID: this.item().addressID()
        });
    }.bind(this);

    var textFieldsHeaders = {
        preNotesToClient: 'Notes to client',
        postNotesToClient: 'Notes to client (afterwards)',
        preNotesToSelf: 'Notes to self',
        postNotesToSelf: 'Booking summary',
        summary: 'What?'
    };

    this.editTextField = function editTextField(field) {

        editFieldOn('textEditor', {
            request: 'textEditor',
            field: field,
            title: this.isNew() ? 'New booking' : 'Booking',
            header: textFieldsHeaders[field],
            text: this.item()[field]()
        });
    }.bind(this);
    
    // pass this ready model view as an API to the outside
    if (typeof(params.api) === 'function') {
        params.api(this);
    }
}

/**
    It manages incoming data provided by external activities given
    the requestData received by the activity hosting this view instance.
    Used to manage the data returned by calls to edit data in
    external activities.
**/
AppointmentCardViewModel.prototype.passIn = function passIn(requestData) {
    /*jshint maxcomplexity:9 */
    
    // If the request includes an appointment plain object, that's an
    // in-editing appointment so put it in place (to restore a previous edition)
    if (requestData.appointment) {
        // Set the edit mode (it performs any required
        // set-up if we are not still in edit mode).
        this.editMode(true);
        // Sets the data
        this.item()
        .model.updateWith(requestData.appointment);
    }
    else {
        // On any other case, and to prevent a bad editMode state,
        // set off edit mode discarding unsaved data:
        this.cancel();
    }
    
    /// Manage specific single data from externally provided
    
    // It comes back from the textEditor.
    if (requestData.request === 'textEditor') {
        this.item()[requestData.field](requestData.text);
    }
    if (requestData.selectClient === true) {
        this.item().customerUserID(requestData.selectedClientID);
    }
    if (typeof(requestData.selectedDatetime) !== 'undefined') {
        this.item().startTime(requestData.selectedDatetime);
        // TODO Calculate the endTime given an appointment duration, retrieved
        // from the selected service
        var calculateEndTime = function calculateEndTime() {
            var duration = this.item().serviceDurationMinutes();
            this.item().endTime(
                moment(this.item().startTime())
                .add(duration, 'minutes').toDate()
            );
        }.bind(this);
        // Calculate now
        calculateEndTime();
        // And every time duration changes
        this.item().serviceDurationMinutes
        .subscribe(calculateEndTime);
    }
    if (requestData.selectAddress === true) {
        this.item().addressID(requestData.selectedAddressID);
    }
    if (requestData.selectedJobTitleID) {
        this.item().jobTitleID(requestData.selectedJobTitleID);
    }
    if (requestData.selectPricing === true) {
        this.item().pricing(
            requestData.selectedPricing.map(function(pricing) {
                return new PricingEstimateDetail(pricing);
            })
        );
    }
};

module.exports = AppointmentCardViewModel;

},{"../models/PricingEstimateDetail":70,"../utils/ModelVersion":88,"../utils/getDateWithoutTime":97,"../utils/getObservable":98,"../viewmodels/AppointmentView":134,"knockout":false,"moment":false}],134:[function(require,module,exports){
/**
    Appointment View model that wraps an Appointment
    model instance extended with extra methods connected
    to related data
**/
'use strict';

var ko = require('knockout');

module.exports = function AppointmentView(appointment, app) {
    if (appointment._isAppointmentView) return appointment;
    appointment._isAppointmentView = true;

    appointment.customer = ko.computed(function() {
        var b = this.sourceBooking();
        if (!b) return null;
        
        var cid = this.customerUserID();
        if (cid) {
            return app.model.customers.getObservableItem(cid, true)();
        }
        return null;
    }, appointment);
    
    appointment.address = ko.computed(function() {
        var b = this.sourceBooking();
        if (!b) return null;
        
        var aid = this.addressID(),
            jid = this.jobTitleID();
        if (aid && jid) {
            return app.model.serviceAddresses.getObservableItem(jid, aid, true)();
        }
        return null;
    }, appointment);

    appointment.addressSummary = ko.computed(function() {
        var add = this.address();
        return add && add.singleLine() || '';
    }, appointment);
    
    /* Property with the pricing array plus information about the
        freelancerPricing.
    */
    appointment.pricingWithInfo = ko.computed(function() {
        var b = this.sourceBooking();
        if (!b) return [];

        var jid = this.jobTitleID(),
            details = this.pricing();

        return details.map(function(det) {
            return PricingEstimateDetailView(det, jid, app);
        });
    }, appointment);

    appointment.servicesSummary = ko.computed(function() {
        return this.pricingWithInfo()
        .map(function(service) {
            return service.freelancerPricing().name();
        }).join(', ');
    }, appointment);
    
    // TODO Review for any change of compute the full service duration
    appointment.serviceDurationMinutes = ko.computed(function() {
        var pricing = this.pricingWithInfo();
        return pricing.reduce(function(prev, service) {
            return prev + service.freelancerPricing().serviceDurationMinutes();
        }, 0);
    }, appointment);
    
    // TODO Review if calculation of fees and that is needed
    appointment.pricing.subscribe(function(pricing) {
        this.price(pricing.reduce(function(prev, cur) {
            return prev + cur.totalPrice();
        }, 0));
    }.bind(appointment));

    return appointment;
};

function PricingEstimateDetailView(pricingEstimateDetail, jobTitleID, app) {

    pricingEstimateDetail.freelancerPricing = ko.computed(function() {
        var pid = this.freelancerPricingID();
        return app.model.freelancerPricing
            .getObservableItem(jobTitleID, pid, true)();
    }, pricingEstimateDetail);

    return pricingEstimateDetail;
}

},{"knockout":false}],135:[function(require,module,exports){
/**
    Simple View Model with main credentials for
    use in a form, with validation.
    Used by Login and Signup activities
**/
'use strict';

var ko = require('knockout');

function FormCredentials() {

    this.username = ko.observable('');
    this.password = ko.observable('');
    
    // validate username as an email
    var emailRegexp = /^[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+@[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+$/;
    this.username.error = ko.observable('');
    this.username.subscribe(function(v) {
        if (v) {
            if (emailRegexp.test(v)) {
                this.username.error('');
            }
            else {
                this.username.error('Is not a valid email');
            }
        }
        else {
            this.username.error('Required');
        }
    }.bind(this));
    
    // required password
    this.password.error = ko.observable('');
    this.password.subscribe(function(v) {
        var err = '';
        if (!v)
            err = 'Required';
        
        this.password.error(err);
    }.bind(this));
}

module.exports = FormCredentials;

},{"knockout":false}],136:[function(require,module,exports){
/** NavAction view model.
    It allows set-up per activity for the AppNav action button.
**/
var Model = require('../models/Model');

function NavAction(values) {
    
    Model(this);
    
    this.model.defProperties({
        link: '',
        icon: '',
        text: '',
        // 'Test' is the header title but placed in the button/action
        isTitle: false,
        // 'Link' is the element ID of a modal (starts with a #)
        isModal: false,
        // 'Link' is a Shell command, like 'goBack 2'
        isShell: false,
        // Set if the element is a menu button, in that case 'link'
        // will be the ID of the menu (contained in the page; without the hash), using
        // the text and icon but special meaning for the text value 'menu'
        // on icon property that will use the standard menu icon.
        isMenu: false
    }, values);
}

module.exports = NavAction;

// Set of view utilities to get the link for the expected html attributes

NavAction.prototype.getHref = function getHref() {
    return (
        (this.isMenu() || this.isModal() || this.isShell()) ?
        '#' :
        this.link()
    );
};

NavAction.prototype.getModalTarget = function getModalTarget() {
    return (
        (this.isMenu() || !this.isModal() || this.isShell()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getShellCommand = function getShellCommand() {
    return (
        (this.isMenu() || !this.isShell()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getMenuID = function getMenuID() {
    return (
        (!this.isMenu()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getMenuLink = function getMenuLink() {
    return (
        (!this.isMenu()) ?
        '' :
        '#' + this.link()
    );
};

/** Static, shared actions **/
NavAction.goHome = new NavAction({
    link: '/',
    icon: 'glyphicon glyphicon-home'
});

NavAction.goBack = new NavAction({
    link: 'goBack',
    icon: 'glyphicon glyphicon-arrow-left',
    isShell: true
});

// TODO TO REMOVE, Example of modal
NavAction.newItem = new NavAction({
    link: '#newItem',
    icon: 'glyphicon glyphicon-plus',
    isModal: true
});

NavAction.menuIn = new NavAction({
    link: 'menuIn',
    icon: 'menu',
    isMenu: true
});

NavAction.menuOut = new NavAction({
    link: 'menuOut',
    icon: 'menu',
    isMenu: true
});

NavAction.menuNewItem = new NavAction({
    link: 'menuNewItem',
    icon: 'glyphicon glyphicon-plus',
    isMenu: true
});

NavAction.goHelpIndex = new NavAction({
    link: '#helpIndex',
    text: 'help',
    isModal: true
});

NavAction.goLogin = new NavAction({
    link: '/login',
    text: 'log-in'
});

NavAction.goLogout = new NavAction({
    link: '/logout',
    text: 'log-out'
});

NavAction.goSignup = new NavAction({
    link: '/signup',
    text: 'sign-up'
});

},{"../models/Model":66}],137:[function(require,module,exports){
/** NavBar view model.
    It allows customize the NavBar per activity.
**/
var Model = require('../models/Model');
    //NavAction = require('./NavAction');

function NavBar(values) {
    
    Model(this);
    
    this.model.defProperties({
        // Title showed in the center
        // When the title is 'null', the app logo is showed in place,
        // on empty text, the empty text is showed and no logo.
        title: '',
        // NavAction instance:
        leftAction: null,
        // NavAction instance:
        rightAction: null
    }, values);
}

module.exports = NavBar;

},{"../models/Model":66}],138:[function(require,module,exports){
/**
    TimeSlot view model (aka: CalendarSlot) for use
    as part of the template/component time-slot-tile or activities
    providing data for the template.
**/
'use strict';

var getObservable = require('../utils/getObservable');

function TimeSlotViewModel(params) {
    /*jshint maxcomplexity:9*/

    this.startTime = getObservable(params.startTime || null);
    this.endTime = getObservable(params.endTime || null);
    this.subject = getObservable(params.subject || null);
    this.description = getObservable(params.description || null);
    this.link = getObservable(params.link || null);
    this.actionIcon = getObservable(params.actionIcon || null);
    this.actionText = getObservable(params.actionText || null);
    this.classNames = getObservable(params.classNames || null);
}

module.exports = TimeSlotViewModel;

var numeral = require('numeral');

/**
    Static constructor to convert an Appointment model into 
    a TimeSlot instance following UI criteria for preset values/setup.
**/
TimeSlotViewModel.fromAppointment = function fromAppointment(apt) {
    /*jshint maxcomplexity:8 */
    return new TimeSlotViewModel({
        startTime: apt.startTime,
        endTime: apt.endTime,
        subject: apt.summary,
        description: apt.description,
        link: '#!appointment/' + apt.startTime().toISOString() + '/' + apt.id(),
        actionIcon: (apt.sourceBooking() ? null : apt.sourceEvent() ? 'glyphicon glyphicon-chevron-right' : !apt.id() ? 'glyphicon glyphicon-plus' : null),
        actionText: (
            apt.sourceBooking() && 
            apt.sourceBooking().bookingRequest() && 
            apt.sourceBooking().bookingRequest().pricingEstimate() ? 
            numeral(apt.sourceBooking().bookingRequest().pricingEstimate().totalPrice() || 0).format('$0.00') :
            null
        ),
        classNames: (apt.id() ? null : 'ListView-item--tag-success')
    });
};

},{"../utils/getObservable":98,"numeral":false}],139:[function(require,module,exports){
/**
    UserJobProfileViewModel: loads data and keep state
    to display the listing of job titles from the 
    user job profile.
**/
'use strict';

var ko = require('knockout');

function UserJobProfileViewModel(app) {
    
    // Load and save job title info
    var jobTitlesIndex = {};
    function syncJobTitle(jobTitleID) {
        return app.model.jobTitles.getJobTitle(jobTitleID)
        .then(function(jobTitle) {
            jobTitlesIndex[jobTitleID] = jobTitle;

            // TODO: errors? not-found job title?
        });
    }
    // Creates a 'jobTitle' observable on the userJobTitle
    // model to have access to a cached jobTitle model.
    function attachJobTitle(userJobTitle) {
        userJobTitle.jobTitle = ko.computed(function(){
            return jobTitlesIndex[this.jobTitleID()];
        }, userJobTitle);
    }
    
    this.userJobProfile = ko.observableArray([]);
    // Updated using the live list, for background updates
    app.model.userJobProfile.list.subscribe(function(list) {
        // We need the job titles info before end
        Promise.all(list.map(function(userJobTitle) {
            return syncJobTitle(userJobTitle.jobTitleID());
        }))
        .then(function() {
            // Create jobTitle property before update
            // observable with the profile
            list.forEach(attachJobTitle);

            this.userJobProfile(list);

            this.isLoading(false);
            this.isSyncing(false);
            this.thereIsError(false);
        }.bind(this))
        .catch(showLoadingError);
    }, this);

    this.isFirstTime = ko.observable(true);
    this.isLoading = ko.observable(false);
    this.isSyncing = ko.observable(false);
    this.thereIsError = ko.observable(false);
    this.baseUrl = ko.observable('/jobtitles');
    
    this.selectJobTitle = function() {
        // Hook to allow for custom handler rather than follow
        // the URL. On that cases, remember to return false
        return true;
    };
    
    var showLoadingError = function showLoadingError(err) {
        app.modals.showError({
            title: 'An error happening when loading your job profile.',
            error: err && err.error || err
        });
        
        this.isLoading(false);
        this.isSyncing(false);
        this.thereIsError(true);
    }.bind(this);

    // Loading and sync of data
    this.sync = function sync() {
        var firstTime = this.isFirstTime();
        this.isFirstTime(false);

        if (firstTime) {
            this.isLoading(true);
        }
        else {
            this.isSyncing(true);
        }

        // Keep data updated:
        app.model.userJobProfile.syncList()
        .catch(showLoadingError);

    }.bind(this);
}

module.exports = UserJobProfileViewModel;

},{"knockout":false}]},{},[42])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYWNjb3VudC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYWRkSm9iVGl0bGVzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9hZGRyZXNzRWRpdG9yLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9hcHBvaW50bWVudC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYm9va01lQnV0dG9uLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9ib29raW5nQ29uZmlybWF0aW9uLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jYWxlbmRhci5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvY2FsZW5kYXJTeW5jaW5nLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jbGllbnRFZGl0b3IuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2NsaWVudHMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2Ntcy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvY29udGFjdEZvcm0uanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2NvbnRhY3RJbmZvLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jb252ZXJzYXRpb24uanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2RhdGV0aW1lUGlja2VyLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9mYXFzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9mZWVkYmFjay5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvZmVlZGJhY2tGb3JtLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9mcmVlbGFuY2VyUHJpY2luZy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvZnJlZWxhbmNlclByaWNpbmdFZGl0b3IuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2hvbWUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2luYm94LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9pbmRleC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvam9idGl0bGVzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9sZWFybk1vcmUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2xvZ2luLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9sb2dvdXQuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL29uYm9hcmRpbmdDb21wbGV0ZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvb25ib2FyZGluZ0hvbWUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL29uYm9hcmRpbmdQb3NpdGlvbnMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL293bmVySW5mby5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvcHJpdmFjeVNldHRpbmdzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zY2hlZHVsaW5nLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zY2hlZHVsaW5nUHJlZmVyZW5jZXMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3NlcnZpY2VBZGRyZXNzZXMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3NpZ251cC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvdGV4dEVkaXRvci5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvd2Vla2x5U2NoZWR1bGUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHAtY29tcG9uZW50cy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcC1uYXZiYXIuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHAuYWN0aXZpdGllcy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcC5tb2RhbHMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHAuc2hlbGwuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9jb21wb25lbnRzL0FjdGl2aXR5LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvY29tcG9uZW50cy9EYXRlUGlja2VyLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvY29tcG9uZW50cy9TbWFydE5hdkJhci5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2xvY2FsZXMvZW4tVVMtTEMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvQWRkcmVzcy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9BcHBvaW50bWVudC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Cb29raW5nLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0Jvb2tpbmdSZXF1ZXN0LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0Jvb2tpbmdTdW1tYXJ5LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0NhbGVuZGFyRXZlbnQuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvQ2FsZW5kYXJTeW5jaW5nLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0N1c3RvbWVyLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0ZyZWVsYW5jZXJQcmljaW5nLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0dldE1vcmUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvSm9iVGl0bGUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvSm9iVGl0bGVQcmljaW5nVHlwZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9MaXN0Vmlld0l0ZW0uanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTWFpbEZvbGRlci5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9NYXJrZXRwbGFjZVByb2ZpbGUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTWVzc2FnZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9NZXNzYWdlVmlldy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Nb2RlbC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9QZXJmb3JtYW5jZVN1bW1hcnkuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvUG9zaXRpb24uanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvUHJpY2luZ0VzdGltYXRlLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1ByaWNpbmdFc3RpbWF0ZURldGFpbC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9QcmljaW5nVHlwZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Qcml2YWN5U2V0dGluZ3MuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvU2NoZWR1bGluZ1ByZWZlcmVuY2VzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1NpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9UaHJlYWQuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVXBjb21pbmdCb29raW5nc1N1bW1hcnkuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVXNlci5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Vc2VySm9iVGl0bGUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy90ZXN0ZGF0YS90aW1lU2xvdHMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9DYWNoZUNvbnRyb2wuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUuX2RlbGF5ZWQuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUuX2luaGVyaXRzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUtcG9seWZpbGwuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9Hcm91cExpc3RSZW1vdGVNb2RlbC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL0luZGV4ZWRHcm91cExpc3RDYWNoZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL0luZGV4ZWRMaXN0Q2FjaGUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9MaXN0UmVtb3RlTW9kZWwuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9Nb2RlbFZlcnNpb24uanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9SZW1vdGVNb2RlbC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL1Jlc3QuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9UaW1lLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvYWNjZXNzQ29udHJvbC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2Jvb3Rrbm9ja0JpbmRpbmdIZWxwZXJzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvYm9vdHN0cmFwU3dpdGNoQmluZGluZy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2VzY2FwZVJlZ0V4cC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2VzY2FwZVNlbGVjdG9yLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvZ2V0RGF0ZVdpdGhvdXRUaW1lLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvZ2V0T2JzZXJ2YWJsZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2dldFVybFF1ZXJ5LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvanF1ZXJ5Lm11bHRpbGluZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2pzUHJvcGVydGllc1Rvb2xzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvcmVtb3ZlQWNjZW50LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvRG9tSXRlbXNNYW5hZ2VyLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvU2hlbGwuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9zaGVsbC9hYnNvbHV0aXplVXJsLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvZGVwZW5kZW5jaWVzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvaGFzaGJhbmdIaXN0b3J5LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvaW5kZXguanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9zaGVsbC9sb2FkZXIuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9zaGVsbC9wYXJzZVVybC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3NoZWxsL3Nhbml0aXplVXJsLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvdGV4dFNlYXJjaC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwtYWNjb3VudC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwuYXBwb2ludG1lbnRzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9BcHBNb2RlbC5ib29raW5ncy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0FwcE1vZGVsLmNhbGVuZGFyU3luY2luZy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwuY3VzdG9tZXJzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9BcHBNb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwuaG9tZUFkZHJlc3MuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0FwcE1vZGVsLmpvYlRpdGxlcy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0FwcE1vZGVsLm1hcmtldHBsYWNlUHJvZmlsZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwubWVzc2FnaW5nLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9BcHBNb2RlbC5wb3N0YWxDb2Rlcy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwucHJpY2luZ1R5cGVzLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9BcHBNb2RlbC5wcml2YWN5U2V0dGluZ3MuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0FwcE1vZGVsLnNjaGVkdWxpbmdQcmVmZXJlbmNlcy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwuc2VydmljZUFkZHJlc3Nlcy5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9BcHBNb2RlbC51c2VySm9iUHJvZmlsZS5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwTW9kZWwudXNlclByb2ZpbGUuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0FwcG9pbnRtZW50Q2FyZC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwb2ludG1lbnRWaWV3LmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9Gb3JtQ3JlZGVudGlhbHMuanMiLCJDOi9Vc2Vycy9JYWdvL1Byb3hlY3Rvcy9Mb2Nvbm9taWNzLmNvbS9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL05hdkFjdGlvbi5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvTmF2QmFyLmpzIiwiQzovVXNlcnMvSWFnby9Qcm94ZWN0b3MvTG9jb25vbWljcy5jb20vc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9UaW1lU2xvdC5qcyIsIkM6L1VzZXJzL0lhZ28vUHJveGVjdG9zL0xvY29ub21pY3MuY29tL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvVXNlckpvYlByb2ZpbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzliQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgIEFjY291bnQgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBY2NvdW50QWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xuICAgIFxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignQWNjb3VudCcpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcbiIsIi8qKlxyXG4gICAgQWRkSm9iVGl0bGVzIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbnJlcXVpcmUoJ2pxdWVyeS11aScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEFkZEpvYlRpdGxlc0FjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5GcmVlbGFuY2VyO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycpO1xyXG4gICAgXHJcbiAgICAvLyBTZXR1cCBhdXRvY29tcGxldGVcclxuICAgIHZhciBhYyA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNhZGRKb2JUaXRsZXMtc2VhcmNoJyk7XHJcbiAgICB2YXIgdncgPSB0aGlzLnZpZXdNb2RlbDtcclxuICAgIC8vIEF1dG9jb21wbGV0ZSBwb3NpdGlvbnMgYW5kIGFkZCB0byB0aGUgbGlzdFxyXG4gICAgYWMuYXV0b2NvbXBsZXRlKHtcclxuICAgICAgICBzb3VyY2U6IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZ3LnNlYXJjaEJ5KHJlcXVlc3QudGVybSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UocmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXV0b0ZvY3VzOiBmYWxzZSxcclxuICAgICAgICBtaW5MZW5ndGg6IDAsXHJcbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHZhbHVlLCBubyBhY3Rpb24gOihcclxuICAgICAgICAgICAgaWYgKCF1aSB8fCAhdWkuaXRlbSB8fCAhdWkuaXRlbS52YWx1ZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdncuYWRkSXRlbSh1aS5pdGVtKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvY3VzOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XHJcbiAgICAgICAgICAgIGlmICghdWkgfHwgIXVpLml0ZW0gfHwgIXVpLml0ZW0ucG9zaXRpb25TaW5ndWxhcik7XHJcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIGxhYmVsIGluIHRleHRib3gsIG5vdCB0aGUgdmFsdWVcclxuICAgICAgICAgICAgJCh0aGlzKS52YWwodWkuaXRlbS5wb3NpdGlvblNpbmd1bGFyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcclxuXHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgXHJcbiAgICAvLyBSZXNldFxyXG4gICAgdGhpcy52aWV3TW9kZWwuc2VhcmNoVGV4dCgnJyk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZXMucmVtb3ZlQWxsKCk7XHJcbn07XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcbiAgICBcclxuICAgIHRoaXMuaXNTZWFyY2hpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuaXNMb2NrZWQgPSB0aGlzLmlzU2F2aW5nO1xyXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICB0aGlzLmpvYlRpdGxlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5vYnNlcnZhYmxlKCdTYXZlJyk7XHJcbiAgICBcclxuICAgIHRoaXMudW5zYXZlZENoYW5nZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5qb2JUaXRsZXMoKS5sZW5ndGg7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNlYXJjaEJ5ID0gZnVuY3Rpb24gc2VhcmNoQnkodGV4dCkge1xyXG4gICAgICAgIHJldHVybiBhcHAubW9kZWwucmVzdC5nZXQoJ2pvYi10aXRsZXMvYXV0b2NvbXBsZXRlJywgeyBzZWFyY2g6IHRleHQgfSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7IGVycm9yOiBlcnIgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKCkge1xyXG4gICAgICAgIHRoaXMuc2VhcmNoQnkodGhpcy5zZWFyY2hUZXh0KCkpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmFkZEl0ZW0gPSBmdW5jdGlvbiBhZGRJdGVtKGl0ZW0pIHtcclxuICAgICAgICAvLyBBZGQgdG8gdGhlIGxpc3QsIGlmIGlzIG5vdCBhbHJlYWR5IGluIGl0XHJcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSB0aGlzLmZpbmRJdGVtKGl0ZW0pO1xyXG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmpvYlRpdGxlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXJjaFRleHQoKTtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEl0ZW0oe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hUZXh0KCcnKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIExvb2sgZm9yIGFuIGl0ZW0gaW4gdGhlIGN1cnJlbnQgbGlzdCwgcmV0dXJuaW5nXHJcbiAgICAgICAgaXRzIGluZGV4IGluIHRoZSBsaXN0IG9yIC0xIGlmIG5vdGhpbmcuXHJcbiAgICAqKi9cclxuICAgIHRoaXMuZmluZEl0ZW0gPSBmdW5jdGlvbiBmaW5kSXRlbShqb2JUaXRsZSkge1xyXG4gICAgICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5qb2JUaXRsZXMoKS5zb21lKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChqb2JUaXRsZS52YWx1ZSAhPT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgaXRlbS52YWx1ZSA9PT0gam9iVGl0bGUudmFsdWUgfHxcclxuICAgICAgICAgICAgICAgIGl0ZW0ubGFiZWwgPT09IGpvYlRpdGxlLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmb3VuZEluZGV4O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoam9iVGl0bGUpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlSW5kZXggPSB0aGlzLmZpbmRJdGVtKGpvYlRpdGxlKTtcclxuICAgICAgICBpZiAocmVtb3ZlSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmpvYlRpdGxlcy5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLmlzU2F2aW5nKHRydWUpO1xyXG4gICAgICAgIHRoaXMuc3VibWl0VGV4dCgnU2F2aW5nJyk7XHJcblxyXG4gICAgICAgIFByb21pc2UuYWxsKHRoaXMuam9iVGl0bGVzKCkubWFwKGZ1bmN0aW9uKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwudXNlckpvYlByb2ZpbGUuY3JlYXRlVXNlckpvYlRpdGxlKHtcclxuICAgICAgICAgICAgICAgIGpvYlRpdGxlSUQ6IGpvYlRpdGxlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgam9iVGl0bGVOYW1lOiBqb2JUaXRsZS5sYWJlbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigvKnJlc3VsdHMqLykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Ym1pdFRleHQoJ0RvbmUnKTtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hUZXh0KCcnKTtcclxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGxpc3RcclxuICAgICAgICAgICAgdGhpcy5qb2JUaXRsZXMucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnN1Ym1pdFRleHQoJ1NhdmUnKTtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hUZXh0KCcnKTtcclxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnSW1wb3NzaWJsZSB0byBhZGQgb25lIG9yIG1vcmUgam9iIHRpdGxlcycsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufVxyXG4iLCIvKipcbiAgICBBZGRyZXNzRWRpdG9yIGFjdGl2aXR5XG4gICAgXG4gICAgVE9ETzogTW9kZWxWZXJzaW9uIGlzIE5PVCBiZWluZyB1c2VkLCBzbyBubyBnZXR0aW5nIHVwZGF0ZXMgaWYgc2VydmVyIHVwZGF0ZXNcbiAgICB0aGUgZGF0YSBhZnRlciBsb2FkIChkYXRhIGxvYWQgaXMgcmVxdWVzdGVkIGJ1dCBnZXQgZmlyc3QgZnJvbSBjYWNoZSkuIFVzZVxuICAgIHZlcnNpb24gYW5kIGdldCBzeW5jJ2VkIGRhdGEgd2hlbiByZWFkeSwgYW5kIGFkZGl0aW9uYWxseSBub3RpZmljYXRpb24gdG9cbiAgICBvdmVycmlkZSBjaGFuZ2VzIGlmIHNlcnZlciBkYXRhIGlzIGRpZmZlcmVudCB0aGF0IGFueSBsb2NhbCBjaGFuZ2UuXG5cbiAgICBUT0RPOiBUaGUgVVJMIHN0cnVjdHVyZSBhbmQgaG93IHBhcmFtcyBhcmUgcmVhZCBpcyByZWFkeSB0byBhbGxvd1xuICAgIGVkaXRpb24gb2YgZGlmZmVyZW50IGtpbmQgb2YgYWRkcmVzc2VzLCBidXQgYWN0dWFsbHkgb25seSBzZXJ2aWNlIGFkZHJlc3Nlc1xuICAgIGFyZSBmdWxseSBzdXBwb3J0ZWQsIHNpbmNlICdob21lIGFkZHJlc3MnIGlzIGVkaXRlZCBpbiBjb250YWN0SW5mbyBhbmRcbiAgICAnYmlsbGluZyBhZGRyZXNzZXMnIGFyZSBub3QgdXNlZCBjdXJyZW50bHksIGJ1dCB3aGVuIG5lZWRlZCwgdGhlIHN1cHBvcnQgZm9yIHRoaXNcbiAgICBsYXN0IHdpbGwgbmVlZCB0byBiZSBjb21wbGV0ZWQuIEFsbCB0aGUgQVBJIGNhbGxzIHJpZ2h0IG5vdyBhcmVcbiAgICBmb3IgbW9kZWwuc2VydmljZUFkZGRyZXNzZXMgZm9yIGV4YW1wbGUuXG4qKi9cbid1c2Ugc3RyaWN0JztcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgQWRkcmVzcyA9IHJlcXVpcmUoJy4uL21vZGVscy9BZGRyZXNzJyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBZGRyZXNzRWRpdG9yQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0xvY2F0aW9ucycpO1xuICAgIFxuICAgIC8vIFJlbW90ZSBwb3N0YWwgY29kZSBsb29rLXVwXG4gICAgLy8gTk9URTogY29waWVkIHRoZSBjb2RlIGluc2lkZSB0aGUgcG9zdGFsQ29kZSBjb21wdXRlZCBoYW5kbGVyIGluIGNvbnRhY3RJbmZvLmpzIHdpdGggc2xpZ2h0IGNoYW5nZXNcbiAgICB2YXIgYXBwID0gdGhpcy5hcHAsXG4gICAgICAgIHZpZXdNb2RlbCA9IHRoaXMudmlld01vZGVsO1xuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihhZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyAmJlxuICAgICAgICAgICAgICAgIWFkZHJlc3MucG9zdGFsQ29kZS5faGFzTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5wb3N0YWxDb2RlLl9oYXNMb29rdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE9uIGNoYW5nZSB0byBhIHZhbGlkIGNvZGUsIGRvIHJlbW90ZSBsb29rLXVwXG4gICAgICAgICAgICAgICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0YWxDb2RlID0gdGhpcy5wb3N0YWxDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdGFsQ29kZSAmJiAhL15cXHMqJC8udGVzdChwb3N0YWxDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLm1vZGVsLnBvc3RhbENvZGVzLmdldEl0ZW0ocG9zdGFsQ29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmNpdHkoaW5mby5jaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5zdGF0ZVByb3ZpbmNlQ29kZShpbmZvLnN0YXRlUHJvdmluY2VDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5zdGF0ZVByb3ZpbmNlTmFtZShpbmZvLnN0YXRlUHJvdmluY2VOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmVycm9yTWVzc2FnZXMucG9zdGFsQ29kZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmNpdHkoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZUNvZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGVjdGVkIGVycm9ycywgYSBzaW5nbGUgbWVzc2FnZSwgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gdHlwZW9mKGVycikgPT09ICdzdHJpbmcnID8gZXJyIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnIHx8IGVyciAmJiBlcnIucmVzcG9uc2VKU09OICYmIGVyci5yZXNwb25zZUpTT04uZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5lcnJvck1lc3NhZ2VzLnBvc3RhbENvZGUobXNnIHx8IGVyci5yZXNwb25zZUpTT04uZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvZyB0byBjb25zb2xlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIG9uIHJlZ3VsYXIgdXNlIGFuIGVycm9yIG9uIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3N0YWwgY29kZSBpcyBub3QgY3JpdGljYWwgYW5kIGNhbiBiZSB0cmFuc3BhcmVudDsgaWYgdGhlcmUgYXJlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0aXZpdHkgb3IgYXV0aGVudGlmaWNhdGlvbiBlcnJvcnMgd2lsbCB0aHJvdyBvbiBzYXZpbmcgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignU2VydmVyIGVycm9yIHZhbGlkYXRpbmcgWmlwIENvZGUnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgYWRkcmVzcylcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBleGNlc3NpdmUgcmVxdWVzdHMgYnkgc2V0dGluZyBhIHRpbWVvdXQgc2luY2UgdGhlIGxhdGVzdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IHRpbWVvdXQ6IDIwMCwgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJyB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eToxMCAgICBcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIFJlc2V0XG4gICAgdGhpcy52aWV3TW9kZWwud2FzUmVtb3ZlZChmYWxzZSk7XG4gICAgXG4gICAgLy8gUGFyYW1zICAgIFxuICAgIHZhciBwYXJhbXMgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cyB8fCBbXTtcblxuICAgIHZhciBraW5kID0gcGFyYW1zWzBdIHx8ICcnLFxuICAgICAgICBpc1NlcnZpY2UgPSBraW5kID09PSBBZGRyZXNzLmtpbmQuc2VydmljZSxcbiAgICAgICAgam9iVGl0bGVJRCA9IGlzU2VydmljZSA/IHBhcmFtc1sxXSB8MCA6IDAsXG4gICAgICAgIGFkZHJlc3NJRCA9IGlzU2VydmljZSA/IHBhcmFtc1syXSB8MCA6IHBhcmFtc1sxXSB8MCxcbiAgICAgICAgLy8gT25seSB1c2VkIG9uIHNlcnZpY2UgYWRkcmVzcyBjcmVhdGlvbiwgaW5zdGVhZCBhbiBJRCB3ZSBnZXRcbiAgICAgICAgLy8gYSBzdHJpbmcgZm9yICdzZXJ2aWNlQXJlYScgb3IgJ3NlcnZpY2VMb2NhdGlvbicpXG4gICAgICAgIHNlcnZpY2VUeXBlID0gcGFyYW1zWzJdIHx8ICcnO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoam9iVGl0bGVJRCk7XG4gICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc0lEKGFkZHJlc3NJRCk7XG5cbiAgICBpZiAoYWRkcmVzc0lEKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYWRkcmVzc1xuICAgICAgICB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldEl0ZW1WZXJzaW9uKGpvYlRpdGxlSUQsIGFkZHJlc3NJRClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3NWZXJzaW9uKSB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzVmVyc2lvbihhZGRyZXNzVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdFZGl0IExvY2F0aW9uJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NWZXJzaW9uKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlcignVW5rbm93IGxvY2F0aW9uIG9yIHdhcyBkZWxldGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5ldyBhZGRyZXNzXG4gICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NWZXJzaW9uKHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMubmV3SXRlbVZlcnNpb24oe1xuICAgICAgICAgICAgam9iVGl0bGVJRDogam9iVGl0bGVJRFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgc3dpdGNoIChzZXJ2aWNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2VydmljZUFyZWEnOlxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3MoKS5pc1NlcnZpY2VBcmVhKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3MoKS5pc1NlcnZpY2VMb2NhdGlvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdBZGQgYSBzZXJ2aWNlIGFyZWEnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlcnZpY2VMb2NhdGlvbic6XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUFyZWEoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3MoKS5pc1NlcnZpY2VMb2NhdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXIoJ0FkZCBhIHNlcnZpY2UgbG9jYXRpb24nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUFyZWEodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUxvY2F0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlcignQWRkIGEgbG9jYXRpb24nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcblxuICAgIHRoaXMuaGVhZGVyID0ga28ub2JzZXJ2YWJsZSgnRWRpdCBMb2NhdGlvbicpO1xuICAgIFxuICAgIC8vIExpc3Qgb2YgcG9zc2libGUgZXJyb3IgbWVzc2FnZXMgcmVnaXN0ZXJlZFxuICAgIC8vIGJ5IG5hbWVcbiAgICB0aGlzLmVycm9yTWVzc2FnZXMgPSB7XG4gICAgICAgIHBvc3RhbENvZGU6IGtvLm9ic2VydmFibGUoJycpXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMuYWRkcmVzc0lEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICBcbiAgICB0aGlzLmFkZHJlc3NWZXJzaW9uID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5hZGRyZXNzVmVyc2lvbigpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnN0YXRlLmlzTG9hZGluZztcbiAgICB0aGlzLmlzU2F2aW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNTYXZpbmc7XG4gICAgdGhpcy5pc0RlbGV0aW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNEZWxldGluZztcblxuICAgIHRoaXMud2FzUmVtb3ZlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIFxuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEZWxldGluZygpIHx8IGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnN0YXRlLmlzTG9ja2VkKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5pc05ldyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmFkZHJlc3MoKS51cGRhdGVkRGF0ZSgpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuYWRkcmVzc1ZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnTG9hZGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmluZyBjaGFuZ2VzJyA6IFxuICAgICAgICAgICAgICAgICAgICB2ICYmIHYuYXJlRGlmZmVyZW50KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmUgY2hhbmdlcycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmVkJ1xuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy51bnNhdmVkQ2hhbmdlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmFkZHJlc3NWZXJzaW9uKCk7XG4gICAgICAgIHJldHVybiB2ICYmIHYuYXJlRGlmZmVyZW50KCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5kZWxldGVUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0RlbGV0aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnRGVsZXRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgJ0RlbGV0ZSdcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnNldEl0ZW0odGhpcy5hZGRyZXNzKCkubW9kZWwudG9QbGFpbk9iamVjdCgpKVxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdmVyc2lvbiB3aXRoIHNlcnZlciBkYXRhLlxuICAgICAgICAgICAgdGhpcy5hZGRyZXNzKCkubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhKTtcbiAgICAgICAgICAgIC8vIFB1c2ggdmVyc2lvbiBzbyBpdCBhcHBlYXJzIGFzIHNhdmVkXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3NWZXJzaW9uKCkucHVzaCh7IGV2ZW5JZk9ic29sZXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBPbiBzYXZlLCBhdXRvIGdvIGJhY2tcbiAgICAgICAgICAgIC8vIE5PVEU6IGlmIGF1dG8gZ28gYmFjayBpcyBkaXNhYmxlZCwgdGhlIFVSTCBtdXN0IHVwZGF0ZSB0byBtYXRjaCB0aGUgbmV3IElEXG4gICAgICAgICAgICBhcHAuc3VjY2Vzc1NhdmUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgc2F2aW5nLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuY29uZmlybVJlbW92YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBwLm1vZGFscy5jb25maXJtKHtcbiAgICAgICAgICAgIHRpdGxlOiAnRGVsZXRlIGxvY2F0aW9uJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdBcmUgeW91IHN1cmU/IFRoZSBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nLFxuICAgICAgICAgICAgeWVzOiAnRGVsZXRlJyxcbiAgICAgICAgICAgIG5vOiAnS2VlcCdcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuZGVsSXRlbSh0aGlzLmpvYlRpdGxlSUQoKSwgdGhpcy5hZGRyZXNzSUQoKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLndhc1JlbW92ZWQodHJ1ZSk7XG4gICAgICAgICAgICAvLyBHbyBvdXQgdGhlIGRlbGV0ZWQgbG9jYXRpb25cbiAgICAgICAgICAgIGFwcC5zaGVsbC5nb0JhY2soKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZGVsZXRpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIC8qKlxuICAgICAgICBUeXBlZCB2YWx1ZSBiaW5kaW5nIHJhdGhlciB0aGFuIGh0bWwgYmluZGluZyBhbGxvdyB0byBhdm9pZFxuICAgICAgICBwcm9ibGVtcyBiZWNhdXNlIHRoZSBkYXRhIGluIGh0bWwgYXJlIHN0cmluZyB2YWx1ZXMgd2hpbGVcbiAgICAgICAgdGhlIGFjdHVhbCBkYXRhIGZyb20gdGhlIG1vZGVsIGlzIGEgbnVtYmVyLlxuICAgICAgICBDYXVzZSBwcm9ibGVtcyBvbiBzb21lIGVkZ2UgY2FzZXMgbWF0Y2hpbmcgdmFsdWVzIGFuZCB3aXRoXG4gICAgICAgIGRldGVjdGlvbiBvZiBjaGFuZ2VzIGluIHRoZSBkYXRhIChiZWNhdXNlIHRoZSBiaW5kaW5nIGNvbWluZyBmcm9tIHRoZVxuICAgICAgICBjb250cm9sIGFzc2lnbmluZyBhIHN0cmluZyB0byB0aGUgdmFsdWUpLlxuICAgICoqL1xuICAgIHRoaXMuc2VydmljZVJhZGl1c09wdGlvbnMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW1xuICAgICAgICB7IHZhbHVlOiAwLjUsIGxhYmVsOiAnMC41IG1pbGVzJyB9LFxuICAgICAgICB7IHZhbHVlOiAxLjAsIGxhYmVsOiAnMSBtaWxlJyB9LFxuICAgICAgICB7IHZhbHVlOiAyLjAsIGxhYmVsOiAnMiBtaWxlcycgfSxcbiAgICAgICAgeyB2YWx1ZTogMy4wLCBsYWJlbDogJzMgbWlsZXMnIH0sXG4gICAgICAgIHsgdmFsdWU6IDQuMCwgbGFiZWw6ICc0IG1pbGVzJyB9LFxuICAgICAgICB7IHZhbHVlOiA1LjAsIGxhYmVsOiAnNSBtaWxlcycgfSxcbiAgICAgICAgeyB2YWx1ZTogMTAsIGxhYmVsOiAnMTAgbWlsZXMnIH0sXG4gICAgICAgIHsgdmFsdWU6IDI1LCBsYWJlbDogJzI1IG1pbGVzJyB9LFxuICAgICAgICB7IHZhbHVlOiA1MCwgbGFiZWw6ICc1MCBtaWxlcycgfSxcbiAgICBdKTtcbn1cbiIsIi8qKiBDYWxlbmRhciBhY3Rpdml0eSAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL0RhdGVQaWNrZXInKTtcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBcHBvaW50bWVudEFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5GcmVlbGFuY2VyOyAgICBcclxuICAgIHRoaXMubWVudUl0ZW0gPSAnY2FsZW5kYXInO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgYSBzcGVjaWZpYyBiYWNrQWN0aW9uIHRoYXQgc2hvd3MgY3VycmVudCBkYXRlXHJcbiAgICAvLyBhbmQgcmV0dXJuIHRvIGNhbGVuZGFyIGluIGN1cnJlbnQgZGF0ZS5cclxuICAgIC8vIExhdGVyIHNvbWUgbW9yZSBjaGFuZ2VzIGFyZSBhcHBsaWVkLCB3aXRoIHZpZXdtb2RlbCByZWFkeVxyXG4gICAgdmFyIGJhY2tBY3Rpb24gPSBuZXcgQWN0aXZpdHkuTmF2QWN0aW9uKHtcclxuICAgICAgICBsaW5rOiAnY2FsZW5kYXIvJywgLy8gUHJlc2VydmUgbGFzdCBzbGFzaCwgZm9yIGxhdGVyIHVzZVxyXG4gICAgICAgIGljb246IEFjdGl2aXR5Lk5hdkFjdGlvbi5nb0JhY2suaWNvbigpLFxyXG4gICAgICAgIGlzVGl0bGU6IHRydWUsXHJcbiAgICAgICAgdGV4dDogJ0NhbGVuZGFyJ1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLm5hdkJhciA9IG5ldyBBY3Rpdml0eS5OYXZCYXIoe1xyXG4gICAgICAgIHRpdGxlOiAnJyxcclxuICAgICAgICBsZWZ0QWN0aW9uOiBiYWNrQWN0aW9uLFxyXG4gICAgICAgIHJpZ2h0QWN0aW9uOiBBY3Rpdml0eS5OYXZBY3Rpb24uZ29IZWxwSW5kZXhcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLiRhcHBvaW50bWVudFZpZXcgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2FsZW5kYXJBcHBvaW50bWVudFZpZXcnKTtcclxuICAgIHRoaXMuJGNob29zZU5ldyA9ICQoJyNjYWxlbmRhckNob29zZU5ldycpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIHRpdGxlIHRleHQgaXMgZHluYW1pYywgd2UgbmVlZCB0byByZXBsYWNlIGl0IGJ5IGEgY29tcHV0ZWQgb2JzZXJ2YWJsZVxyXG4gICAgLy8gc2hvd2luZyB0aGUgY3VycmVudCBkYXRlXHJcbiAgICB2YXIgZGVmQmFja1RleHQgPSBiYWNrQWN0aW9uLnRleHQuX2luaXRpYWxWYWx1ZTtcclxuICAgIGJhY2tBY3Rpb24udGV4dCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZCA9IHRoaXMudmlld01vZGVsLmN1cnJlbnREYXRlKCk7XHJcbiAgICAgICAgaWYgKCFkKVxyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byB0aGUgZGVmYXVsdCB0aXRsZVxyXG4gICAgICAgICAgICByZXR1cm4gZGVmQmFja1RleHQ7XHJcblxyXG4gICAgICAgIHZhciBtID0gbW9tZW50KGQpO1xyXG4gICAgICAgIHZhciB0ID0gbS5mb3JtYXQoJ2RkZGQgWyhdTS9EWyldJyk7XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIC8vIEFuZCB0aGUgbGluayBpcyBkeW5hbWljIHRvbywgdG8gYWxsb3cgcmV0dXJuIHRvIHRoZSBkYXRlXHJcbiAgICAvLyB0aGF0IG1hdGNoZXMgY3VycmVudCBhcHBvaW50bWVudFxyXG4gICAgdmFyIGRlZkxpbmsgPSBiYWNrQWN0aW9uLmxpbmsuX2luaXRpYWxWYWx1ZTtcclxuICAgIGJhY2tBY3Rpb24ubGluayA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZCA9IHRoaXMudmlld01vZGVsLmN1cnJlbnREYXRlKCk7XHJcbiAgICAgICAgaWYgKCFkKVxyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byB0aGUgZGVmYXVsdCBsaW5rXHJcbiAgICAgICAgICAgIHJldHVybiBkZWZMaW5rO1xyXG5cclxuICAgICAgICByZXR1cm4gZGVmTGluayArIGQudG9JU09TdHJpbmcoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBKdXN0IHVwZGF0ZSBVUkwgdG8gbWF0Y2ggdGhlIGFwcG9pbnRtZW50IGN1cnJlbnRseSBzaG93ZWRcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmN1cnJlbnRBcHBvaW50bWVudCxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoYXB0KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIWFwdClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBVUkwgdG8gbWF0Y2ggdGhlIGFwcG9pbnRtZW50IElEIGFuZFxyXG4gICAgICAgICAgICAvLyB0cmFjayBpdCBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBHZXQgSUQgZnJvbSBVUkwsIHRvIGF2b2lkIGRvIGFueXRoaW5nIGlmIHRoZSBzYW1lLlxyXG4gICAgICAgICAgICB2YXIgYXB0SWQgPSBhcHQuaWQoKSxcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gL2FwcG9pbnRtZW50XFwvKFteXFwvXSspXFwvKFxcLT9cXGQrKS9pLmV4ZWMod2luZG93LmxvY2F0aW9uKSxcclxuICAgICAgICAgICAgICAgIHVybElkID0gZm91bmQgJiYgZm91bmRbMl0gfDAsXHJcbiAgICAgICAgICAgICAgICB1cmxEYXRlID0gZm91bmQgJiYgZm91bmRbMV0sXHJcbiAgICAgICAgICAgICAgICBjdXJEYXRlU3RyID0gZ2V0RGF0ZVdpdGhvdXRUaW1lKHRoaXMudmlld01vZGVsLmN1cnJlbnREYXRlKCkpLnRvSVNPU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kIHx8XHJcbiAgICAgICAgICAgICAgICB1cmxJZCAhPT0gYXB0SWQudG9TdHJpbmcoKSB8fFxyXG4gICAgICAgICAgICAgICAgdXJsRGF0ZSAhPT0gY3VyRGF0ZVN0cikge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3YXMgYW4gaW5jb21wbGV0ZSBVUkwsIGp1c3QgcmVwbGFjZSBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAodXJsSWQgPT09ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsICdhcHBvaW50bWVudC8nICsgY3VyRGF0ZVN0ciArICcvJyArIGFwdElkKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCAnYXBwb2ludG1lbnQvJyArIGN1ckRhdGVTdHIgKyAnLycgKyBhcHRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykuX2RlbGF5ZWQoMTApXHJcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBkZWxheWVkIFJFUVVJUkVEIHRvIGF2b2lkIHRyaXBsZSBsb2FkaW5nIChhY3Rpdml0eS5zaG93KSBvbiBmaXJzdCBsb2FkIHRyaWdnZXJlZCBieSBhIGNsaWNrL3RhcCBldmVudC5cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmVkaXRNb2RlLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGlzRWRpdCkge1xyXG4gICAgICAgICAgICB0aGlzLiRhY3Rpdml0eS50b2dnbGVDbGFzcygnaW4tZWRpdCcsIGlzRWRpdCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eToxMCAqL1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgdmFyIHMxID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHNbMF0sXHJcbiAgICAgICAgczIgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50c1sxXSxcclxuICAgICAgICBkYXRlLFxyXG4gICAgICAgIGlkO1xyXG5cclxuICAgIGlmICgvXlxcLT9cXGQrJC8udGVzdChzMSkpIHtcclxuICAgICAgICAvLyBmaXJzdCBwYXJhbWV0ZXIgaXMgYW4gSURcclxuICAgICAgICBpZCA9IHMxIHwwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGF0ZSA9IGdldERhdGVXaXRob3V0VGltZShzMSk7XHJcbiAgICAgICAgaWQgPSBzMiB8MDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5zZXRDdXJyZW50KGRhdGUsIGlkKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gVGhlIGNhcmQgY29tcG9uZW50IG5lZWRzIHRvIGJlIHVwZGF0ZWQgb24gbG9hZFxyXG4gICAgICAgIC8vIHdpdGggYW55IG9wdGlvbiBwYXNzZWQgdG8gdGhlIGFjdGl2aXR5IHNpbmNlIHRoZSBjb21wb25lbnRcclxuICAgICAgICAvLyBpcyBhYmxlIHRvIHRvIGludGVyYWN0IHdpdGggb3RoZXIgYWN0aXZpdGllcyBpdCBoYXMgcmVxdWVzdGVkXHJcbiAgICAgICAgLy8gKHRvIHJlcXVlc3QgaW5mb3JtYXRpb24gZWRpdGlvbilcclxuICAgICAgICB2YXIgY2FyZEFwaSA9IHRoaXMudmlld01vZGVsLmFwcG9pbnRtZW50Q2FyZFZpZXcoKTtcclxuICAgICAgICBpZiAoY2FyZEFwaSkge1xyXG4gICAgICAgICAgICBjYXJkQXBpLnBhc3NJbih0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxudmFyIEFwcG9pbnRtZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FwcG9pbnRtZW50Jyk7XHJcblxyXG52YXIgZ2V0RGF0ZVdpdGhvdXRUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0RGF0ZVdpdGhvdXRUaW1lJyk7XHJcblxyXG5mdW5jdGlvbiBmaW5kQXBwb2ludG1lbnRJbkxpc3QobGlzdCwgaWQpIHtcclxuICAgIHZhciBmb3VuZCA9IG51bGwsXHJcbiAgICAgICAgaW5kZXggPSAtMTtcclxuICAgIGxpc3Quc29tZShmdW5jdGlvbihhcHQsIGkpIHtcclxuICAgICAgICBpZiAoYXB0LmlkKCkgPT09IGlkKSB7XHJcbiAgICAgICAgICAgIGZvdW5kID0gYXB0O1xyXG4gICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpdGVtOiBmb3VuZCxcclxuICAgICAgICBpbmRleDogaW5kZXhcclxuICAgIH07XHJcbn1cclxuXHJcbnZhciBDYWxlbmRhckV2ZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NhbGVuZGFyRXZlbnQnKSxcclxuICAgIEJvb2tpbmcgPSByZXF1aXJlKCcuLi9tb2RlbHMvQm9va2luZycpO1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG4gICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICB0aGlzLmFwcG9pbnRtZW50cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICB0aGlzLmN1cnJlbnREYXRlID0ga28ub2JzZXJ2YWJsZShuZXcgRGF0ZSgpKTtcclxuICAgIHRoaXMuY3VycmVudElEID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIHRoaXMuY3VycmVudEluZGV4ID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIHRoaXMuZWRpdE1vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICB0aGlzLmlzU2F2aW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICBcclxuICAgIC8vIFRvIGFjY2VzcyB0aGUgY29tcG9uZW50IEFQSSB3ZSB1c2UgbmV4dCBvYnNlcnZhYmxlLFxyXG4gICAgLy8gdXBkYXRlZCBieSB0aGUgY29tcG9uZW50IHdpdGggaXRzIHZpZXdcclxuICAgIHRoaXMuYXBwb2ludG1lbnRDYXJkVmlldyA9IGtvLm9ic2VydmFibGUobnVsbCk7XHJcblxyXG4gICAgdmFyIGxvYWRpbmdBcHBvaW50bWVudCA9IG5ldyBBcHBvaW50bWVudCh7XHJcbiAgICAgICAgaWQ6IDAsXHJcbiAgICAgICAgc3VtbWFyeTogJ0xvYWRpbmcuLi4nXHJcbiAgICB9KTtcclxuICAgIHZhciBuZXdFbXB0eURhdGVBcHBvaW50bWVudCA9IGZ1bmN0aW9uIG5ld0VtcHR5RGF0ZUFwcG9pbnRtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgICAgICBpZDogLTEsXHJcbiAgICAgICAgICAgIHN1bW1hcnk6ICdUaGVyZSBhcmUgbm8gYXBwb2ludG1lbnRzIG9uIHRoaXMgZGF0ZScsXHJcbiAgICAgICAgICAgIHN0YXJ0VGltZTogdGhpcy5jdXJyZW50RGF0ZSgpLFxyXG4gICAgICAgICAgICBlbmRUaW1lOiBtb21lbnQodGhpcy5jdXJyZW50RGF0ZSgpKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgdmFyIG5ld0ZyZWVBcHBvaW50bWVudCA9IGZ1bmN0aW9uIG5ld0ZyZWVBcHBvaW50bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFwcG9pbnRtZW50KHtcclxuICAgICAgICAgICAgaWQ6IC0yLFxyXG4gICAgICAgICAgICBzdW1tYXJ5OiAnRnJlZScsXHJcbiAgICAgICAgICAgIHN0YXJ0VGltZTogdGhpcy5jdXJyZW50RGF0ZSgpLFxyXG4gICAgICAgICAgICBlbmRUaW1lOiBtb21lbnQodGhpcy5jdXJyZW50RGF0ZSgpKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgdmFyIG5ld0V2ZW50QXBwb2ludG1lbnQgPSBmdW5jdGlvbiBuZXdFdmVudEFwcG9pbnRtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgICAgICBpZDogLTMsXHJcbiAgICAgICAgICAgIHN1bW1hcnk6ICdOZXcgZXZlbnQuLi4nLFxyXG4gICAgICAgICAgICBzb3VyY2VFdmVudDogbmV3IENhbGVuZGFyRXZlbnQoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBuZXdCb29raW5nQXBwb2ludG1lbnQgPSBmdW5jdGlvbiBuZXdCb29raW5nQXBwb2ludG1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBcHBvaW50bWVudCh7XHJcbiAgICAgICAgICAgIGlkOiAtNCxcclxuICAgICAgICAgICAgc3VtbWFyeTogJ05ldyBib29raW5nLi4uJyxcclxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IG5ldyBDYWxlbmRhckV2ZW50KCksXHJcbiAgICAgICAgICAgIHNvdXJjZUJvb2tpbmc6IG5ldyBCb29raW5nKClcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY3VycmVudEFwcG9pbnRtZW50ID0ga28ub2JzZXJ2YWJsZShsb2FkaW5nQXBwb2ludG1lbnQpO1xyXG5cclxuICAgIHRoaXMuZ29QcmV2aW91cyA9IGZ1bmN0aW9uIGdvUHJldmlvdXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmN1cnJlbnRJbmRleCgpIC0gMTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAvLyBHbyBwcmV2aW91cyBkYXRlXHJcbiAgICAgICAgICAgIHZhciBtID0gbW9tZW50KHRoaXMuY3VycmVudERhdGUoKSk7XHJcbiAgICAgICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIG0gPSBtb21lbnQobmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByZXZEYXRlID0gbS5zdWJ0cmFjdCgxLCAnZGF5cycpLnRvRGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnQocHJldkRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gR28gcHJldmlvdXMgaXRlbSBpbiB0aGUgbGlzdCwgYnkgY2hhbmdpbmcgY3VycmVudElEXHJcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggJSB0aGlzLmFwcG9pbnRtZW50cygpLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGFwdCA9IHRoaXMuYXBwb2ludG1lbnRzKClbaW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudElEKGFwdC5pZCgpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QXBwb2ludG1lbnQoYXB0KTtcclxuICAgICAgICAgICAgLy8gQ29tcGxldGUgbG9hZC1kb3VibGUgY2hlY2s6IHRoaXMuc2V0Q3VycmVudChhcHQuc3RhcnRUaW1lKCksIGFwdC5pZCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ29OZXh0ID0gZnVuY3Rpb24gZ29OZXh0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlKCkpIHJldHVybjtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmN1cnJlbnRJbmRleCgpICsgMTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuYXBwb2ludG1lbnRzKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIEdvIG5leHQgZGF0ZVxyXG4gICAgICAgICAgICB2YXIgbSA9IG1vbWVudCh0aGlzLmN1cnJlbnREYXRlKCkpO1xyXG4gICAgICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBtID0gbW9tZW50KG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXh0RGF0ZSA9IG0uYWRkKDEsICdkYXlzJykudG9EYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudChuZXh0RGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBHbyBuZXh0IGl0ZW0gaW4gdGhlIGxpc3QsIGJ5IGNoYW5naW5nIGN1cnJlbnRJRFxyXG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICUgdGhpcy5hcHBvaW50bWVudHMoKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBhcHQgPSB0aGlzLmFwcG9pbnRtZW50cygpW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJRChhcHQuaWQoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFwcG9pbnRtZW50KGFwdCk7XHJcbiAgICAgICAgICAgIC8vIENvbXBsZXRlIGxvYWQtZG91YmxlIGNoZWNrOiB0aGlzLnNldEN1cnJlbnQoYXB0LnN0YXJ0VGltZSgpLCBhcHQuaWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBDaGFuZ2luZyB0aGUgY3VycmVudCB2aWV3ZWQgZGF0YSBieSBkYXRlIGFuZCBpZFxyXG4gICAgKiovXHJcblxyXG4gICAgdGhpcy5zZXRMaXN0ID0gZnVuY3Rpb24gKGxpc3QpIHtcclxuICAgICAgICBsaXN0ID0gbGlzdCB8fCBbXTtcclxuICAgICAgICB0aGlzLmFwcG9pbnRtZW50cyhsaXN0KTtcclxuICAgIH07XHJcbiAgICB0aGlzLmdldFNwZWNpYWxJdGVtID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgc3dpdGNoIChpZCkge1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvL2Nhc2UgLTE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RW1wdHlEYXRlQXBwb2ludG1lbnQoKTtcclxuICAgICAgICAgICAgY2FzZSAtMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGcmVlQXBwb2ludG1lbnQoKTtcclxuICAgICAgICAgICAgY2FzZSAtMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwcG9pbnRtZW50KCk7XHJcbiAgICAgICAgICAgIGNhc2UgLTQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Qm9va2luZ0FwcG9pbnRtZW50KCk7XHJcbiAgICAgICAgICAgIGNhc2UgLTU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGluZ0FwcG9pbnRtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLnNldEl0ZW1Gcm9tQ3VycmVudExpc3QgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAvKmpzaGludCBtYXhkZXB0aDo2Ki9cclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuYXBwb2ludG1lbnRzKCksXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICBpdGVtO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCwgcmVzcGVjdCBzcGVjaWFsIElEcywgZXhjZXB0IHRoZSAnbm8gYXBwdHMnOlxyXG4gICAgICAgIGlmIChpZCA8IC0xKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldFNwZWNpYWxJdGVtKGlkKTtcclxuICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gTm8gaXRlbSBJRCwgZW1wdHkgbGlzdDpcclxuICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgaXRlbSA9IG5ld0VtcHR5RGF0ZUFwcG9pbnRtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTdGFydCBnZXR0aW5nIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0WzBdO1xyXG4gICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBXaXRoIGFueSBJRCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgSURcclxuICAgICAgICAgICAgICAgIGlmIChpZCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggaXRlbSBpbiBjYWNoZWQgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZpbmRBcHBvaW50bWVudEluTGlzdChsaXN0LCBpZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZC5pdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBmb3VuZC5pdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGZvdW5kLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB0aGUgZmlyc3QgaXRlbSB3aWxsIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldFNwZWNpYWxJdGVtKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRJRChpdGVtLmlkKCkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4KGluZGV4KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBcHBvaW50bWVudChpdGVtKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBfc2V0Q3VycmVudCA9IGZ1bmN0aW9uIHNldEN1cnJlbnQoZGF0ZSwgaWQpIHsgICAgXHJcbiAgICAgICAgLy8gSU1QT1JUQU5UOiB0aGUgZGF0ZSB0byB1c2UgbXVzdCBiZSBldmVyXHJcbiAgICAgICAgLy8gYSBuZXcgb2JqZWN0IHJhdGhlciB0aGFuIHRoZSByZWZlcmVuY2VkIG9uZSB0b1xyXG4gICAgICAgIC8vIGF2b2lkIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgc2FtZSBvYmplY3QgaXMgbXV0YXRlZFxyXG4gICAgICAgIC8vIGFuZCBjb21wYXJpc2lvbnMgY2FuIGZhaWwuIFxyXG4gICAgICAgIC8vIGdldERhdGVXaXRob3V0VGltZSBlbnN1cmUgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGV2ZXIuXHJcbiAgICAgICAgZGF0ZSA9IGRhdGUgJiYgZ2V0RGF0ZVdpdGhvdXRUaW1lKGRhdGUpIHx8IG51bGw7XHJcbiAgICAgICAgaWYgKGRhdGUpXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUoZGF0ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFkYXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChpZCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW90ZSBzZWFyY2ggZm9yIGlkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm90Rm91bmQgPSBmdW5jdGlvbiBub3RGb3VuZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZXRDdXJyZW50KG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwuYXBwb2ludG1lbnRzLmdldEFwcG9pbnRtZW50KGlkKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBhIGxvYWQgZm9yIHRoZSBpdGVtIGRhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdERhdGUgPSBnZXREYXRlV2l0aG91dFRpbWUoaXRlbS5zdGFydFRpbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZXRDdXJyZW50KGl0RGF0ZSwgaXRlbS5pZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3RGb3VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChub3RGb3VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaWQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIElEc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXRDdXJyZW50KG5ldyBEYXRlKCksIGlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGRhdGUsIG5vIElELCBsb2FkIHRvZGF5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NldEN1cnJlbnQobmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwLm1vZGVsLmFwcG9pbnRtZW50cy5nZXRBcHBvaW50bWVudHNCeURhdGUoZGF0ZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGlzdChsaXN0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SXRlbUZyb21DdXJyZW50TGlzdChpZCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0Vycm9yIGxvYWRpbmcgY2FsZW5kYXIgZXZlbnRzLic7XHJcbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci5lcnJvciB8fCBlcnJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdmFyIHByb21pc2VTZXRDdXJyZW50ID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB0aGlzLnNldEN1cnJlbnQgPSBmdW5jdGlvbiBzZXRDdXJyZW50KGRhdGUsIGlkKSB7XHJcbiAgICAgICAgLy8gTk9URTogRG8gbm90aGluZyBpZiBpcyBhbHJlYWR5IGluIGxvYWRpbmcgcHJvY2Vzc1xyXG4gICAgICAgIC8vIFRPRE86IHJldmlldyBpZiBpcyBiZXR0ZXIgdG8gY2FuY2VsIGN1cnJlbnQgYW5kIGNvbnRpbnVlIG9yXHJcbiAgICAgICAgLy8ganVzdCB0aGUgY3VycmVudCBxdWV1ZSBmb3Igd2hlbiBpdCdzIGZpbmlzaC5cclxuICAgICAgICAvLyBJZiBzZXQgYXMgJ2FsbG93IGNvbmN1cnJlbnQnXHJcbiAgICAgICAgLy8gdGhlIGlzTG9hZGluZyBtYXkgYmUgbm90IGVub3VnaCB0byBjb250cm9sIHRoZSBzZXZlcmFsIGxvYWRpbmdzXHJcbiAgICAgICAgcHJvbWlzZVNldEN1cnJlbnQgPSBwcm9taXNlU2V0Q3VycmVudC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3NldEN1cnJlbnQoZGF0ZSwgaWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlU2V0Q3VycmVudDtcclxuICAgIH07XHJcbn1cclxuIiwiLyoqXHJcbiAgICBCb29rTWVCdXR0b24gYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBCb29rTWVCdXR0b25BY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIFxyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5GcmVlbGFuY2VyO1xyXG5cclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycpO1xyXG4gICAgXHJcbiAgICAvLyBBdXRvIHNlbGVjdCB0ZXh0IG9uIHRleHRhcmVhLCBmb3IgYmV0dGVyICdjb3B5J1xyXG4gICAgLy8gTk9URTogdGhlICdzZWxlY3QnIG11c3QgaGFwcGVuIG9uIGNsaWNrLCBub3QgdGFwLCBub3QgZm9jdXMsXHJcbiAgICAvLyBvbmx5ICdjbGljaycgaXMgcmVsaWFibGUgYW5kIGJ1Zy1mcmVlLlxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy4kYWN0aXZpdHksXHJcbiAgICAgICAgZXZlbnQ6ICdjbGljaycsXHJcbiAgICAgICAgc2VsZWN0b3I6ICd0ZXh0YXJlYScsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuc2VsZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLm1hcmtldHBsYWNlUHJvZmlsZSxcclxuICAgICAgICBldmVudDogJ2Vycm9yJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIudGFzayA9PT0gJ3NhdmUnKSByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSAnRXJyb3IgbG9hZGluZyBkYXRhIHRvIGJ1aWxkIHRoZSBCdXR0b24uJztcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcclxuICAgIHRoaXMuYXBwLm1vZGVsLm1hcmtldHBsYWNlUHJvZmlsZS5zeW5jKCk7XHJcbiAgICBcclxuICAgIC8vIFNldCB0aGUgam9iIHRpdGxlXHJcbiAgICB2YXIgam9iSUQgPSBzdGF0ZS5yb3V0ZS5zZWdtZW50c1swXSB8MDtcclxuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoam9iSUQpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHZhciBtYXJrZXRwbGFjZVByb2ZpbGUgPSBhcHAubW9kZWwubWFya2V0cGxhY2VQcm9maWxlO1xyXG4gICAgXHJcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XHJcbiAgICBcclxuICAgIC8vIFJlYWQtb25seSBib29rQ29kZVxyXG4gICAgdGhpcy5ib29rQ29kZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBtYXJrZXRwbGFjZVByb2ZpbGUuZGF0YS5ib29rQ29kZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XHJcbiAgICBcclxuICAgIC8vIEJ1dHRvbiB0eXBlLCBjYW4gYmU6ICdzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnLCAnbGluaydcclxuICAgIHRoaXMudHlwZSA9IGtvLm9ic2VydmFibGUoJ21lZGl1bScpO1xyXG5cclxuICAgIHRoaXMuaXNMb2NrZWQgPSBtYXJrZXRwbGFjZVByb2ZpbGUuaXNMb2NrZWQ7XHJcbiAgICBcclxuICAgIC8vIEdlbmVyYXRpb24gb2YgdGhlIGJ1dHRvbiBjb2RlXHJcbiAgICBcclxuICAgIHZhciBidXR0b25UZW1wbGF0ZSA9XHJcbiAgICAgICAgJzwhLS0gYmVnaW4gTG9jb25vbWljcyBib29rLW1lLWJ1dHRvbiAtLT4nICtcclxuICAgICAgICAnPGEgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9ja1wiPjxpbWcgYWx0PVwiXCIgc3R5bGU9XCJib3JkZXI6bm9uZVwiIC8+PC9hPicgKyBcclxuICAgICAgICAnPCEtLSBlbmQgTG9jb25vbWljcyBib29rLW1lLWJ1dHRvbiAtLT4nO1xyXG4gICAgXHJcbiAgICB2YXIgbGlua1RlbXBsYXRlID1cclxuICAgICAgICAnPCEtLSBiZWdpbiBMb2Nvbm9taWNzIGJvb2stbWUtYnV0dG9uIC0tPicgK1xyXG4gICAgICAgICc8YT48c3Bhbj48L3NwYW4+PC9hPicgK1xyXG4gICAgICAgICc8IS0tIGVuZCBMb2Nvbm9taWNzIGJvb2stbWUtYnV0dG9uIC0tPic7XHJcblxyXG4gICAgdGhpcy5idXR0b25IdG1sQ29kZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAobWFya2V0cGxhY2VQcm9maWxlLmlzTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbG9hZGluZy4uLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZSgpLFxyXG4gICAgICAgICAgICAgICAgdHBsID0gYnV0dG9uVGVtcGxhdGU7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xpbmsnKVxyXG4gICAgICAgICAgICAgICAgdHBsID0gbGlua1RlbXBsYXRlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNpdGVVcmwgPSAkKCdodG1sJykuYXR0cignZGF0YS1zaXRlLXVybCcpLFxyXG4gICAgICAgICAgICAgICAgbGlua1VybCA9IHNpdGVVcmwgKyAnL2Jvb2svJyArIHRoaXMuYm9va0NvZGUoKSArICcvJyArIHRoaXMuam9iVGl0bGVJRCgpICsgJy8nLFxyXG4gICAgICAgICAgICAgICAgaW1nVXJsID0gc2l0ZVVybCArICcvaW1nL2V4dGVybi9ib29rLW1lLWJ1dHRvbi0nICsgdHlwZSArICcucG5nJztcclxuXHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gZ2VuZXJhdGVCdXR0b25Db2RlKHtcclxuICAgICAgICAgICAgICAgIHRwbDogdHBsLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdDbGljayBoZXJlIHRvIGJvb2sgbWUgbm93IChvbiBsb2Nvbm9taWNzLmNvbSknLFxyXG4gICAgICAgICAgICAgICAgbGlua1VybDogbGlua1VybCxcclxuICAgICAgICAgICAgICAgIGltZ1VybDogaW1nVXJsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIC8vIFRPRE8gQ29weSBmZWF0dXJlOyB3aWxsIG5lZWQgYSBuYXRpdmUgcGx1Z2luXHJcbiAgICB0aGlzLmNvcHlDb2RlID0gZnVuY3Rpb24oKSB7IH07XHJcbiAgICBcclxuICAgIHRoaXMuc2VuZEJ5RW1haWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBUT0RPIFNlbmQgYnkgZW1haWwsIHdpdGggd2luZG93Lm9wZW4oJ21haWx0bzomYm9keT1jb2RlJyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUJ1dHRvbkNvZGUob3B0aW9ucykge1xyXG5cclxuICAgIHZhciAkYnRuID0gJCgkLnBhcnNlSFRNTCgnPGRpdj4nICsgb3B0aW9ucy50cGwgKyAnPC9kaXY+JykpO1xyXG5cclxuICAgICRidG5cclxuICAgIC5maW5kKCdhJylcclxuICAgIC5hdHRyKCdocmVmJywgb3B0aW9ucy5saW5rVXJsKVxyXG4gICAgLmZpbmQoJ3NwYW4nKVxyXG4gICAgLnRleHQob3B0aW9ucy5sYWJlbCk7XHJcbiAgICAkYnRuXHJcbiAgICAuZmluZCgnaW1nJylcclxuICAgIC5hdHRyKCdzcmMnLCBvcHRpb25zLmltZ1VybClcclxuICAgIC5hdHRyKCdhbHQnLCBvcHRpb25zLmxhYmVsKTtcclxuXHJcbiAgICByZXR1cm4gJGJ0bi5odG1sKCk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBib29raW5nQ29uZmlybWF0aW9uIGFjdGl2aXR5XHJcbiAgICBcclxuICAgIFRPRE86IFRvIHJlcGxhY2VkIGJ5IGEgbW9kYWxcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcbiAgICBcclxudmFyIHNpbmdsZXRvbiA9IG51bGw7XHJcblxyXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiBpbml0Q2xpZW50cygkYWN0aXZpdHksIGFwcCkge1xyXG5cclxuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpXHJcbiAgICAgICAgc2luZ2xldG9uID0gbmV3IEJvb2tpbmdDb25maXJtYXRpb25BY3Rpdml0eSgkYWN0aXZpdHksIGFwcCk7XHJcbiAgICBcclxuICAgIHJldHVybiBzaW5nbGV0b247XHJcbn07XHJcblxyXG5mdW5jdGlvbiBCb29raW5nQ29uZmlybWF0aW9uQWN0aXZpdHkoJGFjdGl2aXR5LCBhcHApIHtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICBcclxuICAgIHRoaXMuJGFjdGl2aXR5ID0gJGFjdGl2aXR5O1xyXG4gICAgdGhpcy5hcHAgPSBhcHA7XHJcblxyXG4gICAgdGhpcy5kYXRhVmlldyA9IG5ldyBWaWV3TW9kZWwoKTtcclxuICAgIGtvLmFwcGx5QmluZGluZ3ModGhpcy5kYXRhVmlldywgJGFjdGl2aXR5LmdldCgwKSk7XHJcbn1cclxuXHJcbkJvb2tpbmdDb25maXJtYXRpb25BY3Rpdml0eS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xyXG5cclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYm9va2luZylcclxuICAgICAgICB0aGlzLmRhdGFWaWV3LmJvb2tpbmcob3B0aW9ucy5ib29raW5nKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcclxuXHJcbiAgICAvLyA6QXBwb2ludG1lbnRcclxuICAgIHRoaXMuYm9va2luZyA9IGtvLm9ic2VydmFibGUobnVsbCk7XHJcbn1cclxuIiwiLyoqIENhbGVuZGFyIGFjdGl2aXR5ICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcbiAgICAvL0NhbGVuZGFyU2xvdCA9IHJlcXVpcmUoJy4uL21vZGVscy9DYWxlbmRhclNsb3QnKTtcclxuXHJcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvRGF0ZVBpY2tlcicpO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIENhbGVuZGFyQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCdDYWxlbmRhcicpO1xyXG5cclxuICAgIC8qIEdldHRpbmcgZWxlbWVudHMgKi9cclxuICAgIHRoaXMuJGRhdGVwaWNrZXIgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2FsZW5kYXJEYXRlUGlja2VyJyk7XHJcbiAgICB0aGlzLiRkYWlseVZpZXcgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2FsZW5kYXJEYWlseVZpZXcnKTtcclxuICAgIHRoaXMuJGRhdGVIZWFkZXIgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2FsZW5kYXJEYXRlSGVhZGVyJyk7XHJcbiAgICB0aGlzLiRkYXRlVGl0bGUgPSB0aGlzLiRkYXRlSGVhZGVyLmNoaWxkcmVuKCcuQ2FsZW5kYXJEYXRlSGVhZGVyLWRhdGUnKTtcclxuICAgIHRoaXMuJGNob29zZU5ldyA9ICQoJyNjYWxlbmRhckNob29zZU5ldycpO1xyXG4gICAgXHJcbiAgICAvKiBJbml0IGNvbXBvbmVudHMgKi9cclxuICAgIHRoaXMuJGRhdGVwaWNrZXIuc2hvdygpLmRhdGVwaWNrZXIoKTtcclxuICAgIFxyXG4gICAgLyogRXZlbnQgaGFuZGxlcnMgKi9cclxuICAgIC8vIENoYW5nZXMgb24gY3VycmVudERhdGVcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmN1cnJlbnREYXRlLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIGxheW91dCB1cGRhdGUsIHJlcXVpcmVkIGJ5IHRoZSBmdWxsLWhlaWdodCBmZWF0dXJlXHJcbiAgICAgICAgICAgICQod2luZG93KS50cmlnZ2VyKCdsYXlvdXRVcGRhdGUnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWRhdGUgPSBtb21lbnQoZGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1kYXRlLmlzVmFsaWQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNvRGF0ZSA9IG1kYXRlLnRvSVNPU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBkYXRlcGlja2VyIHNlbGVjdGVkIGRhdGUgb24gZGF0ZSBjaGFuZ2UgKGZyb20gXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgc291cmNlIHRoYW4gdGhlIGRhdGVwaWNrZXIgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGF0ZXBpY2tlci5yZW1vdmVDbGFzcygnaXMtdmlzaWJsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBub3QgZnJvbSB0aGUgd2lkZ2V0P1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRkYXRlcGlja2VyLmRhdGVwaWNrZXIoJ2dldFZhbHVlJykudG9JU09TdHJpbmcoKSAhPT0gaXNvRGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGF0ZXBpY2tlci5kYXRlcGlja2VyKCdzZXRWYWx1ZScsIGRhdGUsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPbiBjdXJyZW50RGF0ZSBjaGFuZ2VzLCB1cGRhdGUgdGhlIFVSTFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHNhdmUgYSB1c2VmdWwgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBET1VCVDogcHVzaCBvciByZXBsYWNlIHN0YXRlPyAobW9yZSBoaXN0b3J5IGVudHJpZXMgb3IgdGhlIHNhbWU/KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsICdjYWxlbmRhci8nICsgaXNvRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERPTkVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBmYWlsLCBiYWQgZGF0ZSBvciBub3QgZGF0ZSBhdCBhbGxcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50RGF0ZShnZXREYXRlV2l0aG91dFRpbWUoKSk7XHJcblxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU3dpcGUgZGF0ZSBvbiBnZXN0dXJlXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRkYWlseVZpZXcsXHJcbiAgICAgICAgZXZlbnQ6ICdzd2lwZWxlZnQgc3dpcGVyaWdodCcsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlyID0gZS50eXBlID09PSAnc3dpcGVsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JztcclxuXHJcbiAgICAgICAgICAgIC8vIEhhY2sgdG8gc29sdmUgdGhlIGZyZWV6eS1zd2lwZSBhbmQgdGFwLWFmdGVyIGJ1ZyBvbiBKUU06XHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIoJ3RvdWNoZW5kJyk7XHJcbiAgICAgICAgICAgIC8vIENoYW5nZSBkYXRlXHJcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignbW92ZVZhbHVlJywgZGlyLCAnZGF0ZScpO1xyXG5cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENoYW5naW5nIGRhdGUgd2l0aCBidXR0b25zOlxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy4kZGF0ZUhlYWRlcixcclxuICAgICAgICBldmVudDogJ3RhcCcsXHJcbiAgICAgICAgc2VsZWN0b3I6ICcuQ2FsZW5kYXJEYXRlSGVhZGVyLXN3aXRjaCcsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnI3ByZXYnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignbW92ZVZhbHVlJywgJ3ByZXYnLCAnZGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnI25leHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignbW92ZVZhbHVlJywgJ25leHQnLCAnZGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBMZXRzIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNob3dpbmcgZGF0ZXBpY2tlciB3aGVuIHByZXNzaW5nIHRoZSB0aXRsZVxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy4kZGF0ZVRpdGxlLFxyXG4gICAgICAgIGV2ZW50OiAndGFwJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIudG9nZ2xlQ2xhc3MoJ2lzLXZpc2libGUnKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVXBkYXRpbmcgdmlldyBkYXRlIHdoZW4gcGlja2VkIGFub3RoZXIgb25lXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRkYXRlcGlja2VyLFxyXG4gICAgICAgIGV2ZW50OiAnY2hhbmdlRGF0ZScsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBpZiAoZS52aWV3TW9kZSA9PT0gJ2RheXMnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50RGF0ZShnZXREYXRlV2l0aG91dFRpbWUoZS5kYXRlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNldCBkYXRlIHRvIHRvZGF5XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50RGF0ZShnZXREYXRlV2l0aG91dFRpbWUoKSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvLyBEYXRlIGZyb20gdGhlIHBhcmFtZXRlciwgZmFsbGJhY2sgdG8gdG9kYXlcclxuICAgIHZhciBzZGF0ZSA9IG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cyAmJiBvcHRpb25zLnJvdXRlLnNlZ21lbnRzWzBdLFxyXG4gICAgICAgIGRhdGU7XHJcbiAgICBpZiAoc2RhdGUpIHtcclxuICAgICAgICAvLyBQYXJzaW5nIGRhdGUgZnJvbSBJU08gZm9ybWF0XHJcbiAgICAgICAgdmFyIG1kYXRlID0gbW9tZW50KHNkYXRlKTtcclxuICAgICAgICAvLyBDaGVjayBpcyB2YWxpZCwgYW5kIGVuc3VyZSBpcyBkYXRlIGF0IDEyQU1cclxuICAgICAgICBkYXRlID0gbWRhdGUuaXNWYWxpZCgpID8gZ2V0RGF0ZVdpdGhvdXRUaW1lKG1kYXRlLnRvRGF0ZSgpKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghZGF0ZSlcclxuICAgICAgICAvLyBUb2RheTpcclxuICAgICAgICBkYXRlID0gZ2V0RGF0ZVdpdGhvdXRUaW1lKCk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsLmN1cnJlbnREYXRlKGRhdGUpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0RGF0ZVdpdGhvdXRUaW1lKGRhdGUpIHtcclxuICAgIGRhdGUgPSBkYXRlIHx8IG5ldyBEYXRlKCk7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoXHJcbiAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgIGRhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICBkYXRlLmdldERhdGUoKSxcclxuICAgICAgICAwLCAwLCAwXHJcbiAgICApO1xyXG59XHJcblxyXG52YXIgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKSxcclxuICAgIFRpbWVTbG90Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9UaW1lU2xvdCcpO1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHRoaXMuY3VycmVudERhdGUgPSBrby5vYnNlcnZhYmxlKGdldERhdGVXaXRob3V0VGltZSgpKTtcclxuICAgIHZhciBmdWxsRGF5RnJlZSA9IFtBcHBvaW50bWVudC5uZXdGcmVlU2xvdCh7IGRhdGU6IHRoaXMuY3VycmVudERhdGUoKSB9KV07XHJcbiAgICAvLyBUaGUgJ2ZyZWUnIGV2ZW50IG11c3QgdXBkYXRlIHdpdGggYW55IGNoYW5nZSBpbiBjdXJyZW50RGF0ZVxyXG4gICAgdGhpcy5jdXJyZW50RGF0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgICAgIGlmIChkYXRlKSB7XHJcbiAgICAgICAgICAgIGZ1bGxEYXlGcmVlWzBdLnN0YXJ0VGltZShkYXRlKTtcclxuICAgICAgICAgICAgZnVsbERheUZyZWVbMF0uZW5kVGltZShkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAvLyBzbG90c1NvdXJjZSBzYXZlIHRoZSBkYXRhIGFzIHByb2Nlc3NlZCBieSBhIHJlcXVlc3Qgb2YgXHJcbiAgICAvLyBkYXRhIGJlY2F1c2UgYSBkYXRlIGNoYW5nZS5cclxuICAgIC8vIEl0J3MgdXBkYXRlZCBieSBjaGFuZ2VzIG9uIGN1cnJlbnREYXRlIHRoYXQgcGVyZm9ybXMgdGhlIHJlbW90ZSBsb2FkaW5nXHJcbiAgICB0aGlzLnNsb3RzU291cmNlID0ga28ub2JzZXJ2YWJsZShmdWxsRGF5RnJlZSk7XHJcbiAgICAvLyBzbG90cyBjb21wdXRlZCwgdXNpbmcgc2xvdHNTb3VyY2UuXHJcbiAgICAvLyBBcyBjb21wdXRlZCBpbiBvcmRlciB0byBhbGxvdyBhbnkgb3RoZXIgb2JzZXJ2YWJsZSBjaGFuZ2VcclxuICAgIC8vIGZyb20gdHJpZ2dlciB0aGUgY3JlYXRpb24gb2YgYSBuZXcgdmFsdWVcclxuICAgIHRoaXMuc2xvdHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHNTb3VyY2UoKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYXBwLm1vZGVsLmFwcG9pbnRtZW50c1xyXG4gICAgICAgICAgICAuZmlsbFdpdGhGcmVlU2xvdHMoc2xvdHMpXHJcbiAgICAgICAgICAgIC5tYXAoVGltZVNsb3RWaWV3TW9kZWwuZnJvbUFwcG9pbnRtZW50KTtcclxuXHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgY3VycmVudCBzbG90cyBvbiBkYXRlIGNoYW5nZVxyXG4gICAgdmFyIHByZXZpb3VzRGF0ZSA9IHRoaXMuY3VycmVudERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgdGhpcy5jdXJyZW50RGF0ZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IFRoZSBkYXRlIG9iamVjdCBtYXkgYmUgcmV1c2VkIGFuZCBtdXRhdGVkIGJldHdlZW4gY2FsbHNcclxuICAgICAgICAvLyAobW9zdGx5IGJlY2F1c2UgdGhlIHdpZGdldCBJIHRoaW5rKSwgc28gaXMgYmV0dGVyIHRvIGNyZWF0ZVxyXG4gICAgICAgIC8vIGEgY2xvbmUgYW5kIGF2b2lkIGdldHRpbmcgcmFjZS1jb25kaXRpb25zIGluIHRoZSBkYXRhIGRvd25sb2FkaW5nLlxyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKGRhdGUudG9JU09TdHJpbmcoKSkpO1xyXG5cclxuICAgICAgICAvLyBBdm9pZCBkdXBsaWNhdGVkIG5vdGlmaWNhdGlvbiwgdW4tY2hhbmdlZCBkYXRlXHJcbiAgICAgICAgaWYgKGRhdGUudG9JU09TdHJpbmcoKSA9PT0gcHJldmlvdXNEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNEYXRlID0gZGF0ZS50b0lTT1N0cmluZygpO1xyXG5cclxuICAgICAgICB0aGlzLmlzTG9hZGluZyh0cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICBhcHAubW9kZWwuYXBwb2ludG1lbnRzLmdldEFwcG9pbnRtZW50c0J5RGF0ZShkYXRlKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGFwcG9pbnRtZW50c0xpc3QpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogRmlyc3QsIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB3ZSBhcmVcclxuICAgICAgICAgICAgLy8gaW4gdGhlIHNhbWUgZGF0ZSBzdGlsbCwgYmVjYXVzZSBzZXZlcmFsIGxvYWRpbmdzXHJcbiAgICAgICAgICAgIC8vIGNhbiBoYXBwZW4gYXQgYSB0aW1lIChjaGFuZ2luZyBxdWlja2x5IGZyb20gZGF0ZSB0byBkYXRlXHJcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgd2FpdCBmb3IgZmluaXNoKSwgYXZvaWRpbmcgYSByYWNlLWNvbmRpdGlvblxyXG4gICAgICAgICAgICAvLyB0aGF0IGNyZWF0ZSBmbGlja2VyaW5nIGVmZmVjdHMgb3IgcmVwbGFjZSB0aGUgZGF0ZSBldmVudHNcclxuICAgICAgICAgICAgLy8gYnkgdGhlIGV2ZW50cyBmcm9tIG90aGVyIGRhdGUsIGJlY2F1c2UgaXQgdG9va3MgbW9yZSBhbiBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBzdGlsbCB0aGlzIGhhcyB0aGUgbWlub3IgYnVnIG9mIGxvc2luZyB0aGUgaXNMb2FkaW5nXHJcbiAgICAgICAgICAgIC8vIGlmIGEgcHJldmlvdXMgdHJpZ2dlcmVkIGxvYWQgc3RpbGwgZGlkbid0IGZpbmlzaGVkOyBpdHMgbWlub3JcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpcyB2ZXJ5IHJhcmUgdGhhdCBoYXBwZW5zLCBtb3ZpbmcgdGhpcyBzdHVmZlxyXG4gICAgICAgICAgICAvLyB0byBhIHNwZWNpYWwgYXBwTW9kZWwgZm9yIG1peGVkIGJvb2tpbmdzIGFuZCBldmVudHMgd2l0aCBcclxuICAgICAgICAgICAgLy8gcGVyIGRhdGUgY2FjaGUgdGhhdCBpbmNsdWRlcyBhIHZpZXcgb2JqZWN0IHdpdGggaXNMb2FkaW5nIHdpbGxcclxuICAgICAgICAgICAgLy8gZml4IGl0IGFuZCByZWR1Y2UgdGhpcyBjb21wbGV4aXR5LlxyXG4gICAgICAgICAgICBpZiAoZGF0ZS50b0lTT1N0cmluZygpICE9PSB0aGlzLmN1cnJlbnREYXRlKCkudG9JU09TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmFjZSBjb25kaXRpb24sIG5vdCB0aGUgc2FtZSEhIG91dDpcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYXBwb2ludG1lbnRzTGlzdCAmJiBhcHBvaW50bWVudHNMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzb3VyY2U6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsb3RzU291cmNlKGFwcG9pbnRtZW50c0xpc3QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbG90c1NvdXJjZShmdWxsRGF5RnJlZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFNob3cgZnJlZSBvbiBlcnJvclxyXG4gICAgICAgICAgICB0aGlzLnNsb3RzU291cmNlKGZ1bGxEYXlGcmVlKTtcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG1zZyA9ICdFcnJvciBsb2FkaW5nIGNhbGVuZGFyIGV2ZW50cy4nO1xyXG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBDYWxlbmRhclN5bmNpbmcgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcclxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBDYWxlbmRhclN5bmNpbmdBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIFxyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5GcmVlbGFuY2VyO1xyXG5cclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycsIHtcclxuICAgICAgICBiYWNrTGluazogJ3NjaGVkdWxpbmcnXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQWRkaW5nIGF1dG8tc2VsZWN0IGJlaGF2aW9yIHRvIHRoZSBleHBvcnQgVVJMXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2FsZW5kYXJTeW5jLWljYWxFeHBvcnRVcmwnKSxcclxuICAgICAgICBldmVudDogJ2NsaWNrJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJCh0aGlzKS5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy5hcHAubW9kZWwuY2FsZW5kYXJTeW5jaW5nLFxyXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgY2FsZW5kYXIgc3luY2luZyBzZXR0aW5ncy4nIDogJ0Vycm9yIGxvYWRpbmcgY2FsZW5kYXIgc3luY2luZyBzZXR0aW5ncy4nO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci50YXNrICYmIGVyci5lcnJvciB8fCBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcbiAgICBcclxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxyXG4gICAgdGhpcy5hcHAubW9kZWwuY2FsZW5kYXJTeW5jaW5nLnN5bmMoKTtcclxuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxyXG4gICAgdGhpcy52aWV3TW9kZWwuZGlzY2FyZCgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHZhciBjYWxlbmRhclN5bmNpbmcgPSBhcHAubW9kZWwuY2FsZW5kYXJTeW5jaW5nO1xyXG5cclxuICAgIHZhciBzeW5jVmVyc2lvbiA9IGNhbGVuZGFyU3luY2luZy5uZXdWZXJzaW9uKCk7XHJcbiAgICBzeW5jVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XHJcbiAgICAgICAgaWYgKGl0SXMpIHtcclxuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xyXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXHJcbiAgICAgICAgICAgIC8vIGNvbmZpcm1hdGlvbiB0byBsb2FkIHRoZW0gb3IgZGlzY2FyZCBhbmQgb3ZlcndyaXRlIHRoZW07XHJcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIHNlcnZlciB2ZXJzaW9uKS5cclxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxyXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcclxuICAgICAgICAgICAgc3luY1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XHJcbiAgICB0aGlzLnN5bmMgPSBzeW5jVmVyc2lvbi52ZXJzaW9uO1xyXG5cclxuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2NrZWQoKSB8fCB0aGlzLmlzUmVzZXRpbmcoKTtcclxuICAgIH0sIGNhbGVuZGFyU3luY2luZyk7XHJcblxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICdsb2FkaW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgICAgICAnU2F2ZSdcclxuICAgICAgICApO1xyXG4gICAgfSwgY2FsZW5kYXJTeW5jaW5nKTtcclxuICAgIFxyXG4gICAgdGhpcy5yZXNldFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc1Jlc2V0aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICdyZXNldGluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgICdSZXNldCBQcml2YXRlIFVSTCdcclxuICAgICAgICApO1xyXG4gICAgfSwgY2FsZW5kYXJTeW5jaW5nKTtcclxuICAgIFxyXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcclxuICAgICAgICBzeW5jVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XHJcbiAgICAgICAgLy8gRm9yY2UgdG8gc2F2ZSwgZXZlbiBpZiB0aGVyZSB3YXMgcmVtb3RlIHVwZGF0ZXNcclxuICAgICAgICBzeW5jVmVyc2lvbi5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXBwLnN1Y2Nlc3NTYXZlKCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICAgICAgY2FsZW5kYXJTeW5jaW5nLnJlc2V0RXhwb3J0VXJsKCk7XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qKlxuICAgIENsaWVudEVkaXRpb24gYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIgaXMgPSByZXF1aXJlKCdpc19qcycpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ2xpZW50RWRpdGlvbkFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICBcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ2NsaWVudHMnLCB7XG4gICAgICAgIGJhY2tMaW5rOiAnY2xpZW50cydcbiAgICB9KTtcbiAgICBcbiAgICAvLyBJZiB0aGVyZSBpcyBhIGNoYW5nZSBvbiB0aGUgY2xpZW50SUQsIHRoZSB1cGRhdGVzIG11c3QgbWF0Y2hcbiAgICAvLyB0aGF0IChpZiBpcyBub3QgYWxyZWFkeSB0aGF0KVxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5jbGllbnRJRCxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGNsaWVudElEKSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudElEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGZvdW5kID0gL2NsaWVudEVkaXRvclxcLyhcXC0/XFxkKykvaS5leGVjKHdpbmRvdy5sb2NhdGlvbiksXG4gICAgICAgICAgICAgICAgdXJsSUQgPSBmb3VuZCAmJiBmb3VuZFsxXSB8MDtcblxuICAgICAgICAgICAgLy8gSWYgaXMgZGlmZmVyZW50IFVSTCBhbmQgY3VycmVudCBJRFxuICAgICAgICAgICAgaWYgKCFmb3VuZCB8fFxuICAgICAgICAgICAgICAgIHVybElEICE9PSBjbGllbnRJRCkge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgVVJMXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuaGlzdG9yeS5yZXBsYWNlU3RhdGUobnVsbCwgbnVsbCwgJ2NsaWVudEVkaXRvci8nICsgY2xpZW50SUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBvZiB0aGUgc2F2ZSBvcGVyYXRpb25cbiAgICB0aGlzLnZpZXdNb2RlbC5vblNhdmUgPSBmdW5jdGlvbihjbGllbnRJRCkge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5yZXR1cm5OZXdBc1NlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBHbyB0byBwcmV2aW91cyBhY3Rpdml0eSB0aGF0IHJlcXVpcmVkXG4gICAgICAgICAgICAvLyB0byBzZWxlY3QgYSBjbGllbnRcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuY2xpZW50SUQgPSBjbGllbnRJRDtcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgc2F2ZVxuICAgICAgICAgICAgdGhpcy5hcHAuc3VjY2Vzc1NhdmUoKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogOCovXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG4gICAgXG4gICAgLy8gcmVzZXRcbiAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRJRCgwKTtcblxuICAgIC8vIHBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cyB8fCBbXTtcbiAgICBcbiAgICB2YXIgY2xpZW50SUQgPSBwYXJhbXNbMF0gfDA7XG4gICAgXG4gICAgaWYgKGNsaWVudElEKSB7XG4gICAgICAgIHRoaXMudmlld01vZGVsLmNsaWVudElEKGNsaWVudElEKTtcbiAgICAgICAgXG4gICAgICAgIC8qdGhpcy52aWV3TW9kZWwuY2xpZW50LnN5bmMoY2xpZW50SUQpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgY2xpZW50IGRhdGEnLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcykpOyovXG5cbiAgICAgICAgdGhpcy5hcHAubW9kZWwuY3VzdG9tZXJzLmNyZWF0ZUl0ZW1WZXJzaW9uKGNsaWVudElEKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoY2xpZW50VmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKGNsaWVudFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRWZXJzaW9uKGNsaWVudFZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlcignRWRpdCBDbGllbnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY2xpZW50VmVyc2lvbihudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXIoJ1Vua25vdyBjbGllbnQgb3Igd2FzIGRlbGV0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIGNsaWVudCBkYXRhJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayByZXF1ZXN0IHBhcmFtZXRlcnMgdGhhdCBhbGxvdyBwcmVzZXQgY3VzdG9tZXIgaW5mb3JtYXRpb25cbiAgICAgICAgLy8gKHVzZWQgd2hlbiB0aGUgY3VzdG9tZXIgaXMgY3JlYXRlZCBiYXNlZCBvbiBhbiBleGlzdGVudCBtYXJrZXRwbGFjZSB1c2VyKVxuICAgICAgICB2YXIgcHJlc2V0RGF0YSA9IHRoaXMucmVxdWVzdERhdGEucHJlc2V0RGF0YSB8fCB7fTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IHNldCBhbiBleHBsaWNpdCAnZmFsc2UnIHZhbHVlIG9uIGVkaXRhYmxlXG4gICAgICAgIC8vIGZpZWxkIChhcyB3aGVuIHRoZXJlIGlzIG5vdCBkYXRhIGdpdmVuKSwgc2V0IHRvIHRydWUgc28gY2FuIGJlIGVkaXRlZFxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGJlY2F1c2UgYSBnaXZlbiBtYXJrZXRwbGFjZSB1c2VyIHdpbGwgY29tZSB3aXRoIGVkaXRhYmxlOmZhbHNlXG4gICAgICAgIC8vIGFuZCBuZWVkIHRvIGJlIHByZXNlcnZlZCwgd2hpbGUgb24gcmVndWxhciAnbmV3IGNsaWVudCcgYWxsIGRhdGEgaXMgc2V0IGJ5IFxuICAgICAgICAvLyB0aGUgZnJlZWxhbmNlci5cbiAgICAgICAgaWYgKHByZXNldERhdGEuZWRpdGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcmVzZXREYXRhLmVkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qdGhpcy52aWV3TW9kZWwuY2xpZW50Lm5ld0l0ZW0ocHJlc2V0RGF0YSk7Ki9cbiAgICAgICAgLy8gTmV3IGNsaWVudFxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRWZXJzaW9uKHRoaXMuYXBwLm1vZGVsLmN1c3RvbWVycy5uZXdJdGVtKHByZXNldERhdGEpKTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdBZGQgYSBDbGllbnQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEV4dHJhIHByZXNldCBkYXRhXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLm5ld0ZvclNlYXJjaFRleHQpIHtcbiAgICAgICAgICAgIGNsaWVudERhdGFGcm9tU2VhcmNoVGV4dCh0aGlzLnJlcXVlc3REYXRhLm5ld0ZvclNlYXJjaFRleHQgfHwgJycsIHRoaXMudmlld01vZGVsLmNsaWVudCgpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICAgIFNtYWxsIHV0aWxpdHkgdGhhdCBqdXN0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAgICBzdHJpbmcgc2VlbXMgYSBwb3NzaWJsZSBwaG9uZSBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICBOT1RFOiBJcyBOT1QgYW4gZXhhdXN0aXZlIHBob25lIHZhbGlkYXRpb24gY2hlY2ssIGp1c3RcbiAgICBjaGVja3MgaXMgdGhlcmUgYXJlIHNldmVyYWwgbnVtYmVycyBzbyB0aGVyZSBpcyBhIGNoYW5jZVxuICAgIHRvIGJlIGEgcGhvbmUuIFRoZXJlIGFyZSBzdHJpY2tlciBjaGVja3MgKGFubm90YXRlZCkgYnV0XG4gICAgY2FuIGZhaWwgb24gc29tZSBzaXR1YXRpb25zIChzd2l0Y2hib2FyZCBudW1iZXJzKSBvciBpblxuICAgIGRpZmZlcmVudCBsb2NhbGVzLlxuKiovXG5mdW5jdGlvbiBzZWVtc0FQaG9uZU51bWJlcihzdHIpIHtcbiAgICAvLyBQb3NzaWJsZSBzdHJpY2tlciBjb21wYXJpc2lvblxuICAgIC8vIHJldHVybiBpcy5uYW5wUGhvbmUoc3RyKSB8fCBpcy5lcHBQaG9uZShzdHIpO1xuICAgIFxuICAgIC8vIEp1c3QgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0aHJlZSBjb25zZWN1dGl2ZSBudW1iZXJzLFxuICAgIC8vIHRoZW4gJ21heScgYmUgYSBwaG9uZSBudW1iZXIgKG1heSBiZSBhbnl0aGluZyBlbHNlLCBidXRcbiAgICAvLyBzaW5jZSBzb21lIHNwZWNpYWwgcGhvbmUgbnVtYmVycyBjYW4gaGF2ZSBsZXR0ZXJzIG9yIHNpZ25zLFxuICAgIC8vIHRoaXMgaXMganVzdCBhIHZlcnkgbGF4IGFuZCBjb25zZXJ2YXRpdmUgKHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcykgY2hlY2suXG4gICAgcmV0dXJuICgvXFxkezMsfS8pLnRlc3Qoc3RyIHx8ICcnKTtcbn1cblxuLyoqXG4gICAgVXNlIHRoZSBwcm92aWRlZCBzZWFyY2ggdGV4dCBhcyB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgIGZvcjogbmFtZSwgZW1haWwgb3IgcGhvbmUgKHdoYXQgZml0cyBiZXR0ZXIpXG4qKi9cbmZ1bmN0aW9uIGNsaWVudERhdGFGcm9tU2VhcmNoVGV4dCh0eHQsIGNsaWVudCkge1xuICAgIGlmIChpcy5lbWFpbCh0eHQpKSB7XG4gICAgICAgIGNsaWVudC5lbWFpbCh0eHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWVtc0FQaG9uZU51bWJlcih0eHQpKSB7XG4gICAgICAgIGNsaWVudC5waG9uZSh0eHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGluayBpcyB0aGUgZnVsbG5hbWUsIHNwbGl0aW5nIGJ5IHdoaXRlIHNwYWNlXG4gICAgICAgIHZhciBuYW1lUGFydHMgPSB0eHQuc3BsaXQoJyAnLCAyKTtcbiAgICAgICAgY2xpZW50LmZpcnN0TmFtZShuYW1lUGFydHNbMF0pO1xuICAgICAgICBpZiAobmFtZVBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNsaWVudC5sYXN0TmFtZShuYW1lUGFydHNbMV0pO1xuICAgICAgICAgICAgLy8gVE9ETyBGb3Igc3BhbmlzaCAob3IgYW55IGxvY2FsZSB3aXRoIHNlY29uZExhc3ROYW1lKVxuICAgICAgICAgICAgLy8gbXVzdCB0cnkgdG8gZGV0ZWN0IHRoZSBzZWNvbmQgbGFzdCBuYW1lP1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czo4MCAqL1xuICAgIFxuICAgIHRoaXMuY2xpZW50SUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIFxuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5jbGllbnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5jbGllbnRWZXJzaW9uKCk7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdi52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vdGhpcy5jbGllbnQgPSBhcHAubW9kZWwuY3VzdG9tZXJzLmNyZWF0ZVdpbGRjYXJkSXRlbSgpO1xuXG4gICAgdGhpcy5oZWFkZXIgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICBcbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5jdXN0b21lcnMuc3RhdGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLmN1c3RvbWVycy5zdGF0ZS5pc1N5bmNpbmc7XG4gICAgdGhpcy5pc1NhdmluZyA9IGFwcC5tb2RlbC5jdXN0b21lcnMuc3RhdGUuaXNTYXZpbmc7XG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGFwcC5tb2RlbC5jdXN0b21lcnMuc3RhdGUuaXNMb2NrZWQoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0RlbGV0aW5nKClcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmlzUmVhZE9ubHkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGMgJiYgIWMuZWRpdGFibGUoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaXNEZWxldGluZyA9IGFwcC5tb2RlbC5jdXN0b21lcnMuc3RhdGUuaXNEZWxldGluZztcblxuICAgIHRoaXMud2FzUmVtb3ZlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuXG4gICAgdGhpcy5pc05ldyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xuICAgICAgICByZXR1cm4gIWMgfHwgIWMudXBkYXRlZERhdGUoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmNsaWVudFZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnTG9hZGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmluZyBjaGFuZ2VzJyA6IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTmV3KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FkZCBjbGllbnQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgJiYgdi5hcmVEaWZmZXJlbnQoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmUgY2hhbmdlcycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlZCdcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMudW5zYXZlZENoYW5nZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5jbGllbnRWZXJzaW9uKCk7XG4gICAgICAgIHJldHVybiB2ICYmIHYuYXJlRGlmZmVyZW50KCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5kZWxldGVUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0RlbGV0aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnRGVsZXRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgJ0RlbGV0ZSdcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGFwcC5tb2RlbC5jdXN0b21lcnMuc2V0SXRlbSh0aGlzLmNsaWVudCgpLm1vZGVsLnRvUGxhaW5PYmplY3QoKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRGF0YSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCBzZXJ2ZXIgZGF0YS5cbiAgICAgICAgICAgIHRoaXMuY2xpZW50KCkubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhKTtcbiAgICAgICAgICAgIC8vIFB1c2ggdmVyc2lvbiBzbyBpdCBhcHBlYXJzIGFzIHNhdmVkXG4gICAgICAgICAgICB0aGlzLmNsaWVudFZlcnNpb24oKS5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgICAvLyBTcGVjaWFsIHNhdmUsIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBhY3Rpdml0eSBvbiBzZXQtdXBcbiAgICAgICAgICAgIHRoaXMub25TYXZlKHNlcnZlckRhdGEuY3VzdG9tZXJVc2VySUQpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBzYXZpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5jb25maXJtUmVtb3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAubW9kYWxzLmNvbmZpcm0oe1xuICAgICAgICAgICAgdGl0bGU6ICdEZWxldGUgY2xpZW50JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdBcmUgeW91IHN1cmU/IFRoZSBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nLFxuICAgICAgICAgICAgeWVzOiAnRGVsZXRlJyxcbiAgICAgICAgICAgIG5vOiAnS2VlcCdcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgYXBwLm1vZGVsLmN1c3RvbWVycy5kZWxJdGVtKHRoaXMuY2xpZW50SUQoKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLndhc1JlbW92ZWQodHJ1ZSk7XG4gICAgICAgICAgICAvLyBHbyBvdXQgdGhlIGRlbGV0ZWQgbG9jYXRpb25cbiAgICAgICAgICAgIGFwcC5zaGVsbC5nb0JhY2soKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZGVsZXRpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIC8vIEJpcnRoIG1vbnRoIGRheVxuICAgIC8vIFRPRE8gbDEwblxuICAgIHRoaXMubW9udGhzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtcbiAgICAgICAgeyBpZDogMSwgbmFtZTogJ0phbnVhcnknfSxcbiAgICAgICAgeyBpZDogMiwgbmFtZTogJ0ZlYnJ1YXJ5J30sXG4gICAgICAgIHsgaWQ6IDMsIG5hbWU6ICdNYXJjaCd9LFxuICAgICAgICB7IGlkOiA0LCBuYW1lOiAnQXByaWwnfSxcbiAgICAgICAgeyBpZDogNSwgbmFtZTogJ01heSd9LFxuICAgICAgICB7IGlkOiA2LCBuYW1lOiAnSnVuZSd9LFxuICAgICAgICB7IGlkOiA3LCBuYW1lOiAnSnVseSd9LFxuICAgICAgICB7IGlkOiA4LCBuYW1lOiAnQXVndXN0J30sXG4gICAgICAgIHsgaWQ6IDksIG5hbWU6ICdTZXB0ZW1iZXInfSxcbiAgICAgICAgeyBpZDogMTAsIG5hbWU6ICdPY3RvYmVyJ30sXG4gICAgICAgIHsgaWQ6IDExLCBuYW1lOiAnTm92ZW1iZXInfSxcbiAgICAgICAgeyBpZDogMTIsIG5hbWU6ICdEZWNlbWJlcid9XG4gICAgXSk7XG4gICAgLy8gV2UgbmVlZCB0byB1c2UgYSBzcGVjaWFsIG9ic2VydmFibGUgaW4gdGhlIGZvcm0sIHRoYXQgd2lsbFxuICAgIC8vIHVwZGF0ZSB0aGUgYmFjay1lbmQgcHJvZmlsZS5iaXJ0aE1vbnRoXG4gICAgdGhpcy5zZWxlY3RlZEJpcnRoTW9udGggPSBrby5jb21wdXRlZCh7XG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmlydGhNb250aCA9IGMuYmlydGhNb250aCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiaXJ0aE1vbnRoID8gdGhpcy5tb250aHMoKVtiaXJ0aE1vbnRoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbihtb250aCkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xuICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgYy5iaXJ0aE1vbnRoKG1vbnRoICYmIG1vbnRoLmlkIHx8IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMubW9udGhEYXlzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbiAgICBmb3IgKHZhciBpZGF5ID0gMTsgaWRheSA8PSAzMTsgaWRheSsrKSB7XG4gICAgICAgIHRoaXMubW9udGhEYXlzLnB1c2goaWRheSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4dHJhIGZvciBidXR0b24gYWRkb25zXG4gICAgdGhpcy52YWxpZEVtYWlsID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2xpZW50KCk7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGMuZW1haWwoKTtcbiAgICAgICAgICAgIHJldHVybiBpcy5lbWFpbChlKSA/IGUgOiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnZhbGlkUGhvbmUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIHZhciBlID0gYy5waG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlZW1zQVBob25lTnVtYmVyKGUpID8gZSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICAvLyBQdWJsaWMgU2VhcmNoXG4gICAgXG4gICAgdmFyIGZvdW5kUHVibGljVXNlciA9IGZ1bmN0aW9uIGZvdW5kUHVibGljVXNlcih1c2VyKSB7XG4gICAgICAgIC8vIE9ubHkgaWYgc3RpbGwgbWF0Y2hlcyBjdXJyZW50IHZpZXcgZGF0YVxuICAgICAgICB2YXIgYyA9IHRoaXMuY2xpZW50KCk7XG4gICAgICAgIGlmICghYykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gRG9uJ3Qgb2ZmZXIgaWYgaXMgYWxyZWFkeSB0aGF0IHVzZXIhXG4gICAgICAgIGlmIChjLmN1c3RvbWVyVXNlcklEKCkgPT09IHVzZXIuY3VzdG9tZXJVc2VySUQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIE5PVEU6IGF2b2lkaW5nIHVzZSBmdWxsTmFtZSBiZWNhdXNlIGl0IGNhbiBtYWtlIG1vcmUgdGhhbiBvbmUgY29uZmxpY3RpbmdcbiAgICAgICAgLy8gcmVzdWx0cywgYmVpbmcgbm90IGVub3VnaCB0aGUgbmFtZSB0byBjb25maXJtIHRoZSB1c2VyICh1c2UgdGhlIHNlYXJjaCBmb3IgdGhhdClcbiAgICAgICAgLy8gIGMuZnVsbE5hbWUoKSA9PT0gdXNlci5mdWxsTmFtZSB8fFxuICAgICAgICBpZiAoYy5lbWFpbCgpID09PSB1c2VyLmVtYWlsIHx8XG4gICAgICAgICAgICBjLnBob25lKCkgPT09IHVzZXIucGhvbmUpIHtcblxuICAgICAgICAgICAgLy8gTm90aWZ5IHVzZXJcbiAgICAgICAgICAgIHZhciBtc2cgPSAnV2VgdmUgZm91bmQgYW4gZXhpc3RpbmcgcmVjb3JkIGZvciB7MH0uIFdvdWxkIHlvdSBsaWtlIHRvIGFkZCBoaW0gdG8geW91ciBjbGllbnRzPycucmVwbGFjZSgvXFx7MFxcfS9nLCB1c2VyLmZpcnN0TmFtZSk7XG4gICAgICAgICAgICBhcHAubW9kYWxzLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnQ3VzdG9tZXIgZm91bmQgYXQgbG9jb25vbWljcy5jb20nLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEFjZXB0ZWRcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGN1cnJlbnQgdXNlciBkYXRhXG4gICAgICAgICAgICAgICAgLy8gYnV0IGtlZXAgbm90ZXNBYm91dEN1c3RvbWVyXG4gICAgICAgICAgICAgICAgdmFyIG5vdGVzID0gYy5ub3Rlc0Fib3V0Q3VzdG9tZXIoKTtcbiAgICAgICAgICAgICAgICBjLm1vZGVsLnVwZGF0ZVdpdGgodXNlcik7XG4gICAgICAgICAgICAgICAgYy5ub3Rlc0Fib3V0Q3VzdG9tZXIobm90ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50SUQodXNlci5jdXN0b21lclVzZXJJRCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRGlzY2FyZGVkLCBkbyBub3RoaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gV2hlbiBmaWxlcmluZyBoYXMgbm8gcmVzdWx0czpcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xuICAgICAgICBpZiAoIWMpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIE5PVEU6IGRpc2NhcmRlZCB0aGUgZnVsbE5hbWUgYmVjYXVzZSBzZXZlcmFsIHJlc3VsdHMgY2FuIGJlIHJldHJpZXZlZCxcbiAgICAgICAgLy8gYmV0dGVyIHVzZSB0aGUgc2VhcmNoIGZvciB0aGF0IGFuZCBkb3VibGUgY2hlY2sgZW50cmllc1xuICAgICAgICBcbiAgICAgICAgdmFyIGVtYWlsID0gYy5lbWFpbCgpLFxuICAgICAgICAgICAgLy9mdWxsTmFtZSA9IGMuZnVsbE5hbWUoKSxcbiAgICAgICAgICAgIHBob25lID0gYy5waG9uZSgpO1xuICAgICAgICBpZiAoIWVtYWlsICYmICFwaG9uZSAvKiFmdWxsTmFtZSAmJiAqLykgcmV0dXJuO1xuXG4gICAgICAgIGFwcC5tb2RlbC5jdXN0b21lcnMucHVibGljU2VhcmNoKHtcbiAgICAgICAgICAgIC8vZnVsbE5hbWU6IGZ1bGxOYW1lLFxuICAgICAgICAgICAgZW1haWw6IGVtYWlsLFxuICAgICAgICAgICAgcGhvbmU6IHBob25lXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIGlmIChyICYmIHJbMF0pIGZvdW5kUHVibGljVXNlcihyWzBdKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlcnNcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcylcbiAgICAvLyBBdm9pZCBleGNlc3NpdmUgcmVxdWVzdCBieSBzZXR0aW5nIGEgdGltZW91dCBzaW5jZSB0aGUgbGF0ZXN0IGNoYW5nZVxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgdGltZW91dDogNDAwLCBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnIH0gfSk7XG59XG4iLCIvKipcclxuICAgIGNsaWVudHMgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcclxuICAgIHRleHRTZWFyY2ggPSByZXF1aXJlKCcuLi91dGlscy90ZXh0U2VhcmNoJyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ2xpZW50c0FjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5GcmVlbGFuY2VyO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTsgICAgXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0NsaWVudHMnLCB7XHJcbiAgICAgICAgYmFja0xpbms6ICdjbXMnXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gR2V0dGluZyBlbGVtZW50c1xyXG4gICAgdGhpcy4kaW5kZXggPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2xpZW50c0luZGV4Jyk7XHJcbiAgICB0aGlzLiRsaXN0VmlldyA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjbGllbnRzTGlzdFZpZXcnKTtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlciB0byB1cGRhdGUgaGVhZGVyIGJhc2VkIG9uIGEgbW9kZSBjaGFuZ2U6XHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5pc1NlbGVjdGlvbk1vZGUsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGl0SXMpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyVGV4dChpdElzID8gJ1NlbGVjdCBhIGNsaWVudCcgOiAnJyk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGVyIHRvIGdvIGJhY2sgd2l0aCB0aGUgc2VsZWN0ZWQgY2xpZW50IHdoZW4gXHJcbiAgICAvLyB0aGVyZSBpcyBvbmUgc2VsZWN0ZWQgYW5kIHJlcXVlc3REYXRhIGlzIGZvclxyXG4gICAgLy8gJ3NlbGVjdCBtb2RlJ1xyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRDbGllbnQsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKHRoZVNlbGVjdGVkQ2xpZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSByZXF1ZXN0IGFuZFxyXG4gICAgICAgICAgICAvLyBpdCByZXF1ZXN0ZWQgdG8gc2VsZWN0IGEgY2xpZW50LFxyXG4gICAgICAgICAgICAvLyBhbmQgYSBzZWxlY3RlZCBjbGllbnRcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0Q2xpZW50ID09PSB0cnVlICYmXHJcbiAgICAgICAgICAgICAgICB0aGVTZWxlY3RlZENsaWVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIHNlbGVjdGVkIGNsaWVudCBpbiB0aGUgaW5mb1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZENsaWVudElEID0gdGhlU2VsZWN0ZWRDbGllbnQuY3VzdG9tZXJVc2VySUQoKTtcclxuICAgICAgICAgICAgICAgIC8vIEFuZCBnbyBiYWNrXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyBMYXN0LCBjbGVhciByZXF1ZXN0RGF0YVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcclxuICAgIFxyXG4gICAgLy8gT24gZXZlcnkgc2hvdywgc2VhcmNoIGdldHMgcmVzZXRlZFxyXG4gICAgdGhpcy52aWV3TW9kZWwuc2VhcmNoVGV4dCgnJyk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXF1ZXN0RGF0YSA9IHRoaXMucmVxdWVzdERhdGE7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIGl0IGNvbWVzIGZyb20gYSBjbGllbnRFZGl0b3IgdGhhdFxyXG4gICAgLy8gcmVjZWl2ZWQgdGhlIGZsYWcgJ3JldHVybk5ld0FzU2VsZWN0ZWQnIGFuZCBhIFxyXG4gICAgLy8gY2xpZW50SUQ6IHdlIHdlcmUgaW4gc2VsZWN0aW9uIG1vZGUtPmNyZWF0aW5nIGNsaWVudC0+bXVzdFxyXG4gICAgLy8gcmV0dXJuIHRoZSBqdXN0IGNyZWF0ZWQgY2xpZW50IHRvIHRoZSBwcmV2aW91cyBwYWdlXHJcbiAgICBpZiAoc3RhdGUucmV0dXJuTmV3QXNTZWxlY3RlZCA9PT0gdHJ1ZSAmJlxyXG4gICAgICAgIHN0YXRlLmNsaWVudElEKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gcGVyZm9ybSBhbiBhY3Rpdml0eSBjaGFuZ2UgYnV0IGFsbG93IHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gdG8gc3RvcCBmaXJzdFxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRDbGllbnRJRCA9IHN0YXRlLmNsaWVudElEO1xyXG4gICAgICAgICAgICAvLyBBbmQgZ28gYmFja1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCAxKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBhdm9pZCB0aGUgcmVzdCBvcGVyYXRpb25zXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTZXQgc2VsZWN0aW9uOlxyXG4gICAgdGhpcy52aWV3TW9kZWwuaXNTZWxlY3Rpb25Nb2RlKHN0YXRlLnNlbGVjdENsaWVudCA9PT0gdHJ1ZSk7XHJcbiAgICBcclxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxyXG4gICAgdGhpcy5hcHAubW9kZWwuY3VzdG9tZXJzLnN5bmMoKVxyXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgdGhlIGNsaWVudHMgbGlzdCcsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcblxyXG4gICAgdGhpcy5oZWFkZXJUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcblxyXG4gICAgLy8gRXNwZWNpYWwgbW9kZSB3aGVuIGluc3RlYWQgb2YgcGljayBhbmQgZWRpdCB3ZSBhcmUganVzdCBzZWxlY3RpbmdcclxuICAgIC8vICh3aGVuIGVkaXRpbmcgYW4gYXBwb2ludG1lbnQpXHJcbiAgICB0aGlzLmlzU2VsZWN0aW9uTW9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG5cclxuICAgIC8vIEZ1bGwgbGlzdCBvZiBjbGllbnRzXHJcbiAgICB0aGlzLmNsaWVudHMgPSBhcHAubW9kZWwuY3VzdG9tZXJzLmxpc3Q7XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5jdXN0b21lcnMuc3RhdGUuaXNMb2FkaW5nO1xyXG4gICAgdGhpcy5pc1N5bmNpbmcgPSBhcHAubW9kZWwuY3VzdG9tZXJzLnN0YXRlLmlzU3luY2luZztcclxuICAgIFxyXG4gICAgLy8gU2VhcmNoIHRleHQsIHVzZWQgdG8gZmlsdGVyICdjbGllbnRzJ1xyXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICBcclxuICAgIC8vIFV0aWxpdHkgdG8gZ2V0IGEgZmlsdGVyZWQgbGlzdCBvZiBjbGllbnRzIGJhc2VkIG9uIGNsaWVudHNcclxuICAgIHRoaXMuZ2V0RmlsdGVyZWRMaXN0ID0gZnVuY3Rpb24gZ2V0RmlsdGVyZWRMaXN0KCkge1xyXG4gICAgICAgIHZhciBzID0gKHRoaXMuc2VhcmNoVGV4dCgpIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIFNlYXJjaCB0aGUgY2xpZW50IGJ5OlxyXG4gICAgICAgIC8vIC0gZnVsbCBuYW1lXHJcbiAgICAgICAgLy8gLSAoZWxzZSkgZW1haWxcclxuICAgICAgICAvLyAtIChlbHNlKSBwaG9uZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudHMoKS5maWx0ZXIoZnVuY3Rpb24oY2xpZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghY2xpZW50KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHRleHRTZWFyY2gocywgY2xpZW50LmZ1bGxOYW1lKCkpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRleHRTZWFyY2gocywgY2xpZW50LmVtYWlsKCkpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRleHRTZWFyY2gocywgY2xpZW50LnBob25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEZpbHRlcmVkIGxpc3Qgb2YgY2xpZW50c1xyXG4gICAgdGhpcy5maWx0ZXJlZENsaWVudHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJlZExpc3QoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBHcm91cGVkIGxpc3Qgb2YgZmlsdGVyZWQgY2xpZW50c1xyXG4gICAgdGhpcy5ncm91cGVkQ2xpZW50cyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHZhciBjbGllbnRzID0gdGhpcy5maWx0ZXJlZENsaWVudHMoKS5zb3J0KGZ1bmN0aW9uKGNsaWVudEEsIGNsaWVudEIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudEEuZmlyc3ROYW1lKCkudG9Mb3dlckNhc2UoKSA+IGNsaWVudEIuZmlyc3ROYW1lKCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZ3JvdXBzID0gW10sXHJcbiAgICAgICAgICAgIGxhdGVzdEdyb3VwID0gbnVsbCxcclxuICAgICAgICAgICAgbGF0ZXN0TGV0dGVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xyXG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gKGNsaWVudC5maXJzdE5hbWUoKVswXSB8fCAnJykudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKGxldHRlciAhPT0gbGF0ZXN0TGV0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsYXRlc3RHcm91cCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXI6IGxldHRlcixcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRzOiBbY2xpZW50XVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGxhdGVzdEdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGxhdGVzdExldHRlciA9IGxldHRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhdGVzdEdyb3VwLmNsaWVudHMucHVzaChjbGllbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cHM7XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIFxyXG4gICAgLy8vIFB1YmxpYyBzZWFyY2hcclxuICAgIHRoaXMucHVibGljU2VhcmNoUmVzdWx0cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICB0aGlzLnB1YmxpY1NlYXJjaFJ1bm5pbmcgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgLy8gV2hlbiBmaWxlcmluZyBoYXMgbm8gcmVzdWx0czpcclxuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkgeyAgICBcclxuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLmZpbHRlcmVkQ2xpZW50cygpLFxyXG4gICAgICAgICAgICBzZWFyY2hUZXh0ID0gdGhpcy5zZWFyY2hUZXh0KCksXHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBzZWFyY2ggdGV4dCBhbmQgbm8gcmVzdWx0cyBmcm9tIGxvY2FsIGZpbHRlcmluZ1xyXG4gICAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDAgJiYgc2VhcmNoVGV4dCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIHJlc3VsdHNcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNTZWFyY2hSZXN1bHRzKFtdKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBhcHAubW9kZWwuY3VzdG9tZXJzLnB1YmxpY1NlYXJjaCh7XHJcbiAgICAgICAgICAgICAgICBmdWxsTmFtZTogc2VhcmNoVGV4dCxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiBzZWFyY2hUZXh0LFxyXG4gICAgICAgICAgICAgICAgcGhvbmU6IHNlYXJjaFRleHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUnVubmluZyhyZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmVxdWVzdC50aGVuKGZ1bmN0aW9uKHIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUmVzdWx0cyhyKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hlbiBvbiByZW1vdGUgY2xpZW50cyBzZWFyY2gnLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsd2F5czpcclxuICAgICAgICAgICAgICAgIC8vIGlmIHN0aWxsIHRoZSBzYW1lLCBpdCBlbmRlZCB0aGVuIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHVibGljU2VhcmNoUnVubmluZygpID09PSByZXF1ZXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUnVubmluZyhudWxsKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUmVzdWx0cyhbXSk7XHJcbiAgICAgICAgICAgIC8vIENhbmNlbGxpbmcgYW55IHBlbmRpbmcgcmVxdWVzdCwgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gYW53YW50ZWQgcmVzdWx0cyB3aGVuIGZpbmlzaFxyXG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5wdWJsaWNTZWFyY2hSdW5uaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ICYmXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnhociAmJlxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC54aHIuYWJvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QueGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY1NlYXJjaFJ1bm5pbmcobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKVxyXG4gICAgLy8gQXZvaWQgZXhjZXNzaXZlIHJlcXVlc3QgYnkgc2V0dGluZyBhIHRpbWVvdXQgc2luY2UgdGhlIGxhdGVzdCBjaGFuZ2VcclxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgdGltZW91dDogNDAwLCBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnIH0gfSk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEFkZCBhIGNsaWVudCBmcm9tIHRoZSBwdWJsaWMvcmVtb3RlIHNlYXJjaCByZXN1bHRzXHJcbiAgICAqKi9cclxuICAgIHRoaXMuYWRkUmVtb3RlQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50KSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBjbGllbnQubW9kZWwgJiYgY2xpZW50Lm1vZGVsLnRvUGxhaW5PYmplY3QoKSB8fCBjbGllbnQ7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAkLmV4dGVuZCh7fSwgdGhpcy5yZXF1ZXN0RGF0YSwge1xyXG4gICAgICAgICAgICBwcmVzZXREYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICByZXR1cm5OZXdBc1NlbGVjdGVkOiB0aGlzLmlzU2VsZWN0aW9uTW9kZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXBwLnNoZWxsLmdvKCdjbGllbnRFZGl0b3InLCByZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIENhbGwgdGhlIGFjdGl2aXR5IHRvIGFkZCBhIG5ldyBjbGllbnQsIHBhc3NpbmcgdGhlIGN1cnJlbnRcclxuICAgICAgICBzZWFyY2ggdGV4dCBzbyBjYW4gYmUgdXNlZCBhcyBpbml0aWFsIG5hbWUvZW1haWwvcGhvbmVcclxuICAgICoqL1xyXG4gICAgdGhpcy5hZGROZXcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9ICQuZXh0ZW5kKHt9LCB0aGlzLnJlcXVlc3REYXRhLCB7XHJcbiAgICAgICAgICAgIG5ld0ZvclNlYXJjaFRleHQ6IHRoaXMuc2VhcmNoVGV4dCgpLFxyXG4gICAgICAgICAgICByZXR1cm5OZXdBc1NlbGVjdGVkOiB0aGlzLmlzU2VsZWN0aW9uTW9kZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXBwLnNoZWxsLmdvKCdjbGllbnRFZGl0b3InLCByZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy8vIFNlbGVjdGlvbnNcclxuICAgIFxyXG4gICAgdGhpcy5zZWxlY3RlZENsaWVudCA9IGtvLm9ic2VydmFibGUobnVsbCk7XHJcbiAgICBcclxuICAgIHRoaXMuc2VsZWN0Q2xpZW50ID0gZnVuY3Rpb24oc2VsZWN0ZWRDbGllbnQpIHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2xpZW50KHNlbGVjdGVkQ2xpZW50KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufVxyXG4iLCIvKipcbiAgICBDTVMgYWN0aXZpdHlcbiAgICAoQ2xpZW50IE1hbmFnZW1lbnQgU3lzdGVtKVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBDbXNBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCdDbGllbnQgbWFuYWdlbWVudCcpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcblxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxuICAgIHRoaXMuYXBwLm1vZGVsLmN1c3RvbWVycy5zeW5jKClcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIHRoZSBjbGllbnRzIGxpc3QnLFxuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxudmFyIG51bWVyYWwgPSByZXF1aXJlKCdudW1lcmFsJyk7XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLmNsaWVudHMgPSBhcHAubW9kZWwuY3VzdG9tZXJzLmxpc3Q7XG5cbiAgICB0aGlzLmNsaWVudHNDb3VudCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jbGllbnRzKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3MgPD0gMClcbiAgICAgICAgICAgIHJldHVybiAnMCBjbGllbnRzJztcbiAgICAgICAgZWxzZSBpZiAoY3MgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gJzEgY2xpZW50JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwoY3MubGVuZ3RoIHwwKS5mb3JtYXQoJzAsMCcpICsgJyBjbGllbnRzJztcbiAgICB9LCB0aGlzKTtcbn1cbiIsIi8qKlxuICAgIENvbnRhY3RGb3JtIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ29udGFjdEZvcm1BY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCgpO1xuICAgIFxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xuICAgIFxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignVGFsayB0byB1cycpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcbiAgICBcbiAgICB0aGlzLm1lc3NhZ2UgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICB0aGlzLndhc1NlbnQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuICAgIHZhciB1cGRhdGVXYXNTZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud2FzU2VudChmYWxzZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZS5zdWJzY3JpYmUodXBkYXRlV2FzU2VudCk7XG4gICAgXG4gICAgdGhpcy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgICAgLy8gVE9ETzogU2VuZFxuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgYWZ0ZXIgYmVpbmcgc2VudFxuICAgICAgICB0aGlzLm1lc3NhZ2UoJycpO1xuICAgICAgICB0aGlzLndhc1NlbnQodHJ1ZSk7XG5cbiAgICB9LmJpbmQodGhpcyk7XG59XG4iLCIvKipcclxuICAgIENvbnRhY3RJbmZvIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ29udGFjdEluZm9BY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICBcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignT3duZXIgaW5mb3JtYXRpb24nLCB7XHJcbiAgICAgICAgYmFja0xpbms6ICdvd25lckluZm8nXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIG5hdkJhciBmb3Igb25ib2FyZGluZyBtb2RlIHdoZW4gdGhlIG9uYm9hcmRpbmdTdGVwXHJcbiAgICAvLyBpbiB0aGUgY3VycmVudCBtb2RlbCBjaGFuZ2VzOlxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwucHJvZmlsZS5vbmJvYXJkaW5nU3RlcCxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgICAgICBpZiAoc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBTZXQgbmF2YmFyIHN0ZXAgaW5kZXhcclxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgbmF2YmFyIGZvciBPbmJvYXJkaW5nL3dpemFyZCBtb2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCgnJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyVGV4dCgnSG93IGNhbiB3ZSByZWFjaCB5b3U/Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5idXR0b25UZXh0KCdTYXZlIGFuZCBjb250aW51ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBSZW1vdmUgc3RlcCBpbmRleFxyXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBuYXZiYXIgdG8gZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLnRleHQoJ0FjY291bnQnKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgaGVhZGVyIHRvIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlclRleHQoJ0NvbnRhY3QgaW5mb3JtYXRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmJ1dHRvblRleHQoJ1NhdmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICAvL3RoaXMudmlld01vZGVsLnByb2ZpbGUub25ib2FyZGluZ1N0ZXAuc3Vic2NyaWJlKCk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLnVzZXJQcm9maWxlLFxyXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgY29udGFjdCBkYXRhLicgOiAnRXJyb3IgbG9hZGluZyBjb250YWN0IGRhdGEuJztcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLmhvbWVBZGRyZXNzLFxyXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgYWRkcmVzcyBkZXRhaWxzLicgOiAnRXJyb3IgbG9hZGluZyBhZGRyZXNzIGRldGFpbHMuJztcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIE9uIGNoYW5nZSB0byBhIHZhbGlkIGNvZGUsIGRvIHJlbW90ZSBsb29rLXVwXHJcbiAgICAvLyBOT1RFOiB1c2luZyBkaXJlY3RseSBhIGNvbXB1dGVkIHJhdGhlciB0aGFuIHRoZSByZWdpc3RlckhhbmRsZXIgdG8gdXNlXHJcbiAgICAvLyB0aGUgcmF0ZUxpbWl0IGV4dGVuZGVyIHRoYXQgYXZvaWRzIGV4Y2VzaXZlIHJlcXVlc3QgYmVpbmcgcGVyZm9ybWVkIG9uIGNoYW5nZXMuXHJcbiAgICAvLyBOT1RFOiB0aGUgY29kZSBpbnNpZGUgdGhlIGhhbmRsZXIgaXMgbW9zdGx5IHRoZSBzYW1lIGFzIGluIGFkZHJlc3NFZGl0b3IgZm9yIHRoZSBzYW1lIGxvb2stdXAuXHJcbiAgICB2YXIgYXBwID0gdGhpcy5hcHAsXHJcbiAgICAgICAgdmlld01vZGVsID0gdGhpcy52aWV3TW9kZWw7XHJcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcG9zdGFsQ29kZSA9IHRoaXMucG9zdGFsQ29kZSgpLFxyXG4gICAgICAgICAgICBhZGRyZXNzID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKHBvc3RhbENvZGUgJiYgIS9eXFxzKiQvLnRlc3QocG9zdGFsQ29kZSkpIHtcclxuICAgICAgICAgICAgYXBwLm1vZGVsLnBvc3RhbENvZGVzLmdldEl0ZW0ocG9zdGFsQ29kZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmNpdHkoaW5mby5jaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VDb2RlKGluZm8uc3RhdGVQcm92aW5jZUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoaW5mby5zdGF0ZVByb3ZpbmNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmVycm9yTWVzc2FnZXMucG9zdGFsQ29kZSgnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3MuY2l0eSgnJyk7XHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VDb2RlKCcnKTtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoJycpO1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0ZWQgZXJyb3JzLCBhIHNpbmdsZSBtZXNzYWdlLCBzZXRcclxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBvYnNlcnZhYmxlXHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gdHlwZW9mKGVycikgPT09ICdzdHJpbmcnID8gZXJyIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChtc2cgfHwgZXJyICYmIGVyci5yZXNwb25zZUpTT04gJiYgZXJyLnJlc3BvbnNlSlNPTi5lcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwuZXJyb3JNZXNzYWdlcy5wb3N0YWxDb2RlKG1zZyB8fCBlcnIucmVzcG9uc2VKU09OLmVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgdG8gY29uc29sZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLCBvbiByZWd1bGFyIHVzZSBhbiBlcnJvciBvbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3N0YWwgY29kZSBpcyBub3QgY3JpdGljYWwgYW5kIGNhbiBiZSB0cmFuc3BhcmVudDsgaWYgdGhlcmUgYXJlIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpdml0eSBvciBhdXRoZW50aWZpY2F0aW9uIGVycm9ycyB3aWxsIHRocm93IG9uIHNhdmluZyB0aGUgYWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZlciBlcnJvciB2YWxpZGF0aW5nIFppcCBDb2RlJywgZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcy52aWV3TW9kZWwuYWRkcmVzcylcclxuICAgIC8vIEF2b2lkIGV4Y2Vzc2l2ZSByZXF1ZXN0cyBieSBzZXR0aW5nIGEgdGltZW91dCBzaW5jZSB0aGUgbGF0ZXN0IGNoYW5nZVxyXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyB0aW1lb3V0OiAyMDAsIG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcgfSB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcbiAgICBcclxuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxyXG4gICAgdGhpcy52aWV3TW9kZWwuZGlzY2FyZCgpO1xyXG4gICAgXHJcbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcclxuICAgIHRoaXMuYXBwLm1vZGVsLnVzZXJQcm9maWxlLnN5bmMoKTtcclxuICAgIHRoaXMuYXBwLm1vZGVsLmhvbWVBZGRyZXNzLnN5bmMoKTtcclxufTtcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcblxyXG4gICAgdGhpcy5oZWFkZXJUZXh0ID0ga28ub2JzZXJ2YWJsZSgnQ29udGFjdCBpbmZvcm1hdGlvbicpO1xyXG4gICAgdGhpcy5idXR0b25UZXh0ID0ga28ub2JzZXJ2YWJsZSgnU2F2ZScpO1xyXG4gICAgXHJcbiAgICAvLyBMaXN0IG9mIHBvc3NpYmxlIGVycm9yIG1lc3NhZ2VzIHJlZ2lzdGVyZWRcclxuICAgIC8vIGJ5IG5hbWVcclxuICAgIHRoaXMuZXJyb3JNZXNzYWdlcyA9IHtcclxuICAgICAgICBwb3N0YWxDb2RlOiBrby5vYnNlcnZhYmxlKCcnKVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gVXNlciBQcm9maWxlXHJcbiAgICB2YXIgdXNlclByb2ZpbGUgPSBhcHAubW9kZWwudXNlclByb2ZpbGU7XHJcbiAgICB2YXIgcHJvZmlsZVZlcnNpb24gPSB1c2VyUHJvZmlsZS5uZXdWZXJzaW9uKCk7XHJcbiAgICBwcm9maWxlVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XHJcbiAgICAgICAgaWYgKGl0SXMpIHtcclxuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xyXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXHJcbiAgICAgICAgICAgIC8vIGNvbmZpcm1hdGlvbiB0byBsb2FkIHRoZW0gb3IgZGlzY2FyZCBhbmQgb3ZlcndyaXRlIHRoZW07XHJcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIHNlcnZlciB2ZXJzaW9uKS5cclxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxyXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcclxuICAgICAgICAgICAgcHJvZmlsZVZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XHJcbiAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlVmVyc2lvbi52ZXJzaW9uO1xyXG4gICAgXHJcbiAgICAvLyBUT0RPIGwxMG5cclxuICAgIHRoaXMubW9udGhzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtcclxuICAgICAgICB7IGlkOiAxLCBuYW1lOiAnSmFudWFyeSd9LFxyXG4gICAgICAgIHsgaWQ6IDIsIG5hbWU6ICdGZWJydWFyeSd9LFxyXG4gICAgICAgIHsgaWQ6IDMsIG5hbWU6ICdNYXJjaCd9LFxyXG4gICAgICAgIHsgaWQ6IDQsIG5hbWU6ICdBcHJpbCd9LFxyXG4gICAgICAgIHsgaWQ6IDUsIG5hbWU6ICdNYXknfSxcclxuICAgICAgICB7IGlkOiA2LCBuYW1lOiAnSnVuZSd9LFxyXG4gICAgICAgIHsgaWQ6IDcsIG5hbWU6ICdKdWx5J30sXHJcbiAgICAgICAgeyBpZDogOCwgbmFtZTogJ0F1Z3VzdCd9LFxyXG4gICAgICAgIHsgaWQ6IDksIG5hbWU6ICdTZXB0ZW1iZXInfSxcclxuICAgICAgICB7IGlkOiAxMCwgbmFtZTogJ09jdG9iZXInfSxcclxuICAgICAgICB7IGlkOiAxMSwgbmFtZTogJ05vdmVtYmVyJ30sXHJcbiAgICAgICAgeyBpZDogMTIsIG5hbWU6ICdEZWNlbWJlcid9XHJcbiAgICBdKTtcclxuICAgIC8vIFdlIG5lZWQgdG8gdXNlIGEgc3BlY2lhbCBvYnNlcnZhYmxlIGluIHRoZSBmb3JtLCB0aGF0IHdpbGxcclxuICAgIC8vIHVwZGF0ZSB0aGUgYmFjay1lbmQgcHJvZmlsZS5iaXJ0aE1vbnRoXHJcbiAgICB0aGlzLnNlbGVjdGVkQmlydGhNb250aCA9IGtvLmNvbXB1dGVkKHtcclxuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGJpcnRoTW9udGggPSB0aGlzLnByb2ZpbGUuYmlydGhNb250aCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmlydGhNb250aCA/IHRoaXMubW9udGhzKClbYmlydGhNb250aCAtIDFdIDogbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbihtb250aCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2ZpbGUuYmlydGhNb250aChtb250aCAmJiBtb250aC5pZCB8fCBudWxsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5tb250aERheXMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG4gICAgZm9yICh2YXIgaWRheSA9IDE7IGlkYXkgPD0gMzE7IGlkYXkrKykge1xyXG4gICAgICAgIHRoaXMubW9udGhEYXlzLnB1c2goaWRheSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEhvbWUgQWRkcmVzc1xyXG4gICAgdmFyIGhvbWVBZGRyZXNzID0gYXBwLm1vZGVsLmhvbWVBZGRyZXNzO1xyXG4gICAgdmFyIGhvbWVBZGRyZXNzVmVyc2lvbiA9IGhvbWVBZGRyZXNzLm5ld1ZlcnNpb24oKTtcclxuICAgIGhvbWVBZGRyZXNzVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XHJcbiAgICAgICAgaWYgKGl0SXMpIHtcclxuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xyXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXHJcbiAgICAgICAgICAgIC8vIGNvbmZpcm1hdGlvbiB0byBsb2FkIHRoZW0gb3IgZGlzY2FyZCBhbmQgb3ZlcndyaXRlIHRoZW07XHJcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIHNlcnZlciB2ZXJzaW9uKS5cclxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxyXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcclxuICAgICAgICAgICAgaG9tZUFkZHJlc3NWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQWN0dWFsIGRhdGEgZm9yIHRoZSBmb3JtOlxyXG4gICAgdGhpcy5hZGRyZXNzID0gaG9tZUFkZHJlc3NWZXJzaW9uLnZlcnNpb247XHJcblxyXG4gICAgLy8gQ29udHJvbCBvYnNlcnZhYmxlczogc3BlY2lhbCBiZWNhdXNlIG11c3QgYSBtaXhcclxuICAgIC8vIG9mIHRoZSBib3RoIHJlbW90ZSBtb2RlbHMgdXNlZCBpbiB0aGlzIHZpZXdtb2RlbFxyXG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB1c2VyUHJvZmlsZS5pc0xvY2tlZCgpIHx8IGhvbWVBZGRyZXNzLmlzTG9ja2VkKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLmlzTG9hZGluZygpIHx8IGhvbWVBZGRyZXNzLmlzTG9hZGluZygpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICB0aGlzLmlzU2F2aW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLmlzU2F2aW5nKCkgfHwgaG9tZUFkZHJlc3MuaXNTYXZpbmcoKTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXHJcbiAgICAgICAgICAgICAgICAnbG9hZGluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgICAgICdzYXZpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBBY3Rpb25zXHJcblxyXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcclxuICAgICAgICBwcm9maWxlVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgaG9tZUFkZHJlc3NWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xyXG4gICAgICAgIC8vIEZvcmNlIHRvIHNhdmUsIGV2ZW4gaWYgdGhlcmUgd2FzIHJlbW90ZSB1cGRhdGVzXHJcbiAgICAgICAgcHJvZmlsZVZlcnNpb24ucHVzaCh7IGV2ZW5JZk9ic29sZXRlOiB0cnVlIH0pO1xyXG4gICAgICAgIGhvbWVBZGRyZXNzVmVyc2lvbi5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXBwLnN1Y2Nlc3NTYXZlKCk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn1cclxuIiwiLyoqXG4gICAgQ29udmVyc2F0aW9uIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ29udmVyc2F0aW9uQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIFxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xuICAgIFxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignSW5ib3gnLCB7XG4gICAgICAgIGJhY2tMaW5rOiAnaW5ib3gnXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLnZpZXdNb2RlbC50aHJlYWRJRCgwKTtcbiAgICB0aGlzLnZpZXdNb2RlbC50aHJlYWQobnVsbCk7XG5cbiAgICAvLyBQYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gc3RhdGUgJiYgc3RhdGUucm91dGUgJiYgc3RhdGUucm91dGUuc2VnbWVudHMgfHwgW10sXG4gICAgICAgIHRocmVhZElEID0gcGFyYW1zWzBdIHwwO1xuXG4gICAgdGhpcy52aWV3TW9kZWwudGhyZWFkSUQodGhyZWFkSUQpO1xuICAgIFxuICAgIC8vIExvYWQgdGhlIGRhdGFcbiAgICBpZiAodGhyZWFkSUQpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwudGhyZWFkLnN5bmModGhyZWFkSUQpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgbG9hZGluZyBjb252ZXJzYXRpb24nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICB0aXRsZTogJ0NvbnZlcnNhdGlvbiBOb3QgRm91bmQnXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2soKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5tZXNzYWdpbmcuc3RhdGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5zdGF0ZS5pc1N5bmNpbmc7XG4gICAgdGhpcy5pc1NhdmluZyA9IGFwcC5tb2RlbC5tZXNzYWdpbmcuc3RhdGUuaXNTYXZpbmc7XG5cbiAgICB0aGlzLnRocmVhZElEID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICB0aGlzLnRocmVhZCA9IGFwcC5tb2RlbC5tZXNzYWdpbmcuY3JlYXRlV2lsZGNhcmRJdGVtKCk7XG5cbiAgICB0aGlzLnN1YmplY3QgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50aHJlYWQoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgP1xuICAgICAgICAgICAgICAgICdMb2FkaW5nLi4uJyA6XG4gICAgICAgICAgICAgICAgbSAmJiAobS5zdWJqZWN0KCkgfHwgJycpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSB8fCAnQ29udmVyc2F0aW9uIHdpdGhvdXQgc3ViamVjdCdcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICAvLyBJZiB0aGUgbGFzdCBtZXNzYWdlIHJlZmVyZW5jZSBhIGJvb2tpbmcsIGlzXG4gICAgLy8gYWNjZXNzZWQgd2l0aDpcbiAgICB0aGlzLmJvb2tpbmdJRCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IHRoaXMudGhyZWFkKCkgJiYgdGhpcy50aHJlYWQoKS5tZXNzYWdlcygpWzBdO1xuICAgICAgICBpZiAobXNnICYmXG4gICAgICAgICAgICAobXNnLmF1eFQoKSB8fCAnJykudG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2tpbmcnICYmXG4gICAgICAgICAgICBtc2cuYXV4SUQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZy5hdXhJRCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn1cbiIsIi8qKlxyXG4gICAgZGF0ZXRpbWVQaWNrZXIgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIFRpbWUgPSByZXF1aXJlKCcuLi91dGlscy9UaW1lJyk7XHJcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvRGF0ZVBpY2tlcicpO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIERhdGV0aW1lUGlja2VyQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCcnKTtcclxuICAgIFxyXG4gICAgLy8gR2V0dGluZyBlbGVtZW50c1xyXG4gICAgdGhpcy4kZGF0ZVBpY2tlciA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNkYXRldGltZVBpY2tlckRhdGVQaWNrZXInKTtcclxuICAgIHRoaXMuJHRpbWVQaWNrZXIgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjZGF0ZXRpbWVQaWNrZXJUaW1lUGlja2VyJyk7XHJcbiAgICBcclxuICAgIC8qIEluaXQgY29tcG9uZW50cyAqL1xyXG4gICAgdGhpcy4kZGF0ZVBpY2tlci5zaG93KCkuZGF0ZXBpY2tlcigpO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRkYXRlUGlja2VyLFxyXG4gICAgICAgIGV2ZW50OiAnY2hhbmdlRGF0ZScsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBpZiAoZS52aWV3TW9kZSA9PT0gJ2RheXMnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5zZWxlY3RlZERhdGUoZS5kYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLnNlbGVjdGVkRGF0ZSxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZERhdGVEYXRhKGRhdGUpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZXIgdG8gZ28gYmFjayB3aXRoIHRoZSBzZWxlY3RlZCBkYXRlLXRpbWUgd2hlblxyXG4gICAgLy8gdGhhdCBzZWxlY3Rpb24gaXMgZG9uZSAoY291bGQgYmUgdG8gbnVsbClcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLnNlbGVjdGVkRGF0ZXRpbWUsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGRhdGV0aW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXF1ZXN0RGF0YSB8fFxyXG4gICAgICAgICAgICAgICAgIWRhdGV0aW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgc2VsZWN0ZWQgZGF0ZXRpbWUgaW4gdGhlIGluZm9cclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZERhdGV0aW1lID0gZGF0ZXRpbWU7XHJcbiAgICAgICAgICAgIC8vIEFuZCBnbyBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgICAgICAgICAgLy8gTGFzdCwgY2xlYXIgcmVxdWVzdERhdGFcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YSA9IG51bGw7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVGVzdGluZ0RhdGFcclxuICAgIHRoaXMudmlld01vZGVsLnNsb3RzRGF0YSA9IHJlcXVpcmUoJy4uL3Rlc3RkYXRhL3RpbWVTbG90cycpLnRpbWVTbG90cztcclxuICAgIFxyXG4gICAgdGhpcy5iaW5kRGF0ZURhdGEobmV3IERhdGUoKSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG5cclxuICAgIHZhciBoZWFkZXIgPSB0aGlzLnJlcXVlc3REYXRhLmhlYWRlclRleHQ7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXJUZXh0KGhlYWRlciB8fCAnU2VsZWN0IGRhdGUgYW5kIHRpbWUnKTtcclxufTtcclxuXHJcbkEucHJvdG90eXBlLmJpbmREYXRlRGF0YSA9IGZ1bmN0aW9uIGJpbmREYXRlRGF0YShkYXRlKSB7XHJcblxyXG4gICAgdmFyIHNkYXRlID0gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xyXG4gICAgdmFyIHNsb3RzRGF0YSA9IHRoaXMudmlld01vZGVsLnNsb3RzRGF0YTtcclxuXHJcbiAgICBpZiAoc2xvdHNEYXRhLmhhc093blByb3BlcnR5KHNkYXRlKSkge1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLnNsb3RzKHNsb3RzRGF0YVtzZGF0ZV0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5zbG90cyhzbG90c0RhdGFbJ2RlZmF1bHQnXSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoKSB7XHJcblxyXG4gICAgdGhpcy5oZWFkZXJUZXh0ID0ga28ub2JzZXJ2YWJsZSgnU2VsZWN0IGEgdGltZScpO1xyXG4gICAgdGhpcy5zZWxlY3RlZERhdGUgPSBrby5vYnNlcnZhYmxlKG5ldyBEYXRlKCkpO1xyXG4gICAgdGhpcy5zbG90c0RhdGEgPSB7fTtcclxuICAgIHRoaXMuc2xvdHMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG4gICAgdGhpcy5ncm91cGVkU2xvdHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpe1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICBiZWZvcmUgMTI6MDBwbSAobm9vbikgPSBtb3JuaW5nXHJcbiAgICAgICAgICBhZnRlcm5vb246IDEyOjAwcG0gdW50aWwgNTowMHBtXHJcbiAgICAgICAgICBldmVuaW5nOiA1OjAwcG0gLSAxMTo1OXBtXHJcbiAgICAgICAgKi9cclxuICAgICAgICAvLyBTaW5jZSBzbG90cyBtdXN0IGJlIGZvciB0aGUgc2FtZSBkYXRlLFxyXG4gICAgICAgIC8vIHRvIGRlZmluZSB0aGUgZ3JvdXBzIHJhbmdlcyB1c2UgdGhlIGZpcnN0IGRhdGVcclxuICAgICAgICB2YXIgZGF0ZVBhcnQgPSB0aGlzLnNsb3RzKCkgJiYgdGhpcy5zbG90cygpWzBdIHx8IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdNb3JuaW5nJyxcclxuICAgICAgICAgICAgICAgIHNsb3RzOiBbXSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0czogbmV3IFRpbWUoZGF0ZVBhcnQsIDAsIDApLFxyXG4gICAgICAgICAgICAgICAgZW5kczogbmV3IFRpbWUoZGF0ZVBhcnQsIDEyLCAwKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBncm91cDogJ0FmdGVybm9vbicsXHJcbiAgICAgICAgICAgICAgICBzbG90czogW10sXHJcbiAgICAgICAgICAgICAgICBzdGFydHM6IG5ldyBUaW1lKGRhdGVQYXJ0LCAxMiwgMCksXHJcbiAgICAgICAgICAgICAgICBlbmRzOiBuZXcgVGltZShkYXRlUGFydCwgMTcsIDApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwOiAnRXZlbmluZycsXHJcbiAgICAgICAgICAgICAgICBzbG90czogW10sXHJcbiAgICAgICAgICAgICAgICBzdGFydHM6IG5ldyBUaW1lKGRhdGVQYXJ0LCAxNywgMCksXHJcbiAgICAgICAgICAgICAgICBlbmRzOiBuZXcgVGltZShkYXRlUGFydCwgMjQsIDApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgICAgIC8vIFRPRE8gRW1wdHkgc2xvdHMgbXVzdCBhcHBlYXIgd2l0aFxyXG4gICAgICAgIC8vICdlbXB0eScgbWVzc2FnZSByYXRoZXIgdGhhbiBleGNsdWRlZFxyXG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHMoKS5zb3J0KCk7XHJcbiAgICAgICAgc2xvdHMuZm9yRWFjaChmdW5jdGlvbihzbG90KSB7XHJcbiAgICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdCA+PSBncm91cC5zdGFydHMgJiZcclxuICAgICAgICAgICAgICAgICAgICBzbG90IDwgZ3JvdXAuZW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnNsb3RzLnB1c2goc2xvdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xyXG5cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNlbGVjdGVkRGF0ZXRpbWUgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNlbGVjdERhdGV0aW1lID0gZnVuY3Rpb24oc2VsZWN0ZWREYXRldGltZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRldGltZShzZWxlY3RlZERhdGV0aW1lKTtcclxuXHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG59XHJcbiIsIi8qKlxuICAgIEZhcXMgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBGYXFzQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwoKTtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1RhbGsgdG8gdXMnKTtcbiAgICBcbiAgICAvLyBUZXN0aW5nRGF0YVxuICAgIHNldFNvbWVUZXN0aW5nRGF0YSh0aGlzLnZpZXdNb2RlbCk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIFxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsLnNlYXJjaFRleHQoJycpO1xufTtcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZnVuY3Rpb24gVmlld01vZGVsKCkge1xuXG4gICAgdGhpcy5mYXFzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbiAgICB0aGlzLnNlYXJjaFRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICBcbiAgICB0aGlzLmZpbHRlcmVkRmFxcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXJjaFRleHQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mYXFzKCkuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciBuID0gdiAmJiB2LnRpdGxlKCkgfHwgJyc7XG4gICAgICAgICAgICBuICs9IHYgJiYgdi5kZXNjcmlwdGlvbigpIHx8ICcnO1xuICAgICAgICAgICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuLmluZGV4T2YocykgPiAtMTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpO1xuZnVuY3Rpb24gRmFxKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgaWQ6IDAsXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICcnXG4gICAgfSwgdmFsdWVzKTtcbn1cblxuLyoqIFRFU1RJTkcgREFUQSAqKi9cbmZ1bmN0aW9uIHNldFNvbWVUZXN0aW5nRGF0YSh2aWV3TW9kZWwpIHtcbiAgICBcbiAgICB2YXIgdGVzdGRhdGEgPSBbXG4gICAgICAgIG5ldyBGYXEoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICB0aXRsZTogJ0hvdyBkbyBJIHNldCB1cCBhIG1hcmtldHBsYWNlIHByb2ZpbGU/JyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRGVzY3JpcHRpb24gYWJvdXQgaG93IEkgc2V0IHVwIGEgbWFya2V0cGxhY2UgcHJvZmlsZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBGYXEoe1xuICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICB0aXRsZTogJ0Fub3RoZXIgZmFxJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQW5vdGhlciBkZXNjcmlwdGlvbidcbiAgICAgICAgfSlcbiAgICBdO1xuICAgIHZpZXdNb2RlbC5mYXFzKHRlc3RkYXRhKTtcbn1cbiIsIi8qKlxuICAgIEZlZWRiYWNrIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gRmVlZGJhY2tBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCdUYWxrIHRvIHVzJyk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuIiwiLyoqXG4gICAgRmVlZGJhY2tGb3JtIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gRmVlZGJhY2tGb3JtQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwoKTtcbiAgICBcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1RhbGsgdG8gdXMnKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5mdW5jdGlvbiBWaWV3TW9kZWwoKSB7XG4gICAgXG4gICAgdGhpcy5tZXNzYWdlID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgdGhpcy5iZWNvbWVDb2xsYWJvcmF0b3IgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLndhc1NlbnQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuICAgIHZhciB1cGRhdGVXYXNTZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud2FzU2VudChmYWxzZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZS5zdWJzY3JpYmUodXBkYXRlV2FzU2VudCk7XG4gICAgdGhpcy5iZWNvbWVDb2xsYWJvcmF0b3Iuc3Vic2NyaWJlKHVwZGF0ZVdhc1NlbnQpO1xuICAgIFxuICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICAgIC8vIFRPRE86IFNlbmRcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGFmdGVyIGJlaW5nIHNlbnRcbiAgICAgICAgdGhpcy5tZXNzYWdlKCcnKTtcbiAgICAgICAgdGhpcy5iZWNvbWVDb2xsYWJvcmF0b3IoZmFsc2UpO1xuICAgICAgICB0aGlzLndhc1NlbnQodHJ1ZSk7XG5cbiAgICB9LmJpbmQodGhpcyk7XG59XG4iLCIvKipcclxuICAgIEZyZWVsYW5jZXIgUHJpY2luZyBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEZyZWVsYW5jZXJQcmljaW5nQWN0aXZpdHkoKSB7XHJcblxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0pvYiBUaXRsZScpO1xyXG5cclxuICAgIC8vIE9uIGNoYW5naW5nIGpvYlRpdGxlSUQ6XHJcbiAgICAvLyAtIGxvYWQgcHJpY2luZ1xyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgICAgIGlmIChqb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgZGF0YSBmb3IgdGhlIEpvYiB0aXRsZSBJRCBhbmQgcHJpY2luZyB0eXBlcy5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXkgYXJlIGVzc2VudGlhbCBkYXRhXHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwuam9iVGl0bGVzLmdldEpvYlRpdGxlKGpvYlRpdGxlSUQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRMaXN0KClcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpvYlRpdGxlID0gZGF0YVswXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGwgaW4gam9iIHRpdGxlIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLnRleHQoam9iVGl0bGUuc2luZ3VsYXJOYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIGZvciB1c2UgaW4gdGhlIHZpZXdcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZShqb2JUaXRsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBwcmljaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLmdldExpc3Qoam9iVGl0bGVJRCk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLmFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5hc01vZGVsKGxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgcHJlc2V0cyBzZWxlY3Rpb24gZnJvbSByZXF1ZXN0RGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVzZXQgPSB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkUHJpY2luZyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRQcmljaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgaXNTZWxlY3RlZCBwcm9wZXJ0eSB0byBlYWNoIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlU2VsZWN0ZWQgPSBwcmVzZXQuc29tZShmdW5jdGlvbihwcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByLmZyZWVsYW5jZXJQcmljaW5nSUQgPT09IGl0ZW0uZnJlZWxhbmNlclByaWNpbmdJRCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaXNTZWxlY3RlZCA9IGtvLm9ic2VydmFibGUocHJlU2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZVNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxpc3QobGlzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZy4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwubGlzdChbXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KCdKb2IgVGl0bGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZXIgdG8gdXBkYXRlIGhlYWRlciBiYXNlZCBvbiBhIG1vZGUgY2hhbmdlOlxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuaXNTZWxlY3Rpb25Nb2RlLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChpdElzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlclRleHQoaXRJcyA/ICdTZWxlY3Qgc2VydmljZXMnIDogJ1NlcnZpY2VzJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgbmF2YmFyIHRvb1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBDYW4gYmUgb3RoZXIgdGhhbiAnc2NoZWR1bGluZycsIGxpa2UgbWFya2V0cGxhY2UgcHJvZmlsZSBvciB0aGUgam9iLXRpdGxlP1xyXG4gICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dChpdElzID8gJ0Jvb2tpbmcnIDogJ1NjaGVkdWxpbmcnKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLnByb2dyZXNzU3RlcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aXRsZSBieSBwcm9jZXNzIHN0ZXAgaWYgcmVxdWlyZWRcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKHRoaXMucmVxdWVzdERhdGEucHJvZ3Jlc3NTdGVwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KCcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRpdGxlIG11c3QgYmUgZW1wdHlcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKCcnKTtcclxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gR28gYmFjayB3aXRoIHRoZSBzZWxlY3RlZCBwcmljaW5nIHdoZW4gdHJpZ2dlcmVkIGluIHRoZSBmb3JtL3ZpZXdcclxuICAgIHRoaXMudmlld01vZGVsLnJldHVyblNlbGVjdGVkID0gZnVuY3Rpb24ocHJpY2luZywgam9iVGl0bGVJRCkge1xyXG4gICAgICAgIC8vIFBhc3MgdGhlIHNlbGVjdGVkIGNsaWVudCBpbiB0aGUgaW5mb1xyXG4gICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRQcmljaW5nID0gcHJpY2luZztcclxuICAgICAgICB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkSm9iVGl0bGVJRCA9IGpvYlRpdGxlSUQ7XHJcbiAgICAgICAgLy8gQW5kIGdvIGJhY2tcclxuICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgLy8gUmVzZXQ6IGF2b2lkaW5nIGVycm9ycyBiZWNhdXNlIHBlcnNpc3RlZCBkYXRhIGZvciBkaWZmZXJlbnQgSUQgb24gbG9hZGluZ1xyXG4gICAgLy8gb3Igb3V0ZGF0ZWQgaW5mbyBmb3JjaW5nIHVwZGF0ZVxyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCgwKTtcclxuICAgIHRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZShmYWxzZSk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5zZWxlY3RlZFByaWNpbmcucmVtb3ZlQWxsKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEuc2VsZWN0UHJpY2luZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZSh0cnVlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUGFyYW1zXHJcbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHM7XHJcbiAgICB2YXIgam9iVGl0bGVJRCA9IHBhcmFtc1swXSB8MDtcclxuICAgIFxyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRChqb2JUaXRsZUlEKTtcclxuICAgIFxyXG4gICAgaWYgKGpvYlRpdGxlSUQgPT09IDApIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZXMuc3luYygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIFVzZXJKb2JQcm9maWxlID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9Vc2VySm9iUHJvZmlsZScpO1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHRoaXMuaGVhZGVyVGV4dCA9IGtvLm9ic2VydmFibGUoJ1NlcnZpY2VzJyk7XHJcbiAgICBcclxuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XHJcbiAgICB0aGlzLmpvYlRpdGxlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcclxuICAgIFxyXG4gICAgdGhpcy5qb2JUaXRsZXMgPSBuZXcgVXNlckpvYlByb2ZpbGUoYXBwKTtcclxuICAgIHRoaXMuam9iVGl0bGVzLmJhc2VVcmwoJy9mcmVlbGFuY2VyUHJpY2luZycpO1xyXG4gICAgdGhpcy5qb2JUaXRsZXMuc2VsZWN0Sm9iVGl0bGUgPSBmdW5jdGlvbihqb2JUaXRsZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuam9iVGl0bGVJRChqb2JUaXRsZS5qb2JUaXRsZUlEKCkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmxpc3QgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG5cclxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLnN0YXRlLmlzTG9hZGluZygpIHx8XHJcbiAgICAgICAgICAgIGFwcC5tb2RlbC5wcmljaW5nVHlwZXMuc3RhdGUuaXNMb2FkaW5nKCkgfHxcclxuICAgICAgICAgICAgYXBwLm1vZGVsLmpvYlRpdGxlcy5zdGF0ZS5pc0xvYWRpbmcoKVxyXG4gICAgICAgICk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaXNMb2NrZWQgPSB0aGlzLmlzTG9hZGluZztcclxuXHJcbiAgICAvLyBFc3BlY2lhbCBtb2RlIHdoZW4gaW5zdGVhZCBvZiBwaWNrIGFuZCBlZGl0IHdlIGFyZSBqdXN0IHNlbGVjdGluZ1xyXG4gICAgdGhpcy5pc1NlbGVjdGlvbk1vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2VsZWN0aW9uTW9kZSgpID8gXHJcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUgYW5kIGNvbnRpbnVlJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJydcclxuICAgICAgICApO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIC8vIEdyb3VwZWQgbGlzdCBvZiBwcmljaW5nczpcclxuICAgIC8vIERlZmluZWQgZ3JvdXBzIGJ5IHByaWNpbmcgdHlwZVxyXG4gICAgdGhpcy5ncm91cGVkUHJpY2luZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0KCk7XHJcbiAgICAgICAgdmFyIGlzU2VsZWN0aW9uID0gdGhpcy5pc1NlbGVjdGlvbk1vZGUoKTtcclxuICAgICAgICB2YXIgZ3JvdXBOYW1lUHJlZml4ID0gaXNTZWxlY3Rpb24gPyAnU2VsZWN0ICcgOiAnJztcclxuXHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IF8uZ3JvdXBCeShsaXN0LCBmdW5jdGlvbihwcmljaW5nSXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpY2luZ0l0ZW0ucHJpY2luZ1R5cGVJRCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGluZGV4ZWQgb2JqZWN0IGludG8gYW4gYXJyYXkgd2l0aCBzb21lIG1ldGEtZGF0YVxyXG4gICAgICAgIHZhciBncm91cHNMaXN0ID0gT2JqZWN0LmtleXMoZ3JvdXBzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBnciA9IHtcclxuICAgICAgICAgICAgICAgIHByaWNpbmc6IGdyb3Vwc1trZXldLFxyXG4gICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgcHJpY2luZyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgdHlwZTogYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRPYnNlcnZhYmxlSXRlbShrZXkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGdyLmdyb3VwID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBOYW1lUHJlZml4ICsgKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSgpICYmIHRoaXMudHlwZSgpLnBsdXJhbE5hbWUoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICdTZXJ2aWNlcydcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0sIGdyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNpbmNlIHRoZSBncm91cHNMaXN0IGlzIGJ1aWx0IGZyb20gdGhlIGV4aXN0ZW50IHByaWNpbmcgaXRlbXNcclxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmVjb3JkcyBmb3Igc29tZSBwcmljaW5nIHR5cGUgKG9yIG5vdGhpbmcgd2hlblxyXG4gICAgICAgIC8vIGp1c3QgY3JlYXRlZCB0aGUgam9iIHRpdGxlKSwgdGhhdCB0eXBlcy9ncm91cHMgYXJlIG5vdCBpbmNsdWRlZCxcclxuICAgICAgICAvLyBzbyByZXZpZXcgYW5kIGluY2x1ZGUgbm93LlxyXG4gICAgICAgIC8vIE5PVEU6IGFzIGEgZ29vZCBzaWRlIGVmZmVjdCBvZiB0aGlzIGFwcHJvYWNoLCBwcmljaW5nIHR5cGVzIHdpdGhcclxuICAgICAgICAvLyBzb21lIHByaWNpbmcgd2lsbCBhcHBlYXIgZmlyc3QgaW4gdGhlIGxpc3QgKG5lYXJlc3QgdG8gdGhlIHRvcClcclxuICAgICAgICB2YXIgcHJpY2luZ1R5cGVzID0gdGhpcy5qb2JUaXRsZSgpICYmIHRoaXMuam9iVGl0bGUoKS5wcmljaW5nVHlwZXMoKTtcclxuICAgICAgICBpZiAocHJpY2luZ1R5cGVzICYmIHByaWNpbmdUeXBlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcHJpY2luZ1R5cGVzLmZvckVhY2goZnVuY3Rpb24gKGpvYlR5cGUpIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVJRCA9IGpvYlR5cGUucHJpY2luZ1R5cGVJRCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90IGlmIGFscmVhZHkgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIGlmIChncm91cHMuaGFzT3duUHJvcGVydHkodHlwZUlEKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaWNpbmc6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcC5tb2RlbC5wcmljaW5nVHlwZXMuZ2V0T2JzZXJ2YWJsZUl0ZW0odHlwZUlEKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGdyLmdyb3VwID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwTmFtZVByZWZpeCArIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlKCkgJiYgdGhpcy50eXBlKCkucGx1cmFsTmFtZSgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZXJ2aWNlcydcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSwgZ3IpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdyb3Vwc0xpc3QucHVzaChncik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdyb3Vwc0xpc3Q7XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5zZWxlY3RlZFByaWNpbmcgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG4gICAgLyoqXHJcbiAgICAgICAgVG9nZ2xlIHRoZSBzZWxlY3Rpb24gc3RhdHVzIG9mIGEgcHJpY2luZywgYWRkaW5nXHJcbiAgICAgICAgb3IgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgJ3NlbGVjdGVkUHJpY2luZycgYXJyYXkuXHJcbiAgICAqKi9cclxuICAgIHRoaXMudG9nZ2xlUHJpY2luZ1NlbGVjdGlvbiA9IGZ1bmN0aW9uKHByaWNpbmcpIHtcclxuXHJcbiAgICAgICAgdmFyIGluSW5kZXggPSAtMSxcclxuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRQcmljaW5nKCkuc29tZShmdW5jdGlvbihzZWxlY3RlZFByaWNpbmcsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFByaWNpbmcgPT09IHByaWNpbmcpIHtcclxuICAgICAgICAgICAgICAgIGluSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHByaWNpbmcuaXNTZWxlY3RlZCghaXNTZWxlY3RlZCk7XHJcblxyXG4gICAgICAgIGlmIChpc1NlbGVjdGVkKVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUHJpY2luZy5zcGxpY2UoaW5JbmRleCwgMSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUHJpY2luZy5wdXNoKHByaWNpbmcpO1xyXG5cclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgRW5kcyB0aGUgc2VsZWN0aW9uIHByb2Nlc3MsIHJlYWR5IHRvIGNvbGxlY3Qgc2VsZWN0aW9uXHJcbiAgICAgICAgYW5kIHBhc3NpbmcgaXQgdG8gdGhlIHJlcXVlc3RlciBhY3Rpdml0eVxyXG4gICAgKiovXHJcbiAgICB0aGlzLmVuZFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaXNTZWxlY3Rpb25Nb2RlKGZhbHNlKTtcclxuICAgICAgICAvLyBSdW4gbWV0aG9kIGluamVjdGVkIGJ5IHRoZSBhY3Rpdml0eSB0byByZXR1cm4gYSBcclxuICAgICAgICAvLyBzZWxlY3RlZCBhZGRyZXNzOlxyXG4gICAgICAgIHRoaXMucmV0dXJuU2VsZWN0ZWQoXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRQcmljaW5nKCkubWFwKGZ1bmN0aW9uKHByaWNpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJlZWxhbmNlclByaWNpbmdJRDoga28udW53cmFwKHByaWNpbmcuZnJlZWxhbmNlclByaWNpbmdJRCksXHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxQcmljZToga28udW53cmFwKHByaWNpbmcucHJpY2UpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdGhpcy5qb2JUaXRsZUlEKClcclxuICAgICAgICApO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmVkaXRQcmljaW5nID0gZnVuY3Rpb24ocHJpY2luZykge1xyXG4gICAgICAgIGFwcC5zaGVsbC5nbygnZnJlZWxhbmNlclByaWNpbmdFZGl0b3IvJyArIHRoaXMuam9iVGl0bGVJRCgpICsgJy8nICsgcHJpY2luZy5mcmVlbGFuY2VyUHJpY2luZ0lEKCkpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBIYW5kbGVyIGZvciB0aGUgbGlzdHZpZXcgaXRlbXMsIG1hbmFnaW5nIGVkaXRpb24gYW5kIHNlbGVjdGlvbiBkZXBlbmRpbmcgb24gY3VycmVudCBtb2RlXHJcbiAgICAqKi9cclxuICAgIHRoaXMudGFwUHJpY2luZyA9IGZ1bmN0aW9uKHByaWNpbmcpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGlvbk1vZGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVByaWNpbmdTZWxlY3Rpb24ocHJpY2luZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRQcmljaW5nKHByaWNpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKTtcclxufVxyXG4iLCIvKipcclxuICAgIEZyZWVsYW5jZXJQcmljaW5nRWRpdG9yIGFjdGl2aXR5XHJcbiAgICBcclxuICAgIFRPRE86IE1vZGVsVmVyc2lvbiBpcyBOT1QgYmVpbmcgdXNlZCwgc28gbm8gZ2V0dGluZyB1cGRhdGVzIGlmIHNlcnZlciB1cGRhdGVzXHJcbiAgICB0aGUgZGF0YSBhZnRlciBsb2FkIChkYXRhIGxvYWQgaXMgcmVxdWVzdGVkIGJ1dCBnZXQgZmlyc3QgZnJvbSBjYWNoZSkuIFVzZVxyXG4gICAgdmVyc2lvbiBhbmQgZ2V0IHN5bmMnZWQgZGF0YSB3aGVuIHJlYWR5LCBhbmQgYWRkaXRpb25hbGx5IG5vdGlmaWNhdGlvbiB0b1xyXG4gICAgb3ZlcnJpZGUgY2hhbmdlcyBpZiBzZXJ2ZXIgZGF0YSBpcyBkaWZmZXJlbnQgdGhhdCBhbnkgbG9jYWwgY2hhbmdlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXHJcbiAgICBQcmljaW5nVHlwZSA9IHJlcXVpcmUoJy4uL21vZGVscy9QcmljaW5nVHlwZScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEZyZWVsYW5jZXJQcmljaW5nRWRpdG9yQWN0aXZpdHkoKSB7XHJcblxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1NlcnZpY2VzJyk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xyXG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eToxMCAgICBcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gUmVzZXRcclxuICAgIHRoaXMudmlld01vZGVsLndhc1JlbW92ZWQoZmFsc2UpO1xyXG4gICAgdGhpcy52aWV3TW9kZWwuZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKG51bGwpO1xyXG4gICAgdGhpcy52aWV3TW9kZWwucHJpY2luZ1R5cGUobnVsbCk7XHJcblxyXG4gICAgLy8gUGFyYW1zXHJcbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHMgfHwgW107XHJcblxyXG4gICAgdmFyIGpvYlRpdGxlSUQgPSBwYXJhbXNbMF0gfDAsXHJcbiAgICAgICAgLy8gUGFyYW1ldGVyIFsxXSBjYW4gYmUgJ25ldycgZm9sbG93ZWQgYnkgYSBwcmljaW5nVHlwZUlEIGFzIFsyXVxyXG4gICAgICAgIHByaWNpbmdUeXBlSUQgPSBwYXJhbXNbMV0gPT09ICduZXcnID8gcGFyYW1zWzJdIHwwIDogMCxcclxuICAgICAgICAvLyBPciBhIHByaWNpbmdJRFxyXG4gICAgICAgIGZyZWVsYW5jZXJQcmljaW5nSUQgPSBwYXJhbXNbMV0gfDA7XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRChqb2JUaXRsZUlEKTtcclxuICAgIHRoaXMudmlld01vZGVsLmZyZWVsYW5jZXJQcmljaW5nSUQoZnJlZWxhbmNlclByaWNpbmdJRCk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIFRoZSBwcmljaW5nIHJlY29yZCBuZWVkcyBzb21lIHNwZWNpYWwgc2V0LXVwIGFmdGVyIGNyZWF0aW9uL2xvYWRpbmcgYW5kIGJlZm9yZVxyXG4gICAgICAgIGJlaW5nIHByZXNlbnRlZCB0byB0aGUgdXNlciwgYmVjYXVzZSBzcGVjaWFsIHZhbHVlLXJ1bGVzLlxyXG4gICAgKiovXHJcbiAgICB2YXIgcHJpY2luZ1NldHVwID0gZnVuY3Rpb24gcHJpY2luZ1NldHVwKCkge1xyXG4gICAgICAgIC8vIFByaWNpbmcgZmllbGRzIHRoYXQgaGFzIGEgc3BlY2lhbCBpbml0aWFsIHZhbHVlXHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50KCk7XHJcbiAgICAgICAgaWYgKGMpIHtcclxuICAgICAgICAgICAgLy8gTmFtZTogbXVzdCBiZSB0aGUgUHJpY2luZ1R5cGUuZml4ZWROYW1lIGV2ZXIgaWYgYW55LCBvclxyXG4gICAgICAgICAgICAvLyAgIHRoZSBuYW1lIHNhdmVkIGluIHRoZSBwcmljaW5nIG9yXHJcbiAgICAgICAgICAgIC8vICAgdGhlIHN1Z2dlc3RlZE5hbWUgYXMgbGFzdCBmYWxsYmFja1xyXG4gICAgICAgICAgICBjLnByaWNpbmcubmFtZShjLnR5cGUuZml4ZWROYW1lKCkgfHwgYy5wcmljaW5nLm5hbWUoKSB8fCBjLnR5cGUuc3VnZ2VzdGVkTmFtZSgpKTtcclxuICAgICAgICAgICAgLy8gUmVxdWlyZWQgY2FsbCBhZnRlciBsb2FkaW5nIGEgcHJpY2luZyB0byByZWZsZWN0IGRhdGEgY29ycmVjdGx5IChjYW5ub3QgYmUgYXV0b21hdGVkKVxyXG4gICAgICAgICAgICBjLnByaWNpbmcucmVmcmVzaE5vUHJpY2VSYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHZhciBzaG93SW52YWxpZFJlcXVlc3RFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgIHRpdGxlOiAnSW52YWxpZCByZXF1ZXN0JyxcclxuICAgICAgICAgICAgZXJyb3I6IHsgam9iVGl0bGVJRDogam9iVGl0bGVJRCwgcHJpY2luZ1R5cGVJRDogcHJpY2luZ1R5cGVJRCwgZnJlZWxhbmNlclByaWNpbmdJRDogZnJlZWxhbmNlclByaWNpbmdJRCB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gT24gY2xvc2UgbW9kYWwsIGdvIGJhY2tcclxuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICBpZiAocHJpY2luZ1R5cGVJRCkge1xyXG4gICAgICAgIC8vIExvYWQgdGhlIHByaWNpbmcgVHlwZVxyXG4gICAgICAgIHRoaXMuYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRJdGVtKHByaWNpbmdUeXBlSUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucHJpY2luZ1R5cGUodHlwZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBOZXcgcHJpY2luZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKHRoaXMuYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLm5ld0l0ZW1WZXJzaW9uKHtcclxuICAgICAgICAgICAgICAgICAgICBqb2JUaXRsZUlEOiBqb2JUaXRsZUlELFxyXG4gICAgICAgICAgICAgICAgICAgIHByaWNpbmdUeXBlSUQ6IHByaWNpbmdUeXBlSURcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHByaWNpbmdTZXR1cCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hvd0ludmFsaWRSZXF1ZXN0RXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmcmVlbGFuY2VyUHJpY2luZ0lEKSB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBwcmljaW5nXHJcbiAgICAgICAgdGhpcy5hcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuZ2V0SXRlbVZlcnNpb24oam9iVGl0bGVJRCwgZnJlZWxhbmNlclByaWNpbmdJRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChmcmVlbGFuY2VyUHJpY2luZ1ZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIHByaWNpbmcgdHlwZSBiZWZvcmUgcHV0IHRoZSB2ZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRvIGxldCB0aGUgJ2NhdGNoJyB0byBnZXQgYW55IGVycm9yXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHAubW9kZWwucHJpY2luZ1R5cGVzLmdldEl0ZW0oZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uLnZlcnNpb24ucHJpY2luZ1R5cGVJRCgpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnByaWNpbmdUeXBlKHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5mcmVlbGFuY2VyUHJpY2luZ1ZlcnNpb24oZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2luZ1NldHVwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93SW52YWxpZFJlcXVlc3RFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzaG93SW52YWxpZFJlcXVlc3RFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbiBjbG9zZSBtb2RhbCwgZ28gYmFja1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNob3dJbnZhbGlkUmVxdWVzdEVycm9yKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcbiAgICAvKmpzaGludCBtYXhzdGF0ZW1lbnRzOiAzNSovXHJcblxyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIC8vIG1hbmFnZWQgbWFudWFsbHkgaW5zdGVhZCBvZlxyXG4gICAgLy9hcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuc3RhdGUuaXNMb2FkaW5nO1xyXG4gICAgdGhpcy5pc1NhdmluZyA9IGFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5zdGF0ZS5pc1NhdmluZztcclxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLnN0YXRlLmlzU3luY2luZztcclxuICAgIHRoaXMuaXNEZWxldGluZyA9IGFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5zdGF0ZS5pc0RlbGV0aW5nO1xyXG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIHRoaXMuZnJlZWxhbmNlclByaWNpbmdJRCA9IGtvLm9ic2VydmFibGUoMCk7XHJcbiAgICAvLyBMMTBOXHJcbiAgICB0aGlzLm1vbmV5U3ltYm9sID0ga28ub2JzZXJ2YWJsZSgnJCcpO1xyXG4gICAgXHJcbiAgICB0aGlzLnByaWNpbmdUeXBlID0ga28ub2JzZXJ2YWJsZShuZXcgUHJpY2luZ1R5cGUoKSk7XHJcblxyXG4gICAgdGhpcy5mcmVlbGFuY2VyUHJpY2luZ1ZlcnNpb24gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgdGhpcy5mcmVlbGFuY2VyUHJpY2luZyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKCk7XHJcbiAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYudmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLmhlYWRlciA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0xvYWRpbmcuLi4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbigpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5wcmljaW5nVHlwZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdCAmJiB0LnNpbmd1bGFyTmFtZSgpIHx8ICdTZXJ2aWNlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnVW5rbm93IHNlcnZpY2Ugb3Igd2FzIGRlbGV0ZWQnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgLy8gUXVpY2tlciBhY2Nlc3MgaW4gZm9ybSwgdW5kZXIgYSAnd2l0aCdcclxuICAgIHRoaXMuY3VycmVudCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXMucHJpY2luZ1R5cGUoKSxcclxuICAgICAgICAgICAgcCA9IHRoaXMuZnJlZWxhbmNlclByaWNpbmcoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodCAmJiBwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0LFxyXG4gICAgICAgICAgICAgICAgcHJpY2luZzogcFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMud2FzUmVtb3ZlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzTG9ja2VkID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEZWxldGluZygpIHx8IGFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5zdGF0ZS5pc0xvY2tlZCgpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNOZXcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzLmZyZWVsYW5jZXJQcmljaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIHAgJiYgIXAudXBkYXRlZERhdGUoKTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ0xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnU2F2aW5nIGNoYW5nZXMnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgdiAmJiB2LmFyZURpZmZlcmVudCgpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmUgY2hhbmdlcycgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2F2ZWQnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMudW5zYXZlZENoYW5nZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbigpO1xyXG4gICAgICAgIHJldHVybiB2ICYmIHYuYXJlRGlmZmVyZW50KCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5kZWxldGVUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxldGluZygpID8gXHJcbiAgICAgICAgICAgICAgICAnRGVsZXRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICAnRGVsZXRlJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuc2V0SXRlbSh0aGlzLmZyZWVsYW5jZXJQcmljaW5nKCkubW9kZWwudG9QbGFpbk9iamVjdCgpKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCBzZXJ2ZXIgZGF0YS5cclxuICAgICAgICAgICAgdGhpcy5mcmVlbGFuY2VyUHJpY2luZygpLm1vZGVsLnVwZGF0ZVdpdGgoc2VydmVyRGF0YSk7XHJcbiAgICAgICAgICAgIC8vIFB1c2ggdmVyc2lvbiBzbyBpdCBhcHBlYXJzIGFzIHNhdmVkXHJcbiAgICAgICAgICAgIHRoaXMuZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKCkucHVzaCh7IGV2ZW5JZk9ic29sZXRlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gT24gc2F2ZSwgYXV0byBnbyBiYWNrXHJcbiAgICAgICAgICAgIC8vIE5PVEU6IGlmIGF1dG8gZ28gYmFjayBpcyBkaXNhYmxlZCwgdGhlIFVSTCBtdXN0IHVwZGF0ZSB0byBtYXRjaCB0aGUgbmV3IElEXHJcbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHNhdmluZy4nLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuY29uZmlybVJlbW92YWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBUT0RPIEJldHRlciBsMTBuIG9yIHJlcGxhY2UgYnkgYSBuZXcgcHJlc2V0IGZpZWxkIG9uIHByaWNpbmdUeXBlLmRlbGV0ZUxhYmVsXHJcbiAgICAgICAgdmFyIHAgPSB0aGlzLnByaWNpbmdUeXBlKCk7XHJcbiAgICAgICAgYXBwLm1vZGFscy5jb25maXJtKHtcclxuICAgICAgICAgICAgdGl0bGU6ICdEZWxldGUgJyArIChwICYmIHAuc2luZ3VsYXJOYW1lKCkpLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXJlIHlvdSBzdXJlPyBUaGUgb3BlcmF0aW9uIGNhbm5vdCBiZSB1bmRvbmUuJyxcclxuICAgICAgICAgICAgeWVzOiAnRGVsZXRlJyxcclxuICAgICAgICAgICAgbm86ICdLZWVwJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuZGVsSXRlbSh0aGlzLmpvYlRpdGxlSUQoKSwgdGhpcy5mcmVlbGFuY2VyUHJpY2luZ0lEKCkpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2FzUmVtb3ZlZCh0cnVlKTtcclxuICAgICAgICAgICAgLy8gR28gb3V0IHRoZSBkZWxldGVkIGxvY2F0aW9uXHJcbiAgICAgICAgICAgIGFwcC5zaGVsbC5nb0JhY2soKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBkZWxldGluZy4nLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufVxyXG4iLCIvKipcbiAgICBIb21lIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gSG9tZUFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIC8vIG51bGwgZm9yIGxvZ29cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIobnVsbCk7XG4gICAgXG4gICAgLy8gR2V0dGluZyBlbGVtZW50c1xuICAgIHRoaXMuJG5leHRCb29raW5nID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2hvbWVOZXh0Qm9va2luZycpO1xuICAgIHRoaXMuJHVwY29taW5nQm9va2luZ3MgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjaG9tZVVwY29taW5nQm9va2luZ3MnKTtcbiAgICB0aGlzLiRpbmJveCA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNob21lSW5ib3gnKTtcbiAgICB0aGlzLiRwZXJmb3JtYW5jZSA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNob21lUGVyZm9ybWFuY2UnKTtcbiAgICB0aGlzLiRnZXRNb3JlID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2hvbWVHZXRNb3JlJyk7XG4gICAgXG4gICAgLy8gVGVzdGluZ0RhdGFcbiAgICBzZXRTb21lVGVzdGluZ0RhdGEodGhpcy52aWV3TW9kZWwpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG4gICAgdmFyIHYgPSB0aGlzLnZpZXdNb2RlbCxcbiAgICAgICAgYXBwTW9kZWwgPSB0aGlzLmFwcC5tb2RlbDtcbiAgICBcbiAgICB2YXIgcHJlYXBhcmVTaG93RXJyb3JGb3IgPSBmdW5jdGlvbiBwcmVhcGFyZVNob3dFcnJvckZvcih0aXRsZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGRhdGFcbiAgICBpZiAodi51cGNvbWluZ0Jvb2tpbmdzLml0ZW1zKCkubGVuZ3RoKSB7XG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy5pc1N5bmNpbmcodHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MuaXNMb2FkaW5nKHRydWUpO1xuICAgIH1cbiAgICBhcHBNb2RlbC5ib29raW5ncy5nZXRVcGNvbWluZ0Jvb2tpbmdzKClcbiAgICAudGhlbihmdW5jdGlvbih1cGNvbWluZykge1xuXG4gICAgICAgIGlmICh1cGNvbWluZy5uZXh0Qm9va2luZ0lEKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNJRCA9IHYubmV4dEJvb2tpbmcoKSAmJiB2Lm5leHRCb29raW5nKCkuc291cmNlQm9va2luZygpLmJvb2tpbmdJRCgpO1xuICAgICAgICAgICAgaWYgKHVwY29taW5nLm5leHRCb29raW5nSUQgIT09IHByZXZpb3VzSUQpIHtcbiAgICAgICAgICAgICAgICBpZiAodi5uZXh0Qm9va2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHYubmV4dEJvb2tpbmcuaXNTeW5jaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdi5uZXh0Qm9va2luZy5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcE1vZGVsLmFwcG9pbnRtZW50cy5nZXRBcHBvaW50bWVudCh7IGJvb2tpbmdJRDogdXBjb21pbmcubmV4dEJvb2tpbmdJRCB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGFwdCkge1xuICAgICAgICAgICAgICAgICAgICB2Lm5leHRCb29raW5nKGFwdCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocHJlYXBhcmVTaG93RXJyb3JGb3IoJ0Vycm9yIGxvYWRpbmcgbmV4dCBib29raW5nJykpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHlcbiAgICAgICAgICAgICAgICAgICAgdi5uZXh0Qm9va2luZy5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB2Lm5leHRCb29raW5nLmlzU3luY2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2Lm5leHRCb29raW5nKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLnRvZGF5LnF1YW50aXR5KHVwY29taW5nLnRvZGF5LnF1YW50aXR5KTtcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLnRvZGF5LnRpbWUodXBjb21pbmcudG9kYXkudGltZSAmJiBuZXcgRGF0ZSh1cGNvbWluZy50b2RheS50aW1lKSk7XG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy50b21vcnJvdy5xdWFudGl0eSh1cGNvbWluZy50b21vcnJvdy5xdWFudGl0eSk7XG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy50b21vcnJvdy50aW1lKHVwY29taW5nLnRvbW9ycm93LnRpbWUgJiYgbmV3IERhdGUodXBjb21pbmcudG9tb3Jyb3cudGltZSkpO1xuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MubmV4dFdlZWsucXVhbnRpdHkodXBjb21pbmcubmV4dFdlZWsucXVhbnRpdHkpO1xuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MubmV4dFdlZWsudGltZSh1cGNvbWluZy5uZXh0V2Vlay50aW1lICYmIG5ldyBEYXRlKHVwY29taW5nLm5leHRXZWVrLnRpbWUpKTtcbiAgICB9KVxuICAgIC5jYXRjaChwcmVhcGFyZVNob3dFcnJvckZvcignRXJyb3IgbG9hZGluZyB1cGNvbWluZyBib29raW5ncycpKVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBGaW5hbGx5XG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBNZXNzYWdlc1xuICAgIHZhciBNZXNzYWdlVmlldyA9IHJlcXVpcmUoJy4uL21vZGVscy9NZXNzYWdlVmlldycpO1xuICAgIGlmICh2LmluYm94Lm1lc3NhZ2VzKCkubGVuZ3RoKVxuICAgICAgICB2LmluYm94LmlzU3luY2luZyh0cnVlKTtcbiAgICBlbHNlXG4gICAgICAgIHYuaW5ib3guaXNMb2FkaW5nKHRydWUpO1xuICAgIGFwcE1vZGVsLm1lc3NhZ2luZy5nZXRMaXN0KClcbiAgICAudGhlbihmdW5jdGlvbih0aHJlYWRzKSB7XG4gICAgICAgIHYuaW5ib3gubWVzc2FnZXModGhyZWFkcygpLm1hcChNZXNzYWdlVmlldy5mcm9tVGhyZWFkKSk7XG4gICAgfSlcbiAgICAuY2F0Y2gocHJlYXBhcmVTaG93RXJyb3JGb3IoJ0Vycm9yIGxvYWRpbmcgbGF0ZXN0IG1lc3NhZ2VzJykpXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEZpbmFsbHlcbiAgICAgICAgdi5pbmJveC5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB2LmluYm94LmlzU3luY2luZyhmYWxzZSk7XG4gICAgfSk7XG59O1xuXG5cbnZhciBVcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeSA9IHJlcXVpcmUoJy4uL21vZGVscy9VcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeScpLFxuICAgIE1haWxGb2xkZXIgPSByZXF1aXJlKCcuLi9tb2RlbHMvTWFpbEZvbGRlcicpLFxuICAgIFBlcmZvcm1hbmNlU3VtbWFyeSA9IHJlcXVpcmUoJy4uL21vZGVscy9QZXJmb3JtYW5jZVN1bW1hcnknKSxcbiAgICBHZXRNb3JlID0gcmVxdWlyZSgnLi4vbW9kZWxzL0dldE1vcmUnKTtcblxuZnVuY3Rpb24gVmlld01vZGVsKCkge1xuXG4gICAgdGhpcy51cGNvbWluZ0Jvb2tpbmdzID0gbmV3IFVwY29taW5nQm9va2luZ3NTdW1tYXJ5KCk7XG4gICAgdGhpcy51cGNvbWluZ0Jvb2tpbmdzLmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMudXBjb21pbmdCb29raW5ncy5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuICAgIHRoaXMubmV4dEJvb2tpbmcgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIHRoaXMubmV4dEJvb2tpbmcuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5uZXh0Qm9va2luZy5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBcbiAgICB0aGlzLmluYm94ID0gbmV3IE1haWxGb2xkZXIoe1xuICAgICAgICB0b3BOdW1iZXI6IDRcbiAgICB9KTtcbiAgICB0aGlzLmluYm94LmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuaW5ib3guaXNTeW5jaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgXG4gICAgdGhpcy5wZXJmb3JtYW5jZSA9IG5ldyBQZXJmb3JtYW5jZVN1bW1hcnkoKTtcbiAgICBcbiAgICB0aGlzLmdldE1vcmUgPSBuZXcgR2V0TW9yZSgpO1xufVxuXG4vKiogVEVTVElORyBEQVRBICoqL1xuZnVuY3Rpb24gc2V0U29tZVRlc3RpbmdEYXRhKHZpZXdNb2RlbCkge1xuICAgIFxuICAgIHZpZXdNb2RlbC5wZXJmb3JtYW5jZS5lYXJuaW5ncy5jdXJyZW50QW1vdW50KDI0MDApO1xuICAgIHZpZXdNb2RlbC5wZXJmb3JtYW5jZS5lYXJuaW5ncy5uZXh0QW1vdW50KDYyMDAuNTQpO1xuICAgIHZpZXdNb2RlbC5wZXJmb3JtYW5jZS50aW1lQm9va2VkLnBlcmNlbnQoMC45Myk7XG4gICAgXG4gICAgdmlld01vZGVsLmdldE1vcmUubW9kZWwudXBkYXRlV2l0aCh7XG4gICAgICAgIGF2YWlsYWJpbGl0eTogdHJ1ZSxcbiAgICAgICAgcGF5bWVudHM6IHRydWUsXG4gICAgICAgIHByb2ZpbGU6IHRydWUsXG4gICAgICAgIGNvb3A6IHRydWVcbiAgICB9KTtcbn1cbiIsIi8qKlxuICAgIEluYm94IGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBNZXNzYWdlVmlldyA9IHJlcXVpcmUoJy4uL21vZGVscy9NZXNzYWdlVmlldycpLFxuICAgIHRleHRTZWFyY2ggPSByZXF1aXJlKCcuLi91dGlscy90ZXh0U2VhcmNoJyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBJbmJveEFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIoJ0luYm94Jyk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBcbiAgICAvLyBNZXNzYWdlc1xuICAgIHRoaXMuYXBwLm1vZGVsLm1lc3NhZ2luZy5nZXRMaXN0KClcbiAgICAudGhlbihmdW5jdGlvbih0aHJlYWRzKSB7XG4gICAgICAgIHRoaXMudmlld01vZGVsLnNvdXJjZVRocmVhZHModGhyZWFkcygpKTtcbiAgICB9LmJpbmQodGhpcykpXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgbG9hZGluZyBtZXNzYWdlcycsXG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBhcHAubW9kZWwubWVzc2FnaW5nLnN0YXRlLmlzTG9hZGluZztcbiAgICB0aGlzLmlzU3luY2luZyA9IGFwcC5tb2RlbC5tZXNzYWdpbmcuc3RhdGUuaXNTeW5jaW5nO1xuXG4gICAgdGhpcy5zb3VyY2VUaHJlYWRzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbiAgICBcbiAgICB0aGlzLnNlYXJjaFRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICBcbiAgICAvLyBOT1RFOiBzaW5jZSBjdXJyZW50IEFQSS1jb25uZWN0aW9uIGltcGxlbWVudGF0aW9uIG9ubHkgZ2V0c1xuICAgIC8vIHRoZSBsYXRlc3QgbWVzc2FnZSB3aXRoIGdldExpc3QsIHRoZSBzZWFyY2ggaXMgZG9uZSBpbiB0aGVcbiAgICAvLyBib2R5VGV4dCBvZiB0aGUgbGFzdCBtZXNzYWdlIChhZGRpdGlvbmFsbHkgdG8gdGhlIHRocmVhZCBzdWJqZWN0KVxuICAgIC8vIGV2ZW4gaWYgdGhpcyBpbXBsZW1lbnRhdGlvbiB0cnkgdG8gaXRlcmF0ZSBhbGwgbWVzc2FnZXMuXG4gICAgdGhpcy50aHJlYWRzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuc291cmNlVGhyZWFkcygpLFxuICAgICAgICAgICAgcyA9IHRoaXMuc2VhcmNoVGV4dCgpO1xuXG4gICAgICAgIGlmICghdClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgZWxzZSBpZiAoIXMpXG4gICAgICAgICAgICByZXR1cm4gdC5tYXAoTWVzc2FnZVZpZXcuZnJvbVRocmVhZCk7XG4gICAgICAgIGVsc2UgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHQuZmlsdGVyKGZ1bmN0aW9uKHRocmVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHN1YmplY3RcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRleHRTZWFyY2gocywgdGhyZWFkLnN1YmplY3QoKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgY29udGVudCBvZiBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBzdG9wcyBvbiBmaXJzdCAndHJ1ZScgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIHRocmVhZC5tZXNzYWdlcygpLnNvbWUoZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRleHRTZWFyY2gocywgbXNnLmJvZHlUZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfSkubWFwKE1lc3NhZ2VWaWV3LmZyb21UaHJlYWQpO1xuICAgIH0sIHRoaXMpO1xufVxuIiwiLyoqXG4gICAgSW5kZXggYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBJbmRleEFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBBbnkgdXNlciBjYW4gYWNjZXNzIHRoaXNcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gbnVsbDtcbiAgICBcbiAgICAvLyBudWxsIGZvciBsb2dvXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKG51bGwpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICBcbiAgICAvLyBJdCBjaGVja3MgaWYgdGhlIHVzZXIgaXMgbG9nZ2VkIHNvIHRoZW4gXG4gICAgLy8gdGhlaXIgJ2xvZ2dlZCBpbmRleCcgaXMgdGhlIGRhc2hib2FyZCBub3QgdGhpc1xuICAgIC8vIHBhZ2UgdGhhdCBpcyBmb2N1c2VkIG9uIGFub255bW91cyB1c2Vyc1xuICAgIGlmICghdGhpcy5hcHAubW9kZWwudXNlcigpLmlzQW5vbnltb3VzKCkpIHtcbiAgICAgICAgdGhpcy5hcHAuZ29EYXNoYm9hcmQoKTtcbiAgICB9XG59O1xuIiwiLyoqXG4gICAgSm9idGl0bGVzIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEpvYnRpdGxlc0FjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1NjaGVkdWxpbmcnKTtcbiAgICBcbiAgICAvLyBPbiBjaGFuZ2luZyBqb2JUaXRsZUlEOlxuICAgIC8vIC0gbG9hZCBhZGRyZXNzZXNcbiAgICAvLyAtIGxvYWQgam9iIHRpdGxlIGluZm9ybWF0aW9uXG4gICAgLy8gLSBsb2FkIHByaWNpbmdcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oam9iVGl0bGVJRCkge1xuXG4gICAgICAgICAgICBpZiAoam9iVGl0bGVJRCkge1xuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vIEFkZHJlc3Nlc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuZ2V0TGlzdChqb2JUaXRsZUlEKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGxpc3QpIHtcblxuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gdGhpcy5hcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5hc01vZGVsKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzZXMobGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIGFkZHJlc3Nlcy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vIFByaWNpbmcvU2VydmljZXNcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5nZXRMaXN0KGpvYlRpdGxlSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obGlzdCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLmFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5hc01vZGVsKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcmljaW5nKGxpc3QpO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyBzZXJ2aWNlcy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vIEpvYiBUaXRsZVxuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwuam9iVGl0bGVzLmdldEpvYlRpdGxlKGpvYlRpdGxlSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oam9iVGl0bGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWxsIGluIGpvYiB0aXRsZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlTmFtZShqb2JUaXRsZS5zaW5ndWxhck5hbWUoKSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBqb2IgdGl0bGUuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NlcyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucHJpY2luZyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVOYW1lKCdKb2IgVGl0bGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuXG4gICAgLy8gUmVzZXQ6IGF2b2lkaW5nIGVycm9ycyBiZWNhdXNlIHBlcnNpc3RlZCBkYXRhIGZvciBkaWZmZXJlbnQgSUQgb24gbG9hZGluZ1xuICAgIC8vIG9yIG91dGRhdGVkIGluZm8gZm9yY2luZyB1cGRhdGVcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKDApO1xuXG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cyB8fCB7fTtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGpvYiB0aXRsZVxuICAgIHZhciBqb2JJRCA9IHBhcmFtc1swXSB8MDtcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYklEKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMuam9iVGl0bGVOYW1lID0ga28ub2JzZXJ2YWJsZSgnSm9iIFRpdGxlJyk7XG4gICAgXG4gICAgdGhpcy5hZGRyZXNzZXMgPSBrby5vYnNlcnZhYmxlKFtdKTtcbiAgICB0aGlzLnByaWNpbmcgPSBrby5vYnNlcnZhYmxlKFtdKTtcblxuICAgIC8vIENvbXB1dGVkIHNpbmNlIGl0IGNhbiBjaGVjayBzZXZlcmFsIGV4dGVybmEgbG9hZGluZ3NcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnN0YXRlLmlzTG9hZGluZygpIHx8XG4gICAgICAgICAgICBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuc3RhdGUuaXNMb2FkaW5nKClcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5hZGRyZXNzZXNDb3VudCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE8gbDEwbi5cbiAgICAgICAgLy8gVXNlIGkxOG5leHQgcGx1cmFsIGxvY2FsaXphdGlvbiBzdXBwb3J0IHJhdGhlciB0aGFuIHRoaXMgbWFudWFsLlxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmFkZHJlc3NlcygpLmxlbmd0aCxcbiAgICAgICAgICAgIG9uZSA9ICcxIGxvY2F0aW9uJyxcbiAgICAgICAgICAgIG1vcmUgPSAnIGxvY2F0aW9ucyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY291bnQgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gb25lO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAvLyBTbWFsbCBudW1iZXJzLCBubyBuZWVkIGZvciBmb3JtYXR0aW5nXG4gICAgICAgICAgICByZXR1cm4gY291bnQgKyBtb3JlO1xuXG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5wcmljaW5nQ291bnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPIGwxMG4uXG4gICAgICAgIC8vIFVzZSBpMThuZXh0IHBsdXJhbCBsb2NhbGl6YXRpb24gc3VwcG9ydCByYXRoZXIgdGhhbiB0aGlzIG1hbnVhbC5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5wcmljaW5nKCkubGVuZ3RoLFxuICAgICAgICAgICAgb25lID0gJzEgc2VydmljZScsXG4gICAgICAgICAgICBtb3JlID0gJyBzZXJ2aWNlcyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY291bnQgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gb25lO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAvLyBTbWFsbCBudW1iZXJzLCBubyBuZWVkIGZvciBmb3JtYXR0aW5nXG4gICAgICAgICAgICByZXR1cm4gY291bnQgKyBtb3JlO1xuXG4gICAgfSwgdGhpcyk7XG4gICAgXG59XG4iLCIvKipcbiAgICBMZWFybk1vcmUgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIExlYXJuTW9yZUFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIC8vIG51bGwgZm9yIGxvZ29cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIobnVsbCk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmXG4gICAgICAgIG9wdGlvbnMucm91dGUuc2VnbWVudHMgJiZcbiAgICAgICAgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwucHJvZmlsZShvcHRpb25zLnJvdXRlLnNlZ21lbnRzWzBdKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoKSB7XG4gICAgdGhpcy5wcm9maWxlID0ga28ub2JzZXJ2YWJsZSgnY3VzdG9tZXInKTtcbn1cbiIsIi8qKlxuICAgIExvZ2luIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIExvZ2luQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Bbm9ueW1vdXM7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIoJ0xvZyBpbicpO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gbG9nLWluIHJlcXVlc3Qgd2hlbiBpcyByZXF1ZXN0ZWQgYnkgdGhlIGZvcm06XG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmlzTG9naW5nSW4sXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2ID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGxvZ2luZ1xuXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHN0YXRlOlxuICAgICAgICAgICAgICAgIHZhciAkYnRuID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnW3R5cGU9XCJzdWJtaXRcIl0nKTtcbiAgICAgICAgICAgICAgICAkYnRuLmJ1dHRvbignbG9hZGluZycpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgZXJyb3Igc28gbWFrZXMgY2xlYXIgd2VcbiAgICAgICAgICAgICAgICAvLyBhcmUgYXR0ZW1wdGluZ1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxvZ2luRXJyb3IoJycpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVuZGVkID0gZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9naW5nSW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAkYnRuLmJ1dHRvbigncmVzZXQnKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZnRlciBjbGVhbi11cCBlcnJvciAodG8gZm9yY2Ugc29tZSB2aWV3IHVwZGF0ZXMpLFxuICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRlIGFuZCBhYm9ydCBvbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNoZWNraW5nIGVycm9yIG9uIGVhY2ggZmllbGRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3TW9kZWwudXNlcm5hbWUuZXJyb3IoKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wYXNzd29yZC5lcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxvZ2luRXJyb3IoJ1JldmlldyB5b3VyIGRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLmxvZ2luKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC51c2VybmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wYXNzd29yZCgpXG4gICAgICAgICAgICAgICAgKS50aGVuKGZ1bmN0aW9uKC8qbG9naW5EYXRhKi8pIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kZWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZm9ybSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnVzZXJuYW1lKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucGFzc3dvcmQoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLmdvRGFzaGJvYXJkKCk7XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBlcnIgJiYgZXJyLnJlc3BvbnNlSlNPTiAmJiBlcnIucmVzcG9uc2VKU09OLmVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyICYmIGVyci5zdGF0dXNUZXh0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCB1c2VybmFtZSBvciBwYXNzd29yZCc7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwubG9naW5FcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICBlbmRlZCgpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEZvY3VzIGZpcnN0IGJhZCBmaWVsZCBvbiBlcnJvclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIC8vIExvZ2luIGlzIGVhc3kgc2luY2Ugd2UgbWFyayBib3RoIHVuaXF1ZSBmaWVsZHNcbiAgICAgICAgICAgIC8vIGFzIGVycm9yIG9uIGxvZ2luRXJyb3IgKGl0cyBhIGdlbmVyYWwgZm9ybSBlcnJvcilcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJzppbnB1dCcpLmdldCgwKTtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpbnB1dC5ibHVyKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxudmFyIEZvcm1DcmVkZW50aWFscyA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvRm9ybUNyZWRlbnRpYWxzJyk7XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcblxuICAgIHZhciBjcmVkZW50aWFscyA9IG5ldyBGb3JtQ3JlZGVudGlhbHMoKTsgICAgXG4gICAgdGhpcy51c2VybmFtZSA9IGNyZWRlbnRpYWxzLnVzZXJuYW1lO1xuICAgIHRoaXMucGFzc3dvcmQgPSBjcmVkZW50aWFscy5wYXNzd29yZDtcblxuICAgIHRoaXMubG9naW5FcnJvciA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIFxuICAgIHRoaXMuaXNMb2dpbmdJbiA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIFxuICAgIHRoaXMucGVyZm9ybUxvZ2luID0gZnVuY3Rpb24gcGVyZm9ybUxvZ2luKCkge1xuXG4gICAgICAgIHRoaXMuaXNMb2dpbmdJbih0cnVlKTsgICAgICAgIFxuICAgIH0uYmluZCh0aGlzKTtcbn1cbiIsIi8qKlxuICAgIExvZ291dCBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIExvZ291dEFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG4gICAgXG4gICAgdGhpcy5hcHAubW9kZWwubG9nb3V0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQW5vbnltb3VzIHVzZXIgYWdhaW5cbiAgICAgICAgdmFyIG5ld0Fub24gPSB0aGlzLmFwcC5tb2RlbC51c2VyKCkuY29uc3RydWN0b3IubmV3QW5vbnltb3VzKCk7XG4gICAgICAgIHRoaXMuYXBwLm1vZGVsLnVzZXIoKS5tb2RlbC51cGRhdGVXaXRoKG5ld0Fub24pO1xuXG4gICAgICAgIC8vIEdvIGluZGV4XG4gICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvKCcvJyk7XG4gICAgICAgIFxuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuIiwiLyoqXG4gICAgT25ib2FyZGluZ0NvbXBsZXRlIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gT25ib2FyZGluZ0NvbXBsZXRlQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xuICAgIFxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcihudWxsKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG4iLCIvKipcbiAgICBPbmJvYXJkaW5nSG9tZSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIE9uYm9hcmRpbmdIb21lQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xuICAgIFxuICAgIC8vIG51bGwgZm9yIExvZ29cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIobnVsbCk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuIiwiLyoqXG4gICAgT25ib2FyZGluZyBQb3NpdGlvbnMgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gT25ib2FyZGluZ1Bvc2l0aW9uc0FjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignSm9iIFRpdGxlcycpO1xuXG4gICAgLy8gVGVzdGluZ0RhdGFcbiAgICBzZXRTb21lVGVzdGluZ0RhdGEodGhpcy52aWV3TW9kZWwpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuZnVuY3Rpb24gVmlld01vZGVsKCkge1xuXG4gICAgLy8gRnVsbCBsaXN0IG9mIHBvc2l0aW9uc1xuICAgIHRoaXMucG9zaXRpb25zID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbn1cblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi4vbW9kZWxzL1Bvc2l0aW9uJyk7XG4vLyBVc2VyUG9zaXRpb24gbW9kZWxcbmZ1bmN0aW9uIHNldFNvbWVUZXN0aW5nRGF0YSh2aWV3TW9kZWwpIHtcbiAgICBcbiAgICB2aWV3TW9kZWwucG9zaXRpb25zLnB1c2gobmV3IFBvc2l0aW9uKHtcbiAgICAgICAgcG9zaXRpb25TaW5ndWxhcjogJ01hc3NhZ2UgVGhlcmFwaXN0J1xuICAgIH0pKTtcbiAgICB2aWV3TW9kZWwucG9zaXRpb25zLnB1c2gobmV3IFBvc2l0aW9uKHtcbiAgICAgICAgcG9zaXRpb25TaW5ndWxhcjogJ0hvdXNla2VlcGVyJ1xuICAgIH0pKTtcbn0iLCIvKipcbiAgICBPd25lckluZm8gYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBPd25lckluZm9BY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdBY2NvdW50Jywge1xuICAgICAgICBiYWNrTGluazogJ2FjY291bnQnXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuIiwiLyoqXHJcbiAgICBQcml2YWN5U2V0dGluZ3MgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBQcml2YWN5U2V0dGluZ3NBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIFxyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG5cclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignQWNjb3VudCcsIHtcclxuICAgICAgICBiYWNrTGluazogJ2FjY291bnQnXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy5hcHAubW9kZWwucHJpdmFjeVNldHRpbmdzLFxyXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgcHJpdmFjeSBzZXR0aW5ncy4nIDogJ0Vycm9yIGxvYWRpbmcgcHJpdmFjeSBzZXR0aW5ncy4nO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci50YXNrICYmIGVyci5lcnJvciB8fCBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcbiAgICBcclxuICAgICAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcclxuICAgIHRoaXMuYXBwLm1vZGVsLnByaXZhY3lTZXR0aW5ncy5zeW5jKCk7XHJcbiAgICAvLyBEaXNjYXJkIGFueSBwcmV2aW91cyB1bnNhdmVkIGVkaXRcclxuICAgIHRoaXMudmlld01vZGVsLmRpc2NhcmQoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuXHJcbiAgICB2YXIgcHJpdmFjeVNldHRpbmdzID0gYXBwLm1vZGVsLnByaXZhY3lTZXR0aW5ncztcclxuXHJcbiAgICB2YXIgc2V0dGluZ3NWZXJzaW9uID0gcHJpdmFjeVNldHRpbmdzLm5ld1ZlcnNpb24oKTtcclxuICAgIHNldHRpbmdzVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XHJcbiAgICAgICAgaWYgKGl0SXMpIHtcclxuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xyXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXHJcbiAgICAgICAgICAgIC8vIGNvbmZpcm1hdGlvbiB0byBsb2FkIHRoZW0gb3IgZGlzY2FyZCBhbmQgb3ZlcndyaXRlIHRoZW07XHJcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIHNlcnZlciB2ZXJzaW9uKS5cclxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxyXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcclxuICAgICAgICAgICAgc2V0dGluZ3NWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQWN0dWFsIGRhdGEgZm9yIHRoZSBmb3JtOlxyXG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzVmVyc2lvbi52ZXJzaW9uO1xyXG5cclxuICAgIHRoaXMuaXNMb2NrZWQgPSBwcml2YWN5U2V0dGluZ3MuaXNMb2NrZWQ7XHJcblxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICdsb2FkaW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgICAgICAnU2F2ZSdcclxuICAgICAgICApO1xyXG4gICAgfSwgcHJpdmFjeVNldHRpbmdzKTtcclxuICAgIFxyXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcclxuICAgICAgICBzZXR0aW5nc1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XHJcbiAgICAgICAgLy8gRm9yY2UgdG8gc2F2ZSwgZXZlbiBpZiB0aGVyZSB3YXMgcmVtb3RlIHVwZGF0ZXNcclxuICAgICAgICBzZXR0aW5nc1ZlcnNpb24ucHVzaCh7IGV2ZW5JZk9ic29sZXRlOiB0cnVlIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxuICAgIFNjaGVkdWxpbmcgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXG4gICAgVXNlckpvYlByb2ZpbGVWaWV3TW9kZWwgPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL1VzZXJKb2JQcm9maWxlJyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBTY2hlZHVsaW5nQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFVzZXJKb2JQcm9maWxlVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIoJ1NjaGVkdWxpbmcnKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5zeW5jKCk7XG59O1xuIiwiLyoqXHJcbiAgICBTY2hlZHVsaW5nUHJlZmVyZW5jZXMgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFNjaGVkdWxpbmdQcmVmZXJlbmNlc0FjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XHJcblxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnc2NoZWR1bGluZydcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5zY2hlZHVsaW5nUHJlZmVyZW5jZXMsXHJcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBlcnIudGFzayA9PT0gJ3NhdmUnID8gJ0Vycm9yIHNhdmluZyBzY2hlZHVsaW5nIHByZWZlcmVuY2VzLicgOiAnRXJyb3IgbG9hZGluZyBzY2hlZHVsaW5nIHByZWZlcmVuY2VzLic7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLnRhc2sgJiYgZXJyLmVycm9yIHx8IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxyXG4gICAgdGhpcy5hcHAubW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzLnN5bmMoKTtcclxuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxyXG4gICAgdGhpcy52aWV3TW9kZWwuZGlzY2FyZCgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHZhciBzY2hlZHVsaW5nUHJlZmVyZW5jZXMgPSBhcHAubW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzO1xyXG5cclxuICAgIHZhciBwcmVmc1ZlcnNpb24gPSBzY2hlZHVsaW5nUHJlZmVyZW5jZXMubmV3VmVyc2lvbigpO1xyXG4gICAgcHJlZnNWZXJzaW9uLmlzT2Jzb2xldGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGl0SXMpIHtcclxuICAgICAgICBpZiAoaXRJcykge1xyXG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXHJcbiAgICAgICAgICAgIC8vIEZVVFVSRTogd2FybiBhYm91dCBhIG5ldyByZW1vdGUgdmVyc2lvbiBhc2tpbmdcclxuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcclxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcclxuICAgICAgICAgICAgLy8gd2l0aCBhIDUwOTpDb25mbGljdCBzdGF0dXMgKGl0cyBib2R5IG11c3QgY29udGFpbiB0aGVcclxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxyXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbW90ZSBvbmVzOlxyXG4gICAgICAgICAgICBwcmVmc1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XHJcbiAgICB0aGlzLnByZWZzID0gcHJlZnNWZXJzaW9uLnZlcnNpb247XHJcblxyXG4gICAgdGhpcy5pc0xvY2tlZCA9IHNjaGVkdWxpbmdQcmVmZXJlbmNlcy5pc0xvY2tlZDtcclxuXHJcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnc2F2aW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICdTYXZlJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCBzY2hlZHVsaW5nUHJlZmVyZW5jZXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRpc2NhcmQgPSBmdW5jdGlvbiBkaXNjYXJkKCkge1xyXG4gICAgICAgIHByZWZzVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICAvLyBGb3JjZSB0byBzYXZlLCBldmVuIGlmIHRoZXJlIHdhcyByZW1vdGUgdXBkYXRlc1xyXG4gICAgICAgIHByZWZzVmVyc2lvbi5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXBwLnN1Y2Nlc3NTYXZlKCk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaW5jcmVtZW50c0V4YW1wbGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0ciA9ICdlLmcuICcsXHJcbiAgICAgICAgICAgIGluY1NpemUgPSB0aGlzLmluY3JlbWVudHNTaXplSW5NaW51dGVzKCksXHJcbiAgICAgICAgICAgIG0gPSBtb21lbnQoeyBob3VyOiAxMCwgbWludXRlOiAwIH0pLFxyXG4gICAgICAgICAgICBob3VycyA9IFttLmZvcm1hdCgnSEg6bW0nKV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgaG91cnMucHVzaChcclxuICAgICAgICAgICAgICAgIG0uYWRkKGluY1NpemUsICdtaW51dGVzJylcclxuICAgICAgICAgICAgICAgIC5mb3JtYXQoJ0hIOm1tJylcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RyICs9IGhvdXJzLmpvaW4oJywgJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMucHJlZnMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgU2VydmljZSBBZGRyZXNzZXMgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBTZXJ2aWNlQWRkcmVzc2VzQWN0aXZpdHkoKSB7XHJcblxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0pvYiBUaXRsZScpO1xyXG4gICAgXHJcbiAgICAvLyBHZXR0aW5nIGVsZW1lbnRzXHJcbiAgICB0aGlzLiRsaXN0VmlldyA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNhZGRyZXNzZXNMaXN0VmlldycpO1xyXG5cclxuICAgIC8vIE9uIGNoYW5naW5nIGpvYlRpdGxlSUQ6XHJcbiAgICAvLyAtIGxvYWQgYWRkcmVzc2VzXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlELFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAgICAgaWYgKGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZpZXdNb2RlbC5pc1NlbGVjdGlvbk1vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxsIGluIGpvYiB0aXRsZSBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KGpvYlRpdGxlLnNpbmd1bGFyTmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGFkZHJlc3Nlc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldExpc3Qoam9iVGl0bGVJRCk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmFzTW9kZWwobGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc2VzKGxpc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NlcyhbXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCgnSm9iIFRpdGxlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGVyIHRvIHVwZGF0ZSBoZWFkZXIgYmFzZWQgb24gYSBtb2RlIGNoYW5nZTpcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZSxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoaXRJcykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXJUZXh0KGl0SXMgPyAnU2VsZWN0IG9yIGFkZCBhIHNlcnZpY2UgbG9jYXRpb24nIDogJ0xvY2F0aW9ucycpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIG5hdmJhciB0b29cclxuICAgICAgICAgICAgLy8gVE9ETzogQ2FuIGJlIG90aGVyIHRoYW4gJ3NjaGVkdWxpbmcnLCBsaWtlIG1hcmtldHBsYWNlIHByb2ZpbGUgb3IgdGhlIGpvYi10aXRsZT9cclxuICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLnRleHQoaXRJcyA/ICdCb29raW5nJyA6ICdTY2hlZHVsaW5nJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5wcm9ncmVzc1N0ZXApIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGl0bGUgYnkgcHJvY2VzcyBzdGVwIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdkJhci50aXRsZSh0aGlzLnJlcXVlc3REYXRhLnByb2dyZXNzU3RlcCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCgnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaXRsZSBtdXN0IGJlIGVtcHR5XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdkJhci50aXRsZSgnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBHbyBiYWNrIHdpdGggdGhlIHNlbGVjdGVkIGFkZHJlc3Mgd2hlbiB0cmlnZ2VyZWQgaW4gdGhlIGZvcm0vdmlld1xyXG4gICAgdGhpcy52aWV3TW9kZWwucmV0dXJuU2VsZWN0ZWQgPSBmdW5jdGlvbihhZGRyZXNzSUQsIGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAvLyBQYXNzIHRoZSBzZWxlY3RlZCBjbGllbnQgaW4gdGhlIGluZm9cclxuICAgICAgICB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkQWRkcmVzc0lEID0gYWRkcmVzc0lEO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRKb2JUaXRsZUlEID0gam9iVGl0bGVJRDtcclxuICAgICAgICAvLyBBbmQgZ28gYmFja1xyXG4gICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIFJlc2V0OiBhdm9pZGluZyBlcnJvcnMgYmVjYXVzZSBwZXJzaXN0ZWQgZGF0YSBmb3IgZGlmZmVyZW50IElEIG9uIGxvYWRpbmdcclxuICAgIC8vIG9yIG91dGRhdGVkIGluZm8gZm9yY2luZyB1cGRhdGVcclxuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoMCk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5pc1NlbGVjdGlvbk1vZGUoZmFsc2UpO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnNlbGVjdEFkZHJlc3MgPT09IHRydWUpIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc1NlbGVjdGlvbk1vZGUodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhcmFtcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yb3V0ZSAmJiBvcHRpb25zLnJvdXRlLnNlZ21lbnRzO1xyXG4gICAgdmFyIGpvYlRpdGxlSUQgPSBwYXJhbXNbMF0gfDA7XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRChqb2JUaXRsZUlEKTtcclxuICAgIFxyXG4gICAgaWYgKGpvYlRpdGxlSUQgPT09IDApIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZXMuc3luYygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIFVzZXJKb2JQcm9maWxlID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9Vc2VySm9iUHJvZmlsZScpO1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHRoaXMuaGVhZGVyVGV4dCA9IGtvLm9ic2VydmFibGUoJ0xvY2F0aW9ucycpO1xyXG4gICAgXHJcbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xyXG4gICAgXHJcbiAgICB0aGlzLmpvYlRpdGxlcyA9IG5ldyBVc2VySm9iUHJvZmlsZShhcHApO1xyXG4gICAgdGhpcy5qb2JUaXRsZXMuYmFzZVVybCgnL3NlcnZpY2VBZGRyZXNzJyk7XHJcbiAgICB0aGlzLmpvYlRpdGxlcy5zZWxlY3RKb2JUaXRsZSA9IGZ1bmN0aW9uKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5qb2JUaXRsZUlEKGpvYlRpdGxlLmpvYlRpdGxlSUQoKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIExpc3Qgb2YgYWRkcmVzc2VzXHJcbiAgICB0aGlzLmFkZHJlc3NlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNTeW5jaW5nKCk7XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhZGQgPSBhcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zdGF0ZS5pc0xvYWRpbmcoKSxcclxuICAgICAgICAgICAgam9icyA9IHRoaXMuam9iVGl0bGVzLmlzTG9hZGluZygpO1xyXG4gICAgICAgIHJldHVybiBhZGQgfHwgam9icztcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8vIEVzcGVjaWFsIG1vZGUgd2hlbiBpbnN0ZWFkIG9mIHBpY2sgYW5kIGVkaXQgd2UgYXJlIGp1c3Qgc2VsZWN0aW5nXHJcbiAgICAvLyAod2hlbiBlZGl0aW5nIGFuIGFwcG9pbnRtZW50KVxyXG4gICAgdGhpcy5pc1NlbGVjdGlvbk1vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnNlbGVjdEFkZHJlc3MgPSBmdW5jdGlvbihzZWxlY3RlZEFkZHJlc3MpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGlvbk1vZGUoKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzU2VsZWN0aW9uTW9kZShmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIFJ1biBtZXRob2QgaW5qZWN0ZWQgYnkgdGhlIGFjdGl2aXR5IHRvIHJldHVybiBhIFxyXG4gICAgICAgICAgICAvLyBzZWxlY3RlZCBhZGRyZXNzOlxyXG4gICAgICAgICAgICB0aGlzLnJldHVyblNlbGVjdGVkKFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzLmFkZHJlc3NJRCgpLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzLmpvYlRpdGxlSUQoKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXBwLnNoZWxsLmdvKCdhZGRyZXNzRWRpdG9yL3NlcnZpY2UvJyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLmpvYlRpdGxlSUQoKSArXHJcbiAgICAgICAgICAgICAgICAnLycgKyBzZWxlY3RlZEFkZHJlc3MuYWRkcmVzc0lEKClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxuICAgIFNpZ251cCBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBTaWdudXBBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkFub255bW91cztcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIC8vIG51bGwgZm9yIExvZ29cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIobnVsbCk7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBzaWduLXVwIHJlcXVlc3Qgd2hlbiBpcyByZXF1ZXN0ZWQgYnkgdGhlIGZvcm06XG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmlzU2lnbmluZ1VwLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAodiA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBzaWdudXBcblxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBzdGF0ZTpcbiAgICAgICAgICAgICAgICB2YXIgJGJ0biA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJ1t0eXBlPVwic3VibWl0XCJdJyk7XG4gICAgICAgICAgICAgICAgJGJ0bi5idXR0b24oJ2xvYWRpbmcnKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGVycm9yIHNvIG1ha2VzIGNsZWFyIHdlXG4gICAgICAgICAgICAgICAgLy8gYXJlIGF0dGVtcHRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5zaWdudXBFcnJvcignJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kZWQgPSBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaXNTaWduaW5nVXAoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAkYnRuLmJ1dHRvbigncmVzZXQnKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZnRlciBjbGVhbi11cCBlcnJvciAodG8gZm9yY2Ugc29tZSB2aWV3IHVwZGF0ZXMpLFxuICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRlIGFuZCBhYm9ydCBvbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNoZWNraW5nIGVycm9yIG9uIGVhY2ggZmllbGRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3TW9kZWwudXNlcm5hbWUuZXJyb3IoKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wYXNzd29yZC5lcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnNpZ251cEVycm9yKCdSZXZpZXcgeW91ciBkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5zaWdudXAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnVzZXJuYW1lKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnBhc3N3b3JkKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnByb2ZpbGUoKVxuICAgICAgICAgICAgICAgICkudGhlbihmdW5jdGlvbigvKnNpZ251cERhdGEqLykge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnNpZ251cEVycm9yKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kZWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZm9ybSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnVzZXJuYW1lKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucGFzc3dvcmQoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLmdvRGFzaGJvYXJkKCk7XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBlcnIgJiYgZXJyLnJlc3BvbnNlSlNPTiAmJiBlcnIucmVzcG9uc2VKU09OLmVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyICYmIGVyci5zdGF0dXNUZXh0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCB1c2VybmFtZSBvciBwYXNzd29yZCc7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc2lnbnVwRXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kZWQoKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGb2N1cyBmaXJzdCBiYWQgZmllbGQgb24gZXJyb3JcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuc2lnbnVwRXJyb3IsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gU2lnbnVwIGlzIGVhc3kgc2luY2Ugd2UgbWFyayBib3RoIHVuaXF1ZSBmaWVsZHNcbiAgICAgICAgICAgIC8vIGFzIGVycm9yIG9uIHNpZ251cEVycm9yIChpdHMgYSBnZW5lcmFsIGZvcm0gZXJyb3IpXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCc6aW5wdXQnKS5nZXQoMCk7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW5wdXQuYmx1cigpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmXG4gICAgICAgIG9wdGlvbnMucm91dGUuc2VnbWVudHMgJiZcbiAgICAgICAgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwucHJvZmlsZShvcHRpb25zLnJvdXRlLnNlZ21lbnRzWzBdKTtcbiAgICB9XG59O1xuXG5cbnZhciBGb3JtQ3JlZGVudGlhbHMgPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL0Zvcm1DcmVkZW50aWFscycpO1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoKSB7XG5cbiAgICB2YXIgY3JlZGVudGlhbHMgPSBuZXcgRm9ybUNyZWRlbnRpYWxzKCk7ICAgIFxuICAgIHRoaXMudXNlcm5hbWUgPSBjcmVkZW50aWFscy51c2VybmFtZTtcbiAgICB0aGlzLnBhc3N3b3JkID0gY3JlZGVudGlhbHMucGFzc3dvcmQ7XG5cbiAgICB0aGlzLnNpZ251cEVycm9yID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgXG4gICAgdGhpcy5pc1NpZ25pbmdVcCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIFxuICAgIHRoaXMucGVyZm9ybVNpZ251cCA9IGZ1bmN0aW9uIHBlcmZvcm1TaWdudXAoKSB7XG5cbiAgICAgICAgdGhpcy5pc1NpZ25pbmdVcCh0cnVlKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnByb2ZpbGUgPSBrby5vYnNlcnZhYmxlKCdjdXN0b21lcicpO1xufVxuIiwiLyoqXHJcbiAgICB0ZXh0RWRpdG9yIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxyXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gVGV4dEVkaXRvckFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIC8vIFRpdGxlIGlzIGVtcHR5IGV2ZXIsIHNpbmNlIHdlIGFyZSBpbiAnZ28gYmFjaycgbW9kZSBhbGwgdGhlIHRpbWUgaGVyZVxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCcnKTtcclxuICAgIFxyXG4gICAgLy8gR2V0dGluZyBlbGVtZW50c1xyXG4gICAgdGhpcy4kdGV4dGFyZWEgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCd0ZXh0YXJlYScpO1xyXG4gICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMuJHRleHRhcmVhLmdldCgwKTtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlciBmb3IgdGhlICdzYXZlZCcgZXZlbnQgc28gdGhlIGFjdGl2aXR5XHJcbiAgICAvLyByZXR1cm5zIGJhY2sgdG8gdGhlIHJlcXVlc3RlciBhY3Rpdml0eSBnaXZpbmcgaXRcclxuICAgIC8vIHRoZSBuZXcgdGV4dFxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwsXHJcbiAgICAgICAgZXZlbnQ6ICdzYXZlZCcsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5mbyB3aXRoIHRoZSBuZXcgdGV4dFxyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REYXRhLnRleHQgPSB0aGlzLnZpZXdNb2RlbC50ZXh0KCk7XHJcbiAgICAgICAgICAgIC8vIGFuZCBwYXNzIGl0IGJhY2tcclxuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZXIgdGhlIGNhbmNlbCBldmVudFxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwsXHJcbiAgICAgICAgZXZlbnQ6ICdjYW5jZWwnLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4sIG5vdGhpbmcgY2hhbmdlZFxyXG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgXHJcbiAgICAvLyBTZXQgbmF2aWdhdGlvbiB0aXRsZSBvciBub3RoaW5nXHJcbiAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCh0aGlzLnJlcXVlc3REYXRhLnRpdGxlIHx8ICcnKTtcclxuICAgIFxyXG4gICAgLy8gRmllbGQgaGVhZGVyXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXJUZXh0KHRoaXMucmVxdWVzdERhdGEuaGVhZGVyKTtcclxuICAgIHRoaXMudmlld01vZGVsLnRleHQodGhpcy5yZXF1ZXN0RGF0YS50ZXh0KTtcclxuICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLnJvd3NOdW1iZXIpXHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwucm93c051bWJlcih0aGlzLnJlcXVlc3REYXRhLnJvd3NOdW1iZXIpO1xyXG4gICAgICAgIFxyXG4gICAgLy8gSW5tZWRpYXRlIGZvY3VzIHRvIHRoZSB0ZXh0YXJlYSBmb3IgYmV0dGVyIHVzYWJpbGl0eVxyXG4gICAgdGhpcy50ZXh0YXJlYS5mb2N1cygpO1xyXG4gICAgdGhpcy4kdGV4dGFyZWEuY2xpY2soKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcclxuXHJcbiAgICB0aGlzLmhlYWRlclRleHQgPSBrby5vYnNlcnZhYmxlKCdUZXh0Jyk7XHJcblxyXG4gICAgLy8gVGV4dCB0byBlZGl0XHJcbiAgICB0aGlzLnRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIFxyXG4gICAgLy8gTnVtYmVyIG9mIHJvd3MgZm9yIHRoZSB0ZXh0YXJlYVxyXG4gICAgdGhpcy5yb3dzTnVtYmVyID0ga28ub2JzZXJ2YWJsZSgyKTtcclxuXHJcbiAgICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3NhdmVkJyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5WaWV3TW9kZWwuX2luaGVyaXRzKEV2ZW50RW1pdHRlcik7XHJcbiIsIi8qKlxyXG4gICAgV2Vla2x5U2NoZWR1bGUgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBXZWVrbHlTY2hlZHVsZUFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XHJcblxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnc2NoZWR1bGluZydcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUsXHJcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBlcnIudGFzayA9PT0gJ3NhdmUnID8gJ0Vycm9yIHNhdmluZyB5b3VyIHdlZWtseSBzY2hlZHVsZS4nIDogJ0Vycm9yIGxvYWRpbmcgeW91ciB3ZWVrbHkgc2NoZWR1bGUuJztcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcclxuICAgIHRoaXMuYXBwLm1vZGVsLnNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5zeW5jKCk7XHJcbiAgICAvLyBEaXNjYXJkIGFueSBwcmV2aW91cyB1bnNhdmVkIGVkaXRcclxuICAgIHRoaXMudmlld01vZGVsLmRpc2NhcmQoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuXHJcbiAgICB2YXIgc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlID0gYXBwLm1vZGVsLnNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZTtcclxuXHJcbiAgICB2YXIgc2NoZWR1bGVWZXJzaW9uID0gc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLm5ld1ZlcnNpb24oKTtcclxuICAgIHNjaGVkdWxlVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XHJcbiAgICAgICAgaWYgKGl0SXMpIHtcclxuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xyXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXHJcbiAgICAgICAgICAgIC8vIGNvbmZpcm1hdGlvbiB0byBsb2FkIHRoZW0gb3IgZGlzY2FyZCBhbmQgb3ZlcndyaXRlIHRoZW07XHJcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIHNlcnZlciB2ZXJzaW9uKS5cclxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxyXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcclxuICAgICAgICAgICAgc2NoZWR1bGVWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQWN0dWFsIGRhdGEgZm9yIHRoZSBmb3JtOlxyXG4gICAgdGhpcy5zY2hlZHVsZSA9IHNjaGVkdWxlVmVyc2lvbi52ZXJzaW9uO1xyXG5cclxuICAgIHRoaXMuaXNMb2NrZWQgPSBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUuaXNMb2NrZWQ7XHJcblxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICdsb2FkaW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgICAgICAnU2F2ZSdcclxuICAgICAgICApO1xyXG4gICAgfSwgc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlKTtcclxuICAgIFxyXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcclxuICAgICAgICBzY2hlZHVsZVZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xyXG4gICAgICAgIC8vIEZvcmNlIHRvIHNhdmUsIGV2ZW4gaWYgdGhlcmUgd2FzIHJlbW90ZSB1cGRhdGVzXHJcbiAgICAgICAgc2NoZWR1bGVWZXJzaW9uLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcclxuICAgICAgICBcclxuICAgICAgICBhcHAuc3VjY2Vzc1NhdmUoKTtcclxuICAgIH07XHJcbn1cclxuIiwiLyoqXHJcbiAgICBSZWdpc3RyYXRpb24gb2YgY3VzdG9tIGh0bWwgY29tcG9uZW50cyB1c2VkIGJ5IHRoZSBBcHAuXHJcbiAgICBBbGwgd2l0aCAnYXBwLScgYXMgcHJlZml4LlxyXG4gICAgXHJcbiAgICBTb21lIGRlZmluaXRpb25zIG1heSBiZSBpbmNsdWRlZCBvbi1saW5lIHJhdGhlciB0aGFuIG9uIHNlcGFyYXRlZFxyXG4gICAgZmlsZXMgKHZpZXdtb2RlbHMpLCB0ZW1wbGF0ZXMgYXJlIGxpbmtlZCBzbyBuZWVkIHRvIGJlIFxyXG4gICAgaW5jbHVkZWQgaW4gdGhlIGh0bWwgZmlsZSB3aXRoIHRoZSBzYW1lIElEIHRoYXQgcmVmZXJlbmNlZCBoZXJlLFxyXG4gICAgdXN1YWxseSB1c2luZyBhcyBET00gSUQgdGhlIHNhbWUgbmFtZSBhcyB0aGUgY29tcG9uZW50IHdpdGggc3VmaXggJy10ZW1wbGF0ZScuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgcHJvcFRvb2xzID0gcmVxdWlyZSgnLi91dGlscy9qc1Byb3BlcnRpZXNUb29scycpLFxyXG4gICAgZ2V0T2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0T2JzZXJ2YWJsZScpO1xyXG5cclxuZXhwb3J0cy5yZWdpc3RlckFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgXHJcbiAgICAvLy8gbmF2YmFyLWFjdGlvblxyXG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlcignYXBwLW5hdmJhci1hY3Rpb24nLCB7XHJcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ25hdmJhci1hY3Rpb24tdGVtcGxhdGUnIH0sXHJcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcclxuXHJcbiAgICAgICAgICAgIHByb3BUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ2FjdGlvbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYWN0aW9uICYmIHBhcmFtcy5uYXZCYXIoKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5hdkJhcigpW3BhcmFtcy5hY3Rpb25dKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLy8gdW5sYWJlbGVkLWlucHV0XHJcbiAgICBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdhcHAtdW5sYWJlbGVkLWlucHV0Jywge1xyXG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICd1bmxhYmVsZWQtaW5wdXQtdGVtcGxhdGUnIH0sXHJcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5wbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSA9IGdldE9ic2VydmFibGUocGFyYW1zLmRpc2FibGUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHVzZXJBdHRyID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuYXR0cik7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0ciA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gdXNlckF0dHIoKSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgYXR0ciwge1xyXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5wbGFjZWhvbGRlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMudHlwZSk7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUoKSB8fCAndGV4dCc7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLy8gZmVlZGJhY2stZW50cnlcclxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1mZWVkYmFjay1lbnRyeScsIHtcclxuICAgICAgICB0ZW1wbGF0ZTogeyBlbGVtZW50OiAnZmVlZGJhY2stZW50cnktdGVtcGxhdGUnIH0sXHJcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvbiA9IGdldE9ic2VydmFibGUocGFyYW1zLnNlY3Rpb24gfHwgJycpO1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnL2ZlZWRiYWNrLycgKyB0aGlzLnNlY3Rpb24oKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vLyBmZWVkYmFjay1lbnRyeVxyXG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlcignYXBwLXRpbWUtc2xvdC10aWxlJywge1xyXG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICd0aW1lLXNsb3QtdGlsZS10ZW1wbGF0ZScgfSxcclxuICAgICAgICB2aWV3TW9kZWw6IHJlcXVpcmUoJy4vdmlld21vZGVscy9UaW1lU2xvdCcpXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8vIGxvYWRpbmctc3Bpbm5lclxyXG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlcignYXBwLWxvYWRpbmctc3Bpbm5lcicsIHtcclxuICAgICAgICB0ZW1wbGF0ZTogeyBlbGVtZW50OiAnbG9hZGluZy1zcGlubmVyLXRlbXBsYXRlJyB9LFxyXG4gICAgICAgIHZpZXdNb2RlbDogZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlID0gJ2xvYWRpbmdTcGlubmVyJztcclxuICAgICAgICAgICAgdGhpcy5tb2QgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5tb2QgfHwgJycpO1xyXG4gICAgICAgICAgICB0aGlzLmNzc0NsYXNzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBiYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZHMgPSAodGhpcy5tb2QoKSB8fCAnJykuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChtb2RzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjICs9ICcgJyArIGJhc2UgKyAnLS0nICsgbW9kcy5qb2luKCcgJyArIGJhc2UgKyAnLS0nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8vIGFwcG9pbnRtZW50LWNhcmRcclxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1hcHBvaW50bWVudC1jYXJkJywge1xyXG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICdhcHBvaW50bWVudC1jYXJkLXRlbXBsYXRlJyB9LFxyXG4gICAgICAgIHZpZXdNb2RlbDogcmVxdWlyZSgnLi92aWV3bW9kZWxzL0FwcG9pbnRtZW50Q2FyZCcpXHJcbiAgICB9KTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBOYXZiYXIgZXh0ZW5zaW9uIG9mIHRoZSBBcHAsXHJcbiAgICBhZGRzIHRoZSBlbGVtZW50cyB0byBtYW5hZ2UgYSB2aWV3IG1vZGVsXHJcbiAgICBmb3IgdGhlIE5hdkJhciBhbmQgYXV0b21hdGljIGNoYW5nZXNcclxuICAgIHVuZGVyIHNvbWUgbW9kZWwgY2hhbmdlcyBsaWtlIHVzZXIgbG9naW4vbG9nb3V0XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgTmF2QmFyID0gcmVxdWlyZSgnLi92aWV3bW9kZWxzL05hdkJhcicpLFxyXG4gICAgTmF2QWN0aW9uID0gcmVxdWlyZSgnLi92aWV3bW9kZWxzL05hdkFjdGlvbicpO1xyXG5cclxuZXhwb3J0cy5leHRlbmRzID0gZnVuY3Rpb24gKGFwcCkge1xyXG4gICAgXHJcbiAgICAvLyBSRVZJRVc6IHN0aWxsIG5lZWRlZD8gTWF5YmUgdGhlIHBlciBhY3Rpdml0eSBuYXZCYXIgbWVhbnNcclxuICAgIC8vIHRoaXMgaXMgbm90IG5lZWRlZC4gU29tZSBwcmV2aW91cyBsb2dpYyB3YXMgYWxyZWFkeSByZW1vdmVkXHJcbiAgICAvLyBiZWNhdXNlIHdhcyB1c2VsZXNzLlxyXG4gICAgLy9cclxuICAgIC8vIEFkanVzdCB0aGUgbmF2YmFyIHNldHVwIGRlcGVuZGluZyBvbiBjdXJyZW50IHVzZXIsXHJcbiAgICAvLyBzaW5jZSBkaWZmZXJlbnQgdGhpbmdzIGFyZSBuZWVkIGZvciBsb2dnZWQtaW4vb3V0LlxyXG4gICAgZnVuY3Rpb24gYWRqdXN0VXNlckJhcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHVzZXIgPSBhcHAubW9kZWwudXNlcigpO1xyXG5cclxuICAgICAgICBpZiAodXNlci5pc0Fub255bW91cygpKSB7XHJcbiAgICAgICAgICAgIGFwcC5uYXZCYXIoKS5yaWdodEFjdGlvbihOYXZBY3Rpb24ubWVudU91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ29tbWVudGVkIGxpbmVzLCB1c2VkIHByZXZpb3VzbHkgYnV0IHVudXNlZCBub3csIGl0IG11c3QgYmUgZW5vdWdoIHdpdGggdGhlIHVwZGF0ZVxyXG4gICAgLy8gcGVyIGFjdGl2aXR5IGNoYW5nZVxyXG4gICAgLy9hcHAubW9kZWwudXNlcigpLmlzQW5vbnltb3VzLnN1YnNjcmliZSh1cGRhdGVTdGF0ZXNPblVzZXJDaGFuZ2UpO1xyXG4gICAgLy9hcHAubW9kZWwudXNlcigpLm9uYm9hcmRpbmdTdGVwLnN1YnNjcmliZSh1cGRhdGVTdGF0ZXNPblVzZXJDaGFuZ2UpO1xyXG4gICAgXHJcbiAgICBhcHAubmF2QmFyID0ga28ub2JzZXJ2YWJsZShudWxsKTtcclxuICAgIFxyXG4gICAgdmFyIHJlZnJlc2hOYXYgPSBmdW5jdGlvbiByZWZyZXNoTmF2KCkge1xyXG4gICAgICAgIC8vIFRyaWdnZXIgZXZlbnQgdG8gZm9yY2UgYSBjb21wb25lbnQgdXBkYXRlXHJcbiAgICAgICAgJCgnLkFwcE5hdicpLnRyaWdnZXIoJ2NvbnRlbnRDaGFuZ2UnKTtcclxuICAgIH07XHJcbiAgICB2YXIgYXV0b1JlZnJlc2hOYXYgPSBmdW5jdGlvbiBhdXRvUmVmcmVzaE5hdihhY3Rpb24pIHtcclxuICAgICAgICBpZiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbi50ZXh0LnN1YnNjcmliZShyZWZyZXNoTmF2KTtcclxuICAgICAgICAgICAgYWN0aW9uLmlzVGl0bGUuc3Vic2NyaWJlKHJlZnJlc2hOYXYpO1xyXG4gICAgICAgICAgICBhY3Rpb24uaWNvbi5zdWJzY3JpYmUocmVmcmVzaE5hdik7XHJcbiAgICAgICAgICAgIGFjdGlvbi5pc01lbnUuc3Vic2NyaWJlKHJlZnJlc2hOYXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgVXBkYXRlIHRoZSBuYXYgbW9kZWwgdXNpbmcgdGhlIEFjdGl2aXR5IGRlZmF1bHRzXHJcbiAgICAqKi9cclxuICAgIGFwcC51cGRhdGVBcHBOYXYgPSBmdW5jdGlvbiB1cGRhdGVBcHBOYXYoYWN0aXZpdHkpIHtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGFjdGl2aXR5IGhhcyBpdHMgb3duXHJcbiAgICAgICAgaWYgKCduYXZCYXInIGluIGFjdGl2aXR5KSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSBzcGVjaWFsaXppZWQgYWN0aXZpdHkgYmFyIGRhdGFcclxuICAgICAgICAgICAgYXBwLm5hdkJhcihhY3Rpdml0eS5uYXZCYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgb25lXHJcbiAgICAgICAgICAgIGFwcC5uYXZCYXIobmV3IE5hdkJhcigpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gRG91YmxlIGNoZWNrIGlmIG5lZWRlZC5cclxuICAgICAgICAvLyBMYXRlc3QgY2hhbmdlcywgd2hlbiBuZWVkZWRcclxuICAgICAgICBhZGp1c3RVc2VyQmFyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmVmcmVzaE5hdigpO1xyXG4gICAgICAgIGF1dG9SZWZyZXNoTmF2KGFwcC5uYXZCYXIoKS5sZWZ0QWN0aW9uKCkpO1xyXG4gICAgICAgIGF1dG9SZWZyZXNoTmF2KGFwcC5uYXZCYXIoKS5yaWdodEFjdGlvbigpKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgVXBkYXRlIHRoZSBhcHAgbWVudSB0byBoaWdobGlnaHQgdGhlXHJcbiAgICAgICAgZ2l2ZW4gbGluayBuYW1lXHJcbiAgICAqKi9cclxuICAgIGFwcC51cGRhdGVNZW51ID0gZnVuY3Rpb24gdXBkYXRlTWVudShuYW1lKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyICRtZW51ID0gJCgnLkFwcC1tZW51cyAubmF2YmFyLWNvbGxhcHNlJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBhY3RpdmVcclxuICAgICAgICAkbWVudVxyXG4gICAgICAgIC5maW5kKCdsaScpXHJcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAvLyBBZGQgYWN0aXZlXHJcbiAgICAgICAgJG1lbnVcclxuICAgICAgICAuZmluZCgnLmdvLScgKyBuYW1lKVxyXG4gICAgICAgIC5jbG9zZXN0KCdsaScpXHJcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAvLyBIaWRlIG1lbnVcclxuICAgICAgICAkbWVudVxyXG4gICAgICAgIC5maWx0ZXIoJzp2aXNpYmxlJylcclxuICAgICAgICAuY29sbGFwc2UoJ2hpZGUnKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwcC5zZXR1cE5hdkJhckJpbmRpbmcgPSBmdW5jdGlvbiBzZXR1cE5hdkJhckJpbmRpbmcoKSB7XHJcbiAgICAgICAgLy8gU2V0IG1vZGVsIGZvciB0aGUgQXBwTmF2XHJcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyh7XHJcbiAgICAgICAgICAgIG5hdkJhcjogYXBwLm5hdkJhclxyXG4gICAgICAgIH0sICQoJy5BcHBOYXYnKS5nZXQoMCkpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUGVyZm9ybXMgdGhlICdiYWNrJyB0YXNrIGZyb20gdGhlIG5hdmJhciBsaW5rLCBpZiBhbnkuXHJcbiAgICAgICAgVGhhdCBpcywgdHJpZ2dlciB0aGUgbGVmdCBhY3Rpb24uXHJcbiAgICAgICAgRmFsbGJhY2sgdG8gc2hlbGwgZ29CYWNrXHJcbiAgICAqKi9cclxuICAgIGFwcC5wZXJmb3Jtc05hdkJhckJhY2sgPSBmdW5jdGlvbiBwZXJmb3Jtc05hdkJhckJhY2soKSB7XHJcbiAgICAgICAgdmFyIG5hdiA9IHRoaXMubmF2QmFyKCksXHJcbiAgICAgICAgICAgIGxlZnQgPSBuYXYgJiYgbmF2LmxlZnRBY3Rpb24oKSxcclxuICAgICAgICAgICAgJGJ0biA9ICQoJy5TbWFydE5hdkJhci1lZGdlLmxlZnQgPiAuU21hcnROYXZCYXItYnRuJyk7XHJcblxyXG4gICAgICAgIC8vIFRoZXJlIGlzIGFuIGFjdGlvbiwgdHJpZ2dlciBsaWtlIGEgY2xpY2sgc28gYWxsIHRoZSBoYW5kbGVyc1xyXG4gICAgICAgIC8vIGF0dGFjaGVkIG9uIHNwYXJlIHBsYWNlcyBkbyB0aGVpciB3b3JrOlxyXG4gICAgICAgIGlmIChsZWZ0KSB7XHJcbiAgICAgICAgICAgICRidG4udHJpZ2dlcigndGFwJykudHJpZ2dlcignY2xpY2snKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaGVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNoZWxsLmdvQmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEl0IHNob3dzIGFuIHVub2J0cnVzaXZlIG5vdGlmaWNhdGlvbiBvbiB0aGUgbmF2YmFyIHBsYWNlLCB0aGF0XHJcbiAgICAgICAgaGlkZXMgYWZ0ZXIgYSBzaG9ydCB0aW1lb3V0XHJcbiAgICAqKi9cclxuICAgIHZhciBsYXN0Tm90aWZpY2F0aW9uVGltZXIgPSBudWxsO1xyXG4gICAgYXBwLnNob3dOYXZCYXJOb3RpZmljYXRpb24gPSBmdW5jdGlvbiBzaG93TmF2QmFyTm90aWZpY2F0aW9uKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IHNldHRpbmdzICYmIHNldHRpbmdzLm1lc3NhZ2UgfHwgJ0hlbGxvIFdvcmxkIScsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gc2V0dGluZ3MgJiYgc2V0dGluZ3MuZHVyYXRpb24gfHwgMjAwMCxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gc2V0dGluZ3MgJiYgc2V0dGluZ3MudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDQwMCxcclxuICAgICAgICAgICAgJGVsID0gJCgnLkFwcE5hdiAuU21hcnROYXZCYXItbm90aWZpY2F0aW9uJyk7XHJcblxyXG4gICAgICAgICRlbC50ZXh0KG1zZyk7XHJcbiAgICAgICAgJGVsLmZhZGVJbih0cmFuc2l0aW9uRHVyYXRpb24pXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTWFudWFsIGhpZGUgb24gdGFwcGluZ1xyXG4gICAgICAgICAgICAkZWxcclxuICAgICAgICAgICAgLm9mZigndGFwLm1hbnVhbEhpZGUnKVxyXG4gICAgICAgICAgICAub24oJ3RhcC5tYW51YWxIaWRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkZWwuZmFkZU91dCh0cmFuc2l0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEF1dG8gaGlkZSBhZnRlciB0aW1lb3V0XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChsYXN0Tm90aWZpY2F0aW9uVGltZXIpO1xyXG4gICAgICAgICAgICBsYXN0Tm90aWZpY2F0aW9uVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJGVsLmZhZGVPdXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuICAgICAgICAgICAgfSwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgJCh0aGlzKS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xyXG4iLCIvKipcclxuICAgIExpc3Qgb2YgYWN0aXZpdGllcyBsb2FkZWQgaW4gdGhlIEFwcCxcclxuICAgIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBhY3Rpdml0eSBuYW1lIGFzIHRoZSBrZXlcclxuICAgIGFuZCB0aGUgY29udHJvbGxlciBhcyB2YWx1ZS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgJ2NhbGVuZGFyJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NhbGVuZGFyJyksXHJcbiAgICAnZGF0ZXRpbWVQaWNrZXInOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvZGF0ZXRpbWVQaWNrZXInKSxcclxuICAgICdjbGllbnRzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NsaWVudHMnKSxcclxuICAgICdmcmVlbGFuY2VyUHJpY2luZyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9mcmVlbGFuY2VyUHJpY2luZycpLFxyXG4gICAgJ3NlcnZpY2VBZGRyZXNzZXMnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvc2VydmljZUFkZHJlc3NlcycpLFxyXG4gICAgJ3RleHRFZGl0b3InOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvdGV4dEVkaXRvcicpLFxyXG4gICAgJ2hvbWUnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvaG9tZScpLFxyXG4gICAgJ2FwcG9pbnRtZW50JzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2FwcG9pbnRtZW50JyksXHJcbiAgICAnYm9va2luZ0NvbmZpcm1hdGlvbic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9ib29raW5nQ29uZmlybWF0aW9uJyksXHJcbiAgICAnaW5kZXgnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvaW5kZXgnKSxcclxuICAgICdsb2dpbic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9sb2dpbicpLFxyXG4gICAgJ2xvZ291dCc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9sb2dvdXQnKSxcclxuICAgICdsZWFybk1vcmUnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvbGVhcm5Nb3JlJyksXHJcbiAgICAnc2lnbnVwJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3NpZ251cCcpLFxyXG4gICAgJ2NvbnRhY3RJbmZvJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NvbnRhY3RJbmZvJyksXHJcbiAgICAnb25ib2FyZGluZ1Bvc2l0aW9ucyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9vbmJvYXJkaW5nUG9zaXRpb25zJyksXHJcbiAgICAnb25ib2FyZGluZ0hvbWUnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvb25ib2FyZGluZ0hvbWUnKSxcclxuICAgICdhZGRyZXNzRWRpdG9yJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2FkZHJlc3NFZGl0b3InKSxcclxuICAgICdvbmJvYXJkaW5nQ29tcGxldGUnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvb25ib2FyZGluZ0NvbXBsZXRlJyksXHJcbiAgICAnYWNjb3VudCc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9hY2NvdW50JyksXHJcbiAgICAnaW5ib3gnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvaW5ib3gnKSxcclxuICAgICdjb252ZXJzYXRpb24nOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvY29udmVyc2F0aW9uJyksXHJcbiAgICAnc2NoZWR1bGluZyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9zY2hlZHVsaW5nJyksXHJcbiAgICAnam9idGl0bGVzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2pvYnRpdGxlcycpLFxyXG4gICAgJ2ZlZWRiYWNrJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2ZlZWRiYWNrJyksXHJcbiAgICAnZmFxcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9mYXFzJyksXHJcbiAgICAnZmVlZGJhY2tGb3JtJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2ZlZWRiYWNrRm9ybScpLFxyXG4gICAgJ2NvbnRhY3RGb3JtJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NvbnRhY3RGb3JtJyksXHJcbiAgICAnY21zJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NtcycpLFxyXG4gICAgJ2NsaWVudEVkaXRvcic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9jbGllbnRFZGl0b3InKSxcclxuICAgICdzY2hlZHVsaW5nUHJlZmVyZW5jZXMnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvc2NoZWR1bGluZ1ByZWZlcmVuY2VzJyksXHJcbiAgICAnY2FsZW5kYXJTeW5jaW5nJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NhbGVuZGFyU3luY2luZycpLFxyXG4gICAgJ3dlZWtseVNjaGVkdWxlJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3dlZWtseVNjaGVkdWxlJyksXHJcbiAgICAnYm9va01lQnV0dG9uJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2Jvb2tNZUJ1dHRvbicpLFxyXG4gICAgJ293bmVySW5mbyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9vd25lckluZm8nKSxcclxuICAgICdwcml2YWN5U2V0dGluZ3MnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvcHJpdmFjeVNldHRpbmdzJyksXHJcbiAgICAnYWRkSm9iVGl0bGVzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2FkZEpvYlRpdGxlcycpLFxyXG4gICAgJ2ZyZWVsYW5jZXJQcmljaW5nRWRpdG9yJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2ZyZWVsYW5jZXJQcmljaW5nRWRpdG9yJylcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqIEdsb2JhbCBkZXBlbmRlbmNpZXMgKiovXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbnJlcXVpcmUoJ2pxdWVyeS1tb2JpbGUnKTtcclxucmVxdWlyZSgnLi91dGlscy9qcXVlcnkubXVsdGlsaW5lJyk7XHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcbmtvLmJpbmRpbmdIYW5kbGVycy5mb3JtYXQgPSByZXF1aXJlKCdrby9mb3JtYXRCaW5kaW5nJykuZm9ybWF0QmluZGluZztcclxudmFyIGJvb3Rrbm9jayA9IHJlcXVpcmUoJy4vdXRpbHMvYm9vdGtub2NrQmluZGluZ0hlbHBlcnMnKTtcclxucmVxdWlyZSgnLi91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUuX2luaGVyaXRzJyk7XHJcbnJlcXVpcmUoJy4vdXRpbHMvRnVuY3Rpb24ucHJvdG90eXBlLl9kZWxheWVkJyk7XHJcbi8vIFBvbHlmaWxsIGZvciB1c2VmdWwgbm9uLXN0YW5kYXJkIGZlYXR1cmUgRnVuY3Rpb24ubmFtZSBmb3IgSUU5K1xyXG4vLyAoZmVhdHVyZSB1c2VkIHRvIHNpbXBsaWZ5IGNyZWF0aW9uIG9mIEFjdGl2aXRpZXMgYW5kIE1vZGVscylcclxucmVxdWlyZSgnLi91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUubmFtZS1wb2x5ZmlsbCcpO1xyXG4vLyBQcm9taXNlIHBvbHlmaWxsLCBzbyBpdHMgbm90ICdyZXF1aXJlJ2QgcGVyIG1vZHVsZTpcclxucmVxdWlyZSgnZXM2LXByb21pc2UnKS5wb2x5ZmlsbCgpO1xyXG5cclxudmFyIGxheW91dFVwZGF0ZUV2ZW50ID0gcmVxdWlyZSgnbGF5b3V0VXBkYXRlRXZlbnQnKTtcclxudmFyIEFwcE1vZGVsID0gcmVxdWlyZSgnLi92aWV3bW9kZWxzL0FwcE1vZGVsJyk7XHJcblxyXG4vLyBSZWdpc3RlciB0aGUgc3BlY2lhbCBsb2NhbGVcclxucmVxdWlyZSgnLi9sb2NhbGVzL2VuLVVTLUxDJyk7XHJcblxyXG4vKipcclxuICAgIEEgc2V0IG9mIGZpeGVzL3dvcmthcm91bmRzIGZvciBCb290c3RyYXAgYmVoYXZpb3IvcGx1Z2luc1xyXG4gICAgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIEJvb3RzdHJhcCBpcyBpbmNsdWRlZC9leGVjdXRlZC5cclxuICAgIEZvciBleGFtcGxlLCBiZWNhdXNlIG9mIGRhdGEtYmluZGluZyByZW1vdmluZy9jcmVhdGluZyBlbGVtZW50cyxcclxuICAgIHNvbWUgb2xkIHJlZmVyZW5jZXMgdG8gcmVtb3ZlZCBpdGVtcyBtYXkgZ2V0IGFsaXZlIGFuZCBuZWVkIHVwZGF0ZSxcclxuICAgIG9yIHJlLWVuYWJsaW5nIHNvbWUgYmVoYXZpb3JzLlxyXG4qKi9cclxuZnVuY3Rpb24gcHJlQm9vdHN0cmFwV29ya2Fyb3VuZHMoKSB7XHJcbiAgICAvLyBJbnRlcm5hbCBCb290c3RyYXAgc291cmNlIHV0aWxpdHlcclxuICAgIGZ1bmN0aW9uIGdldFRhcmdldEZyb21UcmlnZ2VyKCR0cmlnZ2VyKSB7XHJcbiAgICAgICAgdmFyIGhyZWYsXHJcbiAgICAgICAgICAgIHRhcmdldCA9ICR0cmlnZ2VyLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHxcclxuICAgICAgICAgICAgKGhyZWYgPSAkdHJpZ2dlci5hdHRyKCdocmVmJykpICYmIFxyXG4gICAgICAgICAgICBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKTsgLy8gc3RyaXAgZm9yIGllN1xyXG5cclxuICAgICAgICByZXR1cm4gJCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBCdWc6IG5hdmJhci1jb2xsYXBzZSBlbGVtZW50cyBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZWlyIG9yaWdpbmFsXHJcbiAgICAvLyAkdHJpZ2dlciwgYnV0IHRoYXQgdHJpZ2dlciBjYW4gY2hhbmdlIG9uIGRpZmZlcmVudCAnY2xpY2tzJyBvclxyXG4gICAgLy8gZ2V0IHJlbW92ZWQgdGhlIG9yaWdpbmFsLCBzbyBpdCBtdXN0IHJlZmVyZW5jZSB0aGUgbmV3IG9uZVxyXG4gICAgLy8gKHRoZSBsYXRlc3RzIGNsaWNrZWQsIGFuZCBub3QgdGhlIGNhY2hlZCBvbmUgdW5kZXIgdGhlICdkYXRhJyBBUEkpLiAgICBcclxuICAgIC8vIE5PVEU6IGhhbmRsZXIgbXVzdCBleGVjdXRlIGJlZm9yZSB0aGUgQm9vdHN0cmFwIGhhbmRsZXIgZm9yIHRoZSBzYW1lXHJcbiAgICAvLyBldmVudCBpbiBvcmRlciB0byB3b3JrLlxyXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmNvbGxhcHNlLmRhdGEtYXBpLndvcmthcm91bmQnLCAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgJHQgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICAkdGFyZ2V0ID0gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHQpLFxyXG4gICAgICAgICAgICBkYXRhID0gJHRhcmdldCAmJiAkdGFyZ2V0LmRhdGEoJ2JzLmNvbGxhcHNlJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgYW55XHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgdHJpZ2dlciBpbiB0aGUgZGF0YSByZWZlcmVuY2U6XHJcbiAgICAgICAgICAgIGRhdGEuJHRyaWdnZXIgPSAkdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT24gZWxzZSwgbm90aGluZyB0byBkbywgYSBuZXcgQ29sbGFwc2UgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXHJcbiAgICAgICAgLy8gd2l0aCB0aGUgY29ycmVjdCB0YXJnZXQsIHRoZSBmaXJzdCB0aW1lXHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAgICBBcHAgc3RhdGljIGNsYXNzXHJcbioqL1xyXG52YXIgYXBwID0ge1xyXG4gICAgc2hlbGw6IHJlcXVpcmUoJy4vYXBwLnNoZWxsJyksXHJcbiAgICBcclxuICAgIC8vIE5ldyBhcHAgbW9kZWwsIHRoYXQgc3RhcnRzIHdpdGggYW5vbnltb3VzIHVzZXJcclxuICAgIG1vZGVsOiBuZXcgQXBwTW9kZWwoKSxcclxuICAgIFxyXG4gICAgLyoqIExvYWQgYWN0aXZpdGllcyBjb250cm9sbGVycyAobm90IGluaXRpYWxpemVkKSAqKi9cclxuICAgIGFjdGl2aXRpZXM6IHJlcXVpcmUoJy4vYXBwLmFjdGl2aXRpZXMnKSxcclxuICAgIFxyXG4gICAgbW9kYWxzOiByZXF1aXJlKCcuL2FwcC5tb2RhbHMnKSxcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgSnVzdCByZWRpcmVjdCB0aGUgYmV0dGVyIHBsYWNlIGZvciBjdXJyZW50IHVzZXIgYW5kIHN0YXRlLlxyXG4gICAgICAgIE5PVEU6IEl0cyBhIGRlbGF5ZWQgZnVuY3Rpb24sIHNpbmNlIG9uIG1hbnkgY29udGV4dHMgbmVlZCB0b1xyXG4gICAgICAgIHdhaXQgZm9yIHRoZSBjdXJyZW50ICdyb3V0aW5nJyBmcm9tIGVuZCBiZWZvcmUgZG8gdGhlIG5ld1xyXG4gICAgICAgIGhpc3RvcnkgY2hhbmdlLlxyXG4gICAgICAgIFRPRE86IE1heWJlLCByYXRoZXIgdGhhbiBkZWxheSBpdCwgY2FuIHN0b3AgY3VycmVudCByb3V0aW5nXHJcbiAgICAgICAgKGNoYW5nZXMgb24gU2hlbGwgcmVxdWlyZWQpIGFuZCBwZXJmb3JtIHRoZSBuZXcuXHJcbiAgICAgICAgVE9ETzogTWF5YmUgYWx0ZXJuYXRpdmUgdG8gcHJldmlvdXMsIHRvIHByb3ZpZGUgYSAncmVwbGFjZSdcclxuICAgICAgICBpbiBzaGVsbCByYXRoZXIgdGhhbiBhIGdvLCB0byBhdm9pZCBhcHBlbmQgcmVkaXJlY3QgZW50cmllc1xyXG4gICAgICAgIGluIHRoZSBoaXN0b3J5LCB0aGF0IGNyZWF0ZSB0aGUgcHJvYmxlbSBvZiAnYnJva2VuIGJhY2sgYnV0dG9uJ1xyXG4gICAgKiovXHJcbiAgICBnb0Rhc2hib2FyZDogZnVuY3Rpb24gZ29EYXNoYm9hcmQoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVG8gYXZvaWQgaW5maW5pdGUgbG9vcHMgaWYgd2UgYWxyZWFkeSBhcmUgcGVyZm9ybWluZyBcclxuICAgICAgICAvLyBhIGdvRGFzaGJvYXJkIHRhc2ssIHdlIGZsYWcgdGhlIGV4ZWN1dGlvblxyXG4gICAgICAgIC8vIGJlaW5nIGNhcmUgb2YgdGhlIGRlbGF5IGludHJvZHVjZWQgaW4gdGhlIGV4ZWN1dGlvblxyXG4gICAgICAgIGlmIChnb0Rhc2hib2FyZC5fZ29pbmcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGVsYXllZCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggaW4tdGhlLW1pZGRsZVxyXG4gICAgICAgICAgICAvLyB0YXNrczoganVzdCBhbGxvd2luZyBjdXJyZW50IHJvdXRpbmcgdG8gZmluaXNoXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZSBwZXJmb3JtIHRoZSAncmVkaXJlY3QnXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGNoYW5nZSBieSBhIHJlYWwgcmVkaXJlY3QgdGhhdCBpcyBhYmxlIHRvXHJcbiAgICAgICAgICAgIC8vIGNhbmNlbCB0aGUgY3VycmVudCBhcHAuc2hlbGwgcm91dGluZyBwcm9jZXNzLlxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZ29EYXNoYm9hcmQuX2dvaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb25ib2FyZGluZyA9IHRoaXMubW9kZWwudXNlcigpLm9uYm9hcmRpbmdTdGVwKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9uYm9hcmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWxsLmdvKCdvbmJvYXJkaW5nSG9tZS8nICsgb25ib2FyZGluZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWxsLmdvKCdob21lJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSnVzdCBiZWNhdXNlIGlzIGRlbGF5ZWQsIG5lZWRzXHJcbiAgICAgICAgICAgICAgICAvLyB0byBiZSBzZXQgb2ZmIGFmdGVyIGFuIGlubWVkaWF0ZSB0byBcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBpcyBzZXQgb2ZmIGFmdGVyIGFueSBvdGhlciBhdHRlbXB0XHJcbiAgICAgICAgICAgICAgICAvLyB0byBhZGQgYSBkZWxheWVkIGdvRGFzaGJvYXJkOlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBnb0Rhc2hib2FyZC5fZ29pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKiBDb250aW51ZSBhcHAgY3JlYXRpb24gd2l0aCB0aGluZ3MgdGhhdCBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSBhcHAgKiovXHJcblxyXG5yZXF1aXJlKCcuL2FwcC1uYXZiYXInKS5leHRlbmRzKGFwcCk7XHJcblxyXG5yZXF1aXJlKCcuL2FwcC1jb21wb25lbnRzJykucmVnaXN0ZXJBbGwoKTtcclxuXHJcbmFwcC5nZXRBY3Rpdml0eSA9IGZ1bmN0aW9uIGdldEFjdGl2aXR5KG5hbWUpIHtcclxuICAgIHZhciBhY3Rpdml0eSA9IHRoaXMuYWN0aXZpdGllc1tuYW1lXTtcclxuICAgIGlmIChhY3Rpdml0eSkge1xyXG4gICAgICAgIHZhciAkYWN0ID0gdGhpcy5zaGVsbC5pdGVtcy5maW5kKG5hbWUpO1xyXG4gICAgICAgIGlmICgkYWN0ICYmICRhY3QubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gYWN0aXZpdHkuaW5pdCgkYWN0LCB0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuYXBwLmdldEFjdGl2aXR5Q29udHJvbGxlckJ5Um91dGUgPSBmdW5jdGlvbiBnZXRBY3Rpdml0eUNvbnRyb2xsZXJCeVJvdXRlKHJvdXRlKSB7XHJcbiAgICAvLyBGcm9tIHRoZSByb3V0ZSBvYmplY3QsIHRoZSBpbXBvcnRhbnQgcGllY2UgaXMgcm91dGUubmFtZVxyXG4gICAgLy8gdGhhdCBjb250YWlucyB0aGUgYWN0aXZpdHkgbmFtZSBleGNlcHQgaWYgaXMgdGhlIHJvb3RcclxuICAgIHZhciBhY3ROYW1lID0gcm91dGUubmFtZSB8fCB0aGlzLnNoZWxsLmluZGV4TmFtZTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZpdHkoYWN0TmFtZSk7XHJcbn07XHJcblxyXG4vLyBhY2Nlc3NDb250cm9sIHNldHVwOiBjYW5ub3QgYmUgc3BlY2lmaWVkIG9uIFNoZWxsIGNyZWF0aW9uIGJlY2F1c2VcclxuLy8gZGVwZW5kcyBvbiB0aGUgYXBwIGluc3RhbmNlXHJcbmFwcC5zaGVsbC5hY2Nlc3NDb250cm9sID0gcmVxdWlyZSgnLi91dGlscy9hY2Nlc3NDb250cm9sJykoYXBwKTtcclxuXHJcbi8vIFNob3J0Y3V0IHRvIFVzZXJUeXBlIGVudW1lcmF0aW9uIHVzZWQgdG8gc2V0IHBlcm1pc3Npb25zXHJcbmFwcC5Vc2VyVHlwZSA9IHJlcXVpcmUoJy4vbW9kZWxzL1VzZXInKS5Vc2VyVHlwZTtcclxuXHJcbi8vIE5ldyBtZXRob2QgZm9yIGNvbW1vbiBmb3JtcyBiZWhhdmlvciBhZnRlciBhIHN1Y2Nlc3NmdWwgc2F2ZSBvcGVyYXRpb24sXHJcbi8vIHRoZSBhY3Rpdml0eSBnb2VzIGJhY2sgKGZvbGxvd2luZyB0aGUgbmF2YmFyIGJhY2stbGluayBvciBzaGVsbC5nb0JhY2soKSlcclxuLy8gYW5kIG5vdGlmeWluZyB3aXRoIGEgdGVtcG9yYXJ5IHVub2J0cnVzaXZlIG5hdmJhciBub3RpZmljYXRpb25cclxuYXBwLnN1Y2Nlc3NTYXZlID0gZnVuY3Rpb24gc3VjY2Vzc1NhdmUoc2V0dGluZ3MpIHtcclxuICAgIC8vIGRlZmF1bHRzXHJcbiAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHtcclxuICAgICAgICBtZXNzYWdlOiAnWW91ciBjaGFuZ2VzIGhhdmUgYmVlbiBzYXZlZCdcclxuICAgIH0sIHNldHRpbmdzKTtcclxuICAgIC8vIGdvIGJhY2tcclxuICAgIHRoaXMucGVyZm9ybXNOYXZCYXJCYWNrKCk7XHJcbiAgICAvLyBzaG93IG5vdGlmaWNhdGlvblxyXG4gICAgdGhpcy5zaG93TmF2QmFyTm90aWZpY2F0aW9uKHNldHRpbmdzKTtcclxufTtcclxuXHJcbi8qKiBBcHAgSW5pdCAqKi9cclxudmFyIGFwcEluaXQgPSBmdW5jdGlvbiBhcHBJbml0KCkge1xyXG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czo1MCxtYXhjb21wbGV4aXR5OjE2ICovXHJcbiAgICBcclxuICAgIC8vIEVuYWJsaW5nIHRoZSAnbGF5b3V0VXBkYXRlJyBqUXVlcnkgV2luZG93IGV2ZW50IHRoYXQgaGFwcGVucyBvbiByZXNpemUgYW5kIHRyYW5zaXRpb25lbmQsXHJcbiAgICAvLyBhbmQgY2FuIGJlIHRyaWdnZXJlZCBtYW51YWxseSBieSBhbnkgc2NyaXB0IHRvIG5vdGlmeSBjaGFuZ2VzIG9uIGxheW91dCB0aGF0XHJcbiAgICAvLyBtYXkgcmVxdWlyZSBhZGp1c3RtZW50cyBvbiBvdGhlciBzY3JpcHRzIHRoYXQgbGlzdGVuIHRvIGl0LlxyXG4gICAgLy8gVGhlIGV2ZW50IGlzIHRocm90dGxlLCBndWFyYW50aW5nIHRoYXQgdGhlIG1pbm9yIGhhbmRsZXJzIGFyZSBleGVjdXRlZCByYXRoZXJcclxuICAgIC8vIHRoYW4gYSBsb3Qgb2YgdGhlbSBpbiBzaG9ydCB0aW1lIGZyYW1lcyAoYXMgaGFwcGVuIHdpdGggJ3Jlc2l6ZScgZXZlbnRzKS5cclxuICAgIGxheW91dFVwZGF0ZUV2ZW50LmxheW91dFVwZGF0ZUV2ZW50ICs9ICcgb3JpZW50YXRpb25jaGFuZ2UnO1xyXG4gICAgbGF5b3V0VXBkYXRlRXZlbnQub24oKTtcclxuICAgIFxyXG4gICAgLy8gS2V5Ym9hcmQgcGx1Z2luIGV2ZW50cyBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCBqUXVlcnkgZXZlbnRzLCBidXQgbmVlZGVkIHRvXHJcbiAgICAvLyB0cmlnZ2VyIGEgbGF5b3V0VXBkYXRlLCBzbyBoZXJlIGFyZSBjb25uZWN0ZWQsIG1haW5seSBmaXhpbmcgYnVncyBvbiBpT1Mgd2hlbiB0aGUga2V5Ym9hcmRcclxuICAgIC8vIGlzIGhpZGRpbmcuXHJcbiAgICB2YXIgdHJpZ0xheW91dCA9IGZ1bmN0aW9uIHRyaWdMYXlvdXQoKSB7XHJcbiAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2xheW91dFVwZGF0ZScpO1xyXG4gICAgfTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRzaG93JywgdHJpZ0xheW91dCk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkaGlkZScsIHRyaWdMYXlvdXQpO1xyXG5cclxuICAgIC8vIGlPUy03KyBzdGF0dXMgYmFyIGZpeC4gQXBwbHkgb24gcGx1Z2luIGxvYWRlZCAoY29yZG92YS9waG9uZWdhcCBlbnZpcm9ubWVudClcclxuICAgIC8vIGFuZCBpbiBhbnkgc3lzdGVtLCBzbyBhbnkgb3RoZXIgc3lzdGVtcyBmaXggaXRzIHNvbHZlZCB0b28gaWYgbmVlZGVkIFxyXG4gICAgLy8ganVzdCB1cGRhdGluZyB0aGUgcGx1Z2luIChmdXR1cmUgcHJvb2YpIGFuZCBlbnN1cmUgaG9tb2dlbmVvdXMgY3Jvc3MgcGxhZnRmb3JtIGJlaGF2aW9yLlxyXG4gICAgaWYgKHdpbmRvdy5TdGF0dXNCYXIpIHtcclxuICAgICAgICAvLyBGaXggaU9TLTcrIG92ZXJsYXkgcHJvYmxlbVxyXG4gICAgICAgIC8vIElzIGluIGNvbmZpZy54bWwgdG9vLCBidXQgc2VlbXMgbm90IHRvIHdvcmsgd2l0aG91dCBuZXh0IGNhbGw6XHJcbiAgICAgICAgd2luZG93LlN0YXR1c0Jhci5vdmVybGF5c1dlYlZpZXcoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGlPUzcrOCBidWdzIHdpdGggaGVpZ2h0IGNhbGN1bGF0aW9uLFxyXG4gICAgLy8gYSBkaWZmZXJlbnQgd2F5IG9mIGFwcGx5IGNvbnRlbnQgaGVpZ2h0IHRvIGZpbGwgYWxsIHRoZSBhdmFpbGFibGUgaGVpZ2h0IChhcyBtaW5pbXVtKVxyXG4gICAgLy8gaXMgcmVxdWlyZWQuXHJcbiAgICAvLyBGb3IgdGhhdCwgdGhlICdmdWxsLWhlaWdodCcgY2xhc3Mgd2FzIGFkZGVkLCB0byBiZSB1c2VkIGluIGVsZW1lbnRzIGluc2lkZSB0aGUgXHJcbiAgICAvLyBhY3Rpdml0eSB0aGF0IG5lZWRzIGFsbCB0aGUgYXZhaWxhYmxlIGhlaWdodCwgaGVyZSB0aGUgY2FsY3VsYXRpb24gaXMgYXBwbGllZCBmb3JcclxuICAgIC8vIGFsbCBwbGF0Zm9ybXMgZm9yIHRoaXMgaG9tb2dlbmVvdXMgYXBwcm9hY2ggdG8gc29sdmUgdGhlIHByb2JsZW1tLlxyXG4gICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkYiA9ICQoJ2JvZHknKTtcclxuICAgICAgICB2YXIgZnVsbEhlaWdodCA9IGZ1bmN0aW9uIGZ1bGxIZWlnaHQoKSB7XHJcbiAgICAgICAgICAgIHZhciBoID0gJGIuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICQoJy5mdWxsLWhlaWdodCcpXHJcbiAgICAgICAgICAgIC8vIExldCBicm93c2VyIHRvIGNvbXB1dGVcclxuICAgICAgICAgICAgLmNzcygnaGVpZ2h0JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAvLyBBcyBtaW5pbXVtXHJcbiAgICAgICAgICAgIC5jc3MoJ21pbi1oZWlnaHQnLCBoKVxyXG4gICAgICAgICAgICAvLyBTZXQgZXhwbGljaXQgdGhlIGF1dG9tYXRpYyBjb21wdXRlZCBoZWlnaHRcclxuICAgICAgICAgICAgLmNzcygnaGVpZ2h0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgYm94LXNpemluZzpib3JkZXItYm94LCBzbyBuZWVkcyB0byBiZSBvdXRlckhlaWdodCB3aXRob3V0IG1hcmdpbjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLm91dGVySGVpZ2h0KGZhbHNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBmdWxsSGVpZ2h0KCk7XHJcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdsYXlvdXRVcGRhdGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZnVsbEhlaWdodCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSkoKTtcclxuICAgIFxyXG4gICAgLy8gRm9yY2UgYW4gdXBkYXRlIGRlbGF5ZWQgdG8gZW5zdXJlIHVwZGF0ZSBhZnRlciBzb21lIHRoaW5ncyBkaWQgYWRkaXRpb25hbCB3b3JrXHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICQod2luZG93KS50cmlnZ2VyKCdsYXlvdXRVcGRhdGUnKTtcclxuICAgIH0sIDIwMCk7XHJcbiAgICBcclxuICAgIC8vIEJvb3RzdHJhcFxyXG4gICAgcHJlQm9vdHN0cmFwV29ya2Fyb3VuZHMoKTtcclxuICAgIHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xyXG4gICAgXHJcbiAgICAvLyBMb2FkIEtub2Nrb3V0IGJpbmRpbmcgaGVscGVyc1xyXG4gICAgYm9vdGtub2NrLnBsdWdJbihrbyk7XHJcbiAgICByZXF1aXJlKCcuL3V0aWxzL2Jvb3RzdHJhcFN3aXRjaEJpbmRpbmcnKS5wbHVnSW4oa28pO1xyXG4gICAgXHJcbiAgICAvLyBQbHVnaW5zIHNldHVwXHJcbiAgICBpZiAod2luZG93LmNvcmRvdmEgJiYgd2luZG93LmNvcmRvdmEucGx1Z2lucyAmJiB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkKSB7XHJcbiAgICAgICAgLy8gRXhwbGljaXRlbHksIHdlIFdBTlQgYXV0byBzY3JvbGwgb24ga2V5Ym9hcmQgc2hvdyB1cC5cclxuICAgICAgICAvLyBDYW4gYmUgZGlzYWJsZWQgb25seSBpZiB0aGVyZSBpcyBhIGphdmFzY3JpcHQgc29sdXRpb24gdG8gYXV0b3Njcm9sbFxyXG4gICAgICAgIC8vIG9uIGlucHV0IGZvY3VzLCBlbHNlIGEgYnVnIHdpbGwgaGFwcGVuIHNwZWNpYWxseSBvbiBpT1Mgd2hlcmUgaW5wdXRcclxuICAgICAgICAvLyBmaWVsZHMgZ2V0cyBoaWRkZW4gYnkgdGhlIG9uIHNjcmVlbiBrZXlib2FyZC5cclxuICAgICAgICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmRpc2FibGVTY3JvbGwoZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFYXN5IGxpbmtzIHRvIHNoZWxsIGFjdGlvbnMsIGxpa2UgZ29CYWNrLCBpbiBodG1sIGVsZW1lbnRzXHJcbiAgICAvLyBFeGFtcGxlOiA8YnV0dG9uIGRhdGEtc2hlbGw9XCJnb0JhY2sgMlwiPkdvIDIgdGltZXMgYmFjazwvYnV0dG9uPlxyXG4gICAgLy8gTk9URTogSW1wb3J0YW50LCByZWdpc3RlcmVkIGJlZm9yZSB0aGUgc2hlbGwucnVuIHRvIGJlIGV4ZWN1dGVkXHJcbiAgICAvLyBiZWZvcmUgaXRzICdjYXRjaCBhbGwgbGlua3MnIGhhbmRsZXJcclxuICAgICQoZG9jdW1lbnQpLm9uKCd0YXAnLCAnW2RhdGEtc2hlbGxdJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIC8vIFVzaW5nIGF0dHIgcmF0aGVyIHRoYW4gdGhlICdkYXRhJyBBUEkgdG8gZ2V0IHVwZGF0ZWRcclxuICAgICAgICAvLyBET00gdmFsdWVzXHJcbiAgICAgICAgdmFyIGNtZGxpbmUgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtc2hlbGwnKSB8fCAnJyxcclxuICAgICAgICAgICAgYXJncyA9IGNtZGxpbmUuc3BsaXQoJyAnKSxcclxuICAgICAgICAgICAgY21kID0gYXJnc1swXTtcclxuXHJcbiAgICAgICAgaWYgKGNtZCAmJiB0eXBlb2YoYXBwLnNoZWxsW2NtZF0pID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGFwcC5zaGVsbFtjbWRdLmFwcGx5KGFwcC5zaGVsbCwgYXJncy5zbGljZSgxKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDYW5jZWwgYW55IG90aGVyIGFjdGlvbiBvbiB0aGUgbGluaywgdG8gYXZvaWQgZG91YmxlIGxpbmtpbmcgcmVzdWx0c1xyXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIE9uIENvcmRvdmEvUGhvbmVnYXAgYXBwLCBzcGVjaWFsIHRhcmdldHMgbXVzdCBiZSBjYWxsZWQgdXNpbmcgdGhlIHdpbmRvdy5vcGVuXHJcbiAgICAvLyBBUEkgdG8gZW5zdXJlIGlzIGNvcnJlY3RseSBvcGVuZWQgb24gdGhlIEluQXBwQnJvd3NlciAoX2JsYW5rKSBvciBzeXN0ZW0gZGVmYXVsdFxyXG4gICAgLy8gYnJvd3NlciAoX3N5c3RlbSkuXHJcbiAgICBpZiAod2luZG93LmNvcmRvdmEpIHtcclxuICAgICAgICAkKGRvY3VtZW50KS5vbigndGFwJywgJ1t0YXJnZXQ9XCJfYmxhbmtcIl0sIFt0YXJnZXQ9XCJfc3lzdGVtXCJdJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpLCB0aGlzLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFdoZW4gYW4gYWN0aXZpdHkgaXMgcmVhZHkgaW4gdGhlIFNoZWxsOlxyXG4gICAgYXBwLnNoZWxsLm9uKGFwcC5zaGVsbC5ldmVudHMuaXRlbVJlYWR5LCBmdW5jdGlvbigkYWN0LCBzdGF0ZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbm5lY3QgdGhlICdhY3Rpdml0aWVzJyBjb250cm9sbGVycyB0byB0aGVpciB2aWV3c1xyXG4gICAgICAgIC8vIEdldCBpbml0aWFsaXplZCBhY3Rpdml0eSBmb3IgdGhlIERPTSBlbGVtZW50XHJcbiAgICAgICAgdmFyIGFjdE5hbWUgPSAkYWN0LmRhdGEoJ2FjdGl2aXR5Jyk7XHJcbiAgICAgICAgdmFyIGFjdGl2aXR5ID0gYXBwLmdldEFjdGl2aXR5KGFjdE5hbWUpO1xyXG4gICAgICAgIC8vIFRyaWdnZXIgdGhlICdzaG93JyBsb2dpYyBvZiB0aGUgYWN0aXZpdHkgY29udHJvbGxlcjpcclxuICAgICAgICBhY3Rpdml0eS5zaG93KHN0YXRlKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIG1lbnVcclxuICAgICAgICB2YXIgbWVudUl0ZW0gPSBhY3Rpdml0eS5tZW51SXRlbSB8fCBhY3ROYW1lO1xyXG4gICAgICAgIGFwcC51cGRhdGVNZW51KG1lbnVJdGVtKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgYXBwIG5hdmlnYXRpb25cclxuICAgICAgICBhcHAudXBkYXRlQXBwTmF2KGFjdGl2aXR5KTtcclxuICAgIH0pO1xyXG4gICAgLy8gV2hlbiBhbiBhY3Rpdml0eSBpcyBoaWRkZW5cclxuICAgIGFwcC5zaGVsbC5vbihhcHAuc2hlbGwuZXZlbnRzLmNsb3NlZCwgZnVuY3Rpb24oJGFjdCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbm5lY3QgdGhlICdhY3Rpdml0aWVzJyBjb250cm9sbGVycyB0byB0aGVpciB2aWV3c1xyXG4gICAgICAgIHZhciBhY3ROYW1lID0gJGFjdC5kYXRhKCdhY3Rpdml0eScpO1xyXG4gICAgICAgIHZhciBhY3Rpdml0eSA9IGFwcC5nZXRBY3Rpdml0eShhY3ROYW1lKTtcclxuICAgICAgICAvLyBUcmlnZ2VyIHRoZSAnaGlkZScgbG9naWMgb2YgdGhlIGFjdGl2aXR5IGNvbnRyb2xsZXI6XHJcbiAgICAgICAgaWYgKGFjdGl2aXR5LmhpZGUpXHJcbiAgICAgICAgICAgIGFjdGl2aXR5LmhpZGUoKTtcclxuICAgIH0pO1xyXG4gICAgLy8gQ2F0Y2ggZXJyb3JzIG9uIGl0ZW0vcGFnZSBsb2FkaW5nLCBzaG93aW5nLi5cclxuICAgIGFwcC5zaGVsbC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7IGVycm9yOiBlcnIgfSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQXR0ZW1wdCBzY3JvbGwgb24gY2xpY2tpbmcgYSB1c3VhbCBmcmFnbWVudCBsaW5rXHJcbiAgICAvLyBUT0RPOiB0aGVyZSBpcyBzb21lIGtpbmQgb2YgcHJvYmxlbSBzb21ldGltZXMgYW5kXHJcbiAgICAvLyBkb2VzIG5vdCBnZXQgY29ycmVjbHR5IGFsaWduZWQsIGludmVzdGlnYXRlXHJcbiAgICAvLyBXT1JLQVJPVU5EIGEgZml4ZWQgdmFsdWUgYXMgb2Zmc2V0IHRvIGF2b2lkIGZvciBub3dcclxuICAgIHZhciBzY3JvbGxUbyA9IGZ1bmN0aW9uIHNjcm9sbFRvKGVsKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xyXG5cclxuICAgICAgICB3aGlsZShwYXJlbnQuZ2V0KDApICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBlbC5vZmZzZXQoKS50b3AgLSBwYXJlbnQub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgICAgICB2YXIgc3QgPSBwYXJlbnQuc2Nyb2xsVG9wKCkgKyB0O1xyXG4gICAgICAgICAgICAvLyBXT1JLQVJPVU5EIENPTlNUQU5UIE9GRlNFVFxyXG4gICAgICAgICAgICBzdCAtPSA0NTtcclxuICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcChzdCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGFwcC5zaGVsbC5vbignZnJhZ21lbnROYXZpZ2F0aW9uJywgZnVuY3Rpb24oaHJlZikge1xyXG4gICAgICAgIC8vIExvY2F0ZSB0YXJnZXRcclxuICAgICAgICAvLyAoaHJlZiBjb21lcyB3aXRoIHRoZSBpbml0aWFsIGhhc2ggZXZlcilcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gJChocmVmKTtcclxuICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzY3JvbGxUbyh0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBOYXZiYXIgYmluZGluZ1xyXG4gICAgYXBwLnNldHVwTmF2QmFyQmluZGluZygpO1xyXG4gICAgXHJcbiAgICB2YXIgU21hcnROYXZCYXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvU21hcnROYXZCYXInKTtcclxuICAgIHZhciBuYXZCYXJzID0gU21hcnROYXZCYXIuZ2V0QWxsKCk7XHJcbiAgICAvLyBDcmVhdGVzIGFuIGV2ZW50IGJ5IGxpc3RlbmluZyB0byBpdCwgc28gb3RoZXIgc2NyaXB0cyBjYW4gdHJpZ2dlclxyXG4gICAgLy8gYSAnY29udGVudENoYW5nZScgZXZlbnQgdG8gZm9yY2UgYSByZWZyZXNoIG9mIHRoZSBuYXZiYXIgKHRvIFxyXG4gICAgLy8gY2FsY3VsYXRlIGFuZCBhcHBseSBhIG5ldyBzaXplKTsgZXhwZWN0ZWQgZnJvbSBkeW5hbWljIG5hdmJhcnNcclxuICAgIC8vIHRoYXQgY2hhbmdlIGl0IGNvbnRlbnQgYmFzZWQgb24gb2JzZXJ2YWJsZXMuXHJcbiAgICBuYXZCYXJzLmZvckVhY2goZnVuY3Rpb24obmF2YmFyKSB7XHJcbiAgICAgICAgJChuYXZiYXIuZWwpLm9uKCdjb250ZW50Q2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIG5hdmJhci5yZWZyZXNoKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gTGlzdGVuIGZvciBtZW51IGV2ZW50cyAoY29sbGFwc2UgaW4gU21hcnROYXZCYXIpXHJcbiAgICAvLyB0byBhcHBseSB0aGUgYmFja2Ryb3BcclxuICAgIHZhciB0b2dnbGluZ0JhY2tkcm9wID0gZmFsc2U7XHJcbiAgICAkKGRvY3VtZW50KS5vbignc2hvdy5icy5jb2xsYXBzZSBoaWRlLmJzLmNvbGxhcHNlJywgJy5BcHBOYXYgLm5hdmJhci1jb2xsYXBzZScsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAoIXRvZ2dsaW5nQmFja2Ryb3ApIHtcclxuICAgICAgICAgICAgdG9nZ2xpbmdCYWNrZHJvcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBlbmFibGVkID0gZS50eXBlID09PSAnc2hvdyc7XHJcbiAgICAgICAgICAgICQoJ2JvZHknKS50b2dnbGVDbGFzcygndXNlLWJhY2tkcm9wJywgZW5hYmxlZCk7XHJcbiAgICAgICAgICAgIC8vIEhpZGUgYW55IG90aGVyIG9wZW5lZCBjb2xsYXBzZVxyXG4gICAgICAgICAgICAkKCcuY29sbGFwc2luZywgLmNvbGxhcHNlLmluJykuY29sbGFwc2UoJ2hpZGUnKTtcclxuICAgICAgICAgICAgdG9nZ2xpbmdCYWNrZHJvcCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENhdGNoIHVuY2F0Y2ggbW9kZWwgZXJyb3JzXHJcbiAgICBhcHAubW9kZWwub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQWRkaXRpb25hbCBmb3JtIGVsZW1lbnRzIGF0dHJpYnV0ZSBhbmQgYmVoYXZpb3I6IGRhdGEtYXV0b3NlbGVjdD10cnVlXHJcbiAgICAvLyBzZXRzIHRvIGF1dG9tYXRpY2FsbHkgc2VsZWN0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gaW5wdXQgdGV4dCBjb250cm9sXHJcbiAgICAvLyB3aGVuIGdldHMgdGhlIGZvY3VzXHJcbiAgICAkKGRvY3VtZW50KS5vbignZm9jdXMnLCAnW2RhdGEtYXV0b3NlbGVjdD1cInRydWVcIl0nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEFwcCBpbml0OlxyXG4gICAgdmFyIGFsZXJ0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcnLFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFwcC5tb2RlbC5pbml0KClcclxuICAgIC50aGVuKGFwcC5zaGVsbC5ydW4uYmluZChhcHAuc2hlbGwpLCBhbGVydEVycm9yKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgcGFnZSBhcyByZWFkeVxyXG4gICAgICAgICQoJ2h0bWwnKS5hZGRDbGFzcygnaXMtcmVhZHknKTtcclxuICAgICAgICAvLyBBcyBhcHAsIGhpZGVzIHNwbGFzaCBzY3JlZW5cclxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnNwbGFzaHNjcmVlbikge1xyXG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnNwbGFzaHNjcmVlbi5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgYWxlcnRFcnJvcik7XHJcblxyXG4gICAgLy8gREVCVUdcclxuICAgIHdpbmRvdy5hcHAgPSBhcHA7XHJcbn07XHJcblxyXG4vLyBBcHAgaW5pdCBvbiBwYWdlIHJlYWR5IGFuZCBwaG9uZWdhcCByZWFkeVxyXG5pZiAod2luZG93LmNvcmRvdmEpIHtcclxuICAgIC8vIE9uIERPTS1SZWFkeSBmaXJzdFxyXG4gICAgJChmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBQYWdlIGlzIHJlYWR5LCBkZXZpY2UgaXMgdG9vP1xyXG4gICAgICAgIC8vIE5vdGU6IENvcmRvdmEgZW5zdXJlcyB0byBjYWxsIHRoZSBoYW5kbGVyIGV2ZW4gaWYgdGhlXHJcbiAgICAgICAgLy8gZXZlbnQgd2FzIGFscmVhZHkgZmlyZWQsIHNvIGlzIGdvb2QgdG8gZG8gaXQgaW5zaWRlXHJcbiAgICAgICAgLy8gdGhlIGRvbS1yZWFkeSBhbmQgd2UgYXJlIGVuc3VyaW5nIHRoYXQgZXZlcnl0aGluZyBpc1xyXG4gICAgICAgIC8vIHJlYWR5LlxyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdkZXZpY2VyZWFkeScsIGFwcEluaXQpO1xyXG4gICAgfSk7XHJcbn0gZWxzZSB7XHJcbiAgICAvLyBPbmx5IG9uIERPTS1SZWFkeSwgZm9yIGluIGJyb3dzZXIgZGV2ZWxvcG1lbnRcclxuICAgICQoYXBwSW5pdCk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBBY2Nlc3MgdG8gdXNlIGdsb2JhbCBBcHAgTW9kYWxzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5cclxuLyoqXHJcbiAgICBHZW5lcmF0ZXMgYSB0ZXh0IG1lc3NhZ2UsIHdpdGggbmV3bGluZXMgaWYgbmVlZGVkLCBkZXNjcmliaW5nIHRoZSBlcnJvclxyXG4gICAgb2JqZWN0IHBhc3NlZC5cclxuICAgIEBwYXJhbSBlcnI6YW55IEFzIGEgc3RyaW5nLCBpcyByZXR1cm5lZCAnYXMgaXMnOyBhcyBmYWxzeSwgaXQgcmV0dXJuIGEgZ2VuZXJpY1xyXG4gICAgbWVzc2FnZSBmb3IgJ3Vua25vdyBlcnJvcic7IGFzIG9iamVjdCwgaXQgaW52ZXN0aWdhdGUgd2hhdCB0eXBlIG9mIGVycm9yIGlzIHRvXHJcbiAgICBwcm92aWRlIHRoZSBtb3JlIG1lYW5pbmZ1bCByZXN1bHQsIHdpdGggZmFsbGJhY2sgdG8gSlNPTi5zdHJpbmdpZnkgcHJlZml4ZWRcclxuICAgIHdpdGggJ1RlY2huaWNhbCBkZXRhaWxzOicuXHJcbiAgICBPYmplY3RzIHJlY29nbml6ZWQ6XHJcbiAgICAtIFhIUi9qUXVlcnkgZm9yIEpTT04gcmVzcG9uc2VzOiBqdXN0IG9iamVjdHMgd2l0aCByZXNwb25zZUpTT04gcHJvcGVydHksIGlzXHJcbiAgICAgIHVzZWQgYXMgdGhlICdlcnInIG9iamVjdCBhbmQgcGFzc2VkIHRvIHRoZSBvdGhlciBvYmplY3QgdGVzdHMuXHJcbiAgICAtIE9iamVjdCB3aXRoICdlcnJvck1lc3NhZ2UnIChzZXJ2ZXItc2lkZSBmb3JtYXR0ZWQgZXJyb3IpLlxyXG4gICAgLSBPYmplY3Qgd2l0aCAnbWVzc2FnZScgcHJvcGVydHksIGxpa2UgdGhlIHN0YW5kYXJkIEVycm9yIGNsYXNzIGFuZCBFeGNlcHRpb24gb2JqZWN0cy5cclxuICAgIC0gT2JqZWN0IHdpdGggJ25hbWUnIHByb3BlcnR5LCBsaWtlIHRoZSBzdGFuZGFyZCBFeGNlcHRpb24gb2JqZWN0cy4gVGhlIG5hbWUsIGlmIGFueSxcclxuICAgICAgaXMgc2V0IGFzIHByZWZpeCBmb3IgdGhlICdtZXNzYWdlJyBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgIC0gT2JqZWN0IHdpdGggJ2Vycm9ycycgcHJvcGVydHkuIEVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgb3Igb2JqZWN0IG93biBrZXlzXHJcbiAgICAgIGlzIGFwcGVuZGVkIHRvIHRoZSBlcnJvck1lc3NhZ2Ugb3IgbWVzc2FnZSBzZXBhcmF0ZWQgYnkgbmV3bGluZS5cclxuKiovXHJcbmV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlRnJvbSA9IGZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZUZyb20oZXJyLCBkZWZhdWx0VGV4dCkge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxNCwgbWF4ZGVwdGg6NSovXHJcblxyXG4gICAgZGVmYXVsdFRleHQgPSBkZWZhdWx0VGV4dCB8fCAnVW5rbm93IGVycm9yJztcclxuICAgIFxyXG4gICAgaWYgKCFlcnIpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFRleHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YoZXJyKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZXJyIHx8IGRlZmF1bHRUZXh0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgaXMgYSBYSFIgb2JqZWN0LCB1c2UgaXRzIHJlc3BvbnNlIGFzIHRoZSBlcnJvci5cclxuICAgICAgICBlcnIgPSBlcnIucmVzcG9uc2VKU09OIHx8IGVycjtcclxuXHJcbiAgICAgICAgdmFyIG1zZyA9IGVyci5uYW1lICYmIChlcnIubmFtZSArICc6ICcpIHx8ICcnO1xyXG4gICAgICAgIG1zZyArPSBlcnIuZXJyb3JNZXNzYWdlIHx8IGVyci5tZXNzYWdlIHx8ICcnO1xyXG5cclxuICAgICAgICBpZiAoZXJyLmVycm9ycykge1xyXG4gICAgICAgICAgICBtc2cgKz0gJ1xcbicgKyBleHBvcnRzLnN0cmluZ2lmeUVycm9yc0xpc3QoZXJyLmVycm9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBdm9pZGluZyB0aGF0IGVuIGVycm9yIGNvbnZlcnRpbmcgdGhlIG9iamVjdCAoY2lyY3VsYXIgcmVmZXJlbmNlcylcclxuICAgICAgICAgICAgLy8gYnJlYWtzIHRoZSBlcnJvciBjb250cm9sIVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGpzZXJyID0gSlNPTi5zdHJpbmdpZnkoZXJyKTtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkaW5nIHRoYXQgZW1wdHkgcmVzdWx0cyAoZW1wdHkgc3RyaW5nIG9yIGVtcHR5IG9iamVjdCB3aGVuIHRoZXJlXHJcbiAgICAgICAgICAgICAgICAvLyBpcyBubyBkZXRhaWxzIHRvIHNob3cpIG1ha2VzIHVzIHRvIHNob3cgYW4gYW5ub3lpbmcgJ3RlY2huaWNhbCBkZXRhaWxzJ1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc01vcmVJbmZvID0ganNlcnIgJiYganNlcnIgIT09ICd7fSc7XHJcbiAgICAgICAgICAgICAgICAvLyBUb28gaWYgdGhlcmUgaXMgbm8gbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZSBvbmUgZXh0cmFjdGVkIHRvIGJ1aWxkIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gbWVzc2FnZSwgc2luY2Ugb24gdGhhdCBjYXNlcyB0aGUgJ3RlY2huaWNhbCBkZXRhaWxzJyB3aWxsIGJlIGp1c3QgYSBcclxuICAgICAgICAgICAgICAgIC8vIGpzb24gZm9ybWF0dGVkIG9mIHRoZSBzYW1lIGRpc3BsYXllZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW9yZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBpbml0aWFsbHksIHJlLWVuYWJsZWQgb25seSBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhbiB0aGUgb25lcyBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTW9yZUluZm8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZVByb3BlcnRpZXNMaXN0ID0gWyduYW1lJywgJ2Vycm9yTWVzc2FnZScsICdtZXNzYWdlJywgJ2Vycm9ycyddO1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVycikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VQcm9wZXJ0aWVzTGlzdC5pbmRleE9mKGtleSkgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzTW9yZUluZm8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNNb3JlSW5mbylcclxuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJ1xcblxcblRlY2huaWNhbCBkZXRhaWxzOiAnICsganNlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1wb3NzaWJsZSB0byBzdHJpbmdpZnkgSlNPTiBlcnJvcicsIGVyciwgZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbXNnIHx8IGRlZmF1bHRUZXh0O1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5zdHJpbmdpZnlFcnJvcnNMaXN0ID0gZnVuY3Rpb24gKGVycm9ycykge1xyXG4gICAgdmFyIG1zZyA9ICcnO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3JzKSkge1xyXG4gICAgICAgIG1zZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1zZyA9IE9iamVjdC5rZXlzKGVycm9ycykubWFwKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzW2tleV0uam9pbignXFxuJyk7XHJcbiAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbXNnO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBTaG93IGFuIGVycm9yIG1vZGFsIHRvIG5vdGlmeSB0aGUgdXNlci5cclxuICAgIEBwYXJhbSBvcHRpb25zOk9iamVjdCB7XHJcbiAgICAgICAgbWVzc2FnZTpzdHJpbmcgREVQUkVDQVRFRC4gT3B0aW9uYWwuIEluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UuXHJcbiAgICAgICAgZXJyb3I6c3RyaW5nIE9wdGlvbmFsLiBFcnJvci9FeGNlcHRpb24vWEhSIG9iamVjdCwgdXNlZCB0byBhdXRvXHJcbiAgICAgICAgICAgIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlLiBJdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgJ21lc3NhZ2UnXHJcbiAgICAgICAgICAgIG9wdGlvbiwgZGlzY2FyZGluZyBhbiBlcnJvciBvYmplY3Qvc3RyaW5nIGlzIHBhc3NlZC5cclxuICAgICAgICAgICAgSXQgcmVwbGFjZXMgJ21lc3NhZ2UnIHNpbmNlIGNhbiBkbyB0aGUgc2FtZSBhbmQgbW9yZS5cclxuICAgICAgICB0aXRsZTpzdHJpbmcgT3B0aW9uYWwuIFRoZSB0ZXh0IHRvIHNob3cgaW4gdGhlIG1vZGFsJ3MgaGVhZGVyLFxyXG4gICAgICAgICAgICB3aXRoIGZhbGxiYWNrIHRvIHRoZSBNb2RhbCdzIGRlZmF1bHQgdGl0bGUuXHJcbiAgICB9XHJcbiAgICBAcmV0dXJucyBQcm9taXNlLiBJdCByZXNvbHZlcyB3aGVuIHRoZSBtb2RhbCBpcyBkaXNtaXNzZWQvY2xvc2VkLlxyXG4gICAgTm8gZm9ybWFsIHJlamVjdGlvbiBoYXBwZW5zLlxyXG4qKi9cclxuZXhwb3J0cy5zaG93RXJyb3IgPSBmdW5jdGlvbiBzaG93RXJyb3JNb2RhbChvcHRpb25zKSB7XHJcbiAgICBcclxuICAgIHZhciBtb2RhbCA9ICQoJyNlcnJvck1vZGFsJyksXHJcbiAgICAgICAgaGVhZGVyID0gbW9kYWwuZmluZCgnI2Vycm9yTW9kYWwtbGFiZWwnKSxcclxuICAgICAgICBib2R5ID0gbW9kYWwuZmluZCgnI2Vycm9yTW9kYWwtYm9keScpO1xyXG4gICAgXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIFxyXG4gICAgLy8gRmFsbGJhY2sgZXJyb3IgbWVzc2FnZVxyXG4gICAgdmFyIG1zZyA9IGJvZHkuZGF0YSgnZGVmYXVsdC10ZXh0Jyk7XHJcblxyXG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmcm9tIGdpdmVuIGVycm9yIG9iamVjdCwgd2l0aCBmYWxsYmFjayB0byBkZWZhdWx0IG9uZS5cclxuICAgIC8vIERFUFJFQ0FURUQgdGVtcG9yYXJseSB1c2luZyB0aGUgJ21lc3NhZ2UnIG9wdGlvbi5cclxuICAgIG1zZyA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlRnJvbShvcHRpb25zLmVycm9yIHx8IG9wdGlvbnMubWVzc2FnZSwgbXNnKTtcclxuXHJcbiAgICBib2R5Lm11bHRpbGluZShtc2cpO1xyXG5cclxuICAgIGhlYWRlci50ZXh0KG9wdGlvbnMudGl0bGUgfHwgaGVhZGVyLmRhdGEoJ2RlZmF1bHQtdGV4dCcpKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcclxuICAgICAgICBtb2RhbC5tb2RhbCgnc2hvdycpO1xyXG4gICAgICAgIG1vZGFsLm9uKCdoaWRlLmJzLm1vZGFsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBTaG93IGNvbmZpcm1hdGlvbiBtb2RhbCB3aXRoIHR3byBidXR0b25zLlxyXG4gICAgQHBhcmFtIG9wdGlvbnM6b2JqZWN0IHtcclxuICAgICAgICB0aXRsZTpzdHJpbmcgSGVhZGVyIHRpdGxlIHRleHRcclxuICAgICAgICBtZXNzYWdlOnN0cmluZyBNZXNzYWdlIHRleHRcclxuICAgICAgICB5ZXM6c3RyaW5nIFllcyBidXR0b24gbGFiZWxcclxuICAgICAgICBubzpzdHJpbmcgTm8gYnV0dG9uIGxhYmVsXHJcbiAgICB9XHJcbiAgICBAcmV0dXJucyBQcm9taXNlLiBJdCByZXNvbHZlcyBpZiBidXR0b24gJ3llcycgcHJlc3NlZFxyXG4gICAgYW5kIHJlamVjdCBvbiBidXR0b24gJ25vJyBwcmVzc2VkIG9yIG1vZGFsIGRpc21pc3NlZC9jbG9zZWQuXHJcbioqL1xyXG5leHBvcnRzLmNvbmZpcm0gPSBmdW5jdGlvbiBjb25maXJtKG9wdGlvbnMpIHtcclxuICAgIFxyXG4gICAgdmFyIG1vZGFsID0gJCgnI2NvbmZpcm1Nb2RhbCcpLFxyXG4gICAgICAgIGhlYWRlciA9IG1vZGFsLmZpbmQoJyNjb25maXJtTW9kYWwtbGFiZWwnKSxcclxuICAgICAgICBib2R5ID0gbW9kYWwuZmluZCgnI2NvbmZpcm1Nb2RhbC1ib2R5JyksXHJcbiAgICAgICAgeWVzQnRuID0gbW9kYWwuZmluZCgnI2NvbmZpcm1Nb2RhbC15ZXNCdG4nKSxcclxuICAgICAgICBub0J0biA9IG1vZGFsLmZpbmQoJyNjb25maXJtTW9kYWwtbm9CdG4nKTtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAvLyBGYWxsYmFjayBlcnJvciBtZXNzYWdlXHJcbiAgICB2YXIgdGl0bGUgPSBoZWFkZXIuZGF0YSgnZGVmYXVsdC10ZXh0JyksXHJcbiAgICAgICAgbXNnID0gYm9keS5kYXRhKCdkZWZhdWx0LXRleHQnKSxcclxuICAgICAgICB5ZXMgPSB5ZXNCdG4uZGF0YSgnZGVmYXVsdC10ZXh0JyksXHJcbiAgICAgICAgbm8gPSBub0J0bi5kYXRhKCdkZWZhdWx0LXRleHQnKTtcclxuXHJcbiAgICBib2R5Lm11bHRpbGluZShvcHRpb25zLm1lc3NhZ2UgfHwgbXNnKTtcclxuICAgIGhlYWRlci50ZXh0KG9wdGlvbnMudGl0bGUgfHwgdGl0bGUpO1xyXG4gICAgeWVzQnRuLnRleHQob3B0aW9ucy55ZXMgfHwgeWVzKTtcclxuICAgIG5vQnRuLnRleHQob3B0aW9ucy5ubyB8fCBubyk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIG1vZGFsLm1vZGFsKCdzaG93Jyk7XHJcbiAgICAgICAgeWVzQnRuLm9uKCd0YXAgY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vQnRuLm9uKCd0YXAgY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW9kYWwub24oJ2hpZGUuYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbiIsIi8qKlxyXG4gICAgU2V0dXAgb2YgdGhlIHNoZWxsIG9iamVjdCB1c2VkIGJ5IHRoZSBhcHBcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBiYXNlVXJsID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xyXG5cclxuLy92YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vYXBwLXNoZWxsLWhpc3RvcnknKS5jcmVhdGUoYmFzZVVybCk7XHJcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi91dGlscy9zaGVsbC9oYXNoYmFuZ0hpc3RvcnknKTtcclxuXHJcbi8vIFNoZWxsIGRlcGVuZGVuY2llc1xyXG52YXIgc2hlbGwgPSByZXF1aXJlKCcuL3V0aWxzL3NoZWxsL2luZGV4JyksXHJcbiAgICBTaGVsbCA9IHNoZWxsLlNoZWxsLFxyXG4gICAgRG9tSXRlbXNNYW5hZ2VyID0gc2hlbGwuRG9tSXRlbXNNYW5hZ2VyO1xyXG5cclxudmFyIGlPUyA9IC8oaVBhZHxpUGhvbmV8aVBvZCkvZy50ZXN0KCBuYXZpZ2F0b3IudXNlckFnZW50ICk7XHJcblxyXG4vLyBDcmVhdGluZyB0aGUgc2hlbGw6XHJcbnZhciBzaGVsbCA9IG5ldyBTaGVsbCh7XHJcblxyXG4gICAgLy8gU2VsZWN0b3IsIERPTSBlbGVtZW50IG9yIGpRdWVyeSBvYmplY3QgcG9pbnRpbmdcclxuICAgIC8vIHRoZSByb290IG9yIGNvbnRhaW5lciBmb3IgdGhlIHNoZWxsIGl0ZW1zXHJcbiAgICByb290OiAnYm9keScsXHJcblxyXG4gICAgLy8gSWYgaXMgbm90IGluIHRoZSBzaXRlIHJvb3QsIHRoZSBiYXNlIFVSTCBpcyByZXF1aXJlZDpcclxuICAgIGJhc2VVcmw6IGJhc2VVcmwsXHJcbiAgICBcclxuICAgIGZvcmNlSGFzaGJhbmc6IHRydWUsXHJcblxyXG4gICAgaW5kZXhOYW1lOiAnaW5kZXgnLFxyXG5cclxuICAgIC8vIFdPUktBUk9VTkQ6IFVzaW5nIHRoZSAndGFwJyBldmVudCBmb3IgZmFzdGVyIG1vYmlsZSBleHBlcmllbmNlXHJcbiAgICAvLyAoZnJvbSBqcXVlcnktbW9iaWxlIGV2ZW50KSBvbiBpT1MgZGV2aWNlcyB3aXRoIGZhbGxiYWNrIHRvICdjbGljaydcclxuICAgIC8vICh0aGUgc2hlbGwgaXMgcmVhZHkgdG8gbWFuYWdlIG11bHRpcGxlIGV2ZW50cyBidXQgZmlyaW5nIG9uY2UpLCBidXQgbGVmdFxyXG4gICAgLy8gJ2NsaWNrJyBvbiBvdGhlcnMgc2luY2UgdGhleSBoYXMgbm90IHRoZSBzbG93LWNsaWNrIHByb2JsZW1cclxuICAgIC8vIHRoYW5rcyB0byB0aGUgbWV0YS12aWV3cG9ydC5cclxuICAgIGxpbmtFdmVudDogaU9TID8gJ3RhcCBjbGljaycgOiAnY2xpY2snLFxyXG5cclxuICAgIC8vIE5vIG5lZWQgZm9yIGxvYWRlciwgZXZlcnl0aGluZyBjb21lcyBidW5kbGVkXHJcbiAgICBsb2FkZXI6IG51bGwsXHJcblxyXG4gICAgLy8gSGlzdG9yeSBQb2x5ZmlsbDpcclxuICAgIGhpc3Rvcnk6IEhpc3RvcnksXHJcblxyXG4gICAgLy8gQSBEb21JdGVtc01hbmFnZXIgb3IgZXF1aXZhbGVudCBvYmplY3QgaW5zdGFuY2UgbmVlZHMgdG9cclxuICAgIC8vIGJlIHByb3ZpZGVkOlxyXG4gICAgZG9tSXRlbXNNYW5hZ2VyOiBuZXcgRG9tSXRlbXNNYW5hZ2VyKHtcclxuICAgICAgICBpZEF0dHJpYnV0ZU5hbWU6ICdkYXRhLWFjdGl2aXR5J1xyXG4gICAgfSlcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNoZWxsO1xyXG4iLCIvKipcclxuICAgIEFjdGl2aXR5IGJhc2UgY2xhc3NcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBOYXZBY3Rpb24gPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL05hdkFjdGlvbicpLFxyXG4gICAgTmF2QmFyID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9OYXZCYXInKTtcclxuXHJcbnJlcXVpcmUoJy4uL3V0aWxzL0Z1bmN0aW9uLnByb3RvdHlwZS5faW5oZXJpdHMnKTtcclxuXHJcbi8qKlxyXG4gICAgQWN0aXZpdHkgY2xhc3MgZGVmaW5pdGlvblxyXG4qKi9cclxuZnVuY3Rpb24gQWN0aXZpdHkoJGFjdGl2aXR5LCBhcHApIHtcclxuXHJcbiAgICB0aGlzLiRhY3Rpdml0eSA9ICRhY3Rpdml0eTtcclxuICAgIHRoaXMuYXBwID0gYXBwO1xyXG5cclxuICAgIC8vIERlZmF1bHQgYWNjZXNzIGxldmVsOiBhbnlvbmVcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSBhcHAuVXNlclR5cGUuTm9uZTtcclxuICAgIFxyXG4gICAgLy8gVE9ETzogRnV0dXJlIHVzZSBvZiBhIHZpZXdTdGF0ZSwgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXHJcbiAgICAvLyBvZiBwYXJ0IG9mIHRoZSB2aWV3TW9kZWwgdG8gYmUgdXNlZCBhcyB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZVxyXG4gICAgLy8gaGlzdG9yeSBhbmQgYmV0d2VlbiBhY3Rpdml0aWVzIGNhbGxzLlxyXG4gICAgdGhpcy52aWV3U3RhdGUgPSB7fTtcclxuICAgIFxyXG4gICAgLy8gT2JqZWN0IHRvIGhvbGQgdGhlIG9wdGlvbnMgcGFzc2VkIG9uICdzaG93JyBhcyBhIHJlc3VsdFxyXG4gICAgLy8gb2YgYSByZXF1ZXN0IGZyb20gYW5vdGhlciBhY3Rpdml0eVxyXG4gICAgdGhpcy5yZXF1ZXN0RGF0YSA9IG51bGw7XHJcblxyXG4gICAgLy8gRGVmYXVsdCBuYXZCYXIgb2JqZWN0LlxyXG4gICAgdGhpcy5uYXZCYXIgPSBuZXcgTmF2QmFyKHtcclxuICAgICAgICB0aXRsZTogbnVsbCwgLy8gbnVsbCBmb3IgbG9nb1xyXG4gICAgICAgIGxlZnRBY3Rpb246IG51bGwsXHJcbiAgICAgICAgcmlnaHRBY3Rpb246IG51bGxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBEZWxheWVkIGJpbmRpbmdzIHRvIGFsbG93IGZvciBmdXJ0aGVyIGNvbnN0cnVjdG9yIHNldC11cCBcclxuICAgIC8vIG9uIHN1YmNsYXNzZXMuXHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIEFjdGl2aXR5Q29uc3RydWN0b3JEZWxheWVkKCkge1xyXG4gICAgICAgIC8vIEEgdmlldyBtb2RlbCBhbmQgYmluZGluZ3MgYmVpbmcgYXBwbGllZCBpcyBldmVyIHJlcXVpcmVkXHJcbiAgICAgICAgLy8gZXZlbiBvbiBBY3Rpdml0aWVzIHdpdGhvdXQgbmVlZCBmb3IgYSB2aWV3IG1vZGVsLCBzaW5jZVxyXG4gICAgICAgIC8vIHRoZSB1c2Ugb2YgY29tcG9uZW50cyBhbmQgdGVtcGxhdGVzLCBvciBhbnkgb3RoZXIgZGF0YS1iaW5kXHJcbiAgICAgICAgLy8gc3ludGF4LCByZXF1aXJlcyB0byBiZSBpbiBhIGNvbnRleHQgd2l0aCBiaW5kaW5nIGVuYWJsZWQ6XHJcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyh0aGlzLnZpZXdNb2RlbCB8fCB7fSwgJGFjdGl2aXR5LmdldCgwKSk7XHJcbiAgICB9LmJpbmQodGhpcyksIDEpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFjdGl2aXR5O1xyXG5cclxuLyoqXHJcbiAgICBTZXQtdXAgdmlzdWFsaXphdGlvbiBvZiB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zL3N0YXRlLFxyXG4gICAgd2l0aCBhIHJlc2V0IG9mIGN1cnJlbnQgc3RhdGUuXHJcbiAgICBNdXN0IGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIGFjdGl2aXR5IGlzIHB1dCBpbiB0aGUgY3VycmVudCB2aWV3LlxyXG4qKi9cclxuQWN0aXZpdHkucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcclxuICAgIC8vIFRPRE86IG11c3Qga2VlcCB2aWV3U3RhdGUgdXAgdG8gZGF0ZSB1c2luZyBvcHRpb25zL3N0YXRlLlxyXG4gICAgXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMucmVxdWVzdERhdGEgPSBvcHRpb25zO1xyXG4gICAgXHJcbiAgICAvLyBFbmFibGUgcmVnaXN0ZXJlZCBoYW5kbGVyc1xyXG4gICAgLy8gVmFsaWRhdGlvbiBvZiBlYWNoIHNldHRpbmdzIG9iamVjdCBpcyBwZXJmb3JtZWRcclxuICAgIC8vIG9uIHJlZ2lzdGVyZWQsIGF2b2lkZWQgaGVyZS5cclxuICAgIGlmICh0aGlzLl9oYW5kbGVycyAmJlxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzQXJlQ29ubmVjdGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpcyBhbiBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvblxyXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmV2ZW50ICYmIHNldHRpbmdzLnRhcmdldC5zdWJzY3JpYmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKHNldHRpbmdzLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gT2JzZXJ2YWJsZXMgaGFzIG5vdCBhICd1bnN1YnNjcmliZScgZnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAvLyB0aGV5IHJldHVybiBhbiBvYmplY3QgdGhhdCBtdXN0IGJlICdkaXNwb3NlZCcuXHJcbiAgICAgICAgICAgICAgICAvLyBTYXZpbmcgdGhhdCB3aXRoIHNldHRpbmdzIHRvIGFsbG93ICd1bnN1YnNjcmliZScgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElubWVkaWF0ZSBleGVjdXRpb246IGlmIGN1cnJlbnQgb2JzZXJ2YWJsZSB2YWx1ZSBpcyBkaWZmZXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIHRoYW4gcHJldmlvdXMgb25lLCBleGVjdXRlIHRoZSBoYW5kbGVyOlxyXG4gICAgICAgICAgICAgICAgLy8gKHRoaXMgYXZvaWQgdGhhdCBhIGNoYW5nZWQgc3RhdGUgZ2V0IG9taXR0ZWQgYmVjYXVzZSBoYXBwZW5lZFxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBzdWJzY3JpcHRpb24gd2FzIG9mZjsgaXQgbWVhbnMgYSBmaXJzdCB0aW1lIGV4ZWN1dGlvbiB0b28pLlxyXG4gICAgICAgICAgICAgICAgLy8gTk9URTogJ3VuZGVmaW5lZCcgdmFsdWUgb24gb2JzZXJ2YWJsZSBtYXkgY2F1c2UgdGhpcyB0byBmYWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuX2xhdGVzdFN1YnNjcmliZWRWYWx1ZSAhPT0gc2V0dGluZ3MudGFyZ2V0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYW5kbGVyLmNhbGwoc2V0dGluZ3MudGFyZ2V0LCBzZXR0aW5ncy50YXJnZXQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Muc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnRhcmdldC5vbihzZXR0aW5ncy5ldmVudCwgc2V0dGluZ3Muc2VsZWN0b3IsIHNldHRpbmdzLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLnRhcmdldC5vbikge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudGFyZ2V0Lm9uKHNldHRpbmdzLmV2ZW50LCBzZXR0aW5ncy5oYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjdGl2aXR5LnNob3c6IEJhZCByZWdpc3RlcmVkIGhhbmRsZXInLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBUbyBhdm9pZCBkb3VibGUgY29ubmVjdGlvbnM6XHJcbiAgICAgICAgLy8gTk9URTogbWF5IGhhcHBlbiB0aGF0ICdzaG93JyBnZXRzIGNhbGxlZCBzZXZlcmFsIHRpbWVzIHdpdGhvdXQgYSAnaGlkZSdcclxuICAgICAgICAvLyBpbiBiZXR3ZWVuLCBiZWNhdXNlICdzaG93JyBhY3RzIGFzIGEgcmVmcmVzaGVyIHJpZ2h0IG5vdyBldmVuIGZyb20gc2VnbWVudFxyXG4gICAgICAgIC8vIGNoYW5nZXMgZnJvbSB0aGUgc2FtZSBhY3Rpdml0eS5cclxuICAgICAgICB0aGlzLl9oYW5kbGVyc0FyZUNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIFBlcmZvcm0gdGFza3MgdG8gc3RvcCBhbnl0aGluZyBydW5uaW5nIG9yIHN0b3AgaGFuZGxlcnMgZnJvbSBsaXN0ZW5pbmcuXHJcbiAgICBNdXN0IGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIGFjdGl2aXR5IGlzIGhpZGRlbi9yZW1vdmVkIFxyXG4gICAgZnJvbSB0aGUgY3VycmVudCB2aWV3LlxyXG4qKi9cclxuQWN0aXZpdHkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xyXG4gICAgXHJcbiAgICAvLyBEaXNhYmxlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcclxuICAgIGlmICh0aGlzLl9oYW5kbGVycykge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYW4gb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLl9zdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLl9zdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBsYXRlc3Qgb2JzZXJ2YWJsZSB2YWx1ZSB0byBtYWtlIGEgY29tcGFyaXNpb25cclxuICAgICAgICAgICAgICAgIC8vIG5leHQgdGltZSBpcyBlbmFibGVkIHRvIGVuc3VyZSBpcyBleGVjdXRlZCBpZiB0aGVyZSB3YXNcclxuICAgICAgICAgICAgICAgIC8vIGEgY2hhbmdlIHdoaWxlIGRpc2FibGVkOlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX2xhdGVzdFN1YnNjcmliZWRWYWx1ZSA9IHNldHRpbmdzLnRhcmdldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLnRhcmdldC5vZmYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zZWxlY3RvcilcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50YXJnZXQub2ZmKHNldHRpbmdzLmV2ZW50LCBzZXR0aW5ncy5zZWxlY3Rvciwgc2V0dGluZ3MuaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudGFyZ2V0Lm9mZihzZXR0aW5ncy5ldmVudCwgc2V0dGluZ3MuaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy50YXJnZXQucmVtb3ZlTGlzdGVuZXIoc2V0dGluZ3MuZXZlbnQsIHNldHRpbmdzLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQWN0aXZpdHkuaGlkZTogQmFkIHJlZ2lzdGVyZWQgaGFuZGxlcicsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzQXJlQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIFJlZ2lzdGVyIGEgaGFuZGxlciB0aGF0IGFjdHMgb24gYW4gZXZlbnQgb3Igc3Vic2NyaXB0aW9uIG5vdGlmaWNhdGlvbixcclxuICAgIHRoYXQgd2lsbCBiZSBlbmFibGVkIG9uIEFjdGl2aXR5LnNob3cgYW5kIGRpc2FibGVkIG9uIEFjdGl2aXR5LmhpZGUuXHJcblxyXG4gICAgQHBhcmFtIHNldHRpbmdzOm9iamVjdCB7XHJcbiAgICAgICAgdGFyZ2V0OiBqUXVlcnksIEV2ZW50RW1pdHRlciwgS25vY2tvdXQub2JzZXJ2YWJsZS4gUmVxdWlyZWRcclxuICAgICAgICBldmVudDogc3RyaW5nLiBFdmVudCBuYW1lIChjYW4gaGF2ZSBuYW1lc3BhY2VzLCBzZXZlcmFsIGV2ZW50cyBhbGxvd2VkKS4gSXRzIHJlcXVpcmVkIGV4Y2VwdCB3aGVuIHRoZSB0YXJnZXQgaXMgYW4gb2JzZXJ2YWJsZSwgdGhlcmUgbXVzdFxyXG4gICAgICAgICAgICBiZSBvbWl0dGVkLlxyXG4gICAgICAgIGhhbmRsZXI6IEZ1bmN0aW9uLiBSZXF1aXJlZCxcclxuICAgICAgICBzZWxlY3Rvcjogc3RyaW5nLiBPcHRpb25hbC4gRm9yIGpRdWVyeSBldmVudHMgb25seSwgcGFzc2VkIGFzIHRoZVxyXG4gICAgICAgICAgICBzZWxlY3RvciBmb3IgZGVsZWdhdGVkIGhhbmRsZXJzLlxyXG4gICAgfVxyXG4qKi9cclxuQWN0aXZpdHkucHJvdG90eXBlLnJlZ2lzdGVySGFuZGxlciA9IGZ1bmN0aW9uIHJlZ2lzdGVySGFuZGxlcihzZXR0aW5ncykge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo4ICovXHJcbiAgICBcclxuICAgIGlmICghc2V0dGluZ3MpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWdpc3RlciByZXF1aXJlIGEgc2V0dGluZ3Mgb2JqZWN0Jyk7XHJcbiAgICBcclxuICAgIGlmICghc2V0dGluZ3MudGFyZ2V0IHx8ICghc2V0dGluZ3MudGFyZ2V0Lm9uICYmICFzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBpcyBudWxsIG9yIG5vdCBhIGpRdWVyeSwgRXZlbnRFbW1pdGVyIG9yIE9ic2VydmFibGUgb2JqZWN0Jyk7XHJcbiAgICBcclxuICAgIGlmICh0eXBlb2Yoc2V0dGluZ3MuaGFuZGxlcikgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoIXNldHRpbmdzLmV2ZW50ICYmICFzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCBpcyBudWxsOyBpdFxcJ3MgcmVxdWlyZWQgZm9yIG5vbiBvYnNlcnZhYmxlIG9iamVjdHMnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9oYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzIHx8IFtdO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goc2V0dGluZ3MpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBTdGF0aWMgdXRpbGl0aWVzXHJcbioqL1xyXG4vLyBGb3IgY29tbW9kaXR5LCBjb21tb24gY2xhc3NlcyBhcmUgZXhwb3NlZCBhcyBzdGF0aWMgcHJvcGVydGllc1xyXG5BY3Rpdml0eS5OYXZCYXIgPSBOYXZCYXI7XHJcbkFjdGl2aXR5Lk5hdkFjdGlvbiA9IE5hdkFjdGlvbjtcclxuXHJcbi8vIFF1aWNrIGNyZWF0aW9uIG9mIGNvbW1vbiB0eXBlcyBvZiBOYXZCYXJcclxuQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhciA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25OYXZCYXIodGl0bGUpIHtcclxuICAgIHJldHVybiBuZXcgTmF2QmFyKHtcclxuICAgICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgICAgbGVmdEFjdGlvbjogTmF2QWN0aW9uLm1lbnVOZXdJdGVtLFxyXG4gICAgICAgIHJpZ2h0QWN0aW9uOiBOYXZBY3Rpb24ubWVudUluXHJcbiAgICB9KTtcclxufTtcclxuXHJcbkFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIgPSBmdW5jdGlvbiBjcmVhdGVTdWJzZWN0aW9uTmF2QmFyKHRpdGxlLCBvcHRpb25zKSB7XHJcbiAgICBcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgXHJcbiAgICB2YXIgZ29CYWNrT3B0aW9ucyA9IHtcclxuICAgICAgICB0ZXh0OiB0aXRsZSxcclxuICAgICAgICBpc1RpdGxlOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChvcHRpb25zLmJhY2tMaW5rKSB7XHJcbiAgICAgICAgZ29CYWNrT3B0aW9ucy5saW5rID0gb3B0aW9ucy5iYWNrTGluaztcclxuICAgICAgICBnb0JhY2tPcHRpb25zLmlzU2hlbGwgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IE5hdkJhcih7XHJcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBObyB0aXRsZVxyXG4gICAgICAgIGxlZnRBY3Rpb246IE5hdkFjdGlvbi5nb0JhY2subW9kZWwuY2xvbmUoZ29CYWNrT3B0aW9ucyksXHJcbiAgICAgICAgcmlnaHRBY3Rpb246IG9wdGlvbnMuaGVscElkID9cclxuICAgICAgICAgICAgTmF2QWN0aW9uLmdvSGVscEluZGV4Lm1vZGVsLmNsb25lKHtcclxuICAgICAgICAgICAgICAgIGxpbms6ICcjJyArIG9wdGlvbnMuaGVscElkXHJcbiAgICAgICAgICAgIH0pIDpcclxuICAgICAgICAgICAgTmF2QWN0aW9uLmdvSGVscEluZGV4XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgU2luZ2xldG9uIGhlbHBlclxyXG4qKi9cclxudmFyIHNpbmdsZW50b25JbnN0YW5jZXMgPSB7fTtcclxudmFyIGNyZWF0ZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbihBY3Rpdml0eUNsYXNzLCAkYWN0aXZpdHksIGFwcCkge1xyXG4gICAgXHJcbiAgICBpZiAoc2luZ2xlbnRvbkluc3RhbmNlc1tBY3Rpdml0eUNsYXNzLm5hbWVdIGluc3RhbmNlb2YgQWN0aXZpdHlDbGFzcykge1xyXG4gICAgICAgIHJldHVybiBzaW5nbGVudG9uSW5zdGFuY2VzW0FjdGl2aXR5Q2xhc3MubmFtZV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgcyA9IG5ldyBBY3Rpdml0eUNsYXNzKCRhY3Rpdml0eSwgYXBwKTtcclxuICAgICAgICBzaW5nbGVudG9uSW5zdGFuY2VzW0FjdGl2aXR5Q2xhc3MubmFtZV0gPSBzO1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG59O1xyXG4vLyBFeGFtcGxlIG9mIHVzZVxyXG4vL2V4cG9ydHMuaW5pdCA9IGNyZWF0ZVNpbmdsZXRvbi5iaW5kKG51bGwsIEFjdGl2aXR5Q2xhc3MpO1xyXG5cclxuLyoqXHJcbiAgICBTdGF0aWMgbWV0aG9kIGV4dGVuZHMgdG8gaGVscCBpbmhlcml0YW5jZS5cclxuICAgIEFkZGl0aW9uYWxseSwgaXQgYWRkcyBhIHN0YXRpYyBpbml0IG1ldGhvZCByZWFkeSBmb3IgdGhlIG5ldyBjbGFzc1xyXG4gICAgdGhhdCBnZW5lcmF0ZXMvcmV0cmlldmVzIHRoZSBzaW5nbGV0b24uXHJcbioqL1xyXG5BY3Rpdml0eS5leHRlbmRzID0gZnVuY3Rpb24gZXh0ZW5kc0FjdGl2aXR5KENsYXNzRm4pIHtcclxuICAgIFxyXG4gICAgQ2xhc3NGbi5faW5oZXJpdHMoQWN0aXZpdHkpO1xyXG4gICAgXHJcbiAgICBDbGFzc0ZuLmluaXQgPSBjcmVhdGVTaW5nbGV0b24uYmluZChudWxsLCBDbGFzc0ZuKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIENsYXNzRm47XHJcbn07XHJcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBEYXRlUGlja2VyIEpTIENvbXBvbmVudCwgd2l0aCBzZXZlcmFsXHJcbiAqIG1vZGVzIGFuZCBvcHRpb25hbCBpbmxpbmUtcGVybWFuZW50IHZpc3VhbGl6YXRpb24uXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE0IExvY29ub21pY3MgQ29vcC5cclxuICpcclxuICogQmFzZWQgb246XHJcbiAqIGJvb3RzdHJhcC1kYXRlcGlja2VyLmpzIFxyXG4gKiBodHRwOi8vd3d3LmV5ZWNvbi5yby9ib290c3RyYXAtZGF0ZXBpY2tlclxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTsgXHJcblxyXG52YXIgY2xhc3NlcyA9IHtcclxuICAgIGNvbXBvbmVudDogJ0RhdGVQaWNrZXInLFxyXG4gICAgbW9udGhzOiAnRGF0ZVBpY2tlci1tb250aHMnLFxyXG4gICAgZGF5czogJ0RhdGVQaWNrZXItZGF5cycsXHJcbiAgICBtb250aERheTogJ2RheScsXHJcbiAgICBtb250aDogJ21vbnRoJyxcclxuICAgIHllYXI6ICd5ZWFyJyxcclxuICAgIHllYXJzOiAnRGF0ZVBpY2tlci15ZWFycydcclxufTtcclxuXHJcbi8vIFBpY2tlciBvYmplY3RcclxudmFyIERhdGVQaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICAvKmpzaGludCBtYXhzdGF0ZW1lbnRzOjMyLG1heGNvbXBsZXhpdHk6MjQqL1xyXG4gICAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcclxuICAgIHRoaXMuZm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQob3B0aW9ucy5mb3JtYXR8fHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlLWZvcm1hdCcpfHwnbW0vZGQveXl5eScpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzSW5wdXQgPSB0aGlzLmVsZW1lbnQuaXMoJ2lucHV0Jyk7XHJcbiAgICB0aGlzLmNvbXBvbmVudCA9IHRoaXMuZWxlbWVudC5pcygnLmRhdGUnKSA/IHRoaXMuZWxlbWVudC5maW5kKCcuYWRkLW9uJykgOiBmYWxzZTtcclxuICAgIHRoaXMuaXNQbGFjZWhvbGRlciA9IHRoaXMuZWxlbWVudC5pcygnLmNhbGVuZGFyLXBsYWNlaG9sZGVyJyk7XHJcbiAgICBcclxuICAgIHRoaXMucGlja2VyID0gJChEUEdsb2JhbC50ZW1wbGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuaXNQbGFjZWhvbGRlciA/IHRoaXMuZWxlbWVudCA6ICdib2R5JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljayB0YXAnLCAkLnByb3h5KHRoaXMuY2xpY2ssIHRoaXMpKTtcclxuICAgIHRoaXMucGlja2VyLmFkZENsYXNzKHRoaXMuaXNQbGFjZWhvbGRlciA/ICcnIDogJ2Ryb3Bkb3duLW1lbnUnKTtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuaXNQbGFjZWhvbGRlcikge1xyXG4gICAgICAgIHRoaXMucGlja2VyLnNob3coKTtcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSA9PSAndG9kYXknKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKHtcclxuICAgICAgICAgICAgdHlwZTogJ3Nob3cnLFxyXG4gICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMuaXNJbnB1dCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbih7XHJcbiAgICAgICAgICAgIGZvY3VzOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcyksXHJcbiAgICAgICAgICAgIC8vYmx1cjogJC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpLFxyXG4gICAgICAgICAgICBrZXl1cDogJC5wcm94eSh0aGlzLnVwZGF0ZSwgdGhpcylcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KXtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQub24oJ2NsaWNrIHRhcCcsICQucHJveHkodGhpcy5zaG93LCB0aGlzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm9uKCdjbGljayB0YXAnLCAkLnByb3h5KHRoaXMuc2hvdywgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyogVG91Y2ggZXZlbnRzIHRvIHN3aXBlIGRhdGVzICovXHJcbiAgICB0aGlzLmVsZW1lbnRcclxuICAgIC5vbignc3dpcGVsZWZ0JywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLm1vdmVEYXRlKCduZXh0Jyk7XHJcbiAgICB9LmJpbmQodGhpcykpXHJcbiAgICAub24oJ3N3aXBlcmlnaHQnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMubW92ZURhdGUoJ3ByZXYnKTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgLyogU2V0LXVwIHZpZXcgbW9kZSAqL1xyXG4gICAgdGhpcy5taW5WaWV3TW9kZSA9IG9wdGlvbnMubWluVmlld01vZGV8fHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlLW1pbnZpZXdtb2RlJyl8fDA7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMubWluVmlld01vZGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLm1pblZpZXdNb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vbnRocyc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pblZpZXdNb2RlID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd5ZWFycyc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pblZpZXdNb2RlID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5WaWV3TW9kZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnZpZXdNb2RlID0gb3B0aW9ucy52aWV3TW9kZXx8dGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUtdmlld21vZGUnKXx8MDtcclxuICAgIGlmICh0eXBlb2YgdGhpcy52aWV3TW9kZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMudmlld01vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbW9udGhzJzpcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3llYXJzJzpcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuc3RhcnRWaWV3TW9kZSA9IHRoaXMudmlld01vZGU7XHJcbiAgICB0aGlzLndlZWtTdGFydCA9IG9wdGlvbnMud2Vla1N0YXJ0fHx0aGlzLmVsZW1lbnQuZGF0YSgnZGF0ZS13ZWVrc3RhcnQnKXx8MDtcclxuICAgIHRoaXMud2Vla0VuZCA9IHRoaXMud2Vla1N0YXJ0ID09PSAwID8gNiA6IHRoaXMud2Vla1N0YXJ0IC0gMTtcclxuICAgIHRoaXMub25SZW5kZXIgPSBvcHRpb25zLm9uUmVuZGVyO1xyXG4gICAgdGhpcy5maWxsRG93KCk7XHJcbiAgICB0aGlzLmZpbGxNb250aHMoKTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB0aGlzLnNob3dNb2RlKCk7XHJcbn07XHJcblxyXG5EYXRlUGlja2VyLnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBEYXRlUGlja2VyLFxyXG4gICAgXHJcbiAgICBzaG93OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdGhpcy5waWNrZXIuc2hvdygpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCgpIDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5wbGFjZSgpO1xyXG4gICAgICAgICQod2luZG93KS5vbigncmVzaXplJywgJC5wcm94eSh0aGlzLnBsYWNlLCB0aGlzKSk7XHJcbiAgICAgICAgaWYgKGUgKSB7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5wdXQpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldil7XHJcbiAgICAgICAgICAgIGlmICgkKGV2LnRhcmdldCkuY2xvc2VzdCgnLicgKyBjbGFzc2VzLmNvbXBvbmVudCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKHtcclxuICAgICAgICAgICAgdHlwZTogJ3Nob3cnLFxyXG4gICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGVcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5waWNrZXIuaGlkZSgpO1xyXG4gICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZScsIHRoaXMucGxhY2UpO1xyXG4gICAgICAgIHRoaXMudmlld01vZGUgPSB0aGlzLnN0YXJ0Vmlld01vZGU7XHJcbiAgICAgICAgdGhpcy5zaG93TW9kZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0lucHV0KSB7XHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZignbW91c2Vkb3duJywgdGhpcy5oaWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy90aGlzLnNldCgpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKHtcclxuICAgICAgICAgICAgdHlwZTogJ2hpZGUnLFxyXG4gICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGVcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdGVkID0gRFBHbG9iYWwuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsIHRoaXMuZm9ybWF0KTtcclxuICAgICAgICBpZiAoIXRoaXMuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykucHJvcCgndmFsdWUnLCBmb3JtYXRlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnLCBmb3JtYXRlZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnByb3AoJ3ZhbHVlJywgZm9ybWF0ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIFNldHMgYSBkYXRlIGFzIHZhbHVlIGFuZCBub3RpZnkgd2l0aCBhbiBldmVudC5cclxuICAgICAgICBQYXJhbWV0ZXIgZG9udE5vdGlmeSBpcyBvbmx5IGZvciBjYXNlcyB3aGVyZSB0aGUgY2FsZW5kYXIgb3JcclxuICAgICAgICBzb21lIHJlbGF0ZWQgY29tcG9uZW50IGdldHMgYWxyZWFkeSB1cGRhdGVkIGJ1dCB0aGUgaGlnaGxpZ2h0ZWRcclxuICAgICAgICBkYXRlIG5lZWRzIHRvIGJlIHVwZGF0ZWQgd2l0aG91dCBjcmVhdGUgaW5maW5pdGUgcmVjdXJzaW9uIFxyXG4gICAgICAgIGJlY2F1c2Ugb2Ygbm90aWZpY2F0aW9uLiBJbiBvdGhlciBjYXNlLCBkb250IHVzZS5cclxuICAgICoqL1xyXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKG5ld0RhdGUsIGRvbnROb3RpZnkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5ld0RhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShuZXdEYXRlLCB0aGlzLmZvcm1hdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUobmV3RGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSwgMSwgMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRvbnROb3RpZnkgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gTm90aWZ5OlxyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2hhbmdlRGF0ZScsXHJcbiAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXHJcbiAgICAgICAgICAgICAgICB2aWV3TW9kZTogRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG1vdmVWYWx1ZTogZnVuY3Rpb24oZGlyLCBtb2RlKSB7XHJcbiAgICAgICAgLy8gZGlyIGNhbiBiZTogJ3ByZXYnLCAnbmV4dCdcclxuICAgICAgICBpZiAoWydwcmV2JywgJ25leHQnXS5pbmRleE9mKGRpciAmJiBkaXIudG9Mb3dlckNhc2UoKSkgPT0gLTEpXHJcbiAgICAgICAgICAgIC8vIE5vIHZhbGlkIG9wdGlvbjpcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBkZWZhdWx0IG1vZGUgaXMgdGhlIGN1cnJlbnQgb25lXHJcbiAgICAgICAgbW9kZSA9IG1vZGUgP1xyXG4gICAgICAgICAgICBEUEdsb2JhbC5tb2Rlc1NldFttb2RlXSA6XHJcbiAgICAgICAgICAgIERQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGVbJ3NldCcgKyBtb2RlLm5hdkZuY10uY2FsbChcclxuICAgICAgICAgICAgdGhpcy5kYXRlLFxyXG4gICAgICAgICAgICB0aGlzLmRhdGVbJ2dldCcgKyBtb2RlLm5hdkZuY10uY2FsbCh0aGlzLmRhdGUpICsgXHJcbiAgICAgICAgICAgIG1vZGUubmF2U3RlcCAqIChkaXIgPT09ICdwcmV2JyA/IC0xIDogMSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5kYXRlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRlO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcGxhY2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XHJcbiAgICAgICAgdGhpcy5waWNrZXIuY3NzKHtcclxuICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wICsgdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG5ld0RhdGUpe1xyXG4gICAgICAgIHRoaXMuZGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShcclxuICAgICAgICAgICAgdHlwZW9mIG5ld0RhdGUgPT09ICdzdHJpbmcnID8gbmV3RGF0ZSA6ICh0aGlzLmlzSW5wdXQgPyB0aGlzLmVsZW1lbnQucHJvcCgndmFsdWUnKSA6IHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlJykpLFxyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSwgMSwgMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBmaWxsRG93OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBkb3dDbnQgPSB0aGlzLndlZWtTdGFydDtcclxuICAgICAgICB2YXIgaHRtbCA9ICc8dHI+JztcclxuICAgICAgICB3aGlsZSAoZG93Q250IDwgdGhpcy53ZWVrU3RhcnQgKyA3KSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzx0aCBjbGFzcz1cImRvd1wiPicrRFBHbG9iYWwuZGF0ZXMuZGF5c01pblsoZG93Q250KyspJTddKyc8L3RoPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGh0bWwgKz0gJzwvdHI+JztcclxuICAgICAgICB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMuZGF5cyArICcgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBmaWxsTW9udGhzOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgMTIpIHtcclxuICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3Nlcy5tb250aCArICdcIj4nK0RQR2xvYmFsLmRhdGVzLm1vbnRoc1Nob3J0W2krK10rJzwvc3Bhbj4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMubW9udGhzICsgJyB0ZCcpLmFwcGVuZChodG1sKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8qanNoaW50IG1heHN0YXRlbWVudHM6NjYsIG1heGNvbXBsZXhpdHk6MjgqL1xyXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSksXHJcbiAgICAgICAgICAgIHllYXIgPSBkLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIG1vbnRoID0gZC5nZXRNb250aCgpLFxyXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHRoaXMuZGF0ZS52YWx1ZU9mKCk7XHJcbiAgICAgICAgdGhpcy5waWNrZXJcclxuICAgICAgICAuZmluZCgnLicgKyBjbGFzc2VzLmRheXMgKyAnIHRoOmVxKDEpJylcclxuICAgICAgICAuaHRtbChEUEdsb2JhbC5kYXRlcy5tb250aHNbbW9udGhdICsgJyAnICsgeWVhcik7XHJcbiAgICAgICAgdmFyIHByZXZNb250aCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLTEsIDI4LDAsMCwwLDApLFxyXG4gICAgICAgICAgICBkYXkgPSBEUEdsb2JhbC5nZXREYXlzSW5Nb250aChwcmV2TW9udGguZ2V0RnVsbFllYXIoKSwgcHJldk1vbnRoLmdldE1vbnRoKCkpO1xyXG4gICAgICAgIHByZXZNb250aC5zZXREYXRlKGRheSk7XHJcbiAgICAgICAgcHJldk1vbnRoLnNldERhdGUoZGF5IC0gKHByZXZNb250aC5nZXREYXkoKSAtIHRoaXMud2Vla1N0YXJ0ICsgNyklNyk7XHJcbiAgICAgICAgdmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHByZXZNb250aCk7XHJcbiAgICAgICAgbmV4dE1vbnRoLnNldERhdGUobmV4dE1vbnRoLmdldERhdGUoKSArIDQyKTtcclxuICAgICAgICBuZXh0TW9udGggPSBuZXh0TW9udGgudmFsdWVPZigpO1xyXG4gICAgICAgIHZhciBodG1sID0gW107XHJcbiAgICAgICAgdmFyIGNsc05hbWUsXHJcbiAgICAgICAgICAgIHByZXZZLFxyXG4gICAgICAgICAgICBwcmV2TTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuX2RheXNDcmVhdGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBodG1sIChmaXJzdCB0aW1lIG9ubHkpXHJcbiAgICAgICBcclxuICAgICAgICAgICAgd2hpbGUocHJldk1vbnRoLnZhbHVlT2YoKSA8IG5leHRNb250aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZNb250aC5nZXREYXkoKSA9PT0gdGhpcy53ZWVrU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2goJzx0cj4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNsc05hbWUgPSB0aGlzLm9uUmVuZGVyKHByZXZNb250aCk7XHJcbiAgICAgICAgICAgICAgICBwcmV2WSA9IHByZXZNb250aC5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgcHJldk0gPSBwcmV2TW9udGguZ2V0TW9udGgoKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJldk0gPCBtb250aCAmJiAgcHJldlkgPT09IHllYXIpIHx8ICBwcmV2WSA8IHllYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lICs9ICcgb2xkJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHByZXZNID4gbW9udGggJiYgcHJldlkgPT09IHllYXIpIHx8IHByZXZZID4geWVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWUgKz0gJyBuZXcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZNb250aC52YWx1ZU9mKCkgPT09IGN1cnJlbnREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZSArPSAnIGFjdGl2ZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBodG1sLnB1c2goJzx0ZCBjbGFzcz1cIicgKyBjbGFzc2VzLm1vbnRoRGF5ICsgJyAnICsgY2xzTmFtZSsnXCI+JytwcmV2TW9udGguZ2V0RGF0ZSgpICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldk1vbnRoLmdldERheSgpID09PSB0aGlzLndlZWtFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2goJzwvdHI+Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2TW9udGguc2V0RGF0ZShwcmV2TW9udGguZ2V0RGF0ZSgpKzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMuZGF5cyArICcgdGJvZHknKS5lbXB0eSgpLmFwcGVuZChodG1sLmpvaW4oJycpKTtcclxuICAgICAgICAgICAgdGhpcy5fZGF5c0NyZWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGRheXMgdmFsdWVzXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgd2Vla1RyID0gdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLmRheXMgKyAnIHRib2R5IHRyOmZpcnN0LWNoaWxkKCknKTtcclxuICAgICAgICAgICAgdmFyIGRheVRkID0gbnVsbDtcclxuICAgICAgICAgICAgd2hpbGUocHJldk1vbnRoLnZhbHVlT2YoKSA8IG5leHRNb250aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRXZWVrRGF5SW5kZXggPSBwcmV2TW9udGguZ2V0RGF5KCkgLSB0aGlzLndlZWtTdGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICBjbHNOYW1lID0gdGhpcy5vblJlbmRlcihwcmV2TW9udGgpO1xyXG4gICAgICAgICAgICAgICAgcHJldlkgPSBwcmV2TW9udGguZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgICAgIHByZXZNID0gcHJldk1vbnRoLmdldE1vbnRoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByZXZNIDwgbW9udGggJiYgIHByZXZZID09PSB5ZWFyKSB8fCAgcHJldlkgPCB5ZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xzTmFtZSArPSAnIG9sZCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChwcmV2TSA+IG1vbnRoICYmIHByZXZZID09PSB5ZWFyKSB8fCBwcmV2WSA+IHllYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbHNOYW1lICs9ICcgbmV3JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwcmV2TW9udGgudmFsdWVPZigpID09PSBjdXJyZW50RGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsc05hbWUgKz0gJyBhY3RpdmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9odG1sLnB1c2goJzx0ZCBjbGFzcz1cImRheSAnK2Nsc05hbWUrJ1wiPicrcHJldk1vbnRoLmdldERhdGUoKSArICc8L3RkPicpO1xyXG4gICAgICAgICAgICAgICAgZGF5VGQgPSB3ZWVrVHIuZmluZCgndGQ6ZXEoJyArIGN1cnJlbnRXZWVrRGF5SW5kZXggKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgZGF5VGRcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkYXkgJyArIGNsc05hbWUpXHJcbiAgICAgICAgICAgICAgICAudGV4dChwcmV2TW9udGguZ2V0RGF0ZSgpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gTmV4dCB3ZWVrP1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZNb250aC5nZXREYXkoKSA9PT0gdGhpcy53ZWVrRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2Vla1RyID0gd2Vla1RyLm5leHQoJ3RyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2TW9udGguc2V0RGF0ZShwcmV2TW9udGguZ2V0RGF0ZSgpKzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY3VycmVudFllYXIgPSB0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbW9udGhzID0gdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLm1vbnRocylcclxuICAgICAgICAgICAgICAgICAgICAuZmluZCgndGg6ZXEoMSknKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuaHRtbCh5ZWFyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW5kKClcclxuICAgICAgICAgICAgICAgICAgICAuZmluZCgnc3BhbicpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICBpZiAoY3VycmVudFllYXIgPT09IHllYXIpIHtcclxuICAgICAgICAgICAgbW9udGhzLmVxKHRoaXMuZGF0ZS5nZXRNb250aCgpKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGh0bWwgPSAnJztcclxuICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhci8xMCwgMTApICogMTA7XHJcbiAgICAgICAgdmFyIHllYXJDb250ID0gdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLnllYXJzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3RoOmVxKDEpJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dCh5ZWFyICsgJy0nICsgKHllYXIgKyA5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW5kKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKCd0ZCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHllYXIgLT0gMTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAodGhpcy5feWVhcnNDcmVhdGVkICE9PSB0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAtMTsgaSA8IDExOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzZXMueWVhciArIChpID09PSAtMSB8fCBpID09PSAxMCA/ICcgb2xkJyA6ICcnKSsoY3VycmVudFllYXIgPT09IHllYXIgPyAnIGFjdGl2ZScgOiAnJykrJ1wiPicreWVhcisnPC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICB5ZWFyICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHllYXJDb250Lmh0bWwoaHRtbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3llYXJzQ3JlYXRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHllYXJTcGFuID0geWVhckNvbnQuZmluZCgnc3BhbjpmaXJzdC1jaGlsZCgpJyk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IC0xOyBpIDwgMTE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy9odG1sICs9ICc8c3BhbiBjbGFzcz1cInllYXInKyhpID09PSAtMSB8fCBpID09PSAxMCA/ICcgb2xkJyA6ICcnKSsoY3VycmVudFllYXIgPT09IHllYXIgPyAnIGFjdGl2ZScgOiAnJykrJ1wiPicreWVhcisnPC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICB5ZWFyU3BhblxyXG4gICAgICAgICAgICAgICAgLnRleHQoeWVhcilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5ZWFyJyArIChpID09PSAtMSB8fCBpID09PSAxMCA/ICcgb2xkJyA6ICcnKSArIChjdXJyZW50WWVhciA9PT0geWVhciA/ICcgYWN0aXZlJyA6ICcnKSk7XHJcbiAgICAgICAgICAgICAgICB5ZWFyICs9IDE7XHJcbiAgICAgICAgICAgICAgICB5ZWFyU3BhbiA9IHllYXJTcGFuLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG1vdmVEYXRlOiBmdW5jdGlvbihkaXIsIG1vZGUpIHtcclxuICAgICAgICAvLyBkaXIgY2FuIGJlOiAncHJldicsICduZXh0J1xyXG4gICAgICAgIGlmIChbJ3ByZXYnLCAnbmV4dCddLmluZGV4T2YoZGlyICYmIGRpci50b0xvd2VyQ2FzZSgpKSA9PSAtMSlcclxuICAgICAgICAgICAgLy8gTm8gdmFsaWQgb3B0aW9uOlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vIGRlZmF1bHQgbW9kZSBpcyB0aGUgY3VycmVudCBvbmVcclxuICAgICAgICBtb2RlID0gbW9kZSB8fCB0aGlzLnZpZXdNb2RlO1xyXG5cclxuICAgICAgICB0aGlzLnZpZXdEYXRlWydzZXQnK0RQR2xvYmFsLm1vZGVzW21vZGVdLm5hdkZuY10uY2FsbChcclxuICAgICAgICAgICAgdGhpcy52aWV3RGF0ZSxcclxuICAgICAgICAgICAgdGhpcy52aWV3RGF0ZVsnZ2V0JytEUEdsb2JhbC5tb2Rlc1ttb2RlXS5uYXZGbmNdLmNhbGwodGhpcy52aWV3RGF0ZSkgKyBcclxuICAgICAgICAgICAgRFBHbG9iYWwubW9kZXNbbW9kZV0ubmF2U3RlcCAqIChkaXIgPT09ICdwcmV2JyA/IC0xIDogMSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuZmlsbCgpO1xyXG4gICAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsaWNrOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxNiovXHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3NwYW4sIHRkLCB0aCcpO1xyXG4gICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBtb250aCwgeWVhcjtcclxuICAgICAgICAgICAgc3dpdGNoKHRhcmdldFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0aCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHRhcmdldFswXS5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd01vZGUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJldic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlRGF0ZSh0YXJnZXRbMF0uY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYW4nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXMoJy4nICsgY2xhc3Nlcy5tb250aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSB0YXJnZXQucGFyZW50KCkuZmluZCgnc3BhbicpLmluZGV4KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0RhdGUuc2V0TW9udGgobW9udGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0RhdGUuc2V0RnVsbFllYXIoeWVhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hhbmdlRGF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZTogRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93TW9kZSgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RkJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzKCcuZGF5JykgJiYgIXRhcmdldC5pcygnLmRpc2FibGVkJykpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF5ID0gcGFyc2VJbnQodGFyZ2V0LnRleHQoKSwgMTApfHwxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9IHRoaXMudmlld0RhdGUuZ2V0TW9udGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pcygnLm9sZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5pcygnLm5ldycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgPSB0aGlzLnZpZXdEYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksMCwwLDAsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgTWF0aC5taW4oMjgsIGRheSksMCwwLDAsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hhbmdlRGF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZTogRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2hvd01vZGU6IGZ1bmN0aW9uKGRpcikge1xyXG4gICAgICAgIGlmIChkaXIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZSA9IE1hdGgubWF4KHRoaXMubWluVmlld01vZGUsIE1hdGgubWluKDIsIHRoaXMudmlld01vZGUgKyBkaXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy4nICsgY2xhc3Nlcy5jb21wb25lbnQgKyAnLScgKyBEUEdsb2JhbC5tb2Rlc1t0aGlzLnZpZXdNb2RlXS5jbHNOYW1lKS5zaG93KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4kLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcclxuICAgIHZhciB2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIHZhciByZXR1cm5lZDtcclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSxcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbjtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgJHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIChkYXRhID0gbmV3IERhdGVQaWNrZXIodGhpcywgJC5leHRlbmQoe30sICQuZm4uZGF0ZXBpY2tlci5kZWZhdWx0cyxvcHRpb25zKSkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm5lZCA9IGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCB2YWxzKTtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgbWV0aG9kP1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mKHJldHVybmVkKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdvIG91dCB0aGUgbG9vcCB0byByZXR1cm4gdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50LW1ldGhvZCBleGVjdXRpb25cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGb2xsb3cgbmV4dCBsb29wIGl0ZW1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmICh0eXBlb2YocmV0dXJuZWQpICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICByZXR1cm4gcmV0dXJuZWQ7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgLy8gY2hhaW5pbmc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4kLmZuLmRhdGVwaWNrZXIuZGVmYXVsdHMgPSB7XHJcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oLypkYXRlKi8pIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn07XHJcbiQuZm4uZGF0ZXBpY2tlci5Db25zdHJ1Y3RvciA9IERhdGVQaWNrZXI7XHJcblxyXG52YXIgRFBHbG9iYWwgPSB7XHJcbiAgICBtb2RlczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2xzTmFtZTogJ2RheXMnLFxyXG4gICAgICAgICAgICBuYXZGbmM6ICdNb250aCcsXHJcbiAgICAgICAgICAgIG5hdlN0ZXA6IDFcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2xzTmFtZTogJ21vbnRocycsXHJcbiAgICAgICAgICAgIG5hdkZuYzogJ0Z1bGxZZWFyJyxcclxuICAgICAgICAgICAgbmF2U3RlcDogMVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbHNOYW1lOiAneWVhcnMnLFxyXG4gICAgICAgICAgICBuYXZGbmM6ICdGdWxsWWVhcicsXHJcbiAgICAgICAgICAgIG5hdlN0ZXA6IDEwXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsc05hbWU6ICdkYXknLFxyXG4gICAgICAgICAgICBuYXZGbmM6ICdEYXRlJyxcclxuICAgICAgICAgICAgbmF2U3RlcDogMVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBkYXRlczp7XHJcbiAgICAgICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiwgXCJTdW5kYXlcIl0sXHJcbiAgICAgICAgZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl0sXHJcbiAgICAgICAgZGF5c01pbjogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIiwgXCJTdVwiXSxcclxuICAgICAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxyXG4gICAgICAgIG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cclxuICAgIH0sXHJcbiAgICBpc0xlYXBZZWFyOiBmdW5jdGlvbiAoeWVhcikge1xyXG4gICAgICAgIHJldHVybiAoKCh5ZWFyICUgNCA9PT0gMCkgJiYgKHllYXIgJSAxMDAgIT09IDApKSB8fCAoeWVhciAlIDQwMCA9PT0gMCkpO1xyXG4gICAgfSxcclxuICAgIGdldERheXNJbk1vbnRoOiBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcclxuICAgICAgICByZXR1cm4gWzMxLCAoRFBHbG9iYWwuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xyXG4gICAgfSxcclxuICAgIHBhcnNlRm9ybWF0OiBmdW5jdGlvbihmb3JtYXQpe1xyXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBmb3JtYXQubWF0Y2goL1suXFwvXFwtXFxzXS4qPy8pLFxyXG4gICAgICAgICAgICBwYXJ0cyA9IGZvcm1hdC5zcGxpdCgvXFxXKy8pO1xyXG4gICAgICAgIGlmICghc2VwYXJhdG9yIHx8ICFwYXJ0cyB8fCBwYXJ0cy5sZW5ndGggPT09IDApe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtzZXBhcmF0b3I6IHNlcGFyYXRvciwgcGFydHM6IHBhcnRzfTtcclxuICAgIH0sXHJcbiAgICBwYXJzZURhdGU6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xyXG4gICAgICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6MTEqL1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IGRhdGUuc3BsaXQoZm9ybWF0LnNlcGFyYXRvciksXHJcbiAgICAgICAgICAgIHZhbDtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgICBkYXRlLnNldEhvdXJzKDApO1xyXG4gICAgICAgIGRhdGUuc2V0TWludXRlcygwKTtcclxuICAgICAgICBkYXRlLnNldFNlY29uZHMoMCk7XHJcbiAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gZm9ybWF0LnBhcnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF5ID0gZGF0ZS5nZXREYXRlKCksIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGNudCA9IGZvcm1hdC5wYXJ0cy5sZW5ndGg7IGkgPCBjbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQocGFydHNbaV0sIDEwKXx8MTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaChmb3JtYXQucGFydHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXREYXRlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21tJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWwgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldE1vbnRoKHZhbCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd5eSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgPSAyMDAwICsgdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKDIwMDAgKyB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd5eXl5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgMCAsMCAsMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIGZvcm1hdERhdGU6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCl7XHJcbiAgICAgICAgdmFyIHZhbCA9IHtcclxuICAgICAgICAgICAgZDogZGF0ZS5nZXREYXRlKCksXHJcbiAgICAgICAgICAgIG06IGRhdGUuZ2V0TW9udGgoKSArIDEsXHJcbiAgICAgICAgICAgIHl5OiBkYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXHJcbiAgICAgICAgICAgIHl5eXk6IGRhdGUuZ2V0RnVsbFllYXIoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFsLmRkID0gKHZhbC5kIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwuZDtcclxuICAgICAgICB2YWwubW0gPSAodmFsLm0gPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5tO1xyXG4gICAgICAgIGRhdGUgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpPTAsIGNudCA9IGZvcm1hdC5wYXJ0cy5sZW5ndGg7IGkgPCBjbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRlLnB1c2godmFsW2Zvcm1hdC5wYXJ0c1tpXV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZS5qb2luKGZvcm1hdC5zZXBhcmF0b3IpO1xyXG4gICAgfSxcclxuICAgIGhlYWRUZW1wbGF0ZTogJzx0aGVhZD4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRyPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwicHJldlwiPiZsc2FxdW87PC90aD4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0aCBjb2xzcGFuPVwiNVwiIGNsYXNzPVwic3dpdGNoXCI+PC90aD4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cIm5leHRcIj4mcnNhcXVvOzwvdGg+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdHI+JytcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nLFxyXG4gICAgY29udFRlbXBsYXRlOiAnPHRib2R5Pjx0cj48dGQgY29sc3Bhbj1cIjdcIj48L3RkPjwvdHI+PC90Ym9keT4nXHJcbn07XHJcbkRQR2xvYmFsLnRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5jb21wb25lbnQgKyAnXCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5kYXlzICsgJ1wiPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiIHRhYmxlLWNvbmRlbnNlZFwiPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRFBHbG9iYWwuaGVhZFRlbXBsYXRlK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGJvZHk+PC90Ym9keT4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGFibGU+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMubW9udGhzICsgJ1wiPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEUEdsb2JhbC5oZWFkVGVtcGxhdGUrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRFBHbG9iYWwuY29udFRlbXBsYXRlK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGFibGU+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMueWVhcnMgKyAnXCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEUEdsb2JhbC5jb250VGVtcGxhdGUrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JytcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcclxuRFBHbG9iYWwubW9kZXNTZXQgPSB7XHJcbiAgICAnZGF0ZSc6IERQR2xvYmFsLm1vZGVzWzNdLFxyXG4gICAgJ21vbnRoJzogRFBHbG9iYWwubW9kZXNbMF0sXHJcbiAgICAneWVhcic6IERQR2xvYmFsLm1vZGVzWzFdLFxyXG4gICAgJ2RlY2FkZSc6IERQR2xvYmFsLm1vZGVzWzJdXHJcbn07XHJcblxyXG4vKiogUHVibGljIEFQSSAqKi9cclxuZXhwb3J0cy5EYXRlUGlja2VyID0gRGF0ZVBpY2tlcjtcclxuZXhwb3J0cy5kZWZhdWx0cyA9IERQR2xvYmFsO1xyXG5leHBvcnRzLnV0aWxzID0gRFBHbG9iYWw7XHJcbiIsIi8qKlxyXG4gICAgU21hcnROYXZCYXIgY29tcG9uZW50LlxyXG4gICAgUmVxdWlyZXMgaXRzIENTUyBjb3VudGVycGFydC5cclxuICAgIFxyXG4gICAgQ3JlYXRlZCBiYXNlZCBvbiB0aGUgcHJvamVjdDpcclxuICAgIFxyXG4gICAgUHJvamVjdC1UeXNvblxyXG4gICAgV2Vic2l0ZTogaHR0cHM6Ly9naXRodWIuY29tL2MycHJvZHMvUHJvamVjdC1UeXNvblxyXG4gICAgQXV0aG9yOiBjMnByb2RzXHJcbiAgICBMaWNlbnNlOlxyXG4gICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAgICBDb3B5cmlnaHQgKGMpIDIwMTMgYzJwcm9kc1xyXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxyXG4gICAgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxyXG4gICAgdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xyXG4gICAgdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2ZcclxuICAgIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcclxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXHJcbiAgICBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gICAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1NcclxuICAgIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUlxyXG4gICAgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSXHJcbiAgICBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxyXG4gICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuKiovXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG4vKipcclxuICAgIEludGVybmFsIHV0aWxpdHkuXHJcbiAgICBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmb3IgYSBET00gbm9kZVxyXG4qKi9cclxudmFyIGNsZWFyTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB3aGlsZShub2RlLmZpcnN0Q2hpbGQpe1xyXG4gICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gICAgQ2FsY3VsYXRlcyBhbmQgYXBwbGllcyB0aGUgYmVzdCBzaXppbmcgYW5kIGRpc3RyaWJ1dGlvbiBmb3IgdGhlIHRpdGxlXHJcbiAgICBkZXBlbmRpbmcgb24gY29udGVudCBhbmQgYnV0dG9ucy5cclxuICAgIFBhc3MgaW4gdGhlIHRpdGxlIGVsZW1lbnQsIGJ1dHRvbnMgbXVzdCBiZSBmb3VuZCBhcyBzaWJsaW5ncyBvZiBpdC5cclxuKiovXHJcbnZhciB0ZXh0Ym94UmVzaXplID0gZnVuY3Rpb24gdGV4dGJveFJlc2l6ZShlbCkge1xyXG4gICAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDI4LCBtYXhjb21wbGV4aXR5OjExICovXHJcbiAgICBcclxuICAgIHZhciBsZWZ0YnRuID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuU21hcnROYXZCYXItZWRnZS5sZWZ0JylbMF07XHJcbiAgICB2YXIgcmlnaHRidG4gPSBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5TbWFydE5hdkJhci1lZGdlLnJpZ2h0JylbMF07XHJcbiAgICBpZiAodHlwZW9mIGxlZnRidG4gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgbGVmdGJ0biA9IHtcclxuICAgICAgICAgICAgb2Zmc2V0V2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJydcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiByaWdodGJ0biA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByaWdodGJ0biA9IHtcclxuICAgICAgICAgICAgb2Zmc2V0V2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJydcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgbWFyZ2luID0gTWF0aC5tYXgobGVmdGJ0bi5vZmZzZXRXaWR0aCwgcmlnaHRidG4ub2Zmc2V0V2lkdGgpO1xyXG4gICAgZWwuc3R5bGUubWFyZ2luTGVmdCA9IG1hcmdpbiArICdweCc7XHJcbiAgICBlbC5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbiArICdweCc7XHJcbiAgICB2YXIgdG9vTG9uZyA9IChlbC5vZmZzZXRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoKSA/IHRydWUgOiBmYWxzZTtcclxuICAgIGlmICh0b29Mb25nKSB7XHJcbiAgICAgICAgaWYgKGxlZnRidG4ub2Zmc2V0V2lkdGggPCByaWdodGJ0bi5vZmZzZXRXaWR0aCkge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gbGVmdGJ0bi5vZmZzZXRXaWR0aCArICdweCc7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUubWFyZ2luUmlnaHQgPSByaWdodGJ0bi5vZmZzZXRXaWR0aCArICdweCc7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9vTG9uZyA9IChlbC5vZmZzZXRXaWR0aDxlbC5zY3JvbGxXaWR0aCkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHRvb0xvbmcpIHtcclxuICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoJ2Fycm93JykudGVzdChsZWZ0YnRuLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyTm9kZShsZWZ0YnRuLmNoaWxkTm9kZXNbMV0pO1xyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUubWFyZ2luTGVmdCA9ICcyNnB4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cCgnYXJyb3cnKS50ZXN0KHJpZ2h0YnRuLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyTm9kZShyaWdodGJ0bi5jaGlsZE5vZGVzWzFdKTtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzI2cHgnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy50ZXh0Ym94UmVzaXplID0gdGV4dGJveFJlc2l6ZTtcclxuXHJcbi8qKlxyXG4gICAgU21hcnROYXZCYXIgY2xhc3MsIGluc3RhbnRpYXRlIHdpdGggYSBET00gZWxlbWVudFxyXG4gICAgcmVwcmVzZW50aW5nIGEgbmF2YmFyLlxyXG4gICAgQVBJOlxyXG4gICAgLSByZWZyZXNoOiB1cGRhdGVzIHRoZSBjb250cm9sIHRha2luZyBjYXJlIG9mIHRoZSBuZWVkZWRcclxuICAgICAgICB3aWR0aCBmb3IgdGl0bGUgYW5kIGJ1dHRvbnNcclxuKiovXHJcbnZhciBTbWFydE5hdkJhciA9IGZ1bmN0aW9uIFNtYXJ0TmF2QmFyKGVsKSB7XHJcbiAgICB0aGlzLmVsID0gZWw7XHJcbiAgICBcclxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XHJcbiAgICAgICAgdmFyIGggPSAkKGVsKS5jaGlsZHJlbignaDEnKS5nZXQoMCk7XHJcbiAgICAgICAgaWYgKGgpXHJcbiAgICAgICAgICAgIHRleHRib3hSZXNpemUoaCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVmcmVzaCgpOyBcclxufTtcclxuXHJcbmV4cG9ydHMuU21hcnROYXZCYXIgPSBTbWFydE5hdkJhcjtcclxuXHJcbi8qKlxyXG4gICAgR2V0IGluc3RhbmNlcyBmb3IgYWxsIHRoZSBTbWFydE5hdkJhciBlbGVtZW50cyBpbiB0aGUgRE9NXHJcbioqL1xyXG5leHBvcnRzLmdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbCgpIHtcclxuICAgIHZhciBhbGwgPSAkKCcuU21hcnROYXZCYXInKTtcclxuICAgIHJldHVybiAkLm1hcChhbGwsIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIG5ldyBTbWFydE5hdkJhcihpdGVtKTsgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFJlZnJlc2ggYWxsIFNtYXJ0TmF2QmFyIGZvdW5kIGluIHRoZSBkb2N1bWVudC5cclxuKiovXHJcbmV4cG9ydHMucmVmcmVzaEFsbCA9IGZ1bmN0aW9uIHJlZnJlc2hBbGwoKSB7XHJcbiAgICAkKCcuU21hcnROYXZCYXIgPiBoMScpLmVhY2goZnVuY3Rpb24oKSB7IHRleHRib3hSZXNpemUodGhpcyk7IH0pO1xyXG59O1xyXG4iLCIvKipcclxuICAgIEN1c3RvbSBMb2Nvbm9taWNzICdsb2NhbGUnIHN0eWxlcyBmb3IgZGF0ZS90aW1lcy5cclxuICAgIEl0cyBhIGJpdCBtb3JlICdjb29sJyByZW5kZXJpbmcgZGF0ZXMgOy0pXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XHJcbi8vIFNpbmNlIHRoZSB0YXNrIG9mIGRlZmluZSBhIGxvY2FsZSBjaGFuZ2VzXHJcbi8vIHRoZSBjdXJyZW50IGdsb2JhbCBsb2NhbGUsIHdlIHNhdmUgYSByZWZlcmVuY2VcclxuLy8gYW5kIHJlc3RvcmUgaXQgbGF0ZXIgc28gbm90aGluZyBjaGFuZ2VkLlxyXG52YXIgY3VycmVudCA9IG1vbWVudC5sb2NhbGUoKTtcclxuXHJcbm1vbWVudC5sb2NhbGUoJ2VuLVVTLUxDJywge1xyXG4gICAgbWVyaWRpZW1QYXJzZSA6IC9bYXBdXFwuP1xcLj8vaSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncCcgOiAnUCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYScgOiAnQSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheV0nLFxyXG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5XScsXHJcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3ddJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbbGFzdF0gZGRkZCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTS9EJ1xyXG4gICAgfSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUOiAnaDptbWEnLFxyXG4gICAgICAgIExUUzogJ2g6bW06c3NhJyxcclxuICAgICAgICBMOiAnTU0vREQvWVlZWScsXHJcbiAgICAgICAgbDogJ00vRC9ZWVlZJyxcclxuICAgICAgICBMTDogJ01NTU0gRG8gWVlZWScsXHJcbiAgICAgICAgbGw6ICdNTU0gRCBZWVlZJyxcclxuICAgICAgICBMTEw6ICdNTU1NIERvIFlZWVkgTFQnLFxyXG4gICAgICAgIGxsbDogJ01NTSBEIFlZWVkgTFQnLFxyXG4gICAgICAgIExMTEw6ICdkZGRkLCBNTU1NIERvIFlZWVkgTFQnLFxyXG4gICAgICAgIGxsbGw6ICdkZGQsIE1NTSBEIFlZWVkgTFQnXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gUmVzdG9yZSBsb2NhbGVcclxubW9tZW50LmxvY2FsZShjdXJyZW50KTtcclxuIiwiLyoqIEFkZHJlc3MgbW9kZWwgKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIEFkZHJlc3ModmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgYWRkcmVzc0lEOiAwLFxyXG4gICAgICAgIGFkZHJlc3NOYW1lOiAnJyxcclxuICAgICAgICBqb2JUaXRsZUlEOiAwLFxyXG4gICAgICAgIHVzZXJJRDogMCxcclxuICAgICAgICBhZGRyZXNzTGluZTE6IG51bGwsXHJcbiAgICAgICAgYWRkcmVzc0xpbmUyOiBudWxsLFxyXG4gICAgICAgIHBvc3RhbENvZGU6IG51bGwsXHJcbiAgICAgICAgY2l0eTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcclxuICAgICAgICBzdGF0ZVByb3ZpbmNlQ29kZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcclxuICAgICAgICBzdGF0ZVByb3ZpbmNlTmFtZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcclxuICAgICAgICBjb3VudHJ5Q29kZTogbnVsbCwgLy8gSVNPIEFscGhhLTIgY29kZSwgRXguOiAnVVMnXHJcbiAgICAgICAgbGF0aXR1ZGU6IG51bGwsXHJcbiAgICAgICAgbG9uZ2l0dWRlOiBudWxsLFxyXG4gICAgICAgIHNwZWNpYWxJbnN0cnVjdGlvbnM6IG51bGwsXHJcbiAgICAgICAgaXNTZXJ2aWNlQXJlYTogZmFsc2UsXHJcbiAgICAgICAgaXNTZXJ2aWNlTG9jYXRpb246IGZhbHNlLFxyXG4gICAgICAgIHNlcnZpY2VSYWRpdXM6IDAsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsIC8vIEF1dG9maWxsZWQgYnkgc2VydmVyXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsIC8vIEF1dG9maWxsZWQgYnkgc2VydmVyXHJcbiAgICAgICAga2luZDogJycgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMuc2luZ2xlTGluZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBsaXN0ID0gW1xyXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3NMaW5lMSgpLFxyXG4gICAgICAgICAgICB0aGlzLmNpdHkoKSxcclxuICAgICAgICAgICAgdGhpcy5wb3N0YWxDb2RlKCksXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVQcm92aW5jZUNvZGUoKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uKHYpIHsgcmV0dXJuICEhdjsgfSkuam9pbignLCAnKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBUT0RPOiBuZWVkZWQ/IGwxMG4/IG11c3QgYmUgcHJvdmlkZWQgYnkgc2VydmVyIHNpZGU/XHJcbiAgICB2YXIgY291bnRyaWVzID0ge1xyXG4gICAgICAgICdVUyc6ICdVbml0ZWQgU3RhdGVzJyxcclxuICAgICAgICAnRVMnOiAnU3BhaW4nXHJcbiAgICB9O1xyXG4gICAgdGhpcy5jb3VudHJ5TmFtZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjb3VudHJpZXNbdGhpcy5jb3VudHJ5Q29kZSgpXSB8fCAndW5rbm93JztcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8vIFVzZWZ1bCBHUFMgb2JqZWN0IHdpdGggdGhlIGZvcm1hdCB1c2VkIGJ5IEdvb2dsZSBNYXBzXHJcbiAgICB0aGlzLmxhdGxuZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxhdDogdGhpcy5sYXRpdHVkZSgpLFxyXG4gICAgICAgICAgICBsbmc6IHRoaXMubG9uZ2l0dWRlKClcclxuICAgICAgICB9O1xyXG4gICAgfSwgdGhpcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWRkcmVzcztcclxuXHJcbi8vIFB1YmxpYyBFbnVtZXJhdGlvbiBmb3IgdGhlICdraW5kJyBwcm9wZXJ0eTpcclxuQWRkcmVzcy5raW5kID0ge1xyXG4gICAgaG9tZTogJ2hvbWUnLFxyXG4gICAgYmlsbGluZzogJ2JpbGxpbmcnLFxyXG4gICAgc2VydmljZTogJ3NlcnZpY2UnXHJcbn07XHJcbiIsIi8qKiBBcHBvaW50bWVudCBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXHJcbiAgICBQcmljaW5nRXN0aW1hdGVEZXRhaWwgPSByZXF1aXJlKCcuL1ByaWNpbmdFc3RpbWF0ZURldGFpbCcpLFxyXG4gICAgQ2FsZW5kYXJFdmVudCA9IHJlcXVpcmUoJy4vQ2FsZW5kYXJFdmVudCcpLFxyXG4gICAgQm9va2luZyA9IHJlcXVpcmUoJy4vQm9va2luZycpO1xyXG4gICBcclxuZnVuY3Rpb24gQXBwb2ludG1lbnQodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgLy8gQW4gYXBwb2ludG1lbnQgZXZlciByZWZlcmVuY2VzIGFuIGV2ZW50LCBhbmQgaXRzICdpZCcgaXMgYSBDYWxlbmRhckV2ZW50SURcclxuICAgICAgICAvLyBldmVuIGlmIG90aGVyIGNvbXBsZW1lbnRhcnkgb2JqZWN0IGFyZSB1c2VkIGFzICdzb3VyY2UnXHJcbiAgICAgICAgaWQ6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgc3RhcnRUaW1lOiBudWxsLFxyXG4gICAgICAgIGVuZFRpbWU6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29tbW9uRXZlbnQgZmllbGRzOlxyXG4gICAgICAgIHN1bW1hcnk6ICdOZXcgYm9va2luZycsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXHJcblxyXG4gICAgICAgIC8vIEZpZWxkcyBzcGVjaWZpYyBmb3IgYm9va2luZ3NcclxuICAgICAgICBwcmljZTogMCxcclxuICAgICAgICAvLyBBY3R1YWwgYm9va2luZ3MgZmllbGRzIHRvIHVzZSBvbiBwb3N0L3B1dFxyXG4gICAgICAgIGN1c3RvbWVyVXNlcklEOiBudWxsLFxyXG4gICAgICAgIHByaWNpbmc6IHtcclxuICAgICAgICAgICAgTW9kZWw6IFByaWNpbmdFc3RpbWF0ZURldGFpbCxcclxuICAgICAgICAgICAgaXNBcnJheTogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkcmVzc0lEOiBudWxsLFxyXG4gICAgICAgIHByZU5vdGVzVG9DbGllbnQ6IG51bGwsXHJcbiAgICAgICAgcG9zdE5vdGVzVG9DbGllbnQ6IG51bGwsXHJcbiAgICAgICAgcHJlTm90ZXNUb1NlbGY6IG51bGwsXHJcbiAgICAgICAgcG9zdE5vdGVzVG9TZWxmOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXHJcbiAgICAgICAgXHJcbiAgICAgICAgc291cmNlRXZlbnQ6IHtcclxuICAgICAgICAgICAgTW9kZWw6IENhbGVuZGFyRXZlbnQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc291cmNlQm9va2luZzoge1xyXG4gICAgICAgICAgICBNb2RlbDogQm9va2luZyxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vc291cmNlQm9va2luZ1JlcXVlc3QsIG1heWJlIGZ1dHVyZT9cclxuICAgIH0sIHZhbHVlcyk7XHJcblxyXG4gICAgLy8gU21hcnQgdmlzdWFsaXphdGlvbiBvZiBkYXRlIGFuZCB0aW1lXHJcbiAgICB0aGlzLmRpc3BsYXllZERhdGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLnN0YXJ0VGltZSgpKS5sb2NhbGUoJ2VuLVVTLUxDJykuY2FsZW5kYXIoKTtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRpc3BsYXllZFN0YXJ0VGltZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuc3RhcnRUaW1lKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5mb3JtYXQoJ0xUJyk7XHJcbiAgICAgICAgXHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5kaXNwbGF5ZWRFbmRUaW1lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBtb21lbnQodGhpcy5lbmRUaW1lKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5mb3JtYXQoJ0xUJyk7XHJcbiAgICAgICAgXHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5kaXNwbGF5ZWRUaW1lUmFuZ2UgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkU3RhcnRUaW1lKCkgKyAnLScgKyB0aGlzLmRpc3BsYXllZEVuZFRpbWUoKTtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLml0U3RhcnRlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRUaW1lKCkgJiYgbmV3IERhdGUoKSA+PSB0aGlzLnN0YXJ0VGltZSgpKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLml0RW5kZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmVuZFRpbWUoKSAmJiBuZXcgRGF0ZSgpID49IHRoaXMuZW5kVGltZSgpKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzTmV3ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoIXRoaXMuaWQoKSk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zdGF0ZUhlYWRlciA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGV4dCA9ICcnO1xyXG4gICAgICAgIGlmICghdGhpcy5pc05ldygpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLml0U3RhcnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdEVuZGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJ0NvbXBsZXRlZDonO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICdOb3c6JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSAnVXBjb21pbmc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICAgICAgXHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBcHBvaW50bWVudDtcclxuXHJcbi8qKlxyXG4gICAgQ3JlYXRlcyBhbiBhcHBvaW50bWVudCBpbnN0YW5jZSBmcm9tIGEgQ2FsZW5kYXJFdmVudCBtb2RlbCBpbnN0YW5jZVxyXG4qKi9cclxuQXBwb2ludG1lbnQuZnJvbUNhbGVuZGFyRXZlbnQgPSBmdW5jdGlvbiBmcm9tQ2FsZW5kYXJFdmVudChldmVudCkge1xyXG4gICAgdmFyIGFwdCA9IG5ldyBBcHBvaW50bWVudCgpO1xyXG4gICAgXHJcbiAgICAvLyBJbmNsdWRlIGV2ZW50IGluIGFwdFxyXG4gICAgYXB0LmlkKGV2ZW50LmNhbGVuZGFyRXZlbnRJRCgpKTtcclxuICAgIGFwdC5zdGFydFRpbWUoZXZlbnQuc3RhcnRUaW1lKCkpO1xyXG4gICAgYXB0LmVuZFRpbWUoZXZlbnQuZW5kVGltZSgpKTtcclxuICAgIGFwdC5zdW1tYXJ5KGV2ZW50LnN1bW1hcnkoKSk7XHJcbiAgICBhcHQuc291cmNlRXZlbnQoZXZlbnQpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gYXB0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBDcmVhdGVzIGFuIGFwcG9pbnRtZW50IGluc3RhbmNlIGZyb20gYSBCb29raW5nIGFuZCBhIENhbGVuZGFyRXZlbnQgbW9kZWwgaW5zdGFuY2VzXHJcbioqL1xyXG5BcHBvaW50bWVudC5mcm9tQm9va2luZyA9IGZ1bmN0aW9uIGZyb21Cb29raW5nKGJvb2tpbmcsIGV2ZW50KSB7XHJcbiAgICAvLyBJbmNsdWRlIGV2ZW50IGluIGFwdFxyXG4gICAgdmFyIGFwdCA9IEFwcG9pbnRtZW50LmZyb21DYWxlbmRhckV2ZW50KGV2ZW50KTtcclxuICAgIFxyXG4gICAgLy8gSW5jbHVkZSBib29raW5nIGluIGFwdFxyXG4gICAgYXB0LmN1c3RvbWVyVXNlcklEKGJvb2tpbmcuYm9va2luZ1JlcXVlc3QoKS5jdXN0b21lclVzZXJJRCgpKTtcclxuICAgIGFwdC5hZGRyZXNzSUQoYm9va2luZy5ib29raW5nUmVxdWVzdCgpLmFkZHJlc3NJRCgpKTtcclxuICAgIGFwdC5qb2JUaXRsZUlEKGJvb2tpbmcuYm9va2luZ1JlcXVlc3QoKS5qb2JUaXRsZUlEKCkpO1xyXG4gICAgYXB0LnByaWNpbmcoYm9va2luZy5ib29raW5nUmVxdWVzdCgpLnByaWNpbmdFc3RpbWF0ZSgpLmRldGFpbHMoKSk7XHJcbiAgICBhcHQucHJlTm90ZXNUb0NsaWVudChib29raW5nLnByZU5vdGVzVG9DbGllbnQoKSk7XHJcbiAgICBhcHQucG9zdE5vdGVzVG9DbGllbnQoYm9va2luZy5wb3N0Tm90ZXNUb0NsaWVudCgpKTtcclxuICAgIGFwdC5wcmVOb3Rlc1RvU2VsZihib29raW5nLnByZU5vdGVzVG9TZWxmKCkpO1xyXG4gICAgYXB0LnBvc3ROb3Rlc1RvU2VsZihib29raW5nLnBvc3ROb3Rlc1RvU2VsZigpKTtcclxuXHJcbiAgICB2YXIgcHJpY2VzID0gYm9va2luZy5ib29raW5nUmVxdWVzdCgpICYmIGJvb2tpbmcuYm9va2luZ1JlcXVlc3QoKS5wcmljaW5nRXN0aW1hdGUoKTtcclxuICAgIGlmIChwcmljZXMpIHtcclxuICAgICAgICAvLyBUT0RPIFNldHRpbmcgZnJlZWxhbmNlciBwcmljZSwgZm9yIGN1c3RvbWVycyBtdXN0IGJlXHJcbiAgICAgICAgLy8ganVzdCB0b3RhbFByaWNlKClcclxuICAgICAgICBhcHQucHJpY2UocHJpY2VzLnRvdGFsUHJpY2UoKSAtIHByaWNlcy5wRmVlUHJpY2UoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXB0LnNvdXJjZUJvb2tpbmcoYm9va2luZyk7XHJcblxyXG4gICAgcmV0dXJuIGFwdDtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgQ3JlYXRlcyBhIGxpc3Qgb2YgYXBwb2ludG1lbnQgaW5zdGFuY2VzIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnRzIGFuZCBib29raW5ncy5cclxuICAgIFRoZSBib29raW5ncyBsaXN0IG11c3QgY29udGFpbiBldmVyeSBib29raW5nIHRoYXQgYmVsb25ncyB0byB0aGUgZXZlbnRzIG9mIHR5cGVcclxuICAgICdib29raW5nJyBmcm9tIHRoZSBsaXN0IG9mIGV2ZW50cy5cclxuKiovXHJcbkFwcG9pbnRtZW50Lmxpc3RGcm9tQ2FsZW5kYXJFdmVudHNCb29raW5ncyA9IGZ1bmN0aW9uIGxpc3RGcm9tQ2FsZW5kYXJFdmVudHNCb29raW5ncyhldmVudHMsIGJvb2tpbmdzKSB7XHJcbiAgICByZXR1cm4gZXZlbnRzLm1hcChmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIHZhciBib29raW5nID0gbnVsbDtcclxuICAgICAgICBib29raW5ncy5zb21lKGZ1bmN0aW9uKHNlYXJjaEJvb2tpbmcpIHtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gc2VhcmNoQm9va2luZy5jb25maXJtZWREYXRlSUQoKSA9PT0gZXZlbnQuY2FsZW5kYXJFdmVudElEKCk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgYm9va2luZyA9IHNlYXJjaEJvb2tpbmc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoYm9va2luZylcclxuICAgICAgICAgICAgcmV0dXJuIEFwcG9pbnRtZW50LmZyb21Cb29raW5nKGJvb2tpbmcsIGV2ZW50KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tQ2FsZW5kYXJFdmVudChldmVudCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbnZhciBUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvVGltZScpO1xyXG4vKipcclxuICAgIENyZWF0ZXMgYW4gQXBwb2ludG1lbnQgaW5zdGFuY2UgdGhhdCByZXByZXNlbnRzIGEgY2FsZW5kYXIgc2xvdCBvZlxyXG4gICAgZnJlZS9zcGFyZSB0aW1lLCBmb3IgdGhlIGdpdmVuIHRpbWUgcmFuZ2UsIG9yIHRoZSBmdWxsIGdpdmVuIGRhdGUuXHJcbiAgICBAcGFyYW0gb3B0aW9uczpPYmplY3Qge1xyXG4gICAgICAgIGRhdGU6RGF0ZS4gT3B0aW9uYWwuIFVzZWQgdG8gY3JlYXRlIGEgZnVsbCBkYXRlIHNsb3Qgb3IgZGVmYXVsdCBmb3Igc3RhcnQvZW5kXHJcbiAgICAgICAgICAgIHRvIGRhdGUgc3RhcnQgb3IgZGF0ZSBlbmRcclxuICAgICAgICBzdGFydDpEYXRlLiBPcHRpb25hbC4gQmVnZ2luaW5nIG9mIHRoZSBzbG90XHJcbiAgICAgICAgZW5kOkRhdGUuIE9wdGlvbmFsLiBFbmRpbmcgb2YgdGhlIHNsb3RcclxuICAgICAgICB0ZXh0OnN0cmluZy4gT3B0aW9uYWwgWydGcmVlJ10uIFRvIGFsbG93IGV4dGVybmFsIGxvY2FsaXphdGlvbiBvZiB0aGUgdGV4dC5cclxuICAgIH1cclxuKiovXHJcbkFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90ID0gZnVuY3Rpb24gbmV3RnJlZVNsb3Qob3B0aW9ucykge1xyXG4gICAgXHJcbiAgICB2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IG5ldyBUaW1lKG9wdGlvbnMuZGF0ZSwgMCwgMCwgMCksXHJcbiAgICAgICAgZW5kID0gb3B0aW9ucy5lbmQgfHwgbmV3IFRpbWUob3B0aW9ucy5kYXRlLCAwLCAwLCAwKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEFwcG9pbnRtZW50KHtcclxuICAgICAgICBpZDogLTIsXHJcblxyXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnQsXHJcbiAgICAgICAgZW5kVGltZTogZW5kLFxyXG5cclxuICAgICAgICBzdW1tYXJ5OiBvcHRpb25zLnRleHQgfHwgJ0ZyZWUnLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsXHJcbiAgICB9KTtcclxufTtcclxuIiwiLyoqIEJvb2tpbmcgbW9kZWwuXHJcblxyXG4gICAgRGVzY3JpYmVzIGEgYm9va2luZyB3aXRoIHJlbGF0ZWQgQm9va2luZ1JlcXVlc3QgXHJcbiAgICBhbmQgUHJpY2luZ0VzdGltYXRlIG9iamVjdHMuXHJcbiAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgQm9va2luZ1JlcXVlc3QgPSByZXF1aXJlKCcuL0Jvb2tpbmdSZXF1ZXN0Jyk7XHJcblxyXG5mdW5jdGlvbiBCb29raW5nKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGJvb2tpbmdJRDogMCxcclxuICAgICAgICBib29raW5nUmVxdWVzdElEOiAwLFxyXG4gICAgICAgIGNvbmZpcm1lZERhdGVJRDogbnVsbCxcclxuICAgICAgICB0b3RhbFByaWNlUGFpZEJ5Q3VzdG9tZXI6IG51bGwsXHJcbiAgICAgICAgdG90YWxTZXJ2aWNlRmVlc1BhaWRCeUN1c3RvbWVyOiBudWxsLFxyXG4gICAgICAgIHRvdGFsUGFpZFRvRnJlZWxhbmNlcjogbnVsbCxcclxuICAgICAgICB0b3RhbFNlcnZpY2VGZWVzUGFpZEJ5RnJlZWxhbmNlcjogbnVsbCxcclxuICAgICAgICBib29raW5nU3RhdHVzSUQ6IG51bGwsXHJcbiAgICAgICAgcHJpY2luZ0FkanVzdG1lbnRBcHBsaWVkOiBmYWxzZSxcclxuICAgICAgICBcclxuICAgICAgICBwcmVOb3Rlc1RvQ2xpZW50OiBudWxsLFxyXG4gICAgICAgIHBvc3ROb3Rlc1RvQ2xpZW50OiBudWxsLFxyXG4gICAgICAgIHByZU5vdGVzVG9TZWxmOiBudWxsLFxyXG4gICAgICAgIHBvc3ROb3Rlc1RvU2VsZjogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICByZXZpZXdlZEJ5RnJlZWxhbmNlcjogZmFsc2UsXHJcbiAgICAgICAgcmV2aWV3ZWRCeUN1c3RvbWVyOiBmYWxzZSxcclxuICAgICAgICBcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBib29raW5nUmVxdWVzdDogbmV3IEJvb2tpbmdSZXF1ZXN0KClcclxuICAgIH0sIHZhbHVlcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9va2luZztcclxuIiwiLyoqXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBQcmljaW5nRXN0aW1hdGUgPSByZXF1aXJlKCcuL1ByaWNpbmdFc3RpbWF0ZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBCb29raW5nUmVxdWVzdCh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBib29raW5nUmVxdWVzdElEOiAwLFxyXG4gICAgICAgIGJvb2tpbmdUeXBlSUQ6IDAsXHJcbiAgICAgICAgY3VzdG9tZXJVc2VySUQ6IDAsXHJcbiAgICAgICAgZnJlZWxhbmNlclVzZXJJRDogMCxcclxuICAgICAgICBqb2JUaXRsZUlEOiAwLFxyXG4gICAgICAgIHByaWNpbmdFc3RpbWF0ZUlEOiAwLFxyXG4gICAgICAgIGJvb2tpbmdSZXF1ZXN0U3RhdHVzSUQ6IDAsXHJcbiAgICAgICAgXHJcbiAgICAgICAgc3BlY2lhbFJlcXVlc3RzOiBudWxsLFxyXG4gICAgICAgIHByZWZlcnJlZERhdGVJRDogbnVsbCxcclxuICAgICAgICBhbHRlcm5hdGl2ZURhdGUxSUQ6IG51bGwsXHJcbiAgICAgICAgYWx0ZXJuYXRpdmVEYXRlMklEOiBudWxsLFxyXG4gICAgICAgIGFkZHJlc3NJRDogbnVsbCxcclxuICAgICAgICBjYW5jZWxsYXRpb25Qb2xpY3lJRDogbnVsbCxcclxuICAgICAgICBpbnN0YW50Qm9va2luZzogZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJpY2luZ0VzdGltYXRlOiBuZXcgUHJpY2luZ0VzdGltYXRlKClcclxuICAgIH0sIHZhbHVlcyk7XHJcbn07XHJcbiIsIi8qKiBCb29raW5nU3VtbWFyeSBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XHJcbiAgICBcclxuZnVuY3Rpb24gQm9va2luZ1N1bW1hcnkodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgcXVhbnRpdHk6IDAsXHJcbiAgICAgICAgY29uY2VwdDogJycsXHJcbiAgICAgICAgdGltZTogbnVsbCxcclxuICAgICAgICB0aW1lRm9ybWF0OiAnIFtAXSBoOm1tYSdcclxuICAgIH0sIHZhbHVlcyk7XHJcblxyXG4gICAgdGhpcy5waHJhc2UgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgdCA9IHRoaXMudGltZUZvcm1hdCgpICYmIFxyXG4gICAgICAgICAgICB0aGlzLnRpbWUoKSAmJiBcclxuICAgICAgICAgICAgbW9tZW50KHRoaXMudGltZSgpKS5mb3JtYXQodGhpcy50aW1lRm9ybWF0KCkpIHx8XHJcbiAgICAgICAgICAgICcnOyAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2VwdCgpICsgdDtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMudXJsID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnRpbWUoKSAmJlxyXG4gICAgICAgICAgICAnL2NhbGVuZGFyLycgKyB0aGlzLnRpbWUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCb29raW5nU3VtbWFyeTtcclxuIiwiLyoqXHJcbiAgICBFdmVudCBtb2RlbFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogRXhhbXBsZSBKU09OIChyZXR1cm5lZCBieSB0aGUgUkVTVCBBUEkpOlxyXG57XHJcbiAgXCJFdmVudElEXCI6IDM1MyxcclxuICBcIlVzZXJJRFwiOiAxNDEsXHJcbiAgXCJFdmVudFR5cGVJRFwiOiAzLFxyXG4gIFwiU3VtbWFyeVwiOiBcIkhvdXNla2VlcGVyIHNlcnZpY2VzIGZvciBKb2huIEQuXCIsXHJcbiAgXCJBdmFpbGFiaWxpdHlUeXBlSURcIjogMyxcclxuICBcIlN0YXJ0VGltZVwiOiBcIjIwMTQtMDMtMjVUMDg6MDA6MDBaXCIsXHJcbiAgXCJFbmRUaW1lXCI6IFwiMjAxNC0wMy0yNVQxODowMDowMFpcIixcclxuICBcIktpbmRcIjogMCxcclxuICBcIklzQWxsRGF5XCI6IGZhbHNlLFxyXG4gIFwiVGltZVpvbmVcIjogXCIwMTowMDowMFwiLFxyXG4gIFwiTG9jYXRpb25cIjogXCJudWxsXCIsXHJcbiAgXCJVcGRhdGVkRGF0ZVwiOiBcIjIwMTQtMTAtMzBUMTU6NDQ6NDkuNjUzXCIsXHJcbiAgXCJDcmVhdGVkRGF0ZVwiOiBudWxsLFxyXG4gIFwiRGVzY3JpcHRpb25cIjogXCJ0ZXN0IGRlc2NyaXB0aW9uIG9mIGEgUkVTVCBldmVudFwiLFxyXG4gIFwiUmVjdXJyZW5jZVJ1bGVcIjoge1xyXG4gICAgXCJGcmVxdWVuY3lUeXBlSURcIjogNTAyLFxyXG4gICAgXCJJbnRlcnZhbFwiOiAxLFxyXG4gICAgXCJVbnRpbFwiOiBcIjIwMTQtMDctMDFUMDA6MDA6MDBcIixcclxuICAgIFwiQ291bnRcIjogbnVsbCxcclxuICAgIFwiRW5kaW5nXCI6IFwiZGF0ZVwiLFxyXG4gICAgXCJTZWxlY3RlZFdlZWtEYXlzXCI6IFtcclxuICAgICAgMSxcclxuICAgIF0sXHJcbiAgICBcIk1vbnRobHlXZWVrRGF5XCI6IGZhbHNlLFxyXG4gICAgXCJJbmNvbXBhdGlibGVcIjogZmFsc2UsXHJcbiAgICBcIlRvb01hbnlcIjogZmFsc2VcclxuICB9LFxyXG4gIFwiUmVjdXJyZW5jZU9jY3VycmVuY2VzXCI6IG51bGwsXHJcbiAgXCJSZWFkT25seVwiOiBmYWxzZVxyXG59Ki9cclxuXHJcbmZ1bmN0aW9uIFJlY3VycmVuY2VSdWxlKHZhbHVlcykge1xyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgZnJlcXVlbmN5VHlwZUlEOiAwLFxyXG4gICAgICAgIGludGVydmFsOiAxLCAvLzpJbnRlZ2VyXHJcbiAgICAgICAgdW50aWw6IG51bGwsIC8vOkRhdGVcclxuICAgICAgICBjb3VudDogbnVsbCwgLy86SW50ZWdlclxyXG4gICAgICAgIGVuZGluZzogbnVsbCwgLy8gOnN0cmluZyBQb3NzaWJsZSB2YWx1ZXMgYWxsb3dlZDogJ25ldmVyJywgJ2RhdGUnLCAnb2N1cnJlbmNlcydcclxuICAgICAgICBzZWxlY3RlZFdlZWtEYXlzOiBbXSwgLy8gOmludGVnZXJbXSAwOlN1bmRheVxyXG4gICAgICAgIG1vbnRobHlXZWVrRGF5OiBmYWxzZSxcclxuICAgICAgICBpbmNvbXBhdGlibGU6IGZhbHNlLFxyXG4gICAgICAgIHRvb01hbnk6IGZhbHNlXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZWN1cnJlbmNlT2NjdXJyZW5jZSh2YWx1ZXMpIHtcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIHN0YXJ0VGltZTogbnVsbCwgLy86RGF0ZVxyXG4gICAgICAgIGVuZFRpbWU6IG51bGwgLy86RGF0ZVxyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG4gICBcclxuZnVuY3Rpb24gQ2FsZW5kYXJFdmVudCh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIC8vIFNwZWNpYWwgdmFsdWVzOiBkYXRlcyBtdXN0IGJlIGNvbnZlcnRlZFxyXG4gICAgLy8gdG8gYSBEYXRlIG9iamVjdC4gVGhleSBjb21lIGFzIElTTyBzdHJpbmdcclxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzb21ldGhpbmcgZ2VuZXJpYywgb3IgZXZlbiBpbiBNb2RlbCBkZWZpbml0aW9ucyxcclxuICAgIC8vIGFuZCB1c2UgZm9yIHVwZGF0ZWQvY3JlYXRlZERhdGUgYXJvdW5kIGFsbCB0aGUgcHJvamVjdFxyXG4gICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgIHZhbHVlcy5zdGFydFRpbWUgPSB2YWx1ZXMuc3RhcnRUaW1lICYmIG5ldyBEYXRlKERhdGUucGFyc2UodmFsdWVzLnN0YXJ0VGltZSkpIHx8IG51bGw7XHJcbiAgICAgICAgdmFsdWVzLmVuZFRpbWUgPSB2YWx1ZXMuZW5kVGltZSAmJiBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlcy5lbmRUaW1lKSkgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGNhbGVuZGFyRXZlbnRJRDogMCxcclxuICAgICAgICB1c2VySUQ6IDAsXHJcbiAgICAgICAgZXZlbnRUeXBlSUQ6IDMsXHJcbiAgICAgICAgc3VtbWFyeTogJycsXHJcbiAgICAgICAgYXZhaWxhYmlsaXR5VHlwZUlEOiAwLFxyXG4gICAgICAgIHN0YXJ0VGltZTogbnVsbCxcclxuICAgICAgICBlbmRUaW1lOiBudWxsLFxyXG4gICAgICAgIGtpbmQ6IDAsXHJcbiAgICAgICAgaXNBbGxEYXk6IGZhbHNlLFxyXG4gICAgICAgIHRpbWVab25lOiAnWicsXHJcbiAgICAgICAgbG9jYXRpb246IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgZGVzY3JpcHRpb246ICcnLFxyXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZVxyXG4gICAgfSwgdmFsdWVzKTtcclxuXHJcbiAgICB0aGlzLnJlY3VycmVuY2VSdWxlID0ga28ub2JzZXJ2YWJsZShcclxuICAgICAgICB2YWx1ZXMgJiYgXHJcbiAgICAgICAgdmFsdWVzLnJlY3VycmVuY2VSdWxlICYmIFxyXG4gICAgICAgIG5ldyBSZWN1cnJlbmNlUnVsZSh2YWx1ZXMucmVjdXJyZW5jZVJ1bGUpXHJcbiAgICApO1xyXG4gICAgdGhpcy5yZWN1cnJlbmNlT2NjdXJyZW5jZXMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pOyAvLzpSZWN1cnJlbmNlT2NjdXJyZW5jZVtdXHJcbiAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5yZWN1cnJlbmNlT2NjdXJyZW5jZXMpIHtcclxuICAgICAgICB2YWx1ZXMucmVjdXJyZW5jZU9jY3VycmVuY2VzLmZvckVhY2goZnVuY3Rpb24ob2NjdXJyZW5jZSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5SZWN1cnJlbmNlT2NjdXJyZW5jZXMucHVzaChuZXcgUmVjdXJyZW5jZU9jY3VycmVuY2Uob2NjdXJyZW5jZSkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbGVuZGFyRXZlbnQ7XHJcblxyXG5DYWxlbmRhckV2ZW50LlJlY3VycmVuY2VSdWxlID0gUmVjdXJyZW5jZVJ1bGU7XHJcbkNhbGVuZGFyRXZlbnQuUmVjdXJyZW5jZU9jY3VycmVuY2UgPSBSZWN1cnJlbmNlT2NjdXJyZW5jZTsiLCIvKipcclxuICAgIENhbGVuZGFyU3luY2luZyBtb2RlbC5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG5mdW5jdGlvbiBDYWxlbmRhclN5bmNpbmcodmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBpY2FsRXhwb3J0VXJsOiAnJyxcclxuICAgICAgICBpY2FsSW1wb3J0VXJsOiAnJ1xyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWxlbmRhclN5bmNpbmc7XHJcbiIsIi8qKiBDdXN0b21lciBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gQ3VzdG9tZXIodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGN1c3RvbWVyVXNlcklEOiAwLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGZpcnN0TmFtZTogJycsXHJcbiAgICAgICAgbGFzdE5hbWU6ICcnLFxyXG4gICAgICAgIHNlY29uZExhc3ROYW1lOiAnJyxcclxuICAgICAgICBlbWFpbDogJycsXHJcbiAgICAgICAgcGhvbmU6IG51bGwsXHJcbiAgICAgICAgY2FuUmVjZWl2ZVNtczogZmFsc2UsXHJcbiAgICAgICAgYmlydGhNb250aERheTogbnVsbCxcclxuICAgICAgICBiaXJ0aE1vbnRoOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIG5vdGVzQWJvdXRDdXN0b21lcjogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICBlZGl0YWJsZTogZmFsc2VcclxuICAgIH0sIHZhbHVlcyk7XHJcblxyXG4gICAgdGhpcy5mdWxsTmFtZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKCh0aGlzLmZpcnN0TmFtZSgpIHx8ICcnKSArICcgJyArICh0aGlzLmxhc3ROYW1lKCkgfHwgJycpKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmJpcnRoRGF5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJpcnRoTW9udGhEYXkoKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmJpcnRoTW9udGgoKSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVE9ETyBpMTBuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpcnRoTW9udGgoKSArICcvJyArIHRoaXMuYmlydGhNb250aERheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VzdG9tZXI7XHJcbiIsIi8qKlxyXG4gICAgRnJlZWxhbmNlciBQcmljaW5nIG1vZGVsOiBtYW5hZ2VzIGFuIGluZGl2aWR1YWxcclxuICAgIHByaWNpbmcvcGFja2FnZSBmcm9tIHRoZSB1c2VyIGFuZCBhIHNwZWNpZmljIGpvYiB0aXRsZS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIG51bWVyYWwgPSByZXF1aXJlKCdudW1lcmFsJyk7XHJcblxyXG5mdW5jdGlvbiBGcmVlbGFuY2VyUHJpY2luZyh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgZnJlZWxhbmNlclByaWNpbmdJRDogMCxcclxuICAgICAgICBmcmVlbGFuY2VyVXNlcklEOiAwLFxyXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXHJcbiAgICAgICAgcHJpY2luZ1R5cGVJRDogMCxcclxuICAgICAgICBuYW1lOiAnJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcclxuICAgICAgICBwcmljZTogbnVsbCxcclxuICAgICAgICBzZXJ2aWNlRHVyYXRpb25NaW51dGVzOiBudWxsLFxyXG4gICAgICAgIGZpcnN0VGltZUNsaWVudHNPbmx5OiBmYWxzZSxcclxuICAgICAgICBudW1iZXJPZlNlc3Npb25zOiAxLFxyXG4gICAgICAgIHByaWNlUmF0ZTogbnVsbCxcclxuICAgICAgICBwcmljZVJhdGVVbml0OiAnaG91cicsXHJcbiAgICAgICAgLy8gU3BlY2lhbCBwcm9wZXJ0eSwgbm90IGluIHNvdXJjZSBkYXRhIGp1c3Qgb25seSBhbiBleHBsaWNpdFxyXG4gICAgICAgIC8vIHdheSB0byBhdm9pZCB2YWxpZGF0aW9uIG9mIHByaWNlUmF0ZSBpZiBub3QgZXhwbGljaXQgdmFsdWUgc2V0XHJcbiAgICAgICAgbm9QcmljZVJhdGU6IGZhbHNlLFxyXG4gICAgICAgIGlzUGhvbmU6IGZhbHNlLFxyXG4gICAgICAgIC8vIEFycmF5IG9mIGludGVnZXJzLCBJRHMgb2Ygc2VydmljZUF0dHJpYnV0ZXNcclxuICAgICAgICBzZXJ2aWNlQXR0cmlidXRlczogW10sXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmSUQoWydmcmVlbGFuY2VyUHJpY2luZ0lEJ10pO1xyXG4gICAgXHJcbiAgICAvLyBPbmUgd2F5IGVmZmVjdDogc2V0IHByaWNlUmF0ZSB0byBudWxsIHdoZW4gc2V0dGluZyBvbiBub1ByaWNlUmF0ZVxyXG4gICAgLy8gQnV0IG5vdGhpbmcgb24gb2ZmIGFuZCBubyBvdGhlciByZWxhdGlvbnMgdG8gYXZvaWQgYmFkIHNpZGUgZWZmZWN0cy5cclxuICAgIHRoaXMubm9QcmljZVJhdGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGVuYWJsZWQpIHtcclxuICAgICAgICBpZiAoZW5hYmxlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnByaWNlUmF0ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgQXNrIGZvciBhIHJlZnJlc2ggb2YgdGhlIG5vUHJpY2VSYXRlLCB0aGF0IG11c3QgYmUgJ3RydWUnIGlmIHRoZSByZWNvcmQgZXhpc3RzIGFuZFxyXG4gICAgICAgIGhhcyBubyBwcmljZVJhdGUgKHRvIHJlbWVtYmVyIHRoZSBwcmV2aW91cyB2YWx1ZSBzZXQgYnkgdGhlIHVzZXIgYWJvdXQgbm9QcmljZVJhdGUpLlxyXG4gICAgICAgIEl0IGVuc3VyZSB0aGF0IHRoZSBpbnRlcm5hbCB0aW1lc3RhbXAga2VlcCB1bnRvdWNoZWQuXHJcbiAgICAgICAgQ2Fubm90IGJlIGF1dG9tYXRpYywgc28gbmVlZCB0byBiZSBjYWxsZWQgbWFudWFsbHkgYWZ0ZXIgYSBkYXRhIGxvYWQgdGhhdCBkb2VzIG5vdFxyXG4gICAgICAgIHdhbnQgdG8gcmVmbGVjdCB0aGlzIGNoYW5nZSBhcyBhIGRhdGEgY2hhbmdlLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLnJlZnJlc2hOb1ByaWNlUmF0ZSA9IGZ1bmN0aW9uIHJlZnJlc2hOb1ByaWNlUmF0ZSgpIHtcclxuICAgICAgICAvLyBOb3QgVG8gU3RhdGUgUHJpY2UgUmF0ZTogaWYgaXMgYSBzYXZlZCBwcmljaW5nLCBtYXJrIHRoZSBub1ByaWNlUmF0ZSBpZiBwcmljZSByYXRlIGlzXHJcbiAgICAgICAgLy8gbnVsbCBvciAwOyBjYW5ub3QgYmUgZG9uZSB3aXRoIGEgc3Vic2NyaXB0aW9uIG9uIHByaWNlUmF0ZSBjaGFuZ2VzIGJlY2F1c2Ugd2lsbCBoYXZlXHJcbiAgICAgICAgLy8gdGhlIGJhZCBzaWRlIGVmZmVjdCBvZiBhdXRvIG1hcmsgbm9QcmljZVJhdGUgb24gc2V0dGluZyAwIG9uIHByaWNlUmF0ZSwgYnJlYWtpbmcgdGhlXHJcbiAgICAgICAgLy8gZXhwbGljaXQgcHVycG9zZSBvZiB0aGUgbm9QcmljZVJhdGUgY2hlY2tib3g6XHJcbiAgICAgICAgaWYgKHRoaXMuZnJlZWxhbmNlclByaWNpbmdJRCgpICYmICh0aGlzLnByaWNlUmF0ZSgpIHwwKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0cyA9IHRoaXMubW9kZWwuZGF0YVRpbWVzdGFtcCgpO1xyXG4gICAgICAgICAgICB0aGlzLm5vUHJpY2VSYXRlKHRydWUpO1xyXG4gICAgICAgICAgICAvLyBTZXQgYWdhaW4gdGltZXN0YW1wIHNvIHRoZSBtb2RlbCBhcHBlYXIgYXMgdW50b3VjaGVkLlxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLmRhdGFUaW1lc3RhbXAodHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gQWx0ZXJuYXRpdmUgZWRpdGlvbiBvZiB0aGUgc2VydmljZUR1cmF0aW9uTWludXRlcyBmaWVsZHM6XHJcbiAgICAvLyBTcGxpdGVkIGFzIGhvdXJzIGFuZCBtaW51dGVzXHJcbiAgICB2YXIgaXMgPSByZXF1aXJlKCdpc19qcycpO1xyXG4gICAgdGhpcy5kdXJhdGlvbkhvdXJzUGFydCA9IGtvLnB1cmVDb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBmdWxsTWludXRlcyA9IHRoaXMuc2VydmljZUR1cmF0aW9uTWludXRlcygpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGlzLm5vdC5udW1iZXIoZnVsbE1pbnV0ZXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKChmdWxsTWludXRlc3wwKSAvIDYwKSB8MDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbihob3Vycykge1xyXG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IHRoaXMuZHVyYXRpb25NaW51dGVzUGFydCgpIHwwO1xyXG4gICAgICAgICAgICAvLyBWYWx1ZSBjb21lcyBmcm9tIHRleHRcclxuICAgICAgICAgICAgaG91cnMgPSBwYXJzZUludChob3VycywgMTApO1xyXG4gICAgICAgICAgICBpZiAoaXMubm90Lm51bWJlcihob3VycykpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMobnVsbCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZUR1cmF0aW9uTWludXRlcygoaG91cnN8MCkgKiA2MCArIG1pbnV0ZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3duZXI6IHRoaXNcclxuICAgIH0pO1xyXG4gICAgdGhpcy5kdXJhdGlvbk1pbnV0ZXNQYXJ0ID0ga28ucHVyZUNvbXB1dGVkKHtcclxuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGZ1bGxNaW51dGVzID0gdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXMubm90Lm51bWJlcihmdWxsTWludXRlcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoZnVsbE1pbnV0ZXN8MCkgJSA2MDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbihtaW51dGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBob3VycyA9IHRoaXMuZHVyYXRpb25Ib3Vyc1BhcnQoKSB8MDtcclxuICAgICAgICAgICAgLy8gVmFsdWUgY29tZXMgZnJvbSB0ZXh0XHJcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludChtaW51dGVzLCAxMCk7XHJcbiAgICAgICAgICAgIGlmIChpcy5ub3QubnVtYmVyKG1pbnV0ZXMpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKG51bGwpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoaG91cnMgKiA2MCArIChtaW51dGVzfDApKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgXHJcbiAgICAvLy8gVmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHNldmVyYWwgZmllbGRzXHJcbiAgICBcclxuICAgIHRoaXMuZHVyYXRpb25UZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtaW51dGVzID0gdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKCkgfHwgMDtcclxuICAgICAgICAvLyBUT0RPOiBsMTBuXHJcbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPyBudW1lcmFsKG1pbnV0ZXMpLmZvcm1hdCgnMCwwJykgKyAnIG1pbnV0ZXMnIDogJyc7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zZXNzaW9uc0FuZER1cmF0aW9uID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzZXNzaW9ucyA9IHRoaXMubnVtYmVyT2ZTZXNzaW9ucygpLFxyXG4gICAgICAgICAgICBkdXIgPSB0aGlzLmR1cmF0aW9uVGV4dCgpO1xyXG4gICAgICAgIGlmIChzZXNzaW9ucyA+IDEpXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGwxMG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25zICsgJyBzZXNzaW9ucywgJyArIGR1cjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBkdXI7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLmRpc3BsYXllZFByaWNlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwcmljZSA9IHRoaXMucHJpY2UoKSxcclxuICAgICAgICAgICAgcmF0ZSA9IHRoaXMucHJpY2VSYXRlKCksXHJcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLnByaWNlUmF0ZVVuaXQoKSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gcHJpY2UgfHwgcmF0ZTtcclxuICAgICAgICAvLyBGb3JtYXR0aW5nXHJcbiAgICAgICAgcmVzdWx0ID0gbnVtZXJhbChyZXN1bHQpLmZvcm1hdCgnJDAsMCcpO1xyXG4gICAgICAgIC8vIElmIGlzIG5vdCBwcmljZSBidXQgcmF0ZSwgYWRkIHVuaXRcclxuICAgICAgICBpZiAoIXByaWNlICYmIHJhdGUgJiYgdW5pdCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJy8nICsgdW5pdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZyZWVsYW5jZXJQcmljaW5nO1xyXG4iLCIvKiogR2V0TW9yZSBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgTGlzdFZpZXdJdGVtID0gcmVxdWlyZSgnLi9MaXN0Vmlld0l0ZW0nKTtcclxuXHJcbmZ1bmN0aW9uIEdldE1vcmUodmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBhdmFpbGFiaWxpdHk6IGZhbHNlLFxyXG4gICAgICAgIHBheW1lbnRzOiBmYWxzZSxcclxuICAgICAgICBwcm9maWxlOiBmYWxzZSxcclxuICAgICAgICBjb29wOiB0cnVlXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICB2YXIgYXZhaWxhYmxlSXRlbXMgPSB7XHJcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBuZXcgTGlzdFZpZXdJdGVtKHtcclxuICAgICAgICAgICAgY29udGVudExpbmUxOiAnQ29tcGxldGUgeW91ciBhdmFpbGFiaWxpdHkgdG8gY3JlYXRlIGEgY2xlYW5lciBjYWxlbmRhcicsXHJcbiAgICAgICAgICAgIG1hcmtlckljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWNhbGVuZGFyJyxcclxuICAgICAgICAgICAgYWN0aW9uSWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBwYXltZW50czogbmV3IExpc3RWaWV3SXRlbSh7XHJcbiAgICAgICAgICAgIGNvbnRlbnRMaW5lMTogJ1N0YXJ0IGFjY2VwdGluZyBwYXltZW50cyB0aHJvdWdoIExvY29ub21pY3MnLFxyXG4gICAgICAgICAgICBtYXJrZXJJY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi11c2QnLFxyXG4gICAgICAgICAgICBhY3Rpb25JY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0J1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHByb2ZpbGU6IG5ldyBMaXN0Vmlld0l0ZW0oe1xyXG4gICAgICAgICAgICBjb250ZW50TGluZTE6ICdBY3RpdmF0ZSB5b3VyIHByb2ZpbGUgaW4gdGhlIG1hcmtldHBsYWNlJyxcclxuICAgICAgICAgICAgbWFya2VySWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tdXNlcicsXHJcbiAgICAgICAgICAgIGFjdGlvbkljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHQnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgY29vcDogbmV3IExpc3RWaWV3SXRlbSh7XHJcbiAgICAgICAgICAgIGNvbnRlbnRMaW5lMTogJ0xlYXJuIG1vcmUgYWJvdXQgb3VyIGNvb3BlcmF0aXZlJyxcclxuICAgICAgICAgICAgYWN0aW9uSWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodCdcclxuICAgICAgICB9KVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLml0ZW1zID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIE9iamVjdC5rZXlzKGF2YWlsYWJsZUl0ZW1zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRoaXNba2V5XSgpKVxyXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChhdmFpbGFibGVJdGVtc1trZXldKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZXRNb3JlO1xyXG4iLCIvKiogSm9iVGl0bGUgbW9kZWwgKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIEpvYlRpdGxlUHJpY2luZ1R5cGUgPSByZXF1aXJlKCcuL0pvYlRpdGxlUHJpY2luZ1R5cGUnKTtcclxuXHJcbmZ1bmN0aW9uIEpvYlRpdGxlKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBqb2JUaXRsZUlEOiAwLFxyXG4gICAgICAgIHNpbmd1bGFyTmFtZTogJycsXHJcbiAgICAgICAgcGx1cmFsTmFtZTogJycsXHJcbiAgICAgICAgYWxpYXNlczogJycsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXHJcbiAgICAgICAgc2VhcmNoRGVzY3JpcHRpb246IG51bGwsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZJRChbJ2pvYlRpdGxlSUQnXSk7XHJcblxyXG4gICAgLy8gVE9ETzogcmV2aWV3IGlmLCBub3QgcmVnaXN0ZXJlZCBhcyBhIHByb3BlcnR5LCB0aGUgbGlzdCBpcyB1cGRhdGVkXHJcbiAgICAvLyBvbiBzeW5jcyBieSB1c2luZyBtb2RlbC51cGRhdGVXaXRoXHJcblxyXG4gICAgLy8gUHJpY2luZyBUeXBlcyByZWxhdGlvbnNoaXAsXHJcbiAgICAvLyBjb2xsZWN0aW9uIG9mIEpvYlRpdGxlUHJpY2luZ1R5cGUgZW50aXRpZXNcclxuICAgIHRoaXMucHJpY2luZ1R5cGVzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuICAgIGlmICh2YWx1ZXMgJiYgdmFsdWVzLnByaWNpbmdUeXBlcykge1xyXG4gICAgICAgIHZhbHVlcy5wcmljaW5nVHlwZXMuZm9yRWFjaChmdW5jdGlvbihqb2JwcmljaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpY2luZ1R5cGVzLnB1c2gobmV3IEpvYlRpdGxlUHJpY2luZ1R5cGUoam9icHJpY2luZykpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSm9iVGl0bGU7XHJcbiIsIi8qKlxyXG4gICAgRGVmaW5lcyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYSBKb2JUaXRsZSBhbmQgYSBQcmljaW5nVHlwZS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIEpvYlRpdGxlUHJpY2luZ1R5cGUodmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgcHJpY2luZ1R5cGVJRDogMCxcclxuICAgICAgICAvLyBOT1RFOiBDbGllbnQgVHlwZSBpcyBtb3N0bHkgdW51c2VkIHRvZGF5IGJ1dCBleGlzdHNcclxuICAgICAgICAvLyBvbiBhbGwgZGF0YWJhc2UgcmVjb3Jkcy4gSXQgdXNlcyB0aGUgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIC8vIG9mIDEgYWxsIHRoZSB0aW1lIGZvciBub3cuXHJcbiAgICAgICAgY2xpZW50VHlwZUlEOiAxLFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZklEKFsncHJpY2luZ1R5cGVJRCcsICdjbGllbnRUeXBlSUQnXSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSm9iVGl0bGVQcmljaW5nVHlwZTtcclxuIiwiLyoqIExpc3RWaWV3SXRlbSBtb2RlbC5cclxuXHJcbiAgICBEZXNjcmliZXMgYSBnZW5lcmljIGl0ZW0gb2YgYVxyXG4gICAgTGlzdFZpZXcgY29tcG9uZW50LlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIExpc3RWaWV3SXRlbSh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBtYXJrZXJMaW5lMTogbnVsbCxcclxuICAgICAgICBtYXJrZXJMaW5lMjogbnVsbCxcclxuICAgICAgICBtYXJrZXJJY29uOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnRlbnRMaW5lMTogJycsXHJcbiAgICAgICAgY29udGVudExpbmUyOiBudWxsLFxyXG4gICAgICAgIGxpbms6ICcjJyxcclxuXHJcbiAgICAgICAgYWN0aW9uSWNvbjogbnVsbCxcclxuICAgICAgICBhY3Rpb25UZXh0OiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNsYXNzTmFtZXM6ICcnXHJcblxyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Vmlld0l0ZW07XHJcbiIsIi8qKiBNYWlsRm9sZGVyIG1vZGVsICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG5mdW5jdGlvbiBNYWlsRm9sZGVyKHZhbHVlcykge1xyXG5cclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxyXG4gICAgICAgIHRvcE51bWJlcjogMTBcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMudG9wID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uIHRvcChudW0pIHtcclxuICAgICAgICBpZiAobnVtKSB0aGlzLnRvcE51bWJlcihudW0pO1xyXG4gICAgICAgIHJldHVybiBfLmZpcnN0KHRoaXMubWVzc2FnZXMoKSwgdGhpcy50b3BOdW1iZXIoKSk7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYWlsRm9sZGVyO1xyXG4iLCIvKiogTWFya2V0cGxhY2VQcm9maWxlIG1vZGVsICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG5mdW5jdGlvbiBNYXJrZXRwbGFjZVByb2ZpbGUodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIHVzZXJJRDogMCxcclxuICAgICAgICBcclxuICAgICAgICBwdWJsaWNCaW86ICcnLFxyXG4gICAgICAgIGZyZWVsYW5jZXJQcm9maWxlVXJsU2x1ZzogJycsXHJcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNlcnZlci1zaWRlIGNvbXB1dGVkIHZhcmlhYmxlIChyZWFkLW9ubHkgZm9yIHRoZSB1c2VyKSBmb3IgYSBMb2Nvbm9taWNzIGFkZHJlc3NcclxuICAgICAgICAvLyBjcmVhdGVkIHVzaW5nIHRoZSBmcmVlbGFuY2VyUHJvZmlsZVVybFNsdWcgaWYgYW55IG9yIHRoZSBmYWxsYmFjayBzeXN0ZW0gVVJMLlxyXG4gICAgICAgIGZyZWVsYW5jZXJQcm9maWxlVXJsOiAnJyxcclxuICAgICAgICAvLyBTcGVjaWZ5IGFuIGV4dGVybmFsIHdlYnNpdGUgb2YgdGhlIGZyZWVsYW5jZXIuXHJcbiAgICAgICAgZnJlZWxhbmNlcldlYnNpdGVVcmw6ICcnLFxyXG4gICAgICAgIC8vIFNlcnZlci1zaWRlIGdlbmVyYXRlZCBjb2RlIHRoYXQgYWxsb3dzIHRvIGlkZW50aWZpY2F0ZSBzcGVjaWFsIGJvb2tpbmcgcmVxdWVzdHNcclxuICAgICAgICAvLyBmcm9tIHRoZSBib29rLW1lLW5vdyBidXR0b24uIFRoZSBzZXJ2ZXIgZW5zdXJlcyB0aGF0IHRoZXJlIGlzIGV2ZXIgYSB2YWx1ZSBvbiB0aGlzIGZvciBmcmVlbGFuY2Vycy5cclxuICAgICAgICBib29rQ29kZTogJycsXHJcblxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtldHBsYWNlUHJvZmlsZTtcclxuIiwiLyoqIE1lc3NhZ2UgbW9kZWwuXHJcblxyXG4gICAgRGVzY3JpYmVzIGEgbWVzc2FnZSB0aGF0IGJlbG9uZ3MgdG8gYSBUaHJlYWQuXHJcbiAgICBBIG1lc3NhZ2UgY291bGQgYmUgb2YgZGlmZmVyZW50IHR5cGVzLFxyXG4gICAgYXMgaW5xdWlyaWVzLCBib29raW5ncywgYm9va2luZyByZXF1ZXN0cy5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxuXHJcbmZ1bmN0aW9uIE1lc3NhZ2UodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgbWVzc2FnZUlEOiAwLFxyXG4gICAgICAgIHRocmVhZElEOiAwLFxyXG4gICAgICAgIHNlbnRCeVVzZXJJRDogbnVsbCxcclxuICAgICAgICB0eXBlSUQ6IG51bGwsXHJcbiAgICAgICAgYXV4VDogbnVsbCxcclxuICAgICAgICBhdXhJRDogbnVsbCxcclxuICAgICAgICBib2R5VGV4dDogJycsXHJcbiAgICAgICAgXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIC8vIFNtYXJ0IHZpc3VhbGl6YXRpb24gb2YgZGF0ZSBhbmQgdGltZVxyXG4gICAgdGhpcy5kaXNwbGF5ZWREYXRlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQodGhpcy5jcmVhdGVkRGF0ZSgpKS5sb2NhbGUoJ2VuLVVTLUxDJykuY2FsZW5kYXIoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRpc3BsYXllZFRpbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLmNyZWF0ZWREYXRlKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5mb3JtYXQoJ0xUJyk7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xyXG4iLCIvKiogTWVzc2FnZSBtb2RlbC5cclxuXHJcbiAgICBEZXNjcmliZXMgYSBtZXNzYWdlIGZyb20gYSBNYWlsRm9sZGVyLlxyXG4gICAgQSBtZXNzYWdlIGNvdWxkIGJlIG9mIGRpZmZlcmVudCB0eXBlcyxcclxuICAgIGFzIGlucXVpcmllcywgYm9va2luZ3MsIGJvb2tpbmcgcmVxdWVzdHMuXHJcbiAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XHJcblxyXG5mdW5jdGlvbiBNZXNzYWdlVmlldyh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBpZDogMCxcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBzdWJqZWN0OiAnJyxcclxuICAgICAgICBjb250ZW50OiBudWxsLFxyXG4gICAgICAgIGxpbms6ICcjJyxcclxuXHJcbiAgICAgICAgYWN0aW9uSWNvbjogbnVsbCxcclxuICAgICAgICBhY3Rpb25UZXh0OiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNsYXNzTmFtZXM6ICcnXHJcblxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgLy8gU21hcnQgdmlzdWFsaXphdGlvbiBvZiBkYXRlIGFuZCB0aW1lXHJcbiAgICB0aGlzLmRpc3BsYXllZERhdGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLmNyZWF0ZWREYXRlKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5jYWxlbmRhcigpO1xyXG4gICAgICAgIFxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuZGlzcGxheWVkVGltZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuY3JlYXRlZERhdGUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VWaWV3O1xyXG5cclxuLyoqXHJcbiAgICBDcmVhdGVzIGEgTWVzc2FnZVZpZXcgaW5zdGFuY2UgZnJvbSBhIFRocmVhZCBpbnN0YW5jZS5cclxuICAgIEl0J3MgYmV0dGVyIHRvIGhhdmUgYWxtb3N0IG9uZSBtZXNzYWdlIGluIHRoZSB0aHJlYWQgKHRoZSBsYXRlc3RcclxuICAgIG9uZSBmaXJzdCwgb3IgdGhlIG9uZSB0byBoaWdobGlnaHQpIHRvIGJ1aWxkIGFcclxuICAgIG1vcmUgZGV0YWlsZWQgTWVzc2FnZVZpZXdcclxuKiovXHJcbk1lc3NhZ2VWaWV3LmZyb21UaHJlYWQgPSBmdW5jdGlvbih0aHJlYWQpIHtcclxuICAgIFxyXG4gICAgdmFyIG1zZyA9IHRocmVhZC5tZXNzYWdlcygpO1xyXG4gICAgbXNnID0gbXNnICYmIG1zZ1swXSB8fCBudWxsO1xyXG4gICAgXHJcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWaWV3KHtcclxuICAgICAgICBpZDogdGhyZWFkLnRocmVhZElEKCksXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IHRocmVhZC5jcmVhdGVkRGF0ZSgpLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiB0aHJlYWQudXBkYXRlZERhdGUoKSxcclxuICAgICAgICBzdWJqZWN0OiB0aHJlYWQuc3ViamVjdCgpLFxyXG4gICAgICAgIGNvbnRlbnQ6IG1zZyAmJiBtc2cuYm9keVRleHQoKSB8fCAnJyxcclxuICAgICAgICBsaW5rOiAnIyEvY29udmVyc2F0aW9uLycgKyB0aHJlYWQudGhyZWFkSUQoKSxcclxuICAgICAgICBhY3Rpb25JY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1zaGFyZS1hbHQnLFxyXG4gICAgICAgIGFjdGlvblRleHQ6ICcnIC8vIEV4YW1wbGU6ICdMaXN0Vmlldy1pdGVtLS10YWctd2FybmluZydcclxuICAgIH0pO1xyXG59O1xyXG4iLCIvKipcclxuICAgIE1vZGVsIGNsYXNzIHRvIGhlbHAgYnVpbGQgbW9kZWxzLlxyXG5cclxuICAgIElzIG5vdCBleGFjdGx5IGFuICdPT1AgYmFzZScgY2xhc3MsIGJ1dCBwcm92aWRlc1xyXG4gICAgdXRpbGl0aWVzIHRvIG1vZGVscyBhbmQgYSBtb2RlbCBkZWZpbml0aW9uIG9iamVjdFxyXG4gICAgd2hlbiBleGVjdXRlZCBpbiB0aGVpciBjb25zdHJ1Y3RvcnMgYXM6XHJcbiAgICBcclxuICAgICcnJ1xyXG4gICAgZnVuY3Rpb24gTXlNb2RlbCgpIHtcclxuICAgICAgICBNb2RlbCh0aGlzKTtcclxuICAgICAgICAvLyBOb3csIHRoZXJlIGlzIGEgdGhpcy5tb2RlbCBwcm9wZXJ0eSB3aXRoXHJcbiAgICAgICAgLy8gYW4gaW5zdGFuY2Ugb2YgdGhlIE1vZGVsIGNsYXNzLCB3aXRoIFxyXG4gICAgICAgIC8vIHV0aWxpdGllcyBhbmQgbW9kZWwgc2V0dGluZ3MuXHJcbiAgICB9XHJcbiAgICAnJydcclxuICAgIFxyXG4gICAgVGhhdCBhdXRvIGNyZWF0aW9uIG9mICdtb2RlbCcgcHJvcGVydHkgY2FuIGJlIGF2b2lkZWRcclxuICAgIHdoZW4gdXNpbmcgdGhlIG9iamVjdCBpbnN0YW50aWF0aW9uIHN5bnRheCAoJ25ldycga2V5d29yZCk6XHJcbiAgICBcclxuICAgICcnJ1xyXG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKG9iaik7XHJcbiAgICAvLyBUaGVyZSBpcyBubyBhICdvYmoubW9kZWwnIHByb3BlcnR5LCBjYW4gYmVcclxuICAgIC8vIGFzc2lnbmVkIHRvIHdoYXRldmVyIHByb3BlcnR5IG9yIG5vdGhpbmcuXHJcbiAgICAnJydcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxua28ubWFwcGluZyA9IHJlcXVpcmUoJ2tub2Nrb3V0Lm1hcHBpbmcnKTtcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxudmFyIGNsb25lID0gZnVuY3Rpb24ob2JqKSB7IHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqKTsgfTtcclxudmFyIGNsb25lVmFsdWUgPSBmdW5jdGlvbih2YWwsIGRlZXBDb3B5KSB7XHJcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiAxMCovXHJcbiAgICBpZiAodHlwZW9mKHZhbCkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gQSBEYXRlIG9iamVjdCBpcyBhIHNwZWNpYWwgY2FzZTogZXZlbiBiZWluZ1xyXG4gICAgICAgIC8vIGFuIG9iamVjdCwgdHJlYXQgYXMgYSBiYXNpYyB0eXBlLCBiZWluZyBjb3BpZWQgYXNcclxuICAgICAgICAvLyBhIG5ldyBpbnN0YW5jZSBpbmRlcGVuZGVudCBvZiB0aGUgZGVlcENvcHkgb3B0aW9uXHJcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgLy8gQSBkYXRlIGNsb25lXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZWVwQ29weSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVWYWx1ZShpdGVtLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsICYmIHZhbC5tb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBIG1vZGVsIGNvcHlcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWwubW9kZWwudG9QbGFpbk9iamVjdChkZWVwQ29weSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQbGFpbiAnc3RhbmRhcmQnIG9iamVjdCBjbG9uZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVlcENvcHkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPbiBlbHNlLCBsZWZ0IHVuZGVmaW5lZCwgbm8gcmVmZXJlbmNlcywgbm8gY2xvbmVzLFxyXG4gICAgICAgIC8vIGRpc2NhcmRlZCB2YWx1ZVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBBIGJhc2ljIHR5cGUgdmFsdWUgaXMgYWxyZWFkeSBjb3BpZWQvY2xvbmVkIGJ5IGphdmFzY3JpcHRcclxuICAgICAgICAvLyBvbiBldmVyeSBhc3NpZ25tZW50XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIE1vZGVsKG1vZGVsT2JqZWN0KSB7XHJcbiAgICBcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlbCkpIHtcclxuICAgICAgICAvLyBFeGVjdXRlZCBhcyBhIGZ1bmN0aW9uLCBpdCBtdXN0IGNyZWF0ZVxyXG4gICAgICAgIC8vIGEgTW9kZWwgaW5zdGFuY2VcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwobW9kZWxPYmplY3QpO1xyXG4gICAgICAgIC8vIGFuZCByZWdpc3RlciBhdXRvbWF0aWNhbGx5IGFzIHBhcnRcclxuICAgICAgICAvLyBvZiB0aGUgbW9kZWxPYmplY3QgaW4gJ21vZGVsJyBwcm9wZXJ0eVxyXG4gICAgICAgIG1vZGVsT2JqZWN0Lm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgaW5zdGFuY2VcclxuICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICB9XHJcbiBcclxuICAgIC8vIEl0IGluY2x1ZGVzIGEgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3RcclxuICAgIHRoaXMubW9kZWxPYmplY3QgPSBtb2RlbE9iamVjdDtcclxuICAgIC8vIEl0IG1haW50YWlucyBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgZmllbGRzXHJcbiAgICB0aGlzLnByb3BlcnRpZXNMaXN0ID0gW107XHJcbiAgICB0aGlzLmZpZWxkc0xpc3QgPSBbXTtcclxuICAgIHRoaXMucHJvcGVydGllc0RlZnMgPSB7fTtcclxuICAgIHRoaXMuZmllbGRzRGVmcyA9IHt9O1xyXG4gICAgLy8gSXQgYWxsb3cgc2V0dGluZyB0aGUgJ2tvLm1hcHBpbmcuZnJvbUpTJyBtYXBwaW5nIG9wdGlvbnNcclxuICAgIC8vIHRvIGNvbnRyb2wgY29udmVyc2lvbnMgZnJvbSBwbGFpbiBKUyBvYmplY3RzIHdoZW4gXHJcbiAgICAvLyAndXBkYXRlV2l0aCcuXHJcbiAgICB0aGlzLm1hcHBpbmdPcHRpb25zID0ge307XHJcbiAgICBcclxuICAgIC8vIFRpbWVzdGFtcCB3aXRoIHRoZSBkYXRlIG9mIGxhc3QgY2hhbmdlXHJcbiAgICAvLyBpbiB0aGUgZGF0YSAoYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gY2hhbmdlc1xyXG4gICAgLy8gaGFwcGVucyBvbiBwcm9wZXJ0aWVzOyBmaWVsZHMgb3IgYW55IG90aGVyIG1lbWJlclxyXG4gICAgLy8gYWRkZWQgdG8gdGhlIG1vZGVsIGNhbm5vdCBiZSBvYnNlcnZlZCBmb3IgY2hhbmdlcyxcclxuICAgIC8vIHJlcXVpcmluZyBtYW51YWwgdXBkYXRpbmcgd2l0aCBhICduZXcgRGF0ZSgpJywgYnV0IGlzXHJcbiAgICAvLyBiZXR0ZXIgdG8gdXNlIHByb3BlcnRpZXMuXHJcbiAgICAvLyBJdHMgcmF0ZWQgdG8gemVybyBqdXN0IHRvIGF2b2lkIHRoYXQgY29uc2VjdXRpdmVcclxuICAgIC8vIHN5bmNocm9ub3VzIGNoYW5nZXMgZW1pdCBsb3Qgb2Ygbm90aWZpY2F0aW9ucywgc3BlY2lhbGx5XHJcbiAgICAvLyB3aXRoIGJ1bGsgdGFza3MgbGlrZSAndXBkYXRlV2l0aCcuXHJcbiAgICB0aGlzLmRhdGFUaW1lc3RhbXAgPSBrby5vYnNlcnZhYmxlKG5ldyBEYXRlKCkpLmV4dGVuZCh7IHJhdGVMaW1pdDogMCB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcclxuXHJcbi8qKlxyXG4gICAgSW50ZXJuYWwgdXRpbGl0eSB0byBtYXAgYSB2YWx1ZSBnaXZlbiBpdHMgcHJvcGVydHkvZmllbGRcclxuICAgIGRlZmluaXRpb25cclxuKiovXHJcbmZ1bmN0aW9uIHByZXBhcmVWYWx1ZUJ5RGVmKHZhbCwgZGVmKSB7XHJcbiAgICBpZiAoZGVmLmlzQXJyYXkgJiYgXHJcbiAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YodmFsKSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIHZhbCA9IFt2YWxdO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFsID0gW107XHJcbiAgICB9XHJcbiAgICBpZiAoZGVmICYmIGRlZi5Nb2RlbCkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgdmFsID0gdmFsLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGRlZi5Nb2RlbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YoaXRlbSkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2FzIGlzJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkZWYuTW9kZWwoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCEodmFsIGluc3RhbmNlb2YgZGVmLk1vZGVsKSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YodmFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBkZWYuTW9kZWwodmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZURlZihnaXZlblZhbCwgaW5pdGlhbFZhbCkge1xyXG4gICAgXHJcbiAgICB2YXIgZGVmLFxyXG4gICAgICAgIGlzTW9kZWwgPSBnaXZlblZhbCAmJiBnaXZlblZhbC5tb2RlbCBpbnN0YW5jZW9mIE1vZGVsLFxyXG4gICAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGdpdmVuVmFsKSxcclxuICAgICAgICBpc09iamVjdCA9IHR5cGVvZihnaXZlblZhbCkgPT09ICdvYmplY3QnICYmICEoZ2l2ZW5WYWwgaW5zdGFuY2VvZiBEYXRlKTtcclxuXHJcbiAgICBpZiAoZ2l2ZW5WYWwgIT09IG51bGwgJiYgIWlzTW9kZWwgJiYgaXNPYmplY3QgJiYgIWlzQXJyYXkpIHtcclxuICAgICAgICBkZWYgPSBnaXZlblZhbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRlZiA9IHtcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnaXZlblZhbCxcclxuICAgICAgICAgICAgaXNBcnJheTogaXNBcnJheVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGlzTW9kZWwpXHJcbiAgICAgICAgICAgIGRlZi5Nb2RlbCA9IGdpdmVuVmFsLmNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpbml0aWFsVmFsID0gdHlwZW9mKGluaXRpYWxWYWwpID09PSAndW5kZWZpbmVkJyA/IGRlZi5kZWZhdWx0VmFsdWUgOiBpbml0aWFsVmFsO1xyXG4gICAgZGVmLmluaXRpYWxWYWx1ZSA9IHByZXBhcmVWYWx1ZUJ5RGVmKGluaXRpYWxWYWwsIGRlZik7XHJcbiAgICBcclxuICAgIHJldHVybiBkZWY7XHJcbn1cclxuXHJcbi8qKlxyXG4gICAgRGVmaW5lIG9ic2VydmFibGUgcHJvcGVydGllcyB1c2luZyB0aGUgZ2l2ZW5cclxuICAgIHByb3BlcnRpZXMgb2JqZWN0IGRlZmluaXRpb24gdGhhdCBpbmNsdWRlcyBkZSBkZWZhdWx0IHZhbHVlcyxcclxuICAgIGFuZCBzb21lIG9wdGlvbmFsIGluaXRpYWxWYWx1ZXMgKG5vcm1hbGx5IHRoYXQgaXMgcHJvdmlkZWQgZXh0ZXJuYWxseVxyXG4gICAgYXMgYSBwYXJhbWV0ZXIgdG8gdGhlIG1vZGVsIGNvbnN0cnVjdG9yLCB3aGlsZSBkZWZhdWx0IHZhbHVlcyBhcmVcclxuICAgIHNldCBpbiB0aGUgY29uc3RydWN0b3IpLlxyXG4gICAgVGhhdCBwcm9wZXJ0aWVzIGJlY29tZSBtZW1iZXJzIG9mIHRoZSBtb2RlbE9iamVjdCwgc2ltcGxpZnlpbmcgXHJcbiAgICBtb2RlbCBkZWZpbml0aW9ucy5cclxuICAgIFxyXG4gICAgSXQgdXNlcyBLbm9ja291dC5vYnNlcnZhYmxlIGFuZCBvYnNlcnZhYmxlQXJyYXksIHNvIHByb3BlcnRpZXNcclxuICAgIGFyZSBmdW50aW9ucyB0aGF0IHJlYWRzIHRoZSB2YWx1ZSB3aGVuIG5vIGFyZ3VtZW50cyBvciBzZXRzIHdoZW5cclxuICAgIG9uZSBhcmd1bWVudCBpcyBwYXNzZWQgb2YuXHJcbioqL1xyXG5Nb2RlbC5wcm90b3R5cGUuZGVmUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZlByb3BlcnRpZXMocHJvcGVydGllcywgaW5pdGlhbFZhbHVlcykge1xyXG5cclxuICAgIGluaXRpYWxWYWx1ZXMgPSBpbml0aWFsVmFsdWVzIHx8IHt9O1xyXG5cclxuICAgIHZhciBtb2RlbE9iamVjdCA9IHRoaXMubW9kZWxPYmplY3QsXHJcbiAgICAgICAgcHJvcGVydGllc0xpc3QgPSB0aGlzLnByb3BlcnRpZXNMaXN0LFxyXG4gICAgICAgIGRlZnMgPSB0aGlzLnByb3BlcnRpZXNEZWZzLFxyXG4gICAgICAgIGRhdGFUaW1lc3RhbXAgPSB0aGlzLmRhdGFUaW1lc3RhbXA7XHJcblxyXG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDcmVhdGUgYW5kIHJlZ2lzdGVyIGRlZmluaXRpb25cclxuICAgICAgICB2YXIgZGVmID0gY3JlYXRlRGVmKHByb3BlcnRpZXNba2V5XSwgaW5pdGlhbFZhbHVlc1trZXldKTtcclxuICAgICAgICBkZWZzW2tleV0gPSBkZWY7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgb2JzZXJ2YWJsZSBwcm9wZXJ0eVxyXG4gICAgICAgIG1vZGVsT2JqZWN0W2tleV0gPSBBcnJheS5pc0FycmF5KGRlZi5pbml0aWFsVmFsdWUpID9cclxuICAgICAgICAgICAga28ub2JzZXJ2YWJsZUFycmF5KGRlZi5pbml0aWFsVmFsdWUpIDpcclxuICAgICAgICAgICAga28ub2JzZXJ2YWJsZShkZWYuaW5pdGlhbFZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gUmVtZW1iZXIgZGVmYXVsdFxyXG4gICAgICAgIG1vZGVsT2JqZWN0W2tleV0uX2RlZmF1bHRWYWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgLy8gcmVtZW1iZXIgaW5pdGlhbFxyXG4gICAgICAgIG1vZGVsT2JqZWN0W2tleV0uX2luaXRpYWxWYWx1ZSA9IGRlZi5pbml0aWFsVmFsdWU7ICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBzdWJzY3JpYmVyIHRvIHVwZGF0ZSB0aGUgdGltZXN0YW1wIG9uIGNoYW5nZXNcclxuICAgICAgICBtb2RlbE9iamVjdFtrZXldLnN1YnNjcmliZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZGF0YVRpbWVzdGFtcChuZXcgRGF0ZSgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgdG8gdGhlIGludGVybmFsIHJlZ2lzdHJ5XHJcbiAgICAgICAgcHJvcGVydGllc0xpc3QucHVzaChrZXkpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSB0aW1lc3RhbXAgYWZ0ZXIgdGhlIGJ1bGsgY3JlYXRpb24uXHJcbiAgICBkYXRhVGltZXN0YW1wKG5ldyBEYXRlKCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBEZWZpbmUgZmllbGRzIGFzIHBsYWluIG1lbWJlcnMgb2YgdGhlIG1vZGVsT2JqZWN0IHVzaW5nXHJcbiAgICB0aGUgZmllbGRzIG9iamVjdCBkZWZpbml0aW9uIHRoYXQgaW5jbHVkZXMgZGVmYXVsdCB2YWx1ZXMsXHJcbiAgICBhbmQgc29tZSBvcHRpb25hbCBpbml0aWFsVmFsdWVzLlxyXG4gICAgXHJcbiAgICBJdHMgbGlrZSBkZWZQcm9wZXJ0aWVzLCBidXQgZm9yIHBsYWluIGpzIHZhbHVlcyByYXRoZXIgdGhhbiBvYnNlcnZhYmxlcy5cclxuKiovXHJcbk1vZGVsLnByb3RvdHlwZS5kZWZGaWVsZHMgPSBmdW5jdGlvbiBkZWZGaWVsZHMoZmllbGRzLCBpbml0aWFsVmFsdWVzKSB7XHJcblxyXG4gICAgaW5pdGlhbFZhbHVlcyA9IGluaXRpYWxWYWx1ZXMgfHwge307XHJcblxyXG4gICAgdmFyIG1vZGVsT2JqZWN0ID0gdGhpcy5tb2RlbE9iamVjdCxcclxuICAgICAgICBkZWZzID0gdGhpcy5maWVsZHNEZWZzLFxyXG4gICAgICAgIGZpZWxkc0xpc3QgPSB0aGlzLmZpZWxkc0xpc3Q7XHJcblxyXG4gICAgT2JqZWN0LmtleXMoZmllbGRzKS5lYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgcmVnaXN0ZXIgZGVmaW5pdGlvblxyXG4gICAgICAgIHZhciBkZWYgPSBjcmVhdGVEZWYoZmllbGRzW2tleV0sIGluaXRpYWxWYWx1ZXNba2V5XSk7XHJcbiAgICAgICAgZGVmc1trZXldID0gZGVmO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENyZWF0ZSBmaWVsZCB3aXRoIGluaXRpYWwgdmFsdWVcclxuICAgICAgICBtb2RlbE9iamVjdFtrZXldID0gZGVmLmluaXRpYWxWYWx1ZTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgdG8gdGhlIGludGVybmFsIHJlZ2lzdHJ5XHJcbiAgICAgICAgZmllbGRzTGlzdC5wdXNoKGtleSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgU3RvcmUgdGhlIGxpc3Qgb2YgZmllbGRzIHRoYXQgbWFrZSB0aGUgSUQvcHJpbWFyeSBrZXlcclxuICAgIGFuZCBjcmVhdGUgYW4gYWxpYXMgJ2lkJyBwcm9wZXJ0eSB0aGF0IHJldHVybnMgdGhlXHJcbiAgICB2YWx1ZSBmb3IgdGhlIElEIGZpZWxkIG9yIGFycmF5IG9mIHZhbHVlcyB3aGVuIG11bHRpcGxlXHJcbiAgICBmaWVsZHMuXHJcbioqL1xyXG5Nb2RlbC5wcm90b3R5cGUuZGVmSUQgPSBmdW5jdGlvbiBkZWZJRChmaWVsZHNOYW1lcykge1xyXG4gICAgXHJcbiAgICAvLyBTdG9yZSB0aGUgbGlzdFxyXG4gICAgdGhpcy5pZEZpZWxkc05hbWVzID0gZmllbGRzTmFtZXM7XHJcbiAgICBcclxuICAgIC8vIERlZmluZSBJRCBvYnNlcnZhYmxlXHJcbiAgICBpZiAoZmllbGRzTmFtZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgLy8gUmV0dXJucyBzaW5nbGUgdmFsdWVcclxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNOYW1lc1swXTtcclxuICAgICAgICB0aGlzLm1vZGVsT2JqZWN0LmlkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tmaWVsZF0oKTtcclxuICAgICAgICB9LCB0aGlzLm1vZGVsT2JqZWN0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMubW9kZWxPYmplY3QuaWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHNOYW1lcy5tYXAoZnVuY3Rpb24oZmllbGROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tmaWVsZE5hbWVdKCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfSwgdGhpcy5tb2RlbE9iamVjdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIEFsbG93cyB0byByZWdpc3RlciBhIHByb3BlcnR5IChwcmV2aW91c2x5IGRlZmluZWQpIGFzIFxyXG4gICAgdGhlIG1vZGVsIHRpbWVzdGFtcCwgc28gZ2V0cyB1cGRhdGVkIG9uIGFueSBkYXRhIGNoYW5nZVxyXG4gICAgKGtlZXAgaW4gc3luYyB3aXRoIHRoZSBpbnRlcm5hbCBkYXRhVGltZXN0YW1wKS5cclxuKiovXHJcbk1vZGVsLnByb3RvdHlwZS5yZWdUaW1lc3RhbXAgPSBmdW5jdGlvbiByZWdUaW1lc3RhbXBQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpIHtcclxuXHJcbiAgICB2YXIgcHJvcCA9IHRoaXMubW9kZWxPYmplY3RbcHJvcGVydHlOYW1lXTtcclxuICAgIGlmICh0eXBlb2YocHJvcCkgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIG9ic2VydmFibGUgcHJvcGVydHkgd2l0aCBuYW1lIFsnICsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSArIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnXSB0byByZWdpc3RlciBhcyB0aW1lc3RhbXAuJ1xyXG4gICAgICAgKTtcclxuICAgIH1cclxuICAgIC8vIEFkZCBzdWJzY3JpYmVyIG9uIGludGVybmFsIHRpbWVzdGFtcCB0byBrZWVwXHJcbiAgICAvLyB0aGUgcHJvcGVydHkgdXBkYXRlZFxyXG4gICAgdGhpcy5kYXRhVGltZXN0YW1wLnN1YnNjcmliZShmdW5jdGlvbih0aW1lc3RhbXApIHtcclxuICAgICAgICBwcm9wKHRpbWVzdGFtcCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgUmV0dXJucyBhIHBsYWluIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGFuZCBmaWVsZHNcclxuICAgIG9mIHRoZSBtb2RlbCBvYmplY3QsIGp1c3QgdmFsdWVzLlxyXG4gICAgXHJcbiAgICBAcGFyYW0gZGVlcENvcHk6Ym9vbCBJZiBsZWZ0IHVuZGVmaW5lZCwgZG8gbm90IGNvcHkgb2JqZWN0cyBpblxyXG4gICAgdmFsdWVzIGFuZCBub3QgcmVmZXJlbmNlcy4gSWYgZmFsc2UsIGRvIGEgc2hhbGxvdyBjb3B5LCBzZXR0aW5nXHJcbiAgICB1cCByZWZlcmVuY2VzIGluIHRoZSByZXN1bHQuIElmIHRydWUsIHRvIGEgZGVlcCBjb3B5IG9mIGFsbCBvYmplY3RzLlxyXG4qKi9cclxuTW9kZWwucHJvdG90eXBlLnRvUGxhaW5PYmplY3QgPSBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KGRlZXBDb3B5KSB7XHJcblxyXG4gICAgdmFyIHBsYWluID0ge30sXHJcbiAgICAgICAgbW9kZWxPYmogPSB0aGlzLm1vZGVsT2JqZWN0O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldFZhbHVlKHByb3BlcnR5LCB2YWwpIHtcclxuICAgICAgICB2YXIgY2xvbmVkVmFsdWUgPSBjbG9uZVZhbHVlKHZhbCwgZGVlcENvcHkpO1xyXG4gICAgICAgIGlmICh0eXBlb2YoY2xvbmVkVmFsdWUpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBwbGFpbltwcm9wZXJ0eV0gPSBjbG9uZWRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wcm9wZXJ0aWVzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XHJcbiAgICAgICAgLy8gUHJvcGVydGllcyBhcmUgb2JzZXJ2YWJsZXMsIHNvIGZ1bmN0aW9ucyB3aXRob3V0IHBhcmFtczpcclxuICAgICAgICB2YXIgdmFsID0gbW9kZWxPYmpbcHJvcGVydHldKCk7XHJcblxyXG4gICAgICAgIHNldFZhbHVlKHByb3BlcnR5LCB2YWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5maWVsZHNMaXN0LmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcclxuICAgICAgICAvLyBGaWVsZHMgYXJlIGp1c3QgcGxhaW4gb2JqZWN0IG1lbWJlcnMgZm9yIHZhbHVlcywganVzdCBjb3B5OlxyXG4gICAgICAgIHZhciB2YWwgPSBtb2RlbE9ialtmaWVsZF07XHJcblxyXG4gICAgICAgIHNldFZhbHVlKGZpZWxkLCB2YWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHBsYWluO1xyXG59O1xyXG5cclxuTW9kZWwucHJvdG90eXBlLnVwZGF0ZVdpdGggPSBmdW5jdGlvbiB1cGRhdGVXaXRoKGRhdGEsIGRlZXBDb3B5KSB7XHJcbiAgICBcclxuICAgIC8vIFdlIG5lZWQgYSBwbGFpbiBvYmplY3QgZm9yICdmcm9tSlMnLlxyXG4gICAgLy8gSWYgaXMgYSBtb2RlbCwgZXh0cmFjdCB0aGVpciBwcm9wZXJ0aWVzIGFuZCBmaWVsZHMgZnJvbVxyXG4gICAgLy8gdGhlIG9ic2VydmFibGVzIChmcm9tSlMpLCBzbyB3ZSBub3QgZ2V0IGNvbXB1dGVkXHJcbiAgICAvLyBvciBmdW5jdGlvbnMsIGp1c3QgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzIGFuZCBmaWVsZHNcclxuICAgIHZhciB0aW1lc3RhbXAgPSBudWxsO1xyXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5tb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IHRoZSBzYW1lIHRpbWVzdGFtcCwgc29cclxuICAgICAgICAvLyByZW1lbWJlciBmb3IgYWZ0ZXIgdGhlIGZyb21KU1xyXG4gICAgICAgIHRpbWVzdGFtcCA9IGRhdGEubW9kZWwuZGF0YVRpbWVzdGFtcCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlcGxhY2UgZGF0YSB3aXRoIGEgcGxhaW4gY29weSBvZiBpdHNlbGZcclxuICAgICAgICBkYXRhID0gZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KGRlZXBDb3B5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5tb2RlbE9iamVjdCxcclxuICAgICAgICBkZWZzID0gdGhpcy5wcm9wZXJ0aWVzRGVmcztcclxuICAgIHRoaXMucHJvcGVydGllc0xpc3QuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xyXG4gICAgICAgIHZhciB2YWwgPSBkYXRhW3Byb3BlcnR5XSxcclxuICAgICAgICAgICAgZGVmID0gZGVmc1twcm9wZXJ0eV07XHJcbiAgICAgICAgaWYgKHR5cGVvZih2YWwpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldKHByZXBhcmVWYWx1ZUJ5RGVmKHZhbCwgZGVmKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVmcyA9IHRoaXMuZmllbGRzRGVmcztcclxuICAgIHRoaXMuZmllbGRzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IGRhdGFbZmllbGRdLFxyXG4gICAgICAgICAgICBkZWYgPSBkZWZzW2ZpZWxkXTtcclxuICAgICAgICBpZiAodHlwZW9mKHZhbCkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtmaWVsZF0gPSBwcmVwYXJlVmFsdWVCeURlZih2YWwsIGRlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2FtZSB0aW1lc3RhbXAgaWYgYW55XHJcbiAgICBpZiAodGltZXN0YW1wKVxyXG4gICAgICAgIHRoaXMubW9kZWxPYmplY3QubW9kZWwuZGF0YVRpbWVzdGFtcCh0aW1lc3RhbXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBHaXZlbiBhIHBsYWluIG9iamVjdCBpbiBhIGFjY2VwdGVkIGltcG9ydCBzdHJ1Y3R1cmVcclxuICAgIChuZXZlciBhIE1vZGVsIGluc3RhbmNlKSwgaXQgbWFwc1xyXG4gICAgdGhlIGRhdGEgdG8gdGhlIG9iamVjdCBmb2xsb3dpbmcgYSBzZXQgb2YgbWFwcGluZyBvcHRpb25zXHJcbiAgICBvZiBrby5tYXBwaW5nLlxyXG4gICAgSWYgdGhlIGRhdGEgaXMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgYnkgJ3RvUGxhaW5PYmplY3QnXHJcbiAgICB0aGVuIHVzZSAndXBkYXRlV2l0aCcgYmV0dGVyLlxyXG4gICAgXHJcbiAgICBUT0RPOiBSZXZpZXcsIG5vdCB1c2VkIHN0aWxsLCBubyBzdXJlIGlmIHJlYWxseSB1c2VmdWwgdG8gZGVwZW5kXHJcbiAgICBvbiBrby5tYXBwaW5nIGFuZCB0aGlzLlxyXG4qKi9cclxuTW9kZWwucHJvdG90eXBlLm1hcERhdGEgPSBmdW5jdGlvbiBtYXBEYXRhKGRhdGEsIG9wdGlvbmFsTWFwcGluZykge1xyXG4gICAga28ubWFwcGluZy5mcm9tSlMoZGF0YSwgb3B0aW9uYWxNYXBwaW5nIHx8IHRoaXMubWFwcGluZ09wdGlvbnMsIHRoaXMubW9kZWxPYmplY3QpO1xyXG59O1xyXG5cclxuTW9kZWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoZGF0YSwgZGVlcENvcHkpIHtcclxuICAgIC8vIEdldCBhIHBsYWluIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZGF0YVxyXG4gICAgdmFyIHBsYWluID0gdGhpcy50b1BsYWluT2JqZWN0KGRlZXBDb3B5KTtcclxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCBpbnN0YW5jZSwgdXNpbmcgdGhlIHNvdXJjZSBwbGFpbiBvYmplY3RcclxuICAgIC8vIGFzIGluaXRpYWwgdmFsdWVzXHJcbiAgICB2YXIgY2xvbmVkID0gbmV3IHRoaXMubW9kZWxPYmplY3QuY29uc3RydWN0b3IocGxhaW4pO1xyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNsb25lZCB3aXRoIHRoZSBwcm92aWRlZCBwbGFpbiBkYXRhIHVzZWRcclxuICAgICAgICAvLyB0byByZXBsYWNlIHZhbHVlcyBvbiB0aGUgY2xvbmVkIG9uZSwgZm9yIHF1aWNrIG9uZS1zdGVwIGNyZWF0aW9uXHJcbiAgICAgICAgLy8gb2YgZGVyaXZlZCBvYmplY3RzLlxyXG4gICAgICAgIGNsb25lZC5tb2RlbC51cGRhdGVXaXRoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU2luY2UgdGhlcmUgaXMgbm8gaW5pdGlhbCBkaWZmZXJlbnRpYWwgZGF0YSwgZW5zdXJlIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgdGltZXN0YW1wIHNpbmNlIHRoZSBjbG9uZSBpcyBzdGlsbCBpZGVudGljYWwgdG8gdGhlIHNvdXJjZVxyXG4gICAgICAgIGNsb25lZC5tb2RlbC5kYXRhVGltZXN0YW1wKHRoaXMubW9kZWxPYmplY3QubW9kZWwuZGF0YVRpbWVzdGFtcCgpKTtcclxuICAgIH1cclxuICAgIC8vIENsb25lZCBtb2RlbCByZWFkeTpcclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFVwZGF0ZXMgdGhlIGRhdGFUaW1lc3RhbXAgdG8gdGhlIGN1cnJlbnQgdW5pcXVlIGRhdGV0aW1lLFxyXG4gICAgc28gdGhlIG1vZGVsIGFwcGVhciBhcyB0b3VjaGVkL3VwZGF0ZWQsIGV2ZW4gaWYgbm90IGRhdGEgY2hhbmdlLlxyXG4gICAgVXNlZnVsIHNvbWV0aW1lcyB0byBtYWtlIGEgZGlmZmVyZW5jZSBmcm9tIGEgY2xvbmVkIGluc3RhbmNlXHJcbiAgICBzbyBhcHBlYXIgZGlmZmVyZW50LlxyXG4gICAgTk9URTogdGhlIGRhdGV0aW1lIHNldCBpcyBub3QgZXhhY3RseSB0aGUgY3VycmVudCBvbmUsIGlzIHRoZSBjdXJyZW50XHJcbiAgICBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHBsdXMgb25lLFxyXG4gICAgdG8gZW5zdXJlIHRoYXQgdGhlIHRpbWVzdGFtcCBpcyBkaWZmZXJlbnQgb24gZWRnZSBjYXNlcyB3aGVyZSB0aGlzXHJcbiAgICBtZXRob2QgaXMgY2FsbGVkIGp1c3QgYWZ0ZXIgYSBjcmVhdGlvbiBvciBjbG9uYXRpb24sIGJlY2F1c2UgdGhlIHdheVxyXG4gICAgamF2YXNjcmlwdCB3b3JrcyBhbmQgdGhlIGxpbWl0ZWQgbWlsbGlzZWNvbmRzIHByZWNpc2lvbiBvZiB0aGUgRGF0ZSBvYmplY3RcclxuICAgIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgdGhlICd0b3VjaGVkJyBkYXRlIHdpbGwgYmUgdGhlIHNhbWUgYXMgYmVmb3JlLFxyXG4gICAgdGhhdHMgYXZvaWRlZCB3aXRoIHRoaXMgc2ltcGxlIHRyaWNrLCBzbyByZW1haW5zICd1bmlxdWUnIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbi5cclxuKiovXHJcbk1vZGVsLnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uIHRvdWNoKCkge1xyXG4gICAgLy8gV2UgdXNlIHRoZSBmdW5jdGlvbiB3YXkgdG8gZ2V0IG1pbGxpc2Vjb25kcywgYWRkIDEgYW5kIGNyZWF0ZSBpbnN0YW5jZVxyXG4gICAgdGhpcy5kYXRhVGltZXN0YW1wKG5ldyBEYXRlKERhdGUoKSArIDEpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgUmVwbGFjZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGFuZCBmaWVsZHMgZGF0YSBpbiB0aGUgbW9kZWwgb2JqZWN0XHJcbiAgICB3aXRoIHRoZSBkZWZhdWx0IG9uZXMgb2YgdGhlIGNvbnN0cnVjdG9yLCBwbHVzIG9wdGlvbmFsIG5ldyBwcmVzZXQgZGF0YS5cclxuKiovXHJcbk1vZGVsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KHByZXNldHMpIHtcclxuICAgIFxyXG4gICAgdmFyIG5ld0luc3RhbmNlID0gbmV3IHRoaXMubW9kZWxPYmplY3QuY29uc3RydWN0b3IocHJlc2V0cyk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVXaXRoKG5ld0luc3RhbmNlLCB0cnVlKTtcclxufTtcclxuIiwiLyoqIFBlcmZvcm1hbmNlU3VtbWFyeSBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgTGlzdFZpZXdJdGVtID0gcmVxdWlyZSgnLi9MaXN0Vmlld0l0ZW0nKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAgbnVtZXJhbCA9IHJlcXVpcmUoJ251bWVyYWwnKTtcclxuXHJcbmZ1bmN0aW9uIFBlcmZvcm1hbmNlU3VtbWFyeSh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XHJcbiAgICBcclxuICAgIC8vIFRPRE86IGRlZmluZSBlYXJuaW5ncyBhbmQgdGltZUJvb2tpbmcgYXMgcHJvcGVydGllcyB3aXRoIGRlZi5Nb2RlbD9cclxuXHJcbiAgICB0aGlzLmVhcm5pbmdzID0gbmV3IEVhcm5pbmdzKHZhbHVlcy5lYXJuaW5ncyk7XHJcbiAgICBcclxuICAgIHZhciBlYXJuaW5nc0xpbmUgPSBuZXcgTGlzdFZpZXdJdGVtKCk7XHJcbiAgICBlYXJuaW5nc0xpbmUubWFya2VyTGluZTEgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbnVtID0gbnVtZXJhbCh0aGlzLmN1cnJlbnRBbW91bnQoKSkuZm9ybWF0KCckMCwwJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bTtcclxuICAgIH0sIHRoaXMuZWFybmluZ3MpO1xyXG4gICAgZWFybmluZ3NMaW5lLmNvbnRlbnRMaW5lMSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb25jZXB0KCk7XHJcbiAgICB9LCB0aGlzLmVhcm5pbmdzKTtcclxuICAgIGVhcm5pbmdzTGluZS5tYXJrZXJMaW5lMiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBudW0gPSBudW1lcmFsKHRoaXMubmV4dEFtb3VudCgpKS5mb3JtYXQoJyQwLDAnKTtcclxuICAgICAgICByZXR1cm4gbnVtO1xyXG4gICAgfSwgdGhpcy5lYXJuaW5ncyk7XHJcbiAgICBlYXJuaW5nc0xpbmUuY29udGVudExpbmUyID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENvbmNlcHQoKTtcclxuICAgIH0sIHRoaXMuZWFybmluZ3MpO1xyXG4gICAgXHJcblxyXG4gICAgdGhpcy50aW1lQm9va2VkID0gbmV3IFRpbWVCb29rZWQodmFsdWVzLnRpbWVCb29rZWQpO1xyXG5cclxuICAgIHZhciB0aW1lQm9va2VkTGluZSA9IG5ldyBMaXN0Vmlld0l0ZW0oKTtcclxuICAgIHRpbWVCb29rZWRMaW5lLm1hcmtlckxpbmUxID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG51bSA9IG51bWVyYWwodGhpcy5wZXJjZW50KCkpLmZvcm1hdCgnMCUnKTtcclxuICAgICAgICByZXR1cm4gbnVtO1xyXG4gICAgfSwgdGhpcy50aW1lQm9va2VkKTtcclxuICAgIHRpbWVCb29rZWRMaW5lLmNvbnRlbnRMaW5lMSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNlcHQoKTtcclxuICAgIH0sIHRoaXMudGltZUJvb2tlZCk7XHJcbiAgICBcclxuICAgIFxyXG4gICAgdGhpcy5pdGVtcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgICAgICBcclxuICAgICAgICBpdGVtcy5wdXNoKGVhcm5pbmdzTGluZSk7XHJcbiAgICAgICAgaXRlbXMucHVzaCh0aW1lQm9va2VkTGluZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBlcmZvcm1hbmNlU3VtbWFyeTtcclxuXHJcbmZ1bmN0aW9uIEVhcm5pbmdzKHZhbHVlcykge1xyXG5cclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgXHJcbiAgICAgICAgIGN1cnJlbnRBbW91bnQ6IDAsXHJcbiAgICAgICAgIGN1cnJlbnRDb25jZXB0VGVtcGxhdGU6ICdhbHJlYWR5IHBhaWQgdGhpcyBtb250aCcsXHJcbiAgICAgICAgIG5leHRBbW91bnQ6IDAsXHJcbiAgICAgICAgIG5leHRDb25jZXB0VGVtcGxhdGU6ICdwcm9qZWN0ZWQge21vbnRofSBlYXJuaW5ncydcclxuXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmN1cnJlbnRDb25jZXB0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgbW9udGggPSBtb21lbnQoKS5mb3JtYXQoJ01NTU0nKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29uY2VwdFRlbXBsYXRlKCkucmVwbGFjZSgvXFx7bW9udGhcXH0vLCBtb250aCk7XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5uZXh0Q29uY2VwdCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIG1vbnRoID0gbW9tZW50KCkuYWRkKDEsICdtb250aCcpLmZvcm1hdCgnTU1NTScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDb25jZXB0VGVtcGxhdGUoKS5yZXBsYWNlKC9cXHttb250aFxcfS8sIG1vbnRoKTtcclxuXHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gVGltZUJvb2tlZCh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgIFxyXG4gICAgICAgIHBlcmNlbnQ6IDAsXHJcbiAgICAgICAgY29uY2VwdFRlbXBsYXRlOiAnb2YgYXZhaWxhYmxlIHRpbWUgYm9va2VkIGluIHttb250aH0nXHJcbiAgICBcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMuY29uY2VwdCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIG1vbnRoID0gbW9tZW50KCkuYWRkKDEsICdtb250aCcpLmZvcm1hdCgnTU1NTScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNlcHRUZW1wbGF0ZSgpLnJlcGxhY2UoL1xce21vbnRoXFx9LywgbW9udGgpO1xyXG5cclxuICAgIH0sIHRoaXMpO1xyXG59XHJcbiIsIi8qKiBQb3NpdGlvbiBtb2RlbC5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG5mdW5jdGlvbiBQb3NpdGlvbih2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBwb3NpdGlvbklEOiAwLFxyXG4gICAgICAgIHBvc2l0aW9uU2luZ3VsYXI6ICcnLFxyXG4gICAgICAgIHBvc2l0aW9uUGx1cmFsOiAnJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogJycsXHJcbiAgICAgICAgYWN0aXZlOiB0cnVlXHJcblxyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb3NpdGlvbjtcclxuIiwiLyoqXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBQcmljaW5nRXN0aW1hdGVEZXRhaWwgPSByZXF1aXJlKCcuL1ByaWNpbmdFc3RpbWF0ZURldGFpbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBQcmljaW5nRXN0aW1hdGUodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgcHJpY2luZ0VzdGltYXRlSUQ6IDAsXHJcbiAgICAgICAgcHJpY2luZ0VzdGltYXRlUmV2aXNpb246IDAsXHJcbiAgICAgICAgc2VydmljZUR1cmF0aW9uSG91cnM6IG51bGwsXHJcbiAgICAgICAgZmlyc3RTZXNzaW9uRHVyYXRpb25Ib3VyczogbnVsbCxcclxuICAgICAgICBzdWJ0b3RhbFByaWNlOiBudWxsLFxyXG4gICAgICAgIGZlZVByaWNlOiBudWxsLFxyXG4gICAgICAgIHRvdGFsUHJpY2U6IG51bGwsXHJcbiAgICAgICAgcEZlZVByaWNlOiBudWxsLFxyXG4gICAgICAgIHN1YnRvdGFsUmVmdW5kZWQ6IG51bGwsXHJcbiAgICAgICAgZmVlUmVmdW5kZWQ6IG51bGwsXHJcbiAgICAgICAgdG90YWxSZWZ1bmRlZDogbnVsbCxcclxuICAgICAgICBkYXRlUmVmdW5kZWQ6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgZGV0YWlsczoge1xyXG4gICAgICAgICAgICBNb2RlbDogUHJpY2luZ0VzdGltYXRlRGV0YWlsLFxyXG4gICAgICAgICAgICBpc0FycmF5OiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfSwgdmFsdWVzKTtcclxufTtcclxuIiwiLyoqXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFByaWNpbmdFc3RpbWF0ZURldGFpbCh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBmcmVlbGFuY2VyUHJpY2luZ0lEOiAwLFxyXG4gICAgICAgIGZyZWVsYW5jZXJQcmljaW5nRGF0YUlucHV0OiBudWxsLFxyXG4gICAgICAgIGN1c3RvbWVyUHJpY2luZ0RhdGFJbnB1dDogbnVsbCxcclxuICAgICAgICBob3VybHlQcmljZTogbnVsbCxcclxuICAgICAgICBzdWJ0b3RhbFByaWNlOiBudWxsLFxyXG4gICAgICAgIGZlZVByaWNlOiBudWxsLFxyXG4gICAgICAgIHRvdGFsUHJpY2U6IG51bGwsXHJcbiAgICAgICAgc2VydmljZUR1cmF0aW9uSG91cnM6IG51bGwsXHJcbiAgICAgICAgZmlyc3RTZXNzaW9uRHVyYXRpb25Ib3VyczogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxyXG4gICAgfSwgdmFsdWVzKTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBQcmljaW5nIFR5cGUgbW9kZWxcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIFByaWNpbmdUeXBlKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBwcmljaW5nVHlwZUlEOiAwLFxyXG4gICAgICAgIHNpbmd1bGFyTmFtZTogJycsXHJcbiAgICAgICAgcGx1cmFsTmFtZTogJycsXHJcbiAgICAgICAgc2x1Z05hbWU6ICcnLFxyXG4gICAgICAgIGFkZE5ld0xhYmVsOiBudWxsLFxyXG4gICAgICAgIGZyZWVsYW5jZXJEZXNjcmlwdGlvbjogbnVsbCxcclxuICAgICAgICAvLyBQcmljZUNhbGN1bGF0aW9uVHlwZSBlbnVtZXJhdGlvbiB2YWx1ZTpcclxuICAgICAgICBwcmljZUNhbGN1bGF0aW9uOiBudWxsLFxyXG4gICAgICAgIGlzQWRkb246IGZhbHNlLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZvcm0gVGV4dHNcclxuICAgICAgICBuYW1lUGxhY2VIb2xkZXI6IG51bGwsXHJcbiAgICAgICAgc3VnZ2VzdGVkTmFtZTogbnVsbCxcclxuICAgICAgICBmaXhlZE5hbWU6IG51bGwsXHJcbiAgICAgICAgZHVyYXRpb25MYWJlbDogbnVsbCxcclxuICAgICAgICBwcmljZUxhYmVsOiBudWxsLFxyXG4gICAgICAgIHByaWNlTm90ZTogbnVsbCxcclxuICAgICAgICBmaXJzdFRpbWVDbGllbnRzT25seUxhYmVsOiBudWxsLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uUGxhY2VIb2xkZXI6IG51bGwsXHJcbiAgICAgICAgcHJpY2VSYXRlUXVhbnRpdHlMYWJlbDogbnVsbCxcclxuICAgICAgICBwcmljZVJhdGVVbml0TGFiZWw6IG51bGwsXHJcbiAgICAgICAgbm9QcmljZVJhdGVMYWJlbDogbnVsbCxcclxuICAgICAgICBudW1iZXJPZlNlc3Npb25zTGFiZWw6IG51bGwsXHJcbiAgICAgICAgaW5QZXJzb25QaG9uZUxhYmVsOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFjdGlvbiBBbmQgVmFsaWRhdGlvbiBUZXh0c1xyXG4gICAgICAgIHN1Y2Nlc3NPbkRlbGV0ZTogbnVsbCxcclxuICAgICAgICBlcnJvck9uRGVsZXRlOiBudWxsLFxyXG4gICAgICAgIHN1Y2Nlc3NPblNhdmU6IG51bGwsXHJcbiAgICAgICAgZXJyb3JPblNhdmU6IG51bGwsXHJcbiAgICAgICAgcHJpY2VSYXRlSXNSZXF1aXJlZFZhbGlkYXRpb25FcnJvcjogbnVsbCxcclxuICAgICAgICBwcmljZVJhdGVVbml0SXNSZXF1aXJlZFZhbGlkYXRpb25FcnJvcjogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICAvLyBIZWxwIFRleHRzXHJcbiAgICAgICAgbGVhcm5Nb3JlTGFiZWw6IG51bGwsXHJcbiAgICAgICAgbGVhcm5Nb3JlVGV4dDogbnVsbCxcclxuICAgICAgICBwcmljZVJhdGVMZWFybk1vcmVMYWJlbDogbnVsbCxcclxuICAgICAgICBwcmljZVJhdGVMZWFybk1vcmVUZXh0OiBudWxsLFxyXG4gICAgICAgIG5vUHJpY2VSYXRlTGVhcm5Nb3JlTGFiZWw6IG51bGwsXHJcbiAgICAgICAgbm9QcmljZVJhdGVMZWFybk1vcmVUZXh0OiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvblxyXG4gICAgICAgIHJlcXVpcmVEdXJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgaW5jbHVkZVNlcnZpY2VBdHRyaWJ1dGVzOiBmYWxzZSxcclxuICAgICAgICBpbmNsdWRlU3BlY2lhbFByb21vdGlvbjogZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTGlzdCBUZXh0c1xyXG4gICAgICAgIC8vLyBTdW1tYXJ5Rm9ybWF0IGlzIHRoZSBkZWZhdWx0IGZvcm1hdCBmb3Igc3VtbWFyaWVzIChyZXF1aXJlZCksXHJcbiAgICAgICAgLy8vIG90aGVyIGZvcm1hdHMgYXJlIGdvb2QgZm9yIGJldHRlciBkZXRhaWwsIGJ1dCBkZXBlbmRzXHJcbiAgICAgICAgLy8vIG9uIG90aGVyIG9wdGlvbnMgY29uZmlndXJlZCBwZXIgdHlwZS5cclxuICAgICAgICAvLy8gV2lsZGNhcmRzOlxyXG4gICAgICAgIC8vLyB7MH06IGR1cmF0aW9uXHJcbiAgICAgICAgLy8vIHsxfTogc2Vzc2lvbnNcclxuICAgICAgICAvLy8gezJ9OiBpbnBlcnNvbi9waG9uZVxyXG4gICAgICAgIHN1bW1hcnlGb3JtYXQ6IG51bGwsXHJcbiAgICAgICAgc3VtbWFyeUZvcm1hdE11bHRpcGxlU2Vzc2lvbnM6IG51bGwsXHJcbiAgICAgICAgc3VtbWFyeUZvcm1hdE5vRHVyYXRpb246IG51bGwsXHJcbiAgICAgICAgc3VtbWFyeUZvcm1hdE11bHRpcGxlU2Vzc2lvbnNOb0R1cmF0aW9uOiBudWxsLFxyXG4gICAgICAgIHdpdGhvdXRTZXJ2aWNlQXR0cmlidXRlc0N1c3RvbWVyTWVzc2FnZTogbnVsbCxcclxuICAgICAgICB3aXRob3V0U2VydmljZUF0dHJpYnV0ZXNGcmVlbGFuY2VyTWVzc2FnZTogbnVsbCxcclxuICAgICAgICBmaXJzdFRpbWVDbGllbnRzT25seUxpc3RUZXh0OiBudWxsLFxyXG4gICAgICAgIHByaWNlUmF0ZVF1YW50aXR5TGlzdExhYmVsOiBudWxsLFxyXG4gICAgICAgIHByaWNlUmF0ZVVuaXRMaXN0TGFiZWw6IG51bGwsXHJcbiAgICAgICAgbm9QcmljZVJhdGVMaXN0TWVzc2FnZTogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICAvLyBCb29raW5nL1ByaWNpbmdFc3RpbWF0ZSBUZXh0c1xyXG4gICAgICAgIC8vLyBOYW1lQW5kU3VtbWFyeUZvcm1hdCBpcyB0aGUgZGVmYXVsdCBmb3JtYXQgZm9yIHN1bW1hcmllcyB3aXRoIHBhY2thZ2UgbmFtZSAocmVxdWlyZWQpLFxyXG4gICAgICAgIC8vLyBvdGhlciBmb3JtYXRzIGFyZSBnb29kIGZvciBiZXR0ZXIgZGV0YWlsLCBidXQgZGVwZW5kc1xyXG4gICAgICAgIC8vLyBvbiBvdGhlciBvcHRpb25zIGNvbmZpZ3VyZWQgcGVyIHR5cGUuXHJcbiAgICAgICAgLy8vIFdpbGRjYXJkczpcclxuICAgICAgICAvLy8gezB9OiBwYWNrYWdlIG5hbWVcclxuICAgICAgICAvLy8gezF9OiBkdXJhdGlvblxyXG4gICAgICAgIC8vLyB7Mn06IHNlc3Npb25zXHJcbiAgICAgICAgLy8vIHszfTogaW5wZXJzb24vcGhvbmVcclxuICAgICAgICBuYW1lQW5kU3VtbWFyeUZvcm1hdDogbnVsbCxcclxuICAgICAgICBuYW1lQW5kU3VtbWFyeUZvcm1hdE11bHRpcGxlU2Vzc2lvbnM6IG51bGwsXHJcbiAgICAgICAgbmFtZUFuZFN1bW1hcnlGb3JtYXROb0R1cmF0aW9uOiBudWxsLFxyXG4gICAgICAgIG5hbWVBbmRTdW1tYXJ5Rm9ybWF0TXVsdGlwbGVTZXNzaW9uc05vRHVyYXRpb246IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVjb3JkIG1haW50ZW5hbmNlXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmSUQoWydwcmljaW5nVHlwZUlEJ10pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByaWNpbmdUeXBlO1xyXG5cclxuLy8gRW51bWVyYXRpb246XHJcbnZhciBQcmljZUNhbGN1bGF0aW9uVHlwZSA9IHtcclxuICAgIEZpeGVkUHJpY2U6IDEsXHJcbiAgICBIb3VybHlQcmljZTogMlxyXG59O1xyXG5cclxuUHJpY2luZ1R5cGUuUHJpY2VDYWxjdWxhdGlvblR5cGUgPSBQcmljZUNhbGN1bGF0aW9uVHlwZTtcclxuIiwiLyoqXHJcbiAgICBQcml2YWN5U2V0dGluZ3MgbW9kZWxcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIFByaXZhY3lTZXR0aW5ncyh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgdXNlcklEOiAwLFxyXG4gICAgICAgIHNtc0Jvb2tpbmdDb21tdW5pY2F0aW9uOiBmYWxzZSxcclxuICAgICAgICBwaG9uZUJvb2tpbmdDb21tdW5pY2F0aW9uOiBmYWxzZSxcclxuICAgICAgICBsb2Nvbm9taWNzQ29tbXVuaXR5Q29tbXVuaWNhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgbG9jb25vbWljc0RibUNhbXBhaWduczogZmFsc2UsXHJcbiAgICAgICAgcHJvZmlsZVNlb1Blcm1pc3Npb246IGZhbHNlLFxyXG4gICAgICAgIGxvY29ub21pY3NNYXJrZXRpbmdDYW1wYWlnbnM6IGZhbHNlLFxyXG4gICAgICAgIGNvQnJhbmRlZFBhcnRuZXJQZXJtaXNzaW9uczogZmFsc2UsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmSUQoWyd1c2VySUQnXSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJpdmFjeVNldHRpbmdzO1xyXG4iLCIvKipcclxuICAgIFNjaGVkdWxpbmdQcmVmZXJlbmNlcyBtb2RlbC5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG5mdW5jdGlvbiBTY2hlZHVsaW5nUHJlZmVyZW5jZXModmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgYWR2YW5jZVRpbWU6IDI0LFxyXG4gICAgICAgIGJldHdlZW5UaW1lOiAwLFxyXG4gICAgICAgIGluY3JlbWVudHNTaXplSW5NaW51dGVzOiAxNVxyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY2hlZHVsaW5nUHJlZmVyZW5jZXM7XHJcbiIsIi8qKlxyXG4gICAgU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlIG1vZGVsLlxyXG4gICAgXHJcbiAgICBJdHMgJ3NpbXBsaWZpZWQnIGJlY2F1c2UgaXQgcHJvdmlkZXMgYW4gQVBJXHJcbiAgICBmb3Igc2ltcGxlIHRpbWUgcmFuZ2UgcGVyIHdlZWsgZGF5LFxyXG4gICAgYSBwYWlyIG9mIGZyb20tdG8gdGltZXMuXHJcbiAgICBHb29kIGZvciBjdXJyZW50IHNpbXBsZSBVSS5cclxuICAgIFxyXG4gICAgVGhlIG9yaWdpbmFsIHdlZWtseSBzY2hlZHVsZSBkZWZpbmVzIHRoZSBzY2hlZHVsZVxyXG4gICAgaW4gMTUgbWludXRlcyBzbG90cywgc28gbXVsdGlwbGUgdGltZSByYW5nZXMgY2FuXHJcbiAgICBleGlzdHMgcGVyIHdlZWsgZGF5LCBqdXN0IG1hcmtpbmcgZWFjaCBzbG90XHJcbiAgICBhcyBhdmFpbGFibGUgb3IgdW5hdmFpbGFibGUuIFRoZSBBcHBNb2RlbFxyXG4gICAgd2lsbCBmaWxsIHRoaXMgbW9kZWwgaW5zdGFuY2VzIHByb3Blcmx5IG1ha2luZ1xyXG4gICAgYW55IGNvbnZlcnNpb24gZnJvbS90byB0aGUgc291cmNlIGRhdGEuXHJcbiAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuLyoqXHJcbiAgICBTdWJtb2RlbCB0aGF0IGlzIHVzZWQgb24gdGhlIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZVxyXG4gICAgZGVmaW5pbmcgYSBzaW5nbGUgd2VlayBkYXkgYXZhaWxhYmlsaXR5IHJhbmdlLlxyXG4gICAgQSBmdWxsIGRheSBtdXN0IGhhdmUgdmFsdWVzIGZyb206MCB0bzoxNDQwLCBuZXZlclxyXG4gICAgYm90aCBhcyB6ZXJvIGJlY2F1c2UgdGhhdHMgY29uc2lkZXJlZCBhcyBub3QgYXZhaWxhYmxlLFxyXG4gICAgc28gaXMgYmV0dGVyIHRvIHVzZSB0aGUgaXNBbGxEYXkgcHJvcGVydHkuXHJcbioqL1xyXG5mdW5jdGlvbiBXZWVrRGF5U2NoZWR1bGUodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIC8vIE5PVEU6IGZyb20tdG8gcHJvcGVyaWVzIGFzIG51bWJlcnNcclxuICAgIC8vIGZvciB0aGUgbWludXRlIG9mIHRoZSBkYXksIGZyb20gMCAoMDA6MDApIHRvIDE0MzkgKDIzOjU5KVxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBmcm9tOiAwLFxyXG4gICAgICAgIHRvOiAwXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBJdCBhbGxvd3MgdG8ga25vdyBpZiB0aGlzIHdlZWsgZGF5IGlzIFxyXG4gICAgICAgIGVuYWJsZWQgZm9yIHdlZWtseSBzY2hlZHVsZSwganVzdCBpdFxyXG4gICAgICAgIGhhcyBmcm9tLXRvIHRpbWVzLlxyXG4gICAgICAgIEl0IGFsbG93cyB0byBiZSBzZXQgYXMgdHJ1ZSBwdXR0aW5nXHJcbiAgICAgICAgYSBkZWZhdWx0IHJhbmdlICg5YS01cCkgb3IgZmFsc2UgXHJcbiAgICAgICAgc2V0dGluZyBib3RoIGFzIDBwLlxyXG4gICAgICAgIFxyXG4gICAgICAgIFNpbmNlIG9uIHdyaXRlIHR3byBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgbW9kaWZpZWQsIGFuZFxyXG4gICAgICAgIGJvdGggYXJlIHVzZWQgaW4gdGhlIHJlYWQsIGEgc2luZ2xlIGNoYW5nZSB0byB0aGUgXHJcbiAgICAgICAgdmFsdWUgd2lsbCB0cmlnZ2VyIHR3byBub3RpZmljYXRpb25zOyB0byBhdm9pZCB0aGF0LFxyXG4gICAgICAgIHRoZSBvYnNlcnZhYmxlIGlzIHJhdGUgbGltaXRlZCB3aXRoIGFuIGlubWVkaWF0ZSB2YWx1ZSxcclxuICAgICAgICBzb24gb25seSBvbmUgbm90aWZpY2F0aW9uIGlzIHJlY2VpdmVkLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLmlzRW5hYmxlZCA9IGtvLmNvbXB1dGVkKHtcclxuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIHR5cGVvZih0aGlzLmZyb20oKSkgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YodGhpcy50bygpKSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSgpIDwgdGhpcy50bygpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgcmFuZ2UgOWEgLSA1cFxyXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSG91cig5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9Ib3VyKDE3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9Ib3VyKDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvd25lcjogdGhpc1xyXG4gICAgfSkuZXh0ZW5kKHsgcmF0ZUxpbWl0OiAwIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzQWxsRGF5ID0ga28uY29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIChcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSgpID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvKCkgPT09IDE0NDBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbigvKnZhbCovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbSgwKTtcclxuICAgICAgICAgICAgdGhpcy50bygxNDQwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KS5leHRlbmQoeyByYXRlTGltaXQ6IDAgfSk7XHJcbiAgICBcclxuICAgIC8vIEFkZGl0aW9uYWwgaW50ZXJmYWNlcyB0byBnZXQvc2V0IHRoZSBmcm9tL3RvIHRpbWVzXHJcbiAgICAvLyBieSB1c2luZyBhIGRpZmZlcmVudCBkYXRhIHVuaXQgb3IgZm9ybWF0LlxyXG4gICAgXHJcbiAgICAvLyBJbnRlZ2VyLCByb3VuZGVkLXVwLCBudW1iZXIgb2YgaG91cnNcclxuICAgIHRoaXMuZnJvbUhvdXIgPSBrby5jb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZnJvbSgpIC8gNjApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGhvdXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbSgoaG91cnMgKiA2MCkgfDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3duZXI6IHRoaXNcclxuICAgIH0pO1xyXG4gICAgdGhpcy50b0hvdXIgPSBrby5jb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy50bygpIC8gNjApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGhvdXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG8oKGhvdXJzICogNjApIHwwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gU3RyaW5nLCB0aW1lIGZvcm1hdCAoJ2hoOm1tJylcclxuICAgIHRoaXMuZnJvbVRpbWUgPSBrby5jb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaW51dGVzVG9UaW1lU3RyaW5nKHRoaXMuZnJvbSgpIHwwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbih0aW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbSh0aW1lU3RyaW5nVG9NaW51dGVzKHRpbWUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxuICAgIHRoaXMudG9UaW1lID0ga28uY29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWludXRlc1RvVGltZVN0cmluZyh0aGlzLnRvKCkgfDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKHRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy50byh0aW1lU3RyaW5nVG9NaW51dGVzKHRpbWUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAgICBNYWluIG1vZGVsIGRlZmluaW5nIHRoZSB3ZWVrIHNjaGVkdWxlXHJcbiAgICBwZXIgd2VlayBkYXRlLCBvciBqdXN0IHNldCBhbGwgZGF5cyB0aW1lc1xyXG4gICAgYXMgYXZhaWxhYmxlIHdpdGggYSBzaW5nbGUgZmxhZy5cclxuKiovXHJcbmZ1bmN0aW9uIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBzdW5kYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICBtb25kYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICB0dWVzZGF5OiBuZXcgV2Vla0RheVNjaGVkdWxlKCksXHJcbiAgICAgICAgd2VkbmVzZGF5OiBuZXcgV2Vla0RheVNjaGVkdWxlKCksXHJcbiAgICAgICAgdGh1cnNkYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICBmcmlkYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICBzYXR1cmRheTogbmV3IFdlZWtEYXlTY2hlZHVsZSgpLFxyXG4gICAgICAgIGlzQWxsVGltZTogZmFsc2VcclxuICAgIH0sIHZhbHVlcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlO1xyXG5cclxuLy8vLyBVVElMUyxcclxuLy8gVE9ETyBPcmdhbml6ZSBvciBleHRlcm5hbGl6ZS4gc29tZSBjb3BpZWQgZm9ybSBhcHBtb2RlbC4uXHJcbi8qKlxyXG4gICAgaW50ZXJuYWwgdXRpbGl0eSBmdW5jdGlvbiAndG8gc3RyaW5nIHdpdGggdHdvIGRpZ2l0cyBhbG1vc3QnXHJcbioqL1xyXG5mdW5jdGlvbiB0d29EaWdpdHMobikge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDEwKSArICcnICsgbiAlIDEwO1xyXG59XHJcblxyXG4vKipcclxuICAgIENvbnZlcnQgYSBudW1iZXIgb2YgbWludXRlc1xyXG4gICAgaW4gYSBzdHJpbmcgbGlrZTogMDA6MDA6MDAgKGhvdXJzOm1pbnV0ZXM6c2Vjb25kcylcclxuKiovXHJcbmZ1bmN0aW9uIG1pbnV0ZXNUb1RpbWVTdHJpbmcobWludXRlcykge1xyXG4gICAgdmFyIGQgPSBtb21lbnQuZHVyYXRpb24obWludXRlcywgJ21pbnV0ZXMnKSxcclxuICAgICAgICBoID0gZC5ob3VycygpLFxyXG4gICAgICAgIG0gPSBkLm1pbnV0ZXMoKSxcclxuICAgICAgICBzID0gZC5zZWNvbmRzKCk7XHJcbiAgICBcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdHdvRGlnaXRzKGgpICsgJzonICtcclxuICAgICAgICB0d29EaWdpdHMobSkgKyAnOicgK1xyXG4gICAgICAgIHR3b0RpZ2l0cyhzKVxyXG4gICAgKTtcclxufVxyXG5cclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5mdW5jdGlvbiB0aW1lU3RyaW5nVG9NaW51dGVzKHRpbWUpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24odGltZSkuYXNNaW51dGVzKCkgfDA7XHJcbn0iLCIvKiogVGhyZWFkIG1vZGVsLlxyXG5cclxuICAgIERlc2NyaWJlcyBhIHRocmVhZCBvZiBtZXNzYWdlcy5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBNZXNzYWdlID0gcmVxdWlyZSgnLi9NZXNzYWdlJyk7XHJcblxyXG5mdW5jdGlvbiBUaHJlYWQodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgdGhyZWFkSUQ6IDAsXHJcbiAgICAgICAgXHJcbiAgICAgICAgY3VzdG9tZXJVc2VySUQ6IG51bGwsXHJcbiAgICAgICAgZnJlZWxhbmNlclVzZXJJRDogbnVsbCxcclxuICAgICAgICBqb2JUaXRsZUlEOiBudWxsLFxyXG4gICAgICAgIHN0YXR1c0lEOiBudWxsLFxyXG4gICAgICAgIHN1YmplY3Q6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgbWVzc2FnZXM6IHtcclxuICAgICAgICAgICAgaXNBcnJheTogdHJ1ZSxcclxuICAgICAgICAgICAgTW9kZWw6IE1lc3NhZ2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsICAgICAgICBcclxuICAgIH0sIHZhbHVlcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGhyZWFkO1xyXG4iLCIvKiogVXBjb21pbmdCb29raW5nc1N1bW1hcnkgbW9kZWwgKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIEJvb2tpbmdTdW1tYXJ5ID0gcmVxdWlyZSgnLi9Cb29raW5nU3VtbWFyeScpO1xyXG5cclxuZnVuY3Rpb24gVXBjb21pbmdCb29raW5nc1N1bW1hcnkoKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIC8vIFRPRE86IGRlZmluZSB0b2RheSwgdG9tb3Jyb3cgYW5kIG5leHRXZWVrIGFzXHJcbiAgICAvLyBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCBNb2RlbD9cclxuICAgIC8vIFJldmlldyBob3cgdXBkYXRlIGhhcHBlbnMgb24gaG9tZS9kYXNoYm9hcmQsIGl0IGNhbiBoZWxwc1xyXG4gICAgLy8gdG8gc2ltcGxpZnkgdGhhdFxyXG5cclxuICAgIHRoaXMudG9kYXkgPSBuZXcgQm9va2luZ1N1bW1hcnkoe1xyXG4gICAgICAgIGNvbmNlcHQ6ICdtb3JlIHRvZGF5JyxcclxuICAgICAgICB0aW1lRm9ybWF0OiAnIFtlbmRpbmcgQF0gaDptbWEnXHJcbiAgICB9KTtcclxuICAgIHRoaXMudG9tb3Jyb3cgPSBuZXcgQm9va2luZ1N1bW1hcnkoe1xyXG4gICAgICAgIGNvbmNlcHQ6ICd0b21vcnJvdycsXHJcbiAgICAgICAgdGltZUZvcm1hdDogJyBbc3RhcnRpbmcgQF0gaDptbWEnXHJcbiAgICB9KTtcclxuICAgIHRoaXMubmV4dFdlZWsgPSBuZXcgQm9va2luZ1N1bW1hcnkoe1xyXG4gICAgICAgIGNvbmNlcHQ6ICduZXh0IHdlZWsnLFxyXG4gICAgICAgIHRpbWVGb3JtYXQ6IG51bGxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLml0ZW1zID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vaWYgKHRoaXMudG9kYXkucXVhbnRpdHkoKSlcclxuICAgICAgICBpdGVtcy5wdXNoKHRoaXMudG9kYXkpO1xyXG4gICAgICAgIC8vaWYgKHRoaXMudG9tb3Jyb3cucXVhbnRpdHkoKSlcclxuICAgICAgICBpdGVtcy5wdXNoKHRoaXMudG9tb3Jyb3cpO1xyXG4gICAgICAgIC8vaWYgKHRoaXMubmV4dFdlZWsucXVhbnRpdHkoKSlcclxuICAgICAgICBpdGVtcy5wdXNoKHRoaXMubmV4dFdlZWspO1xyXG5cclxuICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVwY29taW5nQm9va2luZ3NTdW1tYXJ5O1xyXG4iLCIvKiogVXNlciBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuLy8gRW51bSBVc2VyVHlwZVxyXG52YXIgVXNlclR5cGUgPSB7XHJcbiAgICBOb25lOiAwLFxyXG4gICAgQW5vbnltb3VzOiAxLFxyXG4gICAgQ3VzdG9tZXI6IDIsXHJcbiAgICBGcmVlbGFuY2VyOiA0LFxyXG4gICAgQWRtaW46IDgsXHJcbiAgICBMb2dnZWRVc2VyOiAxNCxcclxuICAgIFVzZXI6IDE1LFxyXG4gICAgU3lzdGVtOiAxNlxyXG59O1xyXG5cclxuZnVuY3Rpb24gVXNlcih2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgdXNlcklEOiAwLFxyXG4gICAgICAgIGVtYWlsOiAnJyxcclxuICAgICAgICBcclxuICAgICAgICBmaXJzdE5hbWU6ICcnLFxyXG4gICAgICAgIGxhc3ROYW1lOiAnJyxcclxuICAgICAgICBzZWNvbmRMYXN0TmFtZTogJycsXHJcbiAgICAgICAgYnVzaW5lc3NOYW1lOiAnJyxcclxuICAgICAgICBcclxuICAgICAgICBhbHRlcm5hdGl2ZUVtYWlsOiAnJyxcclxuICAgICAgICBwaG9uZTogJycsXHJcbiAgICAgICAgY2FuUmVjZWl2ZVNtczogJycsXHJcbiAgICAgICAgYmlydGhNb250aERheTogbnVsbCxcclxuICAgICAgICBiaXJ0aE1vbnRoOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGlzRnJlZWxhbmNlcjogZmFsc2UsXHJcbiAgICAgICAgaXNDdXN0b21lcjogZmFsc2UsXHJcbiAgICAgICAgaXNNZW1iZXI6IGZhbHNlLFxyXG4gICAgICAgIGlzQWRtaW46IGZhbHNlLFxyXG5cclxuICAgICAgICBvbmJvYXJkaW5nU3RlcDogbnVsbCxcclxuICAgICAgICBhY2NvdW50U3RhdHVzSUQ6IDAsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcblxyXG4gICAgdGhpcy5mdWxsTmFtZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbmFtZVBhcnRzID0gW3RoaXMuZmlyc3ROYW1lKCldO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3ROYW1lKCkpXHJcbiAgICAgICAgICAgIG5hbWVQYXJ0cy5wdXNoKHRoaXMubGFzdE5hbWUoKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kTGFzdE5hbWUoKSlcclxuICAgICAgICAgICAgbmFtZVBhcnRzLnB1c2godGhpcy5zZWNvbmRMYXN0TmFtZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCcgJyk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5iaXJ0aERheSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5iaXJ0aE1vbnRoRGF5KCkgJiZcclxuICAgICAgICAgICAgdGhpcy5iaXJ0aE1vbnRoKCkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFRPRE8gaTEwblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXJ0aE1vbnRoKCkgKyAnLycgKyB0aGlzLmJpcnRoTW9udGhEYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnVzZXJUeXBlID0ga28ucHVyZUNvbXB1dGVkKHtcclxuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmlzQ3VzdG9tZXIoKSxcclxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmlzRnJlZWxhbmNlcigpLFxyXG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuaXNBZG1pbigpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHVzZXJUeXBlID0gMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQW5vbnltb3VzKCkpXHJcbiAgICAgICAgICAgICAgICB1c2VyVHlwZSA9IHVzZXJUeXBlIHwgVXNlclR5cGUuQW5vbnltb3VzO1xyXG4gICAgICAgICAgICBpZiAoYylcclxuICAgICAgICAgICAgICAgIHVzZXJUeXBlID0gdXNlclR5cGUgfCBVc2VyVHlwZS5DdXN0b21lcjtcclxuICAgICAgICAgICAgaWYgKHApXHJcbiAgICAgICAgICAgICAgICB1c2VyVHlwZSA9IHVzZXJUeXBlIHwgVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuICAgICAgICAgICAgaWYgKGEpXHJcbiAgICAgICAgICAgICAgICB1c2VyVHlwZSA9IHVzZXJUeXBlIHwgVXNlclR5cGUuQWRtaW47XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gdXNlclR5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiBOT1RFOiBOb3QgcmVxdWlyZWQgZm9yIG5vdzpcclxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odikge1xyXG4gICAgICAgIH0sKi9cclxuICAgICAgICBvd25lcjogdGhpc1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNBbm9ueW1vdXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy51c2VySUQoKSA8IDE7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgSXQgbWF0Y2hlcyBhIFVzZXJUeXBlIGZyb20gdGhlIGVudW1lcmF0aW9uP1xyXG4gICAgKiovXHJcbiAgICB0aGlzLmlzVXNlclR5cGUgPSBmdW5jdGlvbiBpc1VzZXJUeXBlKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudXNlclR5cGUoKSAmIHR5cGUpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7XHJcblxyXG5Vc2VyLlVzZXJUeXBlID0gVXNlclR5cGU7XHJcblxyXG4vKiBDcmVhdGludCBhbiBhbm9ueW1vdXMgdXNlciB3aXRoIHNvbWUgcHJlc3NldHMgKi9cclxuVXNlci5uZXdBbm9ueW1vdXMgPSBmdW5jdGlvbiBuZXdBbm9ueW1vdXMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFVzZXIoe1xyXG4gICAgICAgIHVzZXJJRDogMCxcclxuICAgICAgICBlbWFpbDogJycsXHJcbiAgICAgICAgZmlyc3ROYW1lOiAnJyxcclxuICAgICAgICBvbmJvYXJkaW5nU3RlcDogbnVsbFxyXG4gICAgfSk7XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgVXNlckpvYlRpdGxlIG1vZGVsLCByZWxhdGlvbnNoaXAgYmV0d2VlbiBhbiB1c2VyIGFuZCBhXHJcbiAgICBqb2IgdGl0bGUgYW5kIHRoZSBtYWluIGRhdGEgYXR0YWNoZWQgdG8gdGhhdCByZWxhdGlvbi5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIFVzZXJKb2JUaXRsZSh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgdXNlcklEOiAwLFxyXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXHJcbiAgICAgICAgaW50cm86IG51bGwsXHJcbiAgICAgICAgc3RhdHVzSUQ6IDAsXHJcbiAgICAgICAgY2FuY2VsbGF0aW9uUG9saWN5SUQ6IDAsXHJcbiAgICAgICAgaW5zdGFudEJvb2tpbmc6IGZhbHNlLFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZklEKFsndXNlcklEJywgJ2pvYlRpdGxlSUQnXSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXNlckpvYlRpdGxlO1xyXG4iLCIvKiogXHJcbiAgICB0aW1lU2xvdHNcclxuICAgIHRlc3RpbmcgZGF0YVxyXG4qKi9cclxuXHJcbnZhciBUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvVGltZScpO1xyXG5cclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxudmFyIHRvZGF5ID0gbmV3IERhdGUoKSxcclxuICAgIHRvbW9ycm93ID0gbmV3IERhdGUoKTtcclxudG9tb3Jyb3cuc2V0RGF0ZSh0b21vcnJvdy5nZXREYXRlKCkgKyAxKTtcclxuXHJcbnZhciBzdG9kYXkgPSBtb21lbnQodG9kYXkpLmZvcm1hdCgnWVlZWS1NTS1ERCcpLFxyXG4gICAgc3RvbW9ycm93ID0gbW9tZW50KHRvbW9ycm93KS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcclxuXHJcbnZhciB0ZXN0RGF0YTEgPSBbXHJcbiAgICBUaW1lKHRvZGF5LCA5LCAxNSksXHJcbiAgICBUaW1lKHRvZGF5LCAxMSwgMzApLFxyXG4gICAgVGltZSh0b2RheSwgMTIsIDApLFxyXG4gICAgVGltZSh0b2RheSwgMTIsIDMwKSxcclxuICAgIFRpbWUodG9kYXksIDE2LCAxNSksXHJcbiAgICBUaW1lKHRvZGF5LCAxOCwgMCksXHJcbiAgICBUaW1lKHRvZGF5LCAxOCwgMzApLFxyXG4gICAgVGltZSh0b2RheSwgMTksIDApLFxyXG4gICAgVGltZSh0b2RheSwgMTksIDMwKSxcclxuICAgIFRpbWUodG9kYXksIDIxLCAzMCksXHJcbiAgICBUaW1lKHRvZGF5LCAyMiwgMClcclxuXTtcclxuXHJcbnZhciB0ZXN0RGF0YTIgPSBbXHJcbiAgICBUaW1lKHRvbW9ycm93LCA4LCAwKSxcclxuICAgIFRpbWUodG9tb3Jyb3csIDEwLCAzMCksXHJcbiAgICBUaW1lKHRvbW9ycm93LCAxMSwgMCksXHJcbiAgICBUaW1lKHRvbW9ycm93LCAxMSwgMzApLFxyXG4gICAgVGltZSh0b21vcnJvdywgMTIsIDApLFxyXG4gICAgVGltZSh0b21vcnJvdywgMTIsIDMwKSxcclxuICAgIFRpbWUodG9tb3Jyb3csIDEzLCAwKSxcclxuICAgIFRpbWUodG9tb3Jyb3csIDEzLCAzMCksXHJcbiAgICBUaW1lKHRvbW9ycm93LCAxNCwgNDUpLFxyXG4gICAgVGltZSh0b21vcnJvdywgMTYsIDApLFxyXG4gICAgVGltZSh0b21vcnJvdywgMTYsIDMwKVxyXG5dO1xyXG5cclxudmFyIHRlc3REYXRhQnVzeSA9IFtcclxuXTtcclxuXHJcbnZhciB0ZXN0RGF0YSA9IHtcclxuICAgICdkZWZhdWx0JzogdGVzdERhdGFCdXN5XHJcbn07XHJcbnRlc3REYXRhW3N0b2RheV0gPSB0ZXN0RGF0YTE7XHJcbnRlc3REYXRhW3N0b21vcnJvd10gPSB0ZXN0RGF0YTI7XHJcblxyXG5leHBvcnRzLnRpbWVTbG90cyA9IHRlc3REYXRhO1xyXG4iLCIvKipcclxuICAgIFV0aWxpdHkgdG8gaGVscCB0cmFjayB0aGUgc3RhdGUgb2YgY2FjaGVkIGRhdGFcclxuICAgIG1hbmFnaW5nIHRpbWUsIHByZWZlcmVuY2UgYW5kIGlmIG11c3QgYmUgcmV2YWxpZGF0ZWRcclxuICAgIG9yIG5vdC5cclxuICAgIFxyXG4gICAgSXRzIGp1c3QgbWFuYWdlcyBtZXRhIGRhdGEsIGJ1dCBub3QgdGhlIGRhdGEgdG8gYmUgY2FjaGVkLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuZnVuY3Rpb24gQ2FjaGVDb250cm9sKG9wdGlvbnMpIHtcclxuICAgIFxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLy8gQSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yXHJcbiAgICAvLyBBbiBvYmplY3Qgd2l0aCBkZXNpcmVkIHVuaXRzIGFuZCBhbW91bnQsIGFsbCBvcHRpb25hbCxcclxuICAgIC8vIGFueSBjb21iaW5hdGlvbiB3aXRoIGFsbW9zdCBvbmUgc3BlY2lmaWVkLCBzYW1wbGU6XHJcbiAgICAvLyB7IHllYXJzOiAwLCBtb250aHM6IDAsIHdlZWtzOiAwLCBcclxuICAgIC8vICAgZGF5czogMCwgaG91cnM6IDAsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9XHJcbiAgICB0aGlzLnR0bCA9IG1vbWVudC5kdXJhdGlvbihvcHRpb25zLnR0bCkuYXNNaWxsaXNlY29uZHMoKTtcclxuICAgIHRoaXMubGF0ZXN0ID0gb3B0aW9ucy5sYXRlc3QgfHwgbnVsbDtcclxuXHJcbiAgICB0aGlzLm11c3RSZXZhbGlkYXRlID0gZnVuY3Rpb24gbXVzdFJldmFsaWRhdGUoKSB7XHJcbiAgICAgICAgdmFyIHRkaWZmID0gdGhpcy5sYXRlc3QgJiYgbmV3IERhdGUoKSAtIHRoaXMubGF0ZXN0IHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICByZXR1cm4gdGRpZmYgPiB0aGlzLnR0bDtcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVDb250cm9sO1xyXG4iLCIvKipcclxuICAgIE5ldyBGdW5jdGlvbiBtZXRob2Q6ICdfZGVsYXllZCcuXHJcbiAgICBJdCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uLCB3cmFwcGluZyB0aGUgb3JpZ2luYWwgb25lLFxyXG4gICAgdGhhdCBvbmNlIGl0cyBjYWxsIHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiB0aGUgZ2l2ZW4gbWlsbGlzZWNvbmRzLFxyXG4gICAgdXNpbmcgYSBzZXRUaW1lb3V0LlxyXG4gICAgVGhlIG5ldyBmdW5jdGlvbiByZXR1cm5zICd1bmRlZmluZWQnIHNpbmNlIGl0IGhhcyBub3QgdGhlIHJlc3VsdCxcclxuICAgIGJlY2F1c2Ugb2YgdGhhdCBpcyBvbmx5IHN1aXRhYmxlIHdpdGggcmV0dXJuLWZyZWUgZnVuY3Rpb25zIFxyXG4gICAgbGlrZSBldmVudCBoYW5kbGVycy5cclxuICAgIFxyXG4gICAgV2h5OiBzb21ldGltZXMsIHRoZSBoYW5kbGVyIGZvciBhbiBldmVudCBuZWVkcyB0byBiZSBleGVjdXRlZFxyXG4gICAgYWZ0ZXIgYSBkZWxheSBpbnN0ZWFkIG9mIGluc3RhbnRseS5cclxuKiovXHJcbkZ1bmN0aW9uLnByb3RvdHlwZS5fZGVsYXllZCA9IGZ1bmN0aW9uIGRlbGF5ZWQobWlsbGlzZWNvbmRzKSB7XHJcbiAgICB2YXIgZm4gPSB0aGlzO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcyxcclxuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfSwgbWlsbGlzZWNvbmRzKTtcclxuICAgIH07XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgRXh0ZW5kaW5nIHRoZSBGdW5jdGlvbiBjbGFzcyB3aXRoIGFuIGluaGVyaXRzIG1ldGhvZC5cclxuICAgIFxyXG4gICAgVGhlIGluaXRpYWwgbG93IGRhc2ggaXMgdG8gbWFyayBpdCBhcyBuby1zdGFuZGFyZC5cclxuKiovXHJcbkZ1bmN0aW9uLnByb3RvdHlwZS5faW5oZXJpdHMgPSBmdW5jdGlvbiBfaW5oZXJpdHMoc3VwZXJDdG9yKSB7XHJcbiAgICB0aGlzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG4iLCIvKipcclxuICAgIEZpeCBGdW5jdGlvbiNuYW1lIG9uIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQgKElFOSspOlxyXG4gICAgXHJcbiAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzA1NjUzMC8xNjIyMzQ2ICAgIFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG4vKmpzaGludCAtVzA2OCAqL1xyXG5pZiAoIShmdW5jdGlvbiBmKCkge30pLm5hbWUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICduYW1lJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvKVsxXTtcclxuICAgICAgICAgICAgLy8gRm9yIGJldHRlciBwZXJmb3JtYW5jZSBvbmx5IHBhcnNlIG9uY2UsIGFuZCB0aGVuIGNhY2hlIHRoZVxyXG4gICAgICAgICAgICAvLyByZXN1bHQgdGhyb3VnaCBhIG5ldyBhY2Nlc3NvciBmb3IgcmVwZWF0ZWQgYWNjZXNzLlxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7IHZhbHVlOiBuYW1lIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSIsIi8qKlxyXG4gICAgR3JvdXBMaXN0UmVtb3RlTW9kZWxcclxuICAgIFV0aWxpdHkgY2xhc3MgZm9yIGNvbW1vbiBjb2RlIGZvciBhIGRhdGEgbGlzdCBlbnRpdHkgZnJvbSBhIHJlbW90ZSBzb3VyY2UsXHJcbiAgICB3aXRoIGxvY2FsIGNvcHkgYW5kIGNhY2hlLCB3aGVyZSB0aGUgZnVsbCBsaXN0IGlzIG1hbmFnZWQgcGVyIGdyb3VwcyxcclxuICAgIHdpdGhvdXQgcGFnaW5nL2N1cnNvciwgYWxsIHRoZSBncm91cCBkYXRhIG9uIGVhY2ggb3BlcmF0aW9uLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIEluZGV4ZWRHcm91cExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vSW5kZXhlZEdyb3VwTGlzdENhY2hlJyk7XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlZCh2YWwsIG1zZykge1xyXG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YodmFsKSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ1JlcXVpcmVkIHBhcmFtZXRlcicpO1xyXG4gICAgZWxzZSByZXR1cm4gdmFsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBHcm91cExpc3RSZW1vdGVNb2RlbChzZXR0aW5ncykge1xyXG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czoyOCovXHJcbiAgICBcclxuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcbiAgICBzZXR0aW5ncy5saXN0VHRsID0gcmVxdWlyZWQoc2V0dGluZ3MubGlzdFR0bCwgJ2xpc3RUdGwgaXMgcmVxdWlyZWQnKTtcclxuICAgIHNldHRpbmdzLmdyb3VwSWRGaWVsZCA9IHJlcXVpcmVkKHNldHRpbmdzLmdyb3VwSWRGaWVsZCwgJ2dyb3VwSWRGaWVsZCBpcyByZXF1aXJlZCcpO1xyXG4gICAgc2V0dGluZ3MuaXRlbUlkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5pdGVtSWRGaWVsZCwgJ2l0ZW1JZEZpZWxkIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAvLyBGb3Igbm93LCBvcHRpb25hbCBtb2RlbFxyXG4gICAgc2V0dGluZ3MuTW9kZWwgPSBzZXR0aW5ncy5Nb2RlbCB8fCBudWxsO1xyXG4gICAgLy8gUmVxdWlyZWQgZm9yIEFQSSBhZGRpdGlvbnNcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgIGlzTG9hZGluZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcbiAgICAgICAgaXNTeW5jaW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcclxuICAgICAgICBpc1NhdmluZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcbiAgICAgICAgaXNEZWxldGluZzoga28ub2JzZXJ2YWJsZShmYWxzZSlcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNhY2hlID0gbmV3IEluZGV4ZWRHcm91cExpc3RDYWNoZSh7XHJcbiAgICAgICAgbGlzdFR0bDogc2V0dGluZ3MubGlzdFR0bCxcclxuICAgICAgICBncm91cElkRmllbGQ6IHNldHRpbmdzLmdyb3VwSWRGaWVsZCxcclxuICAgICAgICBpdGVtSWRGaWVsZDogc2V0dGluZ3MuaXRlbUlkRmllbGRcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLmNsZWFyQ2FjaGUgPSBjYWNoZS5jbGVhckNhY2hlO1xyXG5cclxuICAgIHRoaXMuc3RhdGUuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2FkaW5nKCkgfHwgdGhpcy5pc1NhdmluZygpIHx8IHRoaXMuaXNEZWxldGluZygpO1xyXG4gICAgfSwgdGhpcy5zdGF0ZSk7XHJcblxyXG4gICAgLyoqIERhdGEgU3RvcmVzIE1hbmFnZW1lbnQ6IGltcGxlbWVudGF0aW9uIG11c3QgYmUgcmVwbGFjZWQsIHdpdGggY3VzdG9tIGNvZGUgb3IgdXNpbmdcclxuICAgICAgICB0aGUgaGVscGVycyBhZGRlZCB0byB0aGUgY2xhc3MgKHNlZSBhZGRYeFN1cHBvcnQgcHJvdG90eXBlIG1ldGhvZHMpLlxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTsgfVxyXG4gICAgdGhpcy5mZXRjaEdyb3VwRnJvbUxvY2FsID0gbm90SW1wbGVtZW50ZWQ7XHJcbiAgICB0aGlzLmZldGNoR3JvdXBGcm9tUmVtb3RlID0gbm90SW1wbGVtZW50ZWQ7XHJcbiAgICB0aGlzLnB1c2hHcm91cFRvTG9jYWwgPSBub3RJbXBsZW1lbnRlZDtcclxuICAgIHRoaXMucHVzaEdyb3VwVG9SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcclxuICAgIHRoaXMucmVtb3ZlSXRlbUZyb21SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcclxuXHJcbiAgICAvKiogQVBJIGRlZmluaXRpb24gKiovXHJcbiAgICB2YXIgYXBpID0gdGhpcztcclxuXHJcbiAgICBhcGkuZ2V0TGlzdCA9IGZ1bmN0aW9uIGdldExpc3QoZ3JvdXBJRCkge1xyXG4gICAgICAgIHZhciBjYWNoZUVudHJ5ID0gY2FjaGUuZ2V0R3JvdXBDYWNoZShncm91cElEKTtcclxuXHJcbiAgICAgICAgaWYgKGNhY2hlRW50cnkuY29udHJvbC5tdXN0UmV2YWxpZGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGNhY2hlIGRhdGEsIGlzIGZpcnN0IGxvYWQsIHRyeSBmcm9tIGxvY2FsXHJcbiAgICAgICAgICAgIGlmICghY2FjaGVFbnRyeS5saXN0KSB7XHJcbiAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gRnJvbSBsb2NhbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hHcm91cEZyb21Mb2NhbChncm91cElEKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxhdW5jaCByZW1vdGUgZm9yIHN5bmNcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdGVQcm9taXNlID0gdGhpcy5mZXRjaEdyb3VwRnJvbVJlbW90ZShncm91cElEKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0R3JvdXBDYWNoZShncm91cElELCBzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsKGdyb3VwSUQsIHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZlckRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdGUgZmFsbGJhY2s6IElmIG5vIGxvY2FsLCB3YWl0IGZvciByZW1vdGVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGEgOiByZW1vdGVQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZXIgYSBsaXN0LCBldmVuIGlmIGVtcHR5XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0R3JvdXBDYWNoZShncm91cElELCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hHcm91cFRvTG9jYWwoZ3JvdXBJRCwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gRnJvbSByZW1vdGVcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoR3JvdXBGcm9tUmVtb3RlKGdyb3VwSUQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlciBhIGxpc3QsIGV2ZW4gaWYgZW1wdHlcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRHcm91cENhY2hlKGdyb3VwSUQsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaEdyb3VwVG9Mb2NhbChncm91cElELCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRnJvbSBjYWNoZVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlRW50cnkubGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmdldEl0ZW0gPSBmdW5jdGlvbiBnZXRJdGVtKGdyb3VwSUQsIGl0ZW1JRCkge1xyXG4gICAgICAgIC8vIElNUE9SVEFOVDogVG8gc2ltcGxpZnksIGxvYWQgYWxsIHRoZSBsaXN0IChpcyBhIHNob3J0IGxpc3QpXHJcbiAgICAgICAgLy8gYW5kIGxvb2sgZnJvbSBpdHMgY2FjaGVkIGluZGV4XHJcbiAgICAgICAgLy8gVE9ETyBJbXBsZW1lbnQgaXRlbSBzZXJ2ZXIgbG9vay11cC4gQmUgY2FyZWZ1bCB3aXRoIGNhY2hlIHVwZGF0ZSxcclxuICAgICAgICAvLyBsaXN0IHNvcnRpbmcgYW5kIHN0YXRlIGZsYWdzLlxyXG4gICAgICAgIHJldHVybiBhcGkuZ2V0TGlzdChncm91cElEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBHZXQgZnJvbSBjYWNoZWQgaW5kZXhcclxuICAgICAgICAgICAgdmFyIGNhY2hlSXRlbSA9IGNhY2hlLmdldEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogRW5oYW5jZSBvbiBmdXR1cmUgd2l0aCBhY3R1YWwgbG9vay11cCBieSBBUEkgaXRlbUlEXHJcbiAgICAgICAgICAgIC8vIGlmIG5vdCBjYWNoZWQsIHRocm93aW5nIG5vdCBmb3VuZCBmcm9tIHRoZSBzZXJ2ZXIgKGp1c3QgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gbWlub3IgY2FzZXMgd2hlbiBhIG5ldyBpdGVtIGlzIG5vdCBzdGlsbCBpbiB0aGUgY2FjaGUgaWYgbGlua2VkXHJcbiAgICAgICAgICAgIC8vIGZyb20gb3RoZXIgYXBwIGRhdGEpLiBBbmQga2VlcCB1cGRhdGVkIGxpc3QgY2FjaGUgd2l0aCB0aGF0XHJcbiAgICAgICAgICAgIC8vIGl0ZW1zIGxvb2t1cFxyXG4gICAgICAgICAgICBpZiAoIWNhY2hlSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdHcm91cExpc3RSZW1vdGVNb2RlbCBOb3QgZm91bmQnLCBncm91cElELCBpdGVtSUQsIHNldHRpbmdzLk1vZGVsKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEZvdW5kJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlSXRlbS5pdGVtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBTYXZlIGFuIGl0ZW0gaW4gY2FjaGUsIGxvY2FsIGFuZCByZW1vdGUuXHJcbiAgICAgICAgQ2FuIGJlIG5ldyBvciB1cGRhdGVkLlxyXG4gICAgICAgIFRoZSBJRHMgZ29lcyB3aXRoIGFsbCB0aGUgb3RoZXIgZGF0YSwgYmVpbmdcclxuICAgICAgICBncm91cElEIHJlcXVpcmVkLCBpdGVtSUQgcmVxdWlyZWQgZm9yIHVwZGF0ZXNcclxuICAgICAgICBidXQgZmFsc3kgZm9yIGluc2VydGlvbnMuXHJcbiAgICAgICAgQHBhcmFtIGRhdGE6b2JqZWN0IFBsYWluIG9iamVjdFxyXG4gICAgKiovXHJcbiAgICBhcGkuc2V0SXRlbSA9IGZ1bmN0aW9uIHNldEl0ZW0oZGF0YSkge1xyXG4gICAgICAgIGFwaS5zdGF0ZS5pc1NhdmluZyh0cnVlKTtcclxuICAgICAgICAvLyBTZW5kIHRvIHJlbW90ZSBmaXJzdFxyXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hHcm91cFRvUmVtb3RlKGRhdGEpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRGF0YSkge1xyXG4gICAgICAgICAgICAvLyBTdWNjZXNzISB1cGRhdGUgbG9jYWwgY29weSB3aXRoIHJldHVybmVkIGRhdGFcclxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiB0byB1c2Ugc2VydmVyIGRhdGEgaGVyZSBzbyB3ZSBnZXQgdmFsdWVzIHNldFxyXG4gICAgICAgICAgICAvLyBieSB0aGUgc2VydmVyLCBhcyB1cGRhdGVzIGRhdGVzIGFuZCBpdGVtSUQgd2hlbiBjcmVhdGluZ1xyXG4gICAgICAgICAgICAvLyBhIG5ldyBpdGVtLlxyXG4gICAgICAgICAgICBpZiAoc2VydmVyRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwSUQgPSBzZXJ2ZXJEYXRhW3NldHRpbmdzLmdyb3VwSWRGaWVsZF07XHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGluIGNhY2hlXHJcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtQ2FjaGUoZ3JvdXBJRCwgc2VydmVyRGF0YVtzZXR0aW5ncy5pdGVtSWRGaWVsZF0sIHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbiBsb2NhbCBzdG9yYWdlXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBsb2NhbCBuZWVkIHRvIGJlIHNhdmVkIGFsbCB0aGUgZ3JvdXBlZCBkYXRhLCBub3QganVzdFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW07IHNpbmNlIHdlIGhhdmUgdGhlIGNhY2hlIGxpc3QgdXBkYXRlZCwgdXNlIHRoYXRcclxuICAgICAgICAgICAgICAgIC8vIGZ1bGwgbGlzdCB0byBzYXZlIGxvY2FsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hHcm91cFRvTG9jYWwoZ3JvdXBJRCwgY2FjaGUuZ2V0R3JvdXBDYWNoZShncm91cElEKS5saXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckRhdGE7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzU2F2aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmRlbEl0ZW0gPSBmdW5jdGlvbiBkZWxJdGVtKGdyb3VwSUQsIGl0ZW1JRCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGFwaS5zdGF0ZS5pc0RlbGV0aW5nKHRydWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlbW92ZSBpbiByZW1vdGUgZmlyc3RcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZShncm91cElELCBpdGVtSUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVtb3ZlZERhdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICAgICAgICAgIGNhY2hlLmRlbEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQpO1xyXG4gICAgICAgICAgICAvLyBTYXZlIGluIGxvY2FsIHN0b3JhZ2VcclxuICAgICAgICAgICAgLy8gSW4gbG9jYWwgbmVlZCB0byBiZSBzYXZlZCBhbGwgdGhlIGdyb3VwZWQgZGF0YTtcclxuICAgICAgICAgICAgLy8gc2luY2Ugd2UgaGF2ZSB0aGUgY2FjaGUgbGlzdCB1cGRhdGVkLCB1c2UgdGhhdFxyXG4gICAgICAgICAgICAvLyBmdWxsIGxpc3QgdG8gc2F2ZSBsb2NhbFxyXG4gICAgICAgICAgICB0aGlzLnB1c2hHcm91cFRvTG9jYWwoZ3JvdXBJRCwgY2FjaGUuZ2V0R3JvdXBDYWNoZShncm91cElEKS5saXN0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0RlbGV0aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkRGF0YTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIFJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKiBTb21lIFV0aWxzICoqL1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYW4gb2JzZXJ2YWJsZSBpbm1lZGlhdGVseSxcclxuICAgICAgICB3aXRoIHRoZSBjYWNoZWQgdmFsdWUgb3IgdW5kZWZpbmVkLFxyXG4gICAgICAgIGxhdW5jaGluZyBhbiBpdGVtIGxvYWQgdGhhdCB3aWxsIHVwZGF0ZSB0aGUgb2JzZXJ2YWJsZVxyXG4gICAgICAgIG9uIHJlYWR5IGlmIHRoZXJlIGlzIG5vIGNhY2hlZCB2YWx1ZS5cclxuICAgICAgICBBIG1ldGhvZCAnc3luYycgaXMgYWRkZWQgdG8gdGhlIG9ic2VydmFibGUgc28gY2FuIGJlIHJlcXVlc3RlZFxyXG4gICAgICAgIGEgZGF0YSBzeW5jL3JlbG9hZCBvbiBkZW1hbmQuXHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXRPYnNlcnZhYmxlSXRlbSA9IGZ1bmN0aW9uIGdldE9ic2VydmFibGVJdGVtKGdyb3VwSUQsIGl0ZW1JRCwgYXNNb2RlbCkge1xyXG4gICAgICAgIC8vIEdldCBmaXJzdCB2YWx1ZVxyXG4gICAgICAgIHZhciBmaXJzdFZhbHVlID0gY2FjaGUuZ2V0SXRlbUNhY2hlKGdyb3VwSUQsIGl0ZW1JRCk7XHJcbiAgICAgICAgZmlyc3RWYWx1ZSA9IGZpcnN0VmFsdWUgJiYgZmlyc3RWYWx1ZS5pdGVtIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgb2JzID0ga28ub2JzZXJ2YWJsZShhc01vZGVsID8gYXBpLmFzTW9kZWwoZmlyc3RWYWx1ZSkgOiBmaXJzdFZhbHVlKTtcclxuICAgICAgICAvLyBDcmVhdGUgbWV0aG9kICdzeW5jJ1xyXG4gICAgICAgIG9icy5zeW5jID0gZnVuY3Rpb24gc3luY09ic2VydmFibGVJdGVtKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW0oZ3JvdXBJRCwgaXRlbUlEKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXNNb2RlbClcclxuICAgICAgICAgICAgICAgICAgICBvYnMoKS5tb2RlbC51cGRhdGVXaXRoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9icyhpdGVtKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBGaXJzdCBsb2FkIGlmIG5vIGNhY2hlZCB2YWx1ZVxyXG4gICAgICAgIGlmICghZmlyc3RWYWx1ZSlcclxuICAgICAgICAgICAgb2JzLnN5bmMoKTtcclxuICAgICAgICAvLyBSZXR1cm5cclxuICAgICAgICByZXR1cm4gb2JzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmFzTW9kZWwgPSBmdW5jdGlvbiBhc01vZGVsKG9iamVjdCkge1xyXG4gICAgICAgIHZhciBNb2RlbCA9IHRoaXMuc2V0dGluZ3MuTW9kZWw7XHJcbiAgICAgICAgLy8gaWYgaXMgYW4gYXJyYXksIHJldHVybiBhIGxpc3Qgb2YgbW9kZWxzXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsKGl0ZW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZWwob2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcGkuZ2V0SXRlbU1vZGVsID0gZnVuY3Rpb24gZ2V0SXRlbU1vZGVsKGdyb3VwSUQsIGl0ZW1JRCkge1xyXG4gICAgICAgIHJldHVybiBhcGkuZ2V0SXRlbShncm91cElELCBpdGVtSUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YSA/IGFwaS5hc01vZGVsKGRhdGEpIDogbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBNb2RlbFZlcnNpb24gPSByZXF1aXJlKCcuLi91dGlscy9Nb2RlbFZlcnNpb24nKTtcclxuICAgIGFwaS5nZXRJdGVtVmVyc2lvbiA9IGZ1bmN0aW9uIGdldEl0ZW1WZXJzaW9uKGdyb3VwSUQsIGl0ZW1JRCkge1xyXG4gICAgICAgIHJldHVybiBhcGkuZ2V0SXRlbU1vZGVsKGdyb3VwSUQsIGl0ZW1JRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWwgPyBuZXcgTW9kZWxWZXJzaW9uKG1vZGVsKSA6IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcGkubmV3SXRlbVZlcnNpb24gPSBmdW5jdGlvbiBuZXdJdGVtVmVyc2lvbih2YWx1ZXMpIHtcclxuICAgICAgICAvLyBOZXcgb3JpZ2luYWwgYW5kIHZlcnNpb24gZm9yIHRoZSBtb2RlbFxyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gbmV3IE1vZGVsVmVyc2lvbihuZXcgdGhpcy5zZXR0aW5ncy5Nb2RlbCh2YWx1ZXMpKTtcclxuICAgICAgICAvLyBUbyBiZSBzdXJlIHRoYXQgdGhlIHZlcnNpb24gYXBwZWFyIGFzIHNvbWV0aGluZyAnbmV3JywgdW5zYXZlZCxcclxuICAgICAgICAvLyB3ZSB1cGRhdGUgaXRzIHRpbWVzdGFtcCB0byBiZSBkaWZmZXJlbnQgdG8gdGhlIG9yaWdpbmFsLlxyXG4gICAgICAgIHZlcnNpb24udmVyc2lvbi5tb2RlbC50b3VjaCgpO1xyXG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xyXG4gICAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHcm91cExpc3RSZW1vdGVNb2RlbDtcclxuXHJcbkdyb3VwTGlzdFJlbW90ZU1vZGVsLnByb3RvdHlwZS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQgPSBmdW5jdGlvbiBhZGRMb2NhbGZvcmFnZVN1cHBvcnQoYmFzZU5hbWUpIHtcclxuICAgIHZhciBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyk7XHJcblxyXG4gICAgdGhpcy5mZXRjaEdyb3VwRnJvbUxvY2FsID0gZnVuY3Rpb24gZmV0Y2hGcm9tTG9jYWwoZ3JvdXBJRCkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKGJhc2VOYW1lICsgZ3JvdXBJRCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsID0gZnVuY3Rpb24gcHVzaFRvTG9jYWwoZ3JvdXBJRCwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5zZXRJdGVtKGJhc2VOYW1lICsgZ3JvdXBJRCwgZGF0YSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuR3JvdXBMaXN0UmVtb3RlTW9kZWwucHJvdG90eXBlLmFkZFJlc3RTdXBwb3J0ID0gZnVuY3Rpb24gYWRkUmVzdFN1cHBvcnQocmVzdENsaWVudCwgYmFzZVVybCkge1xyXG4gICAgXHJcbiAgICB0aGlzLmZldGNoR3JvdXBGcm9tUmVtb3RlID0gZnVuY3Rpb24gZmV0Y2hGcm9tUmVtb3RlKGdyb3VwSUQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdENsaWVudC5nZXQoYmFzZVVybCArIGdyb3VwSUQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMucHVzaEdyb3VwVG9SZW1vdGUgPSBmdW5jdGlvbiBwdXNoVG9SZW1vdGUoZGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgZ3JvdXBJRCA9IGRhdGFbdGhpcy5zZXR0aW5ncy5ncm91cElkRmllbGRdLFxyXG4gICAgICAgICAgICBpdGVtSUQgPSBkYXRhW3RoaXMuc2V0dGluZ3MuaXRlbUlkRmllbGRdLFxyXG4gICAgICAgICAgICBtZXRob2QgPSBkYXRhW3RoaXMuc2V0dGluZ3MuaXRlbUlkRmllbGRdID8gJ3B1dCcgOiAncG9zdCc7XHJcblxyXG4gICAgICAgIHZhciB1cmwgPSBiYXNlVXJsICsgZ3JvdXBJRCArIChcclxuICAgICAgICAgICAgaXRlbUlEID8gJy8nICsgaXRlbUlEIDogJydcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50W21ldGhvZF0odXJsLCBkYXRhKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tUmVtb3RlID0gZnVuY3Rpb24gcmVtb3ZlSXRlbUZyb21SZW1vdGUoZ3JvdXBJRCwgaXRlbUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3RDbGllbnQuZGVsZXRlKGJhc2VVcmwgKyBncm91cElEICsgJy8nICsgaXRlbUlEKTtcclxuICAgIH07XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgSW5kZXhlZEdyb3VwTGlzdENhY2hlIG1hbmFnZXMgYSBpbi1tZW1vcnkgY2FjaGUgZm9yIGEgbGlzdFxyXG4gICAgb2Ygb2JqZWN0cywgZ3JvdXBlZCBieSBhIGZpZWxkIGFuZCB3aXRoIGluZGV4ZWQgYWNjZXNzIHRvIGdyb3Vwc1xyXG4gICAgYW5kIGl0ZW1zLCB3aXRoIGNhY2hlIGNvbnRyb2wuXHJcbiAgICBcclxuICAgIFNldHRpbmdzIG9iamVjdCBhcyB1bmlxdWUgcGFyYW1ldGVyOlxyXG4gICAgbGlzdFR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgZm9yIGVhY2ggZ3JvdXAgbGlzdCBjYWNoZS5cclxuICAgIEZVVFVSRTogaXRlbVR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgZm9yIGVhY2ggaXRlbSBjYWNoZS5cclxuICAgIHR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgdG8gdXNlIGZvciBsaXN0IGFuZCBpdGVtIGNhY2hlIGlmIHRoZXJlIGlzIG5vIGEgbW9yZSBleHBsaWNpdCBvbmVcclxuICAgIGdyb3VwSWRGaWVsZDogc3RyaW5nIE5hbWUgb2YgdGhlIGZpZWxkIHVzZWQgdG8gZ3JvdXAgb2JqZWN0c1xyXG4gICAgaXRlbUlkRmllbGQ6IHN0cmluZyBOYW1lIG9mIHRoZSBmaWVsZCB1c2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGVhY2ggaXRlbVxyXG4gICAgRlVUVVJFOiBNb2RlbDogY29uc3RydWN0b3Igb2YgdHlwZSBNb2RlbC5cclxuICAgIFxyXG4gICAgTm90ZTogJ3R0bCB0eXBlIGNvbnN0cnVjdG9yJyBjYW4gYmUgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIGEgdmFsdWUgdG8gcGFzcyB0byBtb21lbnQuZHVyYXRpb24gY29uc3RydWN0b3IgKG1vbWVudGpzIG1vZHVsZSkuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ2FjaGVDb250cm9sID0gcmVxdWlyZSgnLi9DYWNoZUNvbnRyb2wnKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4KGxpc3QsIGJ5RmllbGQpIHtcclxuICAgIHZhciBpbmRleCA9IHt9O1xyXG4gICAgXHJcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaXRlbUluZGV4KSB7XHJcbiAgICAgICAgaW5kZXhbaXRlbVtieUZpZWxkXV0gPSB7XHJcbiAgICAgICAgICAgIGluZGV4OiBpdGVtSW5kZXgsXHJcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1cclxuICAgICAgICAgICAgLy8gRGlyZWN0IHJlZmVyZW5jLCBjb3VsZCBiZSBhIHByb3BlcnR5IHRvbyBhdXRvIHJlc29sdmluZyBhc1xyXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgbGlrZSBnZXQgaXRlbSgpIHsgcmV0dXJuIGxpc3RbaXRlbUluZGV4W2l0ZW1bYnlGaWVsZF1dXSB8fCBudWxsOyB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpbmRleDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZWQodmFsLCBtc2cpIHtcclxuICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mKHZhbCkgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdSZXF1aXJlZCBwYXJhbWV0ZXInKTtcclxuICAgIGVsc2UgcmV0dXJuIHZhbDtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5kZXhlZEdyb3VwTGlzdENhY2hlKHNldHRpbmdzKSB7XHJcbiAgICBcclxuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcbiAgICBzZXR0aW5ncy50dGwgPSBzZXR0aW5ncy50dGwgfHwgMDtcclxuICAgIHNldHRpbmdzLmxpc3RUdGwgPSBzZXR0aW5ncy5saXN0VHRsIHx8IHNldHRpbmdzLnR0bCB8fCAwO1xyXG4gICAgLy9GVVRVUkU6IHNldHRpbmdzLml0ZW1UdGwgPSBzZXR0aW5ncy5pdGVtVHRsIHx8IHNldHRpbmdzLnR0bCB8fCAwO1xyXG4gICAgc2V0dGluZ3MuZ3JvdXBJZEZpZWxkID0gcmVxdWlyZWQoc2V0dGluZ3MuZ3JvdXBJZEZpZWxkLCAnZ3JvdXBJZEZpZWxkIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBzZXR0aW5ncy5pdGVtSWRGaWVsZCA9IHJlcXVpcmVkKHNldHRpbmdzLml0ZW1JZEZpZWxkLCAnaXRlbUlkRmllbGQgaXMgcmVxdWlyZWQnKTtcclxuICAgIC8vRlVUVVJFOiBzZXR0aW5ncy5Nb2RlbCA9IHNldHRpbmdzLk1vZGVsIHx8IHRocm93IG5ldyBFcnJvcignQSBNb2RlbCBpcyByZXF1aXJlZCcpO1xyXG4gICAgXHJcbiAgICB2YXIgY2FjaGUgPSB7LypcclxuICAgICAgICBncm91cElkRmllbGQ6IHtcclxuICAgICAgICAgICAgY29udHJvbDogQ2FjaGVDb250cm9sLFxyXG4gICAgICAgICAgICBsaXN0OiBBcnJheSxcclxuICAgICAgICAgICAgaW5kZXg6IHtcclxuICAgICAgICAgICAgICAgIGl0ZW1JZEZpZWxkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IEludGVnZXIgKGluZGV4IGluIHRoZSBsaXN0IGFycmF5KSxcclxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBPYmplY3QgKHJlZmVyZW5jZSB0byB0aGUgaXRlbSBvYmplY3QgaW4gdGhlIGFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIGZ1dHVyZTogY29udHJvbDogQ2FjaGVDb250cm9sIHBlciBpdGVtXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLi5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLi5cclxuICAgICovfTtcclxuICAgIFxyXG4gICAgdGhpcy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICBjYWNoZSA9IHt9O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBuZXdDYWNoZUVudHJ5KGxpc3QpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250cm9sOiBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiBzZXR0aW5ncy5saXN0VHRsIH0pLFxyXG4gICAgICAgICAgICBsaXN0OiBsaXN0IHx8IG51bGwsXHJcbiAgICAgICAgICAgIGluZGV4OiBsaXN0ICYmIGNyZWF0ZUluZGV4KGxpc3QsIHNldHRpbmdzLml0ZW1JZEZpZWxkKSB8fCB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0R3JvdXBDYWNoZShncm91cElELCBsaXN0KSB7XHJcbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSBjYWNoZVtncm91cElEXTtcclxuICAgICAgICBpZiAoY2FjaGVFbnRyeSkge1xyXG4gICAgICAgICAgICBjYWNoZUVudHJ5Lmxpc3QgPSBsaXN0IHx8IFtdO1xyXG4gICAgICAgICAgICBjYWNoZUVudHJ5LmluZGV4ID0gY3JlYXRlSW5kZXgobGlzdCB8fCBbXSwgc2V0dGluZ3MuaXRlbUlkRmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVFbnRyeSA9IGNhY2hlW2dyb3VwSURdID0gbmV3Q2FjaGVFbnRyeShsaXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FjaGVFbnRyeS5jb250cm9sLmxhdGVzdCA9IG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuc2V0R3JvdXBDYWNoZSA9IHNldEdyb3VwQ2FjaGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IHRoZSBjYWNoZSBlbnRyeSBmb3IgdGhlIEdyb3VwXHJcbiAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGdldEdyb3VwQ2FjaGUoZ3JvdXBJRCkge1xyXG4gICAgICAgIHZhciBjYWNoZUVudHJ5ID0gY2FjaGVbZ3JvdXBJRF07XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkgfHwgbmV3Q2FjaGVFbnRyeSgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmdldEdyb3VwQ2FjaGUgPSBnZXRHcm91cENhY2hlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIEdldCB0aGUgY2FjaGUgZW50cnkgZnJvbSB0aGUgSXRlbVxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBnZXRJdGVtQ2FjaGUoZ3JvdXBJRCwgaXRlbUlEKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSBjYWNoZVtncm91cElEXTtcclxuICAgICAgICBpZiAoY2FjaGVFbnRyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmRleFtpdGVtSURdIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0SXRlbUNhY2hlID0gZ2V0SXRlbUNhY2hlO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQsIGl0ZW0pIHtcclxuICAgICAgICB2YXIgY2FjaGVFbnRyeSA9IGNhY2hlW2dyb3VwSURdIHx8IG5ld0NhY2hlRW50cnkoW10pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExvb2YgZm9yIHRoZSBlbnRyeSwgdG8gdXBkYXRlIG9yIGluc2VydCBhIG5ldyBvbmVcclxuICAgICAgICB2YXIgaXRlbUVudHJ5ID0gY2FjaGVFbnRyeS5pbmRleFtpdGVtSURdO1xyXG4gICAgICAgIGlmIChpdGVtRW50cnkpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGVudHJ5XHJcbiAgICAgICAgICAgIGNhY2hlRW50cnkubGlzdFtpdGVtRW50cnkuaW5kZXhdID0gaXRlbTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHJlZmVyZW5jZSBpbiB0aGUgaW5kZXggdG9vIChpcyBub3QgY29tcHV0ZWQgcmlnaHQgbm93KVxyXG4gICAgICAgICAgICBpdGVtRW50cnkuaXRlbSA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGxpc3RcclxuICAgICAgICAgICAgdmFyIGl0ZW1JbmRleCA9IGNhY2hlRW50cnkubGlzdC5wdXNoKGl0ZW0pIC0gMTtcclxuICAgICAgICAgICAgY2FjaGVFbnRyeS5pbmRleFtpdGVtSURdID0ge1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW1JbmRleCxcclxuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuc2V0SXRlbUNhY2hlID0gc2V0SXRlbUNhY2hlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRlbEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQpIHtcclxuICAgICAgICB2YXIgZ3JvdXBFbnRyeSA9IGNhY2hlW2dyb3VwSURdIHx8IG51bGw7XHJcbiAgICAgICAgaWYgKGdyb3VwRW50cnkpIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW1FbnRyeSA9IGdyb3VwRW50cnkuaW5kZXhbaXRlbUlEXTtcclxuICAgICAgICAgICAgaWYgKGl0ZW1FbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxpc3QgcmVtb3ZpbmcgdGhlIGVsZW1lbnQgaW4gcGxhY2UsIHdpdGhvdXQgaG9sZXNcclxuICAgICAgICAgICAgICAgIGdyb3VwRW50cnkubGlzdC5zcGxpY2UoaXRlbUVudHJ5LmluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbmRleCBieTpcclxuICAgICAgICAgICAgICAgIC8vIC0gUmVtb3ZlIGl0ZW1JRCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdyb3VwRW50cnkuaW5kZXhbaXRlbUlEXTtcclxuICAgICAgICAgICAgICAgIC8vIC0gVXBkYXRlIGV2ZXJ5IGVudHJ5IHdpdGggYW4gSUQgZ3JlYXRlciB0aGFuIHRoZSB1cGRhdGVkLFxyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgbm93IG9uZSBwb3NpdGlvbiBsZXNzIGluIHRoZSB1cGRhdGVkIGxpc3RcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGdyb3VwRW50cnkuaW5kZXgpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwRW50cnkuaW5kZXhba2V5XSA+IGl0ZW1FbnRyeS5pbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbnRyeS5pbmRleFtrZXldLS07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5kZWxJdGVtQ2FjaGUgPSBkZWxJdGVtQ2FjaGU7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGRlbEdyb3VwQ2FjaGUoZ3JvdXBJRCkge1xyXG4gICAgICAgIHZhciBncm91cEVudHJ5ID0gY2FjaGVbZ3JvdXBJRF0gfHwgbnVsbDtcclxuICAgICAgICBpZiAoZ3JvdXBFbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIGVudHJ5L3Byb3BlcnR5XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtncm91cElEXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuZGVsR3JvdXBDYWNoZSA9IGRlbEdyb3VwQ2FjaGU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5kZXhlZEdyb3VwTGlzdENhY2hlO1xyXG4iLCIvKipcclxuICAgIEluZGV4ZWRMaXN0Q2FjaGUgbWFuYWdlcyBhIGluLW1lbW9yeSBjYWNoZSBmb3IgYSBsaXN0XHJcbiAgICBvZiBvYmplY3RzLCB3aXRoIGluZGV4ZWQgYWNjZXNzIHRvIGl0ZW1zXHJcbiAgICBhbmQgY2FjaGUgY29udHJvbC5cclxuICAgIFxyXG4gICAgU2V0dGluZ3Mgb2JqZWN0IGFzIHVuaXF1ZSBwYXJhbWV0ZXI6XHJcbiAgICBsaXN0VHRsOiB0dGwgdHlwZSBjb25zdHJ1Y3Rvci4gVGltZVRvTGlmZSBmb3IgZWFjaCBncm91cCBsaXN0IGNhY2hlLlxyXG4gICAgRlVUVVJFOiBpdGVtVHRsOiB0dGwgdHlwZSBjb25zdHJ1Y3Rvci4gVGltZVRvTGlmZSBmb3IgZWFjaCBpdGVtIGNhY2hlLlxyXG4gICAgdHRsOiB0dGwgdHlwZSBjb25zdHJ1Y3Rvci4gVGltZVRvTGlmZSB0byB1c2UgZm9yIGxpc3QgYW5kIGl0ZW0gY2FjaGUgaWYgdGhlcmUgaXMgbm8gYSBtb3JlIGV4cGxpY2l0IG9uZVxyXG4gICAgaXRlbUlkRmllbGQ6IHN0cmluZyBOYW1lIG9mIHRoZSBmaWVsZCB1c2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGVhY2ggaXRlbVxyXG4gICAgTW9kZWw6IGNvbnN0cnVjdG9yIG9mIHR5cGUgTW9kZWwuXHJcbiAgICBcclxuICAgIE5vdGU6ICd0dGwgdHlwZSBjb25zdHJ1Y3RvcicgY2FuIGJlIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciBhIHZhbHVlIHRvIHBhc3MgdG8gbW9tZW50LmR1cmF0aW9uIGNvbnN0cnVjdG9yIChtb21lbnRqcyBtb2R1bGUpLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENhY2hlQ29udHJvbCA9IHJlcXVpcmUoJy4vQ2FjaGVDb250cm9sJyksXHJcbiAgICBqc1Byb3BlcnRpZXNUb29scyA9IHJlcXVpcmUoJy4vanNQcm9wZXJ0aWVzVG9vbHMnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZW1JbmRleEVudHJ5KGxpc3QsIGl0ZW1JbmRleCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbmRleDogaXRlbUluZGV4LFxyXG4gICAgICAgIGdldCBpdGVtKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGlzdFt0aGlzLmluZGV4XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJbmRleChsaXN0LCBieUZpZWxkKSB7XHJcbiAgICB2YXIgaW5kZXggPSB7fTtcclxuICAgIFxyXG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGl0ZW1JbmRleCkge1xyXG4gICAgICAgIGluZGV4W2tvLnVud3JhcChpdGVtW2J5RmllbGRdKV0gPSBjcmVhdGVJdGVtSW5kZXhFbnRyeShsaXN0LCBpdGVtSW5kZXgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlZCh2YWwsIG1zZykge1xyXG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YodmFsKSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ1JlcXVpcmVkIHBhcmFtZXRlcicpO1xyXG4gICAgZWxzZSByZXR1cm4gdmFsO1xyXG59XHJcblxyXG4vKipcclxuICAgIEFuIGl0ZW0gYWRhcHRlciByZWNlaXZlcyB0aGUgb2xkIGFuZCB0aGUgbmV3IGl0ZW0gZGF0YSBhbmQgcmV0dXJuc1xyXG4gICAgdGhlIGl0ZW0gdG8gaG9sZCBpbiB0aGUgbGlzdC4gVGhlIHJldHVybmluZyBvYmplY3QgY2FuIGJlIGEgcmVmZXJlbmNlXHJcbiAgICB0byB0aGUgc2FtZSBleGlzdGVudCBvYmplY3QgKG9sZEl0ZW0pIHRoYXQgZ2V0cyB1cGRhdGVkIHdpdGggdGhlIFxyXG4gICAgbmV3IHZhbHVlcyAobmV3SXRlbSksIG9yIGp1c3QgdGhlIG5ld0l0ZW0gb3IgYW55IGNvbnZlcnNpb24gb3ZlciB0aGVcclxuICAgIHJhdyBuZXdJdGVtIGRhdGEuXHJcbiAgICBUaGlzIGFsbG93cyB0byBwZXJmb3JtIGNoYW5nZXMsIGFkZCBwcm9wZXJ0aWVzLCBvciBrZWVwIHJlZmVyZW5jZXMsXHJcbiAgICBsaWtlIGNyZWF0aW5nIG9ic2VydmFibGVzLCBNb2RlbHMuXHJcbiAgICBcclxuICAgIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybnMgdGhlIG5ld0l0ZW0uXHJcbioqL1xyXG5mdW5jdGlvbiBkZWZhdWx0SXRlbUFkYXB0ZXIob2xkSXRlbSwgbmV3SXRlbSkge1xyXG4gICAgcmV0dXJuIG5ld0l0ZW07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluZGV4ZWRMaXN0Q2FjaGUoc2V0dGluZ3MpIHtcclxuICAgIFxyXG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgIHNldHRpbmdzLnR0bCA9IHNldHRpbmdzLnR0bCB8fCAwO1xyXG4gICAgc2V0dGluZ3MubGlzdFR0bCA9IHNldHRpbmdzLmxpc3RUdGwgfHwgc2V0dGluZ3MudHRsIHx8IDA7XHJcbiAgICAvL0ZVVFVSRTogc2V0dGluZ3MuaXRlbVR0bCA9IHNldHRpbmdzLml0ZW1UdGwgfHwgc2V0dGluZ3MudHRsIHx8IDA7XHJcbiAgICBzZXR0aW5ncy5pdGVtSWRGaWVsZCA9IHJlcXVpcmVkKHNldHRpbmdzLml0ZW1JZEZpZWxkLCAnaXRlbUlkRmllbGQgaXMgcmVxdWlyZWQnKTtcclxuICAgIHNldHRpbmdzLml0ZW1BZGFwdGVyID0gdHlwZW9mKHNldHRpbmdzLml0ZW1BZGFwdGVyKSA9PT0gJ2Z1bmN0aW9uJyA/IHNldHRpbmdzLml0ZW1BZGFwdGVyIDogZGVmYXVsdEl0ZW1BZGFwdGVyO1xyXG5cclxuICAgIC8vIEludGVybmFsIGZsYWcgdG8gbm90aWZ5IGlmIHRoZSBjYWNoZSB3YXMgbm90IHVzZWQgc3RpbGwgKG5vIGRhdGEgc2V0KVxyXG4gICAgLy8gc2luY2UgaXRzIGluc3RhbnRpYXRpb24uIE9uIGZpcnN0IHNldExpc3Qgd2lsbCBjaGFuZ2UgdG8gZmFsc2UgYW5kIGtlZXAgaW4gdGhhdCBzdGF0ZS5cclxuICAgIHZhciB1bnVzZWQgPSB0cnVlO1xyXG4gICAgLy8gSW50ZXJuYWwgY2FjaGUgbWFuYWdlbWVudFxyXG4gICAgdmFyIGNhY2hlID0ge1xyXG4gICAgICAgIGNvbnRyb2w6IG5ldyBDYWNoZUNvbnRyb2woeyB0dGw6IHNldHRpbmdzLmxpc3RUdGwgfSksXHJcbiAgICAgICAgbGlzdDoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcclxuICAgICAgICBpbmRleDogey8qXHJcbiAgICAgICAgICAgIGl0ZW1JZEZpZWxkOiB7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogSW50ZWdlciAoaW5kZXggaW4gdGhlIGxpc3QgYXJyYXkpLFxyXG4gICAgICAgICAgICAgICAgaXRlbTogT2JqZWN0IChwcm9wZXJ0eSByZWZlcmVuY2luZyB0byB0aGUgaXRlbSBvYmplY3QgaW4gdGhlIGFycmF5IGJ5IGl0cyBpbmRleClcclxuICAgICAgICAgICAgICAgIC8vIE1heWJlIGZ1dHVyZTogY29udHJvbDogQ2FjaGVDb250cm9sIHBlciBpdGVtXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC4uXHJcbiAgICAgICAgKi99XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIGNhY2hlLmNvbnRyb2wubGF0ZXN0ID0gbnVsbDtcclxuICAgICAgICBjYWNoZS5saXN0KFtdKTtcclxuICAgICAgICBjYWNoZS5pbmRleCA9IHt9O1xyXG4gICAgICAgIHVudXNlZCA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIEdldCB0aGUgY2FjaGUgZW50cnkgZnJvbSB0aGUgSXRlbVxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBnZXRJdGVtQ2FjaGUoaXRlbUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlLmluZGV4W2l0ZW1JRF0gfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmdldEl0ZW1DYWNoZSA9IGdldEl0ZW1DYWNoZTtcclxuXHJcbiAgICAvLyBBZGFwdCBhIG5ldyBpdGVtIHVzaW5nIHRoZSBpdGVtQWRhcHRlciBhbmQgZ2V0dGluZyB0aGUgb2xkIHJlZmVyZW5jZS5cclxuICAgIGZ1bmN0aW9uIGFkYXB0SXRlbShuZXdJdGVtKSB7XHJcbiAgICAgICAgdmFyIG9sZEl0ZW0gPSBnZXRJdGVtQ2FjaGUoa28udW53cmFwKG5ld0l0ZW1bc2V0dGluZ3MuaXRlbUlkRmllbGRdKSk7XHJcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLml0ZW1BZGFwdGVyKG9sZEl0ZW0sIG5ld0l0ZW0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBZGFwdCB0aGUgZWFjaCBlbGVtZW50IGluIHRoZSBsaXN0IHdpdGggdGhlIGl0ZW1BZGFwdGVyLFxyXG4gICAgLy8gcGFzc2luZyBhbiBvbGQgcmVmZXJlbmNlIGFuZCB0aGUgbmV3IGl0ZW0gb24gZWFjaCwgYW5kIGVuc3VyaW5nXHJcbiAgICAvLyB0byByZXR1cm4gZXZlciBhbiBhcnJheSwgZXZlbiBpZiBlbXB0eS5cclxuICAgIGZ1bmN0aW9uIGFkYXB0TGlzdChsaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIChsaXN0IHx8IFtdKS5tYXAoYWRhcHRJdGVtKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRMaXN0KGxpc3QpIHtcclxuICAgICAgICBjYWNoZS5saXN0KGFkYXB0TGlzdChsaXN0KSk7XHJcbiAgICAgICAgY2FjaGUuaW5kZXggPSBjcmVhdGVJbmRleChjYWNoZS5saXN0KCksIHNldHRpbmdzLml0ZW1JZEZpZWxkKTtcclxuICAgICAgICBjYWNoZS5jb250cm9sLmxhdGVzdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdW51c2VkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljLCByZWFkLW9ubHksIGFjY2VzcyB0byBjYWNoZSBpbmZvIChvYmplY3RzIGFyZSBtdXRhYmxlLCBidXQgYWxtb3N0IHRoZSByZWZlcmVuY2VcclxuICAgIC8vIGNhbm5vdCBiZSBicm9rZW47IGEgY2hhbmdlIGluIHRoZSBsaXN0IGluc3RhbmNlIHVwZGF0ZXMgdGhlIGNhY2hlIHByb3Blcmx5KS5cclxuICAgIGpzUHJvcGVydGllc1Rvb2xzLmRlZmluZUdldHRlcih0aGlzLCAnY29udHJvbCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FjaGUuY29udHJvbDsgfSk7XHJcbiAgICBqc1Byb3BlcnRpZXNUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ2xpc3QnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhY2hlLmxpc3Q7IH0pO1xyXG4gICAganNQcm9wZXJ0aWVzVG9vbHMuZGVmaW5lU2V0dGVyKHRoaXMsICdsaXN0JywgZnVuY3Rpb24obGlzdCkgeyByZXR1cm4gc2V0TGlzdChsaXN0KTsgfSk7XHJcbiAgICBqc1Byb3BlcnRpZXNUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ2luZGV4JywgZnVuY3Rpb24oKSB7IHJldHVybiBjYWNoZS5pbmRleDsgfSk7XHJcbiAgICBqc1Byb3BlcnRpZXNUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ3VudXNlZCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdW51c2VkOyB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRJdGVtQ2FjaGUoaXRlbSkge1xyXG4gICAgICAgIHZhciBpdGVtSUQgPSBrby51bndyYXAoaXRlbVtzZXR0aW5ncy5pdGVtSWRGaWVsZF0pO1xyXG4gICAgICAgIC8vIExvb2sgZm9yIHRoZSBlbnRyeSwgdG8gdXBkYXRlIG9yIGluc2VydCBhIG5ldyBvbmVcclxuICAgICAgICB2YXIgaXRlbUVudHJ5ID0gY2FjaGUuaW5kZXhbaXRlbUlEXTtcclxuICAgICAgICBpZiAoaXRlbUVudHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBlbnRyeVxyXG4gICAgICAgICAgICBjYWNoZS5saXN0KClbaXRlbUVudHJ5LmluZGV4XSA9IGFkYXB0SXRlbShpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICB2YXIgaXRlbUluZGV4ID0gY2FjaGUubGlzdC5wdXNoKGFkYXB0SXRlbShpdGVtKSkgLSAxO1xyXG4gICAgICAgICAgICBjYWNoZS5pbmRleFtpdGVtSURdID0gY3JlYXRlSXRlbUluZGV4RW50cnkoY2FjaGUubGlzdCgpLCBpdGVtSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldEl0ZW1DYWNoZSA9IHNldEl0ZW1DYWNoZTtcclxuXHJcbiAgICBmdW5jdGlvbiBkZWxJdGVtQ2FjaGUoaXRlbUlEKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1FbnRyeSA9IGNhY2hlLmluZGV4W2l0ZW1JRF07XHJcbiAgICAgICAgaWYgKGl0ZW1FbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgbGlzdCByZW1vdmluZyB0aGUgZWxlbWVudCBpbiBwbGFjZSwgd2l0aG91dCBob2xlc1xyXG4gICAgICAgICAgICBjYWNoZS5saXN0LnNwbGljZShpdGVtRW50cnkuaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgaW5kZXggYnk6XHJcbiAgICAgICAgICAgIC8vIC0gUmVtb3ZlIGl0ZW1JRCBlbnRyeVxyXG4gICAgICAgICAgICBkZWxldGUgY2FjaGUuaW5kZXhbaXRlbUlEXTtcclxuICAgICAgICAgICAgLy8gLSBVcGRhdGUgZXZlcnkgZW50cnkgd2l0aCBhbiBJRCBncmVhdGVyIHRoYW4gdGhlIHVwZGF0ZWQsXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIG5vdyBvbmUgcG9zaXRpb24gbGVzcyBpbiB0aGUgdXBkYXRlZCBsaXN0XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNhY2hlLmluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlLmluZGV4W2tleV0gPiBpdGVtRW50cnkuaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5kZXhba2V5XS0tO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuZGVsSXRlbUNhY2hlID0gZGVsSXRlbUNhY2hlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWRMaXN0Q2FjaGU7XHJcbiIsIi8qKlxyXG4gICAgTGlzdFJlbW90ZU1vZGVsXHJcbiAgICBVdGlsaXR5IGNsYXNzIGZvciBjb21tb24gY29kZSBmb3IgYSBkYXRhIGxpc3QgZW50aXR5IGZyb20gYSByZW1vdGUgc291cmNlLFxyXG4gICAgd2l0aCBsb2NhbCBjb3B5IGFuZCBjYWNoZSwgd2hlcmUgdGhlIGxpc3QgaXMgbWFuYWdlZCB3aWxsIGFsbCB0aGUgZGF0YSxcclxuICAgIHdpdGhvdXQgcGFnaW5nL2N1cnNvciwgd2l0aCBpbmRleGVkIGFjY2VzcyB0byBlYWNoIGl0ZW0gYnkgaXRzIElELlxyXG4gICAgSXMgZ29vZCBmb3IgbGlzdHMgdGhhdCBrZWVwIHNtYWxsIGluIHRoZSB0aW1lLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIEluZGV4ZWRMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL0luZGV4ZWRMaXN0Q2FjaGUnKTtcclxuXHJcbmZ1bmN0aW9uIHJlcXVpcmVkKHZhbCwgbXNnKSB7XHJcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZih2YWwpID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnUmVxdWlyZWQgcGFyYW1ldGVyJyk7XHJcbiAgICBlbHNlIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIExpc3RSZW1vdGVNb2RlbChzZXR0aW5ncykge1xyXG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czo1MCovXHJcblxyXG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgIHNldHRpbmdzLmxpc3RUdGwgPSByZXF1aXJlZChzZXR0aW5ncy5saXN0VHRsLCAnbGlzdFR0bCBpcyByZXF1aXJlZCcpO1xyXG4gICAgc2V0dGluZ3MuaXRlbUlkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5pdGVtSWRGaWVsZCwgJ2l0ZW1JZEZpZWxkIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAvLyBPcHRpb25hbCBtb2RlbFxyXG4gICAgc2V0dGluZ3MuTW9kZWwgPSBzZXR0aW5ncy5Nb2RlbCB8fCBudWxsO1xyXG4gICAgLy8gUmVxdWlyZWQgZm9yIEFQSSBhZGRpdGlvbnNcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgIGlzTG9hZGluZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcbiAgICAgICAgaXNTeW5jaW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcclxuICAgICAgICBpc1NhdmluZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcbiAgICAgICAgaXNEZWxldGluZzoga28ub2JzZXJ2YWJsZShmYWxzZSlcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEl0ZW1zIGFyZSBtYW5hZ2VkIGFzIHBsYWluIG9iamVjdCBieSBkZWZhdWx0LCBidXQgYXMgcGVybWFuZW50LCB1cGRhdGVkXHJcbiAgICAvLyBtb2RlbCBpbnN0YW5jZXMgaWYgdGhlIE1vZGVsIGNsYXNzIHdhcyBzcGVjaWZpZWQuXHJcbiAgICAvLyBUaGlzIGFkYXB0ZXIgaXMgcGFzc2VkIHRvIHRoZSBjYWNoZSBjb25zdHJ1Y3RvciB0b28ga2VlcCB0aGUgaW4tbWVtb3J5XHJcbiAgICAvLyBvYmplY3RzIHVwIHRvIGRhdGUgd2l0aCB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXHJcbiAgICBmdW5jdGlvbiBpdGVtQWRhcHRlcihvbGRJdGVtLCBuZXdJdGVtKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLk1vZGVsKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBtb2RlbCBpdGVtIGFscmVhZHkgZXhpc3RzLCB1cGRhdGUgd2l0aCBuZXcgdmFsdWVzXHJcbiAgICAgICAgICAgIGlmIChvbGRJdGVtICYmIG9sZEl0ZW0gaW5zdGFuY2VvZiBzZXR0aW5ncy5Nb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgb2xkSXRlbS5tb2RlbC51cGRhdGVXaXRoKG5ld0l0ZW0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOZXcgY3JlYXRlZCBpdGVtLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXMsIG5vLW1vZGVsLCB2YWx1ZSwgdGhleSBhcmUgZGlzY2FyZGVkXHJcbiAgICAgICAgICAgICAgICAvLyAodGhhdCBzaXR1YXRpb24gY2FuIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBhcmUgaXJyZWd1bGFyIG1vZGlmaWNhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBpbnRlcm5hbCBiZWhhdmlvcikuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNldHRpbmdzLk1vZGVsKG5ld0l0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3SXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBjYWNoZSA9IG5ldyBJbmRleGVkTGlzdENhY2hlKHtcclxuICAgICAgICBsaXN0VHRsOiBzZXR0aW5ncy5saXN0VHRsLFxyXG4gICAgICAgIGl0ZW1JZEZpZWxkOiBzZXR0aW5ncy5pdGVtSWRGaWVsZCxcclxuICAgICAgICBpdGVtQWRhcHRlcjogaXRlbUFkYXB0ZXJcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLmNsZWFyQ2FjaGUgPSBjYWNoZS5jbGVhckNhY2hlO1xyXG5cclxuICAgIHRoaXMuc3RhdGUuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2FkaW5nKCkgfHwgdGhpcy5pc1NhdmluZygpIHx8IHRoaXMuaXNEZWxldGluZygpO1xyXG4gICAgfSwgdGhpcy5zdGF0ZSk7XHJcblxyXG4gICAgLyoqIERhdGEgU3RvcmVzIE1hbmFnZW1lbnQ6IGltcGxlbWVudGF0aW9uIG11c3QgYmUgcmVwbGFjZWQsIHdpdGggY3VzdG9tIGNvZGUgb3IgdXNpbmdcclxuICAgICAgICB0aGUgaGVscGVycyBhZGRlZCB0byB0aGUgY2xhc3MgKHNlZSBhZGRYeFN1cHBvcnQgcHJvdG90eXBlIG1ldGhvZHMpLlxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTsgfVxyXG4gICAgdGhpcy5mZXRjaExpc3RGcm9tTG9jYWwgPSBub3RJbXBsZW1lbnRlZDtcclxuICAgIHRoaXMuZmV0Y2hMaXN0RnJvbVJlbW90ZSA9IG5vdEltcGxlbWVudGVkO1xyXG4gICAgdGhpcy5wdXNoTGlzdFRvTG9jYWwgPSBub3RJbXBsZW1lbnRlZDtcclxuICAgIHRoaXMucHVzaExpc3RUb1JlbW90ZSA9IG5vdEltcGxlbWVudGVkO1xyXG4gICAgdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZSA9IG5vdEltcGxlbWVudGVkO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBSZXRyaWV2ZXMgYSBwbGFpbiBhcnJheS1vYmplY3RzIGZyb20gdGhlIGNhY2hlZCBsaXN0XHJcbiAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGdldFBsYWluQ2FjaGVkTGlzdCgpIHtcclxuICAgICAgICB2YXIgYXJyID0gY2FjaGUubGlzdCgpO1xyXG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgc2V0dGluZ3MuTW9kZWwgJiYgaXRlbSBpbnN0YW5jZW9mIHNldHRpbmdzLk1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5tb2RlbC50b1BsYWluT2JqZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBUEkgZGVmaW5pdGlvbiAqKi9cclxuICAgIHZhciBhcGkgPSB0aGlzO1xyXG4gICAgXHJcbiAgICAvLyBEaXJlY3QgYWNjZXNzIHRvIHRoZSBvYnNlcnZhYmxlIGNhY2hlZCBsaXN0LlxyXG4gICAgYXBpLmxpc3QgPSBjYWNoZS5saXN0O1xyXG5cclxuICAgIC8vIEN1cnJlbnRseSwganVzdCBhIHdyYXBwZXIgZm9yIGdldExpc3QuXHJcbiAgICBhcGkuc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwaS5nZXRMaXN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIFByb21pc2UgYmFzZWQgcmVxdWVzdCB0byBnZXQgdGhlIGxpc3QgKGZyb20gY2FjaGUsIGxvY2FsIG9yIHJlbW90ZSkuXHJcbiAgICAgICAgSXQgdXBkYXRlcyB0aGUgb2JzZXJ2YWJsZSBsaXN0IGlmIG5ldyBkYXRhIGlzIGZldGNoZWQuXHJcbiAgICAgICAgQSBnZW5lcmFsIGFwcHJvYWNoIGlzIHRvIHVzZSB0aGUgb2JzZXJ2YWJsZSBsaXN0IGFuZCBjYWxsIHRoZSAnc3luYycgbWV0aG9kXHJcbiAgICAgICAgcmF0aGVyIHRoYW4gd2FpdCB0aGlzIHByb21pc2UgdG8gZmluaXNoICgnc3luYycgcGVyZm9ybXMgdGhpcyBsb2FkIHJlYWxseSkuXHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXRMaXN0ID0gZnVuY3Rpb24gZ2V0TGlzdCgpIHtcclxuXHJcbiAgICAgICAgaWYgKGNhY2hlLmNvbnRyb2wubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICAvLyBDYWNoZSBzdGlsbCBub3QgdXNlZCwgdGhlbiBpcyBmaXJzdCBsb2FkLCB0cnkgbG9hZCBmcm9tIGxvY2FsXHJcbiAgICAgICAgICAgIGlmIChjYWNoZS51bnVzZWQpIHtcclxuICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBGcm9tIGxvY2FsXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaExpc3RGcm9tTG9jYWwoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxhdW5jaCByZW1vdGUgZm9yIHN5bmNcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdGVQcm9taXNlID0gdGhpcy5mZXRjaExpc3RGcm9tUmVtb3RlKClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmxpc3QgPSBzZXJ2ZXJEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMaXN0VG9Mb2NhbChzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBsb2NhbCBkYXRhLCBjYXRjaCBlcnJvciBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzeW5jIHNpbmNlIHRoaXMgcHJvbWlzZSB3aWxsIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSBhdmFpbGFibGUgdG8gYW55IGNvbnN1bWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvZyB0byBjb25zb2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMaXN0UmVtb3RlTW9kZWw6IHJlbW90ZSBzeW5jaHJvbml6YXRpb24gZmFpbGVkJywgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvbWlzZSBpcyByZXR1cm5lZCBzbyB3aWxsIGJlIGNvbnN1bWVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXRocm93IGFuZCBsZXQgdGhlIG90aGVyIGNhdGNoLWJsb2NrcyBkbyB0aGUgY29tbW9uIHN0dWZmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3RlIGZhbGxiYWNrOiBJZiBubyBsb2NhbCwgd2FpdCBmb3IgcmVtb3RlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhIDogcmVtb3RlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyIGEgbGlzdCwgZXZlbiBpZiBlbXB0eVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmxpc3QgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaExpc3RUb0xvY2FsKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUubGlzdDtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIEZyb20gcmVtb3RlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaExpc3RGcm9tUmVtb3RlKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyIGEgbGlzdCwgZXZlbiBpZiBlbXB0eVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmxpc3QgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaExpc3RUb0xvY2FsKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUubGlzdDtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGcm9tIGNhY2hlXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGUubGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmdldEl0ZW0gPSBmdW5jdGlvbiBnZXRJdGVtKGl0ZW1JRCkge1xyXG4gICAgICAgIC8vIElNUE9SVEFOVDogVG8gc2ltcGxpZnksIGxvYWQgYWxsIHRoZSBsaXN0IChpcyBhIHNob3J0IGxpc3QpXHJcbiAgICAgICAgLy8gYW5kIGxvb2sgZnJvbSBpdHMgY2FjaGVkIGluZGV4XHJcbiAgICAgICAgLy8gVE9ETyBJbXBsZW1lbnQgaXRlbSBzZXJ2ZXIgbG9vay11cC4gQmUgY2FyZWZ1bCB3aXRoIGNhY2hlIHVwZGF0ZSxcclxuICAgICAgICAvLyBsaXN0IHNvcnRpbmcgYW5kIHN0YXRlIGZsYWdzLlxyXG4gICAgICAgIHJldHVybiBhcGkuZ2V0TGlzdCgpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBmcm9tIGNhY2hlZCBpbmRleFxyXG4gICAgICAgICAgICB2YXIgY2FjaGVJdGVtID0gY2FjaGUuZ2V0SXRlbUNhY2hlKGl0ZW1JRCk7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBFbmhhbmNlIG9uIGZ1dHVyZSB3aXRoIGFjdHVhbCBsb29rLXVwIGJ5IEFQSSBpdGVtSURcclxuICAgICAgICAgICAgLy8gaWYgbm90IGNhY2hlZCwgdGhyb3dpbmcgbm90IGZvdW5kIGZyb20gdGhlIHNlcnZlciAoanVzdCB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyBtaW5vciBjYXNlcyB3aGVuIGEgbmV3IGl0ZW0gaXMgbm90IHN0aWxsIGluIHRoZSBjYWNoZSBpZiBsaW5rZWRcclxuICAgICAgICAgICAgLy8gZnJvbSBvdGhlciBhcHAgZGF0YSkuIEFuZCBrZWVwIHVwZGF0ZWQgbGlzdCBjYWNoZSB3aXRoIHRoYXRcclxuICAgICAgICAgICAgLy8gaXRlbXMgbG9va3VwXHJcbiAgICAgICAgICAgIGlmICghY2FjaGVJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0xpc3RSZW1vdGVNb2RlbCBOb3QgZm91bmQnLCBpdGVtSUQsIHNldHRpbmdzLk1vZGVsKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEZvdW5kJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlSXRlbS5pdGVtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2VuZXJhdGVzIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgaW5tZWRpYXRlbHksXHJcbiAgICAgICAgd2l0aCB0aGUgY2FjaGVkIHZhbHVlIG9yIHVuZGVmaW5lZCxcclxuICAgICAgICBsYXVuY2hpbmcgYW4gaXRlbSBsb2FkIHRoYXQgd2lsbCB1cGRhdGUgdGhlIG9ic2VydmFibGVcclxuICAgICAgICBvbiByZWFkeSBpZiB0aGVyZSBpcyBubyBjYWNoZWQgdmFsdWUuXHJcbiAgICAgICAgQSBtZXRob2QgJ3N5bmMnIGlzIGFkZGVkIHRvIHRoZSBvYnNlcnZhYmxlIHNvIGNhbiBiZSByZXF1ZXN0ZWRcclxuICAgICAgICBhIGRhdGEgc3luYy9yZWxvYWQgb24gZGVtYW5kLlxyXG4gICAgKiovXHJcbiAgICBhcGkuZ2V0T2JzZXJ2YWJsZUl0ZW0gPSBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlSXRlbShpdGVtSUQpIHtcclxuICAgICAgICAvLyBHZXQgZmlyc3QgdmFsdWVcclxuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGNhY2hlLmdldEl0ZW1DYWNoZShpdGVtSUQpO1xyXG4gICAgICAgIGZpcnN0VmFsdWUgPSBmaXJzdFZhbHVlICYmIGZpcnN0VmFsdWUuaXRlbSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIG9icyA9IGtvLm9ic2VydmFibGUoZmlyc3RWYWx1ZSk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIG1ldGhvZCAnc3luYydcclxuICAgICAgICBvYnMuc3luYyA9IGZ1bmN0aW9uIHN5bmNPYnNlcnZhYmxlSXRlbSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwaS5nZXRJdGVtKGl0ZW1JRClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbU1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBvYnMoaXRlbU1vZGVsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBGaXJzdCBsb2FkIGlmIG5vIGNhY2hlZCB2YWx1ZVxyXG4gICAgICAgIGlmICghZmlyc3RWYWx1ZSlcclxuICAgICAgICAgICAgb2JzLnN5bmMoKTtcclxuICAgICAgICAvLyBSZXR1cm5cclxuICAgICAgICByZXR1cm4gb2JzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgU2ltaWxhciB0byBnZXRPYnNlcnZhYmxlSXRlbSwgaXQgYWxsb3dzIHRvIGdldFxyXG4gICAgICAgIGFuIG9ic2VydmFibGUgdG8gYW4gaXRlbSBtb2RlbCBzeW5jaHJvbm91c2x5IHRoYXRcclxuICAgICAgICBpdCB0cmlnZ2VycyBhbiBpdGVtIGxvYWQgd2hlbiBpdHMgbWV0aG9kICdzeW5jJ1xyXG4gICAgICAgIGlzIGNhbGxlZC4gVGhlIGl0ZW1JRCBpcyBwYXNzZWQgdG8gdGhlIHN5bmMgaXRlbSxcclxuICAgICAgICBzaW5jZSB0aGUgb2JzZXJ2YWJsZSBpcyBtZWFudCB0byBob2xkIGFueSBpdGVtL2l0ZW1JRFxyXG4gICAgICAgIChpdHMgYSB3aWxkY2FyZCkuXHJcbiAgICAgICAgVGhpcyB3YXksIGEgcmVmZXJlbmNlIHRvIGFuIG9ic2VydmFibGUgY2FuIGJlIGdldCBvbiBpbml0aWFsaXphdGlvblxyXG4gICAgICAgIGV2ZW4gaWYgdGhlcmUgaXMgbm8gZGF0YSBzdGlsbCwgZXZlbiBubyBpdGVtSUQsIGFuZCBsb2FkXHJcbiAgICAgICAgaXQgbGF0ZXIgbGF6aWx5LCBvbiBkZW1hbmQsIHdoaWxlIGtlZXBpbmcgdGhlIGNvbnRlbnQgb2YgdGhlXHJcbiAgICAgICAgcHJldmlvdXMgb3V0ZGF0ZWQgb3IgZGlmZmVyZW50IGl0ZW0uXHJcblxyXG4gICAgICAgIE5PVEU6IEFQSSBhbHRlcm5hdGl2ZSBuYW1lczogZ2V0TGF6eUl0ZW0sIGNyZWF0ZU11dGFibGVJdGVtXHJcbiAgICAgICAgTk9URTogTWF5YmUgY2FuIGdldCBzdGF0ZSBvYnNlcnZhYmxlcyAobG9hZGluZywgc3luY2luZy4uKT9cclxuICAgICAgICBOT1RFOiBPbiB1cGRhdGUgYSBzYW1lIGl0ZW1JRCwgbWF5YmUgdXBkYXRlIHRoZSBtb2RlbCB3aXRoIHVwZGF0ZVdpdGhcclxuICAgICAgICAgICAgICAgIHJhdGhlciB0aGFuIGNoYW5nZSB0aGUgcmVmZXJlbmNlIG1vZGVsPz8gKGRvdWJsZSBjaGVjazpcclxuICAgICAgICAgICAgICAgIHNpbmNlIHRoZSBtb2RlbCBpcyB0aGUgc2FtZSBpbiBjYWNoZSwgYWxyZWFkeSB1cGRhdGVkXHJcbiAgICAgICAgICAgICAgICB3aXRoICd1cGRhdGVXaXRoJywgdGhlcmUgaXMgbm8gbmVlZCB0byByZS1hcHBseSBhbmQgbm9cclxuICAgICAgICAgICAgICAgIG5lZWQgdG8gY2hhbmdlIHRoZSBpdGVtIG9ic2VydmFibGUgYmVjYXVzZSBpcyB0aGUgc2FtZVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZCBhbHJlYWR5LCByaWdodD9cclxuICAgICoqL1xyXG4gICAgYXBpLmNyZWF0ZVdpbGRjYXJkSXRlbSA9IGZ1bmN0aW9uIGNyZWF0ZVdpbGRjYXJkSXRlbSgpIHtcclxuICAgICAgICAvLyBVdGlsaXR5IGZvciByZXVzZSBpbiAnc3luYydcclxuICAgICAgICB2YXIgaGFzSUQgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWQgIT09IG51bGwgJiYgdHlwZW9mKGlkKSAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDcmVhdGUgb2JzZXJ2YWJsZSwgd2l0aCBpbml0aWFsIHVuZGVmaW5lZCB2YWx1ZVxyXG4gICAgICAgIHZhciBvYnMgPSBrby5vYnNlcnZhYmxlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBtZXRob2QgJ3N5bmMnXHJcbiAgICAgICAgdmFyIGxhc3RJRDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgICAgU3luYyBtZXRob2QgdG8gbG9hZCBhbiBpdGVtLCBmcm9tIGNhY2hlIEFTQVAgYW5kXHJcbiAgICAgICAgICAgIGZyb20gbG9jYWwgb3IgcmVtb3RlIGlmIHJlcXVpcmVkIGJ5IHRoZSBjYWNoZSBjb250cm9sLlxyXG4gICAgICAgICAgICBJdCByZXR1cm5zIHRoZSBQcm9taXNlIGZvciBmZXRjaGluZyB0aGUgdmFsdWUgKGdldEl0ZW0pXHJcbiAgICAgICAgICAgIHNvIGxvYWQvc3luYyBlbmRpbmcgYW5kIGVycm9yIGNhbiBiZSBjYXRjaGVkLlxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIG9icy5zeW5jID0gZnVuY3Rpb24gc3luY09ic2VydmFibGVJdGVtKGl0ZW1JRCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGlkQ2hhbmdlZCA9IGhhc0lEKGl0ZW1JRCkgJiYgaXRlbUlEICE9PSBsYXN0SUQ7XHJcbiAgICAgICAgICAgIGxhc3RJRCA9IGhhc0lEKGl0ZW1JRCkgPyBpdGVtSUQgOiBsYXN0SUQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBU0FQIEdldCBmcm9tIGNhY2hlIGlmIGFueSBhbmQgcmVxdWVzdGVkIGl0ZW0gY2hhbmdlZFxyXG4gICAgICAgICAgICBpZiAoaWRDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkSXRlbSA9IGNhY2hlLmdldEl0ZW1DYWNoZShsYXN0SUQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEl0ZW0gJiYgY2FjaGVkSXRlbS5pdGVtKVxyXG4gICAgICAgICAgICAgICAgICAgIG9icyhjYWNoZWRJdGVtLml0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHVwZGF0ZWQgdmFsdWVcclxuICAgICAgICAgICAgcmV0dXJuIGFwaS5nZXRJdGVtKGxhc3RJRClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbU1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBvYnMoaXRlbU1vZGVsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtTW9kZWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgIFNldHMgdGhlIG9ic2VydmFibGUgdmFsdWUgdG8gYSBuZXcgaXRlbSBpbnN0YW5jZVxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIG9icy5uZXdJdGVtID0gZnVuY3Rpb24gbmV3SXRlbShkZWZhdWx0cykge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuTW9kZWwpXHJcbiAgICAgICAgICAgICAgICBvYnMobmV3IHNldHRpbmdzLk1vZGVsKGRlZmF1bHRzKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG9icyhkZWZhdWx0cyB8fCB7fSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuXHJcbiAgICAgICAgcmV0dXJuIG9icztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgU2F2ZSBhbiBpdGVtIGluIGNhY2hlLCBsb2NhbCBhbmQgcmVtb3RlLlxyXG4gICAgICAgIENhbiBiZSBuZXcgb3IgdXBkYXRlZC5cclxuICAgICAgICBUaGUgSURzIGdvZXMgd2l0aCBhbGwgdGhlIG90aGVyIGRhdGEsIGJlaW5nXHJcbiAgICAgICAgZ3JvdXBJRCByZXF1aXJlZCwgaXRlbUlEIHJlcXVpcmVkIGZvciB1cGRhdGVzXHJcbiAgICAgICAgYnV0IGZhbHN5IGZvciBpbnNlcnRpb25zLlxyXG4gICAgICAgIEBwYXJhbSBkYXRhOm9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICoqL1xyXG4gICAgYXBpLnNldEl0ZW0gPSBmdW5jdGlvbiBzZXRJdGVtKGRhdGEpIHtcclxuICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcodHJ1ZSk7XHJcbiAgICAgICAgLy8gU2VuZCB0byByZW1vdGUgZmlyc3RcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoTGlzdFRvUmVtb3RlKGRhdGEpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRGF0YSkge1xyXG4gICAgICAgICAgICAvLyBTdWNjZXNzISB1cGRhdGUgbG9jYWwgY29weSB3aXRoIHJldHVybmVkIGRhdGFcclxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiB0byB1c2Ugc2VydmVyIGRhdGEgaGVyZSBzbyB3ZSBnZXQgdmFsdWVzIHNldFxyXG4gICAgICAgICAgICAvLyBieSB0aGUgc2VydmVyLCBhcyB1cGRhdGVzIGRhdGVzIGFuZCBpdGVtSUQgd2hlbiBjcmVhdGluZ1xyXG4gICAgICAgICAgICAvLyBhIG5ldyBpdGVtLlxyXG4gICAgICAgICAgICBpZiAoc2VydmVyRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbiBjYWNoZVxyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0SXRlbUNhY2hlKHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbiBsb2NhbCBzdG9yYWdlXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBsb2NhbCBuZWVkIHRvIGJlIHNhdmVkIGFsbCB0aGUgbGlzdCwgbm90IGp1c3RcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtOyBzaW5jZSB3ZSBoYXZlIHRoZSBjYWNoZSBsaXN0IHVwZGF0ZWQsIHVzZSB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyBmdWxsIGxpc3QgdG8gc2F2ZSBsb2NhbFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoTGlzdFRvTG9jYWwoZ2V0UGxhaW5DYWNoZWRMaXN0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1NhdmluZyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VydmVyRGF0YTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcGkuZGVsSXRlbSA9IGZ1bmN0aW9uIGRlbEl0ZW0oaXRlbUlEKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXBpLnN0YXRlLmlzRGVsZXRpbmcodHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVtb3ZlIGluIHJlbW90ZSBmaXJzdFxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUl0ZW1Gcm9tUmVtb3RlKGl0ZW1JRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbihyZW1vdmVkRGF0YSkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2FjaGVcclxuICAgICAgICAgICAgY2FjaGUuZGVsSXRlbUNhY2hlKGl0ZW1JRCk7XHJcbiAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWwgc3RvcmFnZVxyXG4gICAgICAgICAgICAvLyBJbiBsb2NhbCBuZWVkIHRvIGJlIHNhdmVkIGFsbCB0aGUgbGlzdDtcclxuICAgICAgICAgICAgLy8gc2luY2Ugd2UgaGF2ZSB0aGUgY2FjaGUgbGlzdCB1cGRhdGVkLCB1c2UgdGhhdFxyXG4gICAgICAgICAgICAvLyBmdWxsIGxpc3QgdG8gc2F2ZSBsb2NhbFxyXG4gICAgICAgICAgICB0aGlzLnB1c2hMaXN0VG9Mb2NhbChnZXRQbGFpbkNhY2hlZExpc3QoKSk7XHJcblxyXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZERhdGE7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzRGVsZXRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKiogU29tZSBVdGlscyAqKi9cclxuXHJcbiAgICB2YXIgTW9kZWxWZXJzaW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvTW9kZWxWZXJzaW9uJyk7XHJcbiAgICAvKipcclxuICAgICAgICBJdCBjcmVhdGVzIGEgbmV3IE1vZGVsVmVyc2lvbiBmb3IgdGhlIHJlcXVlc3RlZCBpdGVtIElEXHJcbiAgICAgICAgYWZ0ZXIgbG9hZCB0aGUgaXRlbS5cclxuICAgICAgICBUaGUgcHJvbWlzZSByZXR1cm5zIHRoZSBNb2RlbFZlcnNpb24gcmVhZHksIG9yIG51bGxcclxuICAgICAgICBpZiB0aGUgaXRlbSBkb2VzIG5vdCBleGlzdHMuXHJcbiAgICAqKi9cclxuICAgIGFwaS5jcmVhdGVJdGVtVmVyc2lvbiA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1WZXJzaW9uKGl0ZW1JRCkge1xyXG4gICAgICAgIHJldHVybiBhcGkuZ2V0SXRlbShpdGVtSUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsID8gbmV3IE1vZGVsVmVyc2lvbihtb2RlbCkgOiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBJdCBjcmVhdGVzIGEgbmV3IE1vZGVsIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIGluaXRpYWwgdmFsdWVzLFxyXG4gICAgICAgIHJldHVybmluZyBhIE1vZGVsVmVyc2lvbiBvYmplY3QuXHJcbiAgICAgICAgVGhlIHZlcnNpb25pbmcgYWxsb3dzIHRvIHRyYWNrIHRoZSBpbml0aWFsXHJcbiAgICAgICAgc3RhdGUgKGlmIGNvbWVzIGZyb20gYSBzZXQgb2YgZGVmYXVsdHMgb3IgY2xvbmUpIHdpdGhcclxuICAgICAgICB0aGUgY2hhbmdlcyBkb25lOyB0aGUgaW50ZXJuYWwgdmVyc2lvbiBub3RpZmllcyBpdHNlbGZcclxuICAgICAgICBhcyAndW5zYXZlZCcgZXZlci5cclxuICAgICAgICBJdHMgdXNlZnVsIHRvIGtlZXAgdGhlIHNhbWUgTW9kZWxWZXJzaW9uIGF3YXJlIGNvZGUgZm9yXHJcbiAgICAgICAgZWRpdGlvbnMgYW5kIGFkZGl0aW9ucy5cclxuICAgICoqL1xyXG4gICAgYXBpLm5ld0l0ZW0gPSBmdW5jdGlvbiBuZXdJdGVtKHZhbHVlcykge1xyXG4gICAgICAgIC8vIE5ldyBvcmlnaW5hbCBhbmQgdmVyc2lvbiBmb3IgdGhlIG1vZGVsXHJcbiAgICAgICAgdmFyIHZlcnNpb24gPSBuZXcgTW9kZWxWZXJzaW9uKG5ldyBzZXR0aW5ncy5Nb2RlbCh2YWx1ZXMpKTtcclxuICAgICAgICAvLyBUbyBiZSBzdXJlIHRoYXQgdGhlIHZlcnNpb24gYXBwZWFyIGFzIHNvbWV0aGluZyAnbmV3JywgdW5zYXZlZCxcclxuICAgICAgICAvLyB3ZSB1cGRhdGUgaXRzIHRpbWVzdGFtcCB0byBiZSBkaWZmZXJlbnQgdG8gdGhlIG9yaWdpbmFsLlxyXG4gICAgICAgIHZlcnNpb24udmVyc2lvbi5tb2RlbC50b3VjaCgpO1xyXG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xyXG4gICAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaXN0UmVtb3RlTW9kZWw7XHJcblxyXG5MaXN0UmVtb3RlTW9kZWwucHJvdG90eXBlLmFkZExvY2FsZm9yYWdlU3VwcG9ydCA9IGZ1bmN0aW9uIGFkZExvY2FsZm9yYWdlU3VwcG9ydChiYXNlTmFtZSkge1xyXG4gICAgdmFyIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKTtcclxuXHJcbiAgICB0aGlzLmZldGNoTGlzdEZyb21Mb2NhbCA9IGZ1bmN0aW9uIGZldGNoTGlzdEZyb21Mb2NhbCgpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbShiYXNlTmFtZSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5wdXNoTGlzdFRvTG9jYWwgPSBmdW5jdGlvbiBwdXNoTGlzdFRvTG9jYWwoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5zZXRJdGVtKGJhc2VOYW1lLCBkYXRhKTtcclxuICAgIH07XHJcbn07XHJcblxyXG5MaXN0UmVtb3RlTW9kZWwucHJvdG90eXBlLmFkZFJlc3RTdXBwb3J0ID0gZnVuY3Rpb24gYWRkUmVzdFN1cHBvcnQocmVzdENsaWVudCwgYmFzZVVybCkge1xyXG4gICAgXHJcbiAgICB0aGlzLmZldGNoTGlzdEZyb21SZW1vdGUgPSBmdW5jdGlvbiBmZXRjaExpc3RGcm9tUmVtb3RlKCkge1xyXG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50LmdldChiYXNlVXJsKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnB1c2hMaXN0VG9SZW1vdGUgPSBmdW5jdGlvbiBwdXNoTGlzdFRvUmVtb3RlKGRhdGEpIHtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1JRCA9IGRhdGFbdGhpcy5zZXR0aW5ncy5pdGVtSWRGaWVsZF0sXHJcbiAgICAgICAgICAgIG1ldGhvZCA9IGl0ZW1JRCA/ICdwdXQnIDogJ3Bvc3QnO1xyXG5cclxuICAgICAgICB2YXIgdXJsID0gYmFzZVVybCArIChcclxuICAgICAgICAgICAgaXRlbUlEID8gJy8nICsgaXRlbUlEIDogJydcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50W21ldGhvZF0odXJsLCBkYXRhKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tUmVtb3RlID0gZnVuY3Rpb24gcmVtb3ZlSXRlbUZyb21SZW1vdGUoaXRlbUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3RDbGllbnQuZGVsZXRlKGJhc2VVcmwgKyAnLycgKyBpdGVtSUQpO1xyXG4gICAgfTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBVdGlsaXR5IHRoYXQgYWxsb3dzIHRvIGtlZXAgYW4gb3JpZ2luYWwgbW9kZWwgdW50b3VjaGVkXHJcbiAgICB3aGlsZSBlZGl0aW5nIGEgdmVyc2lvbiwgaGVscGluZyBzeW5jaHJvbml6ZSBib3RoXHJcbiAgICB3aGVuIGRlc2lyZWQgYnkgcHVzaC9wdWxsL3N5bmMtaW5nLlxyXG4gICAgXHJcbiAgICBJdHMgdGhlIHVzdWFsIHdheSB0byB3b3JrIG9uIGZvcm1zLCB3aGVyZSBhbiBpbiBtZW1vcnlcclxuICAgIG1vZGVsIGNhbiBiZSB1c2VkIGJ1dCBpbiBhIGNvcHkgc28gY2hhbmdlcyBkb2Vzbid0IGFmZmVjdHNcclxuICAgIG90aGVyIHVzZXMgb2YgdGhlIGluLW1lbW9yeSBtb2RlbCAoYW5kIGF2b2lkcyByZW1vdGUgc3luY2luZylcclxuICAgIHVudGlsIHRoZSBjb3B5IHdhbnQgdG8gYmUgcGVyc2lzdGVkIGJ5IHB1c2hpbmcgaXQsIG9yIGJlaW5nXHJcbiAgICBkaXNjYXJkZWQgb3IgcmVmcmVzaGVkIHdpdGggYSByZW1vdGVseSB1cGRhdGVkIG9yaWdpbmFsIG1vZGVsLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxuXHJcbmZ1bmN0aW9uIE1vZGVsVmVyc2lvbihvcmlnaW5hbCkge1xyXG4gICAgXHJcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5vcmlnaW5hbCA9IG9yaWdpbmFsO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgdmVyc2lvblxyXG4gICAgLy8gKHVwZGF0ZVdpdGggdGFrZXMgY2FyZSB0byBzZXQgdGhlIHNhbWUgZGF0YVRpbWVzdGFtcClcclxuICAgIHRoaXMudmVyc2lvbiA9IG9yaWdpbmFsLm1vZGVsLmNsb25lKG51bGwsIHRydWUpO1xyXG4gICAgXHJcbiAgICAvLyBDb21wdXRlZCB0aGF0IHRlc3QgZXF1YWxpdHksIGFsbG93aW5nIGJlaW5nIG5vdGlmaWVkIG9mIGNoYW5nZXNcclxuICAgIC8vIEEgcmF0ZUxpbWl0IGlzIHVzZWQgb24gZWFjaCB0byBhdm9pZCBzZXZlcmFsIHN5bmNyaG9ub3VzIG5vdGlmaWNhdGlvbnMuXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIFJldHVybnMgdHJ1ZSB3aGVuIGJvdGggdmVyc2lvbnMgaGFzIHRoZSBzYW1lIHRpbWVzdGFtcFxyXG4gICAgKiovXHJcbiAgICB0aGlzLmFyZURpZmZlcmVudCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiBhcmVEaWZmZXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbC5tb2RlbC5kYXRhVGltZXN0YW1wKCkgIT09IFxyXG4gICAgICAgICAgICB0aGlzLnZlcnNpb24ubW9kZWwuZGF0YVRpbWVzdGFtcCgpXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpLmV4dGVuZCh7IHJhdGVMaW1pdDogMCB9KTtcclxuICAgIC8qKlxyXG4gICAgICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2ZXJzaW9uIGhhcyBuZXdlciBjaGFuZ2VzIHRoYW5cclxuICAgICAgICB0aGUgb3JpZ2luYWxcclxuICAgICoqL1xyXG4gICAgdGhpcy5pc05ld2VyID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uIGlzTmV3ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbC5tb2RlbC5kYXRhVGltZXN0YW1wKCkgPCBcclxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uLm1vZGVsLmRhdGFUaW1lc3RhbXAoKVxyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKS5leHRlbmQoeyByYXRlTGltaXQ6IDAgfSk7XHJcbiAgICAvKipcclxuICAgICAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmVyc2lvbiBoYXMgb2xkZXIgY2hhbmdlcyB0aGFuXHJcbiAgICAgICAgdGhlIG9yaWdpbmFsXHJcbiAgICAqKi9cclxuICAgIHRoaXMuaXNPYnNvbGV0ZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiBpc0NvbXB1dGVkKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWwubW9kZWwuZGF0YVRpbWVzdGFtcCgpID4gXHJcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5tb2RlbC5kYXRhVGltZXN0YW1wKClcclxuICAgICAgICApO1xyXG4gICAgfSwgdGhpcykuZXh0ZW5kKHsgcmF0ZUxpbWl0OiAwIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsVmVyc2lvbjtcclxuXHJcbk1vZGVsVmVyc2lvbi5faW5oZXJpdHMoRXZlbnRFbWl0dGVyKTtcclxuXHJcbi8qKlxyXG4gICAgU2VuZHMgdGhlIHZlcnNpb24gY2hhbmdlcyB0byB0aGUgb3JpZ2luYWxcclxuICAgIFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAgIGV2ZW5JZk5ld2VyOiBmYWxzZVxyXG4gICAgfVxyXG4qKi9cclxuTW9kZWxWZXJzaW9uLnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24gcHVsbChvcHRpb25zKSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIC8vIEJ5IGRlZmF1bHQsIG5vdGhpbmcgdG8gZG8sIG9yIGF2b2lkIG92ZXJ3cml0ZSBjaGFuZ2VzLlxyXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlLFxyXG4gICAgICAgIHJvbGxiYWNrID0gbnVsbDtcclxuICAgIFxyXG4gICAgaWYgKG9wdGlvbnMuZXZlbklmTmV3ZXIgfHwgIXRoaXMuaXNOZXdlcigpKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCB0aGUgb3JpZ2luYWwgZGF0YSxcclxuICAgICAgICAvLyBjcmVhdGluZyBmaXJzdCBhIHJvbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICAgIHJvbGxiYWNrID0gY3JlYXRlUm9sbGJhY2tGdW5jdGlvbih0aGlzLnZlcnNpb24pO1xyXG4gICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIG9ubHkgcHJvcGVydGllcyBhbmQgZmllbGRzIGZyb20gbW9kZWxzXHJcbiAgICAgICAgLy8gYXJlIGNvcGllZCBhbmQgdGhhdCBtdXN0IGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBUaGUgbWV0aG9kIHVwZGF0ZVdpdGggdGFrZXMgY2FyZSB0byBzZXQgdGhlIHNhbWUgZGF0YVRpbWVzdGFtcDogICAgICAgIFxyXG4gICAgICAgIHRoaXMudmVyc2lvbi5tb2RlbC51cGRhdGVXaXRoKHRoaXMub3JpZ2luYWwsIHRydWUpO1xyXG4gICAgICAgIC8vIERvbmVcclxuICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZW1pdCgncHVsbCcsIHJlc3VsdCwgcm9sbGJhY2spO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgRGlzY2FyZCB0aGUgdmVyc2lvbiBjaGFuZ2VzIGdldHRpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICBkYXRhLlxyXG4gICAgXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgZXZlbklmT2Jzb2xldGU6IGZhbHNlXHJcbiAgICB9XHJcbioqL1xyXG5Nb2RlbFZlcnNpb24ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKG9wdGlvbnMpIHtcclxuICAgIFxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIC8vIEJ5IGRlZmF1bHQsIG5vdGhpbmcgdG8gZG8sIG9yIGF2b2lkIG92ZXJ3cml0ZSBjaGFuZ2VzLlxyXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlLFxyXG4gICAgICAgIHJvbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5ldmVuSWZPYnNvbGV0ZSB8fCAhdGhpcy5pc09ic29sZXRlKCkpIHtcclxuICAgICAgICAvLyBVcGRhdGUgb3JpZ2luYWwsIGNyZWF0aW5nIGZpcnN0IGEgcm9sbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgcm9sbGJhY2sgPSBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKHRoaXMub3JpZ2luYWwpO1xyXG4gICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIG9ubHkgcHJvcGVydGllcyBhbmQgZmllbGRzIGZyb20gbW9kZWxzXHJcbiAgICAgICAgLy8gYXJlIGNvcGllZCBhbmQgdGhhdCBtdXN0IGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBUaGUgbWV0aG9kIHVwZGF0ZVdpdGggdGFrZXMgY2FyZSB0byBzZXQgdGhlIHNhbWUgZGF0YVRpbWVzdGFtcC5cclxuICAgICAgICB0aGlzLm9yaWdpbmFsLm1vZGVsLnVwZGF0ZVdpdGgodGhpcy52ZXJzaW9uLCB0cnVlKTtcclxuICAgICAgICAvLyBEb25lXHJcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmVtaXQoJ3B1c2gnLCByZXN1bHQsIHJvbGxiYWNrKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFNldHMgb3JpZ2luYWwgYW5kIHZlcnNpb24gb24gdGhlIHNhbWUgdmVyc2lvblxyXG4gICAgYnkgZ2V0dGluZyB0aGUgbmV3ZXN0IG9uZS5cclxuKiovXHJcbk1vZGVsVmVyc2lvbi5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLmlzTmV3ZXIoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKCk7XHJcbiAgICBlbHNlIGlmICh0aGlzLmlzT2Jzb2xldGUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5wdWxsKCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBVdGlsaXR5IHRoYXQgY3JlYXRlIGEgZnVuY3Rpb24gYWJsZSB0byBcclxuICAgIHBlcmZvcm0gYSBkYXRhIHJvbGxiYWNrIG9uIGV4ZWN1dGlvbiwgdXNlZnVsXHJcbiAgICB0byBwYXNzIG9uIHRoZSBldmVudHMgdG8gYWxsb3cgcmVhY3QgdXBvbiBjaGFuZ2VzXHJcbiAgICBvciBleHRlcm5hbCBzeW5jaHJvbml6YXRpb24gZmFpbHVyZXMuXHJcbioqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKG1vZGVsSW5zdGFuY2UpIHtcclxuICAgIC8vIFByZXZpb3VzIGZ1bmN0aW9uIGNyZWF0aW9uLCBnZXQgTk9XIHRoZSBpbmZvcm1hdGlvbiB0b1xyXG4gICAgLy8gYmUgYmFja2VkIGZvciBsYXRlci5cclxuICAgIHZhciBiYWNrZWREYXRhID0gbW9kZWxJbnN0YW5jZS5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpLFxyXG4gICAgICAgIGJhY2tlZFRpbWVzdGFtcCA9IG1vZGVsSW5zdGFuY2UubW9kZWwuZGF0YVRpbWVzdGFtcCgpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgZnVuY3Rpb24gdGhhdCAqbWF5KiBnZXQgZXhlY3V0ZWQgbGF0ZXIsIGFmdGVyXHJcbiAgICAvLyBjaGFuZ2VzIHdlcmUgZG9uZSBpbiB0aGUgbW9kZWxJbnN0YW5jZS5cclxuICAgIHJldHVybiBmdW5jdGlvbiByb2xsYmFjaygpIHtcclxuICAgICAgICAvLyBTZXQgdGhlIGJhY2tlZCBkYXRhXHJcbiAgICAgICAgbW9kZWxJbnN0YW5jZS5tb2RlbC51cGRhdGVXaXRoKGJhY2tlZERhdGEsIHRydWUpO1xyXG4gICAgICAgIC8vIEFuZCB0aGUgdGltZXN0YW1wXHJcbiAgICAgICAgbW9kZWxJbnN0YW5jZS5tb2RlbC5kYXRhVGltZXN0YW1wKGJhY2tlZFRpbWVzdGFtcCk7XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qKlxyXG4gICAgUmVtb3RlTW9kZWwgY2xhc3MuXHJcbiAgICBcclxuICAgIEl0IGhlbHBzIG1hbmFnaW5nIGEgbW9kZWwgaW5zdGFuY2UsIG1vZGVsIHZlcnNpb25zXHJcbiAgICBmb3IgaW4gbWVtb3J5IG1vZGlmaWNhdGlvbiwgYW5kIHRoZSBwcm9jZXNzIHRvIFxyXG4gICAgcmVjZWl2ZSBvciBzZW5kIHRoZSBtb2RlbCBkYXRhXHJcbiAgICB0byBhIHJlbW90ZSBzb3VyY2VzLCB3aXRoIGdsdWUgY29kZSBmb3IgdGhlIHRhc2tzXHJcbiAgICBhbmQgc3RhdGUgcHJvcGVydGllcy5cclxuICAgIFxyXG4gICAgRXZlcnkgaW5zdGFuY2Ugb3Igc3ViY2xhc3MgbXVzdCBpbXBsZW1lbnRcclxuICAgIHRoZSBmZXRjaCBhbmQgcHVsbCBtZXRob2RzIHRoYXQga25vd3MgdGhlIHNwZWNpZmljc1xyXG4gICAgb2YgdGhlIHJlbW90ZXMuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWxWZXJzaW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvTW9kZWxWZXJzaW9uJyksXHJcbiAgICBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuLi91dGlscy9DYWNoZUNvbnRyb2wnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxuXHJcbmZ1bmN0aW9uIFJlbW90ZU1vZGVsKG9wdGlvbnMpIHtcclxuXHJcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICAgIFxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIHZhciBmaXJzdFRpbWVMb2FkID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgLy8gTWFya3MgYSBsb2NrIGxvYWRpbmcgaXMgaGFwcGVuaW5nLCBhbnkgdXNlciBjb2RlXHJcbiAgICAvLyBtdXN0IHdhaXQgZm9yIGl0XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgLy8gTWFya3MgYSBsb2NrIHNhdmluZyBpcyBoYXBwZW5pbmcsIGFueSB1c2VyIGNvZGVcclxuICAgIC8vIG11c3Qgd2FpdCBmb3IgaXRcclxuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIC8vIE1hcmtzIGEgYmFja2dyb3VuZCBzeW5jaHJvbml6YXRpb246IGxvYWQgb3Igc2F2ZSxcclxuICAgIC8vIHVzZXIgY29kZSBrbm93cyBpcyBoYXBwZW5pbmcgYnV0IGNhbiBjb250aW51ZVxyXG4gICAgLy8gdXNpbmcgY2FjaGVkIGRhdGFcclxuICAgIHRoaXMuaXNTeW5jaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICAvLyBVdGlsaXR5IHRvIGtub3cgd2hldGhlciBhbnkgbG9ja2luZyBvcGVyYXRpb24gaXNcclxuICAgIC8vIGhhcHBlbmluZy5cclxuICAgIC8vIEp1c3QgbG9hZGluZyBvciBzYXZpbmdcclxuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xvYWRpbmcoKSB8fCB0aGlzLmlzU2F2aW5nKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgaWYgKCFvcHRpb25zLmRhdGEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGVNb2RlbCBkYXRhIG11c3QgYmUgc2V0IG9uIGNvbnN0cnVjdG9yIGFuZCBubyBjaGFuZ2VkIGxhdGVyJyk7XHJcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICBcclxuICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGVDb250cm9sKHtcclxuICAgICAgICB0dGw6IG9wdGlvbnMudHRsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICB0aGlzLmNhY2hlLmxhdGVzdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhLm1vZGVsLnJlc2V0KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBPcHRpb25hbCBuYW1lIHVzZWQgdG8gcGVyc2lzdCBhIGNvcHkgb2YgdGhlIGRhdGEgYXMgcGxhaW4gb2JqZWN0XHJcbiAgICAvLyBpbiB0aGUgbG9jYWwgc3RvcmFnZSBvbiBldmVyeSBzdWNjZXNzZnVsbHkgbG9hZC9zYXZlIG9wZXJhdGlvbi5cclxuICAgIC8vIFdpdGggbm8gbmFtZSwgbm8gc2F2ZWQgKGRlZmF1bHQpLlxyXG4gICAgLy8gSXQgdXNlcyAnbG9jYWxmb3JhZ2UnLCBzbyBtYXkgYmUgbm90IHNhdmVkIHVzaW5nIGxvY2FsU3RvcmFnZSBhY3R1YWxseSxcclxuICAgIC8vIGJ1dCBhbnkgc3VwcG9ydGVkIGFuZCBpbml0aWFsaXplZCBzdG9yYWdlIHN5c3RlbSwgbGlrZSBXZWJTUUwsIEluZGV4ZWREQiBvciBMb2NhbFN0b3JhZ2UuXHJcbiAgICAvLyBsb2NhbGZvcmFnZSBtdXN0IGhhdmUgYSBzZXQtdXAgcHJldmlvdXMgdXNlIG9mIHRoaXMgb3B0aW9uLlxyXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2VOYW1lID0gb3B0aW9ucy5sb2NhbFN0b3JhZ2VOYW1lIHx8IG51bGw7XHJcbiAgICBcclxuICAgIC8vIFJlY29tbWVuZGVkIHdheSB0byBnZXQgdGhlIGluc3RhbmNlIGRhdGFcclxuICAgIC8vIHNpbmNlIGl0IGVuc3VyZXMgdG8gbGF1bmNoIGEgbG9hZCBvZiB0aGVcclxuICAgIC8vIGRhdGEgZWFjaCB0aW1lIGlzIGFjY2Vzc2VkIHRoaXMgd2F5LlxyXG4gICAgdGhpcy5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YSgpIHtcclxuICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm5ld1ZlcnNpb24gPSBmdW5jdGlvbiBuZXdWZXJzaW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gbmV3IE1vZGVsVmVyc2lvbih0aGlzLmRhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmVyc2lvbiBkYXRhIHdpdGggdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgLy8gYWZ0ZXIgYSBsb2NrIGxvYWQgZmluaXNoLCBsaWtlIHRoZSBmaXJzdCB0aW1lLFxyXG4gICAgICAgIC8vIHNpbmNlIHRoZSBVSSB0byBlZGl0IHRoZSB2ZXJzaW9uIHdpbGwgYmUgbG9ja1xyXG4gICAgICAgIC8vIGluIHRoZSBtaWRkbGUuXHJcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcuc3Vic2NyaWJlKGZ1bmN0aW9uIChpc0l0KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNJdCkge1xyXG4gICAgICAgICAgICAgICAgdi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTYXZlIHRoZSByZW1vdGUgd2hlbiBzdWNjZXNzZnVsbHkgcHVzaGVkIHRoZSBuZXcgdmVyc2lvblxyXG4gICAgICAgIHYub24oJ3B1c2gnLCBmdW5jdGlvbihzdWNjZXNzLCByb2xsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdmVyc2lvbiBkYXRhIHdpdGggdGhlIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSByZW1vdGUsIHRoYXQgbWF5IGluY2x1ZGUgcmVtb3RlIGNvbXB1dGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzOlxyXG4gICAgICAgICAgICAgICAgICAgIHYucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBjYXRjaCB0aGUgZXJyb3IgaXMgaW1wb3J0YW50IFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkICd1bmtub3cgZXJyb3IncyBmcm9tIGJlaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VkIG9uIHRoZSBjb25zb2xlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlcnJvciBjYW4gYmUgcmVhZCBieSBsaXN0ZW5pbmcgdGhlICdlcnJvcicgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybXMgYSByb2xsYmFjayBvZiB0aGUgb3JpZ2luYWwgbW9kZWxcclxuICAgICAgICAgICAgICAgICAgICByb2xsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2ZXJzaW9uIGRhdGEga2VlcHMgdW50b3VjaGVkLCB1c2VyIG1heSB3YW50IHRvIHJldHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgbWFkZSBjaGFuZ2VzIG9uIGl0cyB1bi1zYXZlZCBkYXRhLlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZmV0Y2ggPSBvcHRpb25zLmZldGNoIHx8IGZ1bmN0aW9uIGZldGNoKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpOyB9O1xyXG4gICAgdGhpcy5wdXNoID0gb3B0aW9ucy5wdXNoIHx8IGZ1bmN0aW9uIHB1c2goKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGQnKTsgfTtcclxuXHJcbiAgICB2YXIgbG9hZEZyb21SZW1vdGUgPSBmdW5jdGlvbiBsb2FkRnJvbVJlbW90ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCgpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIHBsYWluIGRhdGEgZnJvbSB0aGUgc2VydmVyIChhbmQgYW55XHJcbiAgICAgICAgICAgICAgICAvLyBpbiBiZXR3ZWVuIGNvbnZlcnNpb24gb24gJ2ZlY3RoJykgY2Fubm90IGhhdmUgY2lyY3VsYXJcclxuICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZXM6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwZXJzaXN0ZW50IGxvY2FsIGNvcHk/XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2NhbFN0b3JhZ2VOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSh0aGlzLmxvY2FsU3RvcmFnZU5hbWUsIHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGUgbW9kZWwgZGlkIG5vdCByZXR1cm5lZCBkYXRhLCByZXNwb25zZSBtdXN0IGJlIGEgXCJOb3QgRm91bmRcIicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFdmVudFxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsb2FkZWQnLCBzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3luY2VkJywgc2VydmVyRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHk6IGNvbW1vbiB0YXNrcyBvbiBzdWNjZXNzIG9yIGVycm9yXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jYWNoZS5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2FzTG9hZCA9IHRoaXMuaXNMb2FkaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5hbGx5OiBjb21tb24gdGFza3Mgb24gc3VjY2VzcyBvciBlcnJvclxyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV2ZW50XHJcbiAgICAgICAgICAgIHZhciBlcnJQa2cgPSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrOiB3YXNMb2FkID8gJ2xvYWQnIDogJ3N5bmMnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBCZSBjYXJlZnVsIHdpdGggJ2Vycm9yJyBldmVudCwgaXMgc3BlY2lhbCBhbmQgc3RvcHMgZXhlY3V0aW9uIG9uIGVtaXRcclxuICAgICAgICAgICAgLy8gaWYgbm8gbGlzdGVuZXJzIGF0dGFjaGVkOiBvdmVyd3JpdHRpbmcgdGhhdCBiZWhhdmlvciBieSBqdXN0XHJcbiAgICAgICAgICAgIC8vIHByaW50IG9uIGNvbnNvbGUgd2hlbiBub3RoaW5nLCBvciBlbWl0IGlmIHNvbWUgbGlzdGVuZXI6XHJcbiAgICAgICAgICAgIGlmIChFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJQa2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9nIGl0IHdoZW4gbm90IGhhbmRsZWQgKGV2ZW4gaWYgdGhlIHByb21pc2UgZXJyb3IgaXMgaGFuZGxlZClcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbW90ZU1vZGVsIEVycm9yJywgZXJyUGtnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZUxvYWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyh0cnVlKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBsb2NhbCBzdG9yYWdlIGlzIHNldCBmb3IgdGhpcywgbG9hZCBmaXJzdFxyXG4gICAgICAgICAgICAvLyBmcm9tIGxvY2FsLCB0aGVuIGZvbGxvdyB3aXRoIHN5bmNpbmcgZnJvbSByZW1vdGVcclxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZUxvYWQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxTdG9yYWdlTmFtZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBsb2NhbGZvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxTdG9yYWdlTmFtZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGxvY2FsRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLm1vZGVsLnVwZGF0ZVdpdGgobG9jYWxEYXRhLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgZG9uZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2NhbCBsb2FkIGRvbmUsIGRvIGEgYmFja2dyb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdGUgbG9hZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEZyb21SZW1vdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXRjaCBhbnkgcHJvbWlzZS1lcnJvciBvbiB0aGUgcmVtb3RlLCB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmV4cGVjdGVkIGVycm9ycyBiZWluZyB1bmNhdGNoLCB0aGV5IHN0aWxsIGNhbiBiZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXRjaCB1c2luZyB0aGUgJ2Vycm9yJyBldmVudCBvbiB0aGUgUmVtb3RlTW9kZWwgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZG9uJ3Qgd2FpdCwgcmV0dXJuIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBubyBkYXRhLCBwZXJmb3JtIGEgcmVtb3RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvYWQgYW5kIHdhaXQgZm9yIGl0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZEZyb21SZW1vdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgcmVtb3RlIGxvYWQ6XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbG9hZEZyb21SZW1vdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSwgYmxvY2tpbmcgbG9hZDpcclxuICAgICAgICAgICAgLy8gaXQgcmV0dXJucyB3aGVuIHRoZSBsb2FkIHJldHVybnNcclxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZUxvYWQpIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0VGltZUxvYWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIHByb21pc2UgYW5kIHdpbGwgd2FpdCBmb3IgdGhlIGZpcnN0IGxvYWQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEJhY2tncm91bmQgbG9hZDogaXMgbG9hZGluZyBzdGlsbFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgY2FjaGVkIGRhdGEgc28gd2UgdXNlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGZvciBub3cuXHJcbiAgICAgICAgICAgICAgICAvLyBDYXRjaCBhbnkgcHJvbWlzZS1lcnJvciBvbiB0aGUgcmVtb3RlLCB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBlcnJvcnMgYmVpbmcgdW5jYXRjaCwgdGhleSBzdGlsbCBjYW4gYmVcclxuICAgICAgICAgICAgICAgIC8vIGNhdGNoIHVzaW5nIHRoZSAnZXJyb3InIGV2ZW50IG9uIHRoZSBSZW1vdGVNb2RlbCBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24oKSB7IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYW55dGhpbmcgbmV3IGZyb20gb3V0c2lkZVxyXG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbnMgd2lsbCBnZXQgbm90aWZpZWQgd2l0aCBpc09ic29sZXRlKClcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBkYXRhLCBubyBuZWVkIHRvIGxvYWQgYWdhaW4gZm9yIG5vdy5cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLmlzU2F2aW5nKHRydWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFByZXNlcnZlIHRoZSB0aW1lc3RhbXAgYWZ0ZXIgYmVpbmcgc2F2ZWRcclxuICAgICAgICAvLyB0byBhdm9pZCBmYWxzZSAnb2Jzb2xldGUnIHdhcm5pbmdzIHdpdGhcclxuICAgICAgICAvLyB0aGUgdmVyc2lvbiB0aGF0IGNyZWF0ZWQgdGhlIG5ldyBvcmlnaW5hbFxyXG4gICAgICAgIHZhciB0cyA9IHRoaXMuZGF0YS5tb2RlbC5kYXRhVGltZXN0YW1wKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJ2ZXJEYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIHBsYWluIGRhdGEgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIGNhbm5vdCBoYXZlIGNpcmN1bGFyIHJlZmVyZW5jZXM6XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5tb2RlbC51cGRhdGVXaXRoKHNlcnZlckRhdGEsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEubW9kZWwuZGF0YVRpbWVzdGFtcCh0cyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBwZXJzaXN0ZW50IGxvY2FsIGNvcHk/XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsU3RvcmFnZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0odGhpcy5sb2NhbFN0b3JhZ2VOYW1lLCBzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRXZlbnRcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdzYXZlZCcsIHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRmluYWxseTogY29tbW9uIHRhc2tzIG9uIHN1Y2Nlc3Mgb3IgZXJyb3JcclxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlLmxhdGVzdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgLy8gRmluYWxseTogY29tbW9uIHRhc2tzIG9uIHN1Y2Nlc3Mgb3IgZXJyb3JcclxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBFdmVudFxyXG4gICAgICAgICAgICB2YXIgZXJyUGtnID0ge1xyXG4gICAgICAgICAgICAgICAgdGFzazogJ3NhdmUnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBCZSBjYXJlZnVsIHdpdGggJ2Vycm9yJyBldmVudCwgaXMgc3BlY2lhbCBhbmQgc3RvcHMgZXhlY3V0aW9uIG9uIGVtaXRcclxuICAgICAgICAgICAgLy8gaWYgbm8gbGlzdGVuZXJzIGF0dGFjaGVkOiBvdmVyd3JpdHRpbmcgdGhhdCBiZWhhdmlvciBieSBqdXN0XHJcbiAgICAgICAgICAgIC8vIHByaW50IG9uIGNvbnNvbGUgd2hlbiBub3RoaW5nLCBvciBlbWl0IGlmIHNvbWUgbGlzdGVuZXI6XHJcbiAgICAgICAgICAgIGlmIChFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJQa2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9nIGl0IHdoZW4gbm90IGhhbmRsZWQgKGV2ZW4gaWYgdGhlIHByb21pc2UgZXJyb3IgaXMgaGFuZGxlZClcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbW90ZU1vZGVsIEVycm9yJywgZXJyUGtnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBMYXVuY2ggYSBzeW5jaW5nIHJlcXVlc3QuIFJldHVybnMgbm90aGluZywgdGhlXHJcbiAgICAgICAgd2F5IHRvIHRyYWNrIGFueSByZXN1bHQgaXMgd2l0aCBldmVudHMgb3IgXHJcbiAgICAgICAgdGhlIGluc3RhbmNlIG9ic2VydmFibGVzLlxyXG4gICAgICAgIElNUE9SVEFOVDogcmlnaHQgbm93IGlzIGp1c3QgYSByZXF1ZXN0IGZvciAnbG9hZCdcclxuICAgICAgICB0aGF0IGF2b2lkcyBwcm9taXNlIGVycm9ycyBmcm9tIHRocm93aW5nLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xyXG4gICAgICAgIC8vIENhbGwgZm9yIGEgbG9hZCwgdGhhdCB3aWxsIGJlIHRyZWF0ZWQgYXMgJ3N5bmNpbmcnIGFmdGVyIHRoZVxyXG4gICAgICAgIC8vIGZpcnN0IGxvYWRcclxuICAgICAgICB0aGlzLmxvYWQoKVxyXG4gICAgICAgIC8vIEF2b2lkIGVycm9ycyBmcm9tIHRocm93aW5nIGluIHRoZSBjb25zb2xlLFxyXG4gICAgICAgIC8vIHRoZSAnZXJyb3InIGV2ZW50IGlzIHRoZXJlIHRvIHRyYWNrIGFueW9uZS5cclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZU1vZGVsO1xyXG5cclxuUmVtb3RlTW9kZWwuX2luaGVyaXRzKEV2ZW50RW1pdHRlcik7XHJcbiIsIi8qKlxyXG4gICAgUkVTVCBBUEkgYWNjZXNzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG5mdW5jdGlvbiBsb3dlckZpcnN0TGV0dGVyKG4pIHtcclxuICAgIHJldHVybiBuICYmIG5bMF0gJiYgblswXS50b0xvd2VyQ2FzZSAmJiAoblswXS50b0xvd2VyQ2FzZSgpICsgbi5zbGljZSgxKSkgfHwgbjtcclxufVxyXG5cclxuZnVuY3Rpb24gbG93ZXJDYW1lbGl6ZU9iamVjdChvYmopIHtcclxuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6OFxyXG4gICAgXHJcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcpIHJldHVybiBvYmo7XHJcblxyXG4gICAgdmFyIHJldCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XHJcbiAgICBmb3IodmFyIGsgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3ayA9IGxvd2VyRmlyc3RMZXR0ZXIoayk7XHJcbiAgICAgICAgICAgIHJldFtuZXdrXSA9IHR5cGVvZihvYmpba10pID09PSAnb2JqZWN0JyA/XHJcbiAgICAgICAgICAgICAgICBsb3dlckNhbWVsaXplT2JqZWN0KG9ialtrXSkgOlxyXG4gICAgICAgICAgICAgICAgb2JqW2tdXHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZXN0KG9wdGlvbnNPclVybCkge1xyXG4gICAgXHJcbiAgICB2YXIgdXJsID0gdHlwZW9mKG9wdGlvbnNPclVybCkgPT09ICdzdHJpbmcnID9cclxuICAgICAgICBvcHRpb25zT3JVcmwgOlxyXG4gICAgICAgIG9wdGlvbnNPclVybCAmJiBvcHRpb25zT3JVcmwudXJsO1xyXG5cclxuICAgIHRoaXMuYmFzZVVybCA9IHVybDtcclxuICAgIC8vIE9wdGlvbmFsIGV4dHJhSGVhZGVycyBmb3IgYWxsIHJlcXVlc3RzLFxyXG4gICAgLy8gdXN1YWxseSBmb3IgYXV0aGVudGljYXRpb24gdG9rZW5zXHJcbiAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG51bGw7XHJcbn1cclxuXHJcblJlc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChhcGlVcmwsIGRhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXBpVXJsLCAnZ2V0JywgZGF0YSk7XHJcbn07XHJcblxyXG5SZXN0LnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBnZXQoYXBpVXJsLCBkYXRhKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFwaVVybCwgJ3B1dCcsIGRhdGEpO1xyXG59O1xyXG5cclxuUmVzdC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIGdldChhcGlVcmwsIGRhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXBpVXJsLCAncG9zdCcsIGRhdGEpO1xyXG59O1xyXG5cclxuUmVzdC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gZ2V0KGFwaVVybCwgZGF0YSkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcGlVcmwsICdkZWxldGUnLCBkYXRhKTtcclxufTtcclxuXHJcblJlc3QucHJvdG90eXBlLnB1dEZpbGUgPSBmdW5jdGlvbiBwdXRGaWxlKGFwaVVybCwgZGF0YSkge1xyXG4gICAgLy8gTk9URSBiYXNpYyBwdXRGaWxlIGltcGxlbWVudGF0aW9uLCBvbmUgZmlsZSwgdXNlIGZpbGVVcGxvYWQ/XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFwaVVybCwgJ2RlbGV0ZScsIGRhdGEsICdtdWx0aXBhcnQvZm9ybS1kYXRhJyk7XHJcbn07XHJcblxyXG5SZXN0LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChhcGlVcmwsIGh0dHBNZXRob2QsIGRhdGEsIGNvbnRlbnRUeXBlKSB7XHJcbiAgICBcclxuICAgIHZhciB0aGlzUmVzdCA9IHRoaXM7XHJcbiAgICB2YXIgdXJsID0gdGhpcy5iYXNlVXJsICsgYXBpVXJsO1xyXG5cclxuICAgIC8vIFVzaW5nIGEgcHJvbWlzZSB0byBhdm9pZCB0aGUgZGlmZmVyZW5jZXMgYW5kIHByb2JsZW1zIG9mIHRoZSBqUXVlcnkgdGhlbmFibGVcclxuICAgIC8vIG9iamVjdCwgYnV0IGF0dGFjaGluZyBpdHMgb3JpZ2luYWwgdmFsdWUgYXMgYSBuZXcgcHJvcGVydHkgJ3hocicgb2YgdGhlIHByb21pc2VcclxuICAgIC8vIGNyZWF0ZWQgZm9yIGFkdmFuY2VkIHVzZS5cclxuICAgIHZhciB4aHIgPSAkLmFqYXgoe1xyXG4gICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIC8vIEF2b2lkIGNhY2hlIGZvciBkYXRhLlxyXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcclxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIG1ldGhvZDogaHR0cE1ldGhvZCxcclxuICAgICAgICBoZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVycyxcclxuICAgICAgICAvLyBVUkxFTkNPREVEIGlucHV0OlxyXG4gICAgICAgIC8vIENvbnZlcnQgdG8gSlNPTiBhbmQgYmFjayBqdXN0IHRvIGVuc3VyZSB0aGUgdmFsdWVzIGFyZSBjb252ZXJ0ZWQvZW5jb2RlZFxyXG4gICAgICAgIC8vIHByb3Blcmx5IHRvIGJlIHNlbnQsIGxpa2UgRGF0ZXMgYmVpbmcgY29udmVydGVkIHRvIElTTyBmb3JtYXQuXHJcbiAgICAgICAgZGF0YTogZGF0YSAmJiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSxcclxuICAgICAgICBjb250ZW50VHlwZTogY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcclxuICAgICAgICAvLyBBbHRlcm5hdGU6IEpTT04gYXMgaW5wdXRcclxuICAgICAgICAvL2RhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgICAgIC8vY29udGVudFR5cGU6IGNvbnRlbnRUeXBlIHx8ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHByb21pc2VYaHIgPSBQcm9taXNlLnJlc29sdmUoeGhyKVxyXG4gICAgLnRoZW4obG93ZXJDYW1lbGl6ZU9iamVjdClcclxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAvLyBPbiBhdXRob3JpemF0aW9uIGVycm9yLCBnaXZlIG9wb3J0dW5pdHkgdG8gcmV0cnkgdGhlIG9wZXJhdGlvblxyXG4gICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgICAgICAgdmFyIHJldHJ5ID0gcmVxdWVzdC5iaW5kKHRoaXMsIGFwaVVybCwgaHR0cE1ldGhvZCwgZGF0YSwgY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgcmV0cnlQcm9taXNlID0gdGhpc1Jlc3Qub25BdXRob3JpemF0aW9uUmVxdWlyZWQocmV0cnkpO1xyXG4gICAgICAgICAgICBpZiAocmV0cnlQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdCByZXR1cm5lZCBzb21ldGhpbmcsIGV4cGVjdGluZyBpcyBhIHByb21pc2U6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldHJ5UHJvbWlzZSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGVycm9yIG9uIHJldHJ5LCBqdXN0IHJldHVybiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBjYWxsIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIGNvbnRpbnVlIHByb3BhZ2F0aW5nIHRoZSBlcnJvclxyXG4gICAgICAgIHJldHVybiBlcnI7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcHJvbWlzZVhoci54aHIgPSB4aHI7XHJcbiAgICByZXR1cm4gcHJvbWlzZVhocjtcclxufTtcclxuXHJcblJlc3QucHJvdG90eXBlLm9uQXV0aG9yaXphdGlvblJlcXVpcmVkID0gZnVuY3Rpb24gb25BdXRob3JpemF0aW9uUmVxdWlyZWQoLypyZXRyeSovKSB7XHJcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBvdXRzaWRlLCBpZiBjb252ZW5pZW50IGV4ZWN1dGluZzpcclxuICAgIC8vcmV0cnkoKTtcclxuICAgIC8vIGJ5IGRlZmF1bHQgZG9uJ3Qgd2FpdCBmb3IgcmV0cnksIGp1c3QgcmV0dXJuIG5vdGhpbmc6XHJcbiAgICByZXR1cm47XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3Q7XHJcbiIsIi8qKlxyXG4gICAgVGltZSBjbGFzcyB1dGlsaXR5LlxyXG4gICAgU2hvcnRlciB3YXkgdG8gY3JlYXRlIGEgRGF0ZSBpbnN0YW5jZVxyXG4gICAgc3BlY2lmeWluZyBvbmx5IHRoZSBUaW1lIHBhcnQsXHJcbiAgICBkZWZhdWx0aW5nIHRvIGN1cnJlbnQgZGF0ZSBvciBcclxuICAgIGFub3RoZXIgcmVhZHkgZGF0ZSBpbnN0YW5jZS5cclxuKiovXHJcbmZ1bmN0aW9uIFRpbWUoZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQpIHtcclxuICAgIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gXHJcbiAgICAgICAgc2Vjb25kID0gbWludXRlO1xyXG4gICAgICAgIG1pbnV0ZSA9IGhvdXI7XHJcbiAgICAgICAgaG91ciA9IGRhdGU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7ICAgXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgaG91ciB8fCAwLCBtaW51dGUgfHwgMCwgc2Vjb25kIHx8IDApO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gVGltZTtcclxuIiwiLyoqXHJcbiAgICBDcmVhdGUgYW4gQWNjZXNzIENvbnRyb2wgZm9yIGFuIGFwcCB0aGF0IGp1c3QgY2hlY2tzXHJcbiAgICB0aGUgYWN0aXZpdHkgcHJvcGVydHkgZm9yIGFsbG93ZWQgdXNlciBsZXZlbC5cclxuICAgIFRvIGJlIHByb3ZpZGVkIHRvIFNoZWxsLmpzIGFuZCB1c2VkIGJ5IHRoZSBhcHAuanMsXHJcbiAgICB2ZXJ5IHRpZWQgdG8gdGhhdCBib3RoIGNsYXNzZXMuXHJcbiAgICBcclxuICAgIEFjdGl2aXRpZXMgY2FuIGRlZmluZSBvbiBpdHMgb2JqZWN0IGFuIGFjY2Vzc0xldmVsXHJcbiAgICBwcm9wZXJ0eSBsaWtlIG5leHQgZXhhbXBsZXNcclxuICAgIFxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IGFwcC5Vc2VydHlwZS5Vc2VyOyAvLyBhbnlvbmVcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSBhcHAuVXNlclR5cGUuQW5vbnltb3VzOyAvLyBhbm9ueW1vdXMgdXNlcnMgb25seVxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IGFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyOyAvLyBhdXRoZW50aWNhdGVkIHVzZXJzIG9ubHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFVzZXJUeXBlIGVudW1lcmF0aW9uIGlzIGJpdCBiYXNlZCwgc28gc2V2ZXJhbFxyXG4vLyB1c2VycyBjYW4gaGFzIGFjY2VzcyBpbiBhIHNpbmdsZSBwcm9wZXJ0eVxyXG4vL3ZhciBVc2VyVHlwZSA9IHJlcXVpcmUoJy4uL21vZGVscy9Vc2VyJykuVXNlclR5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc0NvbnRyb2woYXBwKSB7XHJcbiAgICBcclxuICAgIHJldHVybiBmdW5jdGlvbiBhY2Nlc3NDb250cm9sKHJvdXRlKSB7XHJcblxyXG4gICAgICAgIHZhciBhY3Rpdml0eSA9IGFwcC5nZXRBY3Rpdml0eUNvbnRyb2xsZXJCeVJvdXRlKHJvdXRlKTtcclxuXHJcbiAgICAgICAgdmFyIHVzZXIgPSBhcHAubW9kZWwudXNlcigpO1xyXG4gICAgICAgIHZhciBjdXJyZW50VHlwZSA9IHVzZXIgJiYgdXNlci51c2VyVHlwZSgpO1xyXG5cclxuICAgICAgICBpZiAoYWN0aXZpdHkgJiYgYWN0aXZpdHkuYWNjZXNzTGV2ZWwpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYW4gPSBhY3Rpdml0eS5hY2Nlc3NMZXZlbCAmIGN1cnJlbnRUeXBlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFjYW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBlcnJvciwgd2h5IGNhbm5vdCBhY2Nlc3NcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRMZXZlbDogYWN0aXZpdHkuYWNjZXNzTGV2ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFR5cGU6IGN1cnJlbnRUeXBlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbGxvd1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBCb290a25vY2s6IFNldCBvZiBLbm9ja291dCBCaW5kaW5nIEhlbHBlcnMgZm9yIEJvb3RzdHJhcCBqcyBjb21wb25lbnRzIChqcXVlcnkgcGx1Z2lucylcclxuICAgIFxyXG4gICAgRGVwZW5kZW5jaWVzOiBqcXVlcnlcclxuICAgIEluamVjdGVkIGRlcGVuZGVuY2llczoga25vY2tvdXRcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIERlcGVuZGVuY2llc1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG4vLyBESSBpMThuIGxpYnJhcnlcclxuZXhwb3J0cy5pMThuID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUhlbHBlcnMoa28pIHtcclxuICAgIHZhciBoZWxwZXJzID0ge307XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgQmluZGluZyAqKi9cclxuICAgIGhlbHBlcnMucG9wb3ZlciA9IHtcclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNyY09wdGlvbnMgPSBrby51bndyYXAodmFsdWVBY2Nlc3NvcigpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIER1cGxpY2F0aW5nIG9wdGlvbnMgb2JqZWN0IHRvIHBhc3MgdG8gcG9wb3ZlciB3aXRob3V0XHJcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0dG5nIHNvdXJjZSBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHNyY09wdGlvbnMpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVW53cmFwcGluZyBjb250ZW50IHRleHRcclxuICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50ID0ga28udW53cmFwKHNyY09wdGlvbnMuY29udGVudCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gTG9jYWxpemU6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRlbnQgPSBcclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmkxOG4gJiYgZXhwb3J0cy5pMThuLnQob3B0aW9ucy5jb250ZW50KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGVudDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gVG8gZ2V0IHRoZSBuZXcgb3B0aW9ucywgd2UgbmVlZCBkZXN0cm95IGl0IGZpcnN0OlxyXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5wb3BvdmVyKCdkZXN0cm95JykucG9wb3ZlcihvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZSBtdWVzdHJhIHNpIGVsIGVsZW1lbnRvIHRpZW5lIGVsIGZvY29cclxuICAgICAgICAgICAgICAgIGlmICgkKGVsZW1lbnQpLmlzKCc6Zm9jdXMnKSlcclxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnBvcG92ZXIoJ3Nob3cnKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnBvcG92ZXIoJ2Rlc3Ryb3knKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBoZWxwZXJzO1xyXG59XHJcblxyXG4vKipcclxuICAgIFBsdWcgaGVscGVycyBpbiB0aGUgcHJvdmlkZWQgS25vY2tvdXQgaW5zdGFuY2VcclxuKiovXHJcbmZ1bmN0aW9uIHBsdWdJbihrbywgcHJlZml4KSB7XHJcbiAgICB2YXIgbmFtZSxcclxuICAgICAgICBoZWxwZXJzID0gY3JlYXRlSGVscGVycyhrbyk7XHJcbiAgICBcclxuICAgIGZvcih2YXIgaCBpbiBoZWxwZXJzKSB7XHJcbiAgICAgICAgaWYgKGhlbHBlcnMuaGFzT3duUHJvcGVydHkgJiYgIWhlbHBlcnMuaGFzT3duUHJvcGVydHkoaCkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBuYW1lID0gcHJlZml4ID8gcHJlZml4ICsgaFswXS50b1VwcGVyQ2FzZSgpICsgaC5zbGljZSgxKSA6IGg7XHJcbiAgICAgICAga28uYmluZGluZ0hhbmRsZXJzW25hbWVdID0gaGVscGVyc1toXTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0cy5wbHVnSW4gPSBwbHVnSW47XHJcbmV4cG9ydHMuY3JlYXRlQmluZGluZ0hlbHBlcnMgPSBjcmVhdGVIZWxwZXJzO1xyXG4iLCIvKipcclxuICAgIEtub2Nrb3V0IEJpbmRpbmcgSGVscGVyIGZvciB0aGUgQm9vdHN0cmFwIFN3aXRjaCBwbHVnaW4uXHJcbiAgICBcclxuICAgIERlcGVuZGVuY2llczoganF1ZXJ5LCBib290c3RyYXAsIGJvb3RzdHJhcC1zd2l0Y2hcclxuICAgIEluamVjdGVkIGRlcGVuZGVuY2llczoga25vY2tvdXRcclxuICAgIFxyXG4gICAgSU1QT1JUQU5UIE5PVEVTOlxyXG4gICAgLSBBIGNvbnNvbGUgZXJyb3Igb2YgdHlwZSBcIm9iamVjdCBoYXMgbm90IHRoYXQgcHJvcGVydHlcIiB3aWxsIGhhcHBlbiBpZiBzcGVjaWZpZWRcclxuICAgICAgICBhIG5vbiBleGlzdGFudCBvcHRpb24gaW4gdGhlIGJpbmRpbmcuIFRoZSBlcnJvciBsb29rcyBzdHJhbmdlIHdoZW4gdXNpbmcgdGhlIG1pbmlmaWVkIGZpbGUuXHJcbiAgICAtIFRoZSBvcmRlciBvZiBvcHRpb25zIGluIHRoZSBiaW5kaW5nIG1hdHRlcnMgd2hlbiBjb21iaW5pbmcgd2l0aCBkaXNhYmxlZCBhbmQgcmVhZG9ubHlcclxuICAgICAgICBvcHRpb25zOiBpZiB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZDp0cnVlIG9yIHJlYWRvbmx5OnRydWUsIGFueSBhdHRlbXB0IHRvIGNoYW5nZSB0aGVcclxuICAgICAgICB2YWx1ZSB3aWxsIGZhaWwgc2lsZW50bHksIHNvIGlmIHRoZSBzYW1lIGJpbmRpbmcgdXBkYXRlIGNoYW5nZXMgZGlzYWJsZWQgdG8gZmFsc2VcclxuICAgICAgICBhbmQgdGhlIHN0YXRlLCB0aGUgJ2Rpc2FibGVkJyBjaGFuZ2UgbXVzdCBoYXBwZW5zIGJlZm9yZSB0aGUgJ3N0YXRlJyBjaGFuZ2Ugc28gYm90aFxyXG4gICAgICAgIGFyZSBzdWNjZXNzZnVsbHkgdXBkYXRlZC4gRm9yIHRoYXQsIGp1c3Qgc3BlY2lmeSAnZGlzYWJsZWQnIGJlZm9yZSAnc3RhdGUnIGluIHRoZSBiaW5kaW5nc1xyXG4gICAgICAgIGRlZmluaXRpb24uXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBEZXBlbmRlbmNpZXNcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxucmVxdWlyZSgnYm9vdHN0cmFwJyk7XHJcbnJlcXVpcmUoJ2Jvb3RzdHJhcC1zd2l0Y2gnKTtcclxuXHJcbi8qKlxyXG4gICAgQ3JlYXRlIGFuZCBwbHVnLWluIHRoZSBCaW5kaW5nIGluIHRoZSBwcm92aWRlZCBLbm9ja291dCBpbnN0YW5jZVxyXG4qKi9cclxuZXhwb3J0cy5wbHVnSW4gPSBmdW5jdGlvbiBwbHVnSW4oa28sIHByZWZpeCkge1xyXG5cclxuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1twcmVmaXggPyBwcmVmaXggKyAnc3dpdGNoJyA6ICdzd2l0Y2gnXSA9IHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwbHVnaW4gaW5zdGFuY2VcclxuICAgICAgICAgICAgJChlbGVtZW50KS5ib290c3RyYXBTd2l0Y2goKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N3aXRjaCBpbml0Jywga28udG9KUyh2YWx1ZUFjY2Vzc29yKCkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHZhbHVlIG9uIHBsdWdpbiBjaGFuZ2VzXHJcbiAgICAgICAgICAgICQoZWxlbWVudCkub24oJ3N3aXRjaENoYW5nZS5ib290c3RyYXBTd2l0Y2gnLCBmdW5jdGlvbiAoZSwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsdWVBY2Nlc3NvcigpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3dpdGNoQ2hhbmdlJywga28udG9KUyh2KSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZWQ/XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSAhIWtvLnVud3JhcCh2LnN0YXRlKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9ICEhc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBvbiBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZSAhPT0gbmV3U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHYuc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrby5pc1dyaXRlYWJsZU9ic2VydmFibGUodi5zdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuc3RhdGUobmV3U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi5zdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgLy8gR2V0IG9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgcGx1Z2luIGluc3RhbmNlXHJcbiAgICAgICAgICAgIHZhciBzcmNPcHRpb25zID0gdmFsdWVBY2Nlc3NvcigpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzcmNPcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gVW53cmFwcGluZyBldmVyeSBvcHRpb24gdmFsdWUsIGdldHRpbmcgYSBkdXBsaWNhdGVkXHJcbiAgICAgICAgICAgIC8vIHBsYWluIG9iamVjdFxyXG4gICAgICAgICAgICBvcHRpb25zID0ga28udG9KUyhvcHRpb25zKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3dpdGNoIHVwZGF0ZScsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgdmFyICRlbCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBldmVyeSBvcHRpb24gaW4gdGhlIHBsdWdpblxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgJGVsLmJvb3RzdHJhcFN3aXRjaChrZXksIG9wdGlvbnNba2V5XSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgRXNwYWNlIGEgc3RyaW5nIGZvciB1c2Ugb24gYSBSZWdFeHAuXHJcbiAgICBVc3VhbGx5LCB0byBsb29rIGZvciBhIHN0cmluZyBpbiBhIHRleHQgbXVsdGlwbGUgdGltZXNcclxuICAgIG9yIHdpdGggc29tZSBleHByZXNzaW9ucywgc29tZSBjb21tb24gYXJlIFxyXG4gICAgbG9vayBmb3IgYSB0ZXh0ICdpbiB0aGUgYmVnaW5uaW5nJyAoXilcclxuICAgIG9yICdhdCB0aGUgZW5kJyAoJCkuXHJcbiAgICBcclxuICAgIEF1dGhvcjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzE1MTMxMi9jb29sYWo4NiBhbmQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzk0MTAvYXJpc3RvdGxlLXBhZ2FsdHppc1xyXG4gICAgTGluazogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjk2OTQ4NlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gUmVmZXJyaW5nIHRvIHRoZSB0YWJsZSBoZXJlOlxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9yZWdleHBcclxuLy8gdGhlc2UgY2hhcmFjdGVycyBzaG91bGQgYmUgZXNjYXBlZFxyXG4vLyBcXCBeICQgKiArID8gLiAoICkgfCB7IH0gWyBdXHJcbi8vIFRoZXNlIGNoYXJhY3RlcnMgb25seSBoYXZlIHNwZWNpYWwgbWVhbmluZyBpbnNpZGUgb2YgYnJhY2tldHNcclxuLy8gdGhleSBkbyBub3QgbmVlZCB0byBiZSBlc2NhcGVkLCBidXQgdGhleSBNQVkgYmUgZXNjYXBlZFxyXG4vLyB3aXRob3V0IGFueSBhZHZlcnNlIGVmZmVjdHMgKHRvIHRoZSBiZXN0IG9mIG15IGtub3dsZWRnZSBhbmQgY2FzdWFsIHRlc3RpbmcpXHJcbi8vIDogISAsID0gXHJcbi8vIG15IHRlc3QgXCJ+IUAjJCVeJiooKXt9W11gLz0/K1xcfC1fOzonXFxcIiw8Lj5cIi5tYXRjaCgvW1xcI10vZylcclxuXHJcbnZhciBzcGVjaWFscyA9IFtcclxuICAgIC8vIG9yZGVyIG1hdHRlcnMgZm9yIHRoZXNlXHJcbiAgICAgIFwiLVwiXHJcbiAgICAsIFwiW1wiXHJcbiAgICAsIFwiXVwiXHJcbiAgICAvLyBvcmRlciBkb2Vzbid0IG1hdHRlciBmb3IgYW55IG9mIHRoZXNlXHJcbiAgICAsIFwiL1wiXHJcbiAgICAsIFwie1wiXHJcbiAgICAsIFwifVwiXHJcbiAgICAsIFwiKFwiXHJcbiAgICAsIFwiKVwiXHJcbiAgICAsIFwiKlwiXHJcbiAgICAsIFwiK1wiXHJcbiAgICAsIFwiP1wiXHJcbiAgICAsIFwiLlwiXHJcbiAgICAsIFwiXFxcXFwiXHJcbiAgICAsIFwiXlwiXHJcbiAgICAsIFwiJFwiXHJcbiAgICAsIFwifFwiXHJcbiAgXVxyXG5cclxuICAvLyBJIGNob29zZSB0byBlc2NhcGUgZXZlcnkgY2hhcmFjdGVyIHdpdGggJ1xcJ1xyXG4gIC8vIGV2ZW4gdGhvdWdoIG9ubHkgc29tZSBzdHJpY3RseSByZXF1aXJlIGl0IHdoZW4gaW5zaWRlIG9mIFtdXHJcbiwgcmVnZXggPSBSZWdFeHAoJ1snICsgc3BlY2lhbHMuam9pbignXFxcXCcpICsgJ10nLCAnZycpXHJcbjtcclxuXHJcbnZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbnJldHVybiBzdHIucmVwbGFjZShyZWdleCwgXCJcXFxcJCZcIik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVJlZ0V4cDtcclxuXHJcbi8vIHRlc3QgZXNjYXBlUmVnRXhwKFwiL3BhdGgvdG8vcmVzP3NlYXJjaD10aGlzLnRoYXRcIilcclxuIiwiLyoqXHJcbiogZXNjYXBlU2VsZWN0b3JcclxuKlxyXG4qIHNvdXJjZTogaHR0cDovL2tqdmFyZ2EuYmxvZ3Nwb3QuY29tLmVzLzIwMDkvMDYvanF1ZXJ5LXBsdWdpbi10by1lc2NhcGUtY3NzLXNlbGVjdG9yLmh0bWxcclxuKlxyXG4qIEVzY2FwZSBhbGwgc3BlY2lhbCBqUXVlcnkgQ1NTIHNlbGVjdG9yIGNoYXJhY3RlcnMgaW4gKnNlbGVjdG9yKi5cclxuKiBVc2VmdWwgd2hlbiB5b3UgaGF2ZSBhIGNsYXNzIG9yIGlkIHdoaWNoIGNvbnRhaW5zIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG4qIHdoaWNoIHlvdSBuZWVkIHRvIGluY2x1ZGUgaW4gYSBzZWxlY3Rvci5cclxuKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHNwZWNpYWxzID0gW1xyXG4gICcjJywgJyYnLCAnficsICc9JywgJz4nLCBcclxuICBcIidcIiwgJzonLCAnXCInLCAnIScsICc7JywgJywnXHJcbl07XHJcbnZhciByZWdleFNwZWNpYWxzID0gW1xyXG4gICcuJywgJyonLCAnKycsICd8JywgJ1snLCAnXScsICcoJywgJyknLCAnLycsICdeJywgJyQnXHJcbl07XHJcbnZhciBzUkUgPSBuZXcgUmVnRXhwKFxyXG4gICcoJyArIHNwZWNpYWxzLmpvaW4oJ3wnKSArICd8XFxcXCcgKyByZWdleFNwZWNpYWxzLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJ1xyXG4pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKHNSRSwgJ1xcXFwkMScpO1xyXG59O1xyXG4iLCIvKiogZ2V0RGF0ZVdpdGhvdXRUaW1lIHV0aWxpdHkuXHJcbiAgICBSZXR1cm5zIGEgbmV3IERhdGUgaW5zdGFuY2Ugd2l0aCB0aW1lIGF0IHplcm9lc1xyXG4gICAgYW5kIHRoZSBzYW1lIGRhdGUgYXMgdGhlIGlucHV0LlxyXG4gICAgSXQgcmV0dXJucyBjdXJyZW50IGRhdGUgaWYgbm8gdmFsaWQgZGF0ZSBvciBzdHJpbmcgcGFzc2VkLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXREYXRlV2l0aG91dFRpbWUoZGF0ZSkge1xyXG4gICAgaWYgKCFkYXRlKSB7XHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IERhdGUoXHJcbiAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgIGRhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICBkYXRlLmdldERhdGUoKSxcclxuICAgICAgICAwLCAwLCAwXHJcbiAgICApO1xyXG59O1xyXG4iLCIvKipcclxuICAgIEdldCBhIGdpdmVuIHZhbHVlIHdyYXBwZWQgaW4gYW4gb2JzZXJ2YWJsZSBvciByZXR1cm5zXHJcbiAgICBpdCBpZiBpdHMgYWxyZWFkeSBhbiBvYnNlcnZhYmxlIG9yIGp1c3QgYSBmdW5jdGlvbi5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZShvYnNPclZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mKG9ic09yVmFsdWUpID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHJldHVybiBvYnNPclZhbHVlO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBrby5vYnNlcnZhYmxlKG9ic09yVmFsdWUpO1xyXG59O1xyXG4iLCIvKipcclxuICAgIFJlYWQgYSBwYWdlJ3MgR0VUIFVSTCB2YXJpYWJsZXMgYW5kIHJldHVybiB0aGVtIGFzIGFuIGFzc29jaWF0aXZlIGFycmF5LlxyXG4qKi9cclxuJ3VzZXIgc3RyaWN0JztcclxuLy9nbG9iYWwgd2luZG93XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFVybFF1ZXJ5KHVybCkge1xyXG5cclxuICAgIHVybCA9IHVybCB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcclxuXHJcbiAgICB2YXIgdmFycyA9IFtdLCBoYXNoLFxyXG4gICAgICAgIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpO1xyXG4gICAgaWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xyXG4gICAgICAgIHZhciBoYXNoZXMgPSB1cmwuc2xpY2UocXVlcnlJbmRleCArIDEpLnNwbGl0KCcmJyk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGhhc2hlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGhhc2ggPSBoYXNoZXNbaV0uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgdmFycy5wdXNoKGhhc2hbMF0pO1xyXG4gICAgICAgICAgICB2YXJzW2hhc2hbMF1dID0gaGFzaFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFycztcclxufTtcclxuIiwiLy8galF1ZXJ5IHBsdWdpbiB0byBzZXQgbXVsdGlsaW5lIHRleHQgaW4gYW4gZWxlbWVudCxcclxuLy8gYnkgcmVwbGFjaW5nIFxcbiBieSA8YnIvPiB3aXRoIGNhcmVmdWwgdG8gYXZvaWQgWFNTIGF0dGFja3MuXHJcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEzMDgyMDI4XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG4kLmZuLm11bHRpbGluZSA9IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgIHRoaXMudGV4dCh0ZXh0KTtcclxuICAgIHRoaXMuaHRtbCh0aGlzLmh0bWwoKS5yZXBsYWNlKC9cXG4vZywnPGJyLz4nKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiLyoqXHJcbiAgICBTZXQgb2YgdXRpbGl0aWVzIHRvIGRlZmluZSBKYXZhc2NyaXB0IFByb3BlcnRpZXNcclxuICAgIGluZGVwZW5kZW50bHkgb2YgdGhlIGJyb3dzZXIuXHJcbiAgICBcclxuICAgIEFsbG93cyB0byBkZWZpbmUgZ2V0dGVycyBhbmQgc2V0dGVycy5cclxuICAgIFxyXG4gICAgQWRhcHRlZCBjb2RlIGZyb20gdGhlIG9yaWdpbmFsIGNyZWF0ZWQgYnkgSmVmZiBXYWxkZW5cclxuICAgIGh0dHA6Ly93aGVyZXN3YWxkZW4uY29tLzIwMTAvMDQvMTYvbW9yZS1zcGlkZXJtb25rZXktY2hhbmdlcy1hbmNpZW50LWVzb3RlcmljLXZlcnktcmFyZWx5LXVzZWQtc3ludGF4LWZvci1jcmVhdGluZy1nZXR0ZXJzLWFuZC1zZXR0ZXJzLWlzLWJlaW5nLXJlbW92ZWQvXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBhY2Nlc3NvckRlc2NyaXB0b3IoZmllbGQsIGZ1bilcclxue1xyXG4gICAgdmFyIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9O1xyXG4gICAgZGVzY1tmaWVsZF0gPSBmdW47XHJcbiAgICByZXR1cm4gZGVzYztcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lR2V0dGVyKG9iaiwgcHJvcCwgZ2V0KVxyXG57XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBhY2Nlc3NvckRlc2NyaXB0b3IoXCJnZXRcIiwgZ2V0KSk7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKVxyXG4gICAgICAgIHJldHVybiBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBnZXQpO1xyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcihcImJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBnZXR0ZXJzXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVTZXR0ZXIob2JqLCBwcm9wLCBzZXQpXHJcbntcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGFjY2Vzc29yRGVzY3JpcHRvcihcInNldFwiLCBzZXQpKTtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18pXHJcbiAgICAgICAgcmV0dXJuIG9iai5fX2RlZmluZVNldHRlcl9fKHByb3AsIHNldCk7XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHNldHRlcnNcIik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgZGVmaW5lR2V0dGVyOiBkZWZpbmVHZXR0ZXIsXHJcbiAgICBkZWZpbmVTZXR0ZXI6IGRlZmluZVNldHRlclxyXG59O1xyXG4iLCIvKipcclxuICAgIFJlbW92ZSB0aGUgYWNjZW50IGFuZCBzcGVjaWFsIGNoYXJhY3RlcnMgZnJvbSBhIHRleHRcclxuICAgIHJlcGxhY2luZyBlYWNoIGNoYXJhY3RlciBmb3IgaXRzIGJhc2ljIGVxdWl2YWxlbnQuXHJcbiAgICBVc2VmdWwgdG8gcGVyZm9ybXMgcHVuY3R1YXRpb24taW5zZW5zaXRpdmUgdGV4dCBzZWFyY2hzLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG1hcCA9IHsnw4AnOidBJywnw4EnOidBJywnw4InOidBJywnw4MnOidBJywnw4QnOidBJywnw4UnOidBJywnw4YnOidBRScsJ8OHJzonQycsJ8OIJzonRScsJ8OJJzonRScsJ8OKJzonRScsJ8OLJzonRScsJ8OMJzonSScsJ8ONJzonSScsJ8OOJzonSScsJ8OPJzonSScsJ8OQJzonRCcsJ8ORJzonTicsJ8OSJzonTycsJ8OTJzonTycsJ8OUJzonTycsJ8OVJzonTycsJ8OWJzonTycsJ8OYJzonTycsJ8OZJzonVScsJ8OaJzonVScsJ8ObJzonVScsJ8OcJzonVScsJ8OdJzonWScsJ8OfJzoncycsJ8OgJzonYScsJ8OhJzonYScsJ8OiJzonYScsJ8OjJzonYScsJ8OkJzonYScsJ8OlJzonYScsJ8OmJzonYWUnLCfDpyc6J2MnLCfDqCc6J2UnLCfDqSc6J2UnLCfDqic6J2UnLCfDqyc6J2UnLCfDrCc6J2knLCfDrSc6J2knLCfDric6J2knLCfDryc6J2knLCfDsSc6J24nLCfDsic6J28nLCfDsyc6J28nLCfDtCc6J28nLCfDtSc6J28nLCfDtic6J28nLCfDuCc6J28nLCfDuSc6J3UnLCfDuic6J3UnLCfDuyc6J3UnLCfDvCc6J3UnLCfDvSc6J3knLCfDvyc6J3knLCfEgCc6J0EnLCfEgSc6J2EnLCfEgic6J0EnLCfEgyc6J2EnLCfEhCc6J0EnLCfEhSc6J2EnLCfEhic6J0MnLCfEhyc6J2MnLCfEiCc6J0MnLCfEiSc6J2MnLCfEiic6J0MnLCfEiyc6J2MnLCfEjCc6J0MnLCfEjSc6J2MnLCfEjic6J0QnLCfEjyc6J2QnLCfEkCc6J0QnLCfEkSc6J2QnLCfEkic6J0UnLCfEkyc6J2UnLCfElCc6J0UnLCfElSc6J2UnLCfElic6J0UnLCfElyc6J2UnLCfEmCc6J0UnLCfEmSc6J2UnLCfEmic6J0UnLCfEmyc6J2UnLCfEnCc6J0cnLCfEnSc6J2cnLCfEnic6J0cnLCfEnyc6J2cnLCfEoCc6J0cnLCfEoSc6J2cnLCfEoic6J0cnLCfEoyc6J2cnLCfEpCc6J0gnLCfEpSc6J2gnLCfEpic6J0gnLCfEpyc6J2gnLCfEqCc6J0knLCfEqSc6J2knLCfEqic6J0knLCfEqyc6J2knLCfErCc6J0knLCfErSc6J2knLCfEric6J0knLCfEryc6J2knLCfEsCc6J0knLCfEsSc6J2knLCfEsic6J0lKJywnxLMnOidpaicsJ8S0JzonSicsJ8S1JzonaicsJ8S2JzonSycsJ8S3JzonaycsJ8S5JzonTCcsJ8S6JzonbCcsJ8S7JzonTCcsJ8S8JzonbCcsJ8S9JzonTCcsJ8S+JzonbCcsJ8S/JzonTCcsJ8WAJzonbCcsJ8WBJzonTCcsJ8WCJzonbCcsJ8WDJzonTicsJ8WEJzonbicsJ8WFJzonTicsJ8WGJzonbicsJ8WHJzonTicsJ8WIJzonbicsJ8WJJzonbicsJ8WMJzonTycsJ8WNJzonbycsJ8WOJzonTycsJ8WPJzonbycsJ8WQJzonTycsJ8WRJzonbycsJ8WSJzonT0UnLCfFkyc6J29lJywnxZQnOidSJywnxZUnOidyJywnxZYnOidSJywnxZcnOidyJywnxZgnOidSJywnxZknOidyJywnxZonOidTJywnxZsnOidzJywnxZwnOidTJywnxZ0nOidzJywnxZ4nOidTJywnxZ8nOidzJywnxaAnOidTJywnxaEnOidzJywnxaInOidUJywnxaMnOid0JywnxaQnOidUJywnxaUnOid0JywnxaYnOidUJywnxacnOid0JywnxagnOidVJywnxaknOid1JywnxaonOidVJywnxasnOid1JywnxawnOidVJywnxa0nOid1Jywnxa4nOidVJywnxa8nOid1JywnxbAnOidVJywnxbEnOid1JywnxbInOidVJywnxbMnOid1JywnxbQnOidXJywnxbUnOid3JywnxbYnOidZJywnxbcnOid5JywnxbgnOidZJywnxbknOidaJywnxbonOid6JywnxbsnOidaJywnxbwnOid6Jywnxb0nOidaJywnxb4nOid6Jywnxb8nOidzJywnxpInOidmJywnxqAnOidPJywnxqEnOidvJywnxq8nOidVJywnxrAnOid1Jywnx40nOidBJywnx44nOidhJywnx48nOidJJywnx5AnOidpJywnx5EnOidPJywnx5InOidvJywnx5MnOidVJywnx5QnOid1Jywnx5UnOidVJywnx5YnOid1Jywnx5cnOidVJywnx5gnOid1Jywnx5knOidVJywnx5onOid1Jywnx5snOidVJywnx5wnOid1Jywnx7onOidBJywnx7snOidhJywnx7wnOidBRScsJ8e9JzonYWUnLCfHvic6J08nLCfHvyc6J28nfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3ZlQWNjZW50KHN0cikge1xyXG5cclxuICAgIHZhciByZXMgPSAnJywgYztcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGMgPSBzdHIuY2hhckF0KGkpO1xyXG4gICAgICAgIHJlcyArPSBtYXBbY10gfHwgYztcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgRG9tSXRlbXNNYW5hZ2VyIGNsYXNzLCB0aGF0IG1hbmFnZSBhIGNvbGxlY3Rpb24gXHJcbiAgICBvZiBIVE1ML0RPTSBpdGVtcyB1bmRlciBhIHJvb3QvY29udGFpbmVyLCB3aGVyZVxyXG4gICAgb25seSBvbmUgZWxlbWVudCBhdCB0aGUgdGltZSBpcyB2aXNpYmxlLCBwcm92aWRpbmdcclxuICAgIHRvb2xzIHRvIHVuaXF1ZXJseSBpZGVudGlmeSB0aGUgaXRlbXMsXHJcbiAgICB0byBjcmVhdGUgb3IgdXBkYXRlIG5ldyBpdGVtcyAodGhyb3VnaCAnaW5qZWN0JyksXHJcbiAgICBnZXQgdGhlIGN1cnJlbnQsIGZpbmQgYnkgdGhlIElEIGFuZCBtb3JlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxudmFyIGVzY2FwZVNlbGVjdG9yID0gcmVxdWlyZSgnLi4vZXNjYXBlU2VsZWN0b3InKTtcclxuXHJcbmZ1bmN0aW9uIERvbUl0ZW1zTWFuYWdlcihzZXR0aW5ncykge1xyXG5cclxuICAgIHRoaXMuaWRBdHRyaWJ1dGVOYW1lID0gc2V0dGluZ3MuaWRBdHRyaWJ1dGVOYW1lIHx8ICdpZCc7XHJcbiAgICB0aGlzLmFsbG93RHVwbGljYXRlcyA9ICEhc2V0dGluZ3MuYWxsb3dEdXBsaWNhdGVzIHx8IGZhbHNlO1xyXG4gICAgdGhpcy4kcm9vdCA9IG51bGw7XHJcbiAgICAvLyBPbiBwYWdlIHJlYWR5LCBnZXQgdGhlIHJvb3QgZWxlbWVudDpcclxuICAgICQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy4kcm9vdCA9ICQoc2V0dGluZ3Mucm9vdCB8fCAnYm9keScpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEb21JdGVtc01hbmFnZXI7XHJcblxyXG5Eb21JdGVtc01hbmFnZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kKGNvbnRhaW5lck5hbWUsIHJvb3QpIHtcclxuICAgIHZhciAkcm9vdCA9ICQocm9vdCB8fCB0aGlzLiRyb290KTtcclxuICAgIHJldHVybiAkcm9vdC5maW5kKCdbJyArIHRoaXMuaWRBdHRyaWJ1dGVOYW1lICsgJz1cIicgKyBlc2NhcGVTZWxlY3Rvcihjb250YWluZXJOYW1lKSArICdcIl0nKTtcclxufTtcclxuXHJcbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZlID0gZnVuY3Rpb24gZ2V0QWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJHJvb3QuZmluZCgnWycgKyB0aGlzLmlkQXR0cmlidXRlTmFtZSArICddOnZpc2libGUnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgSXQgYWRkcyB0aGUgaXRlbSBpbiB0aGUgaHRtbCBwcm92aWRlZCAoY2FuIGJlIG9ubHkgdGhlIGVsZW1lbnQgb3IgXHJcbiAgICBjb250YWluZWQgaW4gYW5vdGhlciBvciBhIGZ1bGwgaHRtbCBwYWdlKS5cclxuICAgIFJlcGxhY2VzIGFueSBleGlzdGFudCBpZiBkdXBsaWNhdGVzIGFyZSBub3QgYWxsb3dlZC5cclxuKiovXHJcbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KG5hbWUsIGh0bWwpIHtcclxuXHJcbiAgICAvLyBGaWx0ZXJpbmcgaW5wdXQgaHRtbCAoY2FuIGJlIHBhcnRpYWwgb3IgZnVsbCBwYWdlcylcclxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEyODQ4Nzk4XHJcbiAgICBodG1sID0gaHRtbC5yZXBsYWNlKC9eW1xcc1xcU10qPGJvZHkuKj8+fDxcXC9ib2R5PltcXHNcXFNdKiQvZywgJycpO1xyXG5cclxuICAgIC8vIENyZWF0aW5nIGEgd3JhcHBlciBhcm91bmQgdGhlIGh0bWxcclxuICAgIC8vIChjYW4gYmUgcHJvdmlkZWQgdGhlIGlubmVySHRtbCBvciBvdXRlckh0bWwsIGRvZXNuJ3QgbWF0dGVycyB3aXRoIG5leHQgYXBwcm9hY2gpXHJcbiAgICB2YXIgJGh0bWwgPSAkKCc8ZGl2Lz4nLCB7IGh0bWw6IGh0bWwgfSksXHJcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgdGhlIGNvbnRhaW5lciBlbGVtZW50ICh3aGVuIHRoZSBvdXRlckh0bWwgaXMgcHJvdmlkZWQpXHJcbiAgICAgICAgJGMgPSB0aGlzLmZpbmQobmFtZSwgJGh0bWwpO1xyXG5cclxuICAgIGlmICgkYy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAvLyBJdHMgaW5uZXJIdG1sLCBzbyB0aGUgd3JhcHBlciBiZWNvbWVzIHRoZSBjb250YWluZXIgaXRzZWxmXHJcbiAgICAgICAgJGMgPSAkaHRtbC5hdHRyKHRoaXMuaWRBdHRyaWJ1dGVOYW1lLCBuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuYWxsb3dEdXBsaWNhdGVzKSB7XHJcbiAgICAgICAgLy8gTm8gbW9yZSB0aGFuIG9uZSBjb250YWluZXIgaW5zdGFuY2UgY2FuIGV4aXN0cyBhdCB0aGUgc2FtZSB0aW1lXHJcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgYW55IGV4aXN0ZW50IG9uZSBhbmQgaXRzIHJlcGxhY2VkIHdpdGggdGhlIG5ld1xyXG4gICAgICAgIHZhciAkcHJldiA9IHRoaXMuZmluZChuYW1lKTtcclxuICAgICAgICBpZiAoJHByZXYubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAkcHJldi5yZXBsYWNlV2l0aCgkYyk7XHJcbiAgICAgICAgICAgICRjID0gJHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0byB0aGUgZG9jdW1lbnRcclxuICAgIC8vIChvbiB0aGUgY2FzZSBvZiBkdXBsaWNhdGVkIGZvdW5kLCB0aGlzIHdpbGwgZG8gbm90aGluZywgbm8gd29ycnkpXHJcbiAgICAkYy5hcHBlbmRUbyh0aGlzLiRyb290KTtcclxufTtcclxuXHJcbi8qKiBcclxuICAgIFRoZSBzd2l0Y2ggbWV0aG9kIHJlY2VpdmUgdGhlIGl0ZW1zIHRvIGludGVyY2hhbmdlIGFzIGFjdGl2ZSBvciBjdXJyZW50LFxyXG4gICAgdGhlICdmcm9tJyBhbmQgJ3RvJywgYW5kIHRoZSBzaGVsbCBpbnN0YW5jZSB0aGF0IE1VU1QgYmUgdXNlZFxyXG4gICAgdG8gbm90aWZ5IGVhY2ggZXZlbnQgdGhhdCBpbnZvbHZlcyB0aGUgaXRlbTpcclxuICAgIHdpbGxDbG9zZSwgd2lsbE9wZW4sIHJlYWR5LCBvcGVuZWQsIGNsb3NlZC5cclxuICAgIEl0IHJlY2VpdmVzIGFzIGxhdGVzdCBwYXJhbWV0ZXIgdGhlICdub3RpZmljYXRpb24nIG9iamVjdCB0aGF0IG11c3QgYmVcclxuICAgIHBhc3NlZCB3aXRoIHRoZSBldmVudCBzbyBoYW5kbGVycyBoYXMgY29udGV4dCBzdGF0ZSBpbmZvcm1hdGlvbi5cclxuICAgIFxyXG4gICAgSXQncyBkZXNpZ25lZCB0byBiZSBhYmxlIHRvIG1hbmFnZSB0cmFuc2l0aW9ucywgYnV0IHRoaXMgZGVmYXVsdFxyXG4gICAgaW1wbGVtZW50YXRpb24gaXMgYXMgc2ltcGxlIGFzICdzaG93IHRoZSBuZXcgYW5kIGhpZGUgdGhlIG9sZCcuXHJcbioqL1xyXG5Eb21JdGVtc01hbmFnZXIucHJvdG90eXBlLnN3aXRjaCA9IGZ1bmN0aW9uIHN3aXRjaEFjdGl2ZUl0ZW0oJGZyb20sICR0bywgc2hlbGwsIG5vdGlmaWNhdGlvbikge1xyXG5cclxuICAgIGlmICghJHRvLmlzKCc6dmlzaWJsZScpKSB7XHJcbiAgICAgICAgc2hlbGwuZW1pdChzaGVsbC5ldmVudHMud2lsbE9wZW4sICR0bywgbm90aWZpY2F0aW9uKTtcclxuICAgICAgICAkdG8uc2hvdygpO1xyXG4gICAgICAgIC8vIEl0cyBlbm91Z2ggdmlzaWJsZSBhbmQgaW4gRE9NIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gdGFza3NcclxuICAgICAgICAvLyB0aGF0IG1heSBpbnZvbHZlIGxheW91dCBpbmZvcm1hdGlvblxyXG4gICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLml0ZW1SZWFkeSwgJHRvLCBub3RpZmljYXRpb24pO1xyXG4gICAgICAgIC8vIFdoZW4gaXRzIGNvbXBsZXRlbHkgb3BlbmVkXHJcbiAgICAgICAgc2hlbGwuZW1pdChzaGVsbC5ldmVudHMub3BlbmVkLCAkdG8sIG5vdGlmaWNhdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEl0cyByZWFkeTsgbWF5YmUgaXQgd2FzIGJ1dCBzdWItbG9jYXRpb25cclxuICAgICAgICAvLyBvciBzdGF0ZSBjaGFuZ2UgbmVlZCB0byBiZSBjb21tdW5pY2F0ZWRcclxuICAgICAgICBzaGVsbC5lbWl0KHNoZWxsLmV2ZW50cy5pdGVtUmVhZHksICR0bywgbm90aWZpY2F0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJGZyb20uaXMoJzp2aXNpYmxlJykpIHtcclxuICAgICAgICBzaGVsbC5lbWl0KHNoZWxsLmV2ZW50cy53aWxsQ2xvc2UsICRmcm9tLCBub3RpZmljYXRpb24pO1xyXG4gICAgICAgIC8vIERvICd1bmZvY3VzJyBvbiB0aGUgaGlkZGVuIGVsZW1lbnQgYWZ0ZXIgbm90aWZ5ICd3aWxsQ2xvc2UnXHJcbiAgICAgICAgLy8gZm9yIGJldHRlciBVWDogaGlkZGVuIGVsZW1lbnRzIGFyZSBub3QgcmVhY2hhYmxlIGFuZCBoYXMgZ29vZFxyXG4gICAgICAgIC8vIHNpZGUgZWZmZWN0cyBsaWtlIGhpZGRpbmcgdGhlIG9uLXNjcmVlbiBrZXlib2FyZCBpZiBhbiBpbnB1dCB3YXNcclxuICAgICAgICAvLyBmb2N1c2VkXHJcbiAgICAgICAgJGZyb20uZmluZCgnOmZvY3VzJykuYmx1cigpO1xyXG4gICAgICAgIC8vIGhpZGUgYW5kIG5vdGlmeSBpdCBlbmRlZFxyXG4gICAgICAgICRmcm9tLmhpZGUoKTtcclxuICAgICAgICBzaGVsbC5lbWl0KHNoZWxsLmV2ZW50cy5jbG9zZWQsICRmcm9tLCBub3RpZmljYXRpb24pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAgICBJbml0aWFsaXplcyB0aGUgbGlzdCBvZiBpdGVtcy4gTm8gbW9yZSB0aGFuIG9uZVxyXG4gICAgbXVzdCBiZSBvcGVuZWQvdmlzaWJsZSBhdCB0aGUgc2FtZSB0aW1lLCBzbyBhdCB0aGUgXHJcbiAgICBpbml0IGFsbCB0aGUgZWxlbWVudHMgYXJlIGNsb3NlZCB3YWl0aW5nIHRvIHNldFxyXG4gICAgb25lIGFzIHRoZSBhY3RpdmUgb3IgdGhlIGN1cnJlbnQgb25lLlxyXG4qKi9cclxuRG9tSXRlbXNNYW5hZ2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIHRoaXMuZ2V0QWN0aXZlKCkuaGlkZSgpO1xyXG59O1xyXG4iLCIvKipcclxuICAgIEphdmFzY3JpdHAgU2hlbGwgZm9yIFNQQXMuXHJcbioqL1xyXG4vKmdsb2JhbCB3aW5kb3csIGRvY3VtZW50ICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKiBESSBlbnRyeSBwb2ludHMgZm9yIGRlZmF1bHQgYnVpbGRzLiBNb3N0IGRlcGVuZGVuY2llcyBjYW4gYmVcclxuICAgIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3Igc2V0dGluZ3MgZm9yIHBlci1pbnN0YW5jZSBzZXR1cC5cclxuKiovXHJcbnZhciBkZXBzID0gcmVxdWlyZSgnLi9kZXBlbmRlbmNpZXMnKTtcclxuXHJcbi8qKiBDb25zdHJ1Y3RvciAqKi9cclxuXHJcbmZ1bmN0aW9uIFNoZWxsKHNldHRpbmdzKSB7XHJcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjE0XHJcbiAgICBcclxuICAgIGRlcHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy4kID0gc2V0dGluZ3MuanF1ZXJ5IHx8IGRlcHMuanF1ZXJ5O1xyXG4gICAgdGhpcy4kcm9vdCA9IHRoaXMuJChzZXR0aW5ncy5yb290KTtcclxuICAgIHRoaXMuYmFzZVVybCA9IHNldHRpbmdzLmJhc2VVcmwgfHwgJyc7XHJcbiAgICAvLyBXaXRoIGZvcmNlSGFzaGJhbmc9dHJ1ZTpcclxuICAgIC8vIC0gZnJhZ21lbnRzIFVSTHMgY2Fubm90IGJlIHVzZWQgdG8gc2Nyb2xsIHRvIGFuIGVsZW1lbnQgKGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciksXHJcbiAgICAvLyAgIHRoZXkgYXJlIGRlZmF1bHRQcmV2ZW50ZWQgdG8gYXZvaWQgY29uZnVzZSB0aGUgcm91dGluZyBtZWNoYW5pc20gYW5kIGN1cnJlbnQgVVJMLlxyXG4gICAgLy8gLSBwcmVzc2VkIGxpbmtzIHRvIGZyYWdtZW50cyBVUkxzIGFyZSBub3Qgcm91dGVkLCB0aGV5IGFyZSBza2lwcGVkIHNpbGVudGx5XHJcbiAgICAvLyAgIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIGEgaGFzaGJhbmcgKCMhKS4gVGhpcyB3YXksIHNwZWNpYWwgbGlua3NcclxuICAgIC8vICAgdGhhdCBwZXJmb3JtbiBqcyBhY3Rpb25zIGRvZXNuJ3QgY29uZmxpdHMuXHJcbiAgICAvLyAtIGFsbCBVUkxzIHJvdXRlZCB0aHJvdWdoIHRoZSBzaGVsbCBpbmNsdWRlcyBhIGhhc2hiYW5nICgjISksIHRoZSBzaGVsbCBlbnN1cmVzXHJcbiAgICAvLyAgIHRoYXQgaGFwcGVucyBieSBhcHBlbmRpbmcgdGhlIGhhc2hiYW5nIHRvIGFueSBVUkwgcGFzc2VkIGluIChleGNlcHQgdGhlIHN0YW5kYXJkIGhhc2hcclxuICAgIC8vICAgdGhhdCBhcmUgc2tpcHQpLlxyXG4gICAgdGhpcy5mb3JjZUhhc2hiYW5nID0gc2V0dGluZ3MuZm9yY2VIYXNoYmFuZyB8fCBmYWxzZTtcclxuICAgIHRoaXMubGlua0V2ZW50ID0gc2V0dGluZ3MubGlua0V2ZW50IHx8ICdjbGljayc7XHJcbiAgICB0aGlzLnBhcnNlVXJsID0gKHNldHRpbmdzLnBhcnNlVXJsIHx8IGRlcHMucGFyc2VVcmwpLmJpbmQodGhpcywgdGhpcy5iYXNlVXJsKTtcclxuICAgIHRoaXMuYWJzb2x1dGl6ZVVybCA9IChzZXR0aW5ncy5hYnNvbHV0aXplVXJsIHx8IGRlcHMuYWJzb2x1dGl6ZVVybCkuYmluZCh0aGlzLCB0aGlzLmJhc2VVcmwpO1xyXG5cclxuICAgIHRoaXMuaGlzdG9yeSA9IHNldHRpbmdzLmhpc3RvcnkgfHwgd2luZG93Lmhpc3Rvcnk7XHJcblxyXG4gICAgdGhpcy5pbmRleE5hbWUgPSBzZXR0aW5ncy5pbmRleE5hbWUgfHwgJ2luZGV4JztcclxuICAgIFxyXG4gICAgdGhpcy5pdGVtcyA9IHNldHRpbmdzLmRvbUl0ZW1zTWFuYWdlcjtcclxuXHJcbiAgICAvLyBsb2FkZXIgY2FuIGJlIGRpc2FibGVkIHBhc3NpbmcgJ251bGwnLCBzbyB3ZSBtdXN0XHJcbiAgICAvLyBlbnN1cmUgdG8gbm90IHVzZSB0aGUgZGVmYXVsdCBvbiB0aGF0IGNhc2VzOlxyXG4gICAgdGhpcy5sb2FkZXIgPSB0eXBlb2Yoc2V0dGluZ3MubG9hZGVyKSA9PT0gJ3VuZGVmaW5lZCcgPyBkZXBzLmxvYWRlciA6IHNldHRpbmdzLmxvYWRlcjtcclxuICAgIC8vIGxvYWRlciBzZXR1cFxyXG4gICAgaWYgKHRoaXMubG9hZGVyKVxyXG4gICAgICAgIHRoaXMubG9hZGVyLmJhc2VVcmwgPSB0aGlzLmJhc2VVcmw7XHJcblxyXG4gICAgLy8gRGVmaW5pdGlvbiBvZiBldmVudHMgdGhhdCB0aGlzIG9iamVjdCBjYW4gdHJpZ2dlcixcclxuICAgIC8vIGl0cyB2YWx1ZSBjYW4gYmUgY3VzdG9taXplZCBidXQgYW55IGxpc3RlbmVyIG5lZWRzXHJcbiAgICAvLyB0byBrZWVwIHVwZGF0ZWQgdG8gdGhlIGNvcnJlY3QgZXZlbnQgc3RyaW5nLW5hbWUgdXNlZC5cclxuICAgIC8vIFRoZSBpdGVtcyBtYW5pcHVsYXRpb24gZXZlbnRzIE1VU1QgYmUgdHJpZ2dlcmVkXHJcbiAgICAvLyBieSB0aGUgJ2l0ZW1zLnN3aXRjaCcgZnVuY3Rpb25cclxuICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgIHdpbGxPcGVuOiAnc2hlbGwtd2lsbC1vcGVuJyxcclxuICAgICAgICB3aWxsQ2xvc2U6ICdzaGVsbC13aWxsLWNsb3NlJyxcclxuICAgICAgICBpdGVtUmVhZHk6ICdzaGVsbC1pdGVtLXJlYWR5JyxcclxuICAgICAgICBjbG9zZWQ6ICdzaGVsbC1jbG9zZWQnLFxyXG4gICAgICAgIG9wZW5lZDogJ3NoZWxsLW9wZW5lZCdcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEEgZnVuY3Rpb24gdG8gZGVjaWRlIGlmIHRoZVxyXG4gICAgICAgIGFjY2VzcyBpcyBhbGxvd2VkIChyZXR1cm5zICdudWxsJylcclxuICAgICAgICBvciBub3QgKHJldHVybiBhIHN0YXRlIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uXHJcbiAgICAgICAgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgJ25vbkFjY2Vzc05hbWUnIGl0ZW07XHJcbiAgICAgICAgdGhlICdyb3V0ZScgcHJvcGVydHkgb24gdGhlIHN0YXRlIGlzIGF1dG9tYXRpY2FsbHkgZmlsbGVkKS5cclxuICAgICAgICBcclxuICAgICAgICBUaGUgZGVmYXVsdCBidWl0LWluIGp1c3QgYWxsb3cgZXZlcnl0aGluZyBcclxuICAgICAgICBieSBqdXN0IHJldHVybmluZyAnbnVsbCcgYWxsIHRoZSB0aW1lLlxyXG4gICAgICAgIFxyXG4gICAgICAgIEl0IHJlY2VpdmVzIGFzIHBhcmFtZXRlciB0aGUgc3RhdGUgb2JqZWN0LFxyXG4gICAgICAgIHRoYXQgYWxtb3N0IGNvbnRhaW5zIHRoZSAncm91dGUnIHByb3BlcnR5IHdpdGhcclxuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgVVJMLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLmFjY2Vzc0NvbnRyb2wgPSBzZXR0aW5ncy5hY2Nlc3NDb250cm9sIHx8IGRlcHMuYWNjZXNzQ29udHJvbDtcclxuICAgIC8vIFdoYXQgaXRlbSBsb2FkIG9uIG5vbiBhY2Nlc3NcclxuICAgIHRoaXMubm9uQWNjZXNzTmFtZSA9IHNldHRpbmdzLm5vbkFjY2Vzc05hbWUgfHwgJ2luZGV4JztcclxufVxyXG5cclxuLy8gU2hlbGwgaW5oZXJpdHMgZnJvbSBFdmVudEVtaXR0ZXJcclxuU2hlbGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShkZXBzLkV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcclxuICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgdmFsdWU6IFNoZWxsLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hlbGw7XHJcblxyXG5cclxuLyoqIEFQSSBkZWZpbml0aW9uICoqL1xyXG5cclxuU2hlbGwucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28odXJsLCBzdGF0ZSkge1xyXG5cclxuICAgIGlmICh0aGlzLmZvcmNlSGFzaGJhbmcpIHtcclxuICAgICAgICBpZiAoIS9eIyEvLnRlc3QodXJsKSkge1xyXG4gICAgICAgICAgICB1cmwgPSAnIyEnICsgdXJsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVybCA9IHRoaXMuYWJzb2x1dGl6ZVVybCh1cmwpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdW5kZWZpbmVkLCB1cmwpO1xyXG4gICAgLy8gcHVzaFN0YXRlIGRvIE5PVCB0cmlnZ2VyIHRoZSBwb3BzdGF0ZSBldmVudCwgc29cclxuICAgIHJldHVybiB0aGlzLnJlcGxhY2Uoc3RhdGUpO1xyXG59O1xyXG5cclxuU2hlbGwucHJvdG90eXBlLmdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjayhzdGF0ZSwgc3RlcHMpIHtcclxuICAgIHN0ZXBzID0gMCAtIChzdGVwcyB8fCAxKTtcclxuICAgIC8vIElmIHRoZXJlIGlzIG5vdGhpbmcgdG8gZ28tYmFjayBvciBub3QgZW5vdWdodFxyXG4gICAgLy8gJ2JhY2snIHN0ZXBzLCBnbyB0byB0aGUgaW5kZXhcclxuICAgIGlmIChzdGVwcyA8IDAgJiYgTWF0aC5hYnMoc3RlcHMpID49IHRoaXMuaGlzdG9yeS5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmdvKHRoaXMuaW5kZXhOYW1lKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE9uIHJlcGxhY2UsIHRoZSBwYXNzZWQgc3RhdGUgaXMgbWVyZ2VkIHdpdGhcclxuICAgICAgICAvLyB0aGUgb25lIHRoYXQgY29tZXMgZnJvbSB0aGUgc2F2ZWQgaGlzdG9yeVxyXG4gICAgICAgIC8vIGVudHJ5IChpdCAncG9wcycgd2hlbiBkb2luZyB0aGUgaGlzdG9yeS5nbygpKVxyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVVwZGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeS5nbyhzdGVwcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIFByb2Nlc3MgdGhlIGdpdmVuIHN0YXRlIGluIG9yZGVyIHRvIGdldCB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgYmFzZWQgb24gdGhhdCBvciB0aGUgc2F2ZWQgaW4gaGlzdG9yeSwgbWVyZ2UgaXQgd2l0aFxyXG4gICAgYW55IHVwZGF0ZWQgc3RhdGUgcGVuZGluZyBhbmQgYWRkcyB0aGUgcm91dGUgaW5mb3JtYXRpb24sXHJcbiAgICByZXR1cm5pbmcgYW4gc3RhdGUgb2JqZWN0IHN1aXRhYmxlIHRvIHVzZS5cclxuKiovXHJcblNoZWxsLnByb3RvdHlwZS5nZXRVcGRhdGVkU3RhdGUgPSBmdW5jdGlvbiBnZXRVcGRhdGVkU3RhdGUoc3RhdGUpIHtcclxuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDggKi9cclxuICAgIFxyXG4gICAgLy8gRm9yIGN1cnJlbnQgdXNlcywgYW55IHBlbmRpbmdTdGF0ZVVwZGF0ZSBpcyB1c2VkIGFzXHJcbiAgICAvLyB0aGUgc3RhdGUsIHJhdGhlciB0aGFuIHRoZSBwcm92aWRlZCBvbmVcclxuICAgIHN0YXRlID0gdGhpcy5fcGVuZGluZ1N0YXRlVXBkYXRlIHx8IHN0YXRlIHx8IHRoaXMuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcclxuICAgIFxyXG4gICAgLy8gVE9ETzogbW9yZSBhZHZhbmNlZCB1c2VzIG11c3QgYmUgdG8gdXNlIHRoZSAnc3RhdGUnIHRvXHJcbiAgICAvLyByZWNvdmVyIHRoZSBVSSBzdGF0ZSwgd2l0aCBhbnkgbWVzc2FnZSBmcm9tIG90aGVyIFVJXHJcbiAgICAvLyBwYXNzaW5nIGluIGEgd2F5IHRoYXQgYWxsb3cgdXBkYXRlIHRoZSBzdGF0ZSwgbm90XHJcbiAgICAvLyByZXBsYWNlIGl0IChmcm9tIHBlbmRpbmdTdGF0ZVVwZGF0ZSkuXHJcbiAgICAvKlxyXG4gICAgLy8gU3RhdGUgb3IgZGVmYXVsdCBzdGF0ZVxyXG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLmhpc3Rvcnkuc3RhdGUgfHwge307XHJcbiAgICAvLyBtZXJnZSBwZW5kaW5nIHVwZGF0ZWQgc3RhdGVcclxuICAgIHRoaXMuJC5leHRlbmQoc3RhdGUsIHRoaXMuX3BlbmRpbmdTdGF0ZVVwZGF0ZSk7XHJcbiAgICAvLyBkaXNjYXJkIHRoZSB1cGRhdGVcclxuICAgICovXHJcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVVcGRhdGUgPSBudWxsO1xyXG4gICAgXHJcbiAgICAvLyBEb2Vzbid0IG1hdHRlcnMgaWYgc3RhdGUgaW5jbHVkZXMgYWxyZWFkeSBcclxuICAgIC8vICdyb3V0ZScgaW5mb3JtYXRpb24sIG5lZWQgdG8gYmUgb3ZlcndyaXR0ZW5cclxuICAgIC8vIHRvIG1hdGNoIHRoZSBjdXJyZW50IG9uZS5cclxuICAgIC8vIE5PVEU6IHByZXZpb3VzbHksIGEgY2hlY2sgcHJldmVudGVkIHRoaXMgaWZcclxuICAgIC8vIHJvdXRlIHByb3BlcnR5IGV4aXN0cywgY3JlYXRpbmcgaW5maW5pdGUgbG9vcHNcclxuICAgIC8vIG9uIHJlZGlyZWN0aW9ucyBmcm9tIGFjdGl2aXR5LnNob3cgc2luY2UgJ3JvdXRlJyBkb2Vzbid0XHJcbiAgICAvLyBtYXRjaCB0aGUgbmV3IGRlc2lyZWQgbG9jYXRpb25cclxuICAgIFxyXG4gICAgLy8gRGV0ZWN0IGlmIGlzIGEgaGFzaGJhbmcgVVJMIG9yIGFuIHN0YW5kYXJkIG9uZS5cclxuICAgIC8vIEV4Y2VwdCBpZiB0aGUgYXBwIGlzIGZvcmNlZCB0byB1c2UgaGFzaGJhbmcuXHJcbiAgICB2YXIgaXNIYXNoQmFuZyA9IC8jIS8udGVzdChsb2NhdGlvbi5ocmVmKSB8fCB0aGlzLmZvcmNlSGFzaGJhbmc7XHJcbiAgICBcclxuICAgIHZhciBsaW5rID0gKFxyXG4gICAgICAgIGlzSGFzaEJhbmcgP1xyXG4gICAgICAgIGxvY2F0aW9uLmhhc2ggOlxyXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXHJcbiAgICApICsgKGxvY2F0aW9uLnNlYXJjaCB8fCAnJyk7XHJcbiAgICBcclxuICAgIC8vIFNldCB0aGUgcm91dGVcclxuICAgIHN0YXRlLnJvdXRlID0gdGhpcy5wYXJzZVVybChsaW5rKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG59O1xyXG5cclxuU2hlbGwucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XHJcbiAgICBcclxuICAgIHN0YXRlID0gdGhpcy5nZXRVcGRhdGVkU3RhdGUoc3RhdGUpO1xyXG5cclxuICAgIC8vIFVzZSB0aGUgaW5kZXggb24gcm9vdCBjYWxsc1xyXG4gICAgaWYgKHN0YXRlLnJvdXRlLnJvb3QgPT09IHRydWUpIHtcclxuICAgICAgICBzdGF0ZS5yb3V0ZSA9IHRoaXMucGFyc2VVcmwodGhpcy5pbmRleE5hbWUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBY2Nlc3MgY29udHJvbFxyXG4gICAgdmFyIGFjY2Vzc0Vycm9yID0gdGhpcy5hY2Nlc3NDb250cm9sKHN0YXRlLnJvdXRlKTtcclxuICAgIGlmIChhY2Nlc3NFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdvKHRoaXMubm9uQWNjZXNzTmFtZSwgYWNjZXNzRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvY2F0aW5nIHRoZSBjb250YWluZXJcclxuICAgIHZhciAkY29udCA9IHRoaXMuaXRlbXMuZmluZChzdGF0ZS5yb3V0ZS5uYW1lKTtcclxuICAgIHZhciBzaGVsbCA9IHRoaXM7XHJcbiAgICB2YXIgcHJvbWlzZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKCRjb250ICYmICRjb250Lmxlbmd0aCkge1xyXG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9sZENvbnQgPSBzaGVsbC5pdGVtcy5nZXRBY3RpdmUoKTtcclxuICAgICAgICAgICAgICAgICRvbGRDb250ID0gJG9sZENvbnQubm90KCRjb250KTtcclxuICAgICAgICAgICAgICAgIHNoZWxsLml0ZW1zLnN3aXRjaCgkb2xkQ29udCwgJGNvbnQsIHNoZWxsLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpOyAvLz8gcmVzb2x2ZShhY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XHJcbiAgICAgICAgICAgIC8vIGxvYWQgYW5kIGluamVjdCB0aGUgY29udGVudCBpbiB0aGUgcGFnZVxyXG4gICAgICAgICAgICAvLyB0aGVuIHRyeSB0aGUgcmVwbGFjZSBhZ2FpblxyXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy5sb2FkZXIubG9hZChzdGF0ZS5yb3V0ZSkudGhlbihmdW5jdGlvbihodG1sKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGl0ZW1zICh0aGUgbWFuYWdlciB0YWtlcyBjYXJlIHlvdVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIG9ubHkgdGhlIGl0ZW0sIGlmIHRoZXJlIGlzIG9uZSlcclxuICAgICAgICAgICAgICAgIHNoZWxsLml0ZW1zLmluamVjdChzdGF0ZS5yb3V0ZS5uYW1lLCBodG1sKTtcclxuICAgICAgICAgICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSBpdGVtIHdhcyBhZGRlZCBhbmQgaXMgcmVhZHlcclxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBhIHJlcXVlc3Qgbm90IHJldHVybmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW0gYW5kIHRoZSAncmVwbGFjZScgdHJ5aW5nIHRvIGxvYWQgaXQgYWdhaW4sIGFuZCBhZ2FpbiwgYW5kLi5cclxuICAgICAgICAgICAgICAgIGlmIChzaGVsbC5pdGVtcy5maW5kKHN0YXRlLnJvdXRlLm5hbWUpLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hlbGwucmVwbGFjZShzdGF0ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignUGFnZSBub3QgZm91bmQgKCcgKyBzdGF0ZS5yb3V0ZS5uYW1lICsgJyknKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTaGVsbCBQYWdlIG5vdCBmb3VuZCwgc3RhdGU6Jywgc3RhdGUpO1xyXG4gICAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIGJlaW5nIGluIGFuIGluZXhpc3RhbnQgVVJMIChnZW5lcmF0aW5nIGluY29uc2lzdGVuY3kgYmV0d2VlblxyXG4gICAgICAgICAgICAvLyBjdXJyZW50IHZpZXcgYW5kIFVSTCwgY3JlYXRpbmcgYmFkIGhpc3RvcnkgZW50cmllcyksXHJcbiAgICAgICAgICAgIC8vIGEgZ29CYWNrIGlzIGV4ZWN1dGVkLCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IHBpcGUgZW5kc1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcmVkaXJlY3QgdGhhdCBjdXQgY3VycmVudCBwcm9jZXNzaW5nIHJhdGhlciB0aGFuIGV4ZWN1dGUgZGVsYXllZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nb0JhY2soKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciB0aGlzU2hlbGwgPSB0aGlzO1xyXG4gICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpXHJcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihlcnIpO1xyXG5cclxuICAgICAgICAvLyBMb2cgZXJyb3IsIFxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NoZWxsLCB1bmV4cGVjdGVkIGVycm9yLicsIGVycik7XHJcbiAgICAgICAgLy8gbm90aWZ5IGFzIGFuIGV2ZW50XHJcbiAgICAgICAgdGhpc1NoZWxsLmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICAgICAgICAvLyBhbmQgY29udGludWUgcHJvcGFnYXRpbmcgdGhlIGVycm9yXHJcbiAgICAgICAgcmV0dXJuIGVycjtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG59O1xyXG5cclxuU2hlbGwucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcclxuXHJcbiAgICB2YXIgc2hlbGwgPSB0aGlzO1xyXG5cclxuICAgIC8vIENhdGNoIHBvcHN0YXRlIGV2ZW50IHRvIHVwZGF0ZSBzaGVsbCByZXBsYWNpbmcgdGhlIGFjdGl2ZSBjb250YWluZXIuXHJcbiAgICAvLyBBbGxvd3MgcG9seWZpbGxzIHRvIHByb3ZpZGUgYSBkaWZmZXJlbnQgYnV0IGVxdWl2YWxlbnQgZXZlbnQgbmFtZVxyXG4gICAgdGhpcy4kKHdpbmRvdykub24odGhpcy5oaXN0b3J5LnBvcHN0YXRlRXZlbnQgfHwgJ3BvcHN0YXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5zdGF0ZSB8fCBcclxuICAgICAgICAgICAgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5zdGF0ZSkgfHwgXHJcbiAgICAgICAgICAgIHNoZWxsLmhpc3Rvcnkuc3RhdGU7XHJcblxyXG4gICAgICAgIC8vIGdldCBzdGF0ZSBmb3IgY3VycmVudC4gVG8gc3VwcG9ydCBwb2x5ZmlsbHMsIHdlIHVzZSB0aGUgZ2VuZXJhbCBnZXR0ZXJcclxuICAgICAgICAvLyBoaXN0b3J5LnN0YXRlIGFzIGZhbGxiYWNrICh0aGV5IG11c3QgYmUgdGhlIHNhbWUgb24gYnJvd3NlcnMgc3VwcG9ydGluZyBIaXN0b3J5IEFQSSlcclxuICAgICAgICBzaGVsbC5yZXBsYWNlKHN0YXRlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENhdGNoIGFsbCBsaW5rcyBpbiB0aGUgcGFnZSAobm90IG9ubHkgJHJvb3Qgb25lcykgYW5kIGxpa2UtbGlua3MuXHJcbiAgICAvLyBJTVBPUlRBTlQ6IHRoZSB0aW1lb3V0IGFuZCBsaW5rV29ya2luZyBpcyBhIGtpbmQgb2YgaGFjay93b3JrYXJvdW5kIGJlY2F1c2Ugb2Y6XHJcbiAgICAvLyAtIGlPUyBjbGljayBkZWxheTogY2hhbmdpbmcgbGlua0V2ZW50IHRvIGJlICd0YXAgY2xpY2snIChqcW0gdGFwIGV2ZW50KSBvciBcclxuICAgIC8vICAgbW9yZSBzdGFuZGFyZCBidXQgc2ltcGxpc3RpYyAndG91Y2hlbmQgY2xpY2snLCBvbmx5IG9uIGlPUyBpZiBwb3NzaWJsZSwgdGhlXHJcbiAgICAvLyAgIGlPUyBjbGljayBkZWxheSBjYW4gYmUgYXZvaWRlZCwgbGV0dGluZyB0aGUgdG91Y2ggZXZlbnQgdG8gdHJpZ2dlciB0aGlzIFNoZWxsIGhhbmRsZXJcclxuICAgIC8vICAgYW5kIHByZXZlbnRpbmcgdGhlIGNsaWNrIGZyb20gaGFwcGVuaW5nIHRvIGF2b2lkIGRvdWJsZSBleGVjdXRpb25cclxuICAgIC8vICAgKHRoYW5rcyB0byBsaW5rV29ya2luZyBhbmQgc2V0VGltZW91dCkuXHJcbiAgICAvLyAgIEEgYnJva2VuIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIHVzZSBvbmx5IG9uZSBldmVudCwgbGlrZSAndGFwJyBvciAndG91Y2hlbmQnLCBidXRcclxuICAgIC8vICAgdGhleSBmYWxsIGRvd24gd2hlbiBhIHRvdWNoIGdlc3R1cmUgaGFwcGVucyBpbiB0aGUgbGltaXQgb2YgYSBsaW5rL2VsZW1lbnQgYmVjYXVzZVxyXG4gICAgLy8gICBhIHRvdWNoc3RhcnQgaGFwcGVucyBvdXQgb2Ygb3VyIHRhcmdldCBsaW5rIC1mYWlsaW5nIHRvdWNoZW5kIGFuZCB0YXAgc2luY2UgZG9uJ3QgXHJcbiAgICAvLyAgIGdldCB0cmlnZ2VyZWQgaW4gb3VyIGxpbmstIGJ1dCB0aGUgYnJvd3Nlci93ZWJ2aWV3IHN0aWxsIGV4ZWN1dGVzIChhbmQgaW5tZWRpYXRseSlcclxuICAgIC8vICAgdGhlICdjbGljaycgZXZlbnQgb24gdGhlIGxpbmsuIEl0IHNlZW1zIGFuIGVkZ2UgY2FzZSBidXQgaXMgZWFzaWVyIHRvIG1ha2UgaXQgaGFwcGVuc1xyXG4gICAgLy8gICB0aGFuIGl0IHNlZW1zLiBJdCdzIHRoZSBidWcgdGhhdCBmb3JjZWQgdG8gaW1wbGVtZW50IHRoaXMgd29ya2FvdXJuZCA6LS9cclxuICAgIC8vIC0gQW5kIGFkZGl0aW9uYWxseTogaXQgcHJldmVudHMgd28gJ2NsaWNrcycgZnJvbSBoYXBwZW5pbmcgZXhjZXNzaXZlIGZhc3QgYmVjYXVzZVxyXG4gICAgLy8gICBzb21lIGtpbmQgb2YgYSBzZWNvbmQgdW53YW50ZWQgdG91Y2ggaGFwcGVuaW5nIHZlcnkgZmFzdCwgbWFraW5nXHJcbiAgICAvLyAgIGEgY2xpY2sgYnkgbWlzdGFrZSBvbiBhIGRpZmZlcmVudCBsaW5rIG9uIHRoZSBsb2FkZWQgbmV3IHBhZ2UuXHJcbiAgICB2YXIgbGlua1dvcmtpbmcgPSBudWxsLFxyXG4gICAgICAgIC8vIGlPUyAzMDBtcyBkZWxheSwgYSBiaXQgaW5jcmVhc2VkIHRvIGF2b2lkIHByb2JsZW1zLlxyXG4gICAgICAgIGxpbmtXb3JraW5nRGVsYXkgPSAzNDA7XHJcbiAgICAvL0RFQlVHIHZhciBsaW5rRXZlbnQgPSB0aGlzLmxpbmtFdmVudDtcclxuICAgIHRoaXMuJChkb2N1bWVudCkub24odGhpcy5saW5rRXZlbnQsICdbaHJlZl0sIFtkYXRhLWhyZWZdJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJ1NoZWxsIG9uIGV2ZW50JywgZS50eXBlLCBsaW5rV29ya2luZyk7XHJcbiAgICAgICAgLy8gSWYgd29ya2luZywgYXZvaWQgZXZlcnl0aGluZzpcclxuICAgICAgICBpZiAobGlua1dvcmtpbmcpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBsaW5rV29ya2luZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGxpbmtXb3JraW5nID0gbnVsbDtcclxuICAgICAgICB9LCBsaW5rV29ya2luZ0RlbGF5KTtcclxuXHJcbiAgICAgICAgdmFyICR0ID0gc2hlbGwuJCh0aGlzKSxcclxuICAgICAgICAgICAgaHJlZiA9ICR0LmF0dHIoJ2hyZWYnKSB8fCAkdC5kYXRhKCdocmVmJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9ERUJVRyBjb25zb2xlLmxvZygnU2hlbGwgb24nLCBsaW5rRXZlbnQsIGUudHlwZSwgJ2hyZWYnLCBocmVmLCAnZWxlbWVudCcsICR0KTtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgVVJMIGNvbnRhaW5zIHRoZSBwcm90b2NvbFxyXG4gICAgICAgIGlmICgvXlthLXpdKzovaS50ZXN0KGhyZWYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hlbGwuZm9yY2VIYXNoYmFuZyAmJiAvXiMoW14hXXwkKS8udGVzdChocmVmKSkge1xyXG4gICAgICAgICAgICAvLyBTdGFuZGFyZCBoYXNoLCBidXQgbm90IGhhc2hiYW5nOiBhdm9pZCByb3V0aW5nIGFuZCBkZWZhdWx0IGJlaGF2aW9yXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciBzcGVjaWFsIGV2ZW50IG9uIHRoZSBzaGVsbCwgc28gZXh0ZXJuYWwgc2NyaXB0cyBjYW4gZG9cclxuICAgICAgICAgICAgLy8gc29tZXRoaW5nLCBsaWtlIHRyeWluZyB0byBpbXBsZW1lbnQgc3RhbmRhcmQgc2Nyb2xsIGJlaGF2aW9yIG9yIGFueVxyXG4gICAgICAgICAgICAvLyBQYXNzIGluOiBzb3VyY2UgZnJhZ21lbnQgbGluaywgZWxlbWVudCB0aGF0IHJlY2VpdmUgdGhlIG9yaWdpbmFsIGV2ZW50IGFuZFxyXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAgICAgICAgICAgIHNoZWxsLmVtaXQoJ2ZyYWdtZW50TmF2aWdhdGlvbicsIGhyZWYsIHRoaXMsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGVkIGRlbGF5ZWQgdG8gYXZvaWQgaGFuZGxlciBjb2xsaXNpb25zLCBiZWNhdXNlXHJcbiAgICAgICAgLy8gb2YgdGhlIG5ldyBwYWdlIG1vZGlmeWluZyB0aGUgZWxlbWVudCBhbmQgb3RoZXIgaGFuZGxlcnNcclxuICAgICAgICAvLyByZWFkaW5nIGl0IGF0dHJpYnV0ZXMgYW5kIGFwcGx5aW5nIGxvZ2ljIG9uIHRoZSB1cGRhdGVkIGxpbmtcclxuICAgICAgICAvLyBhcyBpZiB3YXMgdGhlIG9sZCBvbmUgKGV4YW1wbGU6IHNoYXJlZCBsaW5rcywgbGlrZSBpbiBhXHJcbiAgICAgICAgLy8gZ2xvYmFsIG5hdmJhciwgdGhhdCBtb2RpZmllcyB3aXRoIHRoZSBuZXcgcGFnZSkuXHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc2hlbGwuZ28oaHJlZik7XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJbml0aWFsbGl6ZSBzdGF0ZVxyXG4gICAgdGhpcy5pdGVtcy5pbml0KCk7XHJcbiAgICAvLyBSb3V0ZSB0byB0aGUgY3VycmVudCB1cmwvc3RhdGVcclxuICAgIHRoaXMucmVwbGFjZSgpO1xyXG59O1xyXG4iLCIvKipcclxuICAgIGFic29sdXRpemVVcmwgdXRpbGl0eSBcclxuICAgIHRoYXQgZW5zdXJlcyB0aGUgdXJsIHByb3ZpZGVkXHJcbiAgICBiZWluZyBpbiB0aGUgcGF0aCBvZiB0aGUgZ2l2ZW4gYmFzZVVybFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHNhbml0aXplVXJsID0gcmVxdWlyZSgnLi9zYW5pdGl6ZVVybCcpLFxyXG4gICAgZXNjYXBlUmVnRXhwID0gcmVxdWlyZSgnLi4vZXNjYXBlUmVnRXhwJyk7XHJcblxyXG5mdW5jdGlvbiBhYnNvbHV0aXplVXJsKGJhc2VVcmwsIHVybCkge1xyXG5cclxuICAgIC8vIHNhbml0aXplIGJlZm9yZSBjaGVja1xyXG4gICAgdXJsID0gc2FuaXRpemVVcmwodXJsKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB1c2UgdGhlIGJhc2UgYWxyZWFkeVxyXG4gICAgdmFyIG1hdGNoQmFzZSA9IG5ldyBSZWdFeHAoJ14nICsgZXNjYXBlUmVnRXhwKGJhc2VVcmwpLCAnaScpO1xyXG4gICAgaWYgKG1hdGNoQmFzZS50ZXN0KHVybCkpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJ1aWxkIGFuZCBzYW5pdGl6ZVxyXG4gICAgcmV0dXJuIHNhbml0aXplVXJsKGJhc2VVcmwgKyB1cmwpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFic29sdXRpemVVcmw7XHJcbiIsIi8qKlxyXG4gICAgRXh0ZXJuYWwgZGVwZW5kZW5jaWVzIGZvciBTaGVsbCBpbiBhIHNlcGFyYXRlIG1vZHVsZVxyXG4gICAgdG8gdXNlIGFzIERJLCBuZWVkcyBzZXR1cCBiZWZvcmUgY2FsbCB0aGUgU2hlbGwuanNcclxuICAgIG1vZHVsZSBjbGFzc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBwYXJzZVVybDogbnVsbCxcclxuICAgIGFic29sdXRpemVVcmw6IG51bGwsXHJcbiAgICBqcXVlcnk6IG51bGwsXHJcbiAgICBsb2FkZXI6IG51bGwsXHJcbiAgICBhY2Nlc3NDb250cm9sOiBmdW5jdGlvbiBhbGxvd0FsbCgvKm5hbWUqLykge1xyXG4gICAgICAgIC8vIGFsbG93IGFjY2VzcyBieSBkZWZhdWx0XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG4gICAgRXZlbnRFbWl0dGVyOiBudWxsXHJcbn07XHJcbiIsIi8qKlxyXG4gICAgU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBIaXN0b3J5IEFQSSB1c2luZyBvbmx5IGhhc2hiYW5ncyBVUkxzLFxyXG4gICAgZG9lc24ndCBtYXR0ZXJzIHRoZSBicm93c2VyIHN1cHBvcnQuXHJcbiAgICBVc2VkIHRvIGF2b2lkIGZyb20gc2V0dGluZyBVUkxzIHRoYXQgaGFzIG5vdCBhbiBlbmQtcG9pbnQsXHJcbiAgICBsaWtlIGluIGxvY2FsIGVudmlyb25tZW50cyB3aXRob3V0IGEgc2VydmVyIGRvaW5nIHVybC1yZXdyaXRpbmcsXHJcbiAgICBpbiBwaG9uZWdhcCBhcHBzLCBvciB0byBjb21wbGV0ZWx5IGJ5LXBhc3MgYnJvd3NlciBzdXBwb3J0IGJlY2F1c2VcclxuICAgIGlzIGJ1Z2d5IChsaWtlIEFuZHJvaWQgPD0gNC4xKS5cclxuICAgIFxyXG4gICAgTk9URVM6XHJcbiAgICAtIEJyb3dzZXIgbXVzdCBzdXBwb3J0ICdoYXNoY2hhbmdlJyBldmVudC5cclxuICAgIC0gQnJvd3NlciBtdXN0IGhhcyBzdXBwb3J0IGZvciBzdGFuZGFyZCBKU09OIGNsYXNzLlxyXG4gICAgLSBSZWxpZXMgb24gc2Vzc2lvbnN0b3JhZ2UgZm9yIHBlcnNpc3RhbmNlLCBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIGFuZCB3ZWJ2aWV3cyBcclxuICAgICAgZm9yIGEgZW5vdWdoIGxvbmcgdGltZSBub3cuXHJcbiAgICAtIFNpbWlsYXIgYXBwcm9hY2ggYXMgSGlzdG9yeS5qcyBwb2x5ZmlsbCwgYnV0IHNpbXBsaWZpZWQsIGFwcGVuZGluZyBhIGZha2UgcXVlcnlcclxuICAgICAgcGFyYW1ldGVyICdfc3VpZD0wJyB0byB0aGUgaGFzaCB2YWx1ZSAoYWN0dWFsIHF1ZXJ5IGdvZXMgYmVmb3JlIHRoZSBoYXNoLCBidXRcclxuICAgICAgd2UgbmVlZCBpdCBpbnNpZGUpLlxyXG4gICAgLSBGb3Igc2ltcGxpZmljYXRpb24sIG9ubHkgdGhlIHN0YXRlIGlzIHBlcnNpc3RlZCwgdGhlICd0aXRsZScgcGFyYW1ldGVyIGlzIG5vdFxyXG4gICAgICB1c2VkIGF0IGFsbCAodGhlIHNhbWUgYXMgbWFqb3IgYnJvd3NlcnMgZG8sIHNvIGlzIG5vdCBhIHByb2JsZW0pOyBpbiB0aGlzIGxpbmUsXHJcbiAgICAgIG9ubHkgaGlzdG9yeSBlbnRyaWVzIHdpdGggc3RhdGUgYXJlIHBlcnNpc3RlZC5cclxuKiovXHJcbi8vZ2xvYmFsIGxvY2F0aW9uXHJcbid1c2Ugc3RyaWN0JztcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIHNhbml0aXplVXJsID0gcmVxdWlyZSgnLi9zYW5pdGl6ZVVybCcpLFxyXG4gICAgZ2V0VXJsUXVlcnkgPSByZXF1aXJlKCcuLi9nZXRVcmxRdWVyeScpO1xyXG5cclxuLy8gSW5pdDogTG9hZCBzYXZlZCBjb3B5IGZyb20gc2Vzc2lvblN0b3JhZ2VcclxudmFyIHNlc3Npb24gPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdoYXNoYmFuZ0hpc3Rvcnkuc3RvcmUnKTtcclxuLy8gT3IgY3JlYXRlIGEgbmV3IG9uZVxyXG5pZiAoIXNlc3Npb24pIHtcclxuICAgIHNlc3Npb24gPSB7XHJcbiAgICAgICAgLy8gU3RhdGVzIGFycmF5IHdoZXJlIGVhY2ggaW5kZXggaXMgdGhlIFNVSUQgY29kZSBhbmQgdGhlXHJcbiAgICAgICAgLy8gdmFsdWUgaXMganVzdCB0aGUgdmFsdWUgcGFzc2VkIGFzIHN0YXRlIG9uIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGVcclxuICAgICAgICBzdGF0ZXM6IFtdXHJcbiAgICB9O1xyXG59XHJcbmVsc2Uge1xyXG4gICAgc2Vzc2lvbiA9IEpTT04ucGFyc2Uoc2Vzc2lvbik7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICAgIEdldCB0aGUgU1VJRCBudW1iZXJcclxuICAgIGZyb20gYSBoYXNoIHN0cmluZ1xyXG4qKi9cclxuZnVuY3Rpb24gZ2V0U3VpZChoYXNoKSB7XHJcbiAgICBcclxuICAgIHZhciBzdWlkID0gK2dldFVybFF1ZXJ5KGhhc2gpLl9zdWlkO1xyXG4gICAgaWYgKGlzTmFOKHN1aWQpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBzdWlkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRTdWlkKGhhc2gsIHN1aWQpIHtcclxuICAgIFxyXG4gICAgLy8gV2UgbmVlZCB0aGUgcXVlcnksIHNpbmNlIHdlIG5lZWQgXHJcbiAgICAvLyB0byByZXBsYWNlIHRoZSBfc3VpZCAobWF5IGV4aXN0KVxyXG4gICAgLy8gYW5kIHJlY3JlYXRlIHRoZSBxdWVyeSBpbiB0aGVcclxuICAgIC8vIHJldHVybmVkIGhhc2gtdXJsXHJcbiAgICB2YXIgcXMgPSBnZXRVcmxRdWVyeShoYXNoKTtcclxuICAgIHFzLnB1c2goJ19zdWlkJyk7XHJcbiAgICBxcy5fc3VpZCA9IHN1aWQ7XHJcblxyXG4gICAgdmFyIHF1ZXJ5ID0gW107XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBxdWVyeS5wdXNoKHFzW2ldICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHFzW3FzW2ldXSkpO1xyXG4gICAgfVxyXG4gICAgcXVlcnkgPSBxdWVyeS5qb2luKCcmJyk7XHJcbiAgICBcclxuICAgIGlmIChxdWVyeSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGhhc2guaW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMCwgaW5kZXgpO1xyXG4gICAgICAgIGhhc2ggKz0gJz8nICsgcXVlcnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhhc2g7XHJcbn1cclxuXHJcbi8qKlxyXG4gICAgQXNrIHRvIHBlcnNpc3QgdGhlIHNlc3Npb24gZGF0YS5cclxuICAgIEl0IGlzIGRvbmUgd2l0aCBhIHRpbWVvdXQgaW4gb3JkZXIgdG8gYXZvaWRcclxuICAgIGRlbGF5IGluIHRoZSBjdXJyZW50IHRhc2sgbWFpbmx5IGFueSBoYW5kbGVyXHJcbiAgICB0aGF0IGFjdHMgYWZ0ZXIgYSBIaXN0b3J5IGNoYW5nZS5cclxuKiovXHJcbmZ1bmN0aW9uIHBlcnNpc3QoKSB7XHJcbiAgICAvLyBFbm91Z2ggdGltZSB0byBhbGxvdyByb3V0aW5nIHRhc2tzLFxyXG4gICAgLy8gbW9zdCBhbmltYXRpb25zIGZyb20gZmluaXNoIGFuZCB0aGUgVUlcclxuICAgIC8vIGJlaW5nIHJlc3BvbnNpdmUuXHJcbiAgICAvLyBCZWNhdXNlIHNlc3Npb25TdG9yYWdlIGlzIHN5bmNocm9ub3VzLlxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdoYXNoYmFuZ0hpc3Rvcnkuc3RvcmUnLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XHJcbiAgICB9LCAxNTAwKTtcclxufVxyXG5cclxuLyoqXHJcbiAgICBSZXR1cm5zIHRoZSBnaXZlbiBzdGF0ZSBvciBudWxsXHJcbiAgICBpZiBpcyBhbiBlbXB0eSBvYmplY3QuXHJcbioqL1xyXG5mdW5jdGlvbiBjaGVja1N0YXRlKHN0YXRlKSB7XHJcbiAgICBcclxuICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgIC8vIGlzIGVtcHR5P1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBOb1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGl0cyBlbXB0eVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gQW55dGhpbmcgZWxzZVxyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG59XHJcblxyXG4vKipcclxuICAgIEdldCBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvblxyXG4gICAgb2YgdGhlIFVSTCBzbyBjYW4gYmUgY29tcGFyZWRcclxuICAgIHdpdGggc3VjY2Vzcy5cclxuKiovXHJcbmZ1bmN0aW9uIGNhbm5vbmljYWxVcmwodXJsKSB7XHJcbiAgICBcclxuICAgIC8vIEF2b2lkIHNvbWUgYmFkIG9yIHByb2JsZW1hdGljIHN5bnRheFxyXG4gICAgdXJsID0gc2FuaXRpemVVcmwodXJsIHx8ICcnKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHRoZSBoYXNoIHBhcnRcclxuICAgIHZhciBpaGFzaCA9IHVybC5pbmRleE9mKCcjJyk7XHJcbiAgICBpZiAoaWhhc2ggPiAtMSkge1xyXG4gICAgICAgIHVybCA9IHVybC5zdWJzdHIoaWhhc2ggKyAxKTtcclxuICAgIH1cclxuICAgIC8vIE1heWJlIGEgaGFzaGJhbmcgVVJMLCByZW1vdmUgdGhlXHJcbiAgICAvLyAnYmFuZycgKHRoZSBoYXNoIHdhcyByZW1vdmVkIGFscmVhZHkpXHJcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXiEvLCAnJyk7XHJcblxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG5cclxuLyoqXHJcbiAgICBUcmFja3MgdGhlIGxhdGVzdCBVUkxcclxuICAgIGJlaW5nIHB1c2hlZCBvciByZXBsYWNlZCBieVxyXG4gICAgdGhlIEFQSS5cclxuICAgIFRoaXMgYWxsb3dzIGxhdGVyIHRvIGF2b2lkXHJcbiAgICB0cmlnZ2VyIHRoZSBwb3BzdGF0ZSBldmVudCxcclxuICAgIHNpbmNlIG11c3QgTk9UIGJlIHRyaWdnZXJlZFxyXG4gICAgYXMgYSByZXN1bHQgb2YgdGhhdCBBUEkgbWV0aG9kc1xyXG4qKi9cclxudmFyIGxhdGVzdFB1c2hlZFJlcGxhY2VkVXJsID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gICAgSGlzdG9yeSBQb2x5ZmlsbFxyXG4qKi9cclxudmFyIGhhc2hiYW5nSGlzdG9yeSA9IHtcclxuICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKSB7XHJcblxyXG4gICAgICAgIC8vIGNsZWFudXAgdXJsXHJcbiAgICAgICAgdXJsID0gY2Fubm9uaWNhbFVybCh1cmwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHNhdmUgbmV3IHN0YXRlIGZvciB1cmxcclxuICAgICAgICBzdGF0ZSA9IGNoZWNrU3RhdGUoc3RhdGUpIHx8IG51bGw7XHJcbiAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgc3RhdGVcclxuICAgICAgICAgICAgc2Vzc2lvbi5zdGF0ZXMucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciBzdWlkID0gc2Vzc2lvbi5zdGF0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIFVSTCB3aXRoIHRoZSBzdWlkXHJcbiAgICAgICAgICAgIHVybCA9IHNldFN1aWQodXJsLCBzdWlkKTtcclxuICAgICAgICAgICAgLy8gY2FsbCB0byBwZXJzaXN0IHRoZSB1cGRhdGVkIHNlc3Npb25cclxuICAgICAgICAgICAgcGVyc2lzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsYXRlc3RQdXNoZWRSZXBsYWNlZFVybCA9IHVybDtcclxuICAgICAgICBcclxuICAgICAgICAvLyB1cGRhdGUgbG9jYXRpb24gdG8gdHJhY2sgaGlzdG9yeTpcclxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMhJyArIHVybDtcclxuICAgIH0sXHJcbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGNsZWFudXAgdXJsXHJcbiAgICAgICAgdXJsID0gY2Fubm9uaWNhbFVybCh1cmwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGl0IGhhcyBzYXZlZCBzdGF0ZT9cclxuICAgICAgICB2YXIgc3VpZCA9IGdldFN1aWQodXJsKSxcclxuICAgICAgICAgICAgaGFzT2xkU3RhdGUgPSBzdWlkICE9PSBudWxsO1xyXG5cclxuICAgICAgICAvLyBzYXZlIG5ldyBzdGF0ZSBmb3IgdXJsXHJcbiAgICAgICAgc3RhdGUgPSBjaGVja1N0YXRlKHN0YXRlKSB8fCBudWxsO1xyXG4gICAgICAgIC8vIGl0cyBzYXZlZCBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdG8gc2F2ZVxyXG4gICAgICAgIC8vIG9yIHNvbWV0aGluZyB0byBkZXN0cm95XHJcbiAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsIHx8IGhhc09sZFN0YXRlKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgc3RhdGVcclxuICAgICAgICAgICAgaWYgKGhhc09sZFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGV4aXN0aW5nIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnN0YXRlc1tzdWlkXSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVybCByZW1haW5zIHRoZSBzYW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgc3RhdGVcclxuICAgICAgICAgICAgICAgIHNlc3Npb24uc3RhdGVzLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgc3VpZCA9IHNlc3Npb24uc3RhdGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgVVJMIHdpdGggdGhlIHN1aWRcclxuICAgICAgICAgICAgICAgIHVybCA9IHNldFN1aWQodXJsLCBzdWlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxsIHRvIHBlcnNpc3QgdGhlIHVwZGF0ZWQgc2Vzc2lvblxyXG4gICAgICAgICAgICBwZXJzaXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGxhdGVzdFB1c2hlZFJlcGxhY2VkVXJsID0gdXJsO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbG9jYXRpb24gdG8gdHJhY2sgaGlzdG9yeTpcclxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMhJyArIHVybDtcclxuICAgIH0sXHJcbiAgICBnZXQgc3RhdGUoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN1aWQgPSBnZXRTdWlkKGxvY2F0aW9uLmhhc2gpO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHN1aWQgIT09IG51bGwgP1xyXG4gICAgICAgICAgICBzZXNzaW9uLnN0YXRlc1tzdWlkXSA6XHJcbiAgICAgICAgICAgIG51bGxcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5Lmxlbmd0aDtcclxuICAgIH0sXHJcbiAgICBnbzogZnVuY3Rpb24gZ28ob2Zmc2V0KSB7XHJcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuZ28ob2Zmc2V0KTtcclxuICAgIH0sXHJcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcclxuICAgIH0sXHJcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEF0dGFjaCBoYXNoY2FuZ2UgZXZlbnQgdG8gdHJpZ2dlciBIaXN0b3J5IEFQSSBldmVudCAncG9wc3RhdGUnXHJcbnZhciAkdyA9ICQod2luZG93KTtcclxuJHcub24oJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbihlKSB7XHJcbiAgICBcclxuICAgIHZhciB1cmwgPSBlLm9yaWdpbmFsRXZlbnQubmV3VVJMO1xyXG4gICAgdXJsID0gY2Fubm9uaWNhbFVybCh1cmwpO1xyXG4gICAgXHJcbiAgICAvLyBBbiBVUkwgYmVpbmcgcHVzaGVkIG9yIHJlcGxhY2VkXHJcbiAgICAvLyBtdXN0IE5PVCB0cmlnZ2VyIHBvcHN0YXRlXHJcbiAgICBpZiAodXJsID09PSBsYXRlc3RQdXNoZWRSZXBsYWNlZFVybClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBcclxuICAgIC8vIGdldCBzdGF0ZSBmcm9tIGhpc3RvcnkgZW50cnlcclxuICAgIC8vIGZvciB0aGUgdXBkYXRlZCBVUkwsIGlmIGFueVxyXG4gICAgLy8gKGNhbiBoYXZlIHZhbHVlIHdoZW4gdHJhdmVyc2luZ1xyXG4gICAgLy8gaGlzdG9yeSkuXHJcbiAgICB2YXIgc3VpZCA9IGdldFN1aWQodXJsKSxcclxuICAgICAgICBzdGF0ZSA9IG51bGw7XHJcbiAgICBcclxuICAgIGlmIChzdWlkICE9PSBudWxsKVxyXG4gICAgICAgIHN0YXRlID0gc2Vzc2lvbi5zdGF0ZXNbc3VpZF07XHJcblxyXG4gICAgJHcudHJpZ2dlcihuZXcgJC5FdmVudCgncG9wc3RhdGUnLCB7XHJcbiAgICAgICAgc3RhdGU6IHN0YXRlXHJcbiAgICB9KSwgJ2hhc2hiYW5nSGlzdG9yeScpO1xyXG59KTtcclxuXHJcbi8vIEZvciBIaXN0b3J5QVBJIGNhcGFibGUgYnJvd3NlcnMsIHdlIG5lZWRcclxuLy8gdG8gY2FwdHVyZSB0aGUgbmF0aXZlICdwb3BzdGF0ZScgZXZlbnQgdGhhdFxyXG4vLyBnZXRzIHRyaWdnZXJlZCBvbiBvdXIgcHVzaC9yZXBsYWNlU3RhdGUgYmVjYXVzZVxyXG4vLyBvZiB0aGUgbG9jYXRpb24gY2hhbmdlLCBidXQgdG9vIG9uIHRyYXZlcnNpbmdcclxuLy8gdGhlIGhpc3RvcnkgKGJhY2svZm9yd2FyZCkuXHJcbi8vIFdlIHdpbGwgbG9jayB0aGUgZXZlbnQgZXhjZXB0IHdoZW4gaXNcclxuLy8gdGhlIG9uZSB3ZSB0cmlnZ2VyLlxyXG4vL1xyXG4vLyBOT1RFOiB0byB0aGlzIHRyaWNrIHRvIHdvcmssIHRoaXMgbXVzdFxyXG4vLyBiZSB0aGUgZmlyc3QgaGFuZGxlciBhdHRhY2hlZCBmb3IgdGhpc1xyXG4vLyBldmVudCwgc28gY2FuIGJsb2NrIGFsbCBvdGhlcnMuXHJcbi8vIEFMVEVSTkFUSVZFOiBpbnN0ZWFkIG9mIHRoaXMsIG9uIHRoZVxyXG4vLyBwdXNoL3JlcGxhY2VTdGF0ZSBtZXRob2RzIGRldGVjdCBpZlxyXG4vLyBIaXN0b3J5QVBJIGlzIG5hdGl2ZSBzdXBwb3J0ZWQgYW5kXHJcbi8vIHVzZSByZXBsYWNlU3RhdGUgdGhlcmUgcmF0aGVyIHRoYW5cclxuLy8gYSBoYXNoIGNoYW5nZS5cclxuJHcub24oJ3BvcHN0YXRlJywgZnVuY3Rpb24oZSwgc291cmNlKSB7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyaW5nIGlzIHRoZSBvbmUgd2UgdHJpZ2dlclxyXG4gICAgaWYgKHNvdXJjZSA9PT0gJ2hhc2hiYW5nSGlzdG9yeScpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAvLyBJbiBvdGhlciBjYXNlLCBibG9jazpcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbn0pO1xyXG5cclxuLy8gRXhwb3NlIEFQSVxyXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hiYW5nSGlzdG9yeTtcclxuIiwiLyoqXHJcbiAgICBEZWZhdWx0IGJ1aWxkIG9mIHRoZSBTaGVsbCBjb21wb25lbnQuXHJcbiAgICBJdCByZXR1cm5zIHRoZSBTaGVsbCBjbGFzcyBhcyBhIG1vZHVsZSBwcm9wZXJ0eSxcclxuICAgIHNldHRpbmcgdXAgdGhlIGJ1aWx0LWluIG1vZHVsZXMgYXMgaXRzIGRlcGVuZGVuY2llcyxcclxuICAgIGFuZCB0aGUgZXh0ZXJuYWwgJ2pxdWVyeScgYW5kICdldmVudHMnIChmb3IgdGhlIEV2ZW50RW1pdHRlcikuXHJcbiAgICBJdCByZXR1cm5zIHRvbyB0aGUgYnVpbHQtaXQgRG9tSXRlbXNNYW5hZ2VyIGNsYXNzIGFzIGEgcHJvcGVydHkgZm9yIGNvbnZlbmllbmNlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlcHMgPSByZXF1aXJlKCcuL2RlcGVuZGVuY2llcycpLFxyXG4gICAgRG9tSXRlbXNNYW5hZ2VyID0gcmVxdWlyZSgnLi9Eb21JdGVtc01hbmFnZXInKSxcclxuICAgIHBhcnNlVXJsID0gcmVxdWlyZSgnLi9wYXJzZVVybCcpLFxyXG4gICAgYWJzb2x1dGl6ZVVybCA9IHJlcXVpcmUoJy4vYWJzb2x1dGl6ZVVybCcpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgbG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxuXHJcbiQuZXh0ZW5kKGRlcHMsIHtcclxuICAgIHBhcnNlVXJsOiBwYXJzZVVybCxcclxuICAgIGFic29sdXRpemVVcmw6IGFic29sdXRpemVVcmwsXHJcbiAgICBqcXVlcnk6ICQsXHJcbiAgICBsb2FkZXI6IGxvYWRlcixcclxuICAgIEV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyXHJcbn0pO1xyXG5cclxuLy8gRGVwZW5kZW5jaWVzIGFyZSByZWFkeSwgd2UgY2FuIGxvYWQgdGhlIGNsYXNzOlxyXG52YXIgU2hlbGwgPSByZXF1aXJlKCcuL1NoZWxsJyk7XHJcblxyXG5leHBvcnRzLlNoZWxsID0gU2hlbGw7XHJcbmV4cG9ydHMuRG9tSXRlbXNNYW5hZ2VyID0gRG9tSXRlbXNNYW5hZ2VyO1xyXG4iLCIvKipcclxuICAgIExvYWRlciB1dGlsaXR5IHRvIGxvYWQgU2hlbGwgaXRlbXMgb24gZGVtYW5kIHdpdGggQUpBWFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBiYXNlVXJsOiAnLycsXHJcbiAgICBcclxuICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQocm91dGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTaGVsbCBsb2FkaW5nIG9uIGRlbWFuZCcsIHJvdXRlLm5hbWUsIHJvdXRlKTtcclxuICAgICAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgICAgICAgIHVybDogbW9kdWxlLmV4cG9ydHMuYmFzZVVybCArIHJvdXRlLm5hbWUgKyAnLmh0bWwnLFxyXG4gICAgICAgICAgICAgICAgY2FjaGU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgbG9hZGluZyB0aGUgcHJvZ3JhbSBhbmQgbm8gbG9hZGVyIHNjcmVlbiBpbiBwbGFjZSxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGFueSBpbiBiZXR3ZWVuIGludGVyYWN0aW9uIHdpbGwgYmUgcHJvYmxlbWF0aWMuXHJcbiAgICAgICAgICAgICAgICAvL2FzeW5jOiBmYWxzZVxyXG4gICAgICAgICAgICB9KS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgcGFyc2VVcmwgZnVuY3Rpb24gZGV0ZWN0aW5nXHJcbiAgICB0aGUgbWFpbiBwYXJ0cyBvZiB0aGUgVVJMIGluIGFcclxuICAgIGNvbnZlbmllbmNlIHdheSBmb3Igcm91dGluZy5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBnZXRVcmxRdWVyeSA9IHJlcXVpcmUoJy4uL2dldFVybFF1ZXJ5JyksXHJcbiAgICBlc2NhcGVSZWdFeHAgPSByZXF1aXJlKCcuLi9lc2NhcGVSZWdFeHAnKTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlVXJsKGJhc2VVcmwsIGxpbmspIHtcclxuXHJcbiAgICBsaW5rID0gbGluayB8fCAnJztcclxuXHJcbiAgICB2YXIgcmF3VXJsID0gbGluaztcclxuXHJcbiAgICAvLyBoYXNoYmFuZyBzdXBwb3J0OiByZW1vdmUgdGhlICMhIG9yIHNpbmdsZSAjIGFuZCB1c2UgdGhlIHJlc3QgYXMgdGhlIGxpbmtcclxuICAgIGxpbmsgPSBsaW5rLnJlcGxhY2UoL14jIS8sICcnKS5yZXBsYWNlKC9eIy8sICcnKTtcclxuICAgIFxyXG4gICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGluaXRpYWwgc2xhc2ggb3IgZG90LXNsYXNoXHJcbiAgICBsaW5rID0gbGluay5yZXBsYWNlKC9eXFwvfF5cXC5cXC8vLCAnJyk7XHJcblxyXG4gICAgLy8gVVJMIFF1ZXJ5IGFzIGFuIG9iamVjdCwgZW1wdHkgb2JqZWN0IGlmIG5vIHF1ZXJ5XHJcbiAgICB2YXIgcXVlcnkgPSBnZXRVcmxRdWVyeShsaW5rIHx8ICc/Jyk7XHJcblxyXG4gICAgLy8gcmVtb3ZlIHF1ZXJ5IGZyb20gdGhlIHJlc3Qgb2YgVVJMIHRvIHBhcnNlXHJcbiAgICBsaW5rID0gbGluay5yZXBsYWNlKC9cXD8uKiQvLCAnJyk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSBiYXNlVXJsIHRvIGdldCB0aGUgYXBwIGJhc2UuXHJcbiAgICB2YXIgcGF0aCA9IGxpbmsucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGVzY2FwZVJlZ0V4cChiYXNlVXJsKSwgJ2knKSwgJycpO1xyXG5cclxuICAgIC8vIEdldCBmaXJzdCBzZWdtZW50IG9yIHBhZ2UgbmFtZSAoYW55dGhpbmcgdW50aWwgYSBzbGFzaCBvciBleHRlbnNpb24gYmVnZ2luaW5nKVxyXG4gICAgdmFyIG1hdGNoID0gL15cXC8/KFteXFwvXFwuXSspW15cXC9dKihcXC8uKikqJC8uZXhlYyhwYXRoKTtcclxuXHJcbiAgICB2YXIgcGFyc2VkID0ge1xyXG4gICAgICAgIHJvb3Q6IHRydWUsXHJcbiAgICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgICBzZWdtZW50czogbnVsbCxcclxuICAgICAgICBwYXRoOiBudWxsLFxyXG4gICAgICAgIHVybDogcmF3VXJsLFxyXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBwYXJzZWQucm9vdCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBwYXJzZWQubmFtZSA9IG1hdGNoWzFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aCA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlZ21lbnRzID0gbWF0Y2hbMl0ucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGggPSAnLyc7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyc2VkO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVXJsOyIsIi8qKlxyXG4gICAgc2FuaXRpemVVcmwgdXRpbGl0eSB0aGF0IGVuc3VyZXNcclxuICAgIHRoYXQgcHJvYmxlbWF0aWMgcGFydHMgZ2V0IHJlbW92ZWQuXHJcbiAgICBcclxuICAgIEFzIGZvciBub3cgaXQgZG9lczpcclxuICAgIC0gcmVtb3ZlcyBwYXJlbnQgZGlyZWN0b3J5IHN5bnRheFxyXG4gICAgLSByZW1vdmVzIGR1cGxpY2F0ZWQgc2xhc2hlc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XHJcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLnsyLH0vZywgJycpLnJlcGxhY2UoL1xcL3syLH0vZywgJy8nKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzYW5pdGl6ZVVybDsiLCIvKipcclxuICAgIFNtYWxsIHV0aWxpdHkgdG8gc2VhcmNoIGEgdGV4dCBmcmFnbWVudCB1c2luZ1xyXG4gICAgY2FzZSBpbnNlbnNpdGl2ZSwgYWNjZW50L3N5bWJvbCBpbnNlbnNpdGl2ZS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciByZW1vdmVBY2NlbnQgPSByZXF1aXJlKCcuL3JlbW92ZUFjY2VudCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0U2VhcmNoKHNlYXJjaCwgdGV4dCkge1xyXG5cclxuICAgIHZhciBzID0gcmVtb3ZlQWNjZW50KHNlYXJjaCB8fCAnJykudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICB0ID0gcmVtb3ZlQWNjZW50KHRleHQgfHwgJycpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgcmV0dXJuIHQuaW5kZXhPZihzKSA+IC0xO1xyXG59O1xyXG4iLCIvKiogXHJcbiAgICBBcHBNb2RlbCBleHRlbnNpb24sXHJcbiAgICBmb2N1c2VkIG9uIHRoZSBBY2NvdW50IHJlbGF0ZWQgQVBJczpcclxuICAgIC0gbG9naW5cclxuICAgIC0gbG9nb3V0XHJcbiAgICAtIHNpZ251cFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKTtcclxuXHJcbmV4cG9ydHMucGx1Z0luID0gZnVuY3Rpb24gKEFwcE1vZGVsKSB7XHJcbiAgICAvKipcclxuICAgICAgICBUcnkgdG8gcGVyZm9ybSBhbiBhdXRvbWF0aWMgbG9naW4gaWYgdGhlcmUgaXMgYSBsb2NhbFxyXG4gICAgICAgIGNvcHkgb2YgY3JlZGVudGlhbHMgdG8gdXNlIG9uIHRoYXQsXHJcbiAgICAgICAgY2FsbGluZyB0aGUgbG9naW4gbWV0aG9kIHRoYXQgc2F2ZSB0aGUgdXBkYXRlZFxyXG4gICAgICAgIGRhdGEgYW5kIHByb2ZpbGUuXHJcbiAgICAqKi9cclxuICAgIEFwcE1vZGVsLnByb3RvdHlwZS50cnlMb2dpbiA9IGZ1bmN0aW9uIHRyeUxvZ2luKCkge1xyXG4gICAgICAgIC8vIEdldCBzYXZlZCBjcmVkZW50aWFsc1xyXG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCdjcmVkZW50aWFscycpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oY3JlZGVudGlhbHMpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBvbmVzLCB0cnkgdG8gbG9nLWluXHJcbiAgICAgICAgICAgIGlmIChjcmVkZW50aWFscykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCBsb2dpbiB3aXRoIHRoYXRcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ2luKFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLnBhc3N3b3JkXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzYXZlZCBjcmVkZW50aWFscycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgUGVyZm9ybXMgYSBsb2dpbiBhdHRlbXB0IHdpdGggdGhlIEFQSSBieSB1c2luZ1xyXG4gICAgICAgIHRoZSBwcm92aWRlZCBjcmVkZW50aWFscy5cclxuICAgICoqL1xyXG4gICAgQXBwTW9kZWwucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24gbG9naW4odXNlcm5hbWUsIHBhc3N3b3JkKSB7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBleHRyYSBoZWFkZXJzIHRvIGF0dGVtcHQgdGhlIGxvZ2luXHJcbiAgICAgICAgdGhpcy5yZXN0LmV4dHJhSGVhZGVycyA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3QucG9zdCgnbG9naW4nLCB7XHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxyXG4gICAgICAgICAgICByZXR1cm5Qcm9maWxlOiB0cnVlXHJcbiAgICAgICAgfSkudGhlbihwZXJmb3JtTG9jYWxMb2dpbih0aGlzLCB1c2VybmFtZSwgcGFzc3dvcmQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgUGVyZm9ybXMgYSBsb2dvdXQsIHJlbW92aW5nIGNhY2hlZCBjcmVkZW50aWFsc1xyXG4gICAgICAgIGFuZCBwcm9maWxlIHNvIHRoZSBhcHAgY2FuIGJlIGZpbGxlZCB1cCB3aXRoXHJcbiAgICAgICAgbmV3IHVzZXIgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgSXQgY2FsbHMgdG8gdGhlIEFQSSBsb2dvdXQgY2FsbCB0b28sIHRvIHJlbW92ZVxyXG4gICAgICAgIGFueSBzZXJ2ZXItc2lkZSBzZXNzaW9uIGFuZCBub3RpZmljYXRpb25cclxuICAgICAgICAocmVtb3ZlcyB0aGUgY29va2llIHRvbywgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRcclxuICAgICAgICB0aGF0IG1heSB1c2UgaXQpLlxyXG4gICAgKiovXHJcbiAgICAvLyBGVVRVUkU6IFRPUkVWSUVXIGlmIHRoZSAvbG9nb3V0IGNhbGwgY2FuIGJlIHJlbW92ZWQuXHJcbiAgICBBcHBNb2RlbC5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gbG9nb3V0KCkge1xyXG5cclxuICAgICAgICAvLyBMb2NhbCBhcHAgY2xvc2Ugc2Vzc2lvblxyXG4gICAgICAgIHRoaXMucmVzdC5leHRyYUhlYWRlcnMgPSBudWxsO1xyXG4gICAgICAgIGxvY2FsZm9yYWdlLnJlbW92ZUl0ZW0oJ2NyZWRlbnRpYWxzJyk7XHJcbiAgICAgICAgbG9jYWxmb3JhZ2UucmVtb3ZlSXRlbSgncHJvZmlsZScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExvY2FsIGRhdGEgY2xlYW4tdXAhXHJcbiAgICAgICAgdGhpcy5jbGVhckxvY2FsRGF0YSgpO1xyXG5cclxuICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdhaXQgdGhlIHJlc3VsdCBvZiB0aGUgUkVTVCBvcGVyYXRpb25cclxuICAgICAgICB0aGlzLnJlc3QucG9zdCgnbG9nb3V0Jyk7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgQXR0ZW1wdHMgdG8gY3JlYXRlIGEgdXNlciBhY2NvdW50LCBnZXR0aW5nIGxvZ2dlZFxyXG4gICAgICAgIGlmIHN1Y2Nlc3NmdWxseSBsaWtlIHdoZW4gZG9pbmcgYSBsb2dpbiBjYWxsLlxyXG4gICAgKiovXHJcbiAgICBBcHBNb2RlbC5wcm90b3R5cGUuc2lnbnVwID0gZnVuY3Rpb24gc2lnbnVwKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvZmlsZVR5cGUpIHtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIGV4dHJhIGhlYWRlcnMgdG8gYXR0ZW1wdCB0aGUgc2lnbnVwXHJcbiAgICAgICAgdGhpcy5yZXN0LmV4dHJhSGVhZHJlcyA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFRoZSByZXN1bHQgaXMgdGhlIHNhbWUgYXMgaW4gYSBsb2dpbiwgYW5kXHJcbiAgICAgICAgLy8gd2UgZG8gdGhlIHNhbWUgYXMgdGhlcmUgdG8gZ2V0IHRoZSB1c2VyIGxvZ2dlZFxyXG4gICAgICAgIC8vIG9uIHRoZSBhcHAgb24gc2lnbi11cCBzdWNjZXNzLlxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3QucG9zdCgnc2lnbnVwP3V0bV9zb3VyY2U9YXBwJywge1xyXG4gICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcclxuICAgICAgICAgICAgcHJvZmlsZVR5cGU6IHByb2ZpbGVUeXBlLFxyXG4gICAgICAgICAgICByZXR1cm5Qcm9maWxlOiB0cnVlXHJcbiAgICAgICAgfSkudGhlbihwZXJmb3JtTG9jYWxMb2dpbih0aGlzLCB1c2VybmFtZSwgcGFzc3dvcmQpKTtcclxuICAgIH07XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwZXJmb3JtTG9jYWxMb2dpbih0aGlzQXBwTW9kZWwsIHVzZXJuYW1lLCBwYXNzd29yZCkge1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihsb2dnZWQpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZW1vdmUgYW55IHByZXZpb3VzIGxvY2FsIGRhdGEgaWYgYW55OlxyXG4gICAgICAgIHJldHVybiB0aGlzQXBwTW9kZWwuY2xlYXJMb2NhbERhdGEoKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gdXNlIGF1dGhvcml6YXRpb24ga2V5IGZvciBlYWNoXHJcbiAgICAgICAgICAgIC8vIG5ldyBSZXN0IHJlcXVlc3RcclxuICAgICAgICAgICAgdGhpc0FwcE1vZGVsLnJlc3QuZXh0cmFIZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgYWx1OiBsb2dnZWQudXNlcklELFxyXG4gICAgICAgICAgICAgICAgYWxrOiBsb2dnZWQuYXV0aEtleVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gYXN5bmMgbG9jYWwgc2F2ZSwgZG9uJ3Qgd2FpdFxyXG4gICAgICAgICAgICBsb2NhbGZvcmFnZS5zZXRJdGVtKCdjcmVkZW50aWFscycsIHtcclxuICAgICAgICAgICAgICAgIHVzZXJJRDogbG9nZ2VkLnVzZXJJRCxcclxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcclxuICAgICAgICAgICAgICAgIGF1dGhLZXk6IGxvZ2dlZC5hdXRoS2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IExvY2FsIG5hbWUga2VwdCBpbiBzeW5jIHdpdGggc2V0LXVwIGF0IEFwcE1vZGVsLnVzZXJQcm9maWxlXHJcbiAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0oJ3Byb2ZpbGUnLCBsb2dnZWQucHJvZmlsZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdXNlciBkYXRhXHJcbiAgICAgICAgICAgIHRoaXNBcHBNb2RlbC51c2VyKCkubW9kZWwudXBkYXRlV2l0aChsb2dnZWQucHJvZmlsZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4iLCIvKipcclxuICAgIEFwcG9pbnRtZW50cyBpcyBhbiBhYnN0cmFjdGlvbiBhcm91bmQgY2FsZW5kYXIgZXZlbnRzXHJcbiAgICB0aGF0IGJlaGF2ZSBhcyBib29raW5ncyBvciBhcyBldmVudHMgKHdoZXJlIGJvb2tpbmdzIGFyZSBidWlsdFxyXG4gICAgb24gdG9wIG9mIGFuIGV2ZW50IGluc3RhbmNlIC0tYSBib29raW5nIHJlY29yZCBtdXN0IGhhdmUgZXZlciBhIGNvbmZpcm1lZERhdGVJRCBldmVudCkuXHJcbiAgICBcclxuICAgIFdpdGggdGhpcyBhcHBNb2RlbCwgdGhlIEFQSXMgdG8gbWFuYWdlIGV2ZW50cyZib29raW5ncyBhcmUgY29tYmluZWQgdG8gb2ZmZXIgcmVsYXRlZFxyXG4gICAgcmVjb3JkcyBlYXNpZXIgaW4gQXBwb2ludG1lbnRzIG9iamVjdHMuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuXHJcbiAgICB2YXIgYXBpID0ge307XHJcbiAgICBcclxuICAgIHZhciBjYWNoZSA9IHtcclxuICAgICAgICBhcHRzQnlEYXRlOiB7fVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIGNhY2hlLmFwdHNCeURhdGUgPSB7fTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgYSBnZW5lcmljIGNhbGVuZGFyIGFwcG9pbnRtZW50IG9iamVjdCwgbWFkZSBvZiBldmVudHMgYW5kL29yIGJvb2tpbmdzLFxyXG4gICAgICAgIGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gSUQgaW4gdGhlIGlkcyBvYmplY3QuXHJcbiAgICAgICAgXHJcbiAgICAgICAgVE9ETzogSW1wbGVtZW50IGNhY2hlIGZvciB0aGUgQXBwb2ludG1lbnQgTW9kZWxzICh0aGUgYmFjay1lbmQgbW9kZWxzIGZvclxyXG4gICAgICAgIGJvb2tpbmdzIGFuZCBldmVudHMgaXMgYWxyZWFkeSBtYW5hZ2VkIGJ5IGl0cyBvd24gQVBJKS5cclxuICAgICoqL1xyXG4gICAgYXBpLmdldEFwcG9pbnRtZW50ID0gZnVuY3Rpb24gZ2V0QXBwb2ludG1lbnQoaWRzKSB7XHJcblxyXG4gICAgICAgIGlmIChpZHMuY2FsZW5kYXJFdmVudElEKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5jYWxlbmRhckV2ZW50cy5nZXRFdmVudChpZHMuY2FsZW5kYXJFdmVudElEKVxyXG4gICAgICAgICAgICAudGhlbihBcHBvaW50bWVudC5mcm9tQ2FsZW5kYXJFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlkcy5ib29raW5nSUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmJvb2tpbmdzLmdldEJvb2tpbmcoaWRzLmJvb2tpbmdJRClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYm9va2luZykge1xyXG4gICAgICAgICAgICAgICAgLy8gQW4gYXBwb2ludG1lbnQgZm9yIGJvb2tpbmcgbmVlZHMgdGhlIGNvbmZpcm1lZCBldmVudCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLmdldEV2ZW50KGJvb2tpbmcuY29uZmlybWVkRGF0ZUlEKCkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tQm9va2luZyhib29raW5nLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1VucmVjb2duaXplZCBJRCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5zZXRBcHBvaW50bWVudCA9IGZ1bmN0aW9uIHNldEFwcG9pbnRtZW50KGFwdCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIGlzIGEgYm9va2luZ1xyXG4gICAgICAgIGlmIChhcHQuc291cmNlQm9va2luZygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5ib29raW5ncy5zZXRCb29raW5nKGFwdClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYm9va2luZykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0aGUgZXZlbnQgaW5mb3JtYXRpb24gdG9vXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuZ2V0RXZlbnQoYm9va2luZy5jb25maXJtZWREYXRlSUQoKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFwcG9pbnRtZW50LmZyb21Cb29raW5nKGJvb2tpbmcsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXB0LnNvdXJjZUV2ZW50KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLnNldEV2ZW50KGFwdClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBhcHBvaW50bWVudCBvYmplY3QnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IGEgbGlzdCBvZiBnZW5lcmljIGNhbGVuZGFyIGFwcG9pbnRtZW50IG9iamVjdHMsIG1hZGUgb2YgZXZlbnRzIGFuZC9vciBib29raW5nc1xyXG4gICAgICAgIGJ5IERhdGUuXHJcbiAgICAgICAgSXQncyBjYWNoZWQuXHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXRBcHBvaW50bWVudHNCeURhdGUgPSBmdW5jdGlvbiBnZXRBcHBvaW50bWVudHNCeURhdGUoZGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXRlS2V5ID0gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWU1NREQnKTtcclxuICAgICAgICBpZiAoY2FjaGUuYXB0c0J5RGF0ZS5oYXNPd25Qcm9wZXJ0eShkYXRlS2V5KSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZS5hcHRzQnlEYXRlW2RhdGVLZXldLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBsYXp5IGxvYWQsIG9uIGJhY2tncm91bmQsIGZvciBzeW5jaHJvbml6YXRpb24sIGRlcGVuZGluZyBvbiBjYWNoZSBjb250cm9sXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIGxvY2FsZm9yYWdlIGNvcHkgZmlyc3Q/XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdGUgbG9hZGluZyBkYXRhXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICBhcHBNb2RlbC5ib29raW5ncy5nZXRCb29raW5nc0J5RGF0ZShkYXRlKSxcclxuICAgICAgICAgICAgICAgIGFwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLmdldEV2ZW50c0J5RGF0ZShkYXRlKVxyXG4gICAgICAgICAgICBdKS50aGVuKGZ1bmN0aW9uKGdyb3VwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IGdyb3VwWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvb2tpbmdzID0gZ3JvdXBbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgYXB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXB0cyA9IEFwcG9pbnRtZW50Lmxpc3RGcm9tQ2FsZW5kYXJFdmVudHNCb29raW5ncyhldmVudHMoKSwgYm9va2luZ3MoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gbG9jYWxmb3JhZ2UgY29weSBvZiBbZGF0ZUtleV09Ym9va2luZ3NcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gUHV0IGluIGNhY2hlXHJcbiAgICAgICAgICAgICAgICBjYWNoZS5hcHRzQnlEYXRlW2RhdGVLZXldID0geyBkYXRhOiBhcHRzIH07XHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXB0cztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgSW50cm9kdWNlIGZyZWUgc2xvdHMgd2hlcmV2ZXIgbmVlZGVkIGluIHRoZSBnaXZlblxyXG4gICAgICAgIGFycmF5IG9mIEFwcG9pbnRtZW50cywgdG8gZmlsbCBhbnkgZ2FwIGluIGEgbmF0dXJhbCBkYXlcclxuICAgICAgICAoZnJvbSBNaWRuaWdodCB0byBNaWRuaWdodCBuZXh0IGRhdGUpLlxyXG4gICAgICAgIEEgbmV3IGFycmF5IGlzIHJldHVybmVkLCBidXQgdGhlIG9yaWdpbmFsIGdldHMgc29ydGVkIFxyXG4gICAgICAgIGJ5IHN0YXJ0VGltZS5cclxuICAgICoqL1xyXG4gICAgYXBpLmZpbGxXaXRoRnJlZVNsb3RzID0gZnVuY3Rpb24gZmlsbFdpdGhGcmVlU2xvdHMoYXBwb2ludG1lbnRzTGlzdCkge1xyXG5cclxuICAgICAgICAvLyBGaXJzdCwgZW5zdXJlIGxpc3QgaXMgc29ydGVkXHJcbiAgICAgICAgdmFyIHNsb3RzID0gYXBwb2ludG1lbnRzTGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnRUaW1lKCkgPiBiLnN0YXJ0VGltZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgZmlsbGVkU2xvdHMgPSBbXSxcclxuICAgICAgICAgICAgemVyb1RpbWUgPSAnMDA6MDA6MDAnLFxyXG4gICAgICAgICAgICBsYXN0ID0gemVyb1RpbWUsXHJcbiAgICAgICAgICAgIGxhc3REYXRlVGltZSA9IG51bGwsXHJcbiAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAnSEg6bW06c3MnO1xyXG5cclxuICAgICAgICBzbG90cy5mb3JFYWNoKGZ1bmN0aW9uKHNsb3QpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2xvdC5zdGFydFRpbWUoKSxcclxuICAgICAgICAgICAgICAgIHMgPSBtb21lbnQoc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgZW5kID0gc2xvdC5lbmRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICBlID0gbW9tZW50KGVuZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocy5mb3JtYXQodGltZUZvcm1hdCkgPiBsYXN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3REYXRlVGltZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHNsb3Qgb2YgdGhlIGRhdGUsIDEyQU09MDA6MDBcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RGF0ZVRpbWUgPSBuZXcgRGF0ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQuZ2V0RnVsbFllYXIoKSwgc3RhcnQuZ2V0TW9udGgoKSwgc3RhcnQuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGdhcCwgZmlsbGVkIGl0XHJcbiAgICAgICAgICAgICAgICBmaWxsZWRTbG90cy5wdXNoKEFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90KHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogbGFzdERhdGVUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc3RhcnRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmlsbGVkU2xvdHMucHVzaChzbG90KTtcclxuICAgICAgICAgICAgbGFzdERhdGVUaW1lID0gZW5kO1xyXG4gICAgICAgICAgICBsYXN0ID0gZS5mb3JtYXQodGltZUZvcm1hdCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGxhdGVzdCB0byBzZWUgYSBnYXAgYXQgdGhlIGVuZDpcclxuICAgICAgICB2YXIgbGFzdEVuZCA9IGxhc3REYXRlVGltZSAmJiBtb21lbnQobGFzdERhdGVUaW1lKS5mb3JtYXQodGltZUZvcm1hdCk7XHJcbiAgICAgICAgaWYgKGxhc3RFbmQgIT09IHplcm9UaW1lKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgZ2FwLCBmaWxsZWQgaXRcclxuICAgICAgICAgICAgdmFyIG5leHRNaWRuaWdodCA9IG5ldyBEYXRlKFxyXG4gICAgICAgICAgICAgICAgbGFzdERhdGVUaW1lLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgICAgICBsYXN0RGF0ZVRpbWUuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgICAgIC8vIE5leHQgZGF0ZSFcclxuICAgICAgICAgICAgICAgIGxhc3REYXRlVGltZS5nZXREYXRlKCkgKyAxLFxyXG4gICAgICAgICAgICAgICAgLy8gQXQgemVybyBob3VycyFcclxuICAgICAgICAgICAgICAgIDAsIDAsIDBcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGZpbGxlZFNsb3RzLnB1c2goQXBwb2ludG1lbnQubmV3RnJlZVNsb3Qoe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3REYXRlVGltZSxcclxuICAgICAgICAgICAgICAgIGVuZDogbmV4dE1pZG5pZ2h0XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmaWxsZWRTbG90cztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBhcGk7XHJcbn07XHJcbiIsIi8qKiBCb29raW5nc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEJvb2tpbmcgPSByZXF1aXJlKCcuLi9tb2RlbHMvQm9va2luZycpLFxyXG4vLyAgYXBpSGVscGVyID0gcmVxdWlyZSgnLi4vdXRpbHMvYXBpSGVscGVyJyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcblxyXG4gICAgdmFyIGFwaSA9IHtcclxuICAgICAgICByZW1vdGU6IHtcclxuICAgICAgICAgICAgcmVzdDogYXBwTW9kZWwucmVzdCxcclxuICAgICAgICAgICAgZ2V0Qm9va2luZ3M6IGZ1bmN0aW9uKGZpbHRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnYm9va2luZ3MnLCBmaWx0ZXJzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmF3SXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF3SXRlbXMgJiYgcmF3SXRlbXMubWFwKGZ1bmN0aW9uKHJhd0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29raW5nKHJhd0l0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4vKlxyXG4gICAgYXBpSGVscGVyLmRlZmluZUNydWRBcGlGb3JSZXN0KHtcclxuICAgICAgICBleHRlbmRlZE9iamVjdDogYXBpLnJlbW90ZSxcclxuICAgICAgICBNb2RlbDogQm9va2luZyxcclxuICAgICAgICBtb2RlbE5hbWU6ICdCb29raW5nJyxcclxuICAgICAgICBtb2RlbExpc3ROYW1lOiAnQm9va2luZ3MnLFxyXG4gICAgICAgIG1vZGVsVXJsOiAnYm9va2luZ3MnLFxyXG4gICAgICAgIGlkUHJvcGVydHlOYW1lOiAnYm9va2luZ0lEJ1xyXG4gICAgfSk7Ki9cclxuXHJcbiAgICB2YXIgY2FjaGVCeURhdGUgPSB7fTtcclxuICAgIFxyXG4gICAgYXBpLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIGNhY2hlQnlEYXRlID0ge307XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXBpLmdldEJvb2tpbmdzQnlEYXRlID0gZnVuY3Rpb24gZ2V0Qm9va2luZ3NCeURhdGUoZGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXRlS2V5ID0gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWU1NREQnKTtcclxuICAgICAgICBpZiAoY2FjaGVCeURhdGUuaGFzT3duUHJvcGVydHkoZGF0ZUtleSkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVCeURhdGVbZGF0ZUtleV0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBsYXp5IGxvYWQsIG9uIGJhY2tncm91bmQsIGZvciBzeW5jaHJvbml6YXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgbG9jYWxmb3JhZ2UgY29weSBmaXJzdFxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3RlIGxvYWRpbmcgZGF0YVxyXG4gICAgICAgICAgICByZXR1cm4gYXBpLnJlbW90ZS5nZXRCb29raW5ncyh7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZSxcclxuICAgICAgICAgICAgICAgIGVuZDogbW9tZW50KGRhdGUpLmFkZCgxLCAnZGF5cycpLnRvRGF0ZSgpXHJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oYm9va2luZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gbG9jYWxmb3JhZ2UgY29weSBvZiBbZGF0ZUtleV09Ym9va2luZ3NcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gY2FjaGUgKHRoZXkgYXJlIGFscmVhZHkgbW9kZWwgaW5zdGFuY2VzKVxyXG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IGtvLm9ic2VydmFibGVBcnJheShib29raW5ncyk7XHJcbiAgICAgICAgICAgICAgICBjYWNoZUJ5RGF0ZVtkYXRlS2V5XSA9IGFycjtcclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgb2JzZXJ2YWJsZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IHVwY29taW5nIGJvb2tpbmdzIG1ldGEtaW5mb3JtYXRpb24gZm9yIGRhc2hib2FyZCBwYWdlXHJcbiAgICAgICAgVE9ETzogaW1wbGVtZW50IGNhY2hlPz9cclxuICAgICoqL1xyXG4gICAgYXBpLmdldFVwY29taW5nQm9va2luZ3MgPSBmdW5jdGlvbiBnZXRVcGNvbWluZ0Jvb2tpbmdzKCkge1xyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgndXBjb21pbmctYm9va2luZ3MnKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IGEgc3BlY2lmaWMgYm9va2luZyBieSBJRFxyXG4gICAgICAgIFRPRE86IEltcGxlbWVudCBjYWNoZT8gcmV1c2luZyBjYWNoZUJ5RGF0ZT9cclxuICAgICoqL1xyXG4gICAgYXBpLmdldEJvb2tpbmcgPSBmdW5jdGlvbiBnZXRCb29raW5nKGlkKSB7XHJcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuIFByb21pc2UucmVqZWN0KCdUaGUgYm9va2luZ0lEIGlzIHJlcXVpcmVkIHRvIGdldCBhIGJvb2tpbmcnKTtcclxuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ2Jvb2tpbmdzLycgKyBpZClcclxuICAgICAgICAudGhlbihmdW5jdGlvbihib29raW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9va2luZyhib29raW5nKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIENvbnZlcnRzIGFuIEFwcG9pbnRtZW50IG1vZGVsIGludG8gYSBzaW1wbGlmaWVkXHJcbiAgICAgICAgYm9va2luZyBwbGFpbiBvYmplY3QsIHN1aXRhYmxlIHRvIFJFU1QgQVBJIGZvciBlZGl0aW9uXHJcbiAgICAqKi9cclxuICAgIGFwaS5hcHBvaW50bWVudFRvU2ltcGxpZmllZEJvb2tpbmcgPSBmdW5jdGlvbihhcHQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBib29raW5nSUQ6IGFwdC5zb3VyY2VCb29raW5nKCkuYm9va2luZ0lEKCksXHJcbiAgICAgICAgICAgIGN1c3RvbWVyVXNlcklEOiBhcHQuY3VzdG9tZXJVc2VySUQoKSxcclxuICAgICAgICAgICAgYWRkcmVzc0lEOiBhcHQuYWRkcmVzc0lEKCksXHJcbiAgICAgICAgICAgIHN0YXJ0VGltZTogYXB0LnN0YXJ0VGltZSgpLFxyXG4gICAgICAgICAgICBwcmljaW5nOiBhcHQucHJpY2luZygpLm1hcChmdW5jdGlvbihwcmljaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBmb3Igbm93LCB0aGUgUkVTVCBBUEkgYWxsb3cgb25seSBhIGxpc3Qgb2YgSURzLFxyXG4gICAgICAgICAgICAgICAgLy8gbm90IG9iamVjdHMsIHNvIG5leHQgbGluZSBpcyByZXBsYWNlZDpcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHByaWNpbmcubW9kZWwudG9QbGFpbk9iamVjdCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmljaW5nLmZyZWVsYW5jZXJQcmljaW5nSUQoKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHByZU5vdGVzVG9DbGllbnQ6IGFwdC5wcmVOb3Rlc1RvQ2xpZW50KCksXHJcbiAgICAgICAgICAgIHByZU5vdGVzVG9TZWxmOiBhcHQucHJlTm90ZXNUb1NlbGYoKSxcclxuICAgICAgICAgICAgcG9zdE5vdGVzVG9DbGllbnQ6IGFwdC5wb3N0Tm90ZXNUb0NsaWVudCgpLFxyXG4gICAgICAgICAgICBwb3N0Tm90ZXNUb1NlbGY6IGFwdC5wb3N0Tm90ZXNUb1NlbGYoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgICAgQ29udmVyc3QgYSBCb29raW5nIG1vZGVsIGludG8gYSBzaW1wbGlmaWVkXHJcbiAgICAgICAgYm9va2luZyBwbGFpbiBvYmplY3QsIHN1aXRhYmxlIHRvIFJFU1QgQVBJIGZvciBlZGl0aW9uXHJcbiAgICAqKi9cclxuICAgIGFwaS5ib29raW5nVG9TaW1wbGlmaWVkQm9va2luZyA9IGZ1bmN0aW9uKGJvb2tpbmcpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBib29raW5nSUQ6IGJvb2tpbmcoKS5ib29raW5nSUQoKSxcclxuICAgICAgICAgICAgY3VzdG9tZXJVc2VySUQ6IGJvb2tpbmcuY3VzdG9tZXJVc2VySUQoKSxcclxuICAgICAgICAgICAgYWRkcmVzc0lEOiBib29raW5nLmFkZHJlc3NJRCgpLFxyXG4gICAgICAgICAgICBzdGFydFRpbWU6IGJvb2tpbmcuc3RhcnRUaW1lKCksXHJcbiAgICAgICAgICAgIHByaWNpbmc6IGJvb2tpbmcuYm9va2luZ1JlcXVlc3QoKS5wcmljaW5nRXN0aW1hdGUoKS5kZXRhaWxzKCkucHJpY2luZ1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHByaWNpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZvciBub3csIHRoZSBSRVNUIEFQSSBhbGxvdyBvbmx5IGEgbGlzdCBvZiBJRHMsXHJcbiAgICAgICAgICAgICAgICAvLyBub3Qgb2JqZWN0cywgc28gbmV4dCBsaW5lIGlzIHJlcGxhY2VkOlxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gcHJpY2luZy5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaWNpbmcuZnJlZWxhbmNlclByaWNpbmdJRCgpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgcHJlTm90ZXNUb0NsaWVudDogYm9va2luZy5wcmVOb3Rlc1RvQ2xpZW50KCksXHJcbiAgICAgICAgICAgIHByZU5vdGVzVG9TZWxmOiBib29raW5nLnByZU5vdGVzVG9TZWxmKCksXHJcbiAgICAgICAgICAgIHBvc3ROb3Rlc1RvQ2xpZW50OiBib29raW5nLnBvc3ROb3Rlc1RvQ2xpZW50KCksXHJcbiAgICAgICAgICAgIHBvc3ROb3Rlc1RvU2VsZjogYm9va2luZy5wb3N0Tm90ZXNUb1NlbGYoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBDcmVhdGVzL3VwZGF0ZXMgYSBib29raW5nLCBnaXZlbiBhIHNpbXBsaWZpZWQgYm9va2luZ1xyXG4gICAgICAgIG9iamVjdCBvciBhbiBBcHBvaW50bWVudCBtb2RlbCBvciBhIEJvb2tpbmcgbW9kZWxcclxuICAgICoqL1xyXG4gICAgYXBpLnNldEJvb2tpbmcgPSBmdW5jdGlvbiBzZXRCb29raW5nKGJvb2tpbmcpIHsgICAgXHJcbiAgICAgICAgYm9va2luZyA9IGJvb2tpbmcuYm9va2luZ0lEID9cclxuICAgICAgICAgICAgYXBpLmJvb2tpbmdUb1NpbXBsaWZpZWRCb29raW5nKGJvb2tpbmcpIDpcclxuICAgICAgICAgICAgYm9va2luZy5zb3VyY2VCb29raW5nID9cclxuICAgICAgICAgICAgICAgIGFwaS5hcHBvaW50bWVudFRvU2ltcGxpZmllZEJvb2tpbmcoYm9va2luZykgOlxyXG4gICAgICAgICAgICAgICAgYm9va2luZ1xyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgdmFyIGlkID0gYm9va2luZy5ib29raW5nSUQgfHwgJycsXHJcbiAgICAgICAgICAgIG1ldGhvZCA9IGlkID8gJ3B1dCcgOiAncG9zdCc7XHJcblxyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0W21ldGhvZF0oJ2ZyZWVsYW5jZXItYm9va2luZ3MvJyArIGlkLCBib29raW5nKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckJvb2tpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29raW5nKHNlcnZlckJvb2tpbmcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKiogRXZlbnRzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ2FsZW5kYXJFdmVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9DYWxlbmRhckV2ZW50JyksXHJcbi8vICBhcGlIZWxwZXIgPSByZXF1aXJlKCcuLi91dGlscy9hcGlIZWxwZXInKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuXHJcbiAgICB2YXIgYXBpID0ge1xyXG4gICAgICAgIHJlbW90ZToge1xyXG4gICAgICAgICAgICByZXN0OiBhcHBNb2RlbC5yZXN0LFxyXG4gICAgICAgICAgICBnZXRDYWxlbmRhckV2ZW50czogZnVuY3Rpb24oZmlsdGVycykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdldmVudHMnLCBmaWx0ZXJzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmF3SXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF3SXRlbXMgJiYgcmF3SXRlbXMubWFwKGZ1bmN0aW9uKHJhd0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhckV2ZW50KHJhd0l0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgY2FjaGUgPSB7XHJcbiAgICAgICAgZXZlbnRzQnlEYXRlOiB7fVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIGNhY2hlLmV2ZW50c0J5RGF0ZSA9IHt9O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qYXBpSGVscGVyLmRlZmluZUNydWRBcGlGb3JSZXN0KHtcclxuICAgICAgICBleHRlbmRlZE9iamVjdDogYXBpLnJlbW90ZSxcclxuICAgICAgICBNb2RlbDogQ2FsZW5kYXJFdmVudCxcclxuICAgICAgICBtb2RlbE5hbWU6ICdDYWxlbmRhckV2ZW50JyxcclxuICAgICAgICBtb2RlbExpc3ROYW1lOiAnQ2FsZW5kYXJFdmVudHMnLFxyXG4gICAgICAgIG1vZGVsVXJsOiAnZXZlbnRzJyxcclxuICAgICAgICBpZFByb3BlcnR5TmFtZTogJ2NhbGVuZGFyRXZlbnRJRCdcclxuICAgIH0pOyovXHJcblxyXG4gICAgYXBpLmdldEV2ZW50c0J5RGF0ZSA9IGZ1bmN0aW9uIGdldEV2ZW50c0J5RGF0ZShkYXRlKSB7XHJcbiAgICAgICAgdmFyIGRhdGVLZXkgPSBtb21lbnQoZGF0ZSkuZm9ybWF0KCdZWVlZTU1ERCcpO1xyXG4gICAgICAgIGlmIChjYWNoZS5ldmVudHNCeURhdGUuaGFzT3duUHJvcGVydHkoZGF0ZUtleSkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGUuZXZlbnRzQnlEYXRlW2RhdGVLZXldLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBsYXp5IGxvYWQsIG9uIGJhY2tncm91bmQsIGZvciBzeW5jaHJvbml6YXRpb24sIGJhc2VkIG9uIGNhY2hlIGNvbnRyb2xcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgbG9jYWxmb3JhZ2UgY29weSBmaXJzdD9cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW90ZSBsb2FkaW5nIGRhdGFcclxuICAgICAgICAgICAgcmV0dXJuIGFwaS5yZW1vdGUuZ2V0Q2FsZW5kYXJFdmVudHMoe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGUsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IG1vbWVudChkYXRlKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKVxyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBsb2NhbGZvcmFnZSBjb3B5IG9mIFtkYXRlS2V5XT1ib29raW5nc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFB1dCBpbiBjYWNoZSAodGhleSBhcmUgYWxyZWFkeSBtb2RlbCBpbnN0YW5jZXMpXHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0ga28ub2JzZXJ2YWJsZUFycmF5KGV2ZW50cyk7XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5ldmVudHNCeURhdGVbZGF0ZUtleV0gPSB7IGRhdGE6IGFyciB9O1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBvYnNlcnZhYmxlIGFycmF5XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFJldmlldyByZWFsbHkgaWYgaGFzIHNlbnNlIHRvIGhhdmUgYW4gb2JzZXJ2YWJsZSBhcnJheSwgdGFrZSBjYXJlIG9mIGl0cyB1c2UgKG9uIGFwcG9pbnRtZW50cyBtYWlubHkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgYSBzcGVjaWZpYyBldmVudCBieSBJRFxyXG4gICAgICAgIFRPRE86IEltcGxlbWVudCBjYWNoZS4gUmV1c2luZyBjYWNoZUJ5RGF0ZSwgcmUtaW5kZXg/XHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXRFdmVudCA9IGZ1bmN0aW9uIGdldEV2ZW50KGlkKSB7XHJcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuIFByb21pc2UucmVqZWN0KCdUaGUgY2FsZW5kYXJFdmVudElEIGlzIHJlcXVpcmVkIHRvIGdldCBhbiBldmVudCcpO1xyXG5cclxuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ2V2ZW50cy8nICsgaWQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhckV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5ldmVudFRvU2ltcGxpZmllZEV2ZW50ID0gZnVuY3Rpb24oLypldmVudCovKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcclxuICAgIH07XHJcbiAgICBhcGkuYXBwb2ludG1lbnRUb1NpbXBsaWZpZWRFdmVudCA9IGZ1bmN0aW9uKC8qZXZlbnQqLykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBDcmVhdGVzL3VwZGF0ZXMgYSBib29raW5nLCBnaXZlbiBhIHNpbXBsaWZpZWQgYm9va2luZ1xyXG4gICAgICAgIG9iamVjdCBvciBhbiBBcHBvaW50bWVudCBtb2RlbCBvciBhIEJvb2tpbmcgbW9kZWxcclxuICAgICoqL1xyXG4gICAgYXBpLnNldEV2ZW50ID0gZnVuY3Rpb24gc2V0RXZlbnQoZXZlbnQpIHtcclxuXHJcbiAgICAgICAgZXZlbnQgPSBldmVudC5jYWxlbmRhckV2ZW50SUQgP1xyXG4gICAgICAgICAgICBhcGkuZXZlbnRUb1NpbXBsaWZpZWRFdmVudChldmVudCkgOlxyXG4gICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudCA/XHJcbiAgICAgICAgICAgICAgICBhcGkuYXBwb2ludG1lbnRUb1NpbXBsaWZpZWRFdmVudChldmVudCkgOlxyXG4gICAgICAgICAgICAgICAgZXZlbnRcclxuICAgICAgICA7XHJcblxyXG4gICAgICAgIHZhciBpZCA9IGV2ZW50LmNhbGVuZGFyRXZlbnRJRCB8fCAnJyxcclxuICAgICAgICAgICAgbWV0aG9kID0gaWQgPyAncHV0JyA6ICdwb3N0JztcclxuXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3RbbWV0aG9kXSgnZXZlbnRzLycgKyBpZCwgZXZlbnQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhckV2ZW50KHNlcnZlckV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIENhbGVuZGFyIFN5bmNpbmcgYXBwIG1vZGVsXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgQ2FsZW5kYXJTeW5jaW5nID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NhbGVuZGFyU3luY2luZycpLFxyXG4gICAgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IG5ldyBDYWxlbmRhclN5bmNpbmcoKSxcclxuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGxvY2FsU3RvcmFnZU5hbWU6ICdjYWxlbmRhclN5bmNpbmcnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdjYWxlbmRhci1zeW5jaW5nJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ2NhbGVuZGFyLXN5bmNpbmcnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gRXh0ZW5kaW5nIHdpdGggdGhlIHNwZWNpYWwgQVBJIG1ldGhvZCAncmVzZXRFeHBvcnRVcmwnXHJcbiAgICByZW0uaXNSZXNldGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgcmVtLnJlc2V0RXhwb3J0VXJsID0gZnVuY3Rpb24gcmVzZXRFeHBvcnRVcmwoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmVtLmlzUmVzZXRpbmcodHJ1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ2NhbGVuZGFyLXN5bmNpbmcvcmVzZXQtZXhwb3J0LXVybCcpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odXBkYXRlZFN5bmNTZXR0aW5ncykge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGluZyB0aGUgY2FjaGVkIGRhdGFcclxuICAgICAgICAgICAgcmVtLmRhdGEubW9kZWwudXBkYXRlV2l0aCh1cGRhdGVkU3luY1NldHRpbmdzKTtcclxuICAgICAgICAgICAgcmVtLmlzUmVzZXRpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRTeW5jU2V0dGluZ3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlbTtcclxufTtcclxuIiwiLyoqIEN1c3RvbWVyc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEN1c3RvbWVyID0gcmVxdWlyZSgnLi4vbW9kZWxzL0N1c3RvbWVyJyk7XHJcblxyXG52YXIgTGlzdFJlbW90ZU1vZGVsID0gcmVxdWlyZSgnLi4vdXRpbHMvTGlzdFJlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgXHJcbiAgICB2YXIgYXBpID0gbmV3IExpc3RSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgbGlzdFR0bDogeyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgaXRlbUlkRmllbGQ6ICdjdXN0b21lclVzZXJJRCcsXHJcbiAgICAgICAgTW9kZWw6IEN1c3RvbWVyXHJcbiAgICB9KTtcclxuXHJcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdjdXN0b21lcnMnKTtcclxuICAgIGFwaS5hZGRSZXN0U3VwcG9ydChhcHBNb2RlbC5yZXN0LCAnY3VzdG9tZXJzJyk7XHJcbiAgICBcclxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUHVibGljIHNlYXJjaCBvZiB1c2VycywgcG9zc2libGUgY3VzdG9tZXJzIGJ5IHdlbGxcclxuICAgICAgICBrbm93IGZpZWxkcywgd2l0aCBmdWxsIHZhbHVlIG1hdGNoLlxyXG4gICAgKiovXHJcbiAgICB2YXIgcHVibGljU2VhcmNoUmVxdWVzdCA9IG51bGw7XHJcbiAgICBhcGkucHVibGljU2VhcmNoID0gZnVuY3Rpb24gcHVibGljU2VhcmNoKHNlYXJjaCkge1xyXG5cclxuICAgICAgICAvLyBPbmx5IG9uZSByZXF1ZXN0IGF0IGEgdGltZVxyXG4gICAgICAgIGlmIChwdWJsaWNTZWFyY2hSZXF1ZXN0ICYmXHJcbiAgICAgICAgICAgIHB1YmxpY1NlYXJjaFJlcXVlc3QuYWJvcnQpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHB1YmxpY1NlYXJjaFJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoYWJvcnRFcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFib3J0aW5nIHJlcXVlc3QnLCBhYm9ydEVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBhcHBNb2RlbC5yZXN0LmdldCgnY3VzdG9tZXJzL3B1YmxpYy1zZWFyY2gnLCBzZWFyY2gpO1xyXG4gICAgICAgIHB1YmxpY1NlYXJjaFJlcXVlc3QgPSByZXF1ZXN0LnhocjtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDYXRjaCAnYWJvcnQnIHRvIGF2b2lkIGNvbW11bmljYXRlIGEgZmFrZSBlcnJvciBpbiB0aGUgcHJvbWlzZTsgdGhlXHJcbiAgICAgICAgLy8gcHJvbWlzZSB3aWxsIGp1c3Qgc29sdmUgYXMgc3VjY2VzcyB3aXRoIGVtcHR5IGFycmF5LlxyXG4gICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5zdGF0dXNUZXh0ID09PSAnYWJvcnQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAvLyBSZXRocm93IG9ubHkgaWYgaXMgbm90IGFuICdhYm9ydCdcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gU2V0IGFnYWluLCByZW1vdmVkIGJ5IHRoZSBjYXRjaCByZXR1cm5lZCBwcm9taXNlXHJcbiAgICAgICAgcmVxdWVzdC54aHIgPSBwdWJsaWNTZWFyY2hSZXF1ZXN0O1xyXG5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIEZyZWVsYW5jZXIgUHJpY2luZ1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEZyZWVsYW5jZXJQcmljaW5nID0gcmVxdWlyZSgnLi4vbW9kZWxzL0ZyZWVsYW5jZXJQcmljaW5nJyksXHJcbiAgICBHcm91cExpc3RSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0dyb3VwTGlzdFJlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG5cclxuICAgIHZhciBhcGkgPSBuZXcgR3JvdXBMaXN0UmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIC8vIENvbnNlcnZhdGl2ZSBjYWNoZSwganVzdCAxIG1pbnV0ZVxyXG4gICAgICAgIGxpc3RUdGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGdyb3VwSWRGaWVsZDogJ2pvYlRpdGxlSUQnLFxyXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAnZnJlZWxhbmNlclByaWNpbmdJRCcsXHJcbiAgICAgICAgTW9kZWw6IEZyZWVsYW5jZXJQcmljaW5nXHJcbiAgICB9KTtcclxuXHJcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdmcmVlbGFuY2VyLXByaWNpbmcvJyk7XHJcbiAgICBhcGkuYWRkUmVzdFN1cHBvcnQoYXBwTW9kZWwucmVzdCwgJ2ZyZWVsYW5jZXItcHJpY2luZy8nKTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKiogSG9tZSBBZGRyZXNzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4uL21vZGVscy9BZGRyZXNzJyk7XHJcblxyXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IG5ldyBBZGRyZXNzKCksXHJcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcclxuICAgICAgICBsb2NhbFN0b3JhZ2VOYW1lOiAnaG9tZUFkZHJlc3MnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdhZGRyZXNzZXMvaG9tZScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucHV0KCdhZGRyZXNzZXMvaG9tZScsIHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiByZW07XHJcbn07XHJcbiIsIi8qKiBGZXRjaCBKb2IgVGl0bGVzIGFuZCBQcmljaW5nIFR5cGVzIGluZm9ybWF0aW9uXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgbG9jYWxmb3JhZ2UgPSByZXF1aXJlKCdsb2NhbGZvcmFnZScpLFxyXG4gICAgSm9iVGl0bGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvSm9iVGl0bGUnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcblxyXG4gICAgdmFyIGFwaSA9IHtcclxuICAgICAgICAgICAgc3RhdGU6ICB7XHJcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhY2hlID0ge1xyXG4gICAgICAgICAgICBqb2JUaXRsZXM6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIGNhY2hlLmpvYlRpdGxlcyA9IHt9O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIFB1YmxpYyBBUElcclxuICAgICAgICBHZXQgYSBKb2IgVGl0bGUgaW5mb3JtYXRpb24gYnkgSURcclxuICAgICoqL1xyXG4gICAgYXBpLmdldEpvYlRpdGxlID0gZnVuY3Rpb24gZ2V0Sm9iVGl0bGUoaWQpIHtcclxuICAgICAgICBpZiAoIWlkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05lZWRzIGFuIElEIHRvIGdldCBhIEpvYiBUaXRsZScpO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCwgaW4tbWVtb3J5IGNhY2hlXHJcbiAgICAgICAgaWYgKGNhY2hlLmpvYlRpdGxlc1tpZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZS5qb2JUaXRsZXNbaWRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIFNlY29uZCwgbG9jYWwgc3RvcmFnZVxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnam9iVGl0bGVzLycgKyBpZClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oam9iVGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChqb2JUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIGluIG1lbW9yeSBhcyBNb2RlbCBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmpvYlRpdGxlc1tpZF0gPSBuZXcgSm9iVGl0bGUoam9iVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5qb2JUaXRsZXNbaWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcmQgYW5kIGxhc3QsIHJlbW90ZSBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdqb2ItdGl0bGVzLycgKyBpZClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmF3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGluIGxvY2FsIHN0b3JhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgnam9iVGl0bGVzLycgKyBpZCwgcmF3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgaW4gbWVtb3J5IGFzIE1vZGVsIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmpvYlRpdGxlc1tpZF0gPSBuZXcgSm9iVGl0bGUocmF3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuam9iVGl0bGVzW2lkXTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbn07XHJcbiIsIi8qKiBBcHBNb2RlbCwgY2VudHJhbGl6ZXMgYWxsIHRoZSBkYXRhIGZvciB0aGUgYXBwLFxyXG4gICAgY2FjaGluZyBhbmQgc2hhcmluZyBkYXRhIGFjcm9zcyBhY3Rpdml0aWVzIGFuZCBwZXJmb3JtaW5nXHJcbiAgICByZXF1ZXN0c1xyXG4qKi9cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIFJlc3QgPSByZXF1aXJlKCcuLi91dGlscy9SZXN0JyksXHJcbiAgICBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyksXHJcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcblxyXG5mdW5jdGlvbiBBcHBNb2RlbCgpIHtcclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMzApO1xyXG59XHJcblxyXG5BcHBNb2RlbC5faW5oZXJpdHMoRXZlbnRFbWl0dGVyKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXBwTW9kZWw7XHJcblxyXG5yZXF1aXJlKCcuL0FwcE1vZGVsLWFjY291bnQnKS5wbHVnSW4oQXBwTW9kZWwpO1xyXG5cclxuLyoqXHJcbiAgICBMb2FkIGNyZWRlbnRpYWxzIGZyb20gdGhlIGxvY2FsIHN0b3JhZ2UsIHdpdGhvdXQgZXJyb3IgaWYgdGhlcmUgaXMgbm90aGluZ1xyXG4gICAgc2F2ZWQuIElmIGxvYWQgcHJvZmlsZSBkYXRhIHRvbywgcGVyZm9ybWluZyBhbiB0cnlMb2dpbiBpZiBubyBsb2NhbCBkYXRhLlxyXG4qKi9cclxuQXBwTW9kZWwucHJvdG90eXBlLmxvYWRMb2NhbENyZWRlbnRpYWxzID0gZnVuY3Rpb24gbG9hZExvY2FsQ3JlZGVudGlhbHMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkgeyAvLyBOZXZlciByZWplY3RzOiAsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAvLyBDYWxsYmFjayB0byBqdXN0IHJlc29sdmUgd2l0aG91dCBlcnJvciAocGFzc2luZyBpbiB0aGUgZXJyb3JcclxuICAgICAgICAvLyB0byB0aGUgJ3Jlc29sdmUnIHdpbGwgbWFrZSB0aGUgcHJvY2VzcyB0byBmYWlsKSxcclxuICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhbiBlcnJvciBmb3IgdGhlXHJcbiAgICAgICAgLy8gYXBwIGluaXQsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc2F2ZWQgaW5mb3JtYXRpb25cclxuICAgICAgICAvLyB0aGUgYXBwIGhhcyBjb2RlIHRvIHJlcXVlc3QgYSBsb2dpbi5cclxuICAgICAgICB2YXIgcmVzb2x2ZUFueXdheSA9IGZ1bmN0aW9uKGRvZXNuTWF0dGVyKXsgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm5pbmcoJ0FwcCBNb2RlbCBJbml0IGVycicsIGRvZXNuTWF0dGVyKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNyZWRlbnRpYWxzIHNhdmVkXHJcbiAgICAgICAgbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnY3JlZGVudGlhbHMnKS50aGVuKGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbHMgJiZcclxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLnVzZXJJRCAmJlxyXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHMudXNlcm5hbWUgJiZcclxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLmF1dGhLZXkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgYXV0aG9yaXphdGlvbiBrZXkgZm9yIGVhY2hcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBSZXN0IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdC5leHRyYUhlYWRlcnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWx1OiBjcmVkZW50aWFscy51c2VySUQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxrOiBjcmVkZW50aWFscy5hdXRoS2V5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgY3JlZGVudGlhbHMhIEhhcyBiYXNpYyBwcm9maWxlIGRhdGE/XHJcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgdXNlclByb2ZpbGUgd2lsbCBsb2FkIGZyb20gbG9jYWwgc3RvcmFnZSBvbiB0aGlzIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0LCBhbmQgbGF6aWx5IHJlcXVlc3QgdXBkYXRlZCBkYXRhIGZyb20gcmVtb3RlIHNvIHdlIG5lZWRcclxuICAgICAgICAgICAgICAgIC8vIHRvIGNhdGNoIHJlbW90ZSBlcnJvcnMgd2l0aCBldmVudHNcclxuICAgICAgICAgICAgICAgIHRoaXMudXNlclByb2ZpbGUub25jZSgnZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW1wb3NzaWJsZSB0byBsb2FkIHlvdXIgZGF0YS4gUGxlYXNlIGNoZWNrIHlvdXIgSW50ZXJuZXQgY29ubmVjdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMudXNlclByb2ZpbGUubG9hZCgpLnRoZW4oZnVuY3Rpb24ocHJvZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgcHJvZmlsZSBjYWNoZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIHN1Y2Nlc2Z1bGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHByb2ZpbGUsIHdlIG5lZWQgdG8gcmVxdWVzdCBpdCB0byBiZSBhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHdvcmsgY29ycmVjdGx5LCBzbyB3ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IGEgbG9naW4gKHRoZSB0cnlMb2dpbiBwcm9jZXNzIHBlcmZvcm1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgbG9naW4gd2l0aCB0aGUgc2F2ZWQgY3JlZGVudGlhbHMgYW5kIGZldGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9maWxlIHRvIHNhdmUgaXQgaW4gdGhlIGxvY2FsIGNvcHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5TG9naW4oKS50aGVuKHJlc29sdmUsIHJlc29sdmVBbnl3YXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgcmVzb2x2ZUFueXdheSlcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBlcnJvciBldmVudCBjYXRjaCBhbnkgZXJyb3IgaWYgaGFwcGVucywgc28gYXZvaWQgdW5jYXVnaHQgZXhjZXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIGNvbnNvbGUgYnkgY2F0Y2hpbmcgdGhlIHByb21pc2UgZXJyb3JcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbmQgc3VjY2Vzc2Z1bGx5LiBOb3QgbG9nZ2luIGlzIG5vdCBhbiBlcnJvcixcclxuICAgICAgICAgICAgICAgIC8vIGlzIGp1c3QgdGhlIGZpcnN0IGFwcCBzdGFydC11cFxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCByZXNvbHZlQW55d2F5KTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG4vKiogSW5pdGlhbGl6ZSBhbmQgd2FpdCBmb3IgYW55dGhpbmcgdXAgKiovXHJcbkFwcE1vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIFxyXG4gICAgLy8gTG9jYWwgZGF0YVxyXG4gICAgLy8gVE9ETyBJbnZlc3RpZ2F0ZSB3aHkgYXV0b21hdGljIHNlbGVjdGlvbiBhbiBJbmRleGVkREIgYXJlXHJcbiAgICAvLyBmYWlsaW5nIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgd29yc2UtcGVyZm9ybWFuY2UgbG9jYWxzdG9yYWdlIGJhY2stZW5kXHJcbiAgICBsb2NhbGZvcmFnZS5jb25maWcoe1xyXG4gICAgICAgIG5hbWU6ICdMb2Nvbm9taWNzQXBwJyxcclxuICAgICAgICB2ZXJzaW9uOiAwLjEsXHJcbiAgICAgICAgc2l6ZSA6IDQ5ODA3MzYsIC8vIFNpemUgb2YgZGF0YWJhc2UsIGluIGJ5dGVzLiBXZWJTUUwtb25seSBmb3Igbm93LlxyXG4gICAgICAgIHN0b3JlTmFtZSA6ICdrZXl2YWx1ZXBhaXJzJyxcclxuICAgICAgICBkZXNjcmlwdGlvbiA6ICdMb2Nvbm9taWNzIEFwcCcsXHJcbiAgICAgICAgZHJpdmVyOiBsb2NhbGZvcmFnZS5MT0NBTFNUT1JBR0VcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBGaXJzdCwgZ2V0IGFueSBzYXZlZCBsb2NhbCBjb25maWdcclxuICAgIC8vIE5PVEU6IGZvciBub3csIHRoaXMgaXMgb3B0aW9uYWwsIHRvIGdldCBhIHNhdmVkIHNpdGVVcmwgcmF0aGVyIHRoYW4gdGhlXHJcbiAgICAvLyBkZWZhdWx0IG9uZSwgaWYgYW55LlxyXG4gICAgcmV0dXJuIGxvY2FsZm9yYWdlLmdldEl0ZW0oJ2NvbmZpZycpXHJcbiAgICAudGhlbihmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAvLyBPcHRpb25hbCBjb25maWdcclxuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNvbmZpZy5zaXRlVXJsKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaHRtbCBVUkxcclxuICAgICAgICAgICAgJCgnaHRtbCcpLmF0dHIoJ2RhdGEtc2l0ZS11cmwnLCBjb25maWcuc2l0ZVVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25maWcuc2l0ZVVybCA9ICQoJ2h0bWwnKS5hdHRyKCdkYXRhLXNpdGUtdXJsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucmVzdCA9IG5ldyBSZXN0KGNvbmZpZy5zaXRlVXJsICsgJy9hcGkvdjEvZW4tVVMvJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2V0dXAgUmVzdCBhdXRoZW50aWNhdGlvblxyXG4gICAgICAgIHRoaXMucmVzdC5vbkF1dGhvcml6YXRpb25SZXF1aXJlZCA9IGZ1bmN0aW9uKHJldHJ5KSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyeUxvZ2luKClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMb2dnZWQhIEp1c3QgcmV0cnlcclxuICAgICAgICAgICAgICAgIHJldHJ5KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBXaXRoIGNvbmZpZyBsb2FkZWQgYW5kIFJFU1QgcmVhZHksIGxvYWQgYWxsIG1vZHVsZXNcclxuICAgICAgICB0aGlzLmxvYWRNb2R1bGVzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZTogY2hlY2sgdGhlIHVzZXIgaGFzIGxvZ2luIGRhdGEgYW5kIG5lZWRlZFxyXG4gICAgICAgIC8vIGNhY2hlZCBkYXRhLCByZXR1cm4gaXRzIHByb21pc2VcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkTG9jYWxDcmVkZW50aWFscygpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkFwcE1vZGVsLnByb3RvdHlwZS5sb2FkTW9kdWxlcyA9IGZ1bmN0aW9uIGxvYWRNb2R1bGVzKCkge1xyXG5cclxuICAgIHRoaXMudXNlclByb2ZpbGUgPSByZXF1aXJlKCcuL0FwcE1vZGVsLnVzZXJQcm9maWxlJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgLy8gTk9URTogQWxpYXMgZm9yIHRoZSB1c2VyIGRhdGFcclxuICAgIC8vIFRPRE86VE9SRVZJRVcgaWYgY29udGludWUgdG8gbWFrZXMgc2Vuc2UgdG8ga2VlcCB0aGlzICd1c2VyKCknIGFsaWFzLCBkb2N1bWVudFxyXG4gICAgLy8gd2hlcmUgaXMgdXNlZCBhbmQgd2h5IGlzIHByZWZlcnJlZCB0byB0aGUgY2Fub25pY2FsIHdheS5cclxuICAgIHRoaXMudXNlciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJQcm9maWxlLmRhdGE7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNjaGVkdWxpbmdQcmVmZXJlbmNlcyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5jYWxlbmRhclN5bmNpbmcgPSByZXF1aXJlKCcuL0FwcE1vZGVsLmNhbGVuZGFyU3luY2luZycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLm1hcmtldHBsYWNlUHJvZmlsZSA9IHJlcXVpcmUoJy4vQXBwTW9kZWwubWFya2V0cGxhY2VQcm9maWxlJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5ob21lQWRkcmVzcyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuaG9tZUFkZHJlc3MnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLnByaXZhY3lTZXR0aW5ncyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwucHJpdmFjeVNldHRpbmdzJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5ib29raW5ncyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuYm9va2luZ3MnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLmNhbGVuZGFyRXZlbnRzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5jYWxlbmRhckV2ZW50cycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuam9iVGl0bGVzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5qb2JUaXRsZXMnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLnVzZXJKb2JQcm9maWxlID0gcmVxdWlyZSgnLi9BcHBNb2RlbC51c2VySm9iUHJvZmlsZScpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuYXBwb2ludG1lbnRzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5hcHBvaW50bWVudHMnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLnNlcnZpY2VBZGRyZXNzZXMgPSByZXF1aXJlKCcuL0FwcE1vZGVsLnNlcnZpY2VBZGRyZXNzZXMnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLmZyZWVsYW5jZXJQcmljaW5nID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5mcmVlbGFuY2VyUHJpY2luZycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMucHJpY2luZ1R5cGVzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5wcmljaW5nVHlwZXMnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLm1lc3NhZ2luZyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwubWVzc2FnaW5nJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5jdXN0b21lcnMgPSByZXF1aXJlKCcuL0FwcE1vZGVsLmN1c3RvbWVycycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMucG9zdGFsQ29kZXMgPSByZXF1aXJlKCcuL0FwcE1vZGVsLnBvc3RhbENvZGVzJykuY3JlYXRlKHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBDbGVhciB0aGUgbG9jYWwgc3RvcmVkIGRhdGEsIGJ1dCB3aXRoIGNhcmVmdWwgZm9yIHRoZSBzcGVjaWFsXHJcbiAgICBjb25maWcgZGF0YSB0aGF0IGlzIGtlcHQuXHJcbioqL1xyXG5BcHBNb2RlbC5wcm90b3R5cGUuY2xlYXJMb2NhbERhdGEgPSBmdW5jdGlvbiBjbGVhckxvY2FsRGF0YSgpIHtcclxuICAgIC8vIEdldCBjb25maWdcclxuICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCdjb25maWcnKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgLy8gQ2xlYXIgYWxsXHJcbiAgICAgICAgbG9jYWxmb3JhZ2UuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBTZXQgY29uZmlnIGFnYWluXHJcbiAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0oJ2NvbmZpZycsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyaWdnZXIgbm90aWZpY2F0aW9uLCBzbyBvdGhlciBjb21wb25lbnRzXHJcbiAgICAgICAgLy8gY2FuIG1ha2UgZnVydGhlciBjbGVhbi11cCBvciB0cnkgc3luY2hyb25pemF0aW9ucyxcclxuICAgICAgICAvLyBmb3IgZXhhbXBsZSB0byBjbGVhbi11cCBpbi1tZW1vcnkgY2FjaGUuXHJcbiAgICAgICAgdGhpcy5lbWl0KCdjbGVhckxvY2FsRGF0YScpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbi8vIFRPRE8gUmV2aWV3IHJlbW92YWwsIG1heWJlIHRvbyB0aGUgdXRpbGl0eSBpbnRlcm5hbGx5IHVzZWQsIHNpbmNlIG5vdyB0aGVyZVxyXG4vLyBpcyBhbiAoaW5jb21wbGV0ZSBzdGlsbCkgQXBwTW9kZWwuY2FsZW5kYXJFdmVudHNcclxuLy8gQ2xhc3Mgc3BsaXRlZCBpbiBkaWZmZXJlbnQgZmlsZXMgdG8gbWl0aWdhdGUgc2l6ZSBhbmQgb3JnYW5pemF0aW9uXHJcbi8vIGJ1dCBrZWVwaW5nIGFjY2VzcyB0byB0aGUgY29tbW9uIHNldCBvZiBtZXRob2RzIGFuZCBvYmplY3RzIGVhc3kgd2l0aFxyXG4vLyB0aGUgc2FtZSBjbGFzcy5cclxuLy8gTG9hZGluZyBleHRlbnNpb25zOlxyXG4vL3JlcXVpcmUoJy4vQXBwTW9kZWwtZXZlbnRzJykucGx1Z0luKEFwcE1vZGVsKTtcclxuXHJcbiIsIi8qKiBNYXJrZXRwbGFjZVByb2ZpbGVcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNYXJrZXRwbGFjZVByb2ZpbGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvTWFya2V0cGxhY2VQcm9maWxlJyk7XHJcblxyXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IG5ldyBNYXJrZXRwbGFjZVByb2ZpbGUoKSxcclxuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGxvY2FsU3RvcmFnZU5hbWU6ICdtYXJrZXRwbGFjZVByb2ZpbGUnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtYXJrZXRwbGFjZS1wcm9maWxlJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ21hcmtldHBsYWNlLXByb2ZpbGUnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcmVtO1xyXG59O1xyXG4iLCIvKiogQXBwTW9kZWwgZm9yIG1lc3NhZ2luZzogdGhyZWFkcyBhbmQgbWVzc2FnZXNcclxuXHJcbiAgICBOT1RFOiBJbml0aWFsIGJhc2ljIGltcGxlbWVudGF0aW9uXHJcbiAgICBUT0RPOiBSZXF1aXJlIGFkdmFuY2VkIGltcGxlbWVudGF0aW9uLCBsb2FkaW5nIGEgbGltaXRlZFxyXG4gICAgICAgIGFtb3VudCBvZiByZWNvcmRzIGZvciB0aHJlYWRzIGFuZCBtZXNzYWdlcyBwZXIgdGhyZWFkXHJcbiAgICAgICAgdXNpbmcgdGhlIGN1cnNvciBwYXJhbWV0ZXJzIG9mIHRoZSBSRVNUIEFQSSB0byBtYW5hZ2VcclxuICAgICAgICBwYWdpbmcgbG9hZC5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBUaHJlYWQgPSByZXF1aXJlKCcuLi9tb2RlbHMvVGhyZWFkJyksXHJcbiAgICBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuLi91dGlscy9DYWNoZUNvbnRyb2wnKSxcclxuICAgIExpc3RSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0xpc3RSZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIFxyXG4gICAgdmFyIGFwaSA9IG5ldyBMaXN0UmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGxpc3RUdGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAndGhyZWFkSUQnLFxyXG4gICAgICAgIE1vZGVsOiBUaHJlYWRcclxuICAgIH0pO1xyXG5cclxuICAgIGFwaS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQoJ21lc3NhZ2luZycpO1xyXG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdtZXNzYWdpbmcnKTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBCYXNpYyBzdXBwb3J0IGlzIGZldGNoaW5nIGFsbCB0aHJlYWRzIHdpdGggdGhlIGxhdGVzdCBtZXNzYWdlIG9mIGVhY2ggb25lLlxyXG4gICAgLy8gUmVwbGFjZSBnZXRJdGVtIGJ1aWx0LWluIHRvIGRvIG5vbiBsb2NhbGx5IHNhdmVkLCBmZXRjaCBmb3IgYWxsIG1lc3NhZ2VzIGluXHJcbiAgICAvLyBhIHRocmVhZCAodGhlIHRocmVhZCBpcyB0aGUgaXRlbSlcclxuICAgIHZhciBmdWxsVGhyZWFkc0NhY2hlID0gey8qXHJcbiAgICAgICAgdGhyZWFkSUQ6IHsgY29udHJvbDogQ2FjaGVDb250cm9sLCB0aHJlYWQ6IFRocmVhZCB9XHJcbiAgICAqL307XHJcbiAgICB2YXIgZmV0Y2hUaHJlYWRSZW1vdGUgPSBmdW5jdGlvbih0aHJlYWRJRCkge1xyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnbWVzc2FnaW5nLycgKyB0aHJlYWRJRCwge1xyXG4gICAgICAgICAgICBsaW1pdDogMTAwMCAvKiBtYXggbWVzc2FnZXMgaW4gdGhlIHRocmVhZCAqL1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odGhyZWFkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aHJlYWQpIHtcclxuICAgICAgICAgICAgICAgIHRocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkKTtcclxuICAgICAgICAgICAgICAgIHZhciBjYWNoZWQgPSBmdWxsVGhyZWFkc0NhY2hlW3RocmVhZElEXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuY29udHJvbC5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC50aHJlYWQgPSB0aHJlYWQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxUaHJlYWRzQ2FjaGVbdGhyZWFkSURdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiB7IG1pbnV0ZXM6IDEgfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyZWFkOiB0aHJlYWRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxUaHJlYWRzQ2FjaGVbdGhyZWFkSURdLmNvbnRyb2wubGF0ZXN0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aHJlYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBGb3VuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIG1hcmtBc0VuZGVkQW5kRm9sbG93VXAgPSBmdW5jdGlvbihhbnkpIHtcclxuICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gYW55O1xyXG4gICAgfTtcclxuICAgIGFwaS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbSh0aHJlYWRJRCkge1xyXG4gICAgICAgIHZhciBjYWNoZWQgPSBmdWxsVGhyZWFkc0NhY2hlW3RocmVhZElEXTtcclxuICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC50aHJlYWQpIHtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZC5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hUaHJlYWRSZW1vdGUodGhyZWFkSUQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihtYXJrQXNFbmRlZEFuZEZvbGxvd1VwLCBtYXJrQXNFbmRlZEFuZEZvbGxvd1VwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZC50aHJlYWQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFRocmVhZFJlbW90ZSh0aHJlYWRJRClcclxuICAgICAgICAgICAgLnRoZW4obWFya0FzRW5kZWRBbmRGb2xsb3dVcCwgbWFya0FzRW5kZWRBbmRGb2xsb3dVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKiogUG9zdGFsIENvZGUuXHJcblxyXG4gICAgQWNjZXNzIHRoZSBBUEkgdG8gdmFsaWRhdGUgYW5kIHJldHJpZXZlIGluZm9ybWF0aW9uIGZvciBhIFxyXG4gICAgZ2l2ZW4gcG9zdGFsIGNvZGUuXHJcbiAgICBcclxuICAgIEl0IGp1c3Qgb2ZmZXJzIGEgJ2dldCBwb3N0YWwgY29kZSBpbmZvJyBtZXRob2QgcmV0dXJuaW5nXHJcbiAgICBhIHBsYWluIG9iamVjdCBmcm9tIHRoZSBSRVNUIGVuZHBvaW50LlxyXG4gICAgXHJcbiAgICBDcmVhdGVzIGFuIGluLW1lbW9yeSBjYWNoZSBmb3IgZnJlcXVlbnRseSB1c2VkIHBvc3RhbCBjb2Rlc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuXHJcbiAgICB2YXIgYXBpID0ge30sXHJcbiAgICAgICAgY2FjaGUgPSB7fTtcclxuICAgIFxyXG4gICAgYXBpLmdldEl0ZW0gPSBmdW5jdGlvbiBnZXRJdGVtKHBvc3RhbENvZGUpIHtcclxuICAgICAgICBcclxuICAgICAgICBwb3N0YWxDb2RlID0gcG9zdGFsQ29kZSB8fCAnJztcclxuICAgICAgICBpZiAoL15cXHMqJC8udGVzdChwb3N0YWxDb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1Bvc3RhbCBDb2RlIE5vdCBWYWxpZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBjYWNoZVxyXG4gICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShwb3N0YWxDb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlW3Bvc3RhbENvZGVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdwb3N0YWwtY29kZXMvJyArIHBvc3RhbENvZGUpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgICAgICAvLyBTYXZlIGNhY2hlXHJcbiAgICAgICAgICAgIGlmIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZVtwb3N0YWxDb2RlXSA9IGluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmV0dXJuXHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBjYWNoZSA9IHt9O1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBhcGk7XHJcbn07XHJcbiIsIi8qKiBQcmljaW5nIFR5cGVzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUHJpY2luZ1R5cGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvUHJpY2luZ1R5cGUnKTtcclxuXHJcbnZhciBMaXN0UmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9MaXN0UmVtb3RlTW9kZWwnKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcbiAgICBcclxuICAgIHZhciBhcGkgPSBuZXcgTGlzdFJlbW90ZU1vZGVsKHtcclxuICAgICAgICAvLyBUeXBlcyBkb2VzIG5vdCBjaGFuZ2VzIHVzdWFsbHksIHNvIGJpZyB0dGxcclxuICAgICAgICBsaXN0VHRsOiB7IGRheXM6IDEgfSxcclxuICAgICAgICBpdGVtSWRGaWVsZDogJ3ByaWNpbmdUeXBlSUQnLFxyXG4gICAgICAgIE1vZGVsOiBQcmljaW5nVHlwZVxyXG4gICAgfSk7XHJcblxyXG4gICAgYXBpLmFkZExvY2FsZm9yYWdlU3VwcG9ydCgncHJpY2luZy10eXBlcycpO1xyXG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdwcmljaW5nLXR5cGVzJyk7XHJcbiAgICBcclxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKiogUHJpdmFjeSBTZXR0aW5nc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFByaXZhY3lTZXR0aW5ncyA9IHJlcXVpcmUoJy4uL21vZGVscy9Qcml2YWN5U2V0dGluZ3MnKTtcclxuXHJcbnZhciBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgdmFyIHJlbSA9IG5ldyBSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgZGF0YTogbmV3IFByaXZhY3lTZXR0aW5ncygpLFxyXG4gICAgICAgIHR0bDogeyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3ByaXZhY3lTZXR0aW5ncycsXHJcbiAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ3ByaXZhY3ktc2V0dGluZ3MnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnB1dCgncHJpdmFjeS1zZXR0aW5ncycsIHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiByZW07XHJcbn07XHJcbiIsIi8qKlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFNjaGVkdWxpbmdQcmVmZXJlbmNlcyA9IHJlcXVpcmUoJy4uL21vZGVscy9TY2hlZHVsaW5nUHJlZmVyZW5jZXMnKTtcclxuXHJcbnZhciBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgdmFyIHJlbSA9IG5ldyBSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgZGF0YTogbmV3IFNjaGVkdWxpbmdQcmVmZXJlbmNlcygpLFxyXG4gICAgICAgIHR0bDogeyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3NjaGVkdWxpbmdQcmVmZXJlbmNlcycsXHJcbiAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ3NjaGVkdWxpbmctcHJlZmVyZW5jZXMnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnB1dCgnc2NoZWR1bGluZy1wcmVmZXJlbmNlcycsIHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiByZW07XHJcbn07XHJcbiIsIi8qKiBTZXJ2aWNlIEFkZHJlc3Nlc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi9tb2RlbHMvQWRkcmVzcycpLFxyXG4gICAgR3JvdXBMaXN0UmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9Hcm91cExpc3RSZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuXHJcbiAgICB2YXIgYXBpID0gbmV3IEdyb3VwTGlzdFJlbW90ZU1vZGVsKHtcclxuICAgICAgICAvLyBDb25zZXJ2YXRpdmUgY2FjaGUsIGp1c3QgMSBtaW51dGVcclxuICAgICAgICBsaXN0VHRsOiB7IG1pbnV0ZXM6IDEgfSxcclxuICAgICAgICBncm91cElkRmllbGQ6ICdqb2JUaXRsZUlEJyxcclxuICAgICAgICBpdGVtSWRGaWVsZDogJ2FkZHJlc3NJRCcsXHJcbiAgICAgICAgTW9kZWw6IEFkZHJlc3NcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdhZGRyZXNzZXMvc2VydmljZS8nKTtcclxuICAgIGFwaS5hZGRSZXN0U3VwcG9ydChhcHBNb2RlbC5yZXN0LCAnYWRkcmVzc2VzL3NlcnZpY2UvJyk7XHJcbiAgICBcclxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1NpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZScpLFxyXG4gICAgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XHJcblxyXG4vLyBUaGUgc2xvdCBzaXplIGlzIGZpeGVkIHRvIDE1IG1pbnV0ZXMgYnkgZGVmYXVsdC5cclxuLy8gTk9URTogY3VycmVudGx5LCB0aGUgQVBJIG9ubHkgYWxsb3dzIDE1IG1pbnV0ZXMgc2xvdHMsXHJcbi8vIGJlaW5nIHRoYXQgaW1wbGljaXQsIGJ1dCBwYXJ0IG9mIHRoZSBjb2RlIGlzIHJlYWR5IGZvciBleHBsaWNpdCBzbG90U2l6ZS5cclxudmFyIGRlZmF1bHRTbG90U2l6ZSA9IDE1O1xyXG4vLyBBIGxpc3Qgb2Ygd2VlayBkYXkgcHJvcGVydGllcyBuYW1lcyBhbGxvd2VkXHJcbi8vIHRvIGJlIHBhcnQgb2YgdGhlIG9iamVjdHMgZGVzY3JpYmluZyB3ZWVrbHkgc2NoZWR1bGVcclxuLy8gKHNpbXBsaWZpZWQgb3IgY29tcGxldGUvc2xvdCBiYXNlZClcclxuLy8gSnVzdCBsb3dlY2FzZWQgZW5nbGlzaCBuYW1lc1xyXG52YXIgd2Vla0RheVByb3BlcnRpZXMgPSBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5J107XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgdmFyIHJlbSA9IG5ldyBSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgZGF0YTogbmV3IFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSgpLFxyXG4gICAgICAgIHR0bDogeyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3dlZWtseVNjaGVkdWxlJyxcclxuICAgICAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnYXZhaWxhYmlsaXR5L3dlZWtseS1zY2hlZHVsZScpXHJcbiAgICAgICAgICAgIC50aGVuKGZyb21XZWVrbHlTY2hlZHVsZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICB2YXIgcGxhaW5EYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgJ2FsbC10aW1lJzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAnanNvbi1kYXRhJzoge31cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5pc0FsbFRpbWUoKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhWydhbGwtdGltZSddID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBsYWluRGF0YVsnanNvbi1kYXRhJ10gPSBKU09OLnN0cmluZ2lmeSh0b1dlZWtseVNjaGVkdWxlKHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnB1dCgnYXZhaWxhYmlsaXR5L3dlZWtseS1zY2hlZHVsZScsIHBsYWluRGF0YSlcclxuICAgICAgICAgICAgLnRoZW4oZnJvbVdlZWtseVNjaGVkdWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcmVtO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZnJvbVdlZWtseVNjaGVkdWxlKHdlZWtseVNjaGVkdWxlKSB7XHJcbiAgICBcclxuICAgIC8vIE5ldyBzaW1wbGlmaWVkIG9iamVjdCwgYXMgYSBwbGFpbiBvYmplY3Qgd2l0aFxyXG4gICAgLy8gd2Vla2RheXMgcHJvcGVydGllcyBhbmQgZnJvbS10byBwcm9wZXJ0aWVzIGxpa2U6XHJcbiAgICAvLyB7IHN1bmRheTogeyBmcm9tOiAwLCB0bzogNjAgfSB9XHJcbiAgICAvLyBTaW5jZSB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGNvbnN1bWVkIGJ5IGZldGNoLXB1c2hcclxuICAgIC8vIG9wZXJhdGlvbnMsIGFuZCBsYXRlciBieSBhbiAnbW9kZWwudXBkYXRlV2l0aCcgb3BlcmF0aW9uLFxyXG4gICAgLy8gc28gcGxhaW4gaXMgc2ltcGxlIGFuZCBiZXR0ZXIgb24gcGVyZm9ybWFuY2U7IGNhbiBiZVxyXG4gICAgLy8gY29udmVydGVkIGVhc2lseSB0byB0aGUgU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlIG9iamVjdC5cclxuICAgIHZhciBzaW1wbGVXUyA9IHt9O1xyXG4gICAgXHJcbiAgICAvLyBPbmx5IHN1cHBvcnRzICdhdmFpbGFibGUnIHN0YXR1cyB3aXRoIGRlZmF1bHQgJ3VuYXZhaWxhYmxlJ1xyXG4gICAgaWYgKHdlZWtseVNjaGVkdWxlLmRlZmF1bHRTdGF0dXMgIT09ICd1bmF2YWlsYWJsZScgfHxcclxuICAgICAgICB3ZWVrbHlTY2hlZHVsZS5zdGF0dXMgIT09ICdhdmFpbGFibGUnKSB7XHJcbiAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICBuYW1lOiAnaW5wdXQtZm9ybWF0JyxcclxuICAgICAgICAgICAgbWVzc2FnZTogJ1dlZWtseSBzY2hlZHVsZSwgZ2l2ZW4gc3RhdHVzZXMgbm90IHN1cHBvcnRlZCwgc3RhdHVzOiAnICtcclxuICAgICAgICAgICAgd2Vla2x5U2NoZWR1bGUuc3RhdHVzICsgJywgZGVmYXVsdFN0YXR1czogJyArIFxyXG4gICAgICAgICAgICB3ZWVrbHlTY2hlZHVsZS5kZWZhdWx0U3RhdHVzXHJcbiAgICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBnaXZlbiBzbG90U2l6ZSBvciBkZWZhdWx0XHJcbiAgICB2YXIgc2xvdFNpemUgPSAod2Vla2x5U2NoZWR1bGUuc2xvdFNpemUgfHwgZGVmYXVsdFNsb3RTaXplKSB8MDtcclxuXHJcbiAgICAvLyBSZWFkIHNsb3RzIHBlciB3ZWVrLWRheSAoeyBzbG90czogeyBcInN1bmRheVwiOiBbXSB9IH0pXHJcbiAgICBPYmplY3Qua2V5cyh3ZWVrbHlTY2hlZHVsZS5zbG90cylcclxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHdlZWtkYXkpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBWZXJpZnkgaXMgYSB3ZWVrZGF5IHByb3BlcnR5LCBvciBleGl0IGVhcmx5XHJcbiAgICAgICAgaWYgKHdlZWtEYXlQcm9wZXJ0aWVzLmluZGV4T2Yod2Vla2RheSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRheXNsb3RzID0gd2Vla2x5U2NoZWR1bGUuc2xvdHNbd2Vla2RheV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gV2UgZ2V0IHRoZSBmaXJzdCBhdmFpbGFibGUgc2xvdCBhbmQgdGhlIGxhc3QgY29uc2VjdXRpdmVcclxuICAgICAgICAvLyB0byBtYWtlIHRoZSByYW5nZVxyXG4gICAgICAgIHZhciBmcm9tID0gbnVsbCxcclxuICAgICAgICAgICAgdG8gPSBudWxsLFxyXG4gICAgICAgICAgICBwcmV2aW91cyA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIHRpbWVzIGFyZSBvcmRlcmVkIGluIGFzY2VuZGluZ1xyXG4gICAgICAgIC8vIGFuZCB3aXRoIGZvcm1hdCBcIjAwOjAwOjAwXCIgdGhhdCB3ZSBjb252ZXJ0IHRvIG1pbnV0ZXNcclxuICAgICAgICAvLyAoZW5vdWdoIHByZWNpc2lvbiBmb3Igc2ltcGxpZmllZCB3ZWVrbHkgc2NoZWR1bGUpXHJcbiAgICAgICAgLy8gdXNpbmcgbW9tZW50LmR1cmF0aW9uXHJcbiAgICAgICAgLy8gTk9URTogdXNpbmcgJ3NvbWUnIHJhdGhlciB0aGFuICdmb3JFYWNoJyB0byBiZSBhYmxlXHJcbiAgICAgICAgLy8gdG8gZXhpdCBlYXJseSBmcm9tIHRoZSBpdGVyYXRpb24gYnkgcmV0dXJuaW5nICd0cnVlJ1xyXG4gICAgICAgIC8vIHdoZW4gdGhlIGVuZCBpcyByZWFjaGVkLlxyXG4gICAgICAgIGRheXNsb3RzLnNvbWUoZnVuY3Rpb24oc2xvdCkge1xyXG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IG1vbWVudC5kdXJhdGlvbihzbG90KS5hc01pbnV0ZXMoKSB8MDtcclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3Qgc3RpbGwgYSAnZnJvbScgdGltZTpcclxuICAgICAgICAgICAgaWYgKGZyb20gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZyb20gPSBtaW51dGVzO1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBtaW51dGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGJlZ2dpbmluZywgY2hlY2sgaWYgdGhpcyBpcyBjb25zZWN1dGl2ZVxyXG4gICAgICAgICAgICAgICAgLy8gdG8gcHJldmlvdXMsIGJ5IGNoZWNraW5nIHByZXZpb3VzIHBsdXMgc2xvdFNpemVcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cyArIHNsb3RTaXplID09PSBtaW51dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGVuZFxyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gbWludXRlcztcclxuICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbWludXRlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbnNlY3V0aXZlLCB3ZSBhbHJlYWR5IGhhcyBhIHJhbmdlLCBhbnlcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIHNsb3QgaXMgZGlzY2FyZGVkLCBvdXQgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlY2lzaW9uIG9mIHRoZSBzaW1wbGlmaWVkIHdlZWtseSBzY2hlZHVsZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4gZ28gb3V0IHRoZSBpdGVyYXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogSWYgaW4gYSBmdXR1cmUgYSBtb3JlIGNvbXBsZXRlIHNjaGVkdWxlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSB3cm90ZW4gdXNpbmcgbXVsdGlwbGUgcmFuZ2VzIHJhdGhlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGl2aWR1YWwgc2xvdHMsIHRoaXMgaXMgdGhlIHBsYWNlIHRvIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kaW5nLCBwb3B1bGF0aW5nIGFuIGFycmF5IG9mIFt7ZnJvbSwgdG99XSA6LSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNsb3RzIGNoZWNrZWQsIGNoZWNrIHRoZSByZXN1bHRcclxuICAgICAgICBpZiAoZnJvbSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNpbXBsZURheSA9IHtcclxuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXHJcbiAgICAgICAgICAgICAgICB0bzogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzaW1wbGVXU1t3ZWVrZGF5XSA9IHNpbXBsZURheTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSByYW5nZSFcclxuICAgICAgICAgICAgaWYgKHRvICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgaGFzIGFuIGVuZCFcclxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgc2xvdCBzaXplIHRvIHRoZSBlbmRpbmdcclxuICAgICAgICAgICAgICAgIHNpbXBsZURheS50byA9IHRvICsgc2xvdFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyIHJhbmdlLCBqdXN0IG9uZSBzbG90LFxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBzbG90IHNpemUgdG8gdGhlIGJlZ2luaW5nXHJcbiAgICAgICAgICAgICAgICBzaW1wbGVEYXkudG8gPSBmcm9tICsgc2xvdFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEb25lIVxyXG4gICAgcmV0dXJuIHNpbXBsZVdTO1xyXG59XHJcblxyXG4vKipcclxuICAgIFBhc3MgaW4gYSBwbGFpbiBvYmplY3QsIG5vdCBhIG1vZGVsLFxyXG4gICAgZ2V0dGluZyBhbiBvYmplY3Qgc3VpdGFibGUgZm9yIHRoZSBBUEkgZW5kcG9pbnQuXHJcbioqL1xyXG5mdW5jdGlvbiB0b1dlZWtseVNjaGVkdWxlKHNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSkge1xyXG5cclxuICAgIHZhciBzbG90U2l6ZSA9IGRlZmF1bHRTbG90U2l6ZTtcclxuICAgIFxyXG4gICAgLy8gSXQncyBidWlsZCB3aXRoICdhdmFpbGFibGUnIGFzIGV4cGxpY2l0IHN0YXR1czpcclxuICAgIHZhciB3ZWVrbHlTY2hlZHVsZSA9IHtcclxuICAgICAgICBzdGF0dXM6ICdhdmFpbGFibGUnLFxyXG4gICAgICAgIGRlZmF1bHRBdmFpbGFiaWxpdHk6ICd1bmF2YWlsYWJsZScsXHJcbiAgICAgICAgc2xvdHM6IHt9LFxyXG4gICAgICAgIHNsb3RTaXplOiBzbG90U2l6ZVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQZXIgd2Vla2RheVxyXG4gICAgT2JqZWN0LmtleXMoc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlKVxyXG4gICAgLmZvckVhY2goZnVuY3Rpb24od2Vla2RheSkge1xyXG5cclxuICAgICAgICAvLyBWZXJpZnkgaXMgYSB3ZWVrZGF5IHByb3BlcnR5LCBvciBleGl0IGVhcmx5XHJcbiAgICAgICAgaWYgKHdlZWtEYXlQcm9wZXJ0aWVzLmluZGV4T2Yod2Vla2RheSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaW1wbGVEYXkgPSBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGVbd2Vla2RheV07XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZXhwYW5kIHRoZSBzaW1wbGlmaWVkIHRpbWUgcmFuZ2VzIFxyXG4gICAgICAgIC8vIGluIHNsb3RzIG9mIHRoZSBzbG90U2l6ZVxyXG4gICAgICAgIC8vIFRoZSBlbmQgdGltZSB3aWxsIGJlIGV4Y2x1ZGVkLCBzaW5jZSBzbG90c1xyXG4gICAgICAgIC8vIGRlZmluZSBvbmx5IHRoZSBzdGFydCwgYmVpbmcgaW1wbGljaXQgdGhlIHNsb3RTaXplLlxyXG4gICAgICAgIHZhciBmcm9tID0gc2ltcGxlRGF5LmZyb20gfDAsXHJcbiAgICAgICAgICAgIHRvID0gc2ltcGxlRGF5LnRvIHwwO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHNsb3QgYXJyYXlcclxuICAgICAgICB3ZWVrbHlTY2hlZHVsZS5zbG90c1t3ZWVrZGF5XSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBJbnRlZ3JpdHkgdmVyaWZpY2F0aW9uXHJcbiAgICAgICAgaWYgKHRvID4gZnJvbSkge1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGJ5IHRoZSBzbG90U2l6ZSB1bnRpbCB3ZSByZWFjaFxyXG4gICAgICAgICAgICAvLyB0aGUgZW5kLCBub3QgaW5jbHVkaW5nIHRoZSAndG8nIHNpbmNlXHJcbiAgICAgICAgICAgIC8vIHNsb3RzIGluZGljYXRlIG9ubHkgdGhlIHN0YXJ0IG9mIHRoZSBzbG90XHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgYXNzdW1lZCB0byBmaWxsIGEgc2xvdFNpemUgc3RhcnRpbmdcclxuICAgICAgICAgICAgLy8gb24gdGhhdCBzbG90LXRpbWVcclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gZnJvbTtcclxuICAgICAgICAgICAgd2hpbGUgKHByZXZpb3VzIDwgdG8pIHtcclxuICAgICAgICAgICAgICAgIHdlZWtseVNjaGVkdWxlLnNsb3RzW3dlZWtkYXldLnB1c2gobWludXRlc1RvVGltZVN0cmluZyhwcmV2aW91cykpO1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgKz0gc2xvdFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEb25lIVxyXG4gICAgcmV0dXJuIHdlZWtseVNjaGVkdWxlO1xyXG59XHJcblxyXG4vKipcclxuICAgIGludGVybmFsIHV0aWxpdHkgZnVuY3Rpb24gJ3RvIHN0cmluZyB3aXRoIHR3byBkaWdpdHMgYWxtb3N0J1xyXG4qKi9cclxuZnVuY3Rpb24gdHdvRGlnaXRzKG4pIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyAxMCkgKyAnJyArIG4gJSAxMDtcclxufVxyXG5cclxuLyoqXHJcbiAgICBDb252ZXJ0IGEgbnVtYmVyIG9mIG1pbnV0ZXNcclxuICAgIGluIGEgc3RyaW5nIGxpa2U6IDAwOjAwOjAwIChob3VyczptaW51dGVzOnNlY29uZHMpXHJcbioqL1xyXG5mdW5jdGlvbiBtaW51dGVzVG9UaW1lU3RyaW5nKG1pbnV0ZXMpIHtcclxuICAgIHZhciBkID0gbW9tZW50LmR1cmF0aW9uKG1pbnV0ZXMsICdtaW51dGVzJyksXHJcbiAgICAgICAgaCA9IGQuaG91cnMoKSxcclxuICAgICAgICBtID0gZC5taW51dGVzKCksXHJcbiAgICAgICAgcyA9IGQuc2Vjb25kcygpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHR3b0RpZ2l0cyhoKSArICc6JyArXHJcbiAgICAgICAgdHdvRGlnaXRzKG0pICsgJzonICtcclxuICAgICAgICB0d29EaWdpdHMocylcclxuICAgICk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBNb2RlbCBBUEkgdG8gbWFuYWdlIHRoZSBjb2xsZWN0aW9uIG9mIEpvYiBUaXRsZXMgYXNzaWduZWRcclxuICAgIHRvIHRoZSBjdXJyZW50IHVzZXIgYW5kIGl0cyB3b3JraW5nIGRhdGEuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVXNlckpvYlRpdGxlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1VzZXJKb2JUaXRsZScpLFxyXG4gICAgQ2FjaGVDb250cm9sID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2FjaGVDb250cm9sJyksXHJcbiAgICBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG5cclxuICAgIHZhciBhcGkgPSB7fSxcclxuICAgICAgICBkZWZhdWx0VHRsID0geyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgY2FjaGUgPSB7XHJcbiAgICAgICAgICAgIC8vIEFycmF5IG9mIHVzZXIgam9iIHRpdGxlcyBtYWtpbmdcclxuICAgICAgICAgICAgLy8gaXRzIHByb2ZpbGVcclxuICAgICAgICAgICAgdXNlckpvYlByb2ZpbGU6IHtcclxuICAgICAgICAgICAgICAgIGNhY2hlOiBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiBkZWZhdWx0VHRsIH0pLFxyXG4gICAgICAgICAgICAgICAgbGlzdDogbnVsbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBJbmRleGVkIGxpc3QgYnkgam9iVGl0bGVJRCB0byB0aGUgdXNlciBqb2IgdGl0bGVzIG1vZGVsc1xyXG4gICAgICAgICAgICAvLyBpbiB0aGUgbGlzdCBhbmQgY2FjaGUgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgdXNlckpvYlRpdGxlczogey8qXHJcbiAgICAgICAgICAgICAgICBqb2JUaXRsZUlEOiB7IG1vZGVsOiBvYmplY3QsIGNhY2hlOiBDYWNoZUNvbnRyb2wgfVxyXG4gICAgICAgICAgICAqL31cclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBPYnNlcnZhYmxlIGxpc3RcclxuICAgIGFwaS5saXN0ID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuICAgIC8vIE5PVEU6IEJhc2ljIGltcGxlbWVudGF0aW9uLCB0byBlbmhhbmNlXHJcbiAgICBhcGkuc3luY0xpc3QgPSBmdW5jdGlvbiBzeW5jTGlzdCgpIHtcclxuICAgICAgICByZXR1cm4gYXBpLmdldFVzZXJKb2JQcm9maWxlKCkudGhlbihmdW5jdGlvbihsaXN0KSB7XHJcbiAgICAgICAgICAgIGFwaS5saXN0KGxpc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICBjYWNoZS51c2VySm9iUHJvZmlsZS5jYWNoZS5sYXRlc3QgPSBudWxsO1xyXG4gICAgICAgIGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QgPSBbXTtcclxuICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzID0ge307XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgQ29udmVydCByYXcgYXJyYXkgb2Ygam9iIHRpdGxlcyByZWNvcmRzIGludG9cclxuICAgICAgICBhbiBpbmRleGVkIGFycmF5IG9mIG1vZGVscywgYWN0dWFsbHkgYW4gb2JqZWN0XHJcbiAgICAgICAgd2l0aCBJRCBudW1iZXJzIGFzIHByb3BlcnRpZXMsXHJcbiAgICAgICAgYW5kIGNhY2hlIGl0IGluIG1lbW9yeS5cclxuICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWFwVG9Vc2VySm9iUHJvZmlsZShyYXdJdGVtcykge1xyXG4gICAgICAgIGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QgPSBbXTtcclxuICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzID0ge307XHJcblxyXG4gICAgICAgIGlmIChyYXdJdGVtcykge1xyXG4gICAgICAgICAgICByYXdJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKHJhd0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gbmV3IFVzZXJKb2JUaXRsZShyYXdJdGVtKTtcclxuICAgICAgICAgICAgICAgIGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QucHVzaChtKTtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmluZyBhbmQgaW5kZXhlZCBjb3B5IGFuZCBwZXIgaXRlbSBjYWNoZSBpbmZvXHJcbiAgICAgICAgICAgICAgICBzZXRHZXRVc2VySm9iVGl0bGVUb0NhY2hlKHJhd0l0ZW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG9ic2VydmFibGVcclxuICAgICAgICBhcGkubGlzdChjYWNoZS51c2VySm9iUHJvZmlsZS5saXN0KTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNhY2hlIHN0YXRlXHJcbiAgICAgICAgY2FjaGUudXNlckpvYlByb2ZpbGUuY2FjaGUubGF0ZXN0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IHRoZSBmdWxsIGpvYlByb2ZpbGUgZnJvbSBsb2NhbCBjb3B5LCB0aHJvd2luZyBhIFByb21pc2UgcmVqZWN0IGV4Y2VwdGlvbiBpZiBub3RoaW5nXHJcbiAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGdldFVzZXJKb2JQcm9maWxlRnJvbUxvY2FsKCkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCd1c2VySm9iUHJvZmlsZScpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odXNlckpvYlByb2ZpbGUpIHtcclxuICAgICAgICAgICAgaWYgKHVzZXJKb2JQcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwVG9Vc2VySm9iUHJvZmlsZSh1c2VySm9iUHJvZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0dXJuIG51bGwgc2luY2UgdGhlcmUgaXMgbm8gZGF0YSwgdGhlIHByb21pc2UgY2FuIGNhdGNoXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIGRhdGEgYW5kIGF0dGVtcHQgYSByZW1vdGVcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIFNldCBhIHJhdyB1c2VySm9iUHJvZmlsZSByZWNvcmQgKGZyb20gc2VydmVyKSBhbmQgc2V0IGl0IGluIHRoZVxyXG4gICAgICAgIGNhY2hlLCBjcmVhdGluZyBvciB1cGRhdGluZyB0aGUgbW9kZWwgKHNvIGFsbCB0aGUgdGltZSB0aGUgc2FtZSBtb2RlbCBpbnN0YW5jZVxyXG4gICAgICAgIGlzIHVzZWQpIGFuZCBjYWNoZSBjb250cm9sIGluZm9ybWF0aW9uLlxyXG4gICAgICAgIFJldHVybnMgdGhlIG1vZGVsIGluc3RhbmNlLlxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBzZXRHZXRVc2VySm9iVGl0bGVUb0NhY2hlKHJhd0l0ZW0pIHtcclxuICAgICAgICB2YXIgYyA9IGNhY2hlLnVzZXJKb2JUaXRsZXNbcmF3SXRlbS5qb2JUaXRsZUlEXSB8fCB7fTtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1vZGVsIGlmIGV4aXN0cywgc28gZ2V0IHJlZmxlY3RlZCB0byBhbnlvbmUgY29uc3VtaW5nIGl0XHJcbiAgICAgICAgaWYgKGMubW9kZWwpIHtcclxuICAgICAgICAgICAgYy5tb2RlbC5tb2RlbC51cGRhdGVXaXRoKHJhd0l0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSwgY3JlYXRlIG1vZGVsXHJcbiAgICAgICAgICAgIGMubW9kZWwgPSBuZXcgVXNlckpvYlRpdGxlKHJhd0l0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgY2FjaGUgY29udHJvbFxyXG4gICAgICAgIGlmIChjLmNhY2hlKSB7XHJcbiAgICAgICAgICAgIGMuY2FjaGUubGF0ZXN0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGMuY2FjaGUgPSBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiBkZWZhdWx0VHRsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHByb2ZpbGUgbGlzdCwgYWRkIG9yIHVwZGF0ZTpcclxuICAgICAgICB2YXIgZnVsbExpc3QgPSAgY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdDtcclxuICAgICAgICBpZiAoZnVsbExpc3QpIHtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gbnVsbDtcclxuICAgICAgICAgICAgZnVsbExpc3Quc29tZShmdW5jdGlvbihpdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0LmpvYlRpdGxlSUQoKSA9PT0gcmF3SXRlbS5qb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpdDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgZm91bmQubW9kZWwudXBkYXRlV2l0aChyYXdJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZ1bGxMaXN0LnB1c2goYy5tb2RlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RlbCwgdXBkYXRlZCBvciBqdXN0IGNyZWF0ZWRcclxuICAgICAgICByZXR1cm4gYy5tb2RlbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IHRoZSBjb250ZW50IGZyb20gdGhlIGNhY2hlLCBmb3IgZnVsbCBwcm9maWxlXHJcbiAgICAgICAgYW5kIHNhdmUgaXQgaW4gbG9jYWwgc3RvcmFnZVxyXG4gICAgICAgIE5PVEUgSXQgaGFzIG5vIHNlbnNlIGluIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gKHByb2JsZW0gb2YgZmV0Y2hcclxuICAgICAgICBqb2IgdGl0bGUgd2l0aG91dCBhIGZ1bGwgam9iIHByb2ZpbGUgaW4gY2FjaGUvbG9jYWwpXHJcbiAgICAqKi9cclxuICAgIC8qZnVuY3Rpb24gc2F2ZUNhY2hlSW5Mb2NhbCgpIHtcclxuICAgICAgICB2YXIgcGxhaW4gPSBjYWNoZS51c2VySm9iUHJvZmlsZS5saXN0Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgIC8vIEVhY2ggaXRlbSBpcyBhIG1vZGVsLCBnZXQgaXQgaW4gcGxhaW46XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLm1vZGVsLnRvUGxhaW5PYmplY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsb2NhbGZvcmFnZS5zZXRJdGVtKCd1c2VySm9iUHJvZmlsZScsIHBsYWluKTtcclxuICAgIH0qL1xyXG4gICAgXHJcbiAgICAvLyBQcml2YXRlLCBmZXRjaCBmcm9tIHJlbW90ZVxyXG4gICAgdmFyIGZldGNoVXNlckpvYlByb2ZpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gVGhpcmQgYW5kIGxhc3QsIHJlbW90ZSBsb2FkaW5nXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2VyLWpvYi1wcm9maWxlJylcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmF3KSB7XHJcbiAgICAgICAgICAgIC8vIENhY2hlIGluIGxvY2FsIHN0b3JhZ2VcclxuICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgndXNlckpvYlByb2ZpbGUnLCByYXcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwVG9Vc2VySm9iUHJvZmlsZShyYXcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUHVibGljIEFQSVxyXG4gICAgICAgIEdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBVc2VySm9iVGl0bGUgZm9yXHJcbiAgICAgICAgYWxsIHRoZSBKb2JUaXRsZXMgYXNzaWduZWQgdG8gdGhlIGN1cnJlbnQgdXNlclxyXG4gICAgKiovXHJcbiAgICBhcGkuZ2V0VXNlckpvYlByb2ZpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSWYgbm8gY2FjaGUgb3IgbXVzdCByZXZhbGlkYXRlLCBnbyByZW1vdGVcclxuICAgICAgICAvLyAodGhlIGZpcnN0IGxvYWRpbmcgaXMgZXZlciAnbXVzdCByZXZhbGlkYXRlJylcclxuICAgICAgICBpZiAoY2FjaGUudXNlckpvYlByb2ZpbGUuY2FjaGUubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjYWNoZSwgaXMgZmlyc3QgbG9hZCwgc28gdHJ5IGxvY2FsXHJcbiAgICAgICAgICAgIGlmICghY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9jYWwgc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFVzZXJKb2JQcm9maWxlRnJvbUxvY2FsKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsYXVuY2ggcmVtb3RlIGZvciBzeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZVByb21pc2UgPSBmZXRjaFVzZXJKb2JQcm9maWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3RlIGZhbGxiYWNrOiBJZiBubyBsb2NhbCwgd2FpdCBmb3IgcmVtb3RlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhIDogcmVtb3RlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gY2FjaGUsIG5vIGxvY2FsLCBvciBvYnNvbGV0ZSwgZ28gcmVtb3RlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoVXNlckpvYlByb2ZpbGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgY2FjaGUgYW5kIGlzIHN0aWxsIHZhbGlkOlxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIFByaXZhdGUsIGZldGNoIGZyb20gcmVtb3RlXHJcbiAgICB2YXIgZmV0Y2hVc2VySm9iVGl0bGUgPSBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2VyLWpvYi1wcm9maWxlLycgKyBqb2JUaXRsZUlEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJhdykge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHRvIGNhY2hlIGFuZCBnZXQgbW9kZWxcclxuICAgICAgICAgICAgdmFyIG0gPSBzZXRHZXRVc2VySm9iVGl0bGVUb0NhY2hlKHJhdyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBjYWNoZSBzYXZpbmcgZm9yIHNpbmdsZSBqb2ItdGl0bGVzLCBjdXJyZW50bHlcclxuICAgICAgICAgICAgLy8gaXQgbmVlZHMgdG8gc2F2ZSB0aGUgcHJvZmlsZSBjYWNoZSwgdGhhdCBtYXkgbm90IGV4aXN0cyBpZlxyXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgcmVxdWVzdCBpcyBmb3IgYSBzaW5nbGUgam9iIHRpdGxlLlxyXG4gICAgICAgICAgICAvLyBOZXh0IGxpbmVzIGFyZSB0byBzYXZlIGZ1bGwgcHJvZmlsZSwgbm90IHZhbGlkIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWxcclxuICAgICAgICAgICAgLy9zYXZlQ2FjaGVJbkxvY2FsKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gbW9kZWxcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgcHVzaE5ld1VzZXJKb2JUaXRsZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xyXG4gICAgICAgIC8vIENyZWF0ZSBqb2IgdGl0bGUgaW4gcmVtb3RlXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucG9zdCgndXNlci1qb2ItcHJvZmlsZScsICQuZXh0ZW5kKHtcclxuICAgICAgICAgICAgam9iVGl0bGVJRDogMCxcclxuICAgICAgICAgICAgam9iVGl0bGVOYW1lOiAnJyxcclxuICAgICAgICAgICAgaW50cm86ICcnLFxyXG4gICAgICAgICAgICBjYW5jZWxsYXRpb25Qb2xpY3lJRDogbnVsbCxcclxuICAgICAgICAgICAgaW5zdGFudEJvb2tpbmc6IGZhbHNlXHJcbiAgICAgICAgfSwgdmFsdWVzKSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihyYXcpIHtcclxuICAgICAgICAgICAgLy8gU2F2ZSB0byBjYWNoZSBhbmQgZ2V0IG1vZGVsXHJcbiAgICAgICAgICAgIHZhciBtID0gc2V0R2V0VXNlckpvYlRpdGxlVG9DYWNoZShyYXcpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgY2FjaGUgc2F2aW5nIGZvciBzaW5nbGUgam9iLXRpdGxlcywgY3VycmVudGx5XHJcbiAgICAgICAgICAgIC8vIGl0IG5lZWRzIHRvIHNhdmUgdGhlIHByb2ZpbGUgY2FjaGUsIHRoYXQgbWF5IG5vdCBleGlzdHMgaWZcclxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHJlcXVlc3QgaXMgZm9yIGEgc2luZ2xlIGpvYiB0aXRsZS5cclxuICAgICAgICAgICAgLy8gTmV4dCBsaW5lcyBhcmUgdG8gc2F2ZSBmdWxsIHByb2ZpbGUsIG5vdCB2YWxpZCBoZXJlLlxyXG4gICAgICAgICAgICAvLyBTYXZlIGluIGxvY2FsXHJcbiAgICAgICAgICAgIC8vc2F2ZUNhY2hlSW5Mb2NhbCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmV0dXJuIG1vZGVsXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUHVibGljIEFQSVxyXG4gICAgICAgIEdldCBhIFVzZXJKb2JUaXRsZSByZWNvcmQgZm9yIHRoZSBnaXZlblxyXG4gICAgICAgIEpvYlRpdGxlSUQgYW5kIHRoZSBjdXJyZW50IHVzZXIuXHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXRVc2VySm9iVGl0bGUgPSBmdW5jdGlvbiAoam9iVGl0bGVJRCkge1xyXG4gICAgICAgIC8vIFF1aWNrIGVycm9yXHJcbiAgICAgICAgaWYgKCFqb2JUaXRsZUlEKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0pvYiBUaXRsZSBJRCByZXF1aXJlZCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vIGNhY2hlIG9yIG11c3QgcmV2YWxpZGF0ZSwgZ28gcmVtb3RlXHJcbiAgICAgICAgaWYgKCFjYWNoZS51c2VySm9iVGl0bGVzW2pvYlRpdGxlSURdIHx8XHJcbiAgICAgICAgICAgIGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0uY2FjaGUubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hVc2VySm9iVGl0bGUoam9iVGl0bGVJRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IGNhY2hlXHJcbiAgICAgICAgICAgIGlmIChjYWNoZS51c2VySm9iVGl0bGVzW2pvYlRpdGxlSURdICYmXHJcbiAgICAgICAgICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzW2pvYlRpdGxlSURdLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0ubW9kZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kLCBsb2NhbCBzdG9yYWdlLCB3aGVyZSB3ZSBoYXZlIHRoZSBmdWxsIGpvYiBwcm9maWxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VXNlckpvYlByb2ZpbGVGcm9tTG9jYWwoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oLyp1c2VySm9iUHJvZmlsZSovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG5lZWQgZm9yIHRoZSBwYXJhbWV0ZXIsIHRoZSBkYXRhIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWVtb3J5IGFuZCBpbmRleGVkLCBsb29rIGZvciB0aGUgam9iIHRpdGxlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0ubW9kZWw7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gbG9jYWwgY29weSAoZXJyb3Igb24gcHJvbWlzZSksXHJcbiAgICAgICAgICAgICAgICAvLyBvciB0aGF0IGRvZXMgbm90IGNvbnRhaW5zIHRoZSBqb2IgdGl0bGUgKGVycm9yIG9uICd0aGVuJyk6XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlyZCBhbmQgbGFzdCwgcmVtb3RlIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmZXRjaFVzZXJKb2JUaXRsZS5iaW5kKG51bGwsIGpvYlRpdGxlSUQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5jcmVhdGVVc2VySm9iVGl0bGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHB1c2hOZXdVc2VySm9iVGl0bGUodmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLyoqIEFESVRJT05BTCBVVElMSVRJRVMgKiovXHJcbiAgICBhcGkuZ2V0VXNlckpvYlRpdGxlQW5kSm9iVGl0bGUgPSBmdW5jdGlvbiBnZXRVc2VySm9iVGl0bGVBbmRKb2JUaXRsZShqb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwaS5nZXRVc2VySm9iVGl0bGUoam9iVGl0bGVJRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbih1c2VySm9iVGl0bGUpIHtcclxuICAgICAgICAgICAgLy8gVmVyeSB1bmxpa2VseSBlcnJvclxyXG4gICAgICAgICAgICBpZiAoIXVzZXJKb2JUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdOb3QgRm91bmQnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExKREk6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdZb3UgaGF2ZSBub3QgdGhpcyBqb2IgdGl0bGUgaW4geW91ciBwcm9maWxlLiAnICsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdNYXliZSB3YXMgZGVsZXRlZCBmcm9tIHlvdXIgcHJvZmlsZSByZWNlbnRseS4nXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgam9iIHRpdGxlIGluZm8gdG9vXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICB1c2VySm9iVGl0bGUsXHJcbiAgICAgICAgICAgICAgICBhcHBNb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRClcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihhbGwpIHtcclxuICAgICAgICAgICAgdmFyIGpvYlRpdGxlID0gYWxsWzFdO1xyXG4gICAgICAgICAgICAvLyBWZXJ5IHVubGlrZWx5IGVycm9yXHJcbiAgICAgICAgICAgIGlmICgham9iVGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTm90IEZvdW5kJyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBMSkRJOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgam9iIHRpdGxlIGRvZXMgbm90IGV4aXN0LidcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGpvYlRpdGxlSUQ6IGpvYlRpdGxlSUQsXHJcbiAgICAgICAgICAgICAgICB1c2VySm9iVGl0bGU6IGFsbFswXSxcclxuICAgICAgICAgICAgICAgIGpvYlRpdGxlOiBqb2JUaXRsZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIFVzZXJQcm9maWxlXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVXNlciA9IHJlcXVpcmUoJy4uL21vZGVscy9Vc2VyJyk7XHJcblxyXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IFVzZXIubmV3QW5vbnltb3VzKCksXHJcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IEtlZXAgdGhlIG5hbWUgaW4gc3luYyB3aXRoIHNldC11cCBhdCBBcHBNb2RlbC1hY2NvdW50XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3Byb2ZpbGUnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdwcm9maWxlJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ3Byb2ZpbGUnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcmVtO1xyXG59O1xyXG4iLCIvKiogQXBwb2ludG1lbnRDYXJkIHZpZXcgbW9kZWwuXHJcbiAgICBJdCBwcm92aWRlcyBkYXRhIGFuZCBtZXRob2QgdG8gdmlzdWFsaXplIGFuZCBcclxuICAgIGVkaXQgYW5kIGFwcG9pbnRtZW50IGNhcmQsIHdpdGggYm9va2luZywgZXZlbnRcclxuICAgIG9yIHBsYWNlaG9sZGVyIGluZm9ybWF0aW9uXHJcbioqL1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAgZ2V0T2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldE9ic2VydmFibGUnKSxcclxuICAgIEFwcG9pbnRtZW50VmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvQXBwb2ludG1lbnRWaWV3JyksXHJcbiAgICBNb2RlbFZlcnNpb24gPSByZXF1aXJlKCcuLi91dGlscy9Nb2RlbFZlcnNpb24nKSxcclxuICAgIGdldERhdGVXaXRob3V0VGltZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldERhdGVXaXRob3V0VGltZScpLFxyXG4gICAgUHJpY2luZ0VzdGltYXRlRGV0YWlsID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ByaWNpbmdFc3RpbWF0ZURldGFpbCcpO1xyXG5cclxuZnVuY3Rpb24gQXBwb2ludG1lbnRDYXJkVmlld01vZGVsKHBhcmFtcykge1xyXG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czogMzAqL1xyXG5cclxuICAgIHRoaXMuc291cmNlSXRlbSA9IGdldE9ic2VydmFibGUocGFyYW1zLnNvdXJjZUl0ZW0pO1xyXG4gICAgdmFyIGFwcCA9IHRoaXMuYXBwID0ga28udW53cmFwKHBhcmFtcy5hcHApO1xyXG5cclxuICAgIHRoaXMuZWRpdE1vZGUgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5lZGl0TW9kZSk7XHJcbiAgICB0aGlzLmVkaXRlZFZlcnNpb24gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzU2F2aW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICBcclxuICAgIHRoaXMuaXRlbSA9IGtvLm9ic2VydmFibGUoQXBwb2ludG1lbnRWaWV3KHRoaXMuc291cmNlSXRlbSgpLCBhcHApKTtcclxuICAgIFxyXG4gICAgdGhpcy5jdXJyZW50SUQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGl0ID0gdGhpcy5pdGVtKCk7XHJcbiAgICAgICAgcmV0dXJuIGl0ICYmIGl0LmlkKCkgfHwgMDtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmN1cnJlbnREYXRlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBnZXREYXRlV2l0aG91dFRpbWUodGhpcy5pdGVtKCkgJiYgdGhpcy5pdGVtKCkuc3RhcnRUaW1lKCkpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNOZXcgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzLmN1cnJlbnRJRCgpO1xyXG4gICAgICAgIHJldHVybiBpZCA9PT0gLTMgfHwgaWQgPT09IC00O1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNCb29raW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbSgpICYmIHRoaXMuaXRlbSgpLnNvdXJjZUJvb2tpbmcoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvKiBSZXR1cm4gdHJ1ZSBpZiBpcyBhbiBldmVudCBvYmplY3QgYnV0IG5vdCBhIGJvb2tpbmcgKi9cclxuICAgIHRoaXMuaXNFdmVudCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0oKSAmJiB0aGlzLml0ZW0oKS5zb3VyY2VFdmVudCgpICYmICF0aGlzLml0ZW0oKS5zb3VyY2VCb29raW5nKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBJZiB0aGUgc291cmNlSXRlbSBjaGFuZ2VzLCBpcyBzZXQgYXMgdGhlIGl0ZW0gdmFsdWVcclxuICAgICAgICBkaXNjYXJkaW5nIGFueSBtb2RlbCB2ZXJzaW9uIGFuZCByZXZlcnRpbmdcclxuICAgICAgICBlZGl0TW9kZSB0byBmYWxzZVxyXG4gICAgKiovXHJcbiAgICB0aGlzLnNvdXJjZUl0ZW0uc3Vic2NyaWJlKGZ1bmN0aW9uKHNvdXJjZUl0ZW0pIHtcclxuICAgICAgICB0aGlzLml0ZW0oQXBwb2ludG1lbnRWaWV3KHNvdXJjZUl0ZW0sIGFwcCkpO1xyXG4gICAgICAgIHRoaXMuZWRpdGVkVmVyc2lvbihudWxsKTtcclxuICAgICAgICB0aGlzLmVkaXRNb2RlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIG5ldyBpdGVtIGlzIGEgbmV3IG9uZSwgc2V0IGVkaXQgbW9kZVxyXG4gICAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBFbnRlciBhbmQgZmluaXNoIGVkaXQ6XHJcbiAgICAgICAgQ3JlYXRlIHZlcnNpb24gYW5kIHNhdmUgZGF0YVxyXG4gICAgKiovXHJcbiAgICB0aGlzLmVkaXRNb2RlLnN1YnNjcmliZShmdW5jdGlvbihpc0VkaXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50SUQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB2ZXJzaW9uO1xyXG5cclxuICAgICAgICBpZiAoaXNFZGl0KSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgc2V0IGEgdmVyc2lvbiB0byBiZSBlZGl0ZWRcclxuICAgICAgICAgICAgdmVyc2lvbiA9IG5ldyBNb2RlbFZlcnNpb24odGhpcy5zb3VyY2VJdGVtKCkpO1xyXG4gICAgICAgICAgICB2ZXJzaW9uLnZlcnNpb24uc291cmNlRXZlbnQodGhpcy5zb3VyY2VJdGVtKCkuc291cmNlRXZlbnQoKSk7XHJcbiAgICAgICAgICAgIHZlcnNpb24udmVyc2lvbi5zb3VyY2VCb29raW5nKHRoaXMuc291cmNlSXRlbSgpLnNvdXJjZUJvb2tpbmcoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZWRpdGVkVmVyc2lvbih2ZXJzaW9uKTtcclxuICAgICAgICAgICAgdGhpcy5pdGVtKEFwcG9pbnRtZW50Vmlldyh2ZXJzaW9uLnZlcnNpb24sIGFwcCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0dXAgYXV0by1zYXZpbmdcclxuICAgICAgICAgICAgdmVyc2lvbi5vbigncHVzaCcsIGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBhcHAubW9kZWwuYXBwb2ludG1lbnRzLnNldEFwcG9pbnRtZW50KHZlcnNpb24udmVyc2lvbilcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihzYXZlZEFwdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciB3YXNOZXcgPSB2ZXJzaW9uLm9yaWdpbmFsLmlkKCkgPCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd2l0aCByZW1vdGUgZGF0YSwgdGhlIG9yaWdpbmFsIGFwcG9pbnRtZW50IGluIHRoZSB2ZXJzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgdGhlIGN1cnJlbnRBcHBvaW50bWVudCBvciBpbiB0aGUgaW5kZXggaW4gdGhlIGxpc3QgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmFjZS1jb25kaXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24ub3JpZ2luYWwubW9kZWwudXBkYXRlV2l0aChzYXZlZEFwdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXNOZXc6dHJ1ZTogYWRkIHRvIHRoZSBsaXN0IGFuZCBzb3J0IGl0Pz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSB3aXphcmQgZm9yIGJvb2tpbmdzLCBzbyBtYXkgYmUgZGlmZmVyZW50IG9uIHRoYXQgY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHNhdmluZyB0aGUgZGF0YS4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmVwbGljYXRlIGVycm9yLCBhbGxvdyBhbHdheXNcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBTFdBWVM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHZlcnNpb24/IFB1c2ggY2hhbmdlcyFcclxuICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMuZWRpdGVkVmVyc2lvbigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZlcnNpb24gJiYgdmVyc2lvbi5hcmVEaWZmZXJlbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUHVzaCB2ZXJzaW9uIHRvIG9yaWdpbmFsLCB3aWxsIGxhdW5jaCBhIHJlbW90ZSB1cGRhdGUgXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBhbml0aGluZyBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc2sgZm9yIGNvbmZpcm1hdGlvbiBpZiB2ZXJzaW9uIGlzT2Jzb2xldGVcclxuICAgICAgICAgICAgICAgIHZlcnNpb24ucHVzaCh7IGV2ZW5JZk9ic29sZXRlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5lZGl0ID0gZnVuY3Rpb24gZWRpdCgpIHtcclxuICAgICAgICAvLyBBIHN1YnNjcmliZWQgaGFuZGxlciBlbnN1cmUgdG8gZG8gdGhlIG5lZWRlZCB0YXNrc1xyXG4gICAgICAgIHRoaXMuZWRpdE1vZGUodHJ1ZSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XHJcbiAgICAgICAgLy8gQSBzdWJzY3JpYmVkIGhhbmRsZXIgZW5zdXJlIHRvIGRvIHRoZSBuZWVkZWQgdGFza3NcclxuICAgICAgICB0aGlzLmVkaXRNb2RlKGZhbHNlKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWRpdGVkVmVyc2lvbigpKSB7XHJcbiAgICAgICAgICAgIC8vIERpc2NhcmQgcHJldmlvdXMgdmVyc2lvblxyXG4gICAgICAgICAgICB0aGlzLmVkaXRlZFZlcnNpb24oKS5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE91dCBvZiBlZGl0IG1vZGVcclxuICAgICAgICB0aGlzLmVkaXRNb2RlKGZhbHNlKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBFeHRlcm5hbCBhY3Rpb25zXHJcbiAgICAqKi9cclxuICAgIHZhciBlZGl0RmllbGRPbiA9IGZ1bmN0aW9uIGVkaXRGaWVsZE9uKGFjdGl2aXR5LCBkYXRhKSB7XHJcblxyXG4gICAgICAgIC8vIEluY2x1ZGUgYXBwb2ludG1lbnQgdG8gcmVjb3ZlciBzdGF0ZSBvbiByZXR1cm46XHJcbiAgICAgICAgZGF0YS5hcHBvaW50bWVudCA9IHRoaXMuaXRlbSgpLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XHJcblxyXG4gICAgICAgIGFwcC5zaGVsbC5nbyhhY3Rpdml0eSwgZGF0YSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5waWNrRGF0ZVRpbWUgPSBmdW5jdGlvbiBwaWNrRGF0ZVRpbWUoKSB7XHJcblxyXG4gICAgICAgIGVkaXRGaWVsZE9uKCdkYXRldGltZVBpY2tlcicsIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWREYXRldGltZTogdGhpcy5pdGVtKCkuc3RhcnRUaW1lKCksXHJcbiAgICAgICAgICAgIGhlYWRlclRleHQ6ICdTZWxlY3QgdGhlIHN0YXJ0IHRpbWUnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5waWNrQ2xpZW50ID0gZnVuY3Rpb24gcGlja0NsaWVudCgpIHtcclxuXHJcbiAgICAgICAgZWRpdEZpZWxkT24oJ2NsaWVudHMnLCB7XHJcbiAgICAgICAgICAgIHNlbGVjdENsaWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRDbGllbnRJRDogdGhpcy5pdGVtKCkuc291cmNlQm9va2luZygpLmJvb2tpbmdSZXF1ZXN0KCkuY3VzdG9tZXJVc2VySUQoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucGlja1NlcnZpY2UgPSBmdW5jdGlvbiBwaWNrU2VydmljZSgpIHtcclxuXHJcbiAgICAgICAgZWRpdEZpZWxkT24oJ2ZyZWVsYW5jZXJQcmljaW5nLycgKyB0aGlzLml0ZW0oKS5qb2JUaXRsZUlEKCksIHtcclxuICAgICAgICAgICAgc2VsZWN0UHJpY2luZzogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRQcmljaW5nOiB0aGlzLml0ZW0oKS5wcmljaW5nKClcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwcmljaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyZWVsYW5jZXJQcmljaW5nSUQ6IGtvLnVud3JhcChwcmljaW5nLmZyZWVsYW5jZXJQcmljaW5nSUQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUHJpY2U6IGtvLnVud3JhcChwcmljaW5nLnRvdGFsUHJpY2UpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2hhbmdlUHJpY2UgPSBmdW5jdGlvbiBjaGFuZ2VQcmljZSgpIHtcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5waWNrTG9jYXRpb24gPSBmdW5jdGlvbiBwaWNrTG9jYXRpb24oKSB7XHJcblxyXG4gICAgICAgIGVkaXRGaWVsZE9uKCdzZXJ2aWNlQWRkcmVzc2VzLycgKyB0aGlzLml0ZW0oKS5qb2JUaXRsZUlEKCksIHtcclxuICAgICAgICAgICAgc2VsZWN0QWRkcmVzczogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzSUQ6IHRoaXMuaXRlbSgpLmFkZHJlc3NJRCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdmFyIHRleHRGaWVsZHNIZWFkZXJzID0ge1xyXG4gICAgICAgIHByZU5vdGVzVG9DbGllbnQ6ICdOb3RlcyB0byBjbGllbnQnLFxyXG4gICAgICAgIHBvc3ROb3Rlc1RvQ2xpZW50OiAnTm90ZXMgdG8gY2xpZW50IChhZnRlcndhcmRzKScsXHJcbiAgICAgICAgcHJlTm90ZXNUb1NlbGY6ICdOb3RlcyB0byBzZWxmJyxcclxuICAgICAgICBwb3N0Tm90ZXNUb1NlbGY6ICdCb29raW5nIHN1bW1hcnknLFxyXG4gICAgICAgIHN1bW1hcnk6ICdXaGF0PydcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5lZGl0VGV4dEZpZWxkID0gZnVuY3Rpb24gZWRpdFRleHRGaWVsZChmaWVsZCkge1xyXG5cclxuICAgICAgICBlZGl0RmllbGRPbigndGV4dEVkaXRvcicsIHtcclxuICAgICAgICAgICAgcmVxdWVzdDogJ3RleHRFZGl0b3InLFxyXG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXHJcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmlzTmV3KCkgPyAnTmV3IGJvb2tpbmcnIDogJ0Jvb2tpbmcnLFxyXG4gICAgICAgICAgICBoZWFkZXI6IHRleHRGaWVsZHNIZWFkZXJzW2ZpZWxkXSxcclxuICAgICAgICAgICAgdGV4dDogdGhpcy5pdGVtKClbZmllbGRdKClcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgLy8gcGFzcyB0aGlzIHJlYWR5IG1vZGVsIHZpZXcgYXMgYW4gQVBJIHRvIHRoZSBvdXRzaWRlXHJcbiAgICBpZiAodHlwZW9mKHBhcmFtcy5hcGkpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcGFyYW1zLmFwaSh0aGlzKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAgICBJdCBtYW5hZ2VzIGluY29taW5nIGRhdGEgcHJvdmlkZWQgYnkgZXh0ZXJuYWwgYWN0aXZpdGllcyBnaXZlblxyXG4gICAgdGhlIHJlcXVlc3REYXRhIHJlY2VpdmVkIGJ5IHRoZSBhY3Rpdml0eSBob3N0aW5nIHRoaXMgdmlldyBpbnN0YW5jZS5cclxuICAgIFVzZWQgdG8gbWFuYWdlIHRoZSBkYXRhIHJldHVybmVkIGJ5IGNhbGxzIHRvIGVkaXQgZGF0YSBpblxyXG4gICAgZXh0ZXJuYWwgYWN0aXZpdGllcy5cclxuKiovXHJcbkFwcG9pbnRtZW50Q2FyZFZpZXdNb2RlbC5wcm90b3R5cGUucGFzc0luID0gZnVuY3Rpb24gcGFzc0luKHJlcXVlc3REYXRhKSB7XHJcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjkgKi9cclxuICAgIFxyXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgaW5jbHVkZXMgYW4gYXBwb2ludG1lbnQgcGxhaW4gb2JqZWN0LCB0aGF0J3MgYW5cclxuICAgIC8vIGluLWVkaXRpbmcgYXBwb2ludG1lbnQgc28gcHV0IGl0IGluIHBsYWNlICh0byByZXN0b3JlIGEgcHJldmlvdXMgZWRpdGlvbilcclxuICAgIGlmIChyZXF1ZXN0RGF0YS5hcHBvaW50bWVudCkge1xyXG4gICAgICAgIC8vIFNldCB0aGUgZWRpdCBtb2RlIChpdCBwZXJmb3JtcyBhbnkgcmVxdWlyZWRcclxuICAgICAgICAvLyBzZXQtdXAgaWYgd2UgYXJlIG5vdCBzdGlsbCBpbiBlZGl0IG1vZGUpLlxyXG4gICAgICAgIHRoaXMuZWRpdE1vZGUodHJ1ZSk7XHJcbiAgICAgICAgLy8gU2V0cyB0aGUgZGF0YVxyXG4gICAgICAgIHRoaXMuaXRlbSgpXHJcbiAgICAgICAgLm1vZGVsLnVwZGF0ZVdpdGgocmVxdWVzdERhdGEuYXBwb2ludG1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gT24gYW55IG90aGVyIGNhc2UsIGFuZCB0byBwcmV2ZW50IGEgYmFkIGVkaXRNb2RlIHN0YXRlLFxyXG4gICAgICAgIC8vIHNldCBvZmYgZWRpdCBtb2RlIGRpc2NhcmRpbmcgdW5zYXZlZCBkYXRhOlxyXG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vLyBNYW5hZ2Ugc3BlY2lmaWMgc2luZ2xlIGRhdGEgZnJvbSBleHRlcm5hbGx5IHByb3ZpZGVkXHJcbiAgICBcclxuICAgIC8vIEl0IGNvbWVzIGJhY2sgZnJvbSB0aGUgdGV4dEVkaXRvci5cclxuICAgIGlmIChyZXF1ZXN0RGF0YS5yZXF1ZXN0ID09PSAndGV4dEVkaXRvcicpIHtcclxuICAgICAgICB0aGlzLml0ZW0oKVtyZXF1ZXN0RGF0YS5maWVsZF0ocmVxdWVzdERhdGEudGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdERhdGEuc2VsZWN0Q2xpZW50ID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtKCkuY3VzdG9tZXJVc2VySUQocmVxdWVzdERhdGEuc2VsZWN0ZWRDbGllbnRJRCk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mKHJlcXVlc3REYXRhLnNlbGVjdGVkRGF0ZXRpbWUpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMuaXRlbSgpLnN0YXJ0VGltZShyZXF1ZXN0RGF0YS5zZWxlY3RlZERhdGV0aW1lKTtcclxuICAgICAgICAvLyBUT0RPIENhbGN1bGF0ZSB0aGUgZW5kVGltZSBnaXZlbiBhbiBhcHBvaW50bWVudCBkdXJhdGlvbiwgcmV0cmlldmVkXHJcbiAgICAgICAgLy8gZnJvbSB0aGUgc2VsZWN0ZWQgc2VydmljZVxyXG4gICAgICAgIHZhciBjYWxjdWxhdGVFbmRUaW1lID0gZnVuY3Rpb24gY2FsY3VsYXRlRW5kVGltZSgpIHtcclxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5pdGVtKCkuc2VydmljZUR1cmF0aW9uTWludXRlcygpO1xyXG4gICAgICAgICAgICB0aGlzLml0ZW0oKS5lbmRUaW1lKFxyXG4gICAgICAgICAgICAgICAgbW9tZW50KHRoaXMuaXRlbSgpLnN0YXJ0VGltZSgpKVxyXG4gICAgICAgICAgICAgICAgLmFkZChkdXJhdGlvbiwgJ21pbnV0ZXMnKS50b0RhdGUoKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgbm93XHJcbiAgICAgICAgY2FsY3VsYXRlRW5kVGltZSgpO1xyXG4gICAgICAgIC8vIEFuZCBldmVyeSB0aW1lIGR1cmF0aW9uIGNoYW5nZXNcclxuICAgICAgICB0aGlzLml0ZW0oKS5zZXJ2aWNlRHVyYXRpb25NaW51dGVzXHJcbiAgICAgICAgLnN1YnNjcmliZShjYWxjdWxhdGVFbmRUaW1lKTtcclxuICAgIH1cclxuICAgIGlmIChyZXF1ZXN0RGF0YS5zZWxlY3RBZGRyZXNzID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtKCkuYWRkcmVzc0lEKHJlcXVlc3REYXRhLnNlbGVjdGVkQWRkcmVzc0lEKTtcclxuICAgIH1cclxuICAgIGlmIChyZXF1ZXN0RGF0YS5zZWxlY3RlZEpvYlRpdGxlSUQpIHtcclxuICAgICAgICB0aGlzLml0ZW0oKS5qb2JUaXRsZUlEKHJlcXVlc3REYXRhLnNlbGVjdGVkSm9iVGl0bGVJRCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdERhdGEuc2VsZWN0UHJpY2luZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuaXRlbSgpLnByaWNpbmcoXHJcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLnNlbGVjdGVkUHJpY2luZy5tYXAoZnVuY3Rpb24ocHJpY2luZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmljaW5nRXN0aW1hdGVEZXRhaWwocHJpY2luZyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXBwb2ludG1lbnRDYXJkVmlld01vZGVsO1xyXG4iLCIvKipcclxuICAgIEFwcG9pbnRtZW50IFZpZXcgbW9kZWwgdGhhdCB3cmFwcyBhbiBBcHBvaW50bWVudFxyXG4gICAgbW9kZWwgaW5zdGFuY2UgZXh0ZW5kZWQgd2l0aCBleHRyYSBtZXRob2RzIGNvbm5lY3RlZFxyXG4gICAgdG8gcmVsYXRlZCBkYXRhXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBBcHBvaW50bWVudFZpZXcoYXBwb2ludG1lbnQsIGFwcCkge1xyXG4gICAgaWYgKGFwcG9pbnRtZW50Ll9pc0FwcG9pbnRtZW50VmlldykgcmV0dXJuIGFwcG9pbnRtZW50O1xyXG4gICAgYXBwb2ludG1lbnQuX2lzQXBwb2ludG1lbnRWaWV3ID0gdHJ1ZTtcclxuXHJcbiAgICBhcHBvaW50bWVudC5jdXN0b21lciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcy5zb3VyY2VCb29raW5nKCk7XHJcbiAgICAgICAgaWYgKCFiKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY2lkID0gdGhpcy5jdXN0b21lclVzZXJJRCgpO1xyXG4gICAgICAgIGlmIChjaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5jdXN0b21lcnMuZ2V0T2JzZXJ2YWJsZUl0ZW0oY2lkLCB0cnVlKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sIGFwcG9pbnRtZW50KTtcclxuICAgIFxyXG4gICAgYXBwb2ludG1lbnQuYWRkcmVzcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcy5zb3VyY2VCb29raW5nKCk7XHJcbiAgICAgICAgaWYgKCFiKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYWlkID0gdGhpcy5hZGRyZXNzSUQoKSxcclxuICAgICAgICAgICAgamlkID0gdGhpcy5qb2JUaXRsZUlEKCk7XHJcbiAgICAgICAgaWYgKGFpZCAmJiBqaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldE9ic2VydmFibGVJdGVtKGppZCwgYWlkLCB0cnVlKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sIGFwcG9pbnRtZW50KTtcclxuXHJcbiAgICBhcHBvaW50bWVudC5hZGRyZXNzU3VtbWFyeSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhZGQgPSB0aGlzLmFkZHJlc3MoKTtcclxuICAgICAgICByZXR1cm4gYWRkICYmIGFkZC5zaW5nbGVMaW5lKCkgfHwgJyc7XHJcbiAgICB9LCBhcHBvaW50bWVudCk7XHJcbiAgICBcclxuICAgIC8qIFByb3BlcnR5IHdpdGggdGhlIHByaWNpbmcgYXJyYXkgcGx1cyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcclxuICAgICAgICBmcmVlbGFuY2VyUHJpY2luZy5cclxuICAgICovXHJcbiAgICBhcHBvaW50bWVudC5wcmljaW5nV2l0aEluZm8gPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYiA9IHRoaXMuc291cmNlQm9va2luZygpO1xyXG4gICAgICAgIGlmICghYikgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICB2YXIgamlkID0gdGhpcy5qb2JUaXRsZUlEKCksXHJcbiAgICAgICAgICAgIGRldGFpbHMgPSB0aGlzLnByaWNpbmcoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRldGFpbHMubWFwKGZ1bmN0aW9uKGRldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJpY2luZ0VzdGltYXRlRGV0YWlsVmlldyhkZXQsIGppZCwgYXBwKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIGFwcG9pbnRtZW50KTtcclxuXHJcbiAgICBhcHBvaW50bWVudC5zZXJ2aWNlc1N1bW1hcnkgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmljaW5nV2l0aEluZm8oKVxyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oc2VydmljZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VydmljZS5mcmVlbGFuY2VyUHJpY2luZygpLm5hbWUoKTtcclxuICAgICAgICB9KS5qb2luKCcsICcpO1xyXG4gICAgfSwgYXBwb2ludG1lbnQpO1xyXG4gICAgXHJcbiAgICAvLyBUT0RPIFJldmlldyBmb3IgYW55IGNoYW5nZSBvZiBjb21wdXRlIHRoZSBmdWxsIHNlcnZpY2UgZHVyYXRpb25cclxuICAgIGFwcG9pbnRtZW50LnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcHJpY2luZyA9IHRoaXMucHJpY2luZ1dpdGhJbmZvKCk7XHJcbiAgICAgICAgcmV0dXJuIHByaWNpbmcucmVkdWNlKGZ1bmN0aW9uKHByZXYsIHNlcnZpY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBzZXJ2aWNlLmZyZWVsYW5jZXJQcmljaW5nKCkuc2VydmljZUR1cmF0aW9uTWludXRlcygpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfSwgYXBwb2ludG1lbnQpO1xyXG4gICAgXHJcbiAgICAvLyBUT0RPIFJldmlldyBpZiBjYWxjdWxhdGlvbiBvZiBmZWVzIGFuZCB0aGF0IGlzIG5lZWRlZFxyXG4gICAgYXBwb2ludG1lbnQucHJpY2luZy5zdWJzY3JpYmUoZnVuY3Rpb24ocHJpY2luZykge1xyXG4gICAgICAgIHRoaXMucHJpY2UocHJpY2luZy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICsgY3VyLnRvdGFsUHJpY2UoKTtcclxuICAgICAgICB9LCAwKSk7XHJcbiAgICB9LmJpbmQoYXBwb2ludG1lbnQpKTtcclxuXHJcbiAgICByZXR1cm4gYXBwb2ludG1lbnQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBQcmljaW5nRXN0aW1hdGVEZXRhaWxWaWV3KHByaWNpbmdFc3RpbWF0ZURldGFpbCwgam9iVGl0bGVJRCwgYXBwKSB7XHJcblxyXG4gICAgcHJpY2luZ0VzdGltYXRlRGV0YWlsLmZyZWVsYW5jZXJQcmljaW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBpZCA9IHRoaXMuZnJlZWxhbmNlclByaWNpbmdJRCgpO1xyXG4gICAgICAgIHJldHVybiBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmdcclxuICAgICAgICAgICAgLmdldE9ic2VydmFibGVJdGVtKGpvYlRpdGxlSUQsIHBpZCwgdHJ1ZSkoKTtcclxuICAgIH0sIHByaWNpbmdFc3RpbWF0ZURldGFpbCk7XHJcblxyXG4gICAgcmV0dXJuIHByaWNpbmdFc3RpbWF0ZURldGFpbDtcclxufVxyXG4iLCIvKipcclxuICAgIFNpbXBsZSBWaWV3IE1vZGVsIHdpdGggbWFpbiBjcmVkZW50aWFscyBmb3JcclxuICAgIHVzZSBpbiBhIGZvcm0sIHdpdGggdmFsaWRhdGlvbi5cclxuICAgIFVzZWQgYnkgTG9naW4gYW5kIFNpZ251cCBhY3Rpdml0aWVzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxuZnVuY3Rpb24gRm9ybUNyZWRlbnRpYWxzKCkge1xyXG5cclxuICAgIHRoaXMudXNlcm5hbWUgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIHRoaXMucGFzc3dvcmQgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIFxyXG4gICAgLy8gdmFsaWRhdGUgdXNlcm5hbWUgYXMgYW4gZW1haWxcclxuICAgIHZhciBlbWFpbFJlZ2V4cCA9IC9eWy0wLTlBLVphLXohIyQlJicqKy89P15fYHt8fX4uXStAWy0wLTlBLVphLXohIyQlJicqKy89P15fYHt8fX4uXSskLztcclxuICAgIHRoaXMudXNlcm5hbWUuZXJyb3IgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIHRoaXMudXNlcm5hbWUuc3Vic2NyaWJlKGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICBpZiAoZW1haWxSZWdleHAudGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51c2VybmFtZS5lcnJvcignJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJuYW1lLmVycm9yKCdJcyBub3QgYSB2YWxpZCBlbWFpbCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVzZXJuYW1lLmVycm9yKCdSZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICBcclxuICAgIC8vIHJlcXVpcmVkIHBhc3N3b3JkXHJcbiAgICB0aGlzLnBhc3N3b3JkLmVycm9yID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICB0aGlzLnBhc3N3b3JkLnN1YnNjcmliZShmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgdmFyIGVyciA9ICcnO1xyXG4gICAgICAgIGlmICghdilcclxuICAgICAgICAgICAgZXJyID0gJ1JlcXVpcmVkJztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnBhc3N3b3JkLmVycm9yKGVycik7XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1DcmVkZW50aWFscztcclxuIiwiLyoqIE5hdkFjdGlvbiB2aWV3IG1vZGVsLlxyXG4gICAgSXQgYWxsb3dzIHNldC11cCBwZXIgYWN0aXZpdHkgZm9yIHRoZSBBcHBOYXYgYWN0aW9uIGJ1dHRvbi5cclxuKiovXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gTmF2QWN0aW9uKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBsaW5rOiAnJyxcclxuICAgICAgICBpY29uOiAnJyxcclxuICAgICAgICB0ZXh0OiAnJyxcclxuICAgICAgICAvLyAnVGVzdCcgaXMgdGhlIGhlYWRlciB0aXRsZSBidXQgcGxhY2VkIGluIHRoZSBidXR0b24vYWN0aW9uXHJcbiAgICAgICAgaXNUaXRsZTogZmFsc2UsXHJcbiAgICAgICAgLy8gJ0xpbmsnIGlzIHRoZSBlbGVtZW50IElEIG9mIGEgbW9kYWwgKHN0YXJ0cyB3aXRoIGEgIylcclxuICAgICAgICBpc01vZGFsOiBmYWxzZSxcclxuICAgICAgICAvLyAnTGluaycgaXMgYSBTaGVsbCBjb21tYW5kLCBsaWtlICdnb0JhY2sgMidcclxuICAgICAgICBpc1NoZWxsOiBmYWxzZSxcclxuICAgICAgICAvLyBTZXQgaWYgdGhlIGVsZW1lbnQgaXMgYSBtZW51IGJ1dHRvbiwgaW4gdGhhdCBjYXNlICdsaW5rJ1xyXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIElEIG9mIHRoZSBtZW51IChjb250YWluZWQgaW4gdGhlIHBhZ2U7IHdpdGhvdXQgdGhlIGhhc2gpLCB1c2luZ1xyXG4gICAgICAgIC8vIHRoZSB0ZXh0IGFuZCBpY29uIGJ1dCBzcGVjaWFsIG1lYW5pbmcgZm9yIHRoZSB0ZXh0IHZhbHVlICdtZW51J1xyXG4gICAgICAgIC8vIG9uIGljb24gcHJvcGVydHkgdGhhdCB3aWxsIHVzZSB0aGUgc3RhbmRhcmQgbWVudSBpY29uLlxyXG4gICAgICAgIGlzTWVudTogZmFsc2VcclxuICAgIH0sIHZhbHVlcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmF2QWN0aW9uO1xyXG5cclxuLy8gU2V0IG9mIHZpZXcgdXRpbGl0aWVzIHRvIGdldCB0aGUgbGluayBmb3IgdGhlIGV4cGVjdGVkIGh0bWwgYXR0cmlidXRlc1xyXG5cclxuTmF2QWN0aW9uLnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gZ2V0SHJlZigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKHRoaXMuaXNNZW51KCkgfHwgdGhpcy5pc01vZGFsKCkgfHwgdGhpcy5pc1NoZWxsKCkpID9cclxuICAgICAgICAnIycgOlxyXG4gICAgICAgIHRoaXMubGluaygpXHJcbiAgICApO1xyXG59O1xyXG5cclxuTmF2QWN0aW9uLnByb3RvdHlwZS5nZXRNb2RhbFRhcmdldCA9IGZ1bmN0aW9uIGdldE1vZGFsVGFyZ2V0KCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICAodGhpcy5pc01lbnUoKSB8fCAhdGhpcy5pc01vZGFsKCkgfHwgdGhpcy5pc1NoZWxsKCkpID9cclxuICAgICAgICAnJyA6XHJcbiAgICAgICAgdGhpcy5saW5rKClcclxuICAgICk7XHJcbn07XHJcblxyXG5OYXZBY3Rpb24ucHJvdG90eXBlLmdldFNoZWxsQ29tbWFuZCA9IGZ1bmN0aW9uIGdldFNoZWxsQ29tbWFuZCgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKHRoaXMuaXNNZW51KCkgfHwgIXRoaXMuaXNTaGVsbCgpKSA/XHJcbiAgICAgICAgJycgOlxyXG4gICAgICAgIHRoaXMubGluaygpXHJcbiAgICApO1xyXG59O1xyXG5cclxuTmF2QWN0aW9uLnByb3RvdHlwZS5nZXRNZW51SUQgPSBmdW5jdGlvbiBnZXRNZW51SUQoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgICghdGhpcy5pc01lbnUoKSkgP1xyXG4gICAgICAgICcnIDpcclxuICAgICAgICB0aGlzLmxpbmsoKVxyXG4gICAgKTtcclxufTtcclxuXHJcbk5hdkFjdGlvbi5wcm90b3R5cGUuZ2V0TWVudUxpbmsgPSBmdW5jdGlvbiBnZXRNZW51TGluaygpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKCF0aGlzLmlzTWVudSgpKSA/XHJcbiAgICAgICAgJycgOlxyXG4gICAgICAgICcjJyArIHRoaXMubGluaygpXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqIFN0YXRpYywgc2hhcmVkIGFjdGlvbnMgKiovXHJcbk5hdkFjdGlvbi5nb0hvbWUgPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICcvJyxcclxuICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWhvbWUnXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLmdvQmFjayA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJ2dvQmFjaycsXHJcbiAgICBpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1hcnJvdy1sZWZ0JyxcclxuICAgIGlzU2hlbGw6IHRydWVcclxufSk7XHJcblxyXG4vLyBUT0RPIFRPIFJFTU9WRSwgRXhhbXBsZSBvZiBtb2RhbFxyXG5OYXZBY3Rpb24ubmV3SXRlbSA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJyNuZXdJdGVtJyxcclxuICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXBsdXMnLFxyXG4gICAgaXNNb2RhbDogdHJ1ZVxyXG59KTtcclxuXHJcbk5hdkFjdGlvbi5tZW51SW4gPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICdtZW51SW4nLFxyXG4gICAgaWNvbjogJ21lbnUnLFxyXG4gICAgaXNNZW51OiB0cnVlXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLm1lbnVPdXQgPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICdtZW51T3V0JyxcclxuICAgIGljb246ICdtZW51JyxcclxuICAgIGlzTWVudTogdHJ1ZVxyXG59KTtcclxuXHJcbk5hdkFjdGlvbi5tZW51TmV3SXRlbSA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJ21lbnVOZXdJdGVtJyxcclxuICAgIGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXBsdXMnLFxyXG4gICAgaXNNZW51OiB0cnVlXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLmdvSGVscEluZGV4ID0gbmV3IE5hdkFjdGlvbih7XHJcbiAgICBsaW5rOiAnI2hlbHBJbmRleCcsXHJcbiAgICB0ZXh0OiAnaGVscCcsXHJcbiAgICBpc01vZGFsOiB0cnVlXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLmdvTG9naW4gPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICcvbG9naW4nLFxyXG4gICAgdGV4dDogJ2xvZy1pbidcclxufSk7XHJcblxyXG5OYXZBY3Rpb24uZ29Mb2dvdXQgPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICcvbG9nb3V0JyxcclxuICAgIHRleHQ6ICdsb2ctb3V0J1xyXG59KTtcclxuXHJcbk5hdkFjdGlvbi5nb1NpZ251cCA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJy9zaWdudXAnLFxyXG4gICAgdGV4dDogJ3NpZ24tdXAnXHJcbn0pO1xyXG4iLCIvKiogTmF2QmFyIHZpZXcgbW9kZWwuXHJcbiAgICBJdCBhbGxvd3MgY3VzdG9taXplIHRoZSBOYXZCYXIgcGVyIGFjdGl2aXR5LlxyXG4qKi9cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL01vZGVsJyk7XHJcbiAgICAvL05hdkFjdGlvbiA9IHJlcXVpcmUoJy4vTmF2QWN0aW9uJyk7XHJcblxyXG5mdW5jdGlvbiBOYXZCYXIodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIC8vIFRpdGxlIHNob3dlZCBpbiB0aGUgY2VudGVyXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgdGl0bGUgaXMgJ251bGwnLCB0aGUgYXBwIGxvZ28gaXMgc2hvd2VkIGluIHBsYWNlLFxyXG4gICAgICAgIC8vIG9uIGVtcHR5IHRleHQsIHRoZSBlbXB0eSB0ZXh0IGlzIHNob3dlZCBhbmQgbm8gbG9nby5cclxuICAgICAgICB0aXRsZTogJycsXHJcbiAgICAgICAgLy8gTmF2QWN0aW9uIGluc3RhbmNlOlxyXG4gICAgICAgIGxlZnRBY3Rpb246IG51bGwsXHJcbiAgICAgICAgLy8gTmF2QWN0aW9uIGluc3RhbmNlOlxyXG4gICAgICAgIHJpZ2h0QWN0aW9uOiBudWxsXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5hdkJhcjtcclxuIiwiLyoqXHJcbiAgICBUaW1lU2xvdCB2aWV3IG1vZGVsIChha2E6IENhbGVuZGFyU2xvdCkgZm9yIHVzZVxyXG4gICAgYXMgcGFydCBvZiB0aGUgdGVtcGxhdGUvY29tcG9uZW50IHRpbWUtc2xvdC10aWxlIG9yIGFjdGl2aXRpZXNcclxuICAgIHByb3ZpZGluZyBkYXRhIGZvciB0aGUgdGVtcGxhdGUuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZ2V0T2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldE9ic2VydmFibGUnKTtcclxuXHJcbmZ1bmN0aW9uIFRpbWVTbG90Vmlld01vZGVsKHBhcmFtcykge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo5Ki9cclxuXHJcbiAgICB0aGlzLnN0YXJ0VGltZSA9IGdldE9ic2VydmFibGUocGFyYW1zLnN0YXJ0VGltZSB8fCBudWxsKTtcclxuICAgIHRoaXMuZW5kVGltZSA9IGdldE9ic2VydmFibGUocGFyYW1zLmVuZFRpbWUgfHwgbnVsbCk7XHJcbiAgICB0aGlzLnN1YmplY3QgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5zdWJqZWN0IHx8IG51bGwpO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGdldE9ic2VydmFibGUocGFyYW1zLmRlc2NyaXB0aW9uIHx8IG51bGwpO1xyXG4gICAgdGhpcy5saW5rID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMubGluayB8fCBudWxsKTtcclxuICAgIHRoaXMuYWN0aW9uSWNvbiA9IGdldE9ic2VydmFibGUocGFyYW1zLmFjdGlvbkljb24gfHwgbnVsbCk7XHJcbiAgICB0aGlzLmFjdGlvblRleHQgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5hY3Rpb25UZXh0IHx8IG51bGwpO1xyXG4gICAgdGhpcy5jbGFzc05hbWVzID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuY2xhc3NOYW1lcyB8fCBudWxsKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaW1lU2xvdFZpZXdNb2RlbDtcclxuXHJcbnZhciBudW1lcmFsID0gcmVxdWlyZSgnbnVtZXJhbCcpO1xyXG5cclxuLyoqXHJcbiAgICBTdGF0aWMgY29uc3RydWN0b3IgdG8gY29udmVydCBhbiBBcHBvaW50bWVudCBtb2RlbCBpbnRvIFxyXG4gICAgYSBUaW1lU2xvdCBpbnN0YW5jZSBmb2xsb3dpbmcgVUkgY3JpdGVyaWEgZm9yIHByZXNldCB2YWx1ZXMvc2V0dXAuXHJcbioqL1xyXG5UaW1lU2xvdFZpZXdNb2RlbC5mcm9tQXBwb2ludG1lbnQgPSBmdW5jdGlvbiBmcm9tQXBwb2ludG1lbnQoYXB0KSB7XHJcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjggKi9cclxuICAgIHJldHVybiBuZXcgVGltZVNsb3RWaWV3TW9kZWwoe1xyXG4gICAgICAgIHN0YXJ0VGltZTogYXB0LnN0YXJ0VGltZSxcclxuICAgICAgICBlbmRUaW1lOiBhcHQuZW5kVGltZSxcclxuICAgICAgICBzdWJqZWN0OiBhcHQuc3VtbWFyeSxcclxuICAgICAgICBkZXNjcmlwdGlvbjogYXB0LmRlc2NyaXB0aW9uLFxyXG4gICAgICAgIGxpbms6ICcjIWFwcG9pbnRtZW50LycgKyBhcHQuc3RhcnRUaW1lKCkudG9JU09TdHJpbmcoKSArICcvJyArIGFwdC5pZCgpLFxyXG4gICAgICAgIGFjdGlvbkljb246IChhcHQuc291cmNlQm9va2luZygpID8gbnVsbCA6IGFwdC5zb3VyY2VFdmVudCgpID8gJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodCcgOiAhYXB0LmlkKCkgPyAnZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzJyA6IG51bGwpLFxyXG4gICAgICAgIGFjdGlvblRleHQ6IChcclxuICAgICAgICAgICAgYXB0LnNvdXJjZUJvb2tpbmcoKSAmJiBcclxuICAgICAgICAgICAgYXB0LnNvdXJjZUJvb2tpbmcoKS5ib29raW5nUmVxdWVzdCgpICYmIFxyXG4gICAgICAgICAgICBhcHQuc291cmNlQm9va2luZygpLmJvb2tpbmdSZXF1ZXN0KCkucHJpY2luZ0VzdGltYXRlKCkgPyBcclxuICAgICAgICAgICAgbnVtZXJhbChhcHQuc291cmNlQm9va2luZygpLmJvb2tpbmdSZXF1ZXN0KCkucHJpY2luZ0VzdGltYXRlKCkudG90YWxQcmljZSgpIHx8IDApLmZvcm1hdCgnJDAuMDAnKSA6XHJcbiAgICAgICAgICAgIG51bGxcclxuICAgICAgICApLFxyXG4gICAgICAgIGNsYXNzTmFtZXM6IChhcHQuaWQoKSA/IG51bGwgOiAnTGlzdFZpZXctaXRlbS0tdGFnLXN1Y2Nlc3MnKVxyXG4gICAgfSk7XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgVXNlckpvYlByb2ZpbGVWaWV3TW9kZWw6IGxvYWRzIGRhdGEgYW5kIGtlZXAgc3RhdGVcclxuICAgIHRvIGRpc3BsYXkgdGhlIGxpc3Rpbmcgb2Ygam9iIHRpdGxlcyBmcm9tIHRoZSBcclxuICAgIHVzZXIgam9iIHByb2ZpbGUuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxuZnVuY3Rpb24gVXNlckpvYlByb2ZpbGVWaWV3TW9kZWwoYXBwKSB7XHJcbiAgICBcclxuICAgIC8vIExvYWQgYW5kIHNhdmUgam9iIHRpdGxlIGluZm9cclxuICAgIHZhciBqb2JUaXRsZXNJbmRleCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gc3luY0pvYlRpdGxlKGpvYlRpdGxlSUQpIHtcclxuICAgICAgICByZXR1cm4gYXBwLm1vZGVsLmpvYlRpdGxlcy5nZXRKb2JUaXRsZShqb2JUaXRsZUlEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgICAgIGpvYlRpdGxlc0luZGV4W2pvYlRpdGxlSURdID0gam9iVGl0bGU7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBlcnJvcnM/IG5vdC1mb3VuZCBqb2IgdGl0bGU/XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGVzIGEgJ2pvYlRpdGxlJyBvYnNlcnZhYmxlIG9uIHRoZSB1c2VySm9iVGl0bGVcclxuICAgIC8vIG1vZGVsIHRvIGhhdmUgYWNjZXNzIHRvIGEgY2FjaGVkIGpvYlRpdGxlIG1vZGVsLlxyXG4gICAgZnVuY3Rpb24gYXR0YWNoSm9iVGl0bGUodXNlckpvYlRpdGxlKSB7XHJcbiAgICAgICAgdXNlckpvYlRpdGxlLmpvYlRpdGxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuIGpvYlRpdGxlc0luZGV4W3RoaXMuam9iVGl0bGVJRCgpXTtcclxuICAgICAgICB9LCB1c2VySm9iVGl0bGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnVzZXJKb2JQcm9maWxlID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuICAgIC8vIFVwZGF0ZWQgdXNpbmcgdGhlIGxpdmUgbGlzdCwgZm9yIGJhY2tncm91bmQgdXBkYXRlc1xyXG4gICAgYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLmxpc3Quc3Vic2NyaWJlKGZ1bmN0aW9uKGxpc3QpIHtcclxuICAgICAgICAvLyBXZSBuZWVkIHRoZSBqb2IgdGl0bGVzIGluZm8gYmVmb3JlIGVuZFxyXG4gICAgICAgIFByb21pc2UuYWxsKGxpc3QubWFwKGZ1bmN0aW9uKHVzZXJKb2JUaXRsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3luY0pvYlRpdGxlKHVzZXJKb2JUaXRsZS5qb2JUaXRsZUlEKCkpO1xyXG4gICAgICAgIH0pKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgam9iVGl0bGUgcHJvcGVydHkgYmVmb3JlIHVwZGF0ZVxyXG4gICAgICAgICAgICAvLyBvYnNlcnZhYmxlIHdpdGggdGhlIHByb2ZpbGVcclxuICAgICAgICAgICAgbGlzdC5mb3JFYWNoKGF0dGFjaEpvYlRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXNlckpvYlByb2ZpbGUobGlzdCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy50aGVyZUlzRXJyb3IoZmFsc2UpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goc2hvd0xvYWRpbmdFcnJvcik7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLmlzRmlyc3RUaW1lID0ga28ub2JzZXJ2YWJsZSh0cnVlKTtcclxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICB0aGlzLmlzU3luY2luZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy50aGVyZUlzRXJyb3IgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuYmFzZVVybCA9IGtvLm9ic2VydmFibGUoJy9qb2J0aXRsZXMnKTtcclxuICAgIFxyXG4gICAgdGhpcy5zZWxlY3RKb2JUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIEhvb2sgdG8gYWxsb3cgZm9yIGN1c3RvbSBoYW5kbGVyIHJhdGhlciB0aGFuIGZvbGxvd1xyXG4gICAgICAgIC8vIHRoZSBVUkwuIE9uIHRoYXQgY2FzZXMsIHJlbWVtYmVyIHRvIHJldHVybiBmYWxzZVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHNob3dMb2FkaW5nRXJyb3IgPSBmdW5jdGlvbiBzaG93TG9hZGluZ0Vycm9yKGVycikge1xyXG4gICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgdGl0bGU6ICdBbiBlcnJvciBoYXBwZW5pbmcgd2hlbiBsb2FkaW5nIHlvdXIgam9iIHByb2ZpbGUuJyxcclxuICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICB0aGlzLnRoZXJlSXNFcnJvcih0cnVlKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvLyBMb2FkaW5nIGFuZCBzeW5jIG9mIGRhdGFcclxuICAgIHRoaXMuc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XHJcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRoaXMuaXNGaXJzdFRpbWUoKTtcclxuICAgICAgICB0aGlzLmlzRmlyc3RUaW1lKGZhbHNlKTtcclxuXHJcbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nKHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XHJcbiAgICAgICAgYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLnN5bmNMaXN0KClcclxuICAgICAgICAuY2F0Y2goc2hvd0xvYWRpbmdFcnJvcik7XHJcblxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJKb2JQcm9maWxlVmlld01vZGVsO1xyXG4iXX0=
;