;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
    Account activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function AccountActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Account');
});

exports.init = A.init;

},{"../components/Activity":64}],2:[function(require,module,exports){
/**
    AddJobTitles activity
**/
'use strict';

var Activity = require('../components/Activity');
var $ = require('jquery');
require('jquery-ui');

var A = Activity.extends(function AddJobTitlesActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Scheduling');
    
    // Setup autocomplete
    var ac = this.$activity.find('#addJobTitles-search');
    var vw = this.viewModel;
    // Autocomplete positions and add to the list
    ac.autocomplete({
        source: function(request, response) {
            vw.searchBy(request.term)
            .then(function(results) {
                response(results);
            });
        },
        autoFocus: false,
        minLength: 0,
        select: function (event, ui) {
            // No value, no action :(
            if (!ui || !ui.item || !ui.item.value) return;

            vw.addItem(ui.item);

            return false;
        },
        focus: function (event, ui) {
            if (!ui || !ui.item || !ui.item.positionSingular);
            // We want the label in textbox, not the value
            $(this).val(ui.item.positionSingular);
            return false;
        }
    });
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var referrer = this.app.shell.referrerRoute;
    referrer = referrer && referrer.url || '/scheduling';
    var link = this.requestData.cancelLink || referrer;
    
    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {
        this.convertToCancelAction(this.navBar.leftAction(), link);
    }
};

A.prototype.show = function show(options) {

    Activity.prototype.show.call(this, options);
    
    // Reset
    this.viewModel.searchText('');
    this.viewModel.jobTitles.removeAll();
    
    this.updateNavBarState();
};

var ko = require('knockout');
function ViewModel(app) {
    
    this.isSearching = ko.observable(false);
    this.isSaving = ko.observable(false);
    this.isLocked = this.isSaving;
    this.searchText = ko.observable('');
    this.jobTitles = ko.observableArray([]);
    
    this.submitText = ko.pureComputed(function() {
        return (
            app.model.onboarding.inProgress() ?
                'Save and continue' :
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, this);
    
    this.unsavedChanges = ko.pureComputed(function() {
        return !!this.jobTitles().length;
    }, this);

    this.searchBy = function searchBy(text) {
        return app.model.rest.get('job-titles/autocomplete', { search: text })
        .catch(function (err) {
            app.modals.showError({ error: err });
        });
    }.bind(this);
    
    this.search = function search() {
        this.searchBy(this.searchText());
    }.bind(this);
    
    this.addItem = function addItem(item) {
        // Add to the list, if is not already in it
        var foundIndex = this.findItem(item);
        if (foundIndex === -1) {
            this.jobTitles.push(item);
        }
    }.bind(this);
    
    this.add = function add() {
        var s = this.searchText();
        if (s) {
            this.addItem({
                value: 0,
                label: s
            });
            this.searchText('');
        }
    }.bind(this);
    
    /**
        Look for an item in the current list, returning
        its index in the list or -1 if nothing.
    **/
    this.findItem = function findItem(jobTitle) {
        var foundIndex = -1;
        this.jobTitles().some(function(item, index) {
            if (jobTitle.value !== 0 &&
                item.value === jobTitle.value ||
                item.label === jobTitle.label) {
                foundIndex = index;
                return true;
            }
        });
        return foundIndex;
    };
    
    this.remove = function remove(jobTitle) {
        var removeIndex = this.findItem(jobTitle);
        if (removeIndex > -1) {
            this.jobTitles.splice(removeIndex, 1);
        }
    }.bind(this);
    
    this.save = function save() {
        this.isSaving(true);

        Promise.all(this.jobTitles().map(function(jobTitle) {
            return app.model.userJobProfile.createUserJobTitle({
                jobTitleID: jobTitle.value,
                jobTitleName: jobTitle.label
            });
        }))
        .then(function(/*results*/) {
            this.searchText('');
            this.isSaving(false);
            // Reset list
            this.jobTitles.removeAll();
            
            if (app.model.onboarding.inProgress()) {
                app.model.onboarding.goNext();
            }
            else {
                app.successSave();
            }
            
        }.bind(this))
        .catch(function(error) {
            this.searchText('');
            this.isSaving(false);
            app.modals.showError({
                title: 'Impossible to add one or more job titles',
                error: error
            });
        }.bind(this));
    }.bind(this);
}

},{"../components/Activity":64,"knockout":false}],3:[function(require,module,exports){
/**
    AddressEditor activity
    
    TODO: ModelVersion is NOT being used, so no getting updates if server updates
    the data after load (data load is requested but get first from cache). Use
    version and get sync'ed data when ready, and additionally notification to
    override changes if server data is different that any local change.

    TODO: The URL structure and how params are read is ready to allow
    edition of different kind of addresses, but actually only service addresses
    are fully supported, since 'home address' is edited in contactInfo and
    'billing addresses' are not used currently, but when needed, the support for this
    last will need to be completed. All the API calls right now are
    for model.serviceAdddresses for example.
**/
'use strict';
var ko = require('knockout'),
    Address = require('../models/Address'),
    Activity = require('../components/Activity');

var A = Activity.extends(function AddressEditorActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Locations');
    
    // Remote postal code look-up
    // NOTE: copied the code inside the postalCode computed handler in contactInfo.js with slight changes
    var app = this.app,
        viewModel = this.viewModel;
    this.registerHandler({
        target: this.viewModel.address,
        handler: function(address) {
            if (address &&
               !address.postalCode._hasLookup) {
                address.postalCode._hasLookup = true;
                
                // On change to a valid code, do remote look-up
                ko.computed(function() {
                    var postalCode = this.postalCode();
                    
                    if (postalCode && !/^\s*$/.test(postalCode)) {
                        app.model.postalCodes.getItem(postalCode)
                        .then(function(info) {
                            if (info) {
                                address.city(info.city);
                                address.stateProvinceCode(info.stateProvinceCode);
                                address.stateProvinceName(info.stateProvinceName);
                                viewModel.errorMessages.postalCode('');
                            }
                        })
                        .catch(function(err) {
                            address.city('');
                            address.stateProvinceCode('');
                            address.stateProvinceName('');
                            // Expected errors, a single message, set
                            // on the observable
                            var msg = typeof(err) === 'string' ? err : null;
                            if (msg || err && err.responseJSON && err.responseJSON.errorMessage) {
                                viewModel.errorMessages.postalCode(msg || err.responseJSON.errorMessage);
                            }
                            else {
                                // Log to console for debugging purposes, on regular use an error on the
                                // postal code is not critical and can be transparent; if there are 
                                // connectivity or authentification errors will throw on saving the address
                                console.error('Server error validating Zip Code', err);
                            }
                        });
                    }
                }, address)
                // Avoid excessive requests by setting a timeout since the latest change
                .extend({ rateLimit: { timeout: 200, method: 'notifyWhenChangesStop' } });
            }
        }
    });
    
    // Special treatment of the save operation
    this.viewModel.onSave = function(addressID) {
        if (this.requestData.returnNewAsSelected === true) {
            // Go to previous activity that required
            // to select an address
            this.requestData.addressID = addressID;
            this.app.shell.goBack(this.requestData);
        }
        else {
            // Regular save
            this.app.successSave();
        }
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var link = this.requestData.cancelLink || '/serviceAddresses/' + this.viewModel.jobTitleID();
    
    this.convertToCancelAction(this.navBar.leftAction(), link);
};

A.prototype.show = function show(options) {
    //jshint maxcomplexity:10    
    Activity.prototype.show.call(this, options);
    
    // Reset
    this.viewModel.wasRemoved(false);
    
    // Params    
    var params = options && options.route && options.route.segments || [];

    var kind = params[0] || '',
        isService = kind === Address.kind.service,
        jobTitleID = isService ? params[1] |0 : 0,
        addressID = isService ? params[2] |0 : params[1] |0,
        // Only used on service address creation, instead an ID we get
        // a string for 'serviceArea' or 'serviceLocation')
        serviceType = params[2] || '';
    
    this.viewModel.jobTitleID(jobTitleID);
    this.viewModel.addressID(addressID);
    
    this.updateNavBarState();

    if (addressID) {
        // Get the address
        this.app.model.serviceAddresses.getItemVersion(jobTitleID, addressID)
        .then(function (addressVersion) {
            if (addressVersion) {
                this.viewModel.addressVersion(addressVersion);
                this.viewModel.header('Edit Location');
            } else {
                this.viewModel.addressVersion(null);
                this.viewModel.header('Unknow location or was deleted');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            });
        }.bind(this));
    }
    else {
        // New address
        this.viewModel.addressVersion(this.app.model.serviceAddresses.newItemVersion({
            jobTitleID: jobTitleID
        }));

        switch (serviceType) {
            case 'serviceArea':
                this.viewModel.address().isServiceArea(true);
                this.viewModel.address().isServiceLocation(false);
                this.viewModel.header('Add a service area');
                break;
            case 'serviceLocation':
                this.viewModel.address().isServiceArea(false);
                this.viewModel.address().isServiceLocation(true);
                this.viewModel.header('Add a service location');
                break;
            default:
                this.viewModel.address().isServiceArea(true);
                this.viewModel.address().isServiceLocation(true);
                this.viewModel.header('Add a location');
                break;
        }
    }
};

function ViewModel(app) {

    this.header = ko.observable('Edit Location');
    
    // List of possible error messages registered
    // by name
    this.errorMessages = {
        postalCode: ko.observable('')
    };
    
    this.jobTitleID = ko.observable(0);
    this.addressID = ko.observable(0);
    
    this.addressVersion = ko.observable(null);
    this.address = ko.pureComputed(function() {
        var v = this.addressVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    this.isLoading = app.model.serviceAddresses.state.isLoading;
    this.isSaving = app.model.serviceAddresses.state.isSaving;
    this.isDeleting = app.model.serviceAddresses.state.isDeleting;

    this.wasRemoved = ko.observable(false);
    
    this.isLocked = ko.computed(function() {
        return this.isDeleting() || app.model.serviceAddresses.state.isLocked();
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        var add = this.address();
        return !add || !add.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.addressVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        'Save changes' :
                        'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.addressVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {

        app.model.serviceAddresses.setItem(this.address().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.address().model.updateWith(serverData);
            // Push version so it appears as saved
            this.addressVersion().push({ evenIfObsolete: true });
            
            // Special save, function provided by the activity on set-up
            this.onSave(serverData.addressID);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        app.modals.confirm({
            title: 'Delete location',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.serviceAddresses.delItem(this.jobTitleID(), this.addressID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    /**
        Typed value binding rather than html binding allow to avoid
        problems because the data in html are string values while
        the actual data from the model is a number.
        Cause problems on some edge cases matching values and with
        detection of changes in the data (because the binding coming from the
        control assigning a string to the value).
    **/
    this.serviceRadiusOptions = ko.observableArray([
        { value: 0.5, label: '0.5 miles' },
        { value: 1.0, label: '1 mile' },
        { value: 2.0, label: '2 miles' },
        { value: 3.0, label: '3 miles' },
        { value: 4.0, label: '4 miles' },
        { value: 5.0, label: '5 miles' },
        { value: 10, label: '10 miles' },
        { value: 25, label: '25 miles' },
        { value: 50, label: '50 miles' },
    ]);
}

},{"../components/Activity":64,"../models/Address":69,"knockout":false}],4:[function(require,module,exports){
/** Calendar activity **/
'use strict';

var $ = require('jquery'),
    moment = require('moment'),
    Appointment = require('../models/Appointment'),
    ko = require('knockout'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

require('../components/DatePicker');

var Activity = require('../components/Activity');

var A = Activity.extends(function AppointmentActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;    
    this.menuItem = 'calendar';
    
    this.$appointmentView = this.$activity.find('#calendarAppointmentView');
    this.$chooseNew = $('#calendarChooseNew');
    
    this.viewModel = new ViewModel(this.app);
    
    // Create default leftAction/backAction settings
    // later used to instantiate a new NavAction that will
    // dynamically change depending on viewModel data.
    var backActionSettings = {
        link: 'calendar/', // Preserve last slash, for later use
        icon: Activity.NavAction.goBack.icon(),
        isTitle: true,
        text: 'Calendar'
    };
    this.navBar = new Activity.NavBar({
        title: '',
        leftAction: new Activity.NavAction(backActionSettings),
        rightAction: Activity.NavAction.goHelpIndex
    });

    // NavBar must update depending on editMode state (to allow cancel and goBack)
    // and appointment date (on read-only, to go back to calendar on current date)
    ko.computed(function() {
        var editMode = this.viewModel.editMode(),
            date = this.viewModel.currentDate();

        if (editMode) {
            // Is cancel action

            var cancelLink = this.viewModel.appointmentCardView();
            cancelLink = cancelLink && cancelLink.progress && cancelLink.progress.cancelLink;

            this.convertToCancelAction(this.navBar.leftAction(), cancelLink || this.requestData.cancelLink);
        }
        else {
            // Is go to calendar/date action
            var defLink = backActionSettings.link,
                defBackText = backActionSettings.text;
            
            var link = date ? defLink + date.toISOString() : defLink;
            var text = date ? moment(date).format('dddd [(]M/D[)]') : defBackText;
            
            this.navBar.leftAction().model.updateWith($.extend({}, backActionSettings, {
                link: link,
                text: text,
                handler: null
            }));
        }

    }, this);

    
    // On changing the current appointment:
    // - Update URL to match the appointment currently showed
    // - Attach handlers to ID and StartTime so we load data for the new
    //   date when it changes (ID changes on create a booking, StartTime on
    //   edition).
    this.registerHandler({
        target: this.viewModel.currentAppointment,
        handler: function (apt) {
            if (!apt)
                return;

            if ((apt.id() === Appointment.specialIds.newBooking ||
                apt.id() === Appointment.specialIds.newEvent) &&
                !apt.__idDateHandlersAttached) {
                apt.__idDateHandlersAttached = true;
                var prevID = apt.id();
                // With explicit subscribe and not a computed because we
                // must avoid the first time execution (creates an infinite loop)
                apt.id.subscribe(function relocateList() {
                    var id = apt.id();
    
                    if (prevID > 0 || id <= 0) return;
                    prevID = id;
                    this.viewModel.setCurrent(null, id)
                    .then(function() {
                        this.viewModel.updateUrl();
                    }.bind(this));
                }.bind(this));
            }
            
        }.bind(this)._delayed(10)
        // IMPORTANT: delayed REQUIRED to avoid triple loading (activity.show) on first load triggered by a click event.
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    /* jshint maxcomplexity:10 */
    Activity.prototype.show.call(this, options);
    
    // Prepare cancelLink, before any attempt of internal URL rewriting
    if (!this.requestData.cancelLink) {
        var referrer = this.app.shell.referrerRoute;
        referrer = referrer && referrer.url;
        // Set a default and avoid links to this same page, preventing infinite loops
        if (referrer && /\/?appointment\//i.test(referrer))
            referrer = '/calendar';
        
        this.requestData.cancelLink = referrer;
    }
    
    var s1 = options && options.route && options.route.segments[0],
        s2 = options && options.route && options.route.segments[1],
        s3 = options && options.route && options.route.segments[2],
        date,
        datetime,
        id,
        type;

    var isNumber = /^\-?\d+$/;
    if (isNumber.test(s1)) {
        // first parameter is an ID
        id = s1 |0;
        type = s2;
    }
    else {
        date = getDateWithoutTime(s1);
        datetime = s1 && new Date(s1) || date;
        id = s2 |0;
        type = s3;
    }
    
    var setupCard = function() {
        // The card component needs to be updated on load
        // with any option passed to the activity since the component
        // is able to to interact with other activities it has requested
        // (to request information edition)
        var cardApi = this.viewModel.appointmentCardView();
        if (cardApi) {
            // Preset the startTime to the one given by the requestData URL parameters
            // when not in an existent appointment, just because:
            // - On a new booking we can preset the date in the 'select date-time' step
            // - On a new event we can preset the date and time in the card
            // - On the other special cards, its allows to pass the datetime to the links
            //   for creation of a new booking/event.
            if (this.viewModel.appointmentCardView().currentID() <= 0) {
                this.viewModel.appointmentCardView().item().startTime(datetime);
            }

            cardApi.passIn(this.requestData);
        }
        else {
            // The first time may happen that the binding is not ready, no cardApi available
            // but we need it, attempt again in short so card is ready:
            setTimeout(setupCard, 80);
        }
    }.bind(this);

    this.viewModel.setCurrent(date, id, type)
    .then(setupCard);
};

var Appointment = require('../models/Appointment');

function findAppointmentInList(list, id) {
    var found = null,
        index = -1;
    list.some(function(apt, i) {
        if (apt.id() === id) {
            found = apt;
            index = i;
            return true;
        }
    });
    return {
        item: found,
        index: index
    };
}

var CalendarEvent = require('../models/CalendarEvent'),
    Booking = require('../models/Booking');

function ViewModel(app) {
    this.app = app;
    this.currentDate = ko.observable(new Date());
    this.currentID = ko.observable(0);
    this.currentIndex = ko.observable(0);
    this.editMode = ko.observable(false);
    this.isLoading = ko.observable(false);
    
    this.dateAvailability = ko.observable();
    this.appointments = ko.pureComputed(function() {
        var dateAvail = this.dateAvailability();
        return dateAvail && dateAvail.appointmentsList() || [];            
    }, this);
    
    // To access the component API we use next observable,
    // updated by the component with its view
    this.appointmentCardView = ko.observable(null);

    var loadingAppointment = new Appointment({
        id: Appointment.specialIds.loading,
        summary: 'Loading...'
    });
    var newEmptyDateAppointment = function newEmptyDateAppointment() {
        return new Appointment({
            id: Appointment.specialIds.emptyDate,
            summary: 'You have nothing scheduled',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newUnavailableAppointment = function newUnavailableAppointment() {
        return new Appointment({
            id: Appointment.specialIds.unavailable,
            summary: 'You`re unavailable all day',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newFreeAppointment = function newFreeAppointment() {
        return new Appointment({
            id: Appointment.specialIds.free,
            summary: 'Free',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newEventAppointment = function newEventAppointment() {
        return new Appointment({
            id: Appointment.specialIds.newEvent,
            summary: 'New event...',
            sourceEvent: new CalendarEvent()
        });
    };
    var newBookingAppointment = function newBookingAppointment() {
        return new Appointment({
            id: Appointment.specialIds.newBooking,
            summary: 'New booking...',
            sourceEvent: new CalendarEvent(),
            sourceBooking: new Booking()
        });
    };
    
    this.currentAppointment = ko.observable(loadingAppointment);

    this.updateUrl = function updateUrl() {
        // Update URL to match the appointment ID and
        // track it state
        // Get ID from URL, to avoid do anything if the same.
        var apt = this.currentAppointment(),
            aptId = apt.id(),
            found = /appointment\/([^\/]+)\/(\-?\d+)/i.exec(window.location),
            urlId = found && found[2] |0,
            urlDate = found && found[1],
            curDateStr = getDateWithoutTime(apt.startTime()).toISOString();

        if (!found ||
            urlId !== aptId.toString() ||
            urlDate !== curDateStr) {

            // If was an incomplete URL, just replace current state
            if (urlId === '')
                this.app.shell.history.replaceState(null, null, 'appointment/' + curDateStr + '/' + aptId);
            else
                this.app.shell.history.pushState(null, null, 'appointment/' + curDateStr + '/' + aptId);
        }
    };

    this.goPrevious = function goPrevious() {
        if (this.editMode()) return;

        var index = this.currentIndex() - 1;

        if (index < 0) {
            // Go previous date
            var m = moment(this.currentDate());
            if (!m.isValid()) {
                m = moment(new Date());
            }
            var prevDate = m.subtract(1, 'days').toDate();
            this.setCurrent(prevDate);
        }
        else {
            // Go previous item in the list, by changing currentID
            index = index % this.appointments().length;
            var apt = this.appointments()[index];
            this.currentIndex(index);
            this.currentID(apt.id());
            this.currentAppointment(apt);
            this.updateUrl();
            // Complete load-double check: this.setCurrent(apt.startTime(), apt.id());
        }
    };

    this.goNext = function goNext() {
        if (this.editMode()) return;
        var index = this.currentIndex() + 1;

        if (index >= this.appointments().length) {
            // Go next date
            var m = moment(this.currentDate());
            if (!m.isValid()) {
                m = moment(new Date());
            }
            var nextDate = m.add(1, 'days').toDate();
            this.setCurrent(nextDate);
        }
        else {
            // Go next item in the list, by changing currentID
            index = index % this.appointments().length;
            var apt = this.appointments()[index];
            this.currentIndex(index);
            this.currentID(apt.id());
            this.currentAppointment(apt);
            this.updateUrl();
            // Complete load-double check: this.setCurrent(apt.startTime(), apt.id());
        }
    };

    /**
        Changing the current viewed data by date and id
    **/

    this.getSpecialItem = function (id) {
        switch (id) {
            default:
            //case -1:
                return newEmptyDateAppointment();
            case Appointment.specialIds.free:
                return newFreeAppointment();
            case Appointment.specialIds.newEvent:
                return newEventAppointment();
            case Appointment.specialIds.newBooking:
                return newBookingAppointment();
            case Appointment.specialIds.loading:
                return loadingAppointment;
            case Appointment.specialIds.unavailable:
                return newUnavailableAppointment();
        }
    };
    this.setItemFromCurrentList = function (id) {
        /*jshint maxdepth:6,maxcomplexity:8*/
        var list = this.appointments(),
            index,
            item;

        // First, respect special IDs, except the 'no appts':
        if (id < -1) {
            item = this.getSpecialItem(id);
            index = -1;
        }
        else if (list.length === 0) {
            // No item ID, empty list:
            index = -1;
            // Show as empty or full-unavailable:
            if (this.dateAvailability().workDayMinutes() === 0)
                item = newUnavailableAppointment();
            else
                item = newEmptyDateAppointment();
        }
        else {
            // Start getting the first item in the list
            item = list[0];
            index = 0;
            
            // With any ID value
            if (id) {
                // Search the ID
                if (id > 0) {
                    // search item in cached list
                    var found = findAppointmentInList(list, id);

                    if (found.item) {
                        item = found.item;
                        index = found.index;
                    }
                    // Else, the first item will be used
                }
                else {
                    item = this.getSpecialItem(id);
                    index = -1;
                }
            }   
        }

        this.currentID(item.id());
        this.currentIndex(index);
        this.currentAppointment(item);
    };
    
    var _setCurrent = function setCurrent(date, id, type) {
        //jshint maxcomplexity:8
        // IMPORTANT: the date to use must be ever
        // a new object rather than the referenced one to
        // avoid some edge cases where the same object is mutated
        // and comparisions can fail. 
        // getDateWithoutTime ensure to create a new instance ever.
        date = date && getDateWithoutTime(date) || null;
        if (date)
            this.currentDate(date);
        
        if (!date) {
            if (id > 0) {
                // remote search for id
                this.isLoading(true);

                var notFound = function notFound() {
                    this.isLoading(false);
                    return _setCurrent(new Date());
                }.bind(this);

                var ids = {};
                if (type === 'booking')
                    ids.bookingID = id;
                else
                    ids.calendarEventID = id;
                
                return app.model.calendar.getAppointment(ids)
                .then(function (item) {
                    if (item) {
                        // Force a load for the item date.
                        var itDate = getDateWithoutTime(item.startTime());
                        this.isLoading(false);
                        return _setCurrent(itDate, item.id());
                    }
                    else {
                        return notFound();
                    }
                }.bind(this))
                .catch(notFound);
            }
            else if (id < 0) {
                // Special IDs
                return _setCurrent(new Date(), id);
            }
            else {
                // No date, no ID, load today
                return _setCurrent(new Date());
            }
        }
        else {
            this.isLoading(true);
            return app.model.calendar.getDateAvailability(date)
            .then(function (dateAvail) {
                this.isLoading(false);
                this.dateAvailability(dateAvail);
                this.setItemFromCurrentList(id);
            }.bind(this))
            .catch(function(err) {

                this.isLoading(false);

                var msg = 'Error loading calendar events.';
                app.modals.showError({
                    title: msg,
                    error: err && err.error || err
                });

            }.bind(this));
        }
    }.bind(this);

    var promiseSetCurrent = Promise.resolve();
    this.setCurrent = function setCurrent(date, id, type) {
        // NOTE: Do nothing if is already in loading process
        // TODO: review if is better to cancel current and continue or
        // just the current queue for when it's finish.
        // If set as 'allow concurrent'
        // the isLoading may be not enough to control the several loadings
        promiseSetCurrent = promiseSetCurrent.then(function() {
            return _setCurrent(date, id, type);
        });
        return promiseSetCurrent;
    };
}

},{"../components/Activity":64,"../components/DatePicker":65,"../models/Appointment":70,"../models/Booking":71,"../models/CalendarEvent":74,"../utils/getDateWithoutTime":121,"knockout":false,"moment":false}],5:[function(require,module,exports){
/**
    BookMeButton activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout'),
    $ = require('jquery');

var A = Activity.extends(function BookMeButtonActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling');
    
    // Auto select text on textarea, for better 'copy'
    // NOTE: the 'select' must happen on click, no touch, not focus,
    // only 'click' is reliable and bug-free.
    this.registerHandler({
        target: this.$activity,
        event: 'click',
        selector: 'textarea',
        handler: function() {
            $(this).select();
        }
    });
    
    this.registerHandler({
        target: this.app.model.marketplaceProfile,
        event: 'error',
        handler: function(err) {
            if (err && err.task === 'save') return;
            var msg = 'Error loading data to build the Button.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.marketplaceProfile.sync();
    
    // Set the job title
    var jobID = state.route.segments[0] |0;
    this.viewModel.jobTitleID(jobID);
};

function ViewModel(app) {

    var marketplaceProfile = app.model.marketplaceProfile;
    
    // Actual data for the form:
    
    // Read-only bookCode
    this.bookCode = ko.computed(function() {
        return marketplaceProfile.data.bookCode();
    });
    
    this.jobTitleID = ko.observable(0);
    
    // Button type, can be: 'small', 'medium', 'large', 'link'
    this.type = ko.observable('medium');

    this.isLocked = marketplaceProfile.isLocked;
    
    // Generation of the button code
    
    var buttonTemplate =
        '<!-- begin Loconomics book-me-button -->' +
        '<a style="display:inline-block"><img alt="" style="border:none" /></a>' + 
        '<!-- end Loconomics book-me-button -->';
    
    var linkTemplate =
        '<!-- begin Loconomics book-me-button -->' +
        '<a><span></span></a>' +
        '<!-- end Loconomics book-me-button -->';

    this.buttonHtmlCode = ko.pureComputed(function() {
        
        if (marketplaceProfile.isLoading()) {
            return 'loading...';
        }
        else {
            var type = this.type(),
                tpl = buttonTemplate;

            if (type === 'link')
                tpl = linkTemplate;

            var siteUrl = $('html').attr('data-site-url'),
                linkUrl = siteUrl + '/book/' + this.bookCode() + '/' + this.jobTitleID() + '/',
                imgUrl = siteUrl + '/img/extern/book-me-button-' + type + '.png';

            var code = generateButtonCode({
                tpl: tpl,
                label: 'Click here to book me now (on loconomics.com)',
                linkUrl: linkUrl,
                imgUrl: imgUrl
            });

            return code;
        }
    }, this);
    
    // TODO Copy feature; will need a native plugin
    this.copyCode = function() { };
    
    this.sendByEmail = function() {
        // TODO Send by email, with window.open('mailto:&body=code');
    };
}

function generateButtonCode(options) {

    var $btn = $($.parseHTML('<div>' + options.tpl + '</div>'));

    $btn
    .find('a')
    .attr('href', options.linkUrl)
    .find('span')
    .text(options.label);
    $btn
    .find('img')
    .attr('src', options.imgUrl)
    .attr('alt', options.label);

    return $btn.html();
}

},{"../components/Activity":64,"knockout":false}],6:[function(require,module,exports){
/** Calendar activity **/
'use strict';

var $ = require('jquery'),
    moment = require('moment'),
    ko = require('knockout'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

require('../components/DatePicker');
var datepickerAvailability = require('../utils/datepickerAvailability');

var Activity = require('../components/Activity');

var A = Activity.extends(function CalendarActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Calendar');

    /* Getting elements */
    this.$datepicker = this.$activity.find('#calendarDatePicker');
    this.$dailyView = this.$activity.find('#calendarDailyView');
    this.$dateTitle = this.$activity.find('.CalendarDateHeader > .btn');
    this.$chooseNew = $('#calendarChooseNew');
    
    /* Init components */
    this.$datepicker.show().datepicker({ extraClasses: 'DatePicker--tagged' });
    
    this.tagAvailability = datepickerAvailability.create(this.app, this.$datepicker, this.viewModel.isLoading);

    /* Event handlers */
    // Changes on currentDate
    this.registerHandler({
        target: this.viewModel.currentDate,
        handler: function(date) {

            if (date) {
                var mdate = moment(date);

                if (mdate.isValid()) {

                    var isoDate = mdate.toISOString();

                    // Update datepicker selected date on date change (from 
                    // a different source than the datepicker itself
                    this.$datepicker.removeClass('is-visible');
                    // Change not from the widget?
                    if (this.$datepicker.datepicker('getValue').toISOString() !== isoDate)
                        this.$datepicker.datepicker('setValue', date, true);

                    // On currentDate changes, update the URL
                    // TODO: save a useful state
                    // DOUBT: push or replace state? (more history entries or the same?)
                    this.app.shell.history.pushState(null, null, 'calendar/' + isoDate);

                    // DONE
                    return;
                }
            }

            // Something fail, bad date or not date at all
            // Set the current 
            this.viewModel.currentDate(getDateWithoutTime());

        }.bind(this)
    });

    // Swipe date on gesture
    this.registerHandler({
        target: this.$dailyView,
        event: 'swipeleft swiperight',
        handler: function(e) {
            e.preventDefault();

            var dir = e.type === 'swipeleft' ? 'next' : 'prev';

            // Hack to solve the freezy-swipe and tap-after bug on JQM:
            $(document).trigger('touchend');
            // Change date
            this.$datepicker.datepicker('moveValue', dir, 'date');

        }.bind(this)
    });

    // Showing datepicker when pressing the title
    this.registerHandler({
        target: this.$dateTitle,
        event: 'click',
        handler: function(e) {
            this.$datepicker.toggleClass('is-visible');
            e.preventDefault();
            e.stopPropagation();
        }.bind(this)
    });

    // Updating view date when picked another one
    this.registerHandler({
        target: this.$datepicker,
        event: 'dateChanged',
        handler: function(e) {
            if (e.viewMode === 'days') {
                this.viewModel.currentDate(getDateWithoutTime(e.date));
            }
        }.bind(this)
    });

    // Set date to today
    this.viewModel.currentDate(getDateWithoutTime());
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    // Date from the parameter, fallback to today
    var sdate = options.route && options.route.segments && options.route.segments[0],
        date;
    if (sdate) {
        // Parsing date from ISO format
        var mdate = moment(sdate);
        // Check is valid, and ensure is date at 12AM
        date = mdate.isValid() ? getDateWithoutTime(mdate.toDate()) : null;
    }
    
    if (!date)
        // Today:
        date = getDateWithoutTime();
    
    // Reset to force new data load (can happens if schedule was change or anything in the middle)
    this.viewModel.previousDate = null;
    this.viewModel.currentDate(date);
    // Force a refresh of tags
    this.tagAvailability(date, true);
};

var Appointment = require('../models/Appointment'),
    TimeSlotViewModel = require('../viewmodels/TimeSlot');

function ViewModel(app) {

    this.currentDate = ko.observable(getDateWithoutTime());
    var fullDayFree = [Appointment.newFreeSlot({ date: this.currentDate() })];
    // The 'free' event must update with any change in currentDate
    this.currentDate.subscribe(function(date) {
        if (date) {
            fullDayFree[0].startTime(date);
            fullDayFree[0].endTime(date);
        }
    }, this);

    // slotsSource save the data as processed by a request of 
    // data because a date change.
    // It's updated by changes on currentDate that performs the remote loading
    this.slotsSource = ko.observable(fullDayFree);
    // slots computed, using slotsSource.
    // As computed in order to allow any other observable change
    // from trigger the creation of a new value
    this.slots = ko.computed(function() {
    
        var slots = this.slotsSource();
        
        // Hide unavailable slots, except if there is only one slot (so there
        // is ever something displayed)
        if (slots.length > 1) {
            slots = slots.filter(function(slot) {
                return slot.id() !== Appointment.specialIds.unavailable;
            });
        }
        
        return slots.map(TimeSlotViewModel.fromAppointment);

    }, this);
    
    this.isLoading = ko.observable(false);

    // Update current slots on date change
    // previousDate is public to allow being reset on a new show (discard old data
    // by forcing a load)
    this.previousDate = this.currentDate().toISOString();
    this.currentDate.subscribe(function (date) {

        // IMPORTANT: The date object may be reused and mutated between calls
        // (mostly because the widget I think), so is better to create
        // a clone and avoid getting race-conditions in the data downloading.
        date = new Date(Date.parse(date.toISOString()));

        // Avoid duplicated notification, un-changed date
        if (date.toISOString() === this.previousDate) {
            return;
        }
        this.previousDate = date.toISOString();

        this.isLoading(true);
        
        app.model.calendar.getDateAvailability(date)
        .then(function(dateAvail) {
            
            // IMPORTANT: First, we need to check that we are
            // in the same date still, because several loadings
            // can happen at a time (changing quickly from date to date
            // without wait for finish), avoiding a race-condition
            // that create flickering effects or replace the date events
            // by the events from other date, because it tooks more an changed.
            // TODO: still this has the minor bug of losing the isLoading
            // if a previous triggered load still didn't finished; its minor
            // because is very rare that happens, moving this stuff
            // to a special appModel for mixed bookings and events with 
            // per date cache that includes a view object with isLoading will
            // fix it and reduce this complexity.
            if (date.toISOString() !== this.currentDate().toISOString()) {
                // Race condition, not the same!! out:
                return;
            }
        
            // Update the source:
            this.slotsSource(dateAvail.list());
            this.isLoading(false);

        }.bind(this))
        .catch(function(err) {
            
            // Show free on error
            this.slotsSource(fullDayFree);
            this.isLoading(false);
            
            var msg = 'Error loading calendar events.';
            app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
            
        }.bind(this));

    }.bind(this));
}

},{"../components/Activity":64,"../components/DatePicker":65,"../models/Appointment":70,"../utils/datepickerAvailability":118,"../utils/getDateWithoutTime":121,"../viewmodels/TimeSlot":144,"knockout":false,"moment":false}],7:[function(require,module,exports){
/**
    CalendarSyncing activity
**/
'use strict';

var Activity = require('../components/Activity'),
    $ = require('jquery'),
    ko = require('knockout');

var A = Activity.extends(function CalendarSyncingActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    
    // Adding auto-select behavior to the export URL
    this.registerHandler({
        target: this.$activity.find('#calendarSync-icalExportUrl'),
        event: 'click',
        handler: function() {
            $(this).select();
        }
    });
    
    this.registerHandler({
        target: this.app.model.calendarSyncing,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving calendar syncing settings.' : 'Error loading calendar syncing settings.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.calendarSyncing.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var calendarSyncing = app.model.calendarSyncing;

    var syncVersion = calendarSyncing.newVersion();
    syncVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            syncVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.sync = syncVersion.version;

    this.isLocked = ko.pureComputed(function() {
        return this.isLocked() || this.isReseting();
    }, calendarSyncing);

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, calendarSyncing);
    
    this.resetText = ko.pureComputed(function() {
        return (
            this.isReseting() ? 
                'reseting...' : 
                'Reset Private URL'
        );
    }, calendarSyncing);
    
    this.discard = function discard() {
        syncVersion.pull({ evenIfNewer: true });
    };

    this.save = function save() {
        syncVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    };
    
    this.reset = function reset() {
        calendarSyncing.resetExportUrl();
    };
}

},{"../components/Activity":64,"knockout":false}],8:[function(require,module,exports){
/**
    ClientEdition activity
**/
'use strict';

var Activity = require('../components/Activity');
var is = require('is_js');

var A = Activity.extends(function ClientEditionActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('clients', {
        backLink: 'clients'
    });
    
    // If there is a change on the clientID, the updates must match
    // that (if is not already that)
    this.registerHandler({
        target: this.viewModel.clientID,
        handler: function (clientID) {
            if (!clientID)
                return;

            var found = /clientEditor\/(\-?\d+)/i.exec(window.location),
                urlID = found && found[1] |0;

            // If is different URL and current ID
            if (!found ||
                urlID !== clientID) {
                // Replace URL
                this.app.shell.history.replaceState(null, null, 'clientEditor/' + clientID);
            }
        }.bind(this)
    });
    
    // Special treatment of the save operation
    this.viewModel.onSave = function(clientID) {
        if (this.requestData.returnNewAsSelected === true) {
            // Go to previous activity that required
            // to select a client
            this.requestData.clientID = clientID;
            this.app.shell.goBack(this.requestData);
        }
        else {
            // Regular save
            this.app.successSave();
        }
    }.bind(this);
});

exports.init = A.init;

var ko = require('knockout');

A.prototype.updateNavBarState = function updateNavBarState() {

    var referrer = this.app.shell.referrerRoute;
    referrer = referrer && referrer.url || '/clients';
    var link = this.requestData.cancelLink || referrer;
    
    this.convertToCancelAction(this.navBar.leftAction(), link);
};

A.prototype.show = function show(state) {
    /*jshint maxcomplexity: 8*/
    Activity.prototype.show.call(this, state);
    
    // reset
    this.viewModel.clientID(0);
    
    this.updateNavBarState();

    // params
    var params = state && state.route && state.route.segments || [];
    
    var clientID = params[0] |0;
    
    if (clientID) {
        this.viewModel.clientID(clientID);
        
        /*this.viewModel.client.sync(clientID)
        .catch(function (err) {
            this.app.modals.showError({
                title: 'Error loading client data',
                error: err
            });
        }.bind(this));*/

        this.app.model.customers.createItemVersion(clientID)
        .then(function (clientVersion) {
            if (clientVersion) {
                this.viewModel.clientVersion(clientVersion);
                this.viewModel.header('Edit Client');
            } else {
                this.viewModel.clientVersion(null);
                this.viewModel.header('Unknow client or was deleted');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'Error loading client data',
                error: err
            });
        }.bind(this));
    }
    else {
        
        // Check request parameters that allow preset customer information
        // (used when the customer is created based on an existent marketplace user)
        var presetData = this.requestData.presetData || {};
        // If there is not set an explicit 'false' value on editable
        // field (as when there is not data given), set to true so can be edited
        // NOTE: This is because a given marketplace user will come with editable:false
        // and need to be preserved, while on regular 'new client' all data is set by 
        // the freelancer.
        if (presetData.editable !== false) {
            presetData.editable = true;
        }

        /*this.viewModel.client.newItem(presetData);*/
        // New client
        this.viewModel.clientVersion(this.app.model.customers.newItem(presetData));
        this.viewModel.header('Add a Client');
        
        // Extra preset data
        if (this.requestData.newForSearchText) {
            clientDataFromSearchText(this.requestData.newForSearchText || '', this.viewModel.client());
        }
    }
};

/**
    Small utility that just returns true if the given
    string seems a possible phone number, false otherwise.
    NOTE: Is NOT an exaustive phone validation check, just
    checks is there are several numbers so there is a chance
    to be a phone. There are stricker checks (annotated) but
    can fail on some situations (switchboard numbers) or in
    different locales.
**/
function seemsAPhoneNumber(str) {
    // Possible stricker comparision
    // return is.nanpPhone(str) || is.eppPhone(str);
    
    // Just if there are more than three consecutive numbers,
    // then 'may' be a phone number (may be anything else, but
    // since some special phone numbers can have letters or signs,
    // this is just a very lax and conservative (to avoid false negatives) check.
    return (/\d{3,}/).test(str || '');
}

/**
    Use the provided search text as the initial value
    for: name, email or phone (what fits better)
**/
function clientDataFromSearchText(txt, client) {
    if (is.email(txt)) {
        client.email(txt);
    }
    else if (seemsAPhoneNumber(txt)) {
        client.phone(txt);
    }
    else {
        // Otherwise, think is the fullname, spliting by white space
        var nameParts = txt.split(' ', 2);
        client.firstName(nameParts[0]);
        if (nameParts.length > 1) {
            client.lastName(nameParts[1]);
            // TODO For spanish (or any locale with secondLastName)
            // must try to detect the second last name?
        }
    }
}

function ViewModel(app) {
    /*jshint maxstatements:80 */
    
    this.clientID = ko.observable(0);
    
    this.clientVersion = ko.observable(null);
    this.client = ko.pureComputed(function() {
        var v = this.clientVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    //this.client = app.model.customers.createWildcardItem();

    this.header = ko.observable('');
    
    this.isLoading = app.model.customers.state.isLoading;
    this.isSyncing = app.model.customers.state.isSyncing;
    this.isSaving = app.model.customers.state.isSaving;
    this.isLocked = ko.pureComputed(function() {
        return (
            app.model.customers.state.isLocked() ||
            this.isDeleting()
        );
    }, this);
    this.isReadOnly = ko.pureComputed(function() {
        var c = this.client();
        return c && !c.editable();
    }, this);

    this.isDeleting = app.model.customers.state.isDeleting;

    this.wasRemoved = ko.observable(false);

    this.isNew = ko.pureComputed(function() {
        var c = this.client();
        return !c || !c.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.clientVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    this.isNew() ?
                        'Add client' :
                        v && v.areDifferent() ?
                            'Save changes' :
                            'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.clientVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {

        app.model.customers.setItem(this.client().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.client().model.updateWith(serverData);
            // Push version so it appears as saved
            this.clientVersion().push({ evenIfObsolete: true });
          
            // Special save, function provided by the activity on set-up
            this.onSave(serverData.customerUserID);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        app.modals.confirm({
            title: 'Delete client',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.customers.delItem(this.clientID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    // Birth month day
    // TODO l10n
    this.months = ko.observableArray([
        { id: 1, name: 'January'},
        { id: 2, name: 'February'},
        { id: 3, name: 'March'},
        { id: 4, name: 'April'},
        { id: 5, name: 'May'},
        { id: 6, name: 'June'},
        { id: 7, name: 'July'},
        { id: 8, name: 'August'},
        { id: 9, name: 'September'},
        { id: 10, name: 'October'},
        { id: 11, name: 'November'},
        { id: 12, name: 'December'}
    ]);
    // We need to use a special observable in the form, that will
    // update the back-end profile.birthMonth
    this.selectedBirthMonth = ko.computed({
        read: function() {
            var c = this.client();
            if (c) {
                var birthMonth = c.birthMonth();
                return birthMonth ? this.months()[birthMonth - 1] : null;
            }
            return null;
        },
        write: function(month) {
            var c = this.client();
            if (c)
                c.birthMonth(month && month.id || null);
        },
        owner: this
    });
    
    this.monthDays = ko.observableArray([]);
    for (var iday = 1; iday <= 31; iday++) {
        this.monthDays.push(iday);
    }
    
    // Extra for button addons
    this.validEmail = ko.pureComputed(function() {
        var c = this.client();
        if (c) {
            var e = c.email();
            return is.email(e) ? e : '';
        }
        return '';
    }, this);

    this.validPhone = ko.pureComputed(function() {
        var c = this.client();
        if (c) {
            var e = c.phone();
            return seemsAPhoneNumber(e) ? e : '';
        }
        return '';
    }, this);
    
    // Public Search
    
    var foundPublicUser = function foundPublicUser(user) {
        // Only if still matches current view data
        var c = this.client();
        if (!c) return;
        
        // Don't offer if is already that user!
        if (c.customerUserID() === user.customerUserID) return;
        
        // NOTE: avoiding use fullName because it can make more than one conflicting
        // results, being not enough the name to confirm the user (use the search for that)
        //  c.fullName() === user.fullName ||
        if (c.email() === user.email ||
            c.phone() === user.phone) {

            // Notify user
            var msg = 'We`ve found an existing record for {0}. Would you like to add him to your clients?'.replace(/\{0\}/g, user.firstName);
            app.modals.confirm({
                title: 'Customer found at loconomics.com',
                message: msg
            })
            .then(function() {
                // Acepted
                // Replace current user data
                // but keep notesAboutCustomer
                var notes = c.notesAboutCustomer();
                c.model.updateWith(user);
                c.notesAboutCustomer(notes);
                this.clientID(user.customerUserID);
            }.bind(this))
            .catch(function() {
                // Discarded, do nothing
            });
        }
        
    }.bind(this);
    
    // When filering has no results:
    ko.computed(function() {
        var c = this.client();
        if (!c) return;
        
        // NOTE: discarded the fullName because several results can be retrieved,
        // better use the search for that and double check entries
        
        var email = c.email(),
            //fullName = c.fullName(),
            phone = c.phone();
        if (!email && !phone /*!fullName && */) return;

        app.model.customers.publicSearch({
            //fullName: fullName,
            email: email,
            phone: phone
        })
        .then(function(r) {
            if (r && r[0]) foundPublicUser(r[0]);
        }.bind(this))
        .catch(function() {
            // Doesn't matters
        });
    }, this)
    // Avoid excessive request by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 400, method: 'notifyWhenChangesStop' } });
}

},{"../components/Activity":64,"is_js":false,"knockout":false}],9:[function(require,module,exports){
/**
    clients activity
**/
'use strict';

var $ = require('jquery'),
    ko = require('knockout'),
    Activity = require('../components/Activity'),
    textSearch = require('../utils/textSearch');

var A = Activity.extends(function ClientsActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Clients', {
        backLink: 'cms'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject();
    
    // Getting elements
    this.$index = this.$activity.find('#clientsIndex');
    this.$listView = this.$activity.find('#clientsListView');

    // Handler to go back with the selected client when 
    // there is one selected and requestData is for
    // 'select mode'
    this.registerHandler({
        target: this.viewModel.selectedClient,
        handler: function (theSelectedClient) {
            // We have a request and
            // it requested to select a client,
            // and a selected client
            if (this.requestData &&
                this.requestData.selectClient === true &&
                theSelectedClient) {

                // Pass the selected client in the info
                this.requestData.selectedClientID = theSelectedClient.customerUserID();
                // And go back
                this.app.shell.goBack(this.requestData);
                // Last, clear requestData
                this.requestData = null;
            }
        }.bind(this)
    });
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    //jshint maxcomplexity:8
    
    var itIs = this.viewModel.isSelectionMode();
    
    this.viewModel.headerText(itIs ? 'Select a client' : '');

    if (this.requestData.title) {
        // Replace title by title if required
        this.navBar.title(this.requestData.title);
    }
    else {
        // Title must be empty
        this.navBar.title('');
    }

    if (this.requestData.cancelLink) {
        this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink);
    }
    else {
        // Reset to defaults, or given title:
        this.navBar.leftAction().model.updateWith(this.defaultLeftAction);
        if (this.requestData.navTitle)
            this.navBar.leftAction().text(this.requestData.navTitle);
    }
    
    if (itIs && !this.requestData.cancelLink) {
        // Uses a custom handler so it returns keeping the given state:
        this.navBar.leftAction().handler(this.returnRequest);
    }
    else if (!itIs) {
        this.navBar.leftAction().handler(null);
    }
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // On every show, search gets reseted
    this.viewModel.searchText('');
    this.viewModel.selectedClient(null);
    this.viewModel.requestData = this.requestData;
    
    // Check if it comes from a clientEditor that
    // received the flag 'returnNewAsSelected' and a 
    // clientID: we were in selection mode->creating client->must
    // return the just created client to the previous page
    if (state.returnNewAsSelected === true &&
        state.clientID) {
        
        // perform an activity change but allow the current
        // to stop first
        setTimeout(function() {
            delete state.returnNewAsSelected;
            this.requestData.selectedClientID = state.clientID;
            // And go back
            this.app.shell.goBack(this.requestData);
        }.bind(this), 1);
        
        // avoid the rest operations
        return;
    }
    
    // Set selection:
    this.viewModel.isSelectionMode(state.selectClient === true);

    this.updateNavBarState();
    
    // Keep data updated:
    this.app.model.customers.sync()
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading the clients list',
            error: err
        });
    }.bind(this));
};

function ViewModel(app) {

    this.headerText = ko.observable('');

    // Especial mode when instead of pick and edit we are just selecting
    // (when editing an appointment)
    this.isSelectionMode = ko.observable(false);

    // Full list of clients
    this.clients = app.model.customers.list;
    this.isLoading = app.model.customers.state.isLoading;
    this.isSyncing = app.model.customers.state.isSyncing;
    
    // Search text, used to filter 'clients'
    this.searchText = ko.observable('');
    
    // Utility to get a filtered list of clients based on clients
    this.getFilteredList = function getFilteredList() {
        var s = (this.searchText() || '').toLowerCase();
        // Search the client by:
        // - full name
        // - (else) email
        // - (else) phone
        return this.clients().filter(function(client) {
            if (!client) return false;
            var found = textSearch(s, client.fullName());
            if (found) return true;
            found = textSearch(s, client.email());
            if (found) return true;
            found = textSearch(s, client.phone());
            return found;
        });
    };

    // Filtered list of clients
    this.filteredClients = ko.computed(function() {
        return this.getFilteredList();
    }, this);
    
    // Grouped list of filtered clients
    this.groupedClients = ko.computed(function(){

        // Sorting list, in a cross browser way (in Firefox, just A > B works, but not on webkit/blink)
        var clients = this.filteredClients().sort(function(clientA, clientB) {
            var a = clientA.firstName().toLowerCase(),
                b = clientB.firstName().toLowerCase();
            if (a === b)
                return 0;
            else if (a > b)
                return 1;
            else
                return -1;
        });
        
        var groups = [],
            latestGroup = null,
            latestLetter = null;

        clients.forEach(function(client) {
            var letter = (client.firstName()[0] || '').toUpperCase();
            if (letter !== latestLetter) {
                latestGroup = {
                    letter: letter,
                    clients: [client]
                };
                groups.push(latestGroup);
                latestLetter = letter;
            }
            else {
                latestGroup.clients.push(client);
            }
        });

        return groups;

    }, this);
    
    
    /// Public search
    this.publicSearchResults = ko.observableArray([]);
    this.publicSearchRunning = ko.observable(null);
    // When filering has no results:
    ko.computed(function() {    
        var filtered = this.filteredClients(),
            searchText = this.searchText(),
            request = null;

        // If there is search text and no results from local filtering
        if (filtered.length === 0 && searchText) {
            
            // Remove previous results
            this.publicSearchResults([]);
            
            request = app.model.customers.publicSearch({
                fullName: searchText,
                email: searchText,
                phone: searchText
            });
            this.publicSearchRunning(request);
            request.then(function(r) {
                this.publicSearchResults(r);
            }.bind(this))
            .catch(function(err) {
                app.modals.showError({
                    title: 'There was an error when on remote clients search',
                    error: err
                });
            })
            .then(function() {
                // Always:
                // if still the same, it ended then remove
                if (this.publicSearchRunning() === request)
                    this.publicSearchRunning(null);
            }.bind(this));
        }
        else {
            this.publicSearchResults([]);
            // Cancelling any pending request, to avoid
            // anwanted results when finish
            request = this.publicSearchRunning();
            if (request &&
                request.xhr &&
                request.xhr.abort) {
                request.xhr.abort();
                this.publicSearchRunning(null);
            }
        }
    }, this)
    // Avoid excessive request by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 400, method: 'notifyWhenChangesStop' } });
    
    /**
        Add a client from the public/remote search results
    **/
    this.addRemoteClient = function(client, event) {
        var data = client.model && client.model.toPlainObject() || client;
        var request = $.extend({}, this.requestData, {
            presetData: data,
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go('clientEditor', request);

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    /**
        Call the activity to add a new client, passing the current
        search text so can be used as initial name/email/phone
    **/
    this.addNew = function(data, event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        
        var request = $.extend({}, this.requestData, {
            newForSearchText: this.searchText(),
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go('clientEditor', request);
    }.bind(this);

    /// Selections
    
    this.selectedClient = ko.observable(null);
    
    this.selectClient = function(selectedClient, event) {
        event.preventDefault();
        event.stopImmediatePropagation();

        this.selectedClient(selectedClient);
    }.bind(this);
}

},{"../components/Activity":64,"../utils/textSearch":137,"knockout":false}],10:[function(require,module,exports){
/**
    CMS activity
    (Client Management System)
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function CmsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Client management');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Keep data updated:
    this.app.model.customers.sync()
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading the clients list',
            error: err
        });
    }.bind(this));
};

var numeral = require('numeral');

function ViewModel(app) {
    
    this.clients = app.model.customers.list;

    this.clientsCount = ko.pureComputed(function() {
        var cs = this.clients();
        
        if (cs <= 0)
            return '0 clients';
        else if (cs === 1)
            return '1 client';
        else
            return numeral(cs.length |0).format('0,0') + ' clients';
    }, this);
}

},{"../components/Activity":64,"knockout":false,"numeral":false}],11:[function(require,module,exports){
/**
    ContactForm activity
**/
'use strict';

var Activity = require('../components/Activity'),
    VocElementEnum = require('../models/VocElementEnum');

var A = Activity.extends(function ContactFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    var params = this.requestData.route.segments || [];
    var elementName = params[0] || '',
        elementID = VocElementEnum[elementName] |0;
    
    if (!elementName) {
        console.log('Feedback Support: Accessing without specify an element, using General (0)');
    }
    else if (!VocElementEnum.hasOwnProperty(elementName)) {
        console.error('Feedback Support: given a bad VOC Element name:', elementName);
    }

    this.viewModel.vocElementID(elementID);
};

var ko = require('knockout');
function ViewModel(app) {
    
    this.message = ko.observable('');
    this.wasSent = ko.observable(false);
    this.isSending = ko.observable(false);
    this.vocElementID = ko.observable(0);

    var updateWasSent = function() {
        this.wasSent(false);
    }.bind(this);
    this.message.subscribe(updateWasSent);
    
    this.submitText = ko.pureComputed(function() {
        return this.isSending() ? 'Sending..' : this.wasSent() ? 'Sent' : 'Send';
    }, this);
    
    this.send = function send() {
        this.isSending(true);
        app.model.feedback.postSupport({
            message: this.message(),
            vocElementID: this.vocElementID()
        })
        .then(function() {
            // Reset after being sent
            this.message('');
            this.wasSent(true);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error sending your feedback',
                error: err
            });
        })
        .then(function() {
            // Always
            this.isSending(false);
        }.bind(this));
    }.bind(this);
}

},{"../components/Activity":64,"../models/VocElementEnum":99,"knockout":false}],12:[function(require,module,exports){
/**
    ContactInfo activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function ContactInfoActivity() {
    
    Activity.apply(this, arguments);

    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Owner information', {
        backLink: 'ownerInfo'
    });
    this.defaultNavBar = this.navBar.model.toPlainObject();
    
    this.registerHandler({
        target: this.app.model.userProfile,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving contact data.' : 'Error loading contact data.';
            this.app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
        }.bind(this)
    });
    
    this.registerHandler({
        target: this.app.model.homeAddress,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving address details.' : 'Error loading address details.';
            this.app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
        }.bind(this)
    });
    
    // On change to a valid code, do remote look-up
    // NOTE: using directly a computed rather than the registerHandler to use
    // the rateLimit extender that avoids excesive request being performed on changes.
    // NOTE: the code inside the handler is mostly the same as in addressEditor for the same look-up.
    var app = this.app,
        viewModel = this.viewModel;
    ko.computed(function() {
        var postalCode = this.postalCode(),
            address = this;

        if (postalCode && !/^\s*$/.test(postalCode)) {
            app.model.postalCodes.getItem(postalCode)
            .then(function(info) {
                if (info) {
                    address.city(info.city);
                    address.stateProvinceCode(info.stateProvinceCode);
                    address.stateProvinceName(info.stateProvinceName);
                    viewModel.errorMessages.postalCode('');
                }
            })
            .catch(function(err) {
                address.city('');
                address.stateProvinceCode('');
                address.stateProvinceName('');
                // Expected errors, a single message, set
                // on the observable
                var msg = typeof(err) === 'string' ? err : null;
                if (msg || err && err.responseJSON && err.responseJSON.errorMessage) {
                    viewModel.errorMessages.postalCode(msg || err.responseJSON.errorMessage);
                }
                else {
                    // Log to console for debugging purposes, on regular use an error on the
                    // postal code is not critical and can be transparent; if there are 
                    // connectivity or authentification errors will throw on saving the address
                    console.error('Server error validating Zip Code', err);
                }
            });
        }
    }, this.viewModel.address)
    // Avoid excessive requests by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 200, method: 'notifyWhenChangesStop' } });
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    
    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {
        // Reset
        this.navBar.model.updateWith(this.defaultNavBar);
    }
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Discard any previous unsaved edit
    this.viewModel.discard();
    
    this.updateNavBarState();
    
    // Keep data updated:
    this.app.model.userProfile.sync();
    this.app.model.homeAddress.sync();
};

function ViewModel(app) {

    this.headerText = ko.pureComputed(function() {
        return app.model.onboarding.inProgress() ?
            'How can we reach you?' :
            'Contact information';
    });
    
    // List of possible error messages registered
    // by name
    this.errorMessages = {
        postalCode: ko.observable('')
    };
    
    // User Profile
    var userProfile = app.model.userProfile;
    var profileVersion = userProfile.newVersion();
    profileVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            profileVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.profile = profileVersion.version;
    
    // TODO l10n
    this.months = ko.observableArray([
        { id: 1, name: 'January'},
        { id: 2, name: 'February'},
        { id: 3, name: 'March'},
        { id: 4, name: 'April'},
        { id: 5, name: 'May'},
        { id: 6, name: 'June'},
        { id: 7, name: 'July'},
        { id: 8, name: 'August'},
        { id: 9, name: 'September'},
        { id: 10, name: 'October'},
        { id: 11, name: 'November'},
        { id: 12, name: 'December'}
    ]);
    // We need to use a special observable in the form, that will
    // update the back-end profile.birthMonth
    this.selectedBirthMonth = ko.computed({
        read: function() {
            var birthMonth = this.profile.birthMonth();
            return birthMonth ? this.months()[birthMonth - 1] : null;
        },
        write: function(month) {
            this.profile.birthMonth(month && month.id || null);
        },
        owner: this
    });
    
    this.monthDays = ko.observableArray([]);
    for (var iday = 1; iday <= 31; iday++) {
        this.monthDays.push(iday);
    }
    
    // Home Address
    var homeAddress = app.model.homeAddress;
    var homeAddressVersion = homeAddress.newVersion();
    homeAddressVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            homeAddressVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.address = homeAddressVersion.version;

    // Control observables: special because must a mix
    // of the both remote models used in this viewmodel
    this.isLocked = ko.computed(function() {
        return userProfile.isLocked() || homeAddress.isLocked();
    }, this);
    this.isLoading = ko.computed(function() {
        return userProfile.isLoading() || homeAddress.isLoading();
    }, this);
    this.isSaving = ko.computed(function() {
        return userProfile.isSaving() || homeAddress.isSaving();
    }, this);

    this.submitText = ko.pureComputed(function() {
        return (
            app.model.onboarding.inProgress() ?
                'Save and continue' :
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, this);
    
    // Actions

    this.discard = function discard() {
        profileVersion.pull({ evenIfNewer: true });
        homeAddressVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        Promise.all([
            profileVersion.pushSave(),
            homeAddressVersion.pushSave()
        ])
        .then(function() {
            if (app.model.onboarding.inProgress()) {
                app.model.onboarding.goNext();
            }
            else {
                app.successSave();
            }
        })
        .catch(function() {
            // catch error, managed on event
        });
    }.bind(this);
}

},{"../components/Activity":64,"knockout":false}],13:[function(require,module,exports){
/**
    Conversation activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function ConversationActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Inbox', {
        backLink: 'inbox'
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Reset
    this.viewModel.threadID(0);
    this.viewModel.thread(null);

    // Params
    var params = state && state.route && state.route.segments || [],
        threadID = params[0] |0;

    this.viewModel.threadID(threadID);
    
    // Load the data
    if (threadID) {
        this.viewModel.thread.sync(threadID)
        .catch(function(err) {
            this.app.modals.showError({
                title: 'Error loading conversation',
                error: err
            }).then(function() {
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));
    }
    else {
        this.app.modals.showError({
            title: 'Conversation Not Found'
        }).then(function() {
            this.app.shell.goBack();
        }.bind(this));
    }
};

var ko = require('knockout');

function ViewModel(app) {

    this.isLoading = app.model.messaging.state.isLoading;
    this.isSyncing = app.model.messaging.state.isSyncing;
    this.isSaving = app.model.messaging.state.isSaving;

    this.threadID = ko.observable(null);
    this.thread = app.model.messaging.createWildcardItem();

    this.subject = ko.pureComputed(function() {
        var m = this.thread();
        return (
            this.isLoading() ?
                'Loading...' :
                m && (m.subject() || '').replace(/^\s+|\s+$/g, '') || 'Conversation without subject'
        );
    }, this);
    
    // If the last message reference a booking, is
    // accessed with:
    this.bookingID = ko.pureComputed(function() {
        var msg = this.thread() && this.thread().messages()[0];
        if (msg &&
            (msg.auxT() || '').toLowerCase() === 'booking' &&
            msg.auxID()) {
            return msg.auxID();
        }
        else {
            return null;
        }
    }, this);
}

},{"../components/Activity":64,"knockout":false}],14:[function(require,module,exports){
/**
    datetimePicker activity
**/
'use strict';

var ko = require('knockout'),
    Time = require('../utils/Time'),
    moment = require('moment'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

require('../components/DatePicker');
var datepickerAvailability = require('../utils/datepickerAvailability');

var Activity = require('../components/Activity');

var A = Activity.extends(function DatetimePickerActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('', {
        helpId: 'datetimePickerHelp'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject();
    
    // Getting elements
    this.$datePicker = this.$activity.find('#datetimePickerDatePicker');
    this.$timePicker = this.$activity.find('#datetimePickerTimePicker');
    

    /* Init components */
    this.$datePicker.show().datepicker({ extraClasses: 'DatePicker--tagged' });
    this.tagAvailability = datepickerAvailability.create(this.app, this.$datePicker, this.viewModel.isLoading);
    
    this.registerHandler({
        target: this.$datePicker,
        event: 'dateChanged',
        handler: function(e) {
            if (e.viewMode === 'days') {
                this.viewModel.selectedDate(e.date);
            }
        }.bind(this)
    });
    
    this.registerHandler({
        target: this.viewModel.selectedDate,
        handler: function(date) {
            this.bindDateData(date);
        }.bind(this)
    });
    
    // Return the selected date-time
    this.registerHandler({
        target: this.viewModel.selectedDatetime,
        handler: function (datetime) {
            if (!datetime) return;
            // Pass the selected datetime in the info
            this.requestData.selectedDatetime = datetime;
            this.requestData.allowBookUnavailableTime = this.viewModel.allowBookUnavailableTime();
            // And go back
            this.app.shell.goBack(this.requestData);
        }.bind(this)
    });
    
//    this.registerHandler({
//        target: this.viewModel.pickedTime,
//        handler: function(t) {
//            if (t) {
//                if (!(t instanceof Date)) {
//                    // Build date-time
//                    var timespan = moment.duration(t);
//                    t = moment(this.selectedDate()).startOf('day').add(timespan).toDate();
//                }
//                this.allowBookUnavailableTime(true);
//                this.selectedDatetime(t);
//            }
//        }.bind(this.viewModel)
//    });
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
    
    // First load of today data
    this.bindDateData(this.viewModel.selectedDate())
    .then(function() {
        // Once finished, load the whole month
        this.tagAvailability(this.viewModel.selectedDate());
    }.bind(this));
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    
    var header = this.requestData.headerText;
    this.viewModel.headerText(header || 'Select date and time');

    if (this.requestData.title) {
        // Replace title
        this.navBar.title(this.requestData.title);
    }
    else {
        // Title must be empty
        this.navBar.title('');
        this.navBar.leftAction().text(this.requestData.navTitle || '');
    }
    
    if (this.requestData.cancelLink) {
        this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink);
    }
    else {
        // Reset to defaults, or given title:
        this.navBar.leftAction().model.updateWith(this.defaultLeftAction);
        if (this.requestData.navTitle)
            this.navBar.leftAction().text(this.requestData.navTitle);
        // Uses a custom handler so it returns keeping the given state:
        this.navBar.leftAction().handler(this.returnRequest);
    }
};

A.prototype.show = function show(state) {
    // Reset
    this.viewModel.selectedDatetime(null);
    this.viewModel.pickedTime(null);
    this.viewModel.allowBookUnavailableTime(false);
    
    Activity.prototype.show.call(this, state);
    
    // Parameters: pass a required duration
    this.viewModel.requiredDuration(this.requestData.requiredDuration |0);

    // Preselect a date, or current date
    this.viewModel.selectedDate(getDateWithoutTime(this.requestData.selectedDatetime));
    this.$datePicker.datepicker('setValue', this.viewModel.selectedDate(), true);
    
    if (!this.__firstShowDone) {
        this.__firstShowDone = true;
        // Force first refresh on datepicker to allow
        // event handlers to get notified on first time:
        this.$datePicker.datepicker('fill');
    }
    
    this.updateNavBarState();
};

A.prototype.bindDateData = function bindDateData(date) {

    this.viewModel.isLoading(true);
    return this.app.model.calendar.getDateAvailability(date)
    .then(function(data) {
        
        this.viewModel.dateAvail(data);
        
        /*var sdate = moment(date).format('YYYY-MM-DD');
        this.viewModel.slots(data.slots.map(function(slot) {
            // From string to Date
            var dateslot = new Date(sdate + 'T' + slot);
            return dateslot;
        }));*/
    }.bind(this))
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading availability',
            error: err
        });
    }.bind(this))
    .then(function() {
        // Finally
        this.viewModel.isLoading(false);
    }.bind(this));
};

function ViewModel(app) {

    this.headerText = ko.observable('Select a time');
    this.selectedDate = ko.observable(getDateWithoutTime());
    this.isLoading = ko.observable(false);
    this.requiredDuration = ko.observable(0);
    
    this.durationDisplay = ko.pureComputed(function() {
        var fullMinutes = this.requiredDuration();
        if (fullMinutes <= 0)
            return '';

        var hours = Math.floor(fullMinutes / 60),
            minutes = fullMinutes % 60,
            text = '';

        if (hours > 0)
            text += moment.duration({ hours: hours }).humanize() + ' ';
        if (minutes > 0)
            text += moment.duration({ minutes: minutes }).humanize();

        return text;
    }, this);

    this.dateAvail = ko.observable();
    this.groupedSlots = ko.computed(function(){
        
        var requiredDuration = this.requiredDuration();
        
        /*
          before 12:00pm (noon) = morning
          afternoon: 12:00pm until 5:00pm
          evening: 5:00pm - 11:59pm
        */
        // Since slots must be for the same date,
        // to define the groups ranges use the first date
        var datePart = this.dateAvail() && this.dateAvail().date() || new Date();
        var groups = [
            {
                group: 'Morning',
                slots: [],
                starts: new Time(datePart, 0, 0),
                ends: new Time(datePart, 12, 0)
            },
            {
                group: 'Afternoon',
                slots: [],
                starts: new Time(datePart, 12, 0),
                ends: new Time(datePart, 17, 0)
            },
            {
                group: 'Evening',
                slots: [],
                starts: new Time(datePart, 17, 0),
                ends: new Time(datePart, 24, 0)
            }
        ];

        // Populate groups with the time slots
        var slots = this.dateAvail() && this.dateAvail().getFreeTimeSlots(requiredDuration) || [];
        // Iterate to organize by group
        slots.forEach(function(slot) {

            // Filter slots by the increment size preference
            /*var totalMinutes = moment.duration(slot).asMinutes() |0;
            if (totalMinutes % incSize !== 0) {
                return;
            }*/

            // Check every group
            groups.some(function(group) {
                // If matches the group, push to it
                // and go out of groups iteration quickly
                if (slot >= group.starts &&
                    slot < group.ends) {
                    group.slots.push(slot);
                    return true;
                }
            });
        });

        return groups;

    }, this);
    
    this.selectedDatetime = ko.observable(null);
    
    this.selectDatetime = function(selectedDatetime, event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this.selectedDatetime(selectedDatetime);
    }.bind(this);

    ///
    /// Time Picker

    this.pickedTime = ko.observable();
    this.allowBookUnavailableTime = ko.observable(false);
    
    this.getPickedDatetime = function() {
        var t = this.pickedTime();
        if (!(t instanceof Date)) {
            // Build date-time
            var timespan = moment.duration(t);
            t = moment(this.selectedDate()).startOf('day').add(timespan).toDate();
        }
        return t;
    };
    
    this.setPickedAsSelected = function() {
        this.allowBookUnavailableTime(true);
        this.selectedDatetime(this.getPickedDatetime());
    }.bind(this);
    
    this.showTimePicker = function() {
        app.modals.showTimePicker({
            title: 'Book an unavailable time',
            selectedTime: null,
            unsetLabel: 'Cancel'
        }).then(function(pickedValue) {
            if (pickedValue.time) {
                this.pickedTime(pickedValue.time);
                this.setPickedAsSelected();
            }
        }.bind(this))
        .catch(function() {
            // Just modal was dismissed, so picker was rejected but not an error
        });
    }.bind(this);
}

},{"../components/Activity":64,"../components/DatePicker":65,"../utils/Time":113,"../utils/datepickerAvailability":118,"../utils/getDateWithoutTime":121,"knockout":false,"moment":false}],15:[function(require,module,exports){
/**
    Faqs activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function FaqsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel();
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
    
    // TestingData
    setSomeTestingData(this.viewModel);
});

exports.init = A.init;

A.prototype.show = function show(state) {
    
    Activity.prototype.show.call(this, state);
    
    this.viewModel.searchText('');
};

var ko = require('knockout');

function ViewModel() {

    this.faqs = ko.observableArray([]);
    this.searchText = ko.observable('');
    
    this.filteredFaqs = ko.pureComputed(function() {
        var s = this.searchText().toLowerCase();
        return this.faqs().filter(function(v) {
            var n = v && v.title() || '';
            n += v && v.description() || '';
            n = n.toLowerCase();
            return n.indexOf(s) > -1;
        });
    }, this);
}

var Model = require('../models/Model');
function Faq(values) {
    
    Model(this);

    this.model.defProperties({
        id: 0,
        title: '',
        description: ''
    }, values);
}

/** TESTING DATA **/
function setSomeTestingData(viewModel) {
    
    var testdata = [
        new Faq({
            id: 1,
            title: 'How do I set up a marketplace profile?',
            description: 'Description about how I set up a marketplace profile'
        }),
        new Faq({
            id: 2,
            title: 'Another faq',
            description: 'Another description'
        })
    ];
    viewModel.faqs(testdata);
}

},{"../components/Activity":64,"../models/Model":87,"knockout":false}],16:[function(require,module,exports){
/**
    Feedback activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function FeedbackActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Talk to us');
});

exports.init = A.init;

},{"../components/Activity":64}],17:[function(require,module,exports){
/**
    FeedbackForm activity
**/
'use strict';

var Activity = require('../components/Activity'),
    VocElementEnum = require('../models/VocElementEnum');

var A = Activity.extends(function FeedbackFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    var params = this.requestData.route.segments || [];
    var elementName = params[0] || '',
        elementID = VocElementEnum[elementName] |0;
    
    if (!elementName) {
        console.log('Feedback Ideas: Accessing feedback without specify an element, using General (0)');
    }
    else if (!VocElementEnum.hasOwnProperty(elementName)) {
        console.error('Feedback Ideas: given a bad VOC Element name:', elementName);
    }

    this.viewModel.vocElementID(elementID);
};

var ko = require('knockout');
function ViewModel(app) {
    
    this.message = ko.observable('');
    this.becomeCollaborator = ko.observable(false);
    this.wasSent = ko.observable(false);
    this.isSending = ko.observable(false);
    this.vocElementID = ko.observable(0);

    var updateWasSent = function() {
        this.wasSent(false);
    }.bind(this);
    this.message.subscribe(updateWasSent);
    this.becomeCollaborator.subscribe(updateWasSent);
    
    this.submitText = ko.pureComputed(function() {
        return this.isSending() ? 'Sending..' : this.wasSent() ? 'Sent' : 'Send';
    }, this);
    
    this.send = function send() {
        this.isSending(true);
        app.model.feedback.postIdea({
            message: this.message(),
            becomeCollaborator: this.becomeCollaborator(),
            vocElementID: this.vocElementID()
        })
        .then(function() {
            // Reset after being sent
            this.message('');
            this.becomeCollaborator(false);
            this.wasSent(true);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error sending your feedback',
                error: err
            });
        })
        .then(function() {
            // Always
            this.isSending(false);
        }.bind(this));
    }.bind(this);
}

},{"../components/Activity":64,"../models/VocElementEnum":99,"knockout":false}],18:[function(require,module,exports){
/**
    Freelancer Pricing activity
**/
'use strict';

var ko = require('knockout'),
    _ = require('lodash'),
    $ = require('jquery'),
    Activity = require('../components/Activity');

var A = Activity.extends(function FreelancerPricingActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Job Title', {
        backLink: '/scheduling'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject();

    // On changing jobTitleID:
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID and pricing types.
                // They are essential data
                Promise.all([
                    this.app.model.jobTitles.getJobTitle(jobTitleID),
                    this.app.model.pricingTypes.getList()
                ])
                .then(function(data) {
                    var jobTitle = data[0];
                    // Save for use in the view
                    this.viewModel.jobTitle(jobTitle);
                    // Update navbar (may indicate the jobTitle name)
                    this.updateNavBarState();
                    // Get pricing
                    return this.app.model.freelancerPricing.getList(jobTitleID);
                }.bind(this))
                .then(function(list) {

                    list = this.app.model.freelancerPricing.asModel(list);
                    
                    // Read presets selection from requestData
                    var preset = this.requestData.selectedPricing || [],
                        selection = this.viewModel.selectedPricing;
                    
                    // Add the isSelected property to each item
                    list.forEach(function(item) {
                        var preSelected = preset.some(function(pr) {
                            if (pr.freelancerPricingID === item.freelancerPricingID())
                                return true;
                        }) || false;
                        
                        item.isSelected = ko.observable(preSelected);
                        
                        if (preSelected) {
                            selection.push(item);
                        }
                    });
                    this.viewModel.list(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.list([]);
                this.viewModel.jobTitle(null);
                this.updateNavBarState();
            }
        }.bind(this)
    });
    
    // Go back with the selected pricing when triggered in the form/view
    this.viewModel.returnSelected = function(pricing, jobTitleID) {
        // Pass the selected client in the info
        this.requestData.selectedPricing = pricing;
        this.requestData.selectedJobTitleID = jobTitleID;
        // And go back
        this.app.shell.goBack(this.requestData);
    }.bind(this);
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    //jshint maxcomplexity:10
    
    var itIs = this.viewModel.isSelectionMode();
    
    this.viewModel.headerText(itIs ? 'Select services' : 'Services');
    
    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {

        if (this.requestData.title) {
            // Replace title by title if required
            this.navBar.title(this.requestData.title);
        }
        else {
            // Title must be empty
            this.navBar.title('');
        }
    
        if (this.requestData.cancelLink) {
            this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink);
        }
        else {
            // Reset to defaults, or given title:
            this.navBar.leftAction().model.updateWith(this.defaultLeftAction);
            if (this.requestData.navTitle)
                this.navBar.leftAction().text(this.requestData.navTitle);

            var jid = this.viewModel.jobTitleID(),
                jname = this.viewModel.jobTitle() && this.viewModel.jobTitle().singularName() || 'Scheduling';

            this.navBar.leftAction().link(jid ? '/jobtitles/' + jid : '/scheduling');
            this.navBar.leftAction().text(jname);
        }

        if (itIs && !this.requestData.cancelLink) {
            // Uses a custom handler so it returns keeping the given state:
            this.navBar.leftAction().handler(this.returnRequest);
        }
        else if (!this.requestData.cancelLink) {
            this.navBar.leftAction().handler(null);
        }
    }
};

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);
    this.viewModel.selectedPricing.removeAll();
    this.viewModel.requestData = this.requestData;

    this.viewModel.isSelectionMode(this.requestData.selectPricing === true);
    
    // Params
    var params = options && options.route && options.route.segments;
    var jobTitleID = params[0] |0;
    if (jobTitleID === 0 && options.selectedJobTitleID > 0)
        jobTitleID = options.selectedJobTitleID |0;

    var isAdditionMode = params[0] === 'new' || params[1] === 'new';
    if (isAdditionMode) {
        // Sets referrer as cancelLink
        var ref = this.app.shell.referrerRoute;
        ref = ref && ref.url || '/';
        this.requestData.cancelLink = ref;
        // Set for editor links in the view
        this.viewModel.cancelLink(ref);
    }
    else {
        // Set this page as cancelLink for editor links in the view
        this.viewModel.cancelLink('/freelancerPricing/' + this.viewModel.jobTitleID());
    }

    this.viewModel.isAdditionMode(isAdditionMode);
    
    this.updateNavBarState();

    this.viewModel.jobTitleID(jobTitleID);
    
    if (jobTitleID === 0) {
        this.viewModel.jobTitles.sync();
    }
};

var UserJobProfile = require('../viewmodels/UserJobProfile');

function ViewModel(app) {

    this.headerText = ko.observable('Services');
    
    this.jobTitleID = ko.observable(0);
    this.jobTitle = ko.observable(null);
    this.isAdditionMode = ko.observable(false);
    this.cancelLink = ko.observable(null);
    
    this.jobTitles = new UserJobProfile(app);
    this.jobTitles.baseUrl('/freelancerPricing');
    this.jobTitles.selectJobTitle = function(jobTitle) {
        
        this.jobTitleID(jobTitle.jobTitleID());
        var url = 'freelancerPricing/' + jobTitle.jobTitleID();
        if (this.isAdditionMode())
            url += '/new';
        // pushState cannot be used because it conflicts with the 
        // selection logic (on new-booking progress)
        // TODO: commented until the bug with replaceState in HashbangHistory is fixed
        //app.shell.history.replaceState(null, null, url);
        
        return false;
    }.bind(this);

    this.list = ko.observableArray([]);

    this.isLoading = ko.computed(function() {
        return (
            app.model.freelancerPricing.state.isLoading() ||
            app.model.pricingTypes.state.isLoading() ||
            app.model.jobTitles.state.isLoading()
        );
    });
    this.isLocked = this.isLoading;

    // Especial mode when instead of pick and edit we are just selecting
    this.isSelectionMode = ko.observable(false);

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                'Save and continue'
        );
    }, this);
    
    // Grouped list of pricings:
    // Defined groups by pricing type
    this.groupedPricing = ko.computed(function(){

        var list = this.list();
        var isSelection = this.isSelectionMode();
        var groupNamePrefix = isSelection ? 'Select ' : '';

        var groups = [],
            groupsList = [];
        if (!this.isAdditionMode()) {
            groups = _.groupBy(list, function(pricingItem) {
                return pricingItem.pricingTypeID();
            });

            // Convert the indexed object into an array with some meta-data
            groupsList = Object.keys(groups).map(function(key) {
                var gr = {
                    pricing: groups[key],
                    // Load the pricing information
                    type: app.model.pricingTypes.getObservableItem(key)
                };
                gr.group = ko.computed(function() {
                    return groupNamePrefix + (
                        this.type() && this.type().pluralName() ||
                        'Services'
                    );
                }, gr);
                return gr;
            });
        }
        
        // Since the groupsList is built from the existent pricing items
        // if there are no records for some pricing type (or nothing when
        // just created the job title), that types/groups are not included,
        // so review and include now.
        // NOTE: as a good side effect of this approach, pricing types with
        // some pricing will appear first in the list (nearest to the top)
        var pricingTypes = this.jobTitle() && this.jobTitle().pricingTypes();
        if (pricingTypes && pricingTypes.length) {
            pricingTypes.forEach(function (jobType) {
                
                var typeID = jobType.pricingTypeID();
                // Not if already in the list
                if (groups.hasOwnProperty(typeID))
                    return;

                var gr = {
                    pricing: [],
                    type: app.model.pricingTypes.getObservableItem(typeID)
                };
                gr.group = ko.computed(function() {
                    return groupNamePrefix + (
                        this.type() && this.type().pluralName() ||
                        'Services'
                    );
                }, gr);

                groupsList.push(gr);
            });
        }

        return groupsList;

    }, this);

    this.selectedPricing = ko.observableArray([]);
    /**
        Toggle the selection status of a pricing, adding
        or removing it from the 'selectedPricing' array.
    **/
    this.togglePricingSelection = function(pricing) {

        var inIndex = -1,
            isSelected = this.selectedPricing().some(function(selectedPricing, index) {
            if (selectedPricing === pricing) {
                inIndex = index;
                return true;
            }
        });

        pricing.isSelected(!isSelected);

        if (isSelected)
            this.selectedPricing.splice(inIndex, 1);
        else
            this.selectedPricing.push(pricing);
    }.bind(this);
    
    this.onboardingNextReady = ko.computed(function() {
        var isin = app.model.onboarding.inProgress(),
            hasPricing = this.list().length > 0;
        
        return isin && hasPricing;
    }, this);
    
    /**
        Ends the selection process, ready to collect selection
        and passing it to the requester activity.
        Works too to pass to the next onboarding step
    **/
    this.endSelection = function(data, event) {
        
        if (app.model.onboarding.inProgress()) {
            app.model.onboarding.goNext();
        }
        else {
            // Run method injected by the activity to return a 
            // selected address:
            this.returnSelected(
                this.selectedPricing().map(function(pricing) {
                    return {
                        freelancerPricingID: ko.unwrap(pricing.freelancerPricingID),
                        totalPrice: ko.unwrap(pricing.price)
                    };
                }),
                this.jobTitleID()
            );
        }

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    this.editPricing = function(pricing) {
        app.shell.go('freelancerPricingEditor/' + this.jobTitleID() + '/' + pricing.freelancerPricingID());
    }.bind(this);
    
    /**
        Handler for the listview items, managing edition and selection depending on current mode
    **/
    this.tapPricing = function(pricing, event) {
        if (this.isSelectionMode()) {
            this.togglePricingSelection(pricing);
        }
        else {
            this.editPricing(pricing);
        }

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    this.tapNewPricing = function(group, event) {
        
        var url = '#!freelancerPricingEditor/' + this.jobTitleID() + '/new/' + (group.type() && group.type().pricingTypeID());

        // Passing original data, for in-progress process (as new-booking)
        // and the selected title since the URL could not be updated properly
        // (see the anotated comment about replaceState bug on this file)
        var request = $.extend({}, this.requestData, {
            selectedJobTitleID: this.jobTitleID()
        });
        if (!request.cancelLink) {
            $.extend(request, {
                cancelLink: this.cancelLink()
            });
        }
        
        // When in selection mode:
        // Add current selection as preselection, so can be recovered later and 
        // the editor can add the new pricing to the list
        if (this.isSelectionMode()) {
            request.selectedPricing = this.selectedPricing()
            .map(function(pricing) {
                return {
                    freelancerPricingID: ko.unwrap(pricing.freelancerPricingID),
                    totalPrice: ko.unwrap(pricing.totalPrice)
                };
            });
        }

        app.shell.go(url, request);

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
}

},{"../components/Activity":64,"../viewmodels/UserJobProfile":145,"knockout":false,"lodash":false}],19:[function(require,module,exports){
/**
    FreelancerPricingEditor activity
    
    TODO: ModelVersion is NOT being used, so no getting updates if server updates
    the data after load (data load is requested but get first from cache). Use
    version and get sync'ed data when ready, and additionally notification to
    override changes if server data is different that any local change.
**/
'use strict';
var ko = require('knockout'),
    Activity = require('../components/Activity'),
    PricingType = require('../models/PricingType');

var A = Activity.extends(function FreelancerPricingEditorActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Services');
    
    /// Go out after save succesfully an item.
    /// Pricing is a plain object
    this.viewModel.onSave = function(pricing) {
        // Go back on save.
        // If we comes with a selection of pricing, we must add the new one
        // there and just go back (freelancerPricing is in selection mode) keeping
        // any requestData for in-progress state.
        if (this.requestData.selectedPricing) {
            // Is an array of plain objects of just ID and totalPrice
            this.requestData.selectedPricing.push({
                freelancerPricingID: pricing.freelancerPricingID,
                totalPrice: pricing.totalPrice
            });
            this.app.shell.goBack(this.requestData);
        }
        else {
            // Just execute the standard save process
            this.app.successSave();
        }
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var link = this.requestData.cancelLink || '/freelancerPricing/' + this.viewModel.jobTitleID();
    
    this.convertToCancelAction(this.navBar.leftAction(), link);
};

A.prototype.show = function show(options) {
    //jshint maxcomplexity:10    
    Activity.prototype.show.call(this, options);

    // Reset
    this.viewModel.wasRemoved(false);
    this.viewModel.freelancerPricingVersion(null);
    this.viewModel.pricingType(null);

    // Params
    var params = options && options.route && options.route.segments || [];

    var jobTitleID = params[0] |0,
        // Parameter [1] can be 'new' followed by a pricingTypeID as [2]
        pricingTypeID = params[1] === 'new' ? params[2] |0 : 0,
        // Or a pricingID
        freelancerPricingID = params[1] |0;

    this.viewModel.jobTitleID(jobTitleID);
    this.viewModel.freelancerPricingID(freelancerPricingID);
    
    this.updateNavBarState();
    
    /**
        The pricing record needs some special set-up after creation/loading and before
        being presented to the user, because special value-rules.
    **/
    var pricingSetup = function pricingSetup() {
        // Pricing fields that has a special initial value
        var c = this.viewModel.current();
        if (c) {
            // Name: must be the PricingType.fixedName ever if any, or
            //   the name saved in the pricing or
            //   the suggestedName as last fallback
            c.pricing.name(c.type.fixedName() || c.pricing.name() || c.type.suggestedName());
            // Required call after loading a pricing to reflect data correctly (cannot be automated)
            c.pricing.refreshNoPriceRate();
        }
        this.viewModel.isLoading(false);
    }.bind(this);
    
    var showInvalidRequestError = function() {
        this.viewModel.isLoading(false);
        this.app.modals.showError({
            title: 'Invalid request',
            error: { jobTitleID: jobTitleID, pricingTypeID: pricingTypeID, freelancerPricingID: freelancerPricingID }
        })
        .then(function() {
            // On close modal, go back
            this.app.shell.goBack();
        }.bind(this));
    }.bind(this);

    this.viewModel.isLoading(true);
    if (pricingTypeID) {
        // Load the pricing Type
        this.app.model.pricingTypes.getItem(pricingTypeID)
        .then(function(type) {
            if (type) {
                this.viewModel.pricingType(type);
                // New pricing
                this.viewModel.freelancerPricingVersion(this.app.model.freelancerPricing.newItemVersion({
                    jobTitleID: jobTitleID,
                    pricingTypeID: pricingTypeID
                }));
                pricingSetup();
            }
            else {
                showInvalidRequestError();
            }
        }.bind(this));
    }
    else if (freelancerPricingID) {
        // Get the pricing
        this.app.model.freelancerPricing.getItemVersion(jobTitleID, freelancerPricingID)
        .then(function (freelancerPricingVersion) {
            if (freelancerPricingVersion) {
                // Load the pricing type before put the version
                // returns to let the 'catch' to get any error
                return this.app.model.pricingTypes.getItem(freelancerPricingVersion.version.pricingTypeID())
                .then(function(type) {
                    if (type) {
                        this.viewModel.pricingType(type);
                        this.viewModel.freelancerPricingVersion(freelancerPricingVersion);
                        pricingSetup();
                    }
                    else {
                        showInvalidRequestError();
                    }
                }.bind(this));
            } else {
                showInvalidRequestError();
            }

        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            })
            .then(function() {
                // On close modal, go back
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));
    }
    else {
        showInvalidRequestError();
    }
};

function ViewModel(app) {
    /*jshint maxstatements: 35*/

    this.isLoading = ko.observable(false);
    // managed manually instead of
    //app.model.freelancerPricing.state.isLoading;
    this.isSaving = app.model.freelancerPricing.state.isSaving;
    this.isSyncing = app.model.freelancerPricing.state.isSyncing;
    this.isDeleting = app.model.freelancerPricing.state.isDeleting;
    this.jobTitleID = ko.observable(0);
    this.freelancerPricingID = ko.observable(0);
    // L10N
    this.moneySymbol = ko.observable('$');
    
    this.pricingType = ko.observable(new PricingType());

    this.freelancerPricingVersion = ko.observable(null);
    this.freelancerPricing = ko.pureComputed(function() {
        var v = this.freelancerPricingVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);

    this.header = ko.pureComputed(function() {
        if (this.isLoading()) {
            return 'Loading...';
        }
        else if (this.freelancerPricingVersion()) {
            var t = this.pricingType();
            return t && t.singularName() || 'Service';
        }
        else {
            return 'Unknow service or was deleted';
        }

    }, this);
    
    // Quicker access in form, under a 'with'
    this.current = ko.pureComputed(function() {
        var t = this.pricingType(),
            p = this.freelancerPricing();
        
        if (t && p) {
            return {
                type: t,
                pricing: p
            };
        }
        return null;
    }, this);

    this.wasRemoved = ko.observable(false);
    
    this.isLocked = ko.computed(function() {
        return this.isDeleting() || app.model.freelancerPricing.state.isLocked();
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        var p = this.freelancerPricing();
        return p && !p.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.freelancerPricingVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        'Save changes' :
                        'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.freelancerPricingVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {
        
        app.model.freelancerPricing.setItem(this.freelancerPricing().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.freelancerPricing().model.updateWith(serverData);
            // Push version so it appears as saved
            this.freelancerPricingVersion().push({ evenIfObsolete: true });
            
            // After save logic provided by the activity, injected in the view:
            this.onSave(serverData);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        // TODO Better l10n or replace by a new preset field on pricingType.deleteLabel
        var p = this.pricingType();
        app.modals.confirm({
            title: 'Delete ' + (p && p.singularName()),
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.freelancerPricing.delItem(this.jobTitleID(), this.freelancerPricingID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
}

},{"../components/Activity":64,"../models/PricingType":91,"knockout":false}],20:[function(require,module,exports){
/**
    Home activity
**/
'use strict';

var ko = require('knockout');

var Activity = require('../components/Activity'),
    AppointmentView = require('../viewmodels/AppointmentView');

var A = Activity.extends(function HomeActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
    
    // Getting elements
    this.$nextBooking = this.$activity.find('#homeNextBooking');
    this.$upcomingBookings = this.$activity.find('#homeUpcomingBookings');
    this.$inbox = this.$activity.find('#homeInbox');
    this.$performance = this.$activity.find('#homePerformance');
    this.$getMore = this.$activity.find('#homeGetMore');
    
    // TestingData
    setSomeTestingData(this.viewModel);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    var v = this.viewModel,
        app = this.app,
        appModel = this.app.model;
    
    if (this.requestData.completedOnboarding) {
        switch (this.requestData.completedOnboarding) {
            case 'welcome': // Schedule complete
                this.app.modals.showNotification({
                    title: 'Congrats',
                    message: 'You\'re all ready to start scheduling ' +
                        'clients. Click + to start adding bookings ' +
                        'and clients.'
                });
                break;
        }
    }
    
    var preapareShowErrorFor = function preapareShowErrorFor(title) {
        return function(err) {
            this.app.modals.showError({
                title: title,
                error: err
            });
        }.bind(this);
    }.bind(this);
    
    // Update data
    if (v.upcomingBookings.items().length) {
        v.upcomingBookings.isSyncing(true);
    }
    else {
        v.upcomingBookings.isLoading(true);
    }
    appModel.bookings.getUpcomingBookings()
    .then(function(upcoming) {

        if (upcoming.nextBookingID) {
            var previousID = v.nextBooking() && v.nextBooking().sourceBooking().bookingID();
            if (upcoming.nextBookingID !== previousID) {
                if (v.nextBooking()) {
                    v.nextBooking.isSyncing(true);
                }
                else {
                    v.nextBooking.isLoading(true);
                }
                appModel.calendar.getAppointment({ bookingID: upcoming.nextBookingID })
                .then(function(apt) {
                    v.nextBooking(new AppointmentView(apt, app));
                })
                .catch(preapareShowErrorFor('Error loading next booking'))
                .then(function() {
                    // Finally
                    v.nextBooking.isLoading(false);
                    v.nextBooking.isSyncing(false);
                });
            }
        }
        else {
            v.nextBooking(null);
        }

        v.upcomingBookings.today.quantity(upcoming.today.quantity);
        v.upcomingBookings.today.time(upcoming.today.time && new Date(upcoming.today.time));
        v.upcomingBookings.tomorrow.quantity(upcoming.tomorrow.quantity);
        v.upcomingBookings.tomorrow.time(upcoming.tomorrow.time && new Date(upcoming.tomorrow.time));
        v.upcomingBookings.nextWeek.quantity(upcoming.nextWeek.quantity);
        v.upcomingBookings.nextWeek.time(upcoming.nextWeek.time && new Date(upcoming.nextWeek.time));
    })
    .catch(preapareShowErrorFor('Error loading upcoming bookings'))
    .then(function() {
        // Finally
        v.upcomingBookings.isLoading(false);
        v.upcomingBookings.isSyncing(false);
    });
    
    // Messages
    var MessageView = require('../models/MessageView');
    if (v.inbox.messages().length)
        v.inbox.isSyncing(true);
    else
        v.inbox.isLoading(true);
    appModel.messaging.getList()
    .then(function(threads) {
        v.inbox.messages(threads().map(MessageView.fromThread.bind(null, app)));
    })
    .catch(preapareShowErrorFor('Error loading latest messages'))
    .then(function() {
        // Finally
        v.inbox.isLoading(false);
        v.inbox.isSyncing(false);
    });
};


var UpcomingBookingsSummary = require('../models/UpcomingBookingsSummary'),
    MailFolder = require('../models/MailFolder'),
    PerformanceSummary = require('../models/PerformanceSummary'),
    GetMore = require('../models/GetMore');

function ViewModel() {

    this.upcomingBookings = new UpcomingBookingsSummary();
    this.upcomingBookings.isLoading = ko.observable(false);
    this.upcomingBookings.isSyncing = ko.observable(false);

    this.nextBooking = ko.observable(null);
    this.nextBooking.isLoading = ko.observable(false);
    this.nextBooking.isSyncing = ko.observable(false);
    
    this.inbox = new MailFolder({
        topNumber: 4
    });
    this.inbox.isLoading = ko.observable(false);
    this.inbox.isSyncing = ko.observable(false);
    
    this.performance = new PerformanceSummary();
    
    this.getMore = new GetMore();
}

/** TESTING DATA **/
function setSomeTestingData(viewModel) {
    
    viewModel.performance.earnings.currentAmount(2400);
    viewModel.performance.earnings.nextAmount(6200.54);
    viewModel.performance.timeBooked.percent(0.93);
    
    viewModel.getMore.model.updateWith({
        availability: false,
        payments: true,
        profile: true,
        coop: false
    });
}

},{"../components/Activity":64,"../models/GetMore":79,"../models/MailFolder":83,"../models/MessageView":86,"../models/PerformanceSummary":88,"../models/UpcomingBookingsSummary":96,"../viewmodels/AppointmentView":139,"knockout":false}],21:[function(require,module,exports){
/**
    Inbox activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout'),
    MessageView = require('../models/MessageView'),
    textSearch = require('../utils/textSearch');

var A = Activity.extends(function InboxActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSectionNavBar('Inbox');
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Messages
    this.app.model.messaging.getList()
    .then(function(threads) {
        this.viewModel.sourceThreads(threads());
    }.bind(this))
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading messages',
            error: err
        });
    }.bind(this));
};

function ViewModel(app) {
    
    this.isLoading = app.model.messaging.state.isLoading;
    this.isSyncing = app.model.messaging.state.isSyncing;

    this.sourceThreads = ko.observableArray([]);
    
    this.searchText = ko.observable('');
    
    // NOTE: since current API-connection implementation only gets
    // the latest message with getList, the search is done in the
    // bodyText of the last message (additionally to the thread subject)
    // even if this implementation try to iterate all messages.
    this.threads = ko.pureComputed(function() {
        var t = this.sourceThreads(),
            s = this.searchText();

        if (!t)
            return [];
        else if (!s)
            return t.map(MessageView.fromThread.bind(null, app));
        else        
            return t.filter(function(thread) {
                var found = false;
                
                // Check subject
                found = textSearch(s, thread.subject());
                
                if (!found) {
                    // Try content of messages
                    // It stops on first 'true' result
                    thread.messages().some(function(msg) {
                        found = textSearch(s, msg.bodyText());
                        return found;
                    });
                }
                
                return found;
            }).map(MessageView.fromThread.bind(null, app));
    }, this);
}

},{"../components/Activity":64,"../models/MessageView":86,"../utils/textSearch":137,"knockout":false}],22:[function(require,module,exports){
/**
    Index activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function IndexActivity() {
    
    Activity.apply(this, arguments);

    // Any user can access this
    this.accessLevel = null;
    
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
    this.navBar.rightAction(null);
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // It checks if the user is logged so then 
    // their 'logged index' is the dashboard not this
    // page that is focused on anonymous users
    if (!this.app.model.user().isAnonymous()) {
        this.app.goDashboard();
    }
};

},{"../components/Activity":64}],23:[function(require,module,exports){
/**
    Jobtitles activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout');

var A = Activity.extends(function JobtitlesActivity() {
    
    Activity.apply(this, arguments);
    
    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: '/scheduling'
    });
    
    // On changing jobTitleID:
    // - load addresses
    // - load job title information
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {

            if (jobTitleID) {
                ////////////
                // Addresses
                this.app.model.serviceAddresses.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.serviceAddresses.asModel(list);
                    this.viewModel.addresses(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading addresses.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Pricing/Services
                this.app.model.freelancerPricing.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.freelancerPricing.asModel(list);
                    this.viewModel.pricing(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading services.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Job Title
                // Get data for the Job title ID
                this.app.model.jobTitles.getJobTitle(jobTitleID)
                .then(function(jobTitle) {

                    // Fill in job title name
                    this.viewModel.jobTitleName(jobTitle.singularName());
                }.bind(this))
                .catch(function(err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading the job title.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.addresses([]);
                this.viewModel.pricing([]);
                this.viewModel.jobTitleName('Job Title');
            }
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);

    // Parameters
    var params = state && state.route && state.route.segments || {};
    
    // Set the job title
    var jobID = params[0] |0;
    this.viewModel.jobTitleID(jobID);
};

function ViewModel(app) {
    
    this.jobTitleID = ko.observable(0);
    this.jobTitleName = ko.observable('Job Title');
    
    this.addresses = ko.observable([]);
    this.pricing = ko.observable([]);

    // Computed since it can check several externa loadings
    this.isLoading = ko.pureComputed(function() {
        return (
            app.model.serviceAddresses.state.isLoading() ||
            app.model.freelancerPricing.state.isLoading()
        );
        
    }, this);
    
    this.addressesCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.addresses().length,
            one = '1 location',
            more = ' locations';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
    this.pricingCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.pricing().length,
            one = '1 service',
            more = ' services';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
}

},{"../components/Activity":64,"knockout":false}],24:[function(require,module,exports){
/**
    LearnMore activity
**/
'use strict';
var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function LearnMoreActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = new ViewModel(this.app);
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
    this.navBar.rightAction(null);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    if (options && options.route &&
        options.route.segments &&
        options.route.segments.length) {
        this.viewModel.profile(options.route.segments[0]);
    }
};

function ViewModel() {
    this.profile = ko.observable('customer');
}

},{"../components/Activity":64,"knockout":false}],25:[function(require,module,exports){
/**
    Login activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function LoginActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Anonymous;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Log in');
    this.navBar.rightAction(null);
    
    // Perform log-in request when is requested by the form:
    this.registerHandler({
        target: this.viewModel.isLogingIn,
        handler: function(v) {
            if (v === true) {

                // Perform loging

                // Notify state:
                var $btn = this.$activity.find('[type="submit"]');
                $btn.button('loading');

                // Clear previous error so makes clear we
                // are attempting
                this.viewModel.loginError('');

                var ended = function ended() {
                    this.viewModel.isLogingIn(false);
                    $btn.button('reset');
                }.bind(this);

                // After clean-up error (to force some view updates),
                // validate and abort on error
                // Manually checking error on each field
                if (this.viewModel.username.error() ||
                    this.viewModel.password.error()) {
                    this.viewModel.loginError('Review your data');
                    ended();
                    return;
                }

                this.app.model.login(
                    this.viewModel.username(),
                    this.viewModel.password()
                ).then(function(/*loginData*/) {

                    this.viewModel.loginError('');
                    ended();

                    // Remove form data
                    this.viewModel.username('');
                    this.viewModel.password('');

                    this.app.goDashboard();

                }.bind(this)).catch(function(err) {

                    var msg = err && err.responseJSON && err.responseJSON.errorMessage ||
                        err && err.statusText ||
                        'Invalid username or password';

                    this.viewModel.loginError(msg);
                    ended();
                }.bind(this));
            }
        }.bind(this)
    });
    
    // Focus first bad field on error
    this.registerHandler({
        target: this.viewModel.loginError,
        handler: function(err) {
            // Login is easy since we mark both unique fields
            // as error on loginError (its a general form error)
            var input = this.$activity.find(':input').get(0);
            if (err)
                input.focus();
            else
                input.blur();
        }.bind(this)
    });
});

exports.init = A.init;

var FormCredentials = require('../viewmodels/FormCredentials');

function ViewModel() {

    var credentials = new FormCredentials();    
    this.username = credentials.username;
    this.password = credentials.password;

    this.loginError = ko.observable('');
    
    this.isLogingIn = ko.observable(false);
    
    this.performLogin = function performLogin() {

        this.isLogingIn(true);        
    }.bind(this);
}

},{"../components/Activity":64,"../viewmodels/FormCredentials":140,"knockout":false}],26:[function(require,module,exports){
/**
    Logout activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function LogoutActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    this.app.model.logout().then(function() {
        // Anonymous user again
        var newAnon = this.app.model.user().constructor.newAnonymous();
        this.app.model.user().model.updateWith(newAnon);

        // Go index
        this.app.shell.go('/');
        
    }.bind(this));
};

},{"../components/Activity":64}],27:[function(require,module,exports){
/**
    OwnerInfo activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function OwnerInfoActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Account', {
        backLink: 'account'
    });
});

exports.init = A.init;

},{"../components/Activity":64}],28:[function(require,module,exports){
/**
    PrivacySettings activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function PrivacySettingsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.LoggedUser;

    this.navBar = Activity.createSubsectionNavBar('Account', {
        backLink: 'account'
    });
    
    this.registerHandler({
        target: this.app.model.privacySettings,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving privacy settings.' : 'Error loading privacy settings.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
        // Keep data updated:
    this.app.model.privacySettings.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var privacySettings = app.model.privacySettings;

    var settingsVersion = privacySettings.newVersion();
    settingsVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            settingsVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.settings = settingsVersion.version;

    this.isLocked = privacySettings.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, privacySettings);
    
    this.discard = function discard() {
        settingsVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        settingsVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    }.bind(this);
}

},{"../components/Activity":64,"knockout":false}],29:[function(require,module,exports){
/**
    Scheduling activity
**/
'use strict';

var Activity = require('../components/Activity'),
    UserJobProfileViewModel = require('../viewmodels/UserJobProfile');

var A = Activity.extends(function SchedulingActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new UserJobProfileViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Scheduling');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    this.viewModel.sync();
};

},{"../components/Activity":64,"../viewmodels/UserJobProfile":145}],30:[function(require,module,exports){
/**
    SchedulingPreferences activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');
var moment = require('moment');

var A = Activity.extends(function SchedulingPreferencesActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    
    this.registerHandler({
        target: this.app.model.schedulingPreferences,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving scheduling preferences.' : 'Error loading scheduling preferences.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.schedulingPreferences.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var schedulingPreferences = app.model.schedulingPreferences;

    var prefsVersion = schedulingPreferences.newVersion();
    prefsVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            prefsVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.prefs = prefsVersion.version;

    this.isLocked = schedulingPreferences.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, schedulingPreferences);
    
    this.discard = function discard() {
        prefsVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        prefsVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    }.bind(this);
    
    this.incrementsExample = ko.pureComputed(function() {
        
        var str = 'e.g. ',
            incSize = this.incrementsSizeInMinutes(),
            m = moment({ hour: 10, minute: 0 }),
            hours = [m.format('HH:mm')];
        
        for (var i = 1; i < 4; i++) {
            hours.push(
                m.add(incSize, 'minutes')
                .format('HH:mm')
            );
        }
        str += hours.join(', ');
        
        return str;
        
    }, this.prefs);
}

},{"../components/Activity":64,"knockout":false,"moment":false}],31:[function(require,module,exports){
/**
    Service Addresses activity
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    Activity = require('../components/Activity');

var A = Activity.extends(function ServiceAddressesActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Freelancer;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Job Title', {
        backLink: '/scheduling'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject();

    // On changing jobTitleID:
    // - load addresses
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID
                this.app.model.jobTitles.getJobTitle(jobTitleID)
                .then(function(jobTitle) {
                    // Save for use in the view
                    this.viewModel.jobTitle(jobTitle);
                    // Update navbar (may indicate the jobTitle name)
                    this.updateNavBarState();
                    
                    // Get addresses
                    return this.app.model.serviceAddresses.getList(jobTitleID);
                }.bind(this))
                .then(function(list) {

                    list = this.app.model.serviceAddresses.asModel(list);
                    this.viewModel.sourceAddresses(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.sourceAddresses([]);
                this.viewModel.jobTitle(null);
                this.updateNavBarState();
            }
        }.bind(this)
    });
    
    // Go back with the selected address when triggered in the form/view
    this.viewModel.returnSelected = function(addressID, jobTitleID) {
        // Pass the selected client in the info
        this.requestData.selectedAddressID = addressID;
        this.requestData.selectedJobTitleID = jobTitleID;
        // And go back
        this.app.shell.goBack(this.requestData);
    }.bind(this);
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    //jshint maxcomplexity:10

    var itIs = this.viewModel.isSelectionMode();
    
    this.viewModel.headerText(itIs ? 'Select or add a service location' : 'Locations');

    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {

        if (this.requestData.title) {
            // Replace title by title if required
            this.navBar.title(this.requestData.title);
        }
        else {
            // Title must be empty
            this.navBar.title('');
        }

        if (this.requestData.cancelLink) {
            this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink);
        }
        else {
            // Reset to defaults, or given title:
            this.navBar.leftAction().model.updateWith(this.defaultLeftAction);
            if (this.requestData.navTitle)
                this.navBar.leftAction().text(this.requestData.navTitle);

            var jid = this.viewModel.jobTitleID(),
                jname = this.viewModel.jobTitle() && this.viewModel.jobTitle().singularName() || 'Scheduling';

            this.navBar.leftAction().link(jid ? '/jobtitles/' + jid : '/scheduling');
            this.navBar.leftAction().text(jname);
        }

        if (itIs && !this.requestData.cancelLink) {
            // Uses a custom handler so it returns keeping the given state:
            this.navBar.leftAction().handler(this.returnRequest);
        }
        else if (!this.requestData.cancelLink) {
            this.navBar.leftAction().handler(null);
        }
    }
};

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);
    this.viewModel.requestData = this.requestData;

    this.viewModel.isSelectionMode(options.selectAddress === true);
    this.viewModel.clientID(options.clientID || null);

    var params = options && options.route && options.route.segments;
    var jobTitleID = params[0] |0;
    
    // Check if it comes from an addressEditor that
    // received the flag 'returnNewAsSelected' and an
    // addressID: we were in selection mode->creating address->must
    // return the just created address to the previous page
    if (options.returnNewAsSelected === true &&
        options.addressID) {
        
        setTimeout(function() {
            delete options.returnNewAsSelected;
            this.viewModel.returnSelected(options.addressID, jobTitleID);
        }.bind(this), 1);
        // quick return
        return;
    }

    this.viewModel.jobTitleID(jobTitleID);

    this.updateNavBarState();
    
    if (jobTitleID === 0) {
        this.viewModel.jobTitles.sync();
    }
};

var UserJobProfile = require('../viewmodels/UserJobProfile');

function ViewModel(app) {

    this.headerText = ko.observable('Locations');
    
    this.jobTitleID = ko.observable(0);
    this.jobTitle = ko.observable(null);
    // Especial mode when instead of pick and edit we are just selecting
    // (when editing an appointment)
    this.isSelectionMode = ko.observable(false);
    // Optionally, some times a clientID can be passed in order to create
    // a location for that client where perform a work.
    this.clientID = ko.observable(null);
    
    this.jobTitles = new UserJobProfile(app);
    this.jobTitles.baseUrl('/serviceAddress');
    this.jobTitles.selectJobTitle = function(jobTitle) {
        
        this.jobTitleID(jobTitle.jobTitleID());
        
        return false;
    }.bind(this);

    // List of addresses
    this.sourceAddresses = ko.observableArray([]);
    this.addresses = ko.computed(function() {
        var list = this.sourceAddresses();
        if (this.isSelectionMode()) {
            // Filter by service addresses (excluding service area)
            list = list.filter(function(add) {
                return add.isServiceLocation();
            });
        }
        return list;
    }, this);
    
    this.isSyncing = app.model.serviceAddresses.state.isSyncing();
    this.isLoading = ko.computed(function() {
        var add = app.model.serviceAddresses.state.isLoading(),
            jobs = this.jobTitles.isLoading();
        return add || jobs;
    }, this);
    
    this.goNext = function() {
        if (app.model.onboarding.inProgress()) {
            app.model.onboarding.goNext();
        }
    };

    this.selectAddress = function(selectedAddress, event) {
        if (this.isSelectionMode() === true) {
            // Run method injected by the activity to return a 
            // selected address:
            this.returnSelected(
                selectedAddress.addressID(),
                selectedAddress.jobTitleID()
            );
        }
        else {
            app.shell.go('addressEditor/service/' +
                this.jobTitleID() +
                '/' + selectedAddress.addressID()
            );
        }
        
        event.preventDefault();
        event.stopImmediatePropagation();

    }.bind(this);
    
    this.addServiceLocation = function() {
        var url = '#!addressEditor/service/' + this.jobTitleID() + '/serviceLocation';
        var request = $.extend({}, this.requestData, {
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go(url, request);
    }.bind(this);
    
    this.addServiceArea = function() {
        var url = '#!addressEditor/service/' + this.jobTitleID() + '/serviceArea';
        var request = $.extend({}, this.requestData, {
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go(url, request);
    }.bind(this);
    
    this.addClientLocation = function() {
        var url = '#!addressEditor/service/' + this.jobTitleID() + '/clientLocation/' + this.clientID();
        var request = $.extend({}, this.requestData, {
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go(url, request);
    }.bind(this);
    
    this.onboardingNextReady = ko.computed(function() {
        var isin = app.model.onboarding.inProgress(),
            hasItems = this.sourceAddresses().length > 0;

        return isin && hasItems;
    }, this);
}

},{"../components/Activity":64,"../viewmodels/UserJobProfile":145,"knockout":false}],32:[function(require,module,exports){
/**
    Signup activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function SignupActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.Anonymous;
    this.viewModel = new ViewModel(this.app);
    // null for Logo
    this.navBar = Activity.createSectionNavBar(null);
    this.navBar.rightAction(null);
    
    // Perform sign-up request when is requested by the form:
    this.registerHandler({
        target: this.viewModel.isSigningUp,
        handler: function(v) {
            if (v === true) {

                // Perform signup

                // Notify state:
                var $btn = this.$activity.find('[type="submit"]');
                $btn.button('loading');

                // Clear previous error so makes clear we
                // are attempting
                this.viewModel.signupError('');

                var ended = function ended() {
                    this.viewModel.isSigningUp(false);
                    $btn.button('reset');
                }.bind(this);

                // After clean-up error (to force some view updates),
                // validate and abort on error
                // Manually checking error on each field
                if (this.viewModel.username.error() ||
                    this.viewModel.password.error()) {
                    this.viewModel.signupError('Review your data');
                    ended();
                    return;
                }

                this.app.model.signup(
                    this.viewModel.username(),
                    this.viewModel.password(),
                    this.viewModel.profile()
                ).then(function(signupData) {

                    this.viewModel.signupError('');
                    ended();
                    
                    // Start onboarding
                    this.app.model.onboarding.setStep(signupData.onboardingStep);

                    // Remove form data
                    this.viewModel.username('');
                    this.viewModel.password('');

                    this.app.goDashboard();

                }.bind(this)).catch(function(err) {

                    var msg = err && err.responseJSON && err.responseJSON.errorMessage ||
                        err && err.statusText ||
                        'Invalid username or password';

                    this.viewModel.signupError(msg);
                    ended();
                }.bind(this));
            }
        }.bind(this)
    });
    
    // Focus first bad field on error
    this.registerHandler({
        target: this.viewModel.signupError,
        handler: function(err) {
            // Signup is easy since we mark both unique fields
            // as error on signupError (its a general form error)
            var input = this.$activity.find(':input').get(0);
            if (err)
                input.focus();
            else
                input.blur();
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    if (options && options.route &&
        options.route.segments &&
        options.route.segments.length) {
        this.viewModel.profile(options.route.segments[0]);
    }
};


var FormCredentials = require('../viewmodels/FormCredentials');

function ViewModel() {

    var credentials = new FormCredentials();    
    this.username = credentials.username;
    this.password = credentials.password;

    this.signupError = ko.observable('');
    
    this.isSigningUp = ko.observable(false);
    
    this.performSignup = function performSignup() {

        this.isSigningUp(true);
    }.bind(this);

    this.profile = ko.observable('customer');
}

},{"../components/Activity":64,"../viewmodels/FormCredentials":140,"knockout":false}],33:[function(require,module,exports){
/**
    textEditor activity
**/
//global window
'use strict';

var ko = require('knockout'),
    EventEmitter = require('events').EventEmitter,
    Activity = require('../components/Activity');

var A = Activity.extends(function TextEditorActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    this.viewModel = new ViewModel(this.app);
    // Title is empty, since we are in 'go back' mode all the time here
    this.navBar = Activity.createSubsectionNavBar('');
    this.navBar.leftAction().handler(function() {
        this.emit('cancel');
    }.bind(this.viewModel));
    
    // Getting elements
    this.$textarea = this.$activity.find('textarea');
    this.textarea = this.$textarea.get(0);
    
    // Handler for the 'saved' event so the activity
    // returns back to the requester activity giving it
    // the new text
    this.registerHandler({
        target: this.viewModel,
        event: 'saved',
        handler: function() {
            // Update the info with the new text
            this.requestData.text = this.viewModel.text();
            // and pass it back
            this.app.shell.goBack(this.requestData);
        }.bind(this)
    });
    
    // Handler the cancel event
    this.registerHandler({
        target: this.viewModel,
        event: 'cancel',
        handler: function() {
            // return, nothing changed
            this.app.shell.goBack(this.requestData);
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Set navigation title or nothing
    this.navBar.leftAction().text(this.requestData.navTitle || '');
    
    // Field header
    this.viewModel.headerText(this.requestData.header);
    this.viewModel.text(this.requestData.text);
        
    // Inmediate focus to the textarea for better usability
    this.textarea.focus();
    this.$textarea.click();
    // IMPORTANT: WORKAROUND: for iOS: on iOS (checked up to 8.3, 2015-05-20), the opening of the virtual keyboard
    // makes a scroll down of the viewport, hiding the text field, header, anything, and only the
    // blank area gets showed. That bad autoscroll can be fixed on this single case with next trick
    // without flickering or bad effects (and alternative, generic approach is do it on the keyboardShow
    // event, but there a flickering happens and may affect cases where there is no need or can be worse
    // if field visibility and actual scroll is not checked):
    window.scrollTo(0, 0);
};

function ViewModel() {

    this.headerText = ko.observable('Text');

    // Text to edit
    this.text = ko.observable('');

    this.cancel = function cancel() {
        this.emit('cancel');
    };
    
    this.save = function save() {
        this.emit('saved');
    };
}

ViewModel._inherits(EventEmitter);

},{"../components/Activity":64,"events":false,"knockout":false}],34:[function(require,module,exports){
/**
    WeeklySchedule activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function WeeklyScheduleActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.Freelancer;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    this.defaultNavBar = this.navBar.model.toPlainObject();
    
    this.registerHandler({
        target: this.app.model.simplifiedWeeklySchedule,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving your weekly schedule.' : 'Error loading your weekly schedule.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    
    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {
        // Reset
        this.navBar.model.updateWith(this.defaultNavBar);
    }
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    this.updateNavBarState();
    
    // Keep data updated:
    this.app.model.simplifiedWeeklySchedule.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var simplifiedWeeklySchedule = app.model.simplifiedWeeklySchedule;

    var scheduleVersion = simplifiedWeeklySchedule.newVersion();
    scheduleVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            scheduleVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.schedule = scheduleVersion.version;

    this.isLocked = simplifiedWeeklySchedule.isLocked;
    this.isSaving = simplifiedWeeklySchedule.isSaving;

    this.submitText = ko.pureComputed(function() {
        return (
            app.model.onboarding.inProgress() ?
                'Save and continue' :
                this.isLoading() ? 
                    'loading...' : 
                    this.isSaving() ? 
                        'saving...' : 
                        'Save'
        );
    }, simplifiedWeeklySchedule);
    
    this.discard = function discard() {
        scheduleVersion.pull({ evenIfNewer: true });
    };

    this.save = function save() {
        scheduleVersion.pushSave()
        .then(function() {
            if (app.model.onboarding.inProgress()) {
                app.model.onboarding.goNext();
            } else {
                app.successSave();
            }
        })
        .catch(function() {
            // catch error, managed on event
        });
    };
}

},{"../components/Activity":64,"knockout":false}],35:[function(require,module,exports){
/**
    Welcome activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function WelcomeActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.LoggedUser;
    
    var app = this.app;
    
    this.viewModel = {
        startOnboarding: function startOnboarding() {
            app.model.onboarding.goNext();
        }
    };
    
    this.navBar = new Activity.NavBar({
        title: null,
        leftAction: Activity.NavAction.goLogout,
        rightAction: null
    });
});

exports.init = A.init;

},{"../components/Activity":64}],36:[function(require,module,exports){
/**
    Registration of custom html components used by the App.
    All with 'app-' as prefix.
    
    Some definitions may be included on-line rather than on separated
    files (viewmodels), templates are linked so need to be 
    included in the html file with the same ID that referenced here,
    usually using as DOM ID the same name as the component with sufix '-template'.
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    propTools = require('./utils/jsPropertiesTools'),
    getObservable = require('./utils/getObservable');

exports.registerAll = function() {
    
    /// navbar-action
    ko.components.register('app-navbar-action', {
        template: { element: 'navbar-action-template' },
        viewModel: function(params) {

            propTools.defineGetter(this, 'action', function() {
                return (
                    params.action && params.navBar() ?
                    params.navBar()[params.action]() :
                    null
                );
            });
        }
    });
    
    /// unlabeled-input
    ko.components.register('app-unlabeled-input', {
        template: { element: 'unlabeled-input-template' },
        viewModel: function(params) {

            this.value = getObservable(params.value);
            this.placeholder = getObservable(params.placeholder);
            this.disable = getObservable(params.disable);
            
            var userAttr = getObservable(params.attr);
            this.attr = ko.pureComputed(function() {
                var attr = userAttr() || {};
                return $.extend({}, attr, {
                    'aria-label': this.placeholder(),
                    placeholder: this.placeholder(),
                    type: this.type()
                });
            }, this);
            
            var type = getObservable(params.type);            
            this.type = ko.computed(function() {
                return type() || 'text';
            }, this);
        }
    });
    
    /// feedback-entry
    ko.components.register('app-feedback-entry', {
        template: { element: 'feedback-entry-template' },
        viewModel: function(params) {

            this.section = getObservable(params.section || '');
            this.url = ko.pureComputed(function() {
                return '/feedbackForm/' + this.section();
            }, this);
        }
    });
    
    /// feedback-entry
    ko.components.register('app-time-slot-tile', {
        template: { element: 'time-slot-tile-template' },
        viewModel: require('./viewmodels/TimeSlot')
    });
    
    /// loading-spinner
    ko.components.register('app-loading-spinner', {
        template: { element: 'loading-spinner-template' },
        viewModel: function(params) {
            var base = 'loadingSpinner';
            this.mod = getObservable(params.mod || '');
            this.cssClass = ko.pureComputed(function() {
                var c = base,
                    mods = (this.mod() || '').split(' ');
                if (mods.length)
                    c += ' ' + base + '--' + mods.join(' ' + base + '--');
                return c;
            }, this);
        }
    });

    /// appointment-card
    ko.components.register('app-appointment-card', {
        template: { element: 'appointment-card-template' },
        viewModel: require('./viewmodels/AppointmentCard')
    });
    
    /// job titles list
    ko.components.register('app-job-titles-list', {
        template: { element: 'job-titles-list-template' },
        viewModel: function(params) {
            this.jobTitles = getObservable(params.jobTitles || []);
            this.selectJobTitle = params.selectJobTitle || function() {};
        }
    });
};

},{"./utils/getObservable":122,"./utils/jsPropertiesTools":125,"./viewmodels/AppointmentCard":138,"./viewmodels/TimeSlot":144,"knockout":false}],37:[function(require,module,exports){
/**
    Navbar extension of the App,
    adds the elements to manage a view model
    for the NavBar and automatic changes
    under some model changes like user login/logout
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    NavBar = require('./viewmodels/NavBar'),
    NavAction = require('./viewmodels/NavAction');

exports.extends = function (app) {
    
    // REVIEW: still needed? Maybe the per activity navBar means
    // this is not needed. Some previous logic was already removed
    // because was useless.
    //
    // Adjust the navbar setup depending on current user,
    // since different things are need for logged-in/out.
    function adjustUserBar() {

        var user = app.model.user();

        if (user.isAnonymous()) {
            app.navBar().leftAction(NavAction.menuOut);
        }
    }
    // Commented lines, used previously but unused now, it must be enough with the update
    // per activity change
    //app.model.user().isAnonymous.subscribe(updateStatesOnUserChange);
    //app.model.user().onboardingStep.subscribe(updateStatesOnUserChange);
    
    app.navBar = ko.observable(null);
    
    var refreshNav = function refreshNav() {
        // Trigger event to force a component update
        $('.AppNav').trigger('contentChange');
    };
    var autoRefreshNav = function autoRefreshNav(action) {
        if (action) {
            action.text.subscribe(refreshNav);
            action.isTitle.subscribe(refreshNav);
            action.icon.subscribe(refreshNav);
            action.isMenu.subscribe(refreshNav);
        }
    };

    /**
        Update the nav model using the Activity defaults
    **/
    app.updateAppNav = function updateAppNav(activity, state) {

        // if the activity has its own
        if ('navBar' in activity) {
            // Use specializied activity bar data
            app.navBar(activity.navBar);
        }
        else {
            // Use default one
            app.navBar(new NavBar());
        }
        
        if (state && state.route && state.route.query &&
            state.route.query.mustReturn) {
            // Left action forced to be a go-back
            app.navBar().leftAction(NavAction.goBack);
        }

        // TODO Double check if needed.
        // Latest changes, when needed
        adjustUserBar();
        
        refreshNav();
        autoRefreshNav(app.navBar().leftAction());
        autoRefreshNav(app.navBar().rightAction());
    };
    
    
    /**
        Update the app menu to highlight the
        given link name
    **/
    app.updateMenu = function updateMenu(name) {
        
        var $menu = $('.App-menus .navbar-collapse');
        
        // Remove any active
        $menu
        .find('li')
        .removeClass('active');
        // Add active
        $menu
        .find('.go-' + name)
        .closest('li')
        .addClass('active');
        // Hide menu
        $menu
        .filter(':visible')
        .collapse('hide');
    };
    
    app.setupNavBarBinding = function setupNavBarBinding() {
        var siteUrl = $('html').attr('data-site-url');
        // Set model for the AppNav
        app.navBarBinding = {
            navBar: app.navBar,
            // URL, keep updated with any site change
            photoUrl: ko.observable(siteUrl + '/en-US/Profile/Photo/'),
            // It's later filled with a call to the model once loaded and ready
            userName: ko.observable('Me')
        };
        ko.applyBindings(app.navBarBinding, $('.AppNav').get(0));
    };
    
    /**
        Performs the 'back' task from the navbar link, if any.
        That is, trigger the left action.
        Fallback to shell goBack
    **/
    app.performsNavBarBack = function performsNavBarBack(options) {
        var nav = this.navBar(),
            left = nav && nav.leftAction(),
            $btn = $('.SmartNavBar-edge.left > a.SmartNavBar-btn');

        // There is an action, trigger like a click so all the handlers
        // attached on spare places do their work:
        if (left && !left.isMenu()) {
            var event = $.Event('click');
            event.options = options || {};
            $btn.trigger(event);
        }
        else if (this.shell) {
            this.shell.goBack();
        }
    };
    
    /**
        It shows an unobtrusive notification on the navbar place, that
        hides after a short timeout
    **/
    var lastNotificationTimer = null;
    app.showNavBarNotification = function showNavBarNotification(settings) {
        var msg = settings && settings.message || 'Hello World!',
            duration = settings && settings.duration || 2000,
            transitionDuration = settings && settings.transitionDuration || 400,
            $el = $('.AppNav .SmartNavBar-notification');

        $el.text(msg);
        $el.fadeIn(transitionDuration)
        .queue(function() {
            
            // Manual hide on clicking
            $el
            .off('click.manualHide')
            .on('click.manualHide', function() {
                $el.fadeOut(transitionDuration);
            });
            
            // Auto hide after timeout
            clearTimeout(lastNotificationTimer);
            lastNotificationTimer = setTimeout(function() {
                $el.fadeOut(transitionDuration);
            }, duration);
            
            $(this).dequeue();
        });
    };
};

},{"./viewmodels/NavAction":141,"./viewmodels/NavBar":142,"knockout":false}],38:[function(require,module,exports){
/**
    List of activities loaded in the App,
    as an object with the activity name as the key
    and the controller as value.
**/
'use strict';

var Activity = require('./components/Activity');
var EmptyActivity = Activity.extends(function EmptyActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = {};
    this.navBar = Activity.createSectionNavBar();
});

module.exports = {
    '_test': EmptyActivity,
    'calendar': require('./activities/calendar'),
    'datetimePicker': require('./activities/datetimePicker'),
    'clients': require('./activities/clients'),
    'freelancerPricing': require('./activities/freelancerPricing'),
    'serviceAddresses': require('./activities/serviceAddresses'),
    'textEditor': require('./activities/textEditor'),
    'home': require('./activities/home'),
    'appointment': require('./activities/appointment'),
    'index': require('./activities/index'),
    'login': require('./activities/login'),
    'logout': require('./activities/logout'),
    'learnMore': require('./activities/learnMore'),
    'signup': require('./activities/signup'),
    'contactInfo': require('./activities/contactInfo'),
    'welcome': require('./activities/welcome'),
    'addressEditor': require('./activities/addressEditor'),
    'account': require('./activities/account'),
    'inbox': require('./activities/inbox'),
    'conversation': require('./activities/conversation'),
    'scheduling': require('./activities/scheduling'),
    'jobtitles': require('./activities/jobtitles'),
    'feedback': require('./activities/feedback'),
    'faqs': require('./activities/faqs'),
    'feedbackForm': require('./activities/feedbackForm'),
    'contactForm': require('./activities/contactForm'),
    'cms': require('./activities/cms'),
    'clientEditor': require('./activities/clientEditor'),
    'schedulingPreferences': require('./activities/schedulingPreferences'),
    'calendarSyncing': require('./activities/calendarSyncing'),
    'weeklySchedule': require('./activities/weeklySchedule'),
    'bookMeButton': require('./activities/bookMeButton'),
    'ownerInfo': require('./activities/ownerInfo'),
    'privacySettings': require('./activities/privacySettings'),
    'addJobTitles': require('./activities/addJobTitles'),
    'freelancerPricingEditor': require('./activities/freelancerPricingEditor')
};

},{"./activities/account":1,"./activities/addJobTitles":2,"./activities/addressEditor":3,"./activities/appointment":4,"./activities/bookMeButton":5,"./activities/calendar":6,"./activities/calendarSyncing":7,"./activities/clientEditor":8,"./activities/clients":9,"./activities/cms":10,"./activities/contactForm":11,"./activities/contactInfo":12,"./activities/conversation":13,"./activities/datetimePicker":14,"./activities/faqs":15,"./activities/feedback":16,"./activities/feedbackForm":17,"./activities/freelancerPricing":18,"./activities/freelancerPricingEditor":19,"./activities/home":20,"./activities/inbox":21,"./activities/index":22,"./activities/jobtitles":23,"./activities/learnMore":24,"./activities/login":25,"./activities/logout":26,"./activities/ownerInfo":27,"./activities/privacySettings":28,"./activities/scheduling":29,"./activities/schedulingPreferences":30,"./activities/serviceAddresses":31,"./activities/signup":32,"./activities/textEditor":33,"./activities/weeklySchedule":34,"./activities/welcome":35,"./components/Activity":64}],39:[function(require,module,exports){
'use strict';

/** Global dependencies **/
var $ = require('jquery');
require('jquery-mobile');
require('./utils/jquery.multiline');
var ko = require('knockout');
ko.bindingHandlers.format = require('ko/formatBinding').formatBinding;
var bootknock = require('./utils/bootknockBindingHelpers');
require('./utils/Function.prototype._inherits');
require('./utils/Function.prototype._delayed');
// Polyfill for useful non-standard feature Function.name for IE9+
// (feature used to simplify creation of Activities and Models)
require('./utils/Function.prototype.name-polyfill');
// Promise polyfill, so its not 'require'd per module:
require('es6-promise').polyfill();

var layoutUpdateEvent = require('layoutUpdateEvent');
var AppModel = require('./appmodel/AppModel');

// Register the special locale
require('./locales/en-US-LC');

var attachFastClick = require('fastclick').attach;

/**
    A set of fixes/workarounds for Bootstrap behavior/plugins
    to be executed before Bootstrap is included/executed.
    For example, because of data-binding removing/creating elements,
    some old references to removed items may get alive and need update,
    or re-enabling some behaviors.
**/
function preBootstrapWorkarounds() {
    // Internal Bootstrap source utility
    function getTargetFromTrigger($trigger) {
        var href,
            target = $trigger.attr('data-target') ||
            (href = $trigger.attr('href')) && 
            href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

        return $(target);
    }
    
    // Bug: navbar-collapse elements hold a reference to their original
    // $trigger, but that trigger can change on different 'clicks' or
    // get removed the original, so it must reference the new one
    // (the latests clicked, and not the cached one under the 'data' API).    
    // NOTE: handler must execute before the Bootstrap handler for the same
    // event in order to work.
    $(document).on('click.bs.collapse.data-api.workaround', '[data-toggle="collapse"]', function() {
        var $t = $(this),
            $target = getTargetFromTrigger($t),
            data = $target && $target.data('bs.collapse');
        
        // If any
        if (data) {
            // Replace the trigger in the data reference:
            data.$trigger = $t;
        }
        // On else, nothing to do, a new Collapse instance will be created
        // with the correct target, the first time
    });
}

/**
    App static class
**/
var app = {
    shell: require('./app.shell'),
    
    // New app model, that starts with anonymous user
    model: new AppModel(),
    
    /** Load activities controllers (not initialized) **/
    activities: require('./app.activities'),
    
    modals: require('./app.modals'),
    
    /**
        Just redirect the better place for current user and state.
        NOTE: Its a delayed function, since on many contexts need to
        wait for the current 'routing' from end before do the new
        history change.
        TODO: Maybe, rather than delay it, can stop current routing
        (changes on Shell required) and perform the new.
        TODO: Maybe alternative to previous, to provide a 'replace'
        in shell rather than a go, to avoid append redirect entries
        in the history, that create the problem of 'broken back button'
    **/
    goDashboard: function goDashboard() {
        
        // To avoid infinite loops if we already are performing 
        // a goDashboard task, we flag the execution
        // being care of the delay introduced in the execution
        if (goDashboard._going === true) {
            return;
        }
        else {
            // Delayed to avoid collisions with in-the-middle
            // tasks: just allowing current routing to finish
            // before perform the 'redirect'
            // TODO: change by a real redirect that is able to
            // cancel the current app.shell routing process.
            setTimeout(function() {
        
                goDashboard._going = true;

                var onboarding = this.model.onboarding.stepUrl();

                if (onboarding) {
                    this.shell.go(onboarding);
                }
                else {
                    this.shell.go('home');
                }

                // Just because is delayed, needs
                // to be set off after an inmediate to 
                // ensure is set off after any other attempt
                // to add a delayed goDashboard:
                setTimeout(function() {
                    goDashboard._going = false;
                }, 1);
            }.bind(this), 1);
        }
    }
};

/** Continue app creation with things that need a reference to the app **/

require('./app-navbar').extends(app);

require('./app-components').registerAll();

app.getActivity = function getActivity(name) {
    var activity = this.activities[name];
    if (activity) {
        var $act = this.shell.items.find(name);
        if ($act && $act.length)
            return activity.init($act, this);
    }
    return null;
};

app.getActivityControllerByRoute = function getActivityControllerByRoute(route) {
    // From the route object, the important piece is route.name
    // that contains the activity name except if is the root
    var actName = route.name || this.shell.indexName;
    
    return this.getActivity(actName);
};

// accessControl setup: cannot be specified on Shell creation because
// depends on the app instance
app.shell.accessControl = require('./utils/accessControl')(app);

// Shortcut to UserType enumeration used to set permissions
app.UserType = require('./models/User').UserType;

// New method for common forms behavior after a successful save operation,
// the activity goes back (following the navbar back-link or shell.goBack())
// and notifying with a temporary unobtrusive navbar notification
app.successSave = function successSave(settings) {
    // defaults
    settings = $.extend({
        message: 'Your changes have been saved',
        link: null
    }, settings);
    
    // show notification
    this.showNavBarNotification(settings);
    
    // requested link or current activity go back
    if (settings.link)
        this.shell.go(settings.link);
    else
        this.performsNavBarBack({ silentMode: true });
};

/** App Init **/
var appInit = function appInit() {
    /*jshint maxstatements:50,maxcomplexity:16 */
    
    attachFastClick(document.body);
    
    // Enabling the 'layoutUpdate' jQuery Window event that happens on resize and transitionend,
    // and can be triggered manually by any script to notify changes on layout that
    // may require adjustments on other scripts that listen to it.
    // The event is throttle, guaranting that the minor handlers are executed rather
    // than a lot of them in short time frames (as happen with 'resize' events).
    layoutUpdateEvent.layoutUpdateEvent += ' orientationchange';
    layoutUpdateEvent.on();
    
    // Keyboard plugin events are not compatible with jQuery events, but needed to
    // trigger a layoutUpdate, so here are connected, mainly fixing bugs on iOS when the keyboard
    // is hidding.
    var trigLayout = function trigLayout() {
        $(window).trigger('layoutUpdate');
    };
    window.addEventListener('native.keyboardshow', trigLayout);
    window.addEventListener('native.keyboardhide', trigLayout);

    // iOS-7+ status bar fix. Apply on plugin loaded (cordova/phonegap environment)
    // and in any system, so any other systems fix its solved too if needed 
    // just updating the plugin (future proof) and ensure homogeneous cross plaftform behavior.
    if (window.StatusBar) {
        // Fix iOS-7+ overlay problem
        // Is in config.xml too, but seems not to work without next call:
        window.StatusBar.overlaysWebView(false);
    }
    
    // Force an update delayed to ensure update after some things did additional work
    setTimeout(function() {
        $(window).trigger('layoutUpdate');
    }, 200);
    
    // Bootstrap
    preBootstrapWorkarounds();
    require('bootstrap');
    
    // Load Knockout binding helpers
    bootknock.plugIn(ko);
    require('./utils/bootstrapSwitchBinding').plugIn(ko);
    
    // Plugins setup
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
        // Explicitely, we WANT auto scroll on keyboard show up.
        // Can be disabled only if there is a javascript solution to autoscroll
        // on input focus, else a bug will happen specially on iOS where input
        // fields gets hidden by the on screen keyboard.
        window.cordova.plugins.Keyboard.disableScroll(false);
    }
    
    // Easy links to shell actions, like goBack, in html elements
    // Example: <button data-shell="goBack 2">Go 2 times back</button>
    // NOTE: Important, registered before the shell.run to be executed
    // before its 'catch all links' handler
    $(document).on('click', '[data-shell]', function(e) {
        // Using attr rather than the 'data' API to get updated
        // DOM values
        var cmdline = $(this).attr('data-shell') || '',
            args = cmdline.split(' '),
            cmd = args[0];

        if (cmd && typeof(app.shell[cmd]) === 'function') {
            app.shell[cmd].apply(app.shell, args.slice(1));
            
            // Cancel any other action on the link, to avoid double linking results
            e.stopImmediatePropagation();
            e.preventDefault();
        }
    });
    
    // On Cordova/Phonegap app, special targets must be called using the window.open
    // API to ensure is correctly opened on the InAppBrowser (_blank) or system default
    // browser (_system).
    if (window.cordova) {
        $(document).on('click', '[target="_blank"], [target="_system"]', function(e) {
            window.open(this.getAttribute('href'), this.getAttribute('target'));
            e.preventDefault();
        });
    }
    
    // When an activity is ready in the Shell:
    app.shell.on(app.shell.events.itemReady, function($act, state) {
        
        // Must be the same:
        var routeName = app.shell.currentRoute.name;
        var actName = $act.data('activity');
        // If not, some race condition, not the same page go out
        if (routeName !== actName)
            return;

        // Connect the 'activities' controllers to their views
        var activity = app.getActivity(actName);
        // Trigger the 'show' logic of the activity controller:
        activity.show(state);
        
        // The show logic may do a redirect, loading other activity, double check
        routeName = app.shell.currentRoute.name;
        if (routeName !== actName)
            return;

        // Update menu
        var menuItem = activity.menuItem || actName;
        app.updateMenu(menuItem);

        // Update app navigation
        app.updateAppNav(activity, state);
    });
    // When an activity is hidden
    app.shell.on(app.shell.events.closed, function($act) {
        
        // Connect the 'activities' controllers to their views
        var actName = $act.data('activity');
        var activity = app.getActivity(actName);
        // Trigger the 'hide' logic of the activity controller:
        if (activity.hide)
            activity.hide();
    });
    // Catch errors on item/page loading, showing..
    app.shell.on('error', function(err) {
        app.modals.showError({ error: err });
    });
    
    // Scroll to element when clicking a usual fragment link (not a page link)
    var scrollToElement = require('./utils/scrollToElement');
    app.shell.on('fragmentNavigation', function(href) {
        // Check link, avoiding empty links
        // (href comes with the initial hash ever, so empty is just '#')
        if (href === '#') {
            // Notify for debugging, because this may be unwanted
            console.warn(
                'Navigation to an empty fragment, this may be not wanted. ' +
                'For root links, use "/"; on script handled links, call event.preventDefault; ' +
                'A touch event was listened on a link, but not the click event.'
            );
        }
        else {
            // Locate target
            var target = $(href);
            if (target.length) {
                // Smooth scrolling with animation
                scrollToElement(target, { animation: { duration: 300 } });
            }
        }
    });
    
    // Navbar binding
    app.setupNavBarBinding();
    
    var SmartNavBar = require('./components/SmartNavBar');
    var navBars = SmartNavBar.getAll();
    // Creates an event by listening to it, so other scripts can trigger
    // a 'contentChange' event to force a refresh of the navbar (to 
    // calculate and apply a new size); expected from dynamic navbars
    // that change it content based on observables.
    navBars.forEach(function(navbar) {
        $(navbar.el).on('contentChange', function() {
            navbar.refresh();
        });
    });
    
    // Listen for menu events (collapse in SmartNavBar)
    // to apply the backdrop; add another class, explicit for know the menu/nav is opened
    var togglingBackdrop = false;
    $(document).on('show.bs.collapse hide.bs.collapse', '.AppNav .navbar-collapse', function(e) {
        if (!togglingBackdrop) {
            togglingBackdrop = true;
            var enabled = e.type === 'show';
            $('body').toggleClass('use-backdrop', enabled);
            $('body').toggleClass('has-appNav-open', enabled);
            // Hide any other opened collapse
            $('.collapsing, .collapse.in').collapse('hide');
            togglingBackdrop = false;
        }
    });

    // Catch uncatch model errors
    app.model.on('error', function(err) {
        app.modals.showError({
            error: err
        });
    });
    
    // Additional form elements attribute and behavior: data-autoselect=true
    // sets to automatically select the text content of an input text control
    // when gets the focus
    $(document).on('focus', '[data-autoselect="true"]', function() {
        $(this).select();
    });
    
    // App init:
    var alertError = function(err) {
        app.modals.showError({
            title: 'There was an error loading',
            error: err
        });
    };

    app.model.init()
    .then(app.shell.run.bind(app.shell), alertError)
    .then(function() {
        // Mark the page as ready
        $('html').addClass('is-ready');
        // As app, hides splash screen
        if (window.navigator && window.navigator.splashscreen) {
            window.navigator.splashscreen.hide();
        }
        
        // Connect username in navbar
        ko.computed(function() {
            var n = app.model.userProfile.data.firstName();
            app.navBarBinding.userName(n || 'Me');
        });
        
        // Onboarding model needs initialization
        app.model.onboarding.init(app);

        // Check onboarding step to redirect there on app start
        var step = app.model.user().onboardingStep();
        if (step && 
            app.model.onboarding.setStep(step)) {
            var url = app.model.onboarding.stepUrl();
            app.shell.go(url);
        }

    }, alertError);

    // DEBUG
    window.app = app;
};

// App init on page ready and phonegap ready
if (window.cordova) {
    // On DOM-Ready first
    $(function() {
        // Page is ready, device is too?
        // Note: Cordova ensures to call the handler even if the
        // event was already fired, so is good to do it inside
        // the dom-ready and we are ensuring that everything is
        // ready.
        $(document).on('deviceready', appInit);
    });
} else {
    // Only on DOM-Ready, for in browser development
    $(appInit);
}

},{"./app-components":36,"./app-navbar":37,"./app.activities":38,"./app.modals":40,"./app.shell":41,"./appmodel/AppModel":52,"./components/SmartNavBar":66,"./locales/en-US-LC":67,"./models/User":97,"./utils/Function.prototype._delayed":103,"./utils/Function.prototype._inherits":104,"./utils/Function.prototype.name-polyfill":105,"./utils/accessControl":114,"./utils/bootknockBindingHelpers":116,"./utils/bootstrapSwitchBinding":117,"./utils/jquery.multiline":124,"./utils/scrollToElement":127,"es6-promise":false,"knockout":false}],40:[function(require,module,exports){
/**
    Access to use global App Modals
**/
'use strict';

var $ = require('jquery');

/**
    Generates a text message, with newlines if needed, describing the error
    object passed.
    @param err:any As a string, is returned 'as is'; as falsy, it return a generic
    message for 'unknow error'; as object, it investigate what type of error is to
    provide the more meaninful result, with fallback to JSON.stringify prefixed
    with 'Technical details:'.
    Objects recognized:
    - XHR/jQuery for JSON responses: just objects with responseJSON property, is
      used as the 'err' object and passed to the other object tests.
    - Object with 'errorMessage' (server-side formatted error).
    - Object with 'message' property, like the standard Error class and Exception objects.
    - Object with 'name' property, like the standard Exception objects. The name, if any,
      is set as prefix for the 'message' property value.
    - Object with 'errors' property. Each element in the array or object own keys
      is appended to the errorMessage or message separated by newline.
**/
exports.getErrorMessageFrom = function getErrorMessageFrom(err, defaultText) {
    /*jshint maxcomplexity:14, maxdepth:5*/

    defaultText = defaultText || 'Unknow error';
    
    if (!err) {
        return defaultText;
    }
    else if (typeof(err) === 'string') {
        return err || defaultText;
    }
    else {
        // If is a XHR object, use its response as the error.
        err = err.responseJSON || err;

        var msg = err.name && (err.name + ': ') || '';
        msg += err.errorMessage || err.message || '';

        if (err.errors) {
            msg += '\n' + exports.stringifyErrorsList(err.errors);
        }
        else {
            // Avoiding that en error converting the object (circular references)
            // breaks the error control!
            try {
                var jserr = JSON.stringify(err);
                // Avoiding that empty results (empty string or empty object when there
                // is no details to show) makes us to show an annoying 'technical details'
                var hasMoreInfo = jserr && jserr !== '{}';
                // Too if there is no more information than the one extracted to build the
                // message, since on that cases the 'technical details' will be just a 
                // json formatted of the same displayed message
                if (hasMoreInfo) {
                    // Reset initially, re-enabled only if there are more properties
                    // than the ones from the list
                    hasMoreInfo = false;
                    var messagePropertiesList = ['name', 'errorMessage', 'message', 'errors'];
                    Object.keys(err).forEach(function(key) {
                        if (messagePropertiesList.indexOf(key) === -1)
                            hasMoreInfo = true;
                    });
                }

                if (hasMoreInfo)
                    msg += '\n\nTechnical details: ' + jserr;
            }
            catch (ex) {
                console.log('Impossible to stringify JSON error', err, ex);
            }
        }

        return msg || defaultText;
    }
};

exports.stringifyErrorsList = function (errors) {
    var msg = '';
    if (Array.isArray(errors)) {
        msg = errors.join('\n');
    }
    else {
        msg = Object.keys(errors).map(function(key) {
            return errors[key].join('\n');
        }).join('\n');
    }
    return msg;
};

/**
    Show an error modal to notify the user.
    @param options:Object {
        message:string DEPRECATED. Optional. Informative error message.
        error:string Optional. Error/Exception/XHR object, used to auto
            generate the error message. It takes precedence over 'message'
            option, discarding an error object/string is passed.
            It replaces 'message' since can do the same and more.
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when the modal is dismissed/closed.
    No formal rejection happens.
**/
exports.showError = function showErrorModal(options) {
    
    var modal = $('#errorModal'),
        header = modal.find('#errorModal-label'),
        body = modal.find('#errorModal-body');
    
    options = options || {};
    
    // Fallback error message
    var msg = body.data('default-text');

    // Error message from given error object, with fallback to default one.
    // DEPRECATED temporarly using the 'message' option.
    msg = exports.getErrorMessageFrom(options.error || options.message, msg);

    body.multiline(msg);

    header.text(options.title || header.data('default-text'));
    
    return new Promise(function(resolve) {
        modal.modal('show');
        modal.on('hide.bs.modal', function() {
            resolve();
        });
    });
};

/**
    Show confirmation modal with two buttons.
    @param options:object {
        title:string Header title text
        message:string Message text
        yes:string Yes button label
        no:string No button label
    }
    @returns Promise. It resolves if button 'yes' pressed
    and reject on button 'no' pressed or modal dismissed/closed.
**/
exports.confirm = function confirm(options) {
    
    var modal = $('#confirmModal'),
        header = modal.find('#confirmModal-label'),
        body = modal.find('#confirmModal-body'),
        yesBtn = modal.find('#confirmModal-yesBtn'),
        noBtn = modal.find('#confirmModal-noBtn');

    options = options || {};

    // Fallback error message
    var title = header.data('default-text'),
        msg = body.data('default-text'),
        yes = yesBtn.data('default-text'),
        no = noBtn.data('default-text');

    body.multiline(options.message || msg);
    header.text(options.title || title);
    yesBtn.text(options.yes || yes);
    noBtn.text(options.no || no);

    return new Promise(function(resolve, reject) {
        modal.modal('show');
        yesBtn.on('click', function() {
            resolve();
        });
        noBtn.on('click', function() {
            reject();
        });
        modal.on('hide.bs.modal', function() {
            reject();
        });
    });
};

/**
    Show an information modal to notify the user about something.
    @param options:Object {
        message:string. Informative message.
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when the modal is dismissed/closed.
    No formal rejection happens.
**/
exports.showNotification = function showNotification(options) {
    
    var modal = $('#notificationModal'),
        header = modal.find('#notificationModal-label'),
        body = modal.find('#notificationModal-body');

    options = options || {};
    
    // Fallback message
    var msg = options.message || body.data('default-text');

    body.multiline(msg);

    header.text(options.title || header.data('default-text'));
    
    return new Promise(function(resolve) {
        modal.modal('show');
        modal.on('hide.bs.modal', function() {
            resolve();
        });
    });
};

exports.showTimePicker = require('./modals/timePicker').show;

},{"./modals/timePicker":68}],41:[function(require,module,exports){
/**
    Setup of the shell object used by the app
**/
'use strict';

var baseUrl = window.location.pathname;

//var History = require('./app-shell-history').create(baseUrl);
var History = require('./utils/shell/hashbangHistory');

// Shell dependencies
var shell = require('./utils/shell/index'),
    Shell = shell.Shell,
    DomItemsManager = shell.DomItemsManager;

//var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );

// Creating the shell:
var shell = new Shell({

    // Selector, DOM element or jQuery object pointing
    // the root or container for the shell items
    root: 'body',

    // If is not in the site root, the base URL is required:
    baseUrl: baseUrl,
    
    forceHashbang: true,

    indexName: 'index',

    linkEvent: 'click',

    // No need for loader, everything comes bundled
    loader: null,

    // History Polyfill:
    history: History,

    // A DomItemsManager or equivalent object instance needs to
    // be provided:
    domItemsManager: new DomItemsManager({
        idAttributeName: 'data-activity'
    })
});

module.exports = shell;

},{"./utils/shell/hashbangHistory":132,"./utils/shell/index":133}],42:[function(require,module,exports){
/** 
    AppModel extension,
    focused on the Account related APIs:
    - login
    - logout
    - signup
**/
'use strict';

var localforage = require('localforage');

exports.plugIn = function (AppModel) {
    /**
        Try to perform an automatic login if there is a local
        copy of credentials to use on that,
        calling the login method that save the updated
        data and profile.
    **/
    AppModel.prototype.tryLogin = function tryLogin() {
        // Get saved credentials
        return localforage.getItem('credentials')
        .then(function(credentials) {
            // If we have ones, try to log-in
            if (credentials) {
                // Attempt login with that
                return this.login(
                    credentials.username,
                    credentials.password
                );
            } else {
                throw new Error('No saved credentials');
            }
        }.bind(this));
    };

    /**
        Performs a login attempt with the API by using
        the provided credentials.
    **/
    AppModel.prototype.login = function login(username, password) {

        // Reset the extra headers to attempt the login
        this.rest.extraHeaders = null;

        return this.rest.post('login', {
            username: username,
            password: password,
            returnProfile: true
        }).then(performLocalLogin(this, username, password));
    };

    /**
        Performs a logout, removing cached credentials
        and profile so the app can be filled up with
        new user information.
        It calls to the API logout call too, to remove
        any server-side session and notification
        (removes the cookie too, for browser environment
        that may use it).
    **/
    // FUTURE: TOREVIEW if the /logout call can be removed.
    AppModel.prototype.logout = function logout() {

        // Local app close session
        this.rest.extraHeaders = null;
        localforage.removeItem('credentials');
        localforage.removeItem('profile');
        
        // Local data clean-up!
        this.clearLocalData();

        // Don't need to wait the result of the REST operation
        this.rest.post('logout');

        return Promise.resolve();
    };

    /**
        Attempts to create a user account, getting logged
        if successfully like when doing a login call.
    **/
    AppModel.prototype.signup = function signup(username, password, profileType) {

        // Reset the extra headers to attempt the signup
        this.rest.extraHeadres = null;

        // The result is the same as in a login, and
        // we do the same as there to get the user logged
        // on the app on sign-up success.
        return this.rest.post('signup?utm_source=app', {
            username: username,
            password: password,
            profileType: profileType,
            returnProfile: true
        }).then(performLocalLogin(this, username, password));
    };
};

function performLocalLogin(thisAppModel, username, password) {

    return function(logged) {
        
        // Remove any previous local data if any:
        return thisAppModel.clearLocalData()
        .then(function() {

            // use authorization key for each
            // new Rest request
            thisAppModel.rest.extraHeaders = {
                alu: logged.userID,
                alk: logged.authKey
            };

            // async local save, don't wait
            localforage.setItem('credentials', {
                userID: logged.userID,
                username: username,
                password: password,
                authKey: logged.authKey
            });
            // IMPORTANT: Local name kept in sync with set-up at AppModel.userProfile
            localforage.setItem('profile', logged.profile);

            // Set user data
            thisAppModel.user().model.updateWith(logged.profile);

            return logged;
        });
    };
}

},{"localforage":false}],43:[function(require,module,exports){
/** Bookings

    IMPORTANT!!!! API not to use directly by the app, but through appModel.calendar (it has cache and more)
**/
'use strict';

var Booking = require('../models/Booking'),
    moment = require('moment'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
        remote: {
            rest: appModel.rest,
            getBookings: function(filters) {
                return appModel.rest.get('bookings', filters)
                .then(function(rawItems) {
                    return rawItems && rawItems.map(function(rawItem) {
                        return new Booking(rawItem);
                    });
                });
            }
        }
    };

    api.getBookingsByDates = function getBookingsByDates(date, end) {
        
        end = end || moment(date).clone().add(1, 'days').toDate();
        
        // Remote loading data
        return api.remote.getBookings({
            start: date,
            end: end
        }).then(function(bookings) {
            // Put in cache (they are already model instances)
            var arr = ko.observableArray(bookings);
            // Return the observable array
            return arr;
        });
    };
    
    /**
        Get upcoming bookings meta-information for dashboard page
    **/
    api.getUpcomingBookings = function getUpcomingBookings() {
        return appModel.rest.get('upcoming-bookings');
    };

    /**
        Get a specific booking by ID
    **/
    api.getBooking = function getBooking(id) {
        if (!id) return Promise.reject('The bookingID is required to get a booking');
        return appModel.rest.get('bookings/' + id)
        .then(function(booking) {
            return new Booking(booking);
        });
    };
    
    /**
        Converts an Appointment model into a simplified
        booking plain object, suitable to REST API for edition
    **/
    api.appointmentToSimplifiedBooking = function(apt) {
        return {
            bookingID: apt.sourceBooking().bookingID(),
            customerUserID: apt.customerUserID(),
            addressID: apt.addressID(),
            startTime: apt.startTime(),
            pricing: apt.pricing().map(function(pricing) {
                // TODO: for now, the REST API allow only a list of IDs,
                // not objects, so next line is replaced:
                //return pricing.model.toPlainObject(true);
                return pricing.freelancerPricingID();
            }),
            preNotesToClient: apt.preNotesToClient(),
            preNotesToSelf: apt.preNotesToSelf(),
            postNotesToClient: apt.postNotesToClient(),
            postNotesToSelf: apt.postNotesToSelf()
        };
    };
    /**
        Converst a Booking model into a simplified
        booking plain object, suitable to REST API for edition
    **/
    api.bookingToSimplifiedBooking = function(booking) {
        return {
            bookingID: booking().bookingID(),
            customerUserID: booking.customerUserID(),
            addressID: booking.addressID(),
            startTime: booking.startTime(),
            pricing: booking.bookingRequest().pricingEstimate().details().pricing
            .map(function(pricing) {
                // TODO: for now, the REST API allow only a list of IDs,
                // not objects, so next line is replaced:
                //return pricing.model.toPlainObject(true);
                return pricing.freelancerPricingID();
            }),
            preNotesToClient: booking.preNotesToClient(),
            preNotesToSelf: booking.preNotesToSelf(),
            postNotesToClient: booking.postNotesToClient(),
            postNotesToSelf: booking.postNotesToSelf()
        };
    };
    
    /**
        Creates/updates a booking, given a simplified booking
        object or an Appointment model or a Booking model
    **/
    api.setBooking = function setBooking(booking, allowBookUnavailableTime) {    
        booking = booking.bookingID ?
            api.bookingToSimplifiedBooking(booking) :
            booking.sourceBooking ?
                api.appointmentToSimplifiedBooking(booking) :
                booking
        ;

        var id = booking.bookingID || '',
            method = id ? 'put' : 'post';
        
        booking.allowBookUnavailableTime = allowBookUnavailableTime || false;

        return appModel.rest[method]('freelancer-bookings/' + id, booking)
        .then(function(serverBooking) {
            return new Booking(serverBooking);
        });
    };

    return api;
};

},{"../models/Booking":71,"knockout":false,"moment":false}],44:[function(require,module,exports){
/**
    It offers access to calendar elements (appointments) and availability
    
    Appointments is an abstraction around calendar events
    that behave as bookings or as events (where bookings are built
    on top of an event instance --a booking record must have ever a confirmedDateID event).
    
    With this appModel, the APIs to manage events&bookings are combined to offer related
    records easier in Appointments objects.
**/
'use strict';

var Appointment = require('../models/Appointment'),
    DateAvailability = require('../models/DateAvailability'),
    DateCache = require('../utils/DateCache'),
    moment = require('moment'),
    _ = require('lodash'),
    EventEmitter = require('events').EventEmitter;

exports.create = function create(appModel) {

    function Api() {
        EventEmitter.call(this);
        this.setMaxListeners(30);
    }
    Api._inherits(EventEmitter);
    
    var api = new Api();
    
    var cache = new DateCache({
        Model: DateAvailability,
        ttl: { minutes: 10 }
    });
    
    api.clearCache = function clearCache() {
        cache.clear();
        this.emit('clearCache');
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Get a generic calendar appointment object, made of events and/or bookings,
        depending on the given ID in the ids object.
        
        TODO: gets single apt from the DateCache
    **/
    api.getAppointment = function getAppointment(ids) {

        if (ids.calendarEventID) {
            return appModel.calendarEvents.getEvent(ids.calendarEventID)
            .then(Appointment.fromCalendarEvent);
        }
        else if (ids.bookingID) {
            return appModel.bookings.getBooking(ids.bookingID)
            .then(function(booking) {
                // An appointment for booking needs the confirmed event information
                return appModel.calendarEvents.getEvent(booking.confirmedDateID())
                .then(function(event) {
                    return Appointment.fromBooking(booking, event);
                });
            });
        }
        else {
            return Promise.reject('Unrecognized ID');
        }
    };
    
    api.setAppointment = function setAppointment(apt, allowBookUnavailableTime) {
        
        // TODO: Saving apt must invalidate the cache and force date
        // availability computation with UI update, when start time or start end changes 
        // (ever when inserting apt), for the previous date and the new one (if date changed)
        // and only date availability computation if date is the same but time changed.
        // And triggers "this.emit('clearCache');" passing as parameter the dates array that needs refresh
        
        // If is a booking
        if (apt.sourceBooking()) {
            return appModel.bookings.setBooking(apt, allowBookUnavailableTime)
            .then(function(booking) {
                
                // TODO: clearCache, enhance by discarding only the cache for the previous
                // and new date
                api.clearCache();
                
                // We need the event information too
                return appModel.calendarEvents.getEvent(booking.confirmedDateID())
                .then(function(event) {
                    return Appointment.fromBooking(booking, event);
                });
            });
        }
        else if (apt.sourceEvent()) {
            return appModel.calendarEvents.setEvent(apt)
            .then(function(event) {
                return Appointment.fromCalendarEvent(event);
            });
        }
        else {
            return Promise.reject(new Error('Unrecognized appointment object'));
        }
    };
    
    /**
        Get a list of generic calendar appointment objects, made of events and/or bookings
        by Date, from the remote source directly.
        Used internally only, to get appointments with and without free/unavailable
        slots use getDateAvailability
    **/
    var getRemoteAppointmentsByDate = function getRemoteAppointmentsByDate(date) {
        return Promise.all([
            appModel.bookings.getBookingsByDates(date),
            appModel.calendarEvents.getEventsByDates(date)
        ]).then(function(group) {

            var events = group[1],
                bookings = group[0],
                apts = [];

            if (events && events().length) {
                apts = Appointment.listFromCalendarEventsBookings(events(), bookings());
            }

            // Return the array
            return apts;
        });
    };
    
    /**
        Fetch appointments and schedule information for the date from remote
        in a convenient object to use with the DateAvailability model.
    **/
    var getRemoteDateAvailability = function getRemoteDateAvailability(date) {
        return Promise.all([
            getRemoteAppointmentsByDate(date),
            appModel.simplifiedWeeklySchedule.load(),
            appModel.schedulingPreferences.load()
        ])
        .then(function(result) {
            var apts = result[0],
                settings = result[1],
                weekDaySchedule = settings.weekDays[date.getDay()](),
                prefs = result[2];

            var dateInfo = {
                date: date,
                appointmentsList: apts || [],
                weekDaySchedule: weekDaySchedule,
                schedulingPreferences: prefs
            };

            return dateInfo;
        });
    };
    
    /**
        Get the appointments and availability for the given date.
        It has cache control, if there is a valid copy is returned
        at the moment, if is reloaded and exists on cache, that copy is
        updated so all previous instances get the updated data too.
    **/
    api.getDateAvailability = function getDateAvailability(date) {
        
        var cached = cache.getSingle(date);

        if (cached) {
            return Promise.resolve(cached);
        }
        else {
            return getRemoteDateAvailability(date)
            .then(function(dateInfo) {
                // Update cache and retun data as class instance
                return cache.set(date, dateInfo).data;
            });
        }
    };
    
    
    //////
    // NEW MULTI DATES API
    
    /**
        Get a list of generic calendar appointment objects, made of events and/or bookings
        by Date, from the remote source directly.
        Used internally only, to get appointments with and without free/unavailable
        slots use getDateAvailability
    **/
    var getRemoteAppointmentsByDates = function getRemoteAppointmentsByDates(start, end) {
        return Promise.all([
            appModel.bookings.getBookingsByDates(start, end),
            appModel.calendarEvents.getEventsByDates(start, end)
        ]).then(function(group) {

            var events = group[1],
                bookings = group[0],
                apts = [];

            if (events && events().length) {
                apts = Appointment.listFromCalendarEventsBookings(events(), bookings());
            }

            // Group apts by date
            var grouped = _.groupBy(apts, function(apt) {
                return moment(apt.startTime()).format('YYYY-MM-DD');
            });
            
            // Ensure all the dates in the range are filled, with empty arrays in the holes.
            // NOTE: this way of first group apts and then fill gaps makes the resulting object
            // to display properties out of order (if some hole needed being filled out).
            var date = new Date(start);
            while (date <= end) {
                var key = moment(date).format('YYYY-MM-DD');
                
                if (!grouped.hasOwnProperty(key))
                    grouped[key] = [];

                // Next date:
                date.setDate(date.getDate() + 1);
            }

            return grouped;
        });
    };
    
    /**
        Fetch appointments and schedule information for the dates from remote
        in a convenient object to use with the DateAvailability model
        (returns an array of them).
    **/
    var getRemoteDatesAvailability = function getRemoteDatesAvailability(start, end) {
        return Promise.all([
            getRemoteAppointmentsByDates(start, end),
            appModel.simplifiedWeeklySchedule.load(),
            appModel.schedulingPreferences.load()
        ])
        .then(function(result) {
            var aptsDates = result[0],
                settings = result[1],
                results = {},
                prefs = result[2];

            Object.keys(aptsDates).forEach(function(dateKey) {
                var date = moment(dateKey, 'YYYY-MM-DD').toDate();
                var weekDaySchedule = settings.weekDays[date.getDay()]();
            
                var dateInfo = {
                    date: date,
                    appointmentsList: aptsDates[dateKey] || [],
                    weekDaySchedule: weekDaySchedule,
                    schedulingPreferences: prefs
                };

                results[dateKey] = dateInfo;
            });

            return results;
        });
    };
    
    api.getDatesAvailability = function getDatesAvailability(start, end) {

        var cacheResults = cache.get(start, end);
        // We know what dates we need and what data is cached already
        // If all cached, just resolve to cache
        if (cacheResults.minHole === null) {
            return Promise.resolve(cacheResults.byDate);
        }
        
        // Request all dates in the range (even if some cached in between)
        return getRemoteDatesAvailability(cacheResults.minHole, cacheResults.maxHole)
        .then(function(results) {
            // Add results to cache, creating DateAvailability object
            // and add that to the resultset
            Object.keys(results).forEach(function(dateKey) {
                cacheResults.byDate[dateKey] = cache.set(dateKey, results[dateKey]).data;
            });
            return cacheResults.byDate;
        });
    };

    return api;
};


},{"../models/Appointment":70,"../models/DateAvailability":77,"../utils/DateCache":102,"events":false,"lodash":false,"moment":false}],45:[function(require,module,exports){
/** Events

    IMPORTANT!!!! API not to use directly by the app, but through appModel.calendar (it has cache and more)
**/
'use strict';

var CalendarEvent = require('../models/CalendarEvent'),
    moment = require('moment'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
        remote: {
            rest: appModel.rest,
            getCalendarEvents: function(filters) {
                return appModel.rest.get('events', filters)
                .then(function(rawItems) {
                    return rawItems && rawItems.map(function(rawItem) {
                        return new CalendarEvent(rawItem);
                    });
                });
            }
        }
    };

    api.getEventsByDates = function getEventsByDates(date, end) {
        
        end = end || moment(date).clone().add(1, 'days').toDate();
        
        // Remote loading data
        return api.remote.getCalendarEvents({
            start: date,
            end: end
        }).then(function(events) {

            // Put in array (they are already model instances)
            var arr = ko.observableArray(events);
            // Return the observable array
            // TODO Review really if has sense to have an observable array, take care of its use (on appointments mainly)
            return arr;
        });
    };
    
    /**
        Get a specific event by ID
    **/
    api.getEvent = function getEvent(id) {
        if (!id) return Promise.reject('The calendarEventID is required to get an event');

        return appModel.rest.get('events/' + id)
        .then(function(event) {
            return new CalendarEvent(event);
        });
    };
    
    api.appointmentToSimplifiedEvent = function(apt) {
        
        var rrule = apt.sourceEvent().recurrenceRule();
        if (rrule)
            rrule = apt.sourceEvent().recurrenceRule().model.toPlainObject();

        var occs = apt.sourceEvent().recurrenceOccurrences();
        if (occs)
            occs = occs.map(function(occ) {
                return occ && occ.model.toPlainObject() || null;
            }).filter(function(occ) { return occ !== null; });
        
        return {
            // The same as apt.sourceEvent().calendarEventID()
            calendarEventID: apt.id() < 0 ? 0 : apt.id(),
            eventTypeID: apt.sourceEvent().eventTypeID(),
            summary: apt.summary(),
            description: apt.description(),
            availabilityTypeID: apt.sourceEvent().availabilityTypeID(),
            location: apt.addressSummary(),
            startTime: apt.startTime(),
            endTime: apt.endTime(),
            isAllDay: apt.sourceEvent().isAllDay(),
            recurrenceRule: rrule,
            recurrenceOccurrences: occs
        };
    };

    /**
        Creates/updates a booking, given a simplified booking
        object or an Appointment model or a Booking model
    **/
    api.setEvent = function setEvent(event) {

        event = event.calendarEventID ?
            event.model.toPlainObject() :
            event.sourceEvent ?
                api.appointmentToSimplifiedEvent(event) :
                event
        ;

        var id = event.calendarEventID || '',
            method = id ? 'put' : 'post';

        return appModel.rest[method]('events' + (id ? '/' : '') + id, event)
        .then(function(serverEvent) {
            return new CalendarEvent(serverEvent);
        });
    };

    return api;
};

},{"../models/CalendarEvent":74,"knockout":false,"moment":false}],46:[function(require,module,exports){
/** Calendar Syncing app model
**/
'use strict';

var ko = require('knockout'),
    CalendarSyncing = require('../models/CalendarSyncing'),
    RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new CalendarSyncing(),
        ttl: { minutes: 1 },
        localStorageName: 'calendarSyncing',
        fetch: function fetch() {
            return appModel.rest.get('calendar-syncing');
        },
        push: function push() {
            return appModel.rest.put('calendar-syncing', this.data.model.toPlainObject());
        }
    });
    
    // Extending with the special API method 'resetExportUrl'
    rem.isReseting = ko.observable(false);
    rem.resetExportUrl = function resetExportUrl() {
        
        rem.isReseting(true);

        return appModel.rest.post('calendar-syncing/reset-export-url')
        .then(function(updatedSyncSettings) {
            // Updating the cached data
            rem.data.model.updateWith(updatedSyncSettings);
            rem.isReseting(false);

            return updatedSyncSettings;
        });
    };
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });

    return rem;
};

},{"../models/CalendarSyncing":75,"../utils/RemoteModel":111,"knockout":false}],47:[function(require,module,exports){
/** Customers
**/
'use strict';

var Customer = require('../models/Customer');

var ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        listTtl: { minutes: 1 },
        itemIdField: 'customerUserID',
        Model: Customer
    });

    api.addLocalforageSupport('customers');
    api.addRestSupport(appModel.rest, 'customers');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    /**
        Public search of users, possible customers by well
        know fields, with full value match.
    **/
    var publicSearchRequest = null;
    api.publicSearch = function publicSearch(search) {

        // Only one request at a time
        if (publicSearchRequest &&
            publicSearchRequest.abort) {
            try {
                publicSearchRequest.abort();
            } catch (abortErr) {
                console.error('Error aborting request', abortErr);
            }
        }
        
        var request = appModel.rest.get('customers/public-search', search);
        publicSearchRequest = request.xhr;
        
        // Catch 'abort' to avoid communicate a fake error in the promise; the
        // promise will just solve as success with empty array.
        request = request.catch(function(err) {
            if (err && err.statusText === 'abort')
                return [];
            else
                // Rethrow only if is not an 'abort'
                return err;
        });
        // Set again, removed by the catch returned promise
        request.xhr = publicSearchRequest;

        return request;
    };

    return api;
};

},{"../models/Customer":76,"../utils/ListRemoteModel":109}],48:[function(require,module,exports){
/** Feedback
**/
//global navigator,window
'use strict';

exports.create = function create(appModel) {
    
    var getUserDeviceInfo = function getUserDeviceInfo() {
        var dev = window.device || {
            platform: 'web',
            model: 'unknow',
            cordova: '',
            version: ''
        };
        return {
            userAgent: navigator.userAgent,
            platform: dev.platform,
            version: dev.version,
            model: dev.model,
            cordova: dev.cordova
        };
    };
    
    return {
        /**
            @param values:Object {
                message:string,
                vocElementID:int,
                becomeCollaborator:boolean,
                userDevice:string (automatic)
            }
        **/
        postIdea: function postIdea(values) {
            values.userDevice = JSON.stringify(getUserDeviceInfo());
            return appModel.rest.post('feedback/ideas', values);
        },
        /**
            @param values:Object {
                message:string,
                vocElementID:int,
                userDevice:string (automatic)
            }
        **/
        postSupport: function postSupport(values) {
            values.userDevice = JSON.stringify(getUserDeviceInfo());
            return appModel.rest.post('feedback/support', values);
        }
    };
};

},{}],49:[function(require,module,exports){
/** Freelancer Pricing
**/
'use strict';

var FreelancerPricing = require('../models/FreelancerPricing'),
    GroupListRemoteModel = require('../utils/GroupListRemoteModel');

exports.create = function create(appModel) {

    var api = new GroupListRemoteModel({
        // Conservative cache, just 1 minute
        listTtl: { minutes: 1 },
        groupIdField: 'jobTitleID',
        itemIdField: 'freelancerPricingID',
        Model: FreelancerPricing
    });

    api.addLocalforageSupport('freelancer-pricing/');
    api.addRestSupport(appModel.rest, 'freelancer-pricing/');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/FreelancerPricing":78,"../utils/GroupListRemoteModel":106}],50:[function(require,module,exports){
/** Home Address
**/
'use strict';

var Address = require('../models/Address');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new Address(),
        ttl: { minutes: 1 },
        localStorageName: 'homeAddress',
        fetch: function fetch() {
            return appModel.rest.get('addresses/home');
        },
        push: function push() {
            return appModel.rest.put('addresses/home', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/Address":69,"../utils/RemoteModel":111}],51:[function(require,module,exports){
/** Fetch Job Titles and Pricing Types information
**/
'use strict';

var localforage = require('localforage'),
    JobTitle = require('../models/JobTitle'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
            state:  {
                isLoading: ko.observable(false)
            }
        },
        cache = {
            jobTitles: {}
        };
    
    api.clearCache = function clearCache() {
        cache.jobTitles = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Public API
        Get a Job Title information by ID
    **/
    api.getJobTitle = function getJobTitle(id) {
        if (!id) return Promise.reject('Needs an ID to get a Job Title');

        // First, in-memory cache
        if (cache.jobTitles[id]) {
            return Promise.resolve(cache.jobTitles[id]);
        }
        else {
            api.state.isLoading(true);
            // Second, local storage
            return localforage.getItem('jobTitles/' + id)
            .then(function(jobTitle) {
                if (jobTitle) {
                    // cache in memory as Model instance
                    cache.jobTitles[id] = new JobTitle(jobTitle);
                    api.state.isLoading(false);
                    // return it
                    return cache.jobTitles[id];
                }
                else {
                    // Third and last, remote loading
                    return appModel.rest.get('job-titles/' + id)
                    .then(function (raw) {
                        // Cache in local storage
                        localforage.setItem('jobTitles/' + id, raw);
                        // cache in memory as Model instance
                        cache.jobTitles[id] = new JobTitle(raw);
                        api.state.isLoading(false);
                        // return it
                        return cache.jobTitles[id];
                    });
                }
            })
            .catch(function(err) {
                api.state.isLoading(false);
                // Rethrow error
                return err;
            });
        }
    };

    return api;
};

},{"../models/JobTitle":80,"knockout":false,"localforage":false}],52:[function(require,module,exports){
/** AppModel, centralizes all the data for the app,
    caching and sharing data across activities and performing
    requests
**/
var ko = require('knockout'),
    $ = require('jquery'),
    Rest = require('../utils/Rest'),
    localforage = require('localforage'),
    EventEmitter = require('events').EventEmitter;

function AppModel() {
    EventEmitter.call(this);
    this.setMaxListeners(30);
}

AppModel._inherits(EventEmitter);

module.exports = AppModel;

require('./AppModel-account').plugIn(AppModel);

/**
    Load credentials from the local storage, without error if there is nothing
    saved. If load profile data too, performing an tryLogin if no local data.
**/
AppModel.prototype.loadLocalCredentials = function loadLocalCredentials() {
    return new Promise(function(resolve) { // Never rejects: , reject) {

        // Callback to just resolve without error (passing in the error
        // to the 'resolve' will make the process to fail),
        // since we don't need to create an error for the
        // app init, if there is not enough saved information
        // the app has code to request a login.
        var resolveAnyway = function(doesnMatter){        
            console.warning('App Model Init err', doesnMatter);
            resolve();
        };
        
        // If there are credentials saved
        localforage.getItem('credentials').then(function(credentials) {

            if (credentials &&
                credentials.userID &&
                credentials.username &&
                credentials.authKey) {

                // use authorization key for each
                // new Rest request
                this.rest.extraHeaders = {
                    alu: credentials.userID,
                    alk: credentials.authKey
                };
                
                // It has credentials! Has basic profile data?
                // NOTE: the userProfile will load from local storage on this first
                // attempt, and lazily request updated data from remote so we need
                // to catch remote errors with events
                this.userProfile.once('error', function(err) {
                    this.emit('error', {
                        message: 'Impossible to load your data. Please check your Internet connection',
                        error: err
                    });
                }.bind(this));
                
                this.userProfile.load().then(function(profile) {
                    if (profile) {
                        // There is a profile cached                    
                        // End succesfully
                        resolve();
                    }
                    else {
                        // No profile, we need to request it to be able
                        // to work correctly, so we
                        // attempt a login (the tryLogin process performs
                        // a login with the saved credentials and fetch
                        // the profile to save it in the local copy)
                        this.tryLogin().then(resolve, resolveAnyway);
                    }
                }.bind(this), resolveAnyway)
                // The error event catch any error if happens, so avoid uncaught exceptions
                // in the console by catching the promise error
                .catch(function() { });
            }
            else {
                // End successfully. Not loggin is not an error,
                // is just the first app start-up
                resolve();
            }
        }.bind(this), resolveAnyway);
    }.bind(this));
};

/** Initialize and wait for anything up **/
AppModel.prototype.init = function init() {
    
    // Local data
    // TODO Investigate why automatic selection an IndexedDB are
    // failing and we need to use the worse-performance localstorage back-end
    localforage.config({
        name: 'LoconomicsApp',
        version: 0.1,
        size : 4980736, // Size of database, in bytes. WebSQL-only for now.
        storeName : 'keyvaluepairs',
        description : 'Loconomics App',
        driver: localforage.LOCALSTORAGE
    });
    
    // First, get any saved local config
    // NOTE: for now, this is optional, to get a saved siteUrl rather than the
    // default one, if any.
    return localforage.getItem('config')
    .then(function(config) {
        // Optional config
        config = config || {};
        
        if (config.siteUrl) {
            // Update the html URL
            $('html').attr('data-site-url', config.siteUrl);
        }
        else {
            config.siteUrl = $('html').attr('data-site-url');
        }
        
        this.rest = new Rest(config.siteUrl + '/api/v1/en-US/');
        
        // Setup Rest authentication
        this.rest.onAuthorizationRequired = function(retry) {

            this.tryLogin()
            .then(function() {
                // Logged! Just retry
                retry();
            });
        }.bind(this);
        
        // With config loaded and REST ready, load all modules
        this.loadModules();
        
        // Initialize: check the user has login data and needed
        // cached data, return its promise
        return this.loadLocalCredentials();
    }.bind(this));
};

AppModel.prototype.loadModules = function loadModules() {

    this.userProfile = require('./AppModel.userProfile').create(this);
    // NOTE: Alias for the user data
    // TODO:TOREVIEW if continue to makes sense to keep this 'user()' alias, document
    // where is used and why is preferred to the canonical way.
    this.user = ko.computed(function() {
        return this.userProfile.data;
    }, this);

    this.onboarding = require('./AppModel.onboarding').create(this);

    this.schedulingPreferences = require('./AppModel.schedulingPreferences').create(this);
    this.calendarSyncing = require('./AppModel.calendarSyncing').create(this);
    this.simplifiedWeeklySchedule = require('./AppModel.simplifiedWeeklySchedule').create(this);
    this.marketplaceProfile = require('./AppModel.marketplaceProfile').create(this);
    this.homeAddress = require('./AppModel.homeAddress').create(this);
    this.privacySettings = require('./AppModel.privacySettings').create(this);
    this.bookings = require('./AppModel.bookings').create(this);
    this.calendarEvents = require('./AppModel.calendarEvents').create(this);
    this.jobTitles = require('./AppModel.jobTitles').create(this);
    this.userJobProfile = require('./AppModel.userJobProfile').create(this);
    this.calendar = require('./AppModel.calendar').create(this);
    this.serviceAddresses = require('./AppModel.serviceAddresses').create(this);
    this.freelancerPricing = require('./AppModel.freelancerPricing').create(this);
    this.pricingTypes = require('./AppModel.pricingTypes').create(this);
    this.messaging = require('./AppModel.messaging').create(this);
    this.customers = require('./AppModel.customers').create(this);
    this.postalCodes = require('./AppModel.postalCodes').create(this);
    this.feedback = require('./AppModel.feedback').create(this);
    //UNSTABLE:this.availability = require('./AppModel.availability').create(this);
};

/**
    Clear the local stored data, but with careful for the special
    config data that is kept.
**/
AppModel.prototype.clearLocalData = function clearLocalData() {
    // Get config
    return localforage.getItem('config')
    .then(function(config) {
        // Clear all
        localforage.clear();

        if (config) {
            // Set config again
            localforage.setItem('config', config);
        }
        
        // Trigger notification, so other components
        // can make further clean-up or try synchronizations,
        // for example to clean-up in-memory cache.
        this.emit('clearLocalData');
    }.bind(this));
};

},{"../utils/Rest":112,"./AppModel-account":42,"./AppModel.bookings":43,"./AppModel.calendar":44,"./AppModel.calendarEvents":45,"./AppModel.calendarSyncing":46,"./AppModel.customers":47,"./AppModel.feedback":48,"./AppModel.freelancerPricing":49,"./AppModel.homeAddress":50,"./AppModel.jobTitles":51,"./AppModel.marketplaceProfile":53,"./AppModel.messaging":54,"./AppModel.onboarding":55,"./AppModel.postalCodes":56,"./AppModel.pricingTypes":57,"./AppModel.privacySettings":58,"./AppModel.schedulingPreferences":59,"./AppModel.serviceAddresses":60,"./AppModel.simplifiedWeeklySchedule":61,"./AppModel.userJobProfile":62,"./AppModel.userProfile":63,"events":false,"knockout":false,"localforage":false}],53:[function(require,module,exports){
/** MarketplaceProfile
**/
'use strict';

var MarketplaceProfile = require('../models/MarketplaceProfile');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new MarketplaceProfile(),
        ttl: { minutes: 1 },
        localStorageName: 'marketplaceProfile',
        fetch: function fetch() {
            return appModel.rest.get('marketplace-profile');
        },
        push: function push() {
            return appModel.rest.put('marketplace-profile', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/MarketplaceProfile":84,"../utils/RemoteModel":111}],54:[function(require,module,exports){
/** AppModel for messaging: threads and messages

    NOTE: Initial basic implementation
    TODO: Require advanced implementation, loading a limited
        amount of records for threads and messages per thread
        using the cursor parameters of the REST API to manage
        paging load.
**/
'use strict';

var Thread = require('../models/Thread'),
    CacheControl = require('../utils/CacheControl'),
    ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        listTtl: { minutes: 1 },
        itemIdField: 'threadID',
        Model: Thread
    });

    api.addLocalforageSupport('messaging');
    api.addRestSupport(appModel.rest, 'messaging');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    // Basic support is fetching all threads with the latest message of each one.
    // Replace getItem built-in to do non locally saved, fetch for all messages in
    // a thread (the thread is the item)
    var fullThreadsCache = {/*
        threadID: { control: CacheControl, thread: Thread }
    */};
    var fetchThreadRemote = function(threadID) {
        return appModel.rest.get('messaging/' + threadID, {
            limit: 1000 /* max messages in the thread */
        })
        .then(function(thread) {
            if (thread) {
                thread = new Thread(thread);
                var cached = fullThreadsCache[threadID];
                if (cached) {
                    cached.control.latest = new Date();
                    cached.thread = thread;
                } else {
                    fullThreadsCache[threadID] = {
                        control: new CacheControl({ ttl: { minutes: 1 } }),
                        thread: thread
                    };
                    fullThreadsCache[threadID].control.latest = new Date();
                }
                return thread;
            }
            else {
                throw new Error('Not Found');
            }
        });
    };
    var markAsEndedAndFollowUp = function(any) {
        api.state.isSyncing(false);
        api.state.isLoading(false);
        return any;
    };
    api.getItem = function getItem(threadID) {
        var cached = fullThreadsCache[threadID];
        if (cached && cached.thread) {
            if (cached.control.mustRevalidate()) {
                api.state.isSyncing(true);
                return fetchThreadRemote(threadID)
                .then(markAsEndedAndFollowUp, markAsEndedAndFollowUp);
            }
            else
                return Promise.resolve(cached.thread);
        } else {
            api.state.isLoading(true);
            return fetchThreadRemote(threadID)
            .then(markAsEndedAndFollowUp, markAsEndedAndFollowUp);
        }
    };

    return api;
};

},{"../models/Thread":95,"../utils/CacheControl":101,"../utils/ListRemoteModel":109}],55:[function(require,module,exports){
/**
    Onboarding tracking information
**/
'use strict';

var OnboardingProgress = require('../viewmodels/OnboardingProgress'),
    NavAction = require('../viewmodels/NavAction');

exports.create = function create(appModel) {
    
    // Onboarding management and state, initially empty so no progress
    var api = new OnboardingProgress();
    
    // Requires initialization to receive and app instance
    api.init = function init(app) {
        api.app = app;
    };
    
    // Extended with new methods

    // Set the correct onboarding progress and step given a step reference
    // (usually from database)
    api.setStep = function(stepReference) {
        if (stepReference) {
            var stepItems = stepReference.split(':', 2),
                group = stepItems[0],
                // step is the second part, or just the same as
                // the full name (that happens for the first steps that share
                // name with the group and only need to define the group name)
                step = stepItems[1] || group;

            // Try to set current step, follow to look for group if does not success
            if (this.setStepByName(step)) {
                return true;
            }
            // else:
            // Look for a group that matches
            var groupSteps = OnboardingProgress.predefinedStepGroups[group];
            if (groupSteps) {
                this.steps(groupSteps);
                this.group(group);
                if (this.setStepByName(step)) {
                    return true;
                }
            }
        }
        // No progress:
        this.model.reset();
        return false;
    };

    // Update the given navbar with the current onboarding information (only if in progress)
    api.updateNavBar = function(navBar) {
        var yep = this.inProgress();
        if (yep) {
            // On 2015-06-16 #575, changed decission from use a 'go back' action
            // (commented in following lines):
//            navBar.leftAction(NavAction.goBack.model.clone());
//            navBar.leftAction().handler(function() {
//                api.goPrevious();
//                return false;
//            });
            // to use the Log-out action
            navBar.leftAction(NavAction.goLogout);

            navBar.title(this.progressText());            
        }
        return yep;
    };
    
    api.goNext = function goNext() {
        var current = this.stepNumber();

        current++;

        if (current > this.totalSteps()) {
            // It ended!!
            this.stepNumber(-1);
            appModel.userProfile.saveOnboardingStep(null);
            this.app.shell.go('/', { completedOnboarding: api.group() });
        }
        else {
            // Get next step
            this.stepNumber(current);
            appModel.userProfile.saveOnboardingStep(this.stepReference());
            this.app.shell.go(this.stepUrl());
        }
    };
    
    api.goPrevious = function goPrevious() {
        var current = this.stepNumber();

        current--;

        if (current >= 0 && current <= this.totalSteps()) {
            // Get previous step
            this.stepNumber(current);
        }
        else {
            this.stepNumber(0);
        }

        appModel.userProfile.saveOnboardingStep(this.stepReference());
        this.app.shell.go(this.stepUrl());
    };
    
    return api;
};

},{"../viewmodels/NavAction":141,"../viewmodels/OnboardingProgress":143}],56:[function(require,module,exports){
/** Postal Code.

    Access the API to validate and retrieve information for a 
    given postal code.
    
    It just offers a 'get postal code info' method returning
    a plain object from the REST endpoint.
    
    Creates an in-memory cache for frequently used postal codes
**/
'use strict';

exports.create = function create(appModel) {

    var api = {},
        cache = {};
    
    api.getItem = function getItem(postalCode) {
        
        postalCode = postalCode || '';
        if (/^\s*$/.test(postalCode)) {
            return Promise.reject('Postal Code Not Valid');
        }
        
        // Check cache
        if (cache.hasOwnProperty(postalCode)) {
            return Promise.resolve(cache[postalCode]);
        }
        
        return appModel.rest.get('postal-codes/' + postalCode)
        .then(function(info) {
            // Save cache
            if (info) {
                cache[postalCode] = info;
            }
            // return
            return info;
        });
    };

    appModel.on('clearLocalData', function() {
        cache = {};
    });
    
    return api;
};

},{}],57:[function(require,module,exports){
/** Pricing Types
**/
'use strict';

var PricingType = require('../models/PricingType');

var ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        // Types does not changes usually, so big ttl
        listTtl: { days: 1 },
        itemIdField: 'pricingTypeID',
        Model: PricingType
    });

    api.addLocalforageSupport('pricing-types');
    api.addRestSupport(appModel.rest, 'pricing-types');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    return api;
};

},{"../models/PricingType":91,"../utils/ListRemoteModel":109}],58:[function(require,module,exports){
/** Privacy Settings
**/
'use strict';

var PrivacySettings = require('../models/PrivacySettings');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new PrivacySettings(),
        ttl: { minutes: 1 },
        localStorageName: 'privacySettings',
        fetch: function fetch() {
            return appModel.rest.get('privacy-settings');
        },
        push: function push() {
            return appModel.rest.put('privacy-settings', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/PrivacySettings":92,"../utils/RemoteModel":111}],59:[function(require,module,exports){
/**
**/
'use strict';

var SchedulingPreferences = require('../models/SchedulingPreferences');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new SchedulingPreferences(),
        ttl: { minutes: 1 },
        localStorageName: 'schedulingPreferences',
        fetch: function fetch() {
            return appModel.rest.get('scheduling-preferences');
        },
        push: function push() {
            return appModel.rest.put('scheduling-preferences', this.data.model.toPlainObject())
            .then(function(result) {
                // We need to recompute availability as side effect of scheduling preferences changes
                appModel.calendar.clearCache();
                // Forward the result
                return result;
            });
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/SchedulingPreferences":93,"../utils/RemoteModel":111}],60:[function(require,module,exports){
/** Service Addresses
**/
'use strict';

var Address = require('../models/Address'),
    GroupListRemoteModel = require('../utils/GroupListRemoteModel');

exports.create = function create(appModel) {

    var api = new GroupListRemoteModel({
        // Conservative cache, just 1 minute
        listTtl: { minutes: 1 },
        groupIdField: 'jobTitleID',
        itemIdField: 'addressID',
        Model: Address
    });
    
    api.addLocalforageSupport('addresses/service/');
    api.addRestSupport(appModel.rest, 'addresses/service/');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/Address":69,"../utils/GroupListRemoteModel":106}],61:[function(require,module,exports){
/**
**/
'use strict';

var SimplifiedWeeklySchedule = require('../models/SimplifiedWeeklySchedule'),
    RemoteModel = require('../utils/RemoteModel'),
    moment = require('moment');

// The slot size is fixed to 15 minutes by default.
// NOTE: currently, the API only allows 15 minutes slots,
// being that implicit, but part of the code is ready for explicit slotSize.
var defaultSlotSize = 15;
// A list of week day properties names allowed
// to be part of the objects describing weekly schedule
// (simplified or complete/slot based)
// Just lowecased english names
var weekDayProperties = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new SimplifiedWeeklySchedule(),
        ttl: { minutes: 1 },
        localStorageName: 'weeklySchedule',
        fetch: function fetch() {
            return appModel.rest.get('availability/weekly-schedule')
            .then(fromWeeklySchedule);
        },
        push: function push() {
            var plainData = {
                'all-time': false,
                'json-data': {}
            };
            if (this.data.isAllTime() === true) {
                plainData['all-time'] = true;
            }
            else {
                plainData['json-data'] = JSON.stringify(toWeeklySchedule(this.data.model.toPlainObject(true)));
            }

            return appModel.rest.put('availability/weekly-schedule', plainData)
            .then(fromWeeklySchedule)
            .then(function(result) {
                // We need to recompute availability as side effect of schedule
                appModel.calendar.clearCache();
                // Forward the result
                return result;
            });
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

function fromWeeklySchedule(weeklySchedule) {
    
    // New simplified object, as a plain object with
    // weekdays properties and from-to properties like:
    // { sunday: { from: 0, to: 60 } }
    // Since this is expected to be consumed by fetch-push
    // operations, and later by an 'model.updateWith' operation,
    // so plain is simple and better on performance; can be
    // converted easily to the SimplifiedWeeklySchedule object.
    var simpleWS = {
        timeZone: weeklySchedule.timeZone || ''
    };
    
    // Only supports 'available' status with default 'unavailable'
    if (weeklySchedule.defaultStatus !== 'unavailable' ||
        weeklySchedule.status !== 'available') {
        throw {
            name: 'input-format',
            message: 'Weekly schedule, given statuses not supported, status: ' +
            weeklySchedule.status + ', defaultStatus: ' + 
            weeklySchedule.defaultStatus
          };
    }
    
    // given slotSize or default
    var slotSize = (weeklySchedule.slotSize || defaultSlotSize) |0;

    // Read slots per week-day ({ slots: { "sunday": [] } })
    Object.keys(weeklySchedule.slots)
    .forEach(function(weekday) {
        
        // Verify is a weekday property, or exit early
        if (weekDayProperties.indexOf(weekday) === -1) {
            return;
        }
        
        var dayslots = weeklySchedule.slots[weekday];
        
        // We get the first available slot and the last consecutive
        // to make the range
        var from = null,
            to = null,
            previous = null;

        // times are ordered in ascending
        // and with format "00:00:00" that we convert to minutes
        // (enough precision for simplified weekly schedule)
        // using moment.duration
        // NOTE: using 'some' rather than 'forEach' to be able
        // to exit early from the iteration by returning 'true'
        // when the end is reached.
        dayslots.some(function(slot) {
            var minutes = moment.duration(slot).asMinutes() |0;
            // We have not still a 'from' time:
            if (from === null) {
                from = minutes;
                previous = minutes;
            }
            else {
                // We have a beggining, check if this is consecutive
                // to previous, by checking previous plus slotSize
                if (previous + slotSize === minutes) {
                    // New end
                    to = minutes;
                    // Next iteration
                    previous = minutes;
                }
                else {
                    // No consecutive, we already has a range, any
                    // additional slot is discarded, out of the
                    // precision of the simplified weekly schedule,
                    // so we can go out the iteration:
                    return true;
                    
                    // NOTE: If in a future a more complete schedule
                    // need to be wroten using multiple ranges rather
                    // individual slots, this is the place to continue
                    // coding, populating an array of [{from, to}] :-)
                }
            }
        });
        
        // Slots checked, check the result
        if (from !== null) {
            
            var simpleDay = {
                from: from,
                to: 0
            };
            simpleWS[weekday] = simpleDay;

            // We have a range!
            if (to !== null) {
                // and has an end!
                // add the slot size to the ending
                simpleDay.to = to + slotSize;
            }
            else {
                // smaller range, just one slot,
                // add the slot size to the begining
                simpleDay.to = from + slotSize;
            }
        }
    });

    // Done!
    return simpleWS;
}

/**
    Pass in a plain object, not a model,
    getting an object suitable for the API endpoint.
**/
function toWeeklySchedule(simplifiedWeeklySchedule) {

    var slotSize = defaultSlotSize;
    
    // It's build with 'available' as explicit status:
    var weeklySchedule = {
        status: 'available',
        defaultAvailability: 'unavailable',
        slots: {},
        slotSize: slotSize,
        timeZone: simplifiedWeeklySchedule.timeZone
    };

    // Per weekday
    Object.keys(simplifiedWeeklySchedule)
    .forEach(function(weekday) {

        // Verify is a weekday property, or exit early
        if (weekDayProperties.indexOf(weekday) === -1) {
            return;
        }

        var simpleDay = simplifiedWeeklySchedule[weekday];

        // We need to expand the simplified time ranges 
        // in slots of the slotSize
        // The end time will be excluded, since slots
        // define only the start, being implicit the slotSize.
        var from = simpleDay.from |0,
            to = simpleDay.to |0;

        // Create the slot array
        weeklySchedule.slots[weekday] = [];

        // Integrity verification
        if (to > from) {
            // Iterate by the slotSize until we reach
            // the end, not including the 'to' since
            // slots indicate only the start of the slot
            // that is assumed to fill a slotSize starting
            // on that slot-time
            var previous = from;
            while (previous < to) {
                weeklySchedule.slots[weekday].push(minutesToTimeString(previous));
                previous += slotSize;
            }
        }
    });

    // Done!
    return weeklySchedule;
}

/**
    internal utility function 'to string with two digits almost'
**/
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Convert a number of minutes
    in a string like: 00:00:00 (hours:minutes:seconds)
**/
function minutesToTimeString(minutes) {
    var d = moment.duration(minutes, 'minutes'),
        h = d.hours(),
        m = d.minutes(),
        s = d.seconds();
    
    return (
        twoDigits(h) + ':' +
        twoDigits(m) + ':' +
        twoDigits(s)
    );
}

},{"../models/SimplifiedWeeklySchedule":94,"../utils/RemoteModel":111,"moment":false}],62:[function(require,module,exports){
/**
    Model API to manage the collection of Job Titles assigned
    to the current user and its working data.
**/
'use strict';

var UserJobTitle = require('../models/UserJobTitle'),
    CacheControl = require('../utils/CacheControl'),
    localforage = require('localforage'),
    ko = require('knockout'),
    $ = require('jquery');

exports.create = function create(appModel) {

    var api = {},
        defaultTtl = { minutes: 1 },
        cache = {
            // Array of user job titles making
            // its profile
            userJobProfile: {
                cache: new CacheControl({ ttl: defaultTtl }),
                list: null
            },
            // Indexed list by jobTitleID to the user job titles models
            // in the list and cache information
            userJobTitles: {/*
                jobTitleID: { model: object, cache: CacheControl }
            */}
        };
    
    // Observable list
    api.list = ko.observableArray([]);
    // NOTE: Basic implementation, to enhance
    api.syncList = function syncList() {
        return api.getUserJobProfile().then(function(list) {
            api.list(list);
            return list;
        });
    };
    
    api.clearCache = function clearCache() {
        cache.userJobProfile.cache.latest = null;
        cache.userJobProfile.list = [];
        cache.userJobTitles = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Convert raw array of job titles records into
        an indexed array of models, actually an object
        with ID numbers as properties,
        and cache it in memory.
    **/
    function mapToUserJobProfile(rawItems) {
        cache.userJobProfile.list = [];
        cache.userJobTitles = {};

        if (rawItems) {
            rawItems.forEach(function(rawItem) {
                var m = new UserJobTitle(rawItem);
                cache.userJobProfile.list.push(m);
                // Saving and indexed copy and per item cache info
                setGetUserJobTitleToCache(rawItem);
            });
        }
        // Update observable
        api.list(cache.userJobProfile.list);

        // Update cache state
        cache.userJobProfile.cache.latest = new Date();
        
        return cache.userJobProfile.list;
    }
    
    /**
        Get the full jobProfile from local copy, throwing a Promise reject exception if nothing
    **/
    function getUserJobProfileFromLocal() {
        return localforage.getItem('userJobProfile')
        .then(function(userJobProfile) {
            if (userJobProfile) {
                return mapToUserJobProfile(userJobProfile);
            }
            // Return null since there is no data, the promise can catch
            // there is no data and attempt a remote
            return null;
        });
    }
    
    /**
        Set a raw userJobProfile record (from server) and set it in the
        cache, creating or updating the model (so all the time the same model instance
        is used) and cache control information.
        Returns the model instance.
    **/
    function setGetUserJobTitleToCache(rawItem) {
        var c = cache.userJobTitles[rawItem.jobTitleID] || {};
        // Update the model if exists, so get reflected to anyone consuming it
        if (c.model) {
            c.model.model.updateWith(rawItem);
        }
        else {
            // First time, create model
            c.model = new UserJobTitle(rawItem);
        }
        // Update cache control
        if (c.cache) {
            c.cache.latest = new Date();
        }
        else {
            c.cache = new CacheControl({ ttl: defaultTtl });
        }
        
        // If there is a profile list, add or update:
        var fullList =  cache.userJobProfile.list;
        if (fullList) {
            var found = null;
            fullList.some(function(it) {
                if (it.jobTitleID() === rawItem.jobTitleID) {
                    found = it;
                    return true;
                }
            });
            if (found) {
                found.model.updateWith(rawItem);
            }
            else {
                fullList.push(c.model);
            }
        }
        
        // Return the model, updated or just created
        return c.model;
    }
    
    /**
        Get the content from the cache, for full profile
        and save it in local storage
        NOTE It has no sense in current implementation (problem of fetch
        job title without a full job profile in cache/local)
    **/
    /*function saveCacheInLocal() {
        var plain = cache.userJobProfile.list.map(function(item) {
            // Each item is a model, get it in plain:
            return item.model.toPlainObject();
        });
        localforage.setItem('userJobProfile', plain);
    }*/
    
    // Private, fetch from remote
    var fetchUserJobProfile = function () {
        // Third and last, remote loading
        return appModel.rest.get('user-job-profile')
        .then(function (raw) {
            // Cache in local storage
            localforage.setItem('userJobProfile', raw);
            return mapToUserJobProfile(raw);
        });
    };
    
    /**
        Public API
        Get the complete list of UserJobTitle for
        all the JobTitles assigned to the current user
    **/
    api.getUserJobProfile = function () {
        // If no cache or must revalidate, go remote
        // (the first loading is ever 'must revalidate')
        if (cache.userJobProfile.cache.mustRevalidate()) {
            // If no cache, is first load, so try local
            if (!cache.userJobProfile.list) {
                // Local storage
                return getUserJobProfileFromLocal()
                .then(function(data) {
                    // launch remote for sync
                    var remotePromise = fetchUserJobProfile();
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                });
            }
            else {
                // No cache, no local, or obsolete, go remote:
                return fetchUserJobProfile();
            }
        }
        else {
            // There is cache and is still valid:
            return Promise.resolve(cache.userJobProfile.list);
        }
    };
    
    // Private, fetch from remote
    var fetchUserJobTitle = function(jobTitleID) {
        return appModel.rest.get('user-job-profile/' + jobTitleID)
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            
            // TODO implement cache saving for single job-titles, currently
            // it needs to save the profile cache, that may not exists if
            // the first request is for a single job title.
            // Next lines are to save full profile, not valid here.
            // Save in local
            //saveCacheInLocal();
            
            // Return model
            return m;
        });
    };
    
    var pushNewUserJobTitle = function(values) {
        // Create job title in remote
        return appModel.rest.post('user-job-profile', $.extend({
            jobTitleID: 0,
            jobTitleName: '',
            intro: '',
            cancellationPolicyID: null,
            instantBooking: false
        }, values))
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            
            // TODO implement cache saving for single job-titles, currently
            // it needs to save the profile cache, that may not exists if
            // the first request is for a single job title.
            // Next lines are to save full profile, not valid here.
            // Save in local
            //saveCacheInLocal();
            
            // Return model
            return m;
        });
    };
    
    /**
        Public API
        Get a UserJobTitle record for the given
        JobTitleID and the current user.
    **/
    api.getUserJobTitle = function (jobTitleID) {
        // Quick error
        if (!jobTitleID) return Promise.reject('Job Title ID required');
        
        // If no cache or must revalidate, go remote
        if (!cache.userJobTitles[jobTitleID] ||
            cache.userJobTitles[jobTitleID].cache.mustRevalidate()) {
            return fetchUserJobTitle(jobTitleID);
        }
        else {
            // First, try cache
            if (cache.userJobTitles[jobTitleID] &&
                cache.userJobTitles[jobTitleID].model) {
                return Promise.resolve(cache.userJobTitles[jobTitleID].model);
            }
            else {
                // Second, local storage, where we have the full job profile
                return getUserJobProfileFromLocal()
                .then(function(/*userJobProfile*/) {
                    // Not need for the parameter, the data is
                    // in memory and indexed, look for the job title
                    return cache.userJobTitles[jobTitleID].model;
                })
                // If no local copy (error on promise),
                // or that does not contains the job title (error on 'then'):
                // Third and last, remote loading
                .catch(fetchUserJobTitle.bind(null, jobTitleID));
            }
        }
    };
    
    api.createUserJobTitle = function (values) {
        return pushNewUserJobTitle(values);
    };
    
    /*************************/
    /** ADITIONAL UTILITIES **/
    api.getUserJobTitleAndJobTitle = function getUserJobTitleAndJobTitle(jobTitleID) {
        return api.getUserJobTitle(jobTitleID)
        .then(function(userJobTitle) {
            // Very unlikely error
            if (!userJobTitle) {
                throw {
                    name: 'Not Found',
                    message:
                        // LJDI:
                        'You have not this job title in your profile. ' + 
                        'Maybe was deleted from your profile recently.'
                };
            }

            // Get job title info too
            return Promise.all([
                userJobTitle,
                appModel.jobTitles.getJobTitle(jobTitleID)
            ]);
        })
        .then(function(all) {
            var jobTitle = all[1];
            // Very unlikely error
            if (!jobTitle) {
                throw {
                    name: 'Not Found',
                    // LJDI:
                    message: 'The job title does not exist.'
                };
            }
        
            return {
                jobTitleID: jobTitleID,
                userJobTitle: all[0],
                jobTitle: jobTitle
            };
        });
    };
    
    return api;
};

},{"../models/UserJobTitle":98,"../utils/CacheControl":101,"knockout":false,"localforage":false}],63:[function(require,module,exports){
/** UserProfile
**/
'use strict';

var User = require('../models/User');

var RemoteModel = require('../utils/RemoteModel'),
    localforage = require('localforage');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: User.newAnonymous(),
        ttl: { minutes: 1 },
        // IMPORTANT: Keep the name in sync with set-up at AppModel-account
        localStorageName: 'profile',
        fetch: function fetch() {
            return appModel.rest.get('profile');
        },
        push: function push() {
            return appModel.rest.put('profile', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    rem.saveOnboardingStep = function saveOnboardingStep(stepReference) {
        if (typeof(stepReference) === 'undefined') {
            stepReference = rem.data.onboardingStep();
        }
        else {
            rem.data.onboardingStep(stepReference);
        }

        return appModel.rest.put('profile/tracking', {
            onboardingStep: stepReference
        })
        .then(function() {
            // If success, save persistent local copy of the data to ensure the
            // new onboardingStep is saved
            localforage.setItem(rem.localStorageName, rem.data.model.toPlainObject());
        });
    };
    
    return rem;
};

},{"../models/User":97,"../utils/RemoteModel":111,"localforage":false}],64:[function(require,module,exports){
/**
    Activity base class
**/
'use strict';

var ko = require('knockout'),
    NavAction = require('../viewmodels/NavAction'),
    NavBar = require('../viewmodels/NavBar');

require('../utils/Function.prototype._inherits');

/**
    Activity class definition
**/
function Activity($activity, app) {

    this.$activity = $activity;
    this.app = app;

    // Default access level: anyone
    this.accessLevel = app.UserType.None;
    
    // TODO: Future use of a viewState, plain object representation
    // of part of the viewModel to be used as the state passed to the
    // history and between activities calls.
    this.viewState = {};
    
    // Object to hold the options passed on 'show' as a result
    // of a request from another activity
    this.requestData = null;

    // Default navBar object.
    this.navBar = new NavBar({
        title: null, // null for logo
        leftAction: null,
        rightAction: null
    });
    
    // Knockout binding of viewState delayed to first show
    // to avoid problems with subclasses replacing the viewState
}

module.exports = Activity;

/**
    Set-up visualization of the view with the given options/state,
    with a reset of current state.
    Must be executed every time the activity is put in the current view.
**/
Activity.prototype.show = function show(options) {
    // TODO: must keep viewState up to date using options/state.
    //console.log('Activity show', this.constructor.name);
    if (!this.__bindingDone) {
        // A view model and bindings being applied is ever required
        // even on Activities without need for a view model, since
        // the use of components and templates, or any other data-bind
        // syntax, requires to be in a context with binding enabled:
        ko.applyBindings(this.viewModel || {}, this.$activity.get(0));
        this.__bindingDone = true;
    }
    
    options = options || {};
    this.requestData = options;
    
    // Enable registered handlers
    // Validation of each settings object is performed
    // on registered, avoided here.
    if (this._handlers &&
        this._handlersAreConnected !== true) {
        this._handlers.forEach(function(settings) {
            // Check if is an observable subscription
            if (!settings.event && settings.target.subscribe) {
                var subscription = settings.target.subscribe(settings.handler);
                // Observables has not a 'unsubscribe' function,
                // they return an object that must be 'disposed'.
                // Saving that with settings to allow 'unsubscribe' later.
                settings._subscription = subscription;

                // Inmediate execution: if current observable value is different
                // than previous one, execute the handler:
                // (this avoid that a changed state get omitted because happened
                // when subscription was off; it means a first time execution too).
                // NOTE: 'undefined' value on observable may cause this to fall
                if (settings._latestSubscribedValue !== settings.target()) {
                    settings.handler.call(settings.target, settings.target());
                }
            }
            else if (settings.selector) {
                settings.target.on(settings.event, settings.selector, settings.handler);
            }
            else if (settings.target.on) {
                settings.target.on(settings.event, settings.handler);
            }
            else {
                console.error('Activity.show: Bad registered handler', settings);
            }
        });
        // To avoid double connections:
        // NOTE: may happen that 'show' gets called several times without a 'hide'
        // in between, because 'show' acts as a refresher right now even from segment
        // changes from the same activity.
        this._handlersAreConnected = true;
    }
};

/**
    Perform tasks to stop anything running or stop handlers from listening.
    Must be executed every time the activity is hidden/removed 
    from the current view.
**/
Activity.prototype.hide = function hide() {
    
    // Disable registered handlers
    if (this._handlers) {
        this._handlers.forEach(function(settings) {
            // Check if is an observable subscription
            if (settings._subscription) {
                settings._subscription.dispose();
                // Save latest observable value to make a comparision
                // next time is enabled to ensure is executed if there was
                // a change while disabled:
                settings._latestSubscribedValue = settings.target();
            }
            else if (settings.target.off) {
                if (settings.selector)
                    settings.target.off(settings.event, settings.selector, settings.handler);
                else
                    settings.target.off(settings.event, settings.handler);
            }
            else if (settings.target.removeListener) {
                settings.target.removeListener(settings.event, settings.handler);
            }
            else {
                console.error('Activity.hide: Bad registered handler', settings);
            }
        });
        
        this._handlersAreConnected = false;
    }
};

/**
    Register a handler that acts on an event or subscription notification,
    that will be enabled on Activity.show and disabled on Activity.hide.

    @param settings:object {
        target: jQuery, EventEmitter, Knockout.observable. Required
        event: string. Event name (can have namespaces, several events allowed). Its required except when the target is an observable, there must
            be omitted.
        handler: Function. Required,
        selector: string. Optional. For jQuery events only, passed as the
            selector for delegated handlers.
    }
**/
Activity.prototype.registerHandler = function registerHandler(settings) {
    /*jshint maxcomplexity:8 */
    
    if (!settings)
        throw new Error('Register require a settings object');
    
    if (!settings.target || (!settings.target.on && !settings.target.subscribe))
        throw new Error('Target is null or not a jQuery, EventEmmiter or Observable object');
    
    if (typeof(settings.handler) !== 'function') {
        throw new Error('Handler must be a function.');
    }
    
    if (!settings.event && !settings.target.subscribe) {
        throw new Error('Event is null; it\'s required for non observable objects');
    }

    this._handlers = this._handlers || [];

    this._handlers.push(settings);
};

/**
    Static utilities
**/
// For commodity, common classes are exposed as static properties
Activity.NavBar = NavBar;
Activity.NavAction = NavAction;

// Quick creation of common types of NavBar
Activity.createSectionNavBar = function createSectionNavBar(title) {
    return new NavBar({
        title: title,
        leftAction: NavAction.menuIn,
        rightAction: NavAction.menuNewItem
    });
};

Activity.createSubsectionNavBar = function createSubsectionNavBar(title, options) {
    
    options = options || {};
    
    var goBackOptions = {
        text: title,
        isTitle: true
    };

    if (options.backLink) {
        goBackOptions.link = options.backLink;
        goBackOptions.isShell = false;
    }

    return new NavBar({
        title: '', // No title
        leftAction: NavAction.goBack.model.clone(goBackOptions),
        rightAction: options.helpId ?
            NavAction.goHelpIndex.model.clone({
                link: '#' + options.helpId
            }) :
            NavAction.goHelpIndex
    });
};

Activity.prototype.createCancelAction = function createCancelAction(cancelLink) {
    
    var app = this.app;
    
    var action = new NavAction({
        link: cancelLink,
        text: 'cancel',
        handler: function(event) {
            var link = this.link(),
                eoptions = event && event.options || {};
            
            var goLink = function() {
                if (link)
                    app.shell.go(link);
                else
                    app.shell.goBack();
            };
            
            // A silentMode passed to the event requires
            // avoid the modal (used when executing a saving task for example)
            if (eoptions.silentMode) {
                goLink();
            }
            else {
                // TODO L18N
                app.modals.confirm({
                    title: 'Cancel',
                    message: 'Are you sure?',
                    yes: 'Yes',
                    no: 'No'
                })
                .then(function() {
                    // Confirmed cancellation:
                    goLink();
                });
            }
        }
    });

    return action;
};

Activity.prototype.convertToCancelAction = function convertToCancelAction(actionModel, cancelLink) {
    var cancel = this.createCancelAction(cancelLink);
    actionModel.model.updateWith(cancel);
    // DUDE: handler is cpied by updateWith?
    actionModel.handler(cancel.handler());
};

/**
    Singleton helper
**/
var singlentonInstances = {};
var createSingleton = function createSingleton(ActivityClass, $activity, app) {
    
    if (singlentonInstances[ActivityClass.name] instanceof ActivityClass) {
        return singlentonInstances[ActivityClass.name];
    }
    else {
        var s = new ActivityClass($activity, app);
        singlentonInstances[ActivityClass.name] = s;
        return s;
    }
};
// Example of use
//exports.init = createSingleton.bind(null, ActivityClass);

/**
    Static method extends to help inheritance.
    Additionally, it adds a static init method ready for the new class
    that generates/retrieves the singleton.
**/
Activity.extends = function extendsActivity(ClassFn) {
    
    ClassFn._inherits(Activity);
    
    ClassFn.init = createSingleton.bind(null, ClassFn);
    
    return ClassFn;
};

},{"../utils/Function.prototype._inherits":104,"../viewmodels/NavAction":141,"../viewmodels/NavBar":142,"knockout":false}],65:[function(require,module,exports){
/* =========================================================
 * DatePicker JS Component, with several
 * modes and optional inline-permanent visualization.
 *
 * Copyright 2014 Loconomics Coop.
 *
 * Based on:
 * bootstrap-datepicker.js 
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

var $ = require('jquery'); 

var classes = {
    component: 'DatePicker',
    months: 'DatePicker-months',
    days: 'DatePicker-days',
    monthDay: 'day',
    month: 'month',
    year: 'year',
    years: 'DatePicker-years',
    weekDays: 'DatePicker-weekDays',
    active: 'active'
};

var events = {
    dayRendered: 'dayRendered',
    dateChanged: 'dateChanged',
    show: 'show',
    hide: 'hide',
    dateSet: 'dateSet',
    // IMPORTANT: Triggered after a value is set or updated in the viewDate property
    // without check if the same or not (but operations updating it happens on a change)
    // AND after is changed and calendar filled (fill method called, so DOM reflects the new viewDate).
    viewDateChanged: 'viewDateChanged'
};

var DPGlobal = {
    modes: [
        {
            clsName: 'days',
            navFnc: 'Month',
            navStep: 1
        },
        {
            clsName: 'months',
            navFnc: 'FullYear',
            navStep: 1
        },
        {
            clsName: 'years',
            navFnc: 'FullYear',
            navStep: 10
        },
        {
            clsName: 'day',
            navFnc: 'Date',
            navStep: 1
        }
    ],
    dates:{
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
        daysMin: ["Su", "M", "Tu", "W", "Th", "F", "Sa", "Su"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    },
    isLeapYear: function (year) {
        return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
    },
    getDaysInMonth: function (year, month) {
        return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },
    parseFormat: function(format){
        var separator = format.match(/[.\/\-\s].*?/),
            parts = format.split(/\W+/);
        if (!separator || !parts || parts.length === 0){
            throw new Error("Invalid date format.");
        }
        return {separator: separator, parts: parts};
    },
    parseDate: function(date, format) {
        /*jshint maxcomplexity:11*/
        var parts = date.split(format.separator),
            val;
        date = new Date();
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        if (parts.length === format.parts.length) {
            var year = date.getFullYear(), day = date.getDate(), month = date.getMonth();
            for (var i=0, cnt = format.parts.length; i < cnt; i++) {
                val = parseInt(parts[i], 10)||1;
                switch(format.parts[i]) {
                    case 'dd':
                    case 'd':
                        day = val;
                        date.setDate(val);
                        break;
                    case 'mm':
                    case 'm':
                        month = val - 1;
                        date.setMonth(val - 1);
                        break;
                    case 'yy':
                        year = 2000 + val;
                        date.setFullYear(2000 + val);
                        break;
                    case 'yyyy':
                        year = val;
                        date.setFullYear(val);
                        break;
                }
            }
            date = new Date(year, month, day, 0 ,0 ,0);
        }
        return date;
    },
    formatDate: function(date, format){
        var val = {
            d: date.getDate(),
            m: date.getMonth() + 1,
            yy: date.getFullYear().toString().substring(2),
            yyyy: date.getFullYear()
        };
        val.dd = (val.d < 10 ? '0' : '') + val.d;
        val.mm = (val.m < 10 ? '0' : '') + val.m;
        date = [];
        for (var i=0, cnt = format.parts.length; i < cnt; i++) {
            date.push(val[format.parts[i]]);
        }
        return date.join(format.separator);
    },
    headTemplate: '<thead>'+
                        '<tr>'+
                            '<th class="prev">&lsaquo;</th>'+
                            '<th colspan="5" class="switch"></th>'+
                            '<th class="next">&rsaquo;</th>'+
                        '</tr>'+
                    '</thead>',
    contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
};
DPGlobal.template = '<div class="' + classes.component + '">'+
                        '<div class="' + classes.days + '">'+
                            '<table class=" table-condensed">'+
                                DPGlobal.headTemplate+
                                '<tbody></tbody>'+
                            '</table>'+
                        '</div>'+
                        '<div class="' + classes.months + '">'+
                            '<table class="table-condensed">'+
                                DPGlobal.headTemplate+
                                DPGlobal.contTemplate+
                            '</table>'+
                        '</div>'+
                        '<div class="' + classes.years + '">'+
                            '<table class="table-condensed">'+
                                DPGlobal.headTemplate+
                                DPGlobal.contTemplate+
                            '</table>'+
                        '</div>'+
                    '</div>';
DPGlobal.modesSet = {
    'date': DPGlobal.modes[3],
    'month': DPGlobal.modes[0],
    'year': DPGlobal.modes[1],
    'decade': DPGlobal.modes[2]
};

// Picker object
var DatePicker = function(element, options) {
    /*jshint maxstatements:40,maxcomplexity:24*/
    this.element = $(element);
    this.format = DPGlobal.parseFormat(options.format||this.element.data('date-format')||'mm/dd/yyyy');
    
    this.isInput = this.element.is('input');
    this.component = this.element.is('.date') ? this.element.find('.add-on') : false;
    this.isPlaceholder = this.element.is('.calendar-placeholder');
    
    this.picker = $(DPGlobal.template)
                        .appendTo(this.isPlaceholder ? this.element : 'body')
                        .on('click', $.proxy(this.click, this));
    this.picker.addClass(this.isPlaceholder ? '' : 'dropdown-menu');
    if (options.extraClasses)
        this.picker.addClass(options.extraClasses);
    
    if (this.isPlaceholder) {
        this.picker.show();
        if (this.element.data('date') == 'today') {
            this.date = new Date();
            this.set();
        }
        this.element.trigger({
            type: events.show,
            date: this.date
        });
    }
    else if (this.isInput) {
        this.element.on({
            focus: $.proxy(this.show, this),
            //blur: $.proxy(this.hide, this),
            keyup: $.proxy(this.update, this)
        });
    } else {
        if (this.component){
            this.component.on('click', $.proxy(this.show, this));
        } else {
            this.element.on('click', $.proxy(this.show, this));
        }
    }
    
    /* Touch events to swipe dates */
    this.element
    .on('swipeleft', function(e) {
        e.preventDefault();
        this.moveDate('next');
    }.bind(this))
    .on('swiperight', function(e) {
        e.preventDefault();
        this.moveDate('prev');
    }.bind(this));

    /* Set-up view mode */
    this.minViewMode = options.minViewMode||this.element.data('date-minviewmode')||0;
    if (typeof this.minViewMode === 'string') {
        switch (this.minViewMode) {
            case 'months':
                this.minViewMode = 1;
                break;
            case 'years':
                this.minViewMode = 2;
                break;
            default:
                this.minViewMode = 0;
                break;
        }
    }
    this.viewMode = options.viewMode||this.element.data('date-viewmode')||0;
    if (typeof this.viewMode === 'string') {
        switch (this.viewMode) {
            case 'months':
                this.viewMode = 1;
                break;
            case 'years':
                this.viewMode = 2;
                break;
            default:
                this.viewMode = 0;
                break;
        }
    }
    this.startViewMode = this.viewMode;
    this.weekStart = options.weekStart||this.element.data('date-weekstart')||0;
    this.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;
    this.onRender = options.onRender;
    this.fillDow();
    this.fillMonths();
    this.update();
    this.showMode();
};

DatePicker.prototype = {
    constructor: DatePicker,
    
    _triggerViewDateChange: function() {
        var viewModeName = DPGlobal.modes[this.viewMode].clsName;
        this.element.trigger(events.viewDateChanged, [{ viewDate: this.viewDate, viewMode: viewModeName }]);
    },
    
    show: function(e) {
        this.picker.show();
        this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
        this.place();
        $(window)
            .off('resize.datepicker')
            .on('resize.datepicker', $.proxy(this.place, this));
        
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        if (!this.isInput) {
        }
        var that = this;
        $(document)
        .off('mousedown.datepicker')
        .on('mousedown.datepicker', function(ev){
            if ($(ev.target).closest('.' + classes.component).length === 0) {
                that.hide();
            }
        });
        this.element.trigger({
            type: events.show,
            date: this.date
        });
    },
    
    hide: function(){
        this.picker.hide();
        $(window).off('resize.datepicker', this.place);
        this.viewMode = this.startViewMode;
        this.showMode();
        if (!this.isInput) {
            $(document).off('mousedown.datepicker', this.hide);
        }
        //this.set();
        this.element.trigger({
            type: events.hide,
            date: this.date
        });
    },
    
    set: function() {
        var formated = DPGlobal.formatDate(this.date, this.format);
        if (!this.isInput) {
            if (this.component){
                this.element.find('input').prop('value', formated);
            }
            this.element.data('date', formated);
        } else {
            this.element.prop('value', formated);
        }
        this.element.trigger(events.dateSet, [this.date, formated]);
    },
    
    /**
        Sets a date as value and notify with an event.
        Parameter dontNotify is only for cases where the calendar or
        some related component gets already updated but the highlighted
        date needs to be updated without create infinite recursion 
        because of notification. In other case, dont use.
    **/
    setValue: function(newDate, dontNotify) {
        if (typeof newDate === 'string') {
            this.date = DPGlobal.parseDate(newDate, this.format);
        } else {
            this.date = new Date(newDate);
        }
        this.set();
        this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
        this.fill();
        // TODO Must check dontNotify?
        this._triggerViewDateChange();
        
        if (dontNotify !== true) {
            // Notify:
            this.element.trigger({
                type: events.dateChanged,
                date: this.date,
                viewMode: DPGlobal.modes[this.viewMode].clsName
            });
        }
    },
    
    getValue: function() {
        return this.date;
    },
    
    getViewDate: function() {
        return this.viewDate;
    },
    
    moveValue: function(dir, mode) {
        // dir can be: 'prev', 'next'
        if (['prev', 'next'].indexOf(dir && dir.toLowerCase()) == -1)
            // No valid option:
            return;

        // default mode is the current one
        mode = mode ?
            DPGlobal.modesSet[mode] :
            DPGlobal.modes[this.viewMode];

        this.date['set' + mode.navFnc].call(
            this.date,
            this.date['get' + mode.navFnc].call(this.date) + 
            mode.navStep * (dir === 'prev' ? -1 : 1)
        );
        this.setValue(this.date);
        return this.date;
    },
    
    place: function(){
        var offset = this.component ? this.component.offset() : this.element.offset();
        this.picker.css({
            top: offset.top + this.height,
            left: offset.left
        });
    },
    
    update: function(newDate){
        this.date = DPGlobal.parseDate(
            typeof newDate === 'string' ? newDate : (this.isInput ? this.element.prop('value') : this.element.data('date')),
            this.format
        );
        this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
        this.fill();
        this._triggerViewDateChange();
    },
    
    getDaysElements: function() {
        return this.picker.find('.' + classes.days + ' .' + classes.monthDay);
    },
    
    fillDow: function(){
        var dowCnt = this.weekStart;
        var html = '<tr class="' + classes.weekDays + '">';
        while (dowCnt < this.weekStart + 7) {
            html += '<th class="dow">'+DPGlobal.dates.daysMin[(dowCnt++)%7]+'</th>';
        }
        html += '</tr>';
        this.picker.find('.' + classes.days + ' thead').append(html);
    },
    
    fillMonths: function(){
        var html = '';
        var i = 0;
        while (i < 12) {
            html += '<span class="' + classes.month + '">'+DPGlobal.dates.monthsShort[i++]+'</span>';
        }
        this.picker.find('.' + classes.months + ' td').append(html);
    },
    
    fill: function() {
        /*jshint maxstatements:70, maxcomplexity:28*/
        var d = new Date(this.viewDate),
            year = d.getFullYear(),
            month = d.getMonth(),
            currentDate = this.date.valueOf();
        
        // Calculate first date to show, usually on previous month:
        var prevMonth = new Date(year, month-1, 28,0,0,0,0),
            lastDayPrevMonth = DPGlobal.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
        // L18N?
        prevMonth.setDate(lastDayPrevMonth);
        prevMonth.setDate(lastDayPrevMonth - (prevMonth.getDay() - this.weekStart + 7)%7);        

        // IMPORTANT: Avoid duplicated work, by checking we are still showing the same month,
        // so not need to 're-render' everything, only swap the active date
        if (this._prevDate && this._prevDate.getMonth() === this.viewDate.getMonth()) {
            var tbody = this.picker.find('.' + classes.days + ' tbody');
            // Remove previous active date mark
            // (viewDate has effectively the value of previous active date, but doing a class search woks too :-)
            tbody.find('.' + classes.monthDay + '.' + classes.active)
            .removeClass(classes.active);

            // Add date mark to current
            var diff = lastDayPrevMonth - prevMonth.getDate(),
                index = diff + this.date.getDate(),
                irow = (index / 7) |0,
                icol = index % 7;
            tbody.find('tr:eq(' + irow + ') td:eq(' + icol + ')').addClass(classes.active);        
            
            this._prevDate = new Date(this.viewDate);
            // DONE:
            return;
        }
        this._prevDate = new Date(this.viewDate);

        // Header
        this.picker
        .find('.' + classes.days + ' th:eq(1)')
        .html(DPGlobal.dates.months[month] + ' ' + year);

        // Calculate ending
        var nextMonth = new Date(prevMonth);
        nextMonth.setDate(nextMonth.getDate() + 42);
        nextMonth = nextMonth.valueOf();
        var html = [];
        var clsName,
            prevY,
            prevM;
            
        if (this._daysCreated !== true) {
            // Create base html (first time only)
            // TODO: Move to constructor
            for(var r = 0; r < 6; r++) {
                html.push('<tr>');
                for(var c = 0; c < 7; c++) {
                    html.push('<td class="' + classes.monthDay + '"><span>&nbsp;</span></td>');
                }
                html.push('</tr>');
            }

            this.picker.find('.' + classes.days + ' tbody').empty().append(html.join(''));
            this._daysCreated = true;
        }

        // Update days values    
        var weekTr = this.picker.find('.' + classes.days + ' tbody tr:first-child()');
        var dayTd = null;
        while(prevMonth.valueOf() < nextMonth) {
            var currentWeekDayIndex = prevMonth.getDay() - this.weekStart;

            clsName = this.onRender(prevMonth);
            prevY = prevMonth.getFullYear();
            prevM = prevMonth.getMonth();
            if ((prevM < month &&  prevY === year) ||  prevY < year) {
                clsName += ' old';
            } else if ((prevM > month && prevY === year) || prevY > year) {
                clsName += ' new';
            }
            if (prevMonth.valueOf() === currentDate) {
                clsName += ' ' + classes.active;
            }

            dayTd = weekTr.find('td:eq(' + currentWeekDayIndex + ')');
            dayTd
            .attr('class', classes.monthDay + ' ' + clsName)
            .data('date-time', prevMonth.toISOString())
            .children('span').text(prevMonth.getDate());

            this.picker.trigger(events.dayRendered, [dayTd]);

            // Next week?
            if (prevMonth.getDay() === this.weekEnd) {
                weekTr = weekTr.next('tr');
            }
            prevMonth.setDate(prevMonth.getDate()+1);
        }

        var currentYear = this.date.getFullYear();
        
        var months = this.picker.find('.' + classes.months)
                    .find('th:eq(1)')
                        .html(year)
                        .end()
                    .find('span').removeClass(classes.active);
        if (currentYear === year) {
            months.eq(this.date.getMonth()).addClass(classes.active);
        }
        
        html = '';
        year = parseInt(year/10, 10) * 10;
        var yearCont = this.picker.find('.' + classes.years)
                            .find('th:eq(1)')
                                .text(year + '-' + (year + 9))
                                .end()
                            .find('td');
        
        year -= 1;
        var i;
        if (this._yearsCreated !== true) {

            for (i = -1; i < 11; i++) {
                html += '<span class="' + classes.year + (i === -1 || i === 10 ? ' old' : '')+(currentYear === year ? ' ' + classes.active : '')+'">'+year+'</span>';
                year += 1;
            }
            
            yearCont.html(html);
            this._yearsCreated = true;
        }
        else {
            
            var yearSpan = yearCont.find('span:first-child()');
            for (i = -1; i < 11; i++) {
                //html += '<span class="year'+(i === -1 || i === 10 ? ' old' : '')+(currentYear === year ? ' ' + classes.active : '')+'">'+year+'</span>';
                yearSpan
                .text(year)
                .attr('class', 'year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' ' + classes.active : ''));
                year += 1;
                yearSpan = yearSpan.next();
            }
        }
    },
    
    moveDate: function(dir, mode) {
        // dir can be: 'prev', 'next'
        if (['prev', 'next'].indexOf(dir && dir.toLowerCase()) == -1)
            // No valid option:
            return;
            
        // default mode is the current one
        mode = mode || this.viewMode;

        this.viewDate['set'+DPGlobal.modes[mode].navFnc].call(
            this.viewDate,
            this.viewDate['get'+DPGlobal.modes[mode].navFnc].call(this.viewDate) + 
            DPGlobal.modes[mode].navStep * (dir === 'prev' ? -1 : 1)
        );
        this.fill();
        this._triggerViewDateChange();
        this.set();
    },

    click: function(e) {
        /*jshint maxcomplexity:16, maxstatements:30*/
        e.stopPropagation();
        e.preventDefault();
        var target = $(e.target).closest('span.month, span.year, td, th');
        if (target.length === 1) {
            var month, year;
            
            var completeMonthYear = function completeMonthYear() {
                if (this.viewMode !== 0) {
                    this.date = new Date(this.viewDate);
                    this.element.trigger({
                        type: events.dateChanged,
                        date: this.date,
                        viewMode: DPGlobal.modes[this.viewMode].clsName
                    });
                }
                this.showMode(-1);
                this.fill();
                this.set();
            }.bind(this);

            if (target.hasClass('switch')) {
                    this.showMode(1);
            }
            else if (target.hasClass('prev') ||
                target.hasClass('next')) {
                    this.moveDate(target[0].className);
            }
            else if (target.hasClass(classes.month)) {
                month = target.parent().find('span').index(target);
                this.viewDate.setMonth(month);
                completeMonthYear();
                this._triggerViewDateChange();
            }
            else if (target.hasClass(classes.year)) {
                year = parseInt(target.text(), 10)||0;
                this.viewDate.setFullYear(year);
                completeMonthYear();
                this._triggerViewDateChange();
            }
            else if (target.hasClass(classes.monthDay)) {
                if (!target.is('.disabled')){
                    var day = parseInt(target.text(), 10)||1;
                    month = this.viewDate.getMonth();
                    month += target.hasClass('old') ? -1 :
                        target.hasClass('new') ? 1 : 0;

                    year = this.viewDate.getFullYear();
                    this.date = new Date(year, month, day,0,0,0,0);
                    this.viewDate = new Date(year, month, Math.min(28, day),0,0,0,0);
                    this.fill();
                    this._triggerViewDateChange();
                    this.set();
                    this.element.trigger({
                        type: events.dateChanged,
                        date: this.date,
                        viewMode: DPGlobal.modes[this.viewMode].clsName
                    });
                }
            }
        }
    },
    
    mousedown: function(e){
        e.stopPropagation();
        e.preventDefault();
    },
    
    showMode: function(dir) {
        if (dir) {
            this.viewMode = Math.max(this.minViewMode, Math.min(2, this.viewMode + dir));
        }
        this.picker.find('>div').hide().filter('.' + classes.component + '-' + DPGlobal.modes[this.viewMode].clsName).show();
    }
};

$.fn.datepicker = function ( option ) {
    var vals = Array.prototype.slice.call(arguments, 1);
    var returned;
    this.each(function () {
        var $this = $(this),
            data = $this.data('datepicker'),
            options = typeof option === 'object' && option;
        if (!data) {
            $this.data('datepicker', (data = new DatePicker(this, $.extend({}, $.fn.datepicker.defaults,options))));
        }

        if (typeof option === 'string') {
            returned = data[option].apply(data, vals);
            // There is a value returned by the method?
            if (typeof(returned) !== 'undefined') {
                // Go out the loop to return the value from the first
                // element-method execution
                return false;
            }
            // Follow next loop item
        }
    });
    if (typeof(returned) !== 'undefined')
        return returned;
    else
        // chaining:
        return this;
};

$.fn.datepicker.defaults = {
    onRender: function(/*date*/) {
        return '';
    }
};
$.fn.datepicker.Constructor = DatePicker;

/** Public API **/
exports.DatePicker = DatePicker;
exports.defaults = DPGlobal;
exports.utils = DPGlobal;

},{}],66:[function(require,module,exports){
/**
    SmartNavBar component.
    Requires its CSS counterpart.
    
    Created based on the project:
    
    Project-Tyson
    Website: https://github.com/c2prods/Project-Tyson
    Author: c2prods
    License:
    The MIT License (MIT)
    Copyright (c) 2013 c2prods
    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**/
var $ = require('jquery');

/**
    Internal utility.
    Removes all children for a DOM node
**/
var clearNode = function (node) {
    while(node.firstChild){
        node.removeChild(node.firstChild);
    }
};

/**
    Calculates and applies the best sizing and distribution for the title
    depending on content and buttons.
    Pass in the title element, buttons must be found as siblings of it.
**/
var textboxResize = function textboxResize(el) {
    /* jshint maxstatements: 28, maxcomplexity:11 */
    
    var leftbtn = el.parentNode.querySelectorAll('.SmartNavBar-edge.left')[0];
    var rightbtn = el.parentNode.querySelectorAll('.SmartNavBar-edge.right')[0];
    if (typeof leftbtn === 'undefined') {
        leftbtn = {
            offsetWidth: 0,
            className: ''
        };
    }
    if (typeof rightbtn === 'undefined') {
        rightbtn = {
            offsetWidth: 0,
            className: ''
        };
    }
    
    var margin = Math.max(leftbtn.offsetWidth, rightbtn.offsetWidth);
    el.style.marginLeft = margin + 'px';
    el.style.marginRight = margin + 'px';
    var tooLong = (el.offsetWidth < el.scrollWidth) ? true : false;
    if (tooLong) {
        if (leftbtn.offsetWidth < rightbtn.offsetWidth) {
            el.style.marginLeft = leftbtn.offsetWidth + 'px';
            el.style.textAlign = 'right';
        } else {
            el.style.marginRight = rightbtn.offsetWidth + 'px';
            el.style.textAlign = 'left';
        }
        tooLong = (el.offsetWidth<el.scrollWidth) ? true : false;
        if (tooLong) {
            if (new RegExp('arrow').test(leftbtn.className)) {
                clearNode(leftbtn.childNodes[1]);
                el.style.marginLeft = '26px';
            }
            if (new RegExp('arrow').test(rightbtn.className)) {
                clearNode(rightbtn.childNodes[1]);
                el.style.marginRight = '26px';
            }
        }
    }
};

exports.textboxResize = textboxResize;

/**
    SmartNavBar class, instantiate with a DOM element
    representing a navbar.
    API:
    - refresh: updates the control taking care of the needed
        width for title and buttons
**/
var SmartNavBar = function SmartNavBar(el) {
    this.el = el;
    
    this.refresh = function refresh() {
        var h = $(el).children('h1').get(0);
        if (h)
            textboxResize(h);
    };

    this.refresh(); 
};

exports.SmartNavBar = SmartNavBar;

/**
    Get instances for all the SmartNavBar elements in the DOM
**/
exports.getAll = function getAll() {
    var all = $('.SmartNavBar');
    return $.map(all, function(item) { return new SmartNavBar(item); });
};

/**
    Refresh all SmartNavBar found in the document.
**/
exports.refreshAll = function refreshAll() {
    $('.SmartNavBar > h1').each(function() { textboxResize(this); });
};

},{}],67:[function(require,module,exports){
/**
    Custom Loconomics 'locale' styles for date/times.
    Its a bit more 'cool' rendering dates ;-)
**/
'use strict';

var moment = require('moment');
// Since the task of define a locale changes
// the current global locale, we save a reference
// and restore it later so nothing changed.
var current = moment.locale();

moment.locale('en-US-LC', {
    meridiemParse : /[ap]\.?\.?/i,
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'p' : 'P';
        } else {
            return isLower ? 'a' : 'A';
        }
    },
    calendar : {
        lastDay : '[Yesterday]',
        sameDay : '[Today]',
        nextDay : '[Tomorrow]',
        lastWeek : '[last] dddd',
        nextWeek : 'dddd',
        sameElse : 'M/D'
    },
    longDateFormat : {
        LT: 'h:mma',
        LTS: 'h:mm:ssa',
        L: 'MM/DD/YYYY',
        l: 'M/D/YYYY',
        LL: 'MMMM Do YYYY',
        ll: 'MMM D YYYY',
        LLL: 'MMMM Do YYYY LT',
        lll: 'MMM D YYYY LT',
        LLLL: 'dddd, MMMM Do YYYY LT',
        llll: 'ddd, MMM D YYYY LT'
    }
});

// Restore locale
moment.locale(current);

},{"moment":false}],68:[function(require,module,exports){
'use strict';

var ko = require('knockout'),
    $ = require('jquery');

// internal utility function 'to string with two digits almost'
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Shows a time picker, based on different dropdowns for each time part.
    Supports hours and minutes (with am/pm for US locale)
    @param options:Object {
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when a button is pressed, with null on 'unset'
    and an object with { time:object, timeString:string } on 'select'.
    The time object is just a plain object as { hours: 0, minutes: 0, seconds: 0 }
    Is rejected when the modal is dismissed/closed without 'unset' or 'select'.
**/
exports.show = function showTimePicker(options) {
    //jshint maxcomplexity:10

    var modal = $('#timePickerModal'),
        vm = modal.data('viewmodel');
    
    if (!vm) {
        vm = new TimePickerModel();

        ko.applyBindings(vm, modal.get(0));
        modal.data('viewmodel', vm);
    }

    options = options || {};
    
    // Fallback title
    vm.title(options.title || 'Select time');
    vm.stepInMinutes(options.stepInMinutes || 5);
    if (typeof(options.selectedTime) === 'string') {
        vm.selectedTimeString(options.selectedTime);
    }
    else {
        vm.selectedTime(options.selectedTime || {});
    }
    vm.unsetLabel(options.unsetLabel || 'Remove');
    vm.selectLabel(options.selectLabel || 'Select');
    
    return new Promise(function(resolve, reject) {
        
        // Handlers
        var unset = function() {
            resolve(null);
            modal.modal('hide');
        };
        var select = function() {
            resolve({
                time: vm.selectedTime(),
                timeString: vm.selectedTimeString()
            });
            modal.modal('hide');
        };

        // Just closed without pick anything, rejects
        modal.off('hide.bs.modal');
        modal.on('hide.bs.modal', reject);
        modal.off('click', '.timePickerModal-unset');
        modal.on('click', '.timePickerModal-unset', unset);
        modal.off('click', '.timePickerModal-select');
        modal.on('click', '.timePickerModal-select', select);

        modal.modal('show');
    });
};

function TimePickerModel() {
    
    // Set-up viewmodel and binding
    var vm = {
        title: ko.observable(''),
        pickedHour: ko.observable(null),
        pickedMinute: ko.observable(null),
        pickedAmpm: ko.observable(null),
        stepInMinutes: ko.observable(5),
        unsetLabel: ko.observable('Remove'),
        selectLabel: ko.observable('Select')
    };
    // TODO: Make localization changes with any app locale change, with timeinterval,
    // as a computed or changed by events:
    vm.locale = ko.observable({ lang: 'en', region: 'US' });

    vm.hourValues = ko.computed(function() {
        var region = this.locale().region;
        var step = (this.stepInMinutes() / 60) |0;
        // IMPORTANT: avoid infinite loops:
        if (step <= 0) step = 1;
        var values = [],
            i;
        if (region === 'US') {
            values.push({
                value: 0,
                label: 12
            });
            for (i = 1; i < 12; i += step) {
                values.push({
                    value: i,
                    label: i
                });
            }
        } else {
            for (i = 0; i < 24; i += step) {
                values.push({
                    value: i,
                    label: i
                });
            }
        }
        return values;
    }, vm);
    vm.minuteValues = ko.computed(function() {
        //var region = this.locale().region;
        var step = this.stepInMinutes() |0;
        // IMPORTANT: avoid infinite loops:
        if (step <= 0) step = 1;
        // No minutes?
        if (step >= 60) return [];

        var values = [];
        //if (region === 'US') {
        for (var i = 0; i < 60; i += step) {
            values.push({
                value: i,
                label: twoDigits(i)
            });
        }
        return values;
    }, vm);
    vm.ampmValues = ko.computed(function() {
        var region = this.locale().region;

        var values = [];
        if (region === 'US') {
            values.push({
                value: 0, // added to hours
                label: 'AM'
            });
            values.push({
                value: 12, // added to hours
                label: 'PM'
            });
        }
        return values;
    }, vm);

    vm.selectedTime = ko.computed({
        read: function() {
            return {
                hours: this.pickedHour() + this.pickedAmpm(),
                minutes: this.pickedMinute(),
                seconds: 0
            };
        },
        write: function(v) {
            if (typeof(v) !== 'object') throw new Error('Invalid input for the time picker. Value:', v);
            v = v || {};
            var region = this.locale().region;
            if (region === 'US') {
                this.pickedHour((v.hours / 12) |0);
                this.pickedMinute(v.minutes |0);
                this.pickedAmpm((v.hours % 12) |0);
            }
            else {
                this.pickedHour(v.hours |0);
                this.pickedMinute(v.minutes |0);
                this.pickedAmpm(0);
            }
        },
        owner: vm
    });

    vm.selectedTimeString = ko.computed({
        read: function() {
            var t = this.selectedTime();
            return twoDigits(t.hours) + ':' + twoDigits(t.minutes) + ':' + twoDigits(t.seconds);
        },
        write: function(v) {
            v = v || '';
            var parts = v.split(':');
            this.selectedTime({
                hours: parts[0] |0,
                minutes: parts[1] |0,
                seconds: parts[2] |0
            });
        },
        owner: vm
    });
    
    return vm;
}

},{"knockout":false}],69:[function(require,module,exports){
/** Address model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

function Address(values) {

    Model(this);
    
    this.model.defProperties({
        addressID: 0,
        addressName: '',
        jobTitleID: 0,
        userID: 0,
        addressLine1: null,
        addressLine2: null,
        postalCode: null,
        city: null, // Autofilled by server
        stateProvinceCode: null, // Autofilled by server
        stateProvinceName: null, // Autofilled by server
        countryCode: null, // ISO Alpha-2 code, Ex.: 'US'
        latitude: null,
        longitude: null,
        specialInstructions: null,
        isServiceArea: false,
        isServiceLocation: false,
        serviceRadius: 0,
        createdDate: null, // Autofilled by server
        updatedDate: null, // Autofilled by server
        kind: '' // Autofilled by server
    }, values);
    
    this.singleLine = ko.computed(function() {
        
        var list = [
            this.addressLine1(),
            this.city(),
            this.postalCode(),
            this.stateProvinceCode()
        ];
        
        return list.filter(function(v) { return !!v; }).join(', ');
    }, this);
    
    // TODO: needed? l10n? must be provided by server side?
    var countries = {
        'US': 'United States',
        'ES': 'Spain'
    };
    this.countryName = ko.computed(function() {
        return countries[this.countryCode()] || 'unknow';
    }, this);

    // Useful GPS object with the format used by Google Maps
    this.latlng = ko.computed(function() {
        return {
            lat: this.latitude(),
            lng: this.longitude()
        };
    }, this);
}

module.exports = Address;

// Public Enumeration for the 'kind' property:
Address.kind = {
    home: 'home',
    billing: 'billing',
    service: 'service'
};

},{"./Model":87,"knockout":false}],70:[function(require,module,exports){
/** Appointment model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment'),
    PricingEstimateDetail = require('./PricingEstimateDetail'),
    CalendarEvent = require('./CalendarEvent'),
    Booking = require('./Booking');
   
function Appointment(values) {
    
    Model(this);

    this.model.defProperties({
        // An appointment ever references an event, and its 'id' is a CalendarEventID
        // even if other complementary object are used as 'source'
        id: null,
        
        startTime: null,
        endTime: null,
        
        // CommonEvent fields:
        summary: 'New booking',
        description: null,
        
        // Event specific fields:
        isAllDay: false,

        // Fields specific for bookings
        price: 0,
        // Actual bookings fields to use on post/put
        customerUserID: null,
        pricing: {
            Model: PricingEstimateDetail,
            isArray: true
        },
        addressID: null,
        preNotesToClient: null,
        postNotesToClient: null,
        preNotesToSelf: null,
        postNotesToSelf: null,
        
        jobTitleID: 0,
        
        readOnly: false,
        
        sourceEvent: {
            Model: CalendarEvent,
            defaultValue: null
        },
        sourceBooking: {
            Model: Booking,
            defaultValue: null
        }
        //sourceBookingRequest, maybe future?
    }, values);

    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').calendar();
        
    }, this);
    
    this.displayedStartTime = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedEndTime = ko.pureComputed(function() {
        
        return moment(this.endTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedTimeRange = ko.pureComputed(function() {
        
        return this.displayedStartTime() + '-' + this.displayedEndTime();
        
    }, this);
    
    this.itStarted = ko.pureComputed(function() {
        return (this.startTime() && new Date() >= this.startTime());
    }, this);
    
    this.itEnded = ko.pureComputed(function() {
        return (this.endTime() && new Date() >= this.endTime());
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        return (!this.id());
    }, this);
    
    this.stateHeader = ko.pureComputed(function() {
        
        var text = '';
        if (this.id() > 0 && this.sourceEvent()) {
            if (!this.sourceBooking()) {
                text = 'Calendar block';
            }
            else if (this.itStarted()) {
                if (this.itEnded()) {
                    text = 'Completed';
                }
                else {
                    text = 'Now';
                }
            }
            else {
                text = 'Upcoming';
            }
        }

        return text;
        
    }, this);
}

module.exports = Appointment;

/**
    Creates an appointment instance from a CalendarEvent model instance
**/
Appointment.fromCalendarEvent = function fromCalendarEvent(event) {
    var apt = new Appointment();
    
    // Include event in apt
    apt.id(event.calendarEventID());
    apt.startTime(event.startTime());
    apt.endTime(event.endTime());
    apt.summary(event.summary());
    apt.description(event.description());
    apt.isAllDay(event.isAllDay());
    apt.readOnly(event.readOnly());
    apt.sourceEvent(event);
    
    return apt;
};

/**
    Creates an appointment instance from a Booking and a CalendarEvent model instances
**/
Appointment.fromBooking = function fromBooking(booking, event) {
    // Include event in apt
    var apt = Appointment.fromCalendarEvent(event);
    
    // Include booking in apt
    apt.customerUserID(booking.bookingRequest().customerUserID());
    apt.addressID(booking.bookingRequest().addressID());
    apt.jobTitleID(booking.bookingRequest().jobTitleID());
    apt.pricing(booking.bookingRequest().pricingEstimate().details());
    apt.preNotesToClient(booking.preNotesToClient());
    apt.postNotesToClient(booking.postNotesToClient());
    apt.preNotesToSelf(booking.preNotesToSelf());
    apt.postNotesToSelf(booking.postNotesToSelf());
    
    // On bookings, readOnly must set to false (is sent as true ever from
    // the server, to prevent direct manipulation of the event that is part of
    // a booking
    apt.readOnly(false);

    var prices = booking.bookingRequest() && booking.bookingRequest().pricingEstimate();
    if (prices) {
        // TODO Setting freelancer price, for customers must be
        // just totalPrice()
        apt.price(prices.totalPrice() - prices.pFeePrice());
    }

    apt.sourceBooking(booking);

    return apt;
};

/**
    Creates a list of appointment instances from the list of events and bookings.
    The bookings list must contain every booking that belongs to the events of type
    'booking' from the list of events.
**/
Appointment.listFromCalendarEventsBookings = function listFromCalendarEventsBookings(events, bookings) {
    return events.map(function(event) {
        var booking = null;
        bookings.some(function(searchBooking) {
            var found = searchBooking.confirmedDateID() === event.calendarEventID();
            if (found) {
                booking = searchBooking;
                return true;
            }
        });

        if (booking)
            return Appointment.fromBooking(booking, event);
        else
            return Appointment.fromCalendarEvent(event);
    });
};

Appointment.specialIds = {
    loading: 0,
    emptyDate: -1,
    free: -2,
    newEvent: -3,
    newBooking: -4,
    unavailable: -5,
    preparationTime: -6
};

var Time = require('../utils/Time');
/**
    Creates an Appointment instance that represents a calendar slot of
    free/spare time, for the given time range, or the full given date.
    @param options:Object {
        date:Date. Optional. Used to create a full date slot or default for start/end
            to date start or date end
        start:Date. Optional. Beggining of the slot
        end:Date. Optional. Ending of the slot
        text:string. Optional ['Free']. To allow external localization of the text.
    }
**/
Appointment.newFreeSlot = function newFreeSlot(options) {
    
    var start = options.start || new Time(options.date, 0, 0, 0),
        end = options.end || new Time(options.date, 0, 0, 0);

    return new Appointment({
        id: Appointment.specialIds.free,

        startTime: start,
        endTime: end,

        summary: options.text || 'Free',
        description: null
    });
};

Appointment.newUnavailableSlot = function newUnavailableSlot(options) {
    
    var start = options.start || new Time(options.date, 0, 0, 0),
        end = options.end || new Time(options.date, 0, 0, 0);

    return new Appointment({
        id: Appointment.specialIds.unavailable,

        startTime: start,
        endTime: end,

        summary: options.text || 'Unavailable',
        description: null
    });
};

Appointment.newPreparationTimeSlot = function newPreparationTimeSlot(options) {

    var start = options.start || new Time(options.date, 0, 0, 0),
        end = options.end || new Time(options.date, 0, 0, 0);

    return new Appointment({
        id: Appointment.specialIds.preparationTime,

        startTime: start,
        endTime: end,

        summary: options.text || 'Preparation time',
        description: null
    });
};
},{"../utils/Time":113,"./Booking":71,"./CalendarEvent":74,"./Model":87,"./PricingEstimateDetail":90,"knockout":false,"moment":false}],71:[function(require,module,exports){
/** Booking model.

    Describes a booking with related BookingRequest 
    and PricingEstimate objects.
 **/
'use strict';

var Model = require('./Model'),
    BookingRequest = require('./BookingRequest');

function Booking(values) {
    
    Model(this);

    this.model.defProperties({
        bookingID: 0,
        bookingRequestID: 0,
        confirmedDateID: null,
        totalPricePaidByCustomer: null,
        totalServiceFeesPaidByCustomer: null,
        totalPaidToFreelancer: null,
        totalServiceFeesPaidByFreelancer: null,
        bookingStatusID: null,
        pricingAdjustmentApplied: false,
        
        preNotesToClient: null,
        postNotesToClient: null,
        preNotesToSelf: null,
        postNotesToSelf: null,
        
        reviewedByFreelancer: false,
        reviewedByCustomer: false,
        
        createdDate: null,
        updatedDate: null,
        
        bookingRequest: new BookingRequest()
    }, values);
}

module.exports = Booking;

},{"./BookingRequest":72,"./Model":87}],72:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model'),
    PricingEstimate = require('./PricingEstimate');

module.exports = function BookingRequest(values) {
    
    Model(this);

    this.model.defProperties({
        bookingRequestID: 0,
        bookingTypeID: 0,
        customerUserID: 0,
        freelancerUserID: 0,
        jobTitleID: 0,
        pricingEstimateID: 0,
        bookingRequestStatusID: 0,
        
        specialRequests: null,
        preferredDateID: null,
        alternativeDate1ID: null,
        alternativeDate2ID: null,
        addressID: null,
        cancellationPolicyID: null,
        instantBooking: false,
        
        createdDate: null,
        updatedDate: null,
        
        pricingEstimate: new PricingEstimate()
    }, values);
};

},{"./Model":87,"./PricingEstimate":89}],73:[function(require,module,exports){
/** BookingSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');
    
function BookingSummary(values) {
    
    Model(this);

    this.model.defProperties({
        quantity: 0,
        concept: '',
        time: null,
        timeFormat: ' [@] h:mma'
    }, values);

    this.phrase = ko.pureComputed(function(){
        var t = this.timeFormat() && 
            this.time() && 
            moment(this.time()).format(this.timeFormat()) ||
            '';        
        return this.concept() + t;
    }, this);

    this.url = ko.pureComputed(function() {
        var url = this.time() &&
            '/calendar/' + this.time().toISOString();
        
        return url;
    }, this);
}

module.exports = BookingSummary;

},{"./Model":87,"knockout":false,"moment":false}],74:[function(require,module,exports){
/**
    Event model
**/
'use strict';

/* Example JSON (returned by the REST API):
{
  "EventID": 353,
  "UserID": 141,
  "EventTypeID": 3,
  "Summary": "Housekeeper services for John D.",
  "AvailabilityTypeID": 3,
  "StartTime": "2014-03-25T08:00:00Z",
  "EndTime": "2014-03-25T18:00:00Z",
  "Kind": 0,
  "IsAllDay": false,
  "TimeZone": "01:00:00",
  "Location": "null",
  "UpdatedDate": "2014-10-30T15:44:49.653",
  "CreatedDate": null,
  "Description": "test description of a REST event",
  "RecurrenceRule": {
    "FrequencyTypeID": 502,
    "Interval": 1,
    "Until": "2014-07-01T00:00:00",
    "Count": null,
    "Ending": "date",
    "SelectedWeekDays": [
      1,
    ],
    "MonthlyWeekDay": false,
    "Incompatible": false,
    "TooMany": false
  },
  "RecurrenceOccurrences": null,
  "ReadOnly": false
}*/

var Model = require('./Model');

function RecurrenceRule(values) {
    Model(this);
    
    this.model.defProperties({
        frequencyTypeID: 0,
        interval: 1, //:Integer
        until: null, //:Date
        count: null, //:Integer
        ending: null, // :string Possible values allowed: 'never', 'date', 'ocurrences'
        selectedWeekDays: [], // :integer[] 0:Sunday
        monthlyWeekDay: false,
        incompatible: false,
        tooMany: false
    }, values);
}

function RecurrenceOccurrence(values) {
    Model(this);
    
    this.model.defProperties({
        startTime: null, //:Date
        endTime: null //:Date
    }, values);
}
   
function CalendarEvent(values) {
    
    Model(this);
    
    // Special values: dates must be converted
    // to a Date object. They come as ISO string
    // TODO: Make this something generic, or even in Model definitions,
    // and use for updated/createdDate around all the project
    if (values) {
        values.startTime = values.startTime && new Date(Date.parse(values.startTime)) || null;
        values.endTime = values.endTime && new Date(Date.parse(values.endTime)) || null;
    }

    this.model.defProperties({
        calendarEventID: 0,
        userID: 0,
        eventTypeID: 3,
        summary: '',
        availabilityTypeID: 0,
        startTime: null,
        endTime: null,
        kind: 0,
        isAllDay: false,
        timeZone: 'Z',
        location: null,
        updatedDate: null,
        createdDate: null,
        description: '',
        readOnly: false,
        recurrenceRule: {
            Model: RecurrenceRule
        },
        recurrenceOccurrences: {
            isArray: true,
            Model: RecurrenceOccurrence
        }
    }, values);
}

module.exports = CalendarEvent;

CalendarEvent.RecurrenceRule = RecurrenceRule;
CalendarEvent.RecurrenceOccurrence = RecurrenceOccurrence;

},{"./Model":87}],75:[function(require,module,exports){
/**
    CalendarSyncing model.
 **/
'use strict';

var Model = require('./Model');

function CalendarSyncing(values) {

    Model(this);

    this.model.defProperties({
        icalExportUrl: '',
        icalImportUrl: ''
    }, values);
}

module.exports = CalendarSyncing;

},{"./Model":87}],76:[function(require,module,exports){
/** Customer model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

function Customer(values) {
    
    Model(this);
    
    this.model.defProperties({
        customerUserID: 0,
        
        firstName: '',
        lastName: '',
        secondLastName: '',
        email: '',
        phone: null,
        canReceiveSms: false,
        birthMonthDay: null,
        birthMonth: null,
        
        notesAboutCustomer: null,
        
        createdDate: null,
        updatedDate: null,
        editable: false
    }, values);

    this.fullName = ko.pureComputed(function() {
        return ((this.firstName() || '') + ' ' + (this.lastName() || ''));
    }, this);
    
    this.birthDay = ko.pureComputed(function() {
        if (this.birthMonthDay() &&
            this.birthMonth()) {
            
            // TODO i10n
            return this.birthMonth() + '/' + this.birthMonthDay();
        }
        else {
            return null;
        }
    }, this);
}

module.exports = Customer;

},{"./Model":87,"knockout":false}],77:[function(require,module,exports){
/**
    Keeps a date availability object that includes a list of appointments
    that fills all the times in the date (following the weekDaySchedule and free/unavailable
    times) and summary of the availability status of the date.
    Updating the main properties: appointmentsList, date, weekDaySchedule, the complete
    list and summaries auto calculate to show the proper listing.
**/
'use strict';

var Model = require('../models/Model');
var Appointment = require('../models/Appointment'),
    WeekDaySchedule = require('../models/WeekDaySchedule'),
    SchedulingPreferences = require('../models/SchedulingPreferences'),
    moment = require('moment'),
    ko = require('knockout'),
    availabilityCalculation = require('../utils/availabilityCalculation'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

function DateAvailability(values) {

    Model(this);
    
    this.model.defProperties({
        date: null, // Date
        weekDaySchedule: {
            Model: WeekDaySchedule
        },
        appointmentsList: {
            isArray: true,
            Model: Appointment
        },
        schedulingPreferences: {
            Model: SchedulingPreferences
        }
    }, values);
    
    /**
        :array<Appointment> List of appointments for all the times in the date.
        It introduces free and unavailable appointments using appointmentsList as base
        for actual *busy* appointments and the rules of weekDaySchedule
    **/
    this.list = ko.pureComputed(function() {
        return availabilityCalculation.fillDayAvailability(
            this.date(), this.appointmentsList(), this.weekDaySchedule(), this.schedulingPreferences()
        );
    }, this);

    /**
        :int
        Number of minutes scheduled for work in a generic/empty day
        based on the information at weekDaySchedule.
    **/
    this.workDayMinutes = ko.pureComputed(function() {
        var schedule = this.weekDaySchedule();
        // from-to are minutes of the day, so its easy to calculate
        return (schedule.to() - schedule.from()) |0;
    }, this);

    /**
        :int
        Number of minutes available to be scheduled in this date
        inside the work time (weekDaySchedule.
        It's the sum of all 'Free' appointments in the date.
    **/
    this.availableMinutes = ko.pureComputed(function() {
        return this.list().reduce(function(minutes, apt) {
            if (apt.id() === Appointment.specialIds.free) {
                var et = moment(apt.endTime()),
                    st = moment(apt.startTime());
                minutes += et.diff(st, 'minutes');
            }
            return minutes;
        }, 0);
    }, this);

    /**
        :int
        Percentage number from 0 to 100 of time
        available time in the date (availableMinutes / workDayMinutes)
    **/
    this.availablePercent = ko.pureComputed(function() {
        return (Math.round((this.availableMinutes() / this.workDayMinutes()) * 100));
    }, this);

    /**
        :string
        A text value from an enumeration that represents
            ranges of availablePercent, suitable for high level use as CSS classes.
            Special case on past date-time, when it returns 'past' rather than the
            availability, since past times are not availabile for anything new (can't change the past! ;-)
            Can be: 'none', 'low', 'medium', 'full', 'past'
    **/
    this.availableTag = ko.pureComputed(function() {
        var perc = this.availablePercent(),
            date = this.date(),
            today = getDateWithoutTime();

        if (date < today)
            return 'past';
        else if (perc >= 100)
            return 'full';
        else if (perc >= 50)
            return 'medium';
        else if (perc > 0)
            return 'low';
        else // <= 0
            return 'none';
    }, this);
    
    /**
        Retrieve a list of date-times that are free, available to be used,
        in this date with a separation between each of the given slotSize
        in minutes or using the default from the scheduling preferences
        included in the object.

        The parameter 'duration' (in minutes) allows that returned slots
        are free almost for the given duration. This allows to choose times
        that fit the needed service duration.
    **/
    this.getFreeTimeSlots = function getFreeTimeSlots(duration, slotSizeMinutes) {
        
        slotSizeMinutes = slotSizeMinutes || this.schedulingPreferences().incrementsSizeInMinutes();
        
        if (!duration)
            duration = slotSizeMinutes;
        
        var date = this.date(),
            today = getDateWithoutTime();
    
        // Quick return if with empty list when
        // - past date (no time)
        // - no available time (already computed)
        if (date < today ||
            this.availableMinutes() <= 0) {
            return [];
        }
        else {
            var slots = [];
            // Iterate every free appointment
            this.list().forEach(function (apt) {
                if (apt.id() === Appointment.specialIds.free) {
                    slots.push.apply(slots, createTimeSlots(apt.startTime(), apt.endTime(), slotSizeMinutes, duration));
                }
            });
            return slots;
        }
    };
}

module.exports = DateAvailability;

/**
    It creates slots between the given times and size for each one.
    Past times are avoided, because are not available
**/
function createTimeSlots(from, to, size, duration) {
    var i = moment(from),
        d,
        slots = [],
        now = new Date(),
        enought;

    // Shortcut if bad 'to' (avoid infinite loop)
    if (to <= from)
        return slots;

    while(i.toDate() < to) {
        d = i.clone().toDate();
        enought = i.clone().add(duration, 'minutes').toDate();
        // Check that:
        // - is not a past date
        // - it has enought time in advance to fill the expected duration
        if (d >= now &&
            enought <= to)
            slots.push(d);
        // Next slot
        i.add(size, 'minutes');
    }
    
    return slots;
}

},{"../models/Appointment":70,"../models/Model":87,"../models/SchedulingPreferences":93,"../models/WeekDaySchedule":100,"../utils/availabilityCalculation":115,"../utils/getDateWithoutTime":121,"knockout":false,"moment":false}],78:[function(require,module,exports){
/**
    Freelancer Pricing model: manages an individual
    pricing/package from the user and a specific job title.
**/
'use strict';

var Model = require('./Model'),
    ko = require('knockout'),
    numeral = require('numeral');

function FreelancerPricing(values) {
    
    Model(this);
    
    this.model.defProperties({
        freelancerPricingID: 0,
        freelancerUserID: 0,
        jobTitleID: 0,
        pricingTypeID: 0,
        name: '',
        description: null,
        price: null,
        serviceDurationMinutes: null,
        firstTimeClientsOnly: false,
        numberOfSessions: 1,
        priceRate: null,
        priceRateUnit: 'hour',
        // Special property, not in source data just only an explicit
        // way to avoid validation of priceRate if not explicit value set
        noPriceRate: false,
        isPhone: false,
        // Array of integers, IDs of serviceAttributes
        serviceAttributes: [],
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['freelancerPricingID']);
    
    // One way effect: set priceRate to null when setting on noPriceRate
    // But nothing on off and no other relations to avoid bad side effects.
    this.noPriceRate.subscribe(function(enabled) {
        if (enabled === true) {
            this.priceRate(null);
        }
    }, this);
    
    /**
        Ask for a refresh of the noPriceRate, that must be 'true' if the record exists and
        has no priceRate (to remember the previous value set by the user about noPriceRate).
        It ensure that the internal timestamp keep untouched.
        Cannot be automatic, so need to be called manually after a data load that does not
        want to reflect this change as a data change.
    **/
    this.refreshNoPriceRate = function refreshNoPriceRate() {
        // Not To State Price Rate: if is a saved pricing, mark the noPriceRate if price rate is
        // null or 0; cannot be done with a subscription on priceRate changes because will have
        // the bad side effect of auto mark noPriceRate on setting 0 on priceRate, breaking the
        // explicit purpose of the noPriceRate checkbox:
        if (this.freelancerPricingID() && (this.priceRate() |0) <= 0) {
            var ts = this.model.dataTimestamp();
            this.noPriceRate(true);
            // Set again timestamp so the model appear as untouched.
            this.model.dataTimestamp(ts);
        }
    };

    // Alternative edition of the serviceDurationMinutes fields:
    // Splited as hours and minutes
    var is = require('is_js');
    this.durationHoursPart = ko.pureComputed({
        read: function() {
            var fullMinutes = this.serviceDurationMinutes();
            
            if (is.not.number(fullMinutes))
                return null;

            return ((fullMinutes|0) / 60) |0;
        },
        write: function(hours) {
            var minutes = this.durationMinutesPart() |0;
            // Value comes from text
            hours = parseInt(hours, 10);
            if (is.not.number(hours))
                this.serviceDurationMinutes(null);
            else
                this.serviceDurationMinutes((hours|0) * 60 + minutes);
        },
        owner: this
    });
    this.durationMinutesPart = ko.pureComputed({
        read: function() {
            var fullMinutes = this.serviceDurationMinutes();

            if (is.not.number(fullMinutes))
                return null;

            return (fullMinutes|0) % 60;
        },
        write: function(minutes) {
            var hours = this.durationHoursPart() |0;
            // Value comes from text
            minutes = parseInt(minutes, 10);
            if (is.not.number(minutes))
                this.serviceDurationMinutes(null);
            else
                this.serviceDurationMinutes(hours * 60 + (minutes|0));
        },
        owner: this
    });
    
    
    /// Visual representation of several fields
    
    this.durationText = ko.pureComputed(function() {
        var minutes = this.serviceDurationMinutes() || 0;
        // TODO: l10n
        return minutes ? numeral(minutes).format('0,0') + ' minutes' : '';
    }, this);
    
    this.sessionsAndDuration = ko.pureComputed(function() {
        var sessions = this.numberOfSessions(),
            dur = this.durationText();
        if (sessions > 1)
            // TODO: l10n
            return sessions + ' sessions, ' + dur;
        else
            return dur;
    }, this);

    this.displayedPrice = ko.pureComputed(function() {
        var price = this.price(),
            rate = this.priceRate(),
            unit = this.priceRateUnit(),
            result = price || rate;
        // Formatting
        result = numeral(result).format('$0,0');
        // If is not price but rate, add unit
        if (!price && rate && unit) {
            result += '/' + unit;
        }
        return result;
    }, this);
}

module.exports = FreelancerPricing;

},{"./Model":87,"is_js":false,"knockout":false,"numeral":false}],79:[function(require,module,exports){
/** GetMore model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    ListViewItem = require('./ListViewItem');

function GetMore(values) {

    Model(this);

    this.model.defProperties({
        availability: false,
        payments: false,
        profile: false,
        coop: true
    }, values);

    var availableItems = {
        availability: new ListViewItem({
            contentLine1: 'Complete your availability to create a cleaner calendar',
            markerIcon: 'fa fa-fw fa-calendar'
        }),
        payments: new ListViewItem({
            contentLine1: 'Start accepting payments through Loconomics',
            markerIcon: 'fa ion ion-card'
        }),
        profile: new ListViewItem({
            contentLine1: 'Activate your profile in the marketplace',
            markerIcon: 'fa ion ion-cash'
        }),
        coop: new ListViewItem({
            contentLine1: 'Learn more about our cooperative',
            actionIcon: 'fa fa-gavel'
        })
    };

    this.items = ko.pureComputed(function() {
        var items = [];
        
        Object.keys(availableItems).forEach(function(key) {
            
            if (this[key]())
                items.push(availableItems[key]);
        }.bind(this));

        return items;
    }, this);
}

module.exports = GetMore;

},{"./ListViewItem":82,"./Model":87,"knockout":false}],80:[function(require,module,exports){
/** JobTitle model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    JobTitlePricingType = require('./JobTitlePricingType');

function JobTitle(values) {
    
    Model(this);
    
    this.model.defProperties({
        jobTitleID: 0,
        singularName: '',
        pluralName: '',
        aliases: '',
        description: null,
        searchDescription: null,
        createdDate: null,
        updatedDate: null
    }, values);

    this.model.defID(['jobTitleID']);

    // TODO: review if, not registered as a property, the list is updated
    // on syncs by using model.updateWith

    // Pricing Types relationship,
    // collection of JobTitlePricingType entities
    this.pricingTypes = ko.observableArray([]);
    if (values && values.pricingTypes) {
        values.pricingTypes.forEach(function(jobpricing) {
            this.pricingTypes.push(new JobTitlePricingType(jobpricing));
        }.bind(this));
    }
}

module.exports = JobTitle;

},{"./JobTitlePricingType":81,"./Model":87,"knockout":false}],81:[function(require,module,exports){
/**
    Defines the relationship between a JobTitle and a PricingType.
**/
'use strict';

var Model = require('./Model');

function JobTitlePricingType(values) {

    Model(this);
    
    this.model.defProperties({
        pricingTypeID: 0,
        // NOTE: Client Type is mostly unused today but exists
        // on all database records. It uses the default value
        // of 1 all the time for now.
        clientTypeID: 1,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['pricingTypeID', 'clientTypeID']);
}

module.exports = JobTitlePricingType;

},{"./Model":87}],82:[function(require,module,exports){
/** ListViewItem model.

    Describes a generic item of a
    ListView component.
 **/
'use strict';

var Model = require('./Model');

function ListViewItem(values) {
    
    Model(this);

    this.model.defProperties({
        markerLine1: null,
        markerLine2: null,
        markerIcon: null,
        
        contentLine1: '',
        contentLine2: null,
        link: '#',

        actionIcon: null,
        actionText: null,
        
        classNames: ''

    }, values);
}

module.exports = ListViewItem;

},{"./Model":87}],83:[function(require,module,exports){
/** MailFolder model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    _ = require('lodash');

function MailFolder(values) {

    Model(this);

    this.model.defProperties({
        messages: [],
        topNumber: 10
    }, values);
    
    this.top = ko.pureComputed(function top(num) {
        if (num) this.topNumber(num);
        return _.first(this.messages(), this.topNumber());
    }, this);
}

module.exports = MailFolder;

},{"./Model":87,"knockout":false,"lodash":false}],84:[function(require,module,exports){
/** MarketplaceProfile model **/
'use strict';

var Model = require('./Model');

function MarketplaceProfile(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        
        publicBio: '',
        freelancerProfileUrlSlug: '',
        // This is a server-side computed variable (read-only for the user) for a Loconomics address
        // created using the freelancerProfileUrlSlug if any or the fallback system URL.
        freelancerProfileUrl: '',
        // Specify an external website of the freelancer.
        freelancerWebsiteUrl: '',
        // Server-side generated code that allows to identificate special booking requests
        // from the book-me-now button. The server ensures that there is ever a value on this for freelancers.
        bookCode: '',

        createdDate: null,
        updatedDate: null
    }, values);
}

module.exports = MarketplaceProfile;

},{"./Model":87}],85:[function(require,module,exports){
/** Message model.

    Describes a message that belongs to a Thread.
    A message could be of different types,
    as inquiries, bookings, booking requests.
 **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');

function Message(values) {
    
    Model(this);

    this.model.defProperties({
        messageID: 0,
        threadID: 0,
        sentByUserID: null,
        typeID: null,
        auxT: null,
        auxID: null,
        bodyText: '',
        
        createdDate: null,
        updatedDate: null
    }, values);
    
    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        return moment(this.createdDate()).locale('en-US-LC').calendar();
    }, this);
    
    this.displayedTime = ko.pureComputed(function() {
        return moment(this.createdDate()).locale('en-US-LC').format('LT');
    }, this);
}

module.exports = Message;

},{"./Model":87,"knockout":false,"moment":false}],86:[function(require,module,exports){
/** Message model.

    Describes a message from a MailFolder.
    A message could be of different types,
    as inquiries, bookings, booking requests.
 **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');

function MessageView(values, app) {
    
    Model(this);

    this.model.defProperties({
        id: 0,
        createdDate: null,
        updatedDate: null,
        
        subject: '',
        content: null,
        link: '#',
        
        tag: '',
        classNames: '',
        
        sourceThread: null,
        sourceMessage: null

    }, values);
    
    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        
        return moment(this.createdDate()).locale('en-US-LC').calendar();
        
    }, this);
    
    this.displayedTime = ko.pureComputed(function() {
        
        return moment(this.createdDate()).locale('en-US-LC').format('LT');

    }, this);
    
    this.quickDateTime = ko.pureComputed(function() {
        var date = this.createdDate();

        var m = moment(date).locale('en-US-LC'),
            t = moment().startOf('day');

        if (m.isAfter(t)) {
            return m.format('LT');
        }
        else {
            return m.fromNow();
        }
    }, this);
    
    this.customer = ko.computed(function() {
        var s = this.sourceMessage();
        if (!s || !app) return null;

        var cid = s.sentByUserID();
        if (cid) {
            if (cid === app.model.userProfile.data.userID())
                return app.model.userProfile.data;
            else
                return app.model.customers.getObservableItem(cid, true)();
        }
        return null;
    }, this)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
}

module.exports = MessageView;

/**
    Creates a MessageView instance from a Thread instance.
    It's better to have almost one message in the thread (the latest
    one first, or the one to highlight) to build a
    more detailed MessageView
**/
MessageView.fromThread = function(app, thread) {
    
    var msg = thread.messages();
    msg = msg && msg[0] || null;
    
    // TODO: more different tag/classes depending on booking state as per design
    // NOTE: That requires to load the booking or request by auxID and wait for it
    var tag, classNames;
    if (msg.auxT() === 'Booking') {
        tag = 'Booking';
        classNames = 'text-success';
    } else if (msg.auxT() === 'BookingRequest') {
        tag = 'Booking request';
        classNames = 'text-warning';
    }
    
    return new MessageView({
        sourceThread: thread,
        sourceMessage: msg,
        id: thread.threadID(),
        createdDate: thread.createdDate(),
        updatedDate: thread.updatedDate(),
        subject: thread.subject(),
        content: msg && msg.bodyText() || '',
        link: '#!/conversation/' + thread.threadID(),
        tag: tag,
        classNames: classNames
    }, app);
};

},{"./Model":87,"knockout":false,"moment":false}],87:[function(require,module,exports){
/**
    Model class to help build models.

    Is not exactly an 'OOP base' class, but provides
    utilities to models and a model definition object
    when executed in their constructors as:
    
    '''
    function MyModel() {
        Model(this);
        // Now, there is a this.model property with
        // an instance of the Model class, with 
        // utilities and model settings.
    }
    '''
    
    That auto creation of 'model' property can be avoided
    when using the object instantiation syntax ('new' keyword):
    
    '''
    var model = new Model(obj);
    // There is no a 'obj.model' property, can be
    // assigned to whatever property or nothing.
    '''
**/
'use strict';
var ko = require('knockout');
ko.mapping = require('knockout.mapping');
var $ = require('jquery');
var clone = function(obj) { return $.extend(true, {}, obj); };
var cloneValue = function(val, deepCopy) {
    /*jshint maxcomplexity: 10*/
    if (typeof(val) === 'object') {
        // A Date object is a special case: even being
        // an object, treat as a basic type, being copied as
        // a new instance independent of the deepCopy option
        if (val instanceof Date) {
            // A date clone
            return new Date(val);
        }
        else if (deepCopy === true) {
            if (val instanceof Array) {
                return val.map(function(item) {
                    return cloneValue(item, true);
                });
            }
            else if (val === null) {
                return null;
            }
            else if (val && val.model instanceof Model) {
                // A model copy
                return val.model.toPlainObject(deepCopy);
            }
            else {
                // Plain 'standard' object clone
                return clone(val);
            }
        }
        else if (deepCopy === false) {
            // Shallow copy
            return val;
        }
        // On else, left undefined, no references, no clones,
        // discarded value
        return undefined;
    }
    else {
        // A basic type value is already copied/cloned by javascript
        // on every assignment
        return val;
    }
};

function Model(modelObject) {
    
    if (!(this instanceof Model)) {
        // Executed as a function, it must create
        // a Model instance
        var model = new Model(modelObject);
        // and register automatically as part
        // of the modelObject in 'model' property
        modelObject.model = model;
        
        // Returns the instance
        return model;
    }
 
    // It includes a reference to the object
    this.modelObject = modelObject;
    // It maintains a list of properties and fields
    this.propertiesList = [];
    this.fieldsList = [];
    this.propertiesDefs = {};
    this.fieldsDefs = {};
    // It allow setting the 'ko.mapping.fromJS' mapping options
    // to control conversions from plain JS objects when 
    // 'updateWith'.
    this.mappingOptions = {};
    
    // Timestamp with the date of last change
    // in the data (automatically updated when changes
    // happens on properties; fields or any other member
    // added to the model cannot be observed for changes,
    // requiring manual updating with a 'new Date()', but is
    // better to use properties.
    // Its rated to zero just to avoid that consecutive
    // synchronous changes emit lot of notifications, specially
    // with bulk tasks like 'updateWith'.
    this.dataTimestamp = ko.observable(new Date()).extend({ rateLimit: 0 });
}

module.exports = Model;

/**
    Internal utility to map a value given its property/field
    definition
**/
function prepareValueByDef(val, def) {
    if (def.isArray && 
        !Array.isArray(val)) {
        if (typeof(val) !== 'undefined')
            val = [val];
        else
            val = [];
    }
    if (def && def.Model) {
        if (Array.isArray(val)) {
            val = val.map(function(item) {
                if (item instanceof def.Model ||
                    item === null ||
                    typeof(item) === 'undefined') {
                    // 'as is'
                    return item;
                }
                else {
                    return new def.Model(item);
                }
            });
        }
        else {
            if (!(val instanceof def.Model) &&
                val !== null &&
                typeof(val) !== 'undefined') {
                val = new def.Model(val);
            }
        }
    }
    return val;
}

function createDef(givenVal, initialVal) {
    
    var def,
        isModel = givenVal && givenVal.model instanceof Model,
        isArray = Array.isArray(givenVal),
        isObject = typeof(givenVal) === 'object' && !(givenVal instanceof Date);

    if (givenVal !== null && !isModel && isObject && !isArray) {
        def = givenVal;
    }
    else {
        def = {
            defaultValue: givenVal,
            isArray: isArray
        };
        if (isModel)
            def.Model = givenVal.constructor;
    }
    
    initialVal = typeof(initialVal) === 'undefined' ? def.defaultValue : initialVal;
    def.initialValue = prepareValueByDef(initialVal, def);
    
    return def;
}

/**
    Define observable properties using the given
    properties object definition that includes de default values,
    and some optional initialValues (normally that is provided externally
    as a parameter to the model constructor, while default values are
    set in the constructor).
    That properties become members of the modelObject, simplifying 
    model definitions.
    
    It uses Knockout.observable and observableArray, so properties
    are funtions that reads the value when no arguments or sets when
    one argument is passed of.
**/
Model.prototype.defProperties = function defProperties(properties, initialValues) {

    initialValues = initialValues || {};

    var modelObject = this.modelObject,
        propertiesList = this.propertiesList,
        defs = this.propertiesDefs,
        dataTimestamp = this.dataTimestamp;

    Object.keys(properties).forEach(function(key) {
        
        // Create and register definition
        var def = createDef(properties[key], initialValues[key]);
        defs[key] = def;

        // Create the observable property
        modelObject[key] = Array.isArray(def.initialValue) ?
            ko.observableArray(def.initialValue) :
            ko.observable(def.initialValue);

        // Remember default
        modelObject[key]._defaultValue = def.defaultValue;
        // remember initial
        modelObject[key]._initialValue = def.initialValue;    
        
        // Add subscriber to update the timestamp on changes
        modelObject[key].subscribe(function() {
            dataTimestamp(new Date());
        });
        
        // Add to the internal registry
        propertiesList.push(key);
    });
    
    // Update timestamp after the bulk creation.
    dataTimestamp(new Date());
};

/**
    Define fields as plain members of the modelObject using
    the fields object definition that includes default values,
    and some optional initialValues.
    
    Its like defProperties, but for plain js values rather than observables.
**/
Model.prototype.defFields = function defFields(fields, initialValues) {

    initialValues = initialValues || {};

    var modelObject = this.modelObject,
        defs = this.fieldsDefs,
        fieldsList = this.fieldsList;

    Object.keys(fields).each(function(key) {
        
        // Create and register definition
        var def = createDef(fields[key], initialValues[key]);
        defs[key] = def;
        
        // Create field with initial value
        modelObject[key] = def.initialValue;
        
        // Add to the internal registry
        fieldsList.push(key);
    });
};

/**
    Store the list of fields that make the ID/primary key
    and create an alias 'id' property that returns the
    value for the ID field or array of values when multiple
    fields.
**/
Model.prototype.defID = function defID(fieldsNames) {
    
    // Store the list
    this.idFieldsNames = fieldsNames;
    
    // Define ID observable
    if (fieldsNames.length === 1) {
        // Returns single value
        var field = fieldsNames[0];
        this.modelObject.id = ko.pureComputed(function() {
            return this[field]();
        }, this.modelObject);
    }
    else {
        this.modelObject.id = ko.pureComputed(function() {
            return fieldsNames.map(function(fieldName) {
                return this[fieldName]();
            }.bind(this));
        }, this.modelObject);
    }
};

/**
    Allows to register a property (previously defined) as 
    the model timestamp, so gets updated on any data change
    (keep in sync with the internal dataTimestamp).
**/
Model.prototype.regTimestamp = function regTimestampProperty(propertyName) {

    var prop = this.modelObject[propertyName];
    if (typeof(prop) !== 'function') {
        throw new Error('There is no observable property with name [' + 
                        propertyName + 
                        '] to register as timestamp.'
       );
    }
    // Add subscriber on internal timestamp to keep
    // the property updated
    this.dataTimestamp.subscribe(function(timestamp) {
        prop(timestamp);
    });
};

/**
    Returns a plain object with the properties and fields
    of the model object, just values.
    
    @param deepCopy:bool If left undefined, do not copy objects in
    values and not references. If false, do a shallow copy, setting
    up references in the result. If true, to a deep copy of all objects.
**/
Model.prototype.toPlainObject = function toPlainObject(deepCopy) {

    var plain = {},
        modelObj = this.modelObject;

    function setValue(property, val) {
        var clonedValue = cloneValue(val, deepCopy);
        if (typeof(clonedValue) !== 'undefined') {
            plain[property] = clonedValue;
        }
    }

    this.propertiesList.forEach(function(property) {
        // Properties are observables, so functions without params:
        var val = modelObj[property]();

        setValue(property, val);
    });

    this.fieldsList.forEach(function(field) {
        // Fields are just plain object members for values, just copy:
        var val = modelObj[field];

        setValue(field, val);
    });

    return plain;
};

Model.prototype.updateWith = function updateWith(data, deepCopy) {
    
    // We need a plain object for 'fromJS'.
    // If is a model, extract their properties and fields from
    // the observables (fromJS), so we not get computed
    // or functions, just registered properties and fields
    var timestamp = null;
    if (data && data.model instanceof Model) {

        // We need to set the same timestamp, so
        // remember for after the fromJS
        timestamp = data.model.dataTimestamp();
        
        // Replace data with a plain copy of itself
        data = data.model.toPlainObject(deepCopy);
    }

    var target = this.modelObject,
        defs = this.propertiesDefs;
    this.propertiesList.forEach(function(property) {
        var val = data[property],
            def = defs[property];
        if (typeof(val) !== 'undefined') {
            target[property](prepareValueByDef(val, def));
        }
    });

    defs = this.fieldsDefs;
    this.fieldsList.forEach(function(field) {
        var val = data[field],
            def = defs[field];
        if (typeof(val) !== 'undefined') {
            target[field] = prepareValueByDef(val, def);
        }
    });

    // Same timestamp if any
    if (timestamp)
        this.modelObject.model.dataTimestamp(timestamp);
};

/**
    Given a plain object in a accepted import structure
    (never a Model instance), it maps
    the data to the object following a set of mapping options
    of ko.mapping.
    If the data is a representation of the model by 'toPlainObject'
    then use 'updateWith' better.
    
    TODO: Review, not used still, no sure if really useful to depend
    on ko.mapping and this.
**/
Model.prototype.mapData = function mapData(data, optionalMapping) {
    ko.mapping.fromJS(data, optionalMapping || this.mappingOptions, this.modelObject);
};

Model.prototype.clone = function clone(data, deepCopy) {
    // Get a plain object with the object data
    var plain = this.toPlainObject(deepCopy);
    // Create a new model instance, using the source plain object
    // as initial values
    var cloned = new this.modelObject.constructor(plain);
    if (data) {
        // Update the cloned with the provided plain data used
        // to replace values on the cloned one, for quick one-step creation
        // of derived objects.
        cloned.model.updateWith(data);
    }
    else {
        // Since there is no initial differential data, ensure the
        // same timestamp since the clone is still identical to the source
        cloned.model.dataTimestamp(this.modelObject.model.dataTimestamp());
    }
    // Cloned model ready:
    return cloned;
};

/**
    Updates the dataTimestamp to the current unique datetime,
    so the model appear as touched/updated, even if not data change.
    Useful sometimes to make a difference from a cloned instance
    so appear different.
    NOTE: the datetime set is not exactly the current one, is the current
    number of milliseconds plus one,
    to ensure that the timestamp is different on edge cases where this
    method is called just after a creation or clonation, because the way
    javascript works and the limited milliseconds precision of the Date object
    there is a chance that the 'touched' date will be the same as before,
    thats avoided with this simple trick, so remains 'unique' in the current execution.
**/
Model.prototype.touch = function touch() {
    // We use the function way to get milliseconds, add 1 and create instance
    this.dataTimestamp(new Date(Date() + 1));
};

/**
    Replaces all the properties and fields data in the model object
    with the default ones of the constructor, plus optional new preset data.
**/
Model.prototype.reset = function reset(presets) {
    
    var newInstance = new this.modelObject.constructor(presets);

    this.updateWith(newInstance, true);
};

},{"knockout":false,"knockout.mapping":false}],88:[function(require,module,exports){
/** PerformanceSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    ListViewItem = require('./ListViewItem'),
    moment = require('moment'),
    numeral = require('numeral');

function PerformanceSummary(values) {

    Model(this);

    values = values || {};
    
    // TODO: define earnings and timeBooking as properties with def.Model?

    this.earnings = new Earnings(values.earnings);
    
    var earningsLine = new ListViewItem();
    earningsLine.markerLine1 = ko.computed(function() {
        var num = numeral(this.currentAmount()).format('$0,0');
        return num;
    }, this.earnings);
    earningsLine.contentLine1 = ko.computed(function() {
        return this.currentConcept();
    }, this.earnings);
    earningsLine.markerLine2 = ko.computed(function() {
        var num = numeral(this.nextAmount()).format('$0,0');
        return num;
    }, this.earnings);
    earningsLine.contentLine2 = ko.computed(function() {
        return this.nextConcept();
    }, this.earnings);
    

    this.timeBooked = new TimeBooked(values.timeBooked);

    var timeBookedLine = new ListViewItem();
    timeBookedLine.markerLine1 = ko.computed(function() {
        var num = numeral(this.percent()).format('0%');
        return num;
    }, this.timeBooked);
    timeBookedLine.contentLine1 = ko.computed(function() {
        return this.concept();
    }, this.timeBooked);
    
    
    this.items = ko.pureComputed(function() {
        var items = [];
        
        items.push(earningsLine);
        items.push(timeBookedLine);

        return items;
    }, this);
}

module.exports = PerformanceSummary;

function Earnings(values) {

    Model(this);
    
    this.model.defProperties({
    
         currentAmount: 0,
         currentConceptTemplate: 'already paid this month',
         nextAmount: 0,
         nextConceptTemplate: 'projected {month} earnings'

    }, values);
    
    this.currentConcept = ko.pureComputed(function() {

        var month = moment().format('MMMM');
        return this.currentConceptTemplate().replace(/\{month\}/, month);

    }, this);

    this.nextConcept = ko.pureComputed(function() {

        var month = moment().add(1, 'month').format('MMMM');
        return this.nextConceptTemplate().replace(/\{month\}/, month);

    }, this);
}

function TimeBooked(values) {

    Model(this);
    
    this.model.defProperties({
    
        percent: 0,
        conceptTemplate: 'of available time booked in {month}'
    
    }, values);
    
    this.concept = ko.pureComputed(function() {

        var month = moment().add(1, 'month').format('MMMM');
        return this.conceptTemplate().replace(/\{month\}/, month);

    }, this);
}

},{"./ListViewItem":82,"./Model":87,"knockout":false,"moment":false,"numeral":false}],89:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model'),
    PricingEstimateDetail = require('./PricingEstimateDetail');

module.exports = function PricingEstimate(values) {
    
    Model(this);

    this.model.defProperties({
        pricingEstimateID: 0,
        pricingEstimateRevision: 0,
        serviceDurationHours: null,
        firstSessionDurationHours: null,
        subtotalPrice: null,
        feePrice: null,
        totalPrice: null,
        pFeePrice: null,
        subtotalRefunded: null,
        feeRefunded: null,
        totalRefunded: null,
        dateRefunded: null,
        
        createdDate: null,
        updatedDate: null,
        
        details: {
            Model: PricingEstimateDetail,
            isArray: true
        }
    }, values);
};

},{"./Model":87,"./PricingEstimateDetail":90}],90:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model');

module.exports = function PricingEstimateDetail(values) {
    
    Model(this);

    this.model.defProperties({
        freelancerPricingID: 0,
        freelancerPricingDataInput: null,
        customerPricingDataInput: null,
        hourlyPrice: null,
        subtotalPrice: null,
        feePrice: null,
        totalPrice: null,
        serviceDurationHours: null,
        firstSessionDurationHours: null,
        
        createdDate: null,
        updatedDate: null
    }, values);
};

},{"./Model":87}],91:[function(require,module,exports){
/**
    Pricing Type model
**/
'use strict';

var Model = require('./Model');

function PricingType(values) {
    
    Model(this);
    
    this.model.defProperties({
        pricingTypeID: 0,
        singularName: '',
        pluralName: '',
        slugName: '',
        addNewLabel: null,
        freelancerDescription: null,
        // PriceCalculationType enumeration value:
        priceCalculation: null,
        isAddon: false,
        
        // Form Texts
        namePlaceHolder: null,
        suggestedName: null,
        fixedName: null,
        durationLabel: null,
        priceLabel: null,
        priceNote: null,
        firstTimeClientsOnlyLabel: null,
        descriptionPlaceHolder: null,
        priceRateQuantityLabel: null,
        priceRateUnitLabel: null,
        noPriceRateLabel: null,
        numberOfSessionsLabel: null,
        inPersonPhoneLabel: null,
        
        // Action And Validation Texts
        successOnDelete: null,
        errorOnDelete: null,
        successOnSave: null,
        errorOnSave: null,
        priceRateIsRequiredValidationError: null,
        priceRateUnitIsRequiredValidationError: null,
        
        // Help Texts
        learnMoreLabel: null,
        learnMoreText: null,
        priceRateLearnMoreLabel: null,
        priceRateLearnMoreText: null,
        noPriceRateLearnMoreLabel: null,
        noPriceRateLearnMoreText: null,
        
        // Additional configuration
        requireDuration: false,
        includeServiceAttributes: false,
        includeSpecialPromotion: false,
        
        // List Texts
        /// SummaryFormat is the default format for summaries (required),
        /// other formats are good for better detail, but depends
        /// on other options configured per type.
        /// Wildcards:
        /// {0}: duration
        /// {1}: sessions
        /// {2}: inperson/phone
        summaryFormat: null,
        summaryFormatMultipleSessions: null,
        summaryFormatNoDuration: null,
        summaryFormatMultipleSessionsNoDuration: null,
        withoutServiceAttributesCustomerMessage: null,
        withoutServiceAttributesFreelancerMessage: null,
        firstTimeClientsOnlyListText: null,
        priceRateQuantityListLabel: null,
        priceRateUnitListLabel: null,
        noPriceRateListMessage: null,
        
        // Booking/PricingEstimate Texts
        /// NameAndSummaryFormat is the default format for summaries with package name (required),
        /// other formats are good for better detail, but depends
        /// on other options configured per type.
        /// Wildcards:
        /// {0}: package name
        /// {1}: duration
        /// {2}: sessions
        /// {3}: inperson/phone
        nameAndSummaryFormat: null,
        nameAndSummaryFormatMultipleSessions: null,
        nameAndSummaryFormatNoDuration: null,
        nameAndSummaryFormatMultipleSessionsNoDuration: null,
        
        // Record maintenance
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['pricingTypeID']);
}

module.exports = PricingType;

// Enumeration:
var PriceCalculationType = {
    FixedPrice: 1,
    HourlyPrice: 2
};

PricingType.PriceCalculationType = PriceCalculationType;

},{"./Model":87}],92:[function(require,module,exports){
/**
    PrivacySettings model
**/
'use strict';

var Model = require('./Model');

function PrivacySettings(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        smsBookingCommunication: false,
        phoneBookingCommunication: false,
        loconomicsCommunityCommunication: false,
        loconomicsDbmCampaigns: false,
        profileSeoPermission: false,
        loconomicsMarketingCampaigns: false,
        coBrandedPartnerPermissions: false,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['userID']);
}

module.exports = PrivacySettings;

},{"./Model":87}],93:[function(require,module,exports){
/**
    SchedulingPreferences model.
 **/
'use strict';

var Model = require('./Model');

function SchedulingPreferences(values) {
    
    Model(this);

    this.model.defProperties({
        advanceTime: 24, // Hours
        betweenTime: 0, // Hours
        incrementsSizeInMinutes: 15
    }, values);
}

module.exports = SchedulingPreferences;

},{"./Model":87}],94:[function(require,module,exports){
/**
    SimplifiedWeeklySchedule model.
    
    Its 'simplified' because it provides an API
    for simple time range per week day,
    a pair of from-to times.
    Good for current simple UI.
    
    The original weekly schedule defines the schedule
    in 15 minutes slots, so multiple time ranges can
    exists per week day, just marking each slot
    as available or unavailable. The AppModel
    will fill this model instances properly making
    any conversion from/to the source data.
 **/
'use strict';

var ko = require('knockout'),
    moment = require('moment-timezone'),
    Model = require('./Model'),
    WeekDaySchedule = require('./WeekDaySchedule');

/**
    It attemps to locate local/system timezone,
    getting the first IANA tzid that matches 
    local setup.
**/
function detectLocalTimezone() {
    var year = new Date().getFullYear(),
        winter = new Date(year, 1, 1),
        winOff = winter.getTimezoneOffset(),
        summer = new Date(year, 6, 1),
        sumOff = summer.getTimezoneOffset(),
        found = null;

    moment.tz.names().some(function(tz) {
        var zone = moment.tz.zone(tz);
        if (zone.offset(winter) === winOff &&
            zone.offset(summer) === sumOff) {
           found = zone;
           return true;
        }
    });

    return found;
}

/**
    Main model defining the week schedule
    per week date, or just set all days times
    as available with a single flag.
**/
function SimplifiedWeeklySchedule(values) {
    
    Model(this);

    this.model.defProperties({
        sunday: new WeekDaySchedule(),
        monday: new WeekDaySchedule(),
        tuesday: new WeekDaySchedule(),
        wednesday: new WeekDaySchedule(),
        thursday: new WeekDaySchedule(),
        friday: new WeekDaySchedule(),
        saturday: new WeekDaySchedule(),
        isAllTime: false,
        timeZone: ''
    }, values);
    
    // Index access
    this.weekDays = [
        this.sunday,
        this.monday,
        this.tuesday,
        this.wednesday,
        this.thursday,
        this.friday,
        this.saturday
    ];
    
    this.timeZoneDisplayName = ko.computed(function() {
        var tzid = this.timeZone(),
            tz = moment.tz(tzid),
            name = tz.tz();
        
        // !moment.tz.zoneExists, just check the name is enough
        if (!name) {
            var localtz = detectLocalTimezone();
            if (localtz)
                tz = moment.tz(localtz.name);
            if (tz)
                name = tz.tz();
            if (name)
                setTimeout(function() {
                    this.timeZone(name);
                }.bind(this), 1);
        }

        if (name)
            return name; // + ' (' + tz.zoneAbbr() + ')';
        else
            return '';
    }, this);
}

module.exports = SimplifiedWeeklySchedule;

},{"./Model":87,"./WeekDaySchedule":100,"knockout":false,"moment-timezone":false}],95:[function(require,module,exports){
/** Thread model.

    Describes a thread of messages.
 **/
'use strict';

var Model = require('./Model'),
    Message = require('./Message');

function Thread(values) {
    
    Model(this);

    this.model.defProperties({
        threadID: 0,
        
        customerUserID: null,
        freelancerUserID: null,
        jobTitleID: null,
        statusID: null,
        subject: null,
        
        messages: {
            isArray: true,
            Model: Message
        },
        
        createdDate: null,
        updatedDate: null        
    }, values);
}

module.exports = Thread;

},{"./Message":85,"./Model":87}],96:[function(require,module,exports){
/** UpcomingBookingsSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    BookingSummary = require('./BookingSummary');

function UpcomingBookingsSummary() {

    Model(this);
    
    // TODO: define today, tomorrow and nextWeek as
    // properties with default Model?
    // Review how update happens on home/dashboard, it can helps
    // to simplify that

    this.today = new BookingSummary({
        concept: 'more today',
        timeFormat: ' [ending @] h:mma'
    });
    this.tomorrow = new BookingSummary({
        concept: 'tomorrow',
        timeFormat: ' [starting @] h:mma'
    });
    this.nextWeek = new BookingSummary({
        concept: 'next week',
        timeFormat: null
    });
    
    this.items = ko.pureComputed(function() {
        var items = [];
        
        //if (this.today.quantity())
        items.push(this.today);
        //if (this.tomorrow.quantity())
        items.push(this.tomorrow);
        //if (this.nextWeek.quantity())
        items.push(this.nextWeek);

        return items;
    }, this);
    
}

module.exports = UpcomingBookingsSummary;

},{"./BookingSummary":73,"./Model":87,"knockout":false}],97:[function(require,module,exports){
/** User model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

// Enum UserType
var UserType = {
    None: 0,
    Anonymous: 1,
    Customer: 2,
    Freelancer: 4,
    Admin: 8,
    LoggedUser: 14,
    User: 15,
    System: 16
};

function User(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        email: '',
        
        firstName: '',
        lastName: '',
        secondLastName: '',
        businessName: '',
        
        alternativeEmail: '',
        phone: '',
        canReceiveSms: '',
        birthMonthDay: null,
        birthMonth: null,
        
        isFreelancer: false,
        isCustomer: false,
        isMember: false,
        isAdmin: false,

        onboardingStep: null,
        accountStatusID: 0,
        createdDate: null,
        updatedDate: null
    }, values);

    this.fullName = ko.pureComputed(function() {
        var nameParts = [this.firstName()];
        if (this.lastName())
            nameParts.push(this.lastName());
        if (this.secondLastName())
            nameParts.push(this.secondLastName);
        
        return nameParts.join(' ');
    }, this);
    
    this.birthDay = ko.pureComputed(function() {
        if (this.birthMonthDay() &&
            this.birthMonth()) {
            
            // TODO i10n
            return this.birthMonth() + '/' + this.birthMonthDay();
        }
        else {
            return null;
        }
    }, this);
    
    this.userType = ko.pureComputed({
        read: function() {
            var c = this.isCustomer(),
                p = this.isFreelancer(),
                a = this.isAdmin();
            
            var userType = 0;
            
            if (this.isAnonymous())
                userType = userType | UserType.Anonymous;
            if (c)
                userType = userType | UserType.Customer;
            if (p)
                userType = userType | UserType.Freelancer;
            if (a)
                userType = userType | UserType.Admin;
            
            return userType;
        },
        /* NOTE: Not required for now:
        write: function(v) {
        },*/
        owner: this
    });
    
    this.isAnonymous = ko.pureComputed(function(){
        return this.userID() < 1;
    }, this);
    
    /**
        It matches a UserType from the enumeration?
    **/
    this.isUserType = function isUserType(type) {
        return (this.userType() & type);
    }.bind(this);
}

module.exports = User;

User.UserType = UserType;

/* Creatint an anonymous user with some pressets */
User.newAnonymous = function newAnonymous() {
    return new User({
        userID: 0,
        email: '',
        firstName: '',
        onboardingStep: null
    });
};

},{"./Model":87,"knockout":false}],98:[function(require,module,exports){
/**
    UserJobTitle model, relationship between an user and a
    job title and the main data attached to that relation.
**/
'use strict';

var Model = require('./Model');

function UserJobTitle(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        jobTitleID: 0,
        intro: null,
        statusID: 0,
        cancellationPolicyID: 0,
        instantBooking: false,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['userID', 'jobTitleID']);
}

module.exports = UserJobTitle;

},{"./Model":87}],99:[function(require,module,exports){
/**
    Enumeration of possible values for VocElementIDs, 
    used to identify sections/components when sending Feedback.
**/
'use strict';

module.exports = {
    general: 0,
    nps: 1,
    signup: 2,
    calendar: 3,
    inbox: 4,
    scheduling: 5,
    cms: 6,
    payments: 7,
    performance: 8,
    marketplaceProfile: 9,
    mobileFriendly: 10, // easy of using mobile/tablet app/web
    desktopFriendly: 11, // easy of using desktop website
    coopBenefits: 12,
    coopFee: 13,
    senseOfCommunity: 14,
    customerServiceAgents: 15,
    helpPages: 16
};

},{}],100:[function(require,module,exports){
/**
    Submodel that is used on the SimplifiedWeeklySchedule
    defining a single week day availability range.
    A full day must have values from:0 to:1440, never
    both as zero because thats considered as not available,
    so is better to use the isAllDay property.
**/
'use strict';

var Model = require('./Model'),
    moment = require('moment'),
    ko = require('knockout');

function WeekDaySchedule(values) {

    Model(this);

    // NOTE: from-to properies as numbers
    // for the minute of the day, from 0 (00:00) to 1439 (23:59)
    this.model.defProperties({
        from: 0,
        to: 0
    }, values);
    
    /**
        It allows to know if this week day is 
        enabled for weekly schedule, just it
        has from-to times.
        It allows to be set as true putting
        a default range (9a-5p) or false 
        setting both as 0p.
        
        Since on write two observables are being modified, and
        both are used in the read, a single change to the 
        value will trigger two notifications; to avoid that,
        the observable is rate limited with an inmediate value,
        son only one notification is received.
    **/
    this.isEnabled = ko.computed({
        read: function() {
            return (
                typeof(this.from()) === 'number' &&
                typeof(this.to()) === 'number' &&
                this.from() < this.to()
            );
        },
        write: function(val) {
            if (val === true) {
                // Default range 9a - 5p
                this.fromHour(9);
                this.toHour(17);
            }
            else {
                this.toHour(0);
                this.from(0);
            }
        },
        owner: this
    }).extend({ rateLimit: 0 });
    
    this.isAllDay = ko.computed({
        read: function() {
            return  (
                this.from() === 0 &&
                this.to() === 1440
            );
        },
        write: function(/*val*/) {
            this.from(0);
            this.to(1440);
        },
        owner: this
    }).extend({ rateLimit: 0 });
    
    // Additional interfaces to get/set the from/to times
    // by using a different data unit or format.
    
    // Integer, rounded-up, number of hours
    this.fromHour = ko.computed({
        read: function() {
            return Math.floor(this.from() / 60);
        },
        write: function(hours) {
            this.from((hours * 60) |0);
        },
        owner: this
    });
    this.toHour = ko.computed({
        read: function() {
            return Math.ceil(this.to() / 60);
        },
        write: function(hours) {
            this.to((hours * 60) |0);
        },
        owner: this
    });
    
    // String, time format ('hh:mm')
    this.fromTime = ko.computed({
        read: function() {
            return minutesToTimeString(this.from() |0);
        },
        write: function(time) {
            this.from(timeStringToMinutes(time));
        },
        owner: this
    });
    this.toTime = ko.computed({
        read: function() {
            return minutesToTimeString(this.to() |0);
        },
        write: function(time) {
            this.to(timeStringToMinutes(time));
        },
        owner: this
    });
}

module.exports = WeekDaySchedule;

//// UTILS,
// TODO Organize or externalize. some copied form appmodel..
/**
    internal utility function 'to string with two digits almost'
**/
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Convert a number of minutes
    in a string like: 00:00:00 (hours:minutes:seconds)
**/
function minutesToTimeString(minutes) {
    var d = moment.duration(minutes, 'minutes'),
        h = d.hours(),
        m = d.minutes(),
        s = d.seconds();
    
    return (
        twoDigits(h) + ':' +
        twoDigits(m) + ':' +
        twoDigits(s)
    );
}

function timeStringToMinutes(time) {
    return moment.duration(time).asMinutes() |0;
}
},{"./Model":87,"knockout":false,"moment":false}],101:[function(require,module,exports){
/**
    Utility to help track the state of cached data
    managing time, preference and if must be revalidated
    or not.
    
    Its just manages meta data, but not the data to be cached.
**/
'use strict';

var moment = require('moment');

function CacheControl(options) {
    
    options = options || {};

    // A number of milliseconds or
    // An object with desired units and amount, all optional,
    // any combination with almost one specified, sample:
    // { years: 0, months: 0, weeks: 0, 
    //   days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }
    this.ttl = moment.duration(options.ttl).asMilliseconds();
    this.latest = options.latest || null;

    this.mustRevalidate = function mustRevalidate() {
        var tdiff = this.latest && new Date() - this.latest || Number.POSITIVE_INFINITY;
        return tdiff > this.ttl;
    };
    
    this.touch = function touch() {
        this.latest = new Date();
    };
}

module.exports = CacheControl;

},{"moment":false}],102:[function(require,module,exports){
/**
    Keep an in memory cache of data organized by date as key-value.
    
    IMPORTANT: Date without time, in ISO format YYYY-MM-DD, using
    local timezone. A change of timezone displayed to the user must
    invalidate the cache (through .clear()).
**/
'use strict';

var moment = require('moment'),
    CacheControl = require('./CacheControl');

module.exports = function DateCache(settings) {
    
    this.Model = settings && settings.Model || null;
    this.ttl = settings && settings.ttl || { minutes: 1 };
    
    this.byDate = {};
    
    this.clear = function() {
        this.byDate = {};
    };
    
    this.getSingle = function(date) {
        var dateKey = date;
        if (date instanceof Date)
            dateKey = moment(date).format('YYYY-MM-DD');
        
        if (this.byDate.hasOwnProperty(dateKey) &&
            !this.byDate[dateKey].control.mustRevalidate()) {

            return this.byDate[dateKey].data;
        }

        return null;
    };
    
    this.remove = function(date) {
        var dateKey = date;
        if (date instanceof Date)
            dateKey = moment(date).format('YYYY-MM-DD');
        delete this.byDate[dateKey];
    };
    
    this.get = function(start, end) {

        var date = new Date(start);
        var resultsPerDate = {},
            holes = [],
            minRequest = null,
            maxRequest = null;

        while (date <= end) {
            var dateKey = moment(date).format('YYYY-MM-DD');
            
            if (this.byDate.hasOwnProperty(dateKey) &&
                !this.byDate[dateKey].control.mustRevalidate()) {
                resultsPerDate[dateKey] = this.byDate[dateKey].data;
            }
            else {
                holes.push(new Date(date));
            }
            // Next date:
            date.setDate(date.getDate() + 1);
        }
        
        // Sort holes
        holes.sort(function(a, b) { return a === b ? 0 : a < b ? -1 : 1; });
        // min hole is the first one
        minRequest = holes.length ? holes[0] : null;
        // max hole is the last one
        maxRequest = holes.length ? holes[holes.length - 1] : null;
        
        return {
            byDate: resultsPerDate,
            holes: holes,
            minHole: minRequest,
            maxHole: maxRequest
        };
    };
    
    this.set = function(date, data) {
        // Date formatting. Provide a formatted date as string is valid too
        var dateKey = date;
        if (date instanceof Date)
            dateKey = moment(date).format('YYYY-MM-DD');
        
        // Update cache
        var c = this.byDate[dateKey];
        if (c && c.data) {
            if (this.Model)
                c.data.model.updateWith(data);
            else
                c.data = data;
        }
        else {
            c = {
                data: this.Model ? new this.Model(data) : data,
                control: new CacheControl({ ttl: this.ttl })
            };
            this.byDate[dateKey] = c;
        }
        c.control.touch();
        return c;
    };
};

},{"./CacheControl":101,"moment":false}],103:[function(require,module,exports){
/**
    New Function method: '_delayed'.
    It returns a new function, wrapping the original one,
    that once its call will delay the execution the given milliseconds,
    using a setTimeout.
    The new function returns 'undefined' since it has not the result,
    because of that is only suitable with return-free functions 
    like event handlers.
    
    Why: sometimes, the handler for an event needs to be executed
    after a delay instead of instantly.
**/
Function.prototype._delayed = function delayed(milliseconds) {
    var fn = this;
    return function() {
        var context = this,
            args = arguments;
        setTimeout(function () {
            fn.apply(context, args);
        }, milliseconds);
    };
};

},{}],104:[function(require,module,exports){
/**
    Extending the Function class with an inherits method.
    
    The initial low dash is to mark it as no-standard.
**/
Function.prototype._inherits = function _inherits(superCtor) {
    this.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: this,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

},{}],105:[function(require,module,exports){
/**
    Fix Function#name on browsers that do not support it (IE9+):
    
    http://stackoverflow.com/a/17056530/1622346    
**/
'use strict';
/*jshint -W068 */
if (!(function f() {}).name) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function() {
            var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
            // For better performance only parse once, and then cache the
            // result through a new accessor for repeated access.
            Object.defineProperty(this, 'name', { value: name });
            return name;
        }
    });
}
},{}],106:[function(require,module,exports){
/**
    GroupListRemoteModel
    Utility class for common code for a data list entity from a remote source,
    with local copy and cache, where the full list is managed per groups,
    without paging/cursor, all the group data on each operation.
**/
'use strict';

var ko = require('knockout'),
    IndexedGroupListCache = require('./IndexedGroupListCache');

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function GroupListRemoteModel(settings) {
    /*jshint maxstatements:28*/
    
    settings = settings || {};
    settings.listTtl = required(settings.listTtl, 'listTtl is required');
    settings.groupIdField = required(settings.groupIdField, 'groupIdField is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    // For now, optional model
    settings.Model = settings.Model || null;
    // Required for API additions
    this.settings = settings;

    this.state = {
        isLoading: ko.observable(false),
        isSyncing: ko.observable(false),
        isSaving: ko.observable(false),
        isDeleting: ko.observable(false)
    };

    var cache = new IndexedGroupListCache({
        listTtl: settings.listTtl,
        groupIdField: settings.groupIdField,
        itemIdField: settings.itemIdField
    });
    
    this.clearCache = cache.clearCache;

    this.state.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving() || this.isDeleting();
    }, this.state);

    /** Data Stores Management: implementation must be replaced, with custom code or using
        the helpers added to the class (see addXxSupport prototype methods).
    **/
    function notImplemented() { throw new Error('Not Implemented'); }
    this.fetchGroupFromLocal = notImplemented;
    this.fetchGroupFromRemote = notImplemented;
    this.pushGroupToLocal = notImplemented;
    this.pushGroupToRemote = notImplemented;
    this.removeItemFromRemote = notImplemented;

    /** API definition **/
    var api = this;

    api.getList = function getList(groupID) {
        var cacheEntry = cache.getGroupCache(groupID);

        if (cacheEntry.control.mustRevalidate()) {
            // No cache data, is first load, try from local
            if (!cacheEntry.list) {
                api.state.isLoading(true);
                // From local
                return this.fetchGroupFromLocal(groupID)
                .then(function(data) {
                    // launch remote for sync
                    api.state.isSyncing(true);
                    var remotePromise = this.fetchGroupFromRemote(groupID)
                    .then(function(serverData) {
                        cache.setGroupCache(groupID, serverData);
                        this.pushGroupToLocal(groupID, serverData);
                        api.state.isSyncing(false);
                        return serverData;
                    }.bind(this));
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                }.bind(this))
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.setGroupCache(groupID, data);
                    this.pushGroupToLocal(groupID, data);
                    api.state.isLoading(false);

                    return data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            } else {
                api.state.isSyncing(true);
                // From remote
                return this.fetchGroupFromRemote(groupID)
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.setGroupCache(groupID, data);
                    this.pushGroupToLocal(groupID, data);
                    api.state.isLoading(false);
                    api.state.isSyncing(false);

                    return data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            }
        }
        else {
            // From cache
            return Promise.resolve(cacheEntry.list);
        }
    };
    
    api.getItem = function getItem(groupID, itemID) {
        // IMPORTANT: To simplify, load all the list (is a short list)
        // and look from its cached index
        // TODO Implement item server look-up. Be careful with cache update,
        // list sorting and state flags.
        return api.getList(groupID)
        .then(function() {
            // Get from cached index
            var cacheItem = cache.getItemCache(groupID, itemID);

            // TODO: Enhance on future with actual look-up by API itemID
            // if not cached, throwing not found from the server (just to avoid
            // minor cases when a new item is not still in the cache if linked
            // from other app data). And keep updated list cache with that
            // items lookup
            if (!cacheItem) {
                console.warn('GroupListRemoteModel Not found', groupID, itemID, settings.Model);
                throw new Error('Not Found');
            }
            return cacheItem.item;
        });
    };

    /**
        Save an item in cache, local and remote.
        Can be new or updated.
        The IDs goes with all the other data, being
        groupID required, itemID required for updates
        but falsy for insertions.
        @param data:object Plain object
    **/
    api.setItem = function setItem(data) {
        api.state.isSaving(true);
        // Send to remote first
        return this.pushGroupToRemote(data)
        .then(function(serverData) {
            // Success! update local copy with returned data
            // IMPORTANT: to use server data here so we get values set
            // by the server, as updates dates and itemID when creating
            // a new item.
            if (serverData) {
                var groupID = serverData[settings.groupIdField];
                // Save in cache
                cache.setItemCache(groupID, serverData[settings.itemIdField], serverData);
                // Save in local storage
                // In local need to be saved all the grouped data, not just
                // the item; since we have the cache list updated, use that
                // full list to save local
                this.pushGroupToLocal(groupID, cache.getGroupCache(groupID).list);
            }
            api.state.isSaving(false);

            return serverData;
        }.bind(this))
        .catch(function(err) {
            api.state.isSaving(false);
            // Rethrow error
            return err;
        });
    };
    
    api.delItem = function delItem(groupID, itemID) {
        
        api.state.isDeleting(true);
        
        // Remove in remote first
        return this.removeItemFromRemote(groupID, itemID)
        .then(function(removedData) {
            // Update cache
            cache.delItemCache(groupID, itemID);
            // Save in local storage
            // In local need to be saved all the grouped data;
            // since we have the cache list updated, use that
            // full list to save local
            this.pushGroupToLocal(groupID, cache.getGroupCache(groupID).list);
            
            api.state.isDeleting(false);
            
            return removedData;
        }.bind(this))
        .catch(function(err) {
            api.state.isDeleting(false);
            // Rethrow error
            return err;
        });
    };
    
    /** Some Utils **/
    
    /**
        Generates and returns an observable inmediately,
        with the cached value or undefined,
        launching an item load that will update the observable
        on ready if there is no cached value.
        A method 'sync' is added to the observable so can be requested
        a data sync/reload on demand.
    **/
    api.getObservableItem = function getObservableItem(groupID, itemID, asModel) {
        // Get first value
        var firstValue = cache.getItemCache(groupID, itemID);
        firstValue = firstValue && firstValue.item || undefined;
        var obs = ko.observable(asModel ? api.asModel(firstValue) : firstValue);
        // Create method 'sync'
        obs.sync = function syncObservableItem() {
            return api.getItem(groupID, itemID)
            .then(function(item) {
                if (asModel)
                    obs().model.updateWith(item);
                else
                    obs(item);
            });
        };
        // First load if no cached value
        if (!firstValue)
            obs.sync();
        // Return
        return obs;
    };
    
    api.asModel = function asModel(object) {
        var Model = this.settings.Model;
        // if is an array, return a list of models
        if (Array.isArray(object)) {
            return object.map(function(item) {
                return new Model(item);
            });
        }
        else {
            return new Model(object);
        }
    };
    
    api.getItemModel = function getItemModel(groupID, itemID) {
        return api.getItem(groupID, itemID)
        .then(function(data) {
            return data ? api.asModel(data) : null;
        });
    };
    
    var ModelVersion = require('../utils/ModelVersion');
    api.getItemVersion = function getItemVersion(groupID, itemID) {
        return api.getItemModel(groupID, itemID)
        .then(function(model) {
            return model ? new ModelVersion(model) : null;
        });
    };
    
    api.newItemVersion = function newItemVersion(values) {
        // New original and version for the model
        var version = new ModelVersion(new this.settings.Model(values));
        // To be sure that the version appear as something 'new', unsaved,
        // we update its timestamp to be different to the original.
        version.version.model.touch();
        return version;
    };
}

module.exports = GroupListRemoteModel;

GroupListRemoteModel.prototype.addLocalforageSupport = function addLocalforageSupport(baseName) {
    var localforage = require('localforage');

    this.fetchGroupFromLocal = function fetchFromLocal(groupID) {
        return localforage.getItem(baseName + groupID);
    };
    this.pushGroupToLocal = function pushToLocal(groupID, data) {
        return localforage.setItem(baseName + groupID, data);
    };
};

GroupListRemoteModel.prototype.addRestSupport = function addRestSupport(restClient, baseUrl) {
    
    this.fetchGroupFromRemote = function fetchFromRemote(groupID) {
        return restClient.get(baseUrl + groupID);
    };
    this.pushGroupToRemote = function pushToRemote(data) {

        var groupID = data[this.settings.groupIdField],
            itemID = data[this.settings.itemIdField],
            method = data[this.settings.itemIdField] ? 'put' : 'post';

        var url = baseUrl + groupID + (
            itemID ? '/' + itemID : ''
        );
        return restClient[method](url, data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(groupID, itemID) {
        return restClient.delete(baseUrl + groupID + '/' + itemID);
    };
};

},{"../utils/ModelVersion":110,"./IndexedGroupListCache":107,"knockout":false,"localforage":false}],107:[function(require,module,exports){
/**
    IndexedGroupListCache manages a in-memory cache for a list
    of objects, grouped by a field and with indexed access to groups
    and items, with cache control.
    
    Settings object as unique parameter:
    listTtl: ttl type constructor. TimeToLife for each group list cache.
    FUTURE: itemTtl: ttl type constructor. TimeToLife for each item cache.
    ttl: ttl type constructor. TimeToLife to use for list and item cache if there is no a more explicit one
    groupIdField: string Name of the field used to group objects
    itemIdField: string Name of the field used to uniquely identify each item
    FUTURE: Model: constructor of type Model.
    
    Note: 'ttl type constructor' can be a number of milliseconds or a value to pass to moment.duration constructor (momentjs module).
**/
'use strict';

var CacheControl = require('./CacheControl');

function createIndex(list, byField) {
    var index = {};
    
    list.forEach(function(item, itemIndex) {
        index[item[byField]] = {
            index: itemIndex,
            item: item
            // Direct referenc, could be a property too auto resolving as
            // something like get item() { return list[itemIndex[item[byField]]] || null; }
        };
    });

    return index;
}

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function IndexedGroupListCache(settings) {
    
    settings = settings || {};
    settings.ttl = settings.ttl || 0;
    settings.listTtl = settings.listTtl || settings.ttl || 0;
    //FUTURE: settings.itemTtl = settings.itemTtl || settings.ttl || 0;
    settings.groupIdField = required(settings.groupIdField, 'groupIdField is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    //FUTURE: settings.Model = settings.Model || throw new Error('A Model is required');
    
    var cache = {/*
        groupIdField: {
            control: CacheControl,
            list: Array,
            index: {
                itemIdField: {
                    index: Integer (index in the list array),
                    item: Object (reference to the item object in the array)
                    // Maybe future: control: CacheControl per item
                },
                ..
            }
        },
        ..
    */};
    
    this.clearCache = function clearCache() {
        cache = {};
    };

    function newCacheEntry(list) {
        return {
            control: new CacheControl({ ttl: settings.listTtl }),
            list: list || null,
            index: list && createIndex(list, settings.itemIdField) || {}
        };
    }

    function setGroupCache(groupID, list) {
        var cacheEntry = cache[groupID];
        if (cacheEntry) {
            cacheEntry.list = list || [];
            cacheEntry.index = createIndex(list || [], settings.itemIdField);
        }
        else {
            cacheEntry = cache[groupID] = newCacheEntry(list);
        }
        cacheEntry.control.latest = new Date();
    }
    
    this.setGroupCache = setGroupCache;

    /**
        Get the cache entry for the Group
    **/
    function getGroupCache(groupID) {
        var cacheEntry = cache[groupID];
        return cacheEntry || newCacheEntry();
    }
    
    this.getGroupCache = getGroupCache;

    /**
        Get the cache entry from the Item
    **/
    function getItemCache(groupID, itemID) {
        var cacheEntry = cache[groupID];
        if (cacheEntry) {
            return cacheEntry.index[itemID] || null;
        }
        else {
            return null;
        }
    }
    
    this.getItemCache = getItemCache;

    function setItemCache(groupID, itemID, item) {
        var cacheEntry = cache[groupID] || newCacheEntry([]);
        
        // Loof for the entry, to update or insert a new one
        var itemEntry = cacheEntry.index[itemID];
        if (itemEntry) {
            // Update entry
            cacheEntry.list[itemEntry.index] = item;
            // Update reference in the index too (is not computed right now)
            itemEntry.item = item;
        }
        else {
            // Add to the list
            var itemIndex = cacheEntry.list.push(item) - 1;
            cacheEntry.index[itemID] = {
                index: itemIndex,
                item: item
            };
        }
    }
    
    this.setItemCache = setItemCache;

    function delItemCache(groupID, itemID) {
        var groupEntry = cache[groupID] || null;
        if (groupEntry) {
            var itemEntry = groupEntry.index[itemID];
            if (itemEntry) {
                // Update list removing the element in place, without holes
                groupEntry.list.splice(itemEntry.index, 1);
                // Update index by:
                // - Remove itemID entry
                delete groupEntry.index[itemID];
                // - Update every entry with an ID greater than the updated,
                // since they are now one position less in the updated list
                Object.keys(groupEntry.index).forEach(function(key) {
                    if (groupEntry.index[key] > itemEntry.index)
                        groupEntry.index[key]--;
                });
            }
        }
    }
    
    this.delItemCache = delItemCache;
    
    function delGroupCache(groupID) {
        var groupEntry = cache[groupID] || null;
        if (groupEntry) {
            // Delete the entry/property
            delete cache[groupID];
        }
    }
    
    this.delGroupCache = delGroupCache;
}

module.exports = IndexedGroupListCache;

},{"./CacheControl":101}],108:[function(require,module,exports){
/**
    IndexedListCache manages a in-memory cache for a list
    of objects, with indexed access to items
    and cache control.
    
    Settings object as unique parameter:
    listTtl: ttl type constructor. TimeToLife for each group list cache.
    FUTURE: itemTtl: ttl type constructor. TimeToLife for each item cache.
    ttl: ttl type constructor. TimeToLife to use for list and item cache if there is no a more explicit one
    itemIdField: string Name of the field used to uniquely identify each item
    Model: constructor of type Model.
    
    Note: 'ttl type constructor' can be a number of milliseconds or a value to pass to moment.duration constructor (momentjs module).
**/
'use strict';

var CacheControl = require('./CacheControl'),
    jsPropertiesTools = require('./jsPropertiesTools'),
    ko = require('knockout');

function createItemIndexEntry(list, itemIndex) {
    return {
        index: itemIndex,
        get item() {
            return list[this.index];
        }
    };
}

function createIndex(list, byField) {
    var index = {};
    
    list.forEach(function(item, itemIndex) {
        index[ko.unwrap(item[byField])] = createItemIndexEntry(list, itemIndex);
    });

    return index;
}

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

/**
    An item adapter receives the old and the new item data and returns
    the item to hold in the list. The returning object can be a reference
    to the same existent object (oldItem) that gets updated with the 
    new values (newItem), or just the newItem or any conversion over the
    raw newItem data.
    This allows to perform changes, add properties, or keep references,
    like creating observables, Models.
    
    This default implementation just returns the newItem.
**/
function defaultItemAdapter(oldItem, newItem) {
    return newItem;
}

function IndexedListCache(settings) {
    
    settings = settings || {};
    settings.ttl = settings.ttl || 0;
    settings.listTtl = settings.listTtl || settings.ttl || 0;
    //FUTURE: settings.itemTtl = settings.itemTtl || settings.ttl || 0;
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    settings.itemAdapter = typeof(settings.itemAdapter) === 'function' ? settings.itemAdapter : defaultItemAdapter;

    // Internal flag to notify if the cache was not used still (no data set)
    // since its instantiation. On first setList will change to false and keep in that state.
    var unused = true;
    // Internal cache management
    var cache = {
        control: new CacheControl({ ttl: settings.listTtl }),
        list: ko.observableArray([]),
        index: {/*
            itemIdField: {
                index: Integer (index in the list array),
                item: Object (property referencing to the item object in the array by its index)
                // Maybe future: control: CacheControl per item
            },
            ..
        */}
    };
    
    this.clearCache = function clearCache() {
        cache.control.latest = null;
        cache.list([]);
        cache.index = {};
        unused = true;
    };

    /**
        Get the cache entry from the Item
    **/
    function getItemCache(itemID) {
        return cache.index[itemID] || null;
    }

    this.getItemCache = getItemCache;

    // Adapt a new item using the itemAdapter and getting the old reference.
    function adaptItem(newItem) {
        var oldItem = getItemCache(ko.unwrap(newItem[settings.itemIdField]));
        return settings.itemAdapter(oldItem, newItem);
    }
    
    // Adapt the each element in the list with the itemAdapter,
    // passing an old reference and the new item on each, and ensuring
    // to return ever an array, even if empty.
    function adaptList(list) {
        return (list || []).map(adaptItem);
    }

    function setList(list) {
        cache.list(adaptList(list));
        cache.index = createIndex(cache.list(), settings.itemIdField);
        cache.control.latest = new Date();
        unused = false;
    }

    // Public, read-only, access to cache info (objects are mutable, but almost the reference
    // cannot be broken; a change in the list instance updates the cache properly).
    jsPropertiesTools.defineGetter(this, 'control', function() { return cache.control; });
    jsPropertiesTools.defineGetter(this, 'list', function() { return cache.list; });
    jsPropertiesTools.defineSetter(this, 'list', function(list) { return setList(list); });
    jsPropertiesTools.defineGetter(this, 'index', function() { return cache.index; });
    jsPropertiesTools.defineGetter(this, 'unused', function() { return unused; });

    function setItemCache(item) {
        var itemID = ko.unwrap(item[settings.itemIdField]);
        // Look for the entry, to update or insert a new one
        var itemEntry = cache.index[itemID];
        if (itemEntry) {
            // Update entry
            cache.list()[itemEntry.index] = adaptItem(item);
        }
        else {
            // Add to the list
            var itemIndex = cache.list.push(adaptItem(item)) - 1;
            cache.index[itemID] = createItemIndexEntry(cache.list(), itemIndex);
        }
    }

    this.setItemCache = setItemCache;

    function delItemCache(itemID) {
        var itemEntry = cache.index[itemID];
        if (itemEntry) {
            // Update list removing the element in place, without holes
            cache.list.splice(itemEntry.index, 1);
            // Update index by:
            // - Remove itemID entry
            delete cache.index[itemID];
            // - Update every entry with an ID greater than the updated,
            // since they are now one position less in the updated list
            Object.keys(cache.index).forEach(function(key) {
                if (cache.index[key] > itemEntry.index)
                    cache.index[key]--;
            });
        }
    }
    
    this.delItemCache = delItemCache;
}

module.exports = IndexedListCache;

},{"./CacheControl":101,"./jsPropertiesTools":125,"knockout":false}],109:[function(require,module,exports){
/**
    ListRemoteModel
    Utility class for common code for a data list entity from a remote source,
    with local copy and cache, where the list is managed will all the data,
    without paging/cursor, with indexed access to each item by its ID.
    Is good for lists that keep small in the time.
**/
'use strict';

var ko = require('knockout'),
    IndexedListCache = require('./IndexedListCache');

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function ListRemoteModel(settings) {
    /*jshint maxstatements:50*/

    settings = settings || {};
    settings.listTtl = required(settings.listTtl, 'listTtl is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    // Optional model
    settings.Model = settings.Model || null;
    // Required for API additions
    this.settings = settings;

    this.state = {
        isLoading: ko.observable(false),
        isSyncing: ko.observable(false),
        isSaving: ko.observable(false),
        isDeleting: ko.observable(false)
    };
    
    // Items are managed as plain object by default, but as permanent, updated
    // model instances if the Model class was specified.
    // This adapter is passed to the cache constructor too keep the in-memory
    // objects up to date with the correct structure.
    function itemAdapter(oldItem, newItem) {
        if (settings.Model) {
            // If the model item already exists, update with new values
            if (oldItem && oldItem instanceof settings.Model) {
                oldItem.model.updateWith(newItem);
                return oldItem;
            }
            else {
                // New created item.
                // If there was a previous, no-model, value, they are discarded
                // (that situation can only happens if there are irregular modifications
                // of the internal behavior).
                return new settings.Model(newItem);
            }
        }
        else {
            return newItem;
        }
    }
    
    var cache = new IndexedListCache({
        listTtl: settings.listTtl,
        itemIdField: settings.itemIdField,
        itemAdapter: itemAdapter
    });
    
    this.clearCache = cache.clearCache;

    this.state.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving() || this.isDeleting();
    }, this.state);

    /** Data Stores Management: implementation must be replaced, with custom code or using
        the helpers added to the class (see addXxSupport prototype methods).
    **/
    function notImplemented() { throw new Error('Not Implemented'); }
    this.fetchListFromLocal = notImplemented;
    this.fetchListFromRemote = notImplemented;
    this.pushListToLocal = notImplemented;
    this.pushListToRemote = notImplemented;
    this.removeItemFromRemote = notImplemented;
    
    /**
        Retrieves a plain array-objects from the cached list
    **/
    function getPlainCachedList() {
        var arr = cache.list();
        return arr.map(function(item) {
            if (item && settings.Model && item instanceof settings.Model) {
                return item.model.toPlainObject();
            }
            else {
                return item;
            }
        });
    }

    /** API definition **/
    var api = this;
    
    // Direct access to the observable cached list.
    api.list = cache.list;

    // Currently, just a wrapper for getList.
    api.sync = function sync() {
        return api.getList();
    };

    /**
        Promise based request to get the list (from cache, local or remote).
        It updates the observable list if new data is fetched.
        A general approach is to use the observable list and call the 'sync' method
        rather than wait this promise to finish ('sync' performs this load really).
    **/
    api.getList = function getList() {

        if (cache.control.mustRevalidate()) {
            // Cache still not used, then is first load, try load from local
            if (cache.unused) {
                api.state.isLoading(true);
                // From local
                return this.fetchListFromLocal()
                .then(function(data) {
                    // launch remote for sync
                    api.state.isSyncing(true);
                    var remotePromise = this.fetchListFromRemote()
                    .then(function(serverData) {
                        cache.list = serverData;
                        this.pushListToLocal(serverData);
                        api.state.isSyncing(false);
                        return serverData;
                    }.bind(this))
                    .catch(function(err) {
                        // If there was local data, catch error and
                        // stop sync since this promise will not
                        // be available to any consumer
                        if (data) {
                            api.state.isSyncing(false);
                            // Log to console
                            console.error('ListRemoteModel: remote synchronization failed', err);
                        }
                        else {
                            // This promise is returned so will be consumed,
                            // just rethrow and let the other catch-blocks do the common stuff
                            return err;
                        }
                    });
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                }.bind(this))
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.list = data;
                    this.pushListToLocal(data);
                    api.state.isLoading(false);

                    return cache.list;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            } else {
                api.state.isSyncing(true);
                // From remote
                return this.fetchListFromRemote()
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.list = data;
                    this.pushListToLocal(data);
                    api.state.isLoading(false);
                    api.state.isSyncing(false);

                    return cache.list;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            }
        }
        else {
            // From cache
            return Promise.resolve(cache.list);
        }
    };
    
    api.getItem = function getItem(itemID) {
        // IMPORTANT: To simplify, load all the list (is a short list)
        // and look from its cached index
        // TODO Implement item server look-up. Be careful with cache update,
        // list sorting and state flags.
        return api.getList()
        .then(function() {
            // Get from cached index
            var cacheItem = cache.getItemCache(itemID);

            // TODO: Enhance on future with actual look-up by API itemID
            // if not cached, throwing not found from the server (just to avoid
            // minor cases when a new item is not still in the cache if linked
            // from other app data). And keep updated list cache with that
            // items lookup
            if (!cacheItem) {
                console.warn('ListRemoteModel Not found', itemID, settings.Model);
                throw new Error('Not Found');
            }
            return cacheItem.item;
        });
    };
    
    /**
        Generates and returns an observable inmediately,
        with the cached value or undefined,
        launching an item load that will update the observable
        on ready if there is no cached value.
        A method 'sync' is added to the observable so can be requested
        a data sync/reload on demand.
    **/
    api.getObservableItem = function getObservableItem(itemID) {
        // Get first value
        var firstValue = cache.getItemCache(itemID);
        firstValue = firstValue && firstValue.item || undefined;
        var obs = ko.observable(firstValue);
        // Create method 'sync'
        obs.sync = function syncObservableItem() {
            return api.getItem(itemID)
            .then(function(itemModel) {
                obs(itemModel);
            });
        };
        // First load if no cached value
        if (!firstValue)
            obs.sync();
        // Return
        return obs;
    };
    
    /**
        Similar to getObservableItem, it allows to get
        an observable to an item model synchronously that
        it triggers an item load when its method 'sync'
        is called. The itemID is passed to the sync item,
        since the observable is meant to hold any item/itemID
        (its a wildcard).
        This way, a reference to an observable can be get on initialization
        even if there is no data still, even no itemID, and load
        it later lazily, on demand, while keeping the content of the
        previous outdated or different item.

        NOTE: API alternative names: getLazyItem, createMutableItem
        NOTE: Maybe can get state observables (loading, syncing..)?
        NOTE: On update a same itemID, maybe update the model with updateWith
                rather than change the reference model?? (double check:
                since the model is the same in cache, already updated
                with 'updateWith', there is no need to re-apply and no
                need to change the item observable because is the same
                updated already, right?
    **/
    api.createWildcardItem = function createWildcardItem() {
        // Utility for reuse in 'sync'
        var hasID = function(id) {
            return id !== null && typeof(id) !== 'undefined';
        };
        
        // Create observable, with initial undefined value
        var obs = ko.observable(undefined);

        // Create method 'sync'
        var lastID;
        /**
            Sync method to load an item, from cache ASAP and
            from local or remote if required by the cache control.
            It returns the Promise for fetching the value (getItem)
            so load/sync ending and error can be catched.
        **/
        obs.sync = function syncObservableItem(itemID) {
            
            var idChanged = hasID(itemID) && itemID !== lastID;
            lastID = hasID(itemID) ? itemID : lastID;
            
            // ASAP Get from cache if any and requested item changed
            if (idChanged) {
                var cachedItem = cache.getItemCache(lastID);
                if (cachedItem && cachedItem.item)
                    obs(cachedItem.item);
            }

            // Request updated value
            return api.getItem(lastID)
            .then(function(itemModel) {
                obs(itemModel);
                return itemModel;
            });
        };
        
        /**
            Sets the observable value to a new item instance
        **/
        obs.newItem = function newItem(defaults) {
            if (settings.Model)
                obs(new settings.Model(defaults));
            else
                obs(defaults || {});
        };

        // Return
        return obs;
    };

    /**
        Save an item in cache, local and remote.
        Can be new or updated.
        The IDs goes with all the other data, being
        groupID required, itemID required for updates
        but falsy for insertions.
        @param data:object Plain object
    **/
    api.setItem = function setItem(data) {
        api.state.isSaving(true);
        // Send to remote first
        return this.pushListToRemote(data)
        .then(function(serverData) {
            // Success! update local copy with returned data
            // IMPORTANT: to use server data here so we get values set
            // by the server, as updates dates and itemID when creating
            // a new item.
            if (serverData) {
                // Save in cache
                cache.setItemCache(serverData);
                // Save in local storage
                // In local need to be saved all the list, not just
                // the item; since we have the cache list updated, use that
                // full list to save local
                this.pushListToLocal(getPlainCachedList());
            }
            api.state.isSaving(false);

            return serverData;
        }.bind(this))
        .catch(function(err) {
            api.state.isSaving(false);
            // Rethrow error
            return err;
        });
    };
    
    api.delItem = function delItem(itemID) {
        
        api.state.isDeleting(true);
        
        // Remove in remote first
        return this.removeItemFromRemote(itemID)
        .then(function(removedData) {
            // Update cache
            cache.delItemCache(itemID);
            // Save in local storage
            // In local need to be saved all the list;
            // since we have the cache list updated, use that
            // full list to save local
            this.pushListToLocal(getPlainCachedList());

            api.state.isDeleting(false);
            
            return removedData;
        }.bind(this))
        .catch(function(err) {
            api.state.isDeleting(false);
            // Rethrow error
            return err;
        });
    };
    
    /** Some Utils **/

    var ModelVersion = require('../utils/ModelVersion');
    /**
        It creates a new ModelVersion for the requested item ID
        after load the item.
        The promise returns the ModelVersion ready, or null
        if the item does not exists.
    **/
    api.createItemVersion = function createItemVersion(itemID) {
        return api.getItem(itemID)
        .then(function(model) {
            return model ? new ModelVersion(model) : null;
        });
    };

    /**
        It creates a new Model instance with the given initial values,
        returning a ModelVersion object.
        The versioning allows to track the initial
        state (if comes from a set of defaults or clone) with
        the changes done; the internal version notifies itself
        as 'unsaved' ever.
        Its useful to keep the same ModelVersion aware code for
        editions and additions.
    **/
    api.newItem = function newItem(values) {
        // New original and version for the model
        var version = new ModelVersion(new settings.Model(values));
        // To be sure that the version appear as something 'new', unsaved,
        // we update its timestamp to be different to the original.
        version.version.model.touch();
        return version;
    };
}

module.exports = ListRemoteModel;

ListRemoteModel.prototype.addLocalforageSupport = function addLocalforageSupport(baseName) {
    var localforage = require('localforage');

    this.fetchListFromLocal = function fetchListFromLocal() {
        return localforage.getItem(baseName);
    };
    this.pushListToLocal = function pushListToLocal(data) {
        return localforage.setItem(baseName, data);
    };
};

ListRemoteModel.prototype.addRestSupport = function addRestSupport(restClient, baseUrl) {
    
    this.fetchListFromRemote = function fetchListFromRemote() {
        return restClient.get(baseUrl);
    };
    this.pushListToRemote = function pushListToRemote(data) {

        var itemID = data[this.settings.itemIdField],
            method = itemID ? 'put' : 'post';

        var url = baseUrl + (
            itemID ? '/' + itemID : ''
        );
        return restClient[method](url, data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(itemID) {
        return restClient.delete(baseUrl + '/' + itemID);
    };
};

},{"../utils/ModelVersion":110,"./IndexedListCache":108,"knockout":false,"localforage":false}],110:[function(require,module,exports){
/**
    Utility that allows to keep an original model untouched
    while editing a version, helping synchronize both
    when desired by push/pull/sync-ing.
    
    Its the usual way to work on forms, where an in memory
    model can be used but in a copy so changes doesn't affects
    other uses of the in-memory model (and avoids remote syncing)
    until the copy want to be persisted by pushing it, or being
    discarded or refreshed with a remotely updated original model.
**/
'use strict';

var ko = require('knockout'),
    EventEmitter = require('events').EventEmitter;

function ModelVersion(original) {
    
    EventEmitter.call(this);
    
    this.original = original;
    
    // Create version
    // (updateWith takes care to set the same dataTimestamp)
    this.version = original.model.clone(null, true);
    
    // Computed that test equality, allowing being notified of changes
    // A rateLimit is used on each to avoid several syncrhonous notifications.
    
    /**
        Returns true when both versions has the same timestamp
    **/
    this.areDifferent = ko.pureComputed(function areDifferent() {
        return (
            this.original.model.dataTimestamp() !== 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
    /**
        Returns true when the version has newer changes than
        the original
    **/
    this.isNewer = ko.pureComputed(function isNewer() {
        return (
            this.original.model.dataTimestamp() < 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
    /**
        Returns true when the version has older changes than
        the original
    **/
    this.isObsolete = ko.pureComputed(function isComputed() {
        return (
            this.original.model.dataTimestamp() > 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
}

module.exports = ModelVersion;

ModelVersion._inherits(EventEmitter);

ModelVersion.prototype.getRollback = function getRollback(from) {
    if (from === 'version')
        return createRollbackFunction(this.version);
    else if (from === 'original')
        return createRollbackFunction(this.original);
    throw new Error('from value not valid');
};

/**
    Sends the version changes to the original
    
    options: {
        evenIfNewer: false
    }
**/
ModelVersion.prototype.pull = function pull(options) {

    options = options || {};
    
    // By default, nothing to do, or avoid overwrite changes.
    var result = false,
        rollback = null;
    
    if (options.evenIfNewer || !this.isNewer()) {
        // Update version with the original data,
        // creating first a rollback function.
        rollback = createRollbackFunction(this.version);
        // Ever deepCopy, since only properties and fields from models
        // are copied and that must avoid circular references
        // The method updateWith takes care to set the same dataTimestamp:        
        this.version.model.updateWith(this.original, true);
        // Done
        result = true;
    }

    this.emit('pull', result, rollback);
    return result;
};

/**
    Discard the version changes getting the original
    data.
    
    options: {
        evenIfObsolete: false
    }
**/
ModelVersion.prototype.push = function push(options) {
    
    options = options || {};
    
    // By default, nothing to do, or avoid overwrite changes.
    var result = false,
        rollback = null;

    if (options.evenIfObsolete || !this.isObsolete()) {
        // Update original, creating first a rollback function.
        rollback = createRollbackFunction(this.original);
        // Ever deepCopy, since only properties and fields from models
        // are copied and that must avoid circular references
        // The method updateWith takes care to set the same dataTimestamp.
        this.original.model.updateWith(this.version, true);
        // Done
        result = true;
    }

    this.emit('push', result, rollback);
    return result;
};

/**
    Sets original and version on the same version
    by getting the newest one.
**/
ModelVersion.prototype.sync = function sync() {
    
    if (this.isNewer())
        return this.push();
    else if (this.isObsolete())
        return this.pull();
    else
        return false;
};

/**
    Utility that create a function able to 
    perform a data rollback on execution, useful
    to pass on the events to allow react upon changes
    or external synchronization failures.
**/
function createRollbackFunction(modelInstance) {
    // Previous function creation, get NOW the information to
    // be backed for later.
    var backedData = modelInstance.model.toPlainObject(true),
        backedTimestamp = modelInstance.model.dataTimestamp();

    // Create the function that *may* get executed later, after
    // changes were done in the modelInstance.
    return function rollback() {
        // Set the backed data
        modelInstance.model.updateWith(backedData, true);
        // And the timestamp
        modelInstance.model.dataTimestamp(backedTimestamp);
    };
}

},{"events":false,"knockout":false}],111:[function(require,module,exports){
/**
    RemoteModel class.
    
    It helps managing a model instance, model versions
    for in memory modification, and the process to 
    receive or send the model data
    to a remote sources, with glue code for the tasks
    and state properties.
    
    Every instance or subclass must implement
    the fetch and pull methods that knows the specifics
    of the remotes.
**/
'use strict';

var ModelVersion = require('../utils/ModelVersion'),
    CacheControl = require('../utils/CacheControl'),
    ko = require('knockout'),
    localforage = require('localforage'),
    EventEmitter = require('events').EventEmitter;

function RemoteModel(options) {

    EventEmitter.call(this);
    
    options = options || {};
    
    var firstTimeLoad = true;
    
    // Marks a lock loading is happening, any user code
    // must wait for it
    this.isLoading = ko.observable(false);
    // Marks a lock saving is happening, any user code
    // must wait for it
    this.isSaving = ko.observable(false);
    // Marks a background synchronization: load or save,
    // user code knows is happening but can continue
    // using cached data
    this.isSyncing = ko.observable(false);
    // Utility to know whether any locking operation is
    // happening.
    // Just loading or saving
    this.isLocked = ko.pureComputed(function(){
        return this.isLoading() || this.isSaving();
    }, this);
    
    if (!options.data)
        throw new Error('RemoteModel data must be set on constructor and no changed later');
    this.data = options.data;
    
    this.cache = new CacheControl({
        ttl: options.ttl
    });
    
    this.clearCache = function clearCache() {
        this.cache.latest = null;
        this.data.model.reset();
    };
    
    // Optional name used to persist a copy of the data as plain object
    // in the local storage on every successfully load/save operation.
    // With no name, no saved (default).
    // It uses 'localforage', so may be not saved using localStorage actually,
    // but any supported and initialized storage system, like WebSQL, IndexedDB or LocalStorage.
    // localforage must have a set-up previous use of this option.
    this.localStorageName = options.localStorageName || null;
    
    // Recommended way to get the instance data
    // since it ensures to launch a load of the
    // data each time is accessed this way.
    this.getData = function getData() {
        this.load();
        return this.data;
    };

    this.newVersion = function newVersion() {
        var v = new ModelVersion(this.data);
        
        // Update the version data with the original
        // after a lock load finish, like the first time,
        // since the UI to edit the version will be lock
        // in the middle.
        this.isLoading.subscribe(function (isIt) {
            if (!isIt) {
                v.pull({ evenIfNewer: true });
            }
        });

        // new method for push and remote same returning
        // the save promise to track immediate success or error,
        // with error auto recovering original data.
        v.pushSave = function pushSave() {
            var rollback = v.getRollback('original');
            v.push({ evenIfObsolete: true });

            return this.save()
            .then(function() {
                // Update the version data with the new one
                // from the remote, that may include remote computed
                // values:
                v.pull({ evenIfNewer: true });
            })
            .catch(function(error) {
                // Performs a rollback of the original model
                rollback();
                // The version data keeps untouched, user may want to retry
                // or made changes on its un-saved data.
                // rethrow error
                return error;
            });
        }.bind(this);

        return v;
    };
    
    this.fetch = options.fetch || function fetch() { throw new Error('Not implemented'); };
    this.push = options.push || function push() { throw new Error('Not implementd'); };

    var loadFromRemote = function loadFromRemote() {
        return this.fetch()
        .then(function (serverData) {
            if (serverData) {
                // Ever deepCopy, since plain data from the server (and any
                // in between conversion on 'fecth') cannot have circular
                // references:
                this.data.model.updateWith(serverData, true);

                // persistent local copy?
                if (this.localStorageName) {
                    localforage.setItem(this.localStorageName, serverData);
                }
            }
            else {
                throw new Error('Remote model did not returned data, response must be a "Not Found"');
            }

            // Event
            if (this.isLoading()) {
                this.emit('loaded', serverData);
            }
            else {
                this.emit('synced', serverData);
            }

            // Finally: common tasks on success or error
            this.isLoading(false);
            this.isSyncing(false);

            this.cache.latest = new Date();
            return this.data;
        }.bind(this))
        .catch(function(err) {

            var wasLoad = this.isLoading();

            // Finally: common tasks on success or error
            this.isLoading(false);
            this.isSyncing(false);

            // Event
            var errPkg = {
                task: wasLoad ? 'load' : 'sync',
                error: err
            };
            // Be careful with 'error' event, is special and stops execution on emit
            // if no listeners attached: overwritting that behavior by just
            // print on console when nothing, or emit if some listener:
            if (EventEmitter.listenerCount(this, 'error') > 0) {
                this.emit('error', errPkg);
            }
            else {
                // Log it when not handled (even if the promise error is handled)
                console.error('RemoteModel Error', errPkg);
            }

            // Rethrow error
            return err;
        }.bind(this));
    }.bind(this);
    
    this.load = function load() {
        if (this.cache.mustRevalidate()) {
            
            if (firstTimeLoad)
                this.isLoading(true);
            else
                this.isSyncing(true);
            
            var promise = null;
            
            // If local storage is set for this, load first
            // from local, then follow with syncing from remote
            if (firstTimeLoad &&
                this.localStorageName) {

                promise = localforage.getItem(this.localStorageName)
                .then(function(localData) {
                    if (localData) {
                        this.data.model.updateWith(localData, true);
                        
                        // Load done:
                        this.isLoading(false);
                        this.isSyncing(false);
                        
                        // Local load done, do a background
                        // remote load.
                        loadFromRemote()
                        // Catch any promise-error on the remote, to avoid
                        // unexpected errors being uncatch, they still can be
                        // catch using the 'error' event on the RemoteModel instance.
                        .catch(function() { });
                        // just don't wait, return current
                        // data
                        return this.data;
                    }
                    else {
                        // When no data, perform a remote
                        // load and wait for it:
                        return loadFromRemote();
                    }
                }.bind(this));
            }
            else {
                // Perform the remote load:
                promise = loadFromRemote();
            }
            
            // First time, blocking load:
            // it returns when the load returns
            if (firstTimeLoad) {
                firstTimeLoad = false;
                // Returns the promise and will wait for the first load:
                return promise;
            }
            else {
                // Background load: is loading still
                // but we have cached data so we use
                // that for now.
                // Catch any promise-error on the remote, to avoid
                // unexpected errors being uncatch, they still can be
                // catch using the 'error' event on the RemoteModel instance.
                promise.catch(function() { });
                // If anything new from outside
                // versions will get notified with isObsolete()
                return Promise.resolve(this.data);
            }
        }
        else {
            // Return cached data, no need to load again for now.
            return Promise.resolve(this.data);
        }
    };

    this.save = function save() {
        this.isSaving(true);
        
        // Preserve the timestamp after being saved
        // to avoid false 'obsolete' warnings with
        // the version that created the new original
        var ts = this.data.model.dataTimestamp();

        return this.push()
        .then(function (serverData) {
            // Ever deepCopy, since plain data from the server
            // cannot have circular references:
            this.data.model.updateWith(serverData, true);
            this.data.model.dataTimestamp(ts);
            
            // persistent local copy?
            if (this.localStorageName) {
                localforage.setItem(this.localStorageName, serverData);
            }
            
            // Event
            this.emit('saved', serverData);
            
            // Finally: common tasks on success or error
            this.isSaving(false);
            
            this.cache.latest = new Date();
            return this.data;
        }.bind(this))
        .catch(function(err) {
            // Finally: common tasks on success or error
            this.isSaving(false);
            
            // Event
            var errPkg = {
                task: 'save',
                error: err
            };
            // Be careful with 'error' event, is special and stops execution on emit
            // if no listeners attached: overwritting that behavior by just
            // print on console when nothing, or emit if some listener:
            if (EventEmitter.listenerCount(this, 'error') > 0) {
                this.emit('error', errPkg);
            }
            else {
                // Log it when not handled (even if the promise error is handled)
                console.error('RemoteModel Error', errPkg);
            }
            
            // Rethrow error
            return err;
        }.bind(this));
    };
    
    /**
        Launch a syncing request. Returns nothing, the
        way to track any result is with events or 
        the instance observables.
        IMPORTANT: right now is just a request for 'load'
        that avoids promise errors from throwing.
    **/
    this.sync = function sync() {
        // Call for a load, that will be treated as 'syncing' after the
        // first load
        this.load()
        // Avoid errors from throwing in the console,
        // the 'error' event is there to track anyone.
        .catch(function() {});
    };
}

module.exports = RemoteModel;

RemoteModel._inherits(EventEmitter);

},{"../utils/CacheControl":101,"../utils/ModelVersion":110,"events":false,"knockout":false,"localforage":false}],112:[function(require,module,exports){
/**
    REST API access
**/
'use strict';
var $ = require('jquery');
require('jquery.ajaxQueue');

function lowerFirstLetter(n) {
    return n && n[0] && n[0].toLowerCase && (n[0].toLowerCase() + n.slice(1)) || n;
}

function lowerCamelizeObject(obj) {
    //jshint maxcomplexity:8
    
    if (!obj || typeof(obj) !== 'object') return obj;

    var ret = Array.isArray(obj) ? [] : {};
    for(var k in obj) {
        if (obj.hasOwnProperty(k)) {
            var newk = lowerFirstLetter(k);
            ret[newk] = typeof(obj[k]) === 'object' ?
                lowerCamelizeObject(obj[k]) :
                obj[k]
            ;
        }
    }
    return ret;
}

function Rest(optionsOrUrl) {
    
    var url = typeof(optionsOrUrl) === 'string' ?
        optionsOrUrl :
        optionsOrUrl && optionsOrUrl.url;

    this.baseUrl = url;
    // Optional extraHeaders for all requests,
    // usually for authentication tokens
    this.extraHeaders = null;
}

Rest.prototype.get = function get(apiUrl, data) {
    return this.request(apiUrl, 'get', data);
};

Rest.prototype.put = function get(apiUrl, data) {
    return this.request(apiUrl, 'put', data);
};

Rest.prototype.post = function get(apiUrl, data) {
    return this.request(apiUrl, 'post', data);
};

Rest.prototype.delete = function get(apiUrl, data) {
    return this.request(apiUrl, 'delete', data);
};

Rest.prototype.putFile = function putFile(apiUrl, data) {
    // NOTE basic putFile implementation, one file, use fileUpload?
    return this.request(apiUrl, 'delete', data, 'multipart/form-data');
};

Rest.prototype.request = function request(apiUrl, httpMethod, data, contentType) {
    
    var thisRest = this;
    var url = this.baseUrl + apiUrl;

    // Using a promise to avoid the differences and problems of the jQuery thenable
    // object, but attaching its original value as a new property 'xhr' of the promise
    // created for advanced use.
    var xhr = $.ajaxQueue({
        url: url,
        // Avoid cache for data.
        cache: false,
        dataType: 'json',
        method: httpMethod,
        headers: this.extraHeaders,
        // URLENCODED input:
        // Convert to JSON and back just to ensure the values are converted/encoded
        // properly to be sent, like Dates being converted to ISO format.
        data: data && JSON.parse(JSON.stringify(data)),
        contentType: contentType || 'application/x-www-form-urlencoded'
        // Alternate: JSON as input
        //data: JSON.stringify(data),
        //contentType: contentType || 'application/json'
    });

    var promiseXhr = Promise.resolve(xhr)
    .then(lowerCamelizeObject)
    .catch(function(err) {
        // On authorization error, give oportunity to retry the operation
        if (err.status === 401) {
            var retry = request.bind(this, apiUrl, httpMethod, data, contentType);
            var retryPromise = thisRest.onAuthorizationRequired(retry);
            if (retryPromise) {
                // It returned something, expecting is a promise:
                return Promise.resolve(retryPromise)
                .catch(function(){
                    // There is error on retry, just return the
                    // original call error
                    return err;
                });
            }
        }
        // by default, continue propagating the error
        return err;
    });
    
    promiseXhr.xhr = xhr;
    return promiseXhr;
};

Rest.prototype.onAuthorizationRequired = function onAuthorizationRequired(/*retry*/) {
    // To be implemented outside, if convenient executing:
    //retry();
    // by default don't wait for retry, just return nothing:
    return;
};

module.exports = Rest;

},{}],113:[function(require,module,exports){
/**
    Time class utility.
    Shorter way to create a Date instance
    specifying only the Time part,
    defaulting to current date or 
    another ready date instance.
**/
function Time(date, hour, minute, second) {
    if (!(date instanceof Date)) {
 
        second = minute;
        minute = hour;
        hour = date;
        
        date = new Date();   
    }

    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hour || 0, minute || 0, second || 0);
}
module.exports = Time;

},{}],114:[function(require,module,exports){
/**
    Create an Access Control for an app that just checks
    the activity property for allowed user level.
    To be provided to Shell.js and used by the app.js,
    very tied to that both classes.
    
    Activities can define on its object an accessLevel
    property like next examples
    
    this.accessLevel = app.Usertype.User; // anyone
    this.accessLevel = app.UserType.Anonymous; // anonymous users only
    this.accessLevel = app.UserType.LoggedUser; // authenticated users only
**/
'use strict';

// UserType enumeration is bit based, so several
// users can has access in a single property
//var UserType = require('../models/User').UserType;

module.exports = function createAccessControl(app) {
    
    return function accessControl(route) {

        var activity = app.getActivityControllerByRoute(route);

        var user = app.model.user();
        var currentType = user && user.userType();

        if (activity && activity.accessLevel) {

            var can = activity.accessLevel & currentType;
            
            if (!can) {
                // Notify error, why cannot access
                return {
                    requiredLevel: activity.accessLevel,
                    currentType: currentType
                };
            }
        }

        // Allow
        return null;
    };
};

},{}],115:[function(require,module,exports){
/**
    Set of functions to make calculations of availability
    per date given a list of appointments.
    It allows to sort them, create and insert free/unavailable appointments
    following a given daySchedule and summarize the date availability status.
    
    It relies (directly or not) in models like Appointment, 
    SimplifiedWeeklySchedule.WeekDaySchedule.
**/
'use strict';

var Appointment = require('../models/Appointment'),
    moment = require('moment');

exports.sortAppointments = function(a, b) {
    var as = a.startTime(),
        ae = a.endTime(),
        bs = b.startTime(),
        be = b.endTime();

    if (as === null)
        return -1;
    else if (bs === null)
        return 1;

    var eq = as.toISOString() === bs.toISOString();
    if (eq) {
        if (ae === null)
            return -1;
        else if (be === null)
            return 1;
        
        return ae - be;
    }
    else {
        return as - bs;
    }
};

/**
    It adds before every booking apt/slot a 'preparation time' slot for the 'preparationHours' (AKA 'betweenTime').
    The given slots array MUST BE SORTED.
    It takes care to:
    - do not add slots out of the given date
    - do not add slots that overlay other bookings (if two bookings too close; because of manual timing or preference
      change of the preparationHours)
**/
exports.fillPreparationTimeSlots = function fillPreparationTimeSlots(date, slots, preparationHours) {
    
    // Initial check of previous slot start and ends is the given date (at midnight)
    // so we avoid to insert slots out of the date.
    var prevEnd = date;

    slots.forEach(function(slot, index) {
        // for each booking
        if (slot.id() > 0 &&
            slot.sourceBooking()) {
            
            var end = slot.startTime(),
                start = moment(end).subtract(preparationHours, 'hours').toDate();
    
            // avoiding the preparation slot if it ends before or just on
            // the previous slot end (or before the date) to avoid unneeded slots
            // NOTE: do NOT a (end <= prevEnd return;) because will introduce a bug
            // since the prevEnd will not be collected, failing when there are 
            // more than 2 consecutive bookings
            if (end > prevEnd) {
                // ..or cuts the beggining of the slot ('start') by
                // the end of the previous slot (so fits perfectly, without overlay)
                start = start < prevEnd ? prevEnd : start;

                // its added before the current slot:
                slots.splice(index, 0, Appointment.newPreparationTimeSlot({
                    start: start,
                    end: end
                }));
            }
        }
        prevEnd = slot.endTime();
    });
};

/**
    Introduce free or unavailable slots wherever needed in the given
    array of Appointments, to fill any gap in a natural day
    (from Midnight to Midnight next date) and based on the
    given week day schedule.
    The hours in the schedule are assumed in the local time.
    A new array is returned.
    It introduce 'preparation time' slots too before of bookings when needed.
    
    date is a Date object representing the same date as used in
    the appointmentsList; it's used when no appointments exists (so
    date cannot be extracted from first appointent) to return an empty
    date unavaialable/free/unavailable slots; and when filling preparation slots, to
    avoid add a slot with time that starts in a previous date
    
    TODO: Make it compatible with an initial appointment that may start before the 
    date (but ends inside the date) and a final appointment that may end
    on the next date (but starts inside the date).
**/
exports.fillDayAvailability = function fillDayAvailability(date, appointmentsList, weekDaySchedule, schedulingPreferences) {

    // Shadow clone
    var slots = appointmentsList.slice(0);
    // sort the list
    slots.sort(exports.sortAppointments);
    // add preparation time for each booking
    exports.fillPreparationTimeSlots(date, slots, schedulingPreferences.betweenTime());

    var filledSlots = [],
        zeroTime = '00:00:00',
        last = zeroTime,
        lastDateTime = null,
        timeFormat = 'HH:mm:ss';

    if (slots.length === 0) {
        // No slots, empty date so create the required
        // unavailable/free/unavailable slots for the 'date'
        var fullStart = moment(date).startOf('day'),
            fullEnd = fullStart.clone().add(1, 'days');

        filledSlots = exports.createScheduleSlots({
            start: fullStart.toDate(),
            end: fullEnd.toDate()
        }, weekDaySchedule);
    }
    else {
        // Look for time gaps in the list
        slots.forEach(function(slot) {
            var start = slot.startTime(),
                s = moment(start),
                end = slot.endTime(),
                e = moment(end);

            if (s.format(timeFormat) > last) {

                if (lastDateTime === null) {
                    // First slot of the date, 12AM=00:00
                    lastDateTime = new Date(
                        start.getFullYear(), start.getMonth(), start.getDate(),
                        0, 0, 0
                    );
                }

                // There is a gap, fill it
                filledSlots.push.apply(filledSlots, exports.createScheduleSlots({
                    start: lastDateTime,
                    end: start
                }, weekDaySchedule));
            }

            filledSlots.push(slot);
            lastDateTime = end;
            last = e.format(timeFormat);
        });

        // Check latest to see a gap at the end:
        var lastEnd = lastDateTime && moment(lastDateTime).format(timeFormat);
        if (lastEnd !== zeroTime) {
            // There is a gap, filled it
            var nextMidnight = new Date(
                lastDateTime.getFullYear(),
                lastDateTime.getMonth(),
                // Next date!
                lastDateTime.getDate() + 1,
                // At zero hours!
                0, 0, 0
            );

            filledSlots.push.apply(filledSlots, exports.createScheduleSlots({
                start: lastDateTime,
                end: nextMidnight
            }, weekDaySchedule));
        }
    }

    return filledSlots;
};

/**
    Given a time range without appointments, and the day schedule,
    it returns an array of appointments objects to fullfill
    that empty range with unavailable/free appointments.
    
    The range must be two times inside the same date (local time), format
    range { start:Date, end:Date }
    
    weekDaySchedule is an instance of WeekDaySchedule Model, basically:
    { from:observable(Date), to:observable(Date) }
**/
exports.createScheduleSlots = function createScheduleSlots(range, weekDaySchedule) {
    /*jshint maxcomplexity:10*/
    var list = [],
        start = range.start,
        end = range.end,
        date = moment(start).startOf('day'),
        from = moment(date).add({ minutes: weekDaySchedule.from() }).toDate(),
        to = moment(date).add({ minutes: weekDaySchedule.to() }).toDate();

    // It happens before the week day schedule starts
    var beforeSchedule = 
        start < from &&
        end <= from;
    // It happens after the week day schedule ends
    var afterSchedule = 
        end > to &&
        start >= to;
    // It happens inside the week day schedule
    var insideSchedule =
        start >= from &&
        end <= to;

    if (beforeSchedule || afterSchedule) {
        list.push(
            Appointment.newUnavailableSlot({
                start: start,
                end: end
            })
        );
    }
    else if (insideSchedule) {
        list.push(
            Appointment.newFreeSlot({
                start: start,
                end: end
            })
        );
    }
    else {
        // Is in a intermediate position, needs two
        // or three slots
        var crossStart =
            start < from &&
            end > from;
        var crossEnd = 
            start < to &&
            end > to;

        if (crossStart) {
            // Unavailable slot until the 'from'
            list.push(
                Appointment.newUnavailableSlot({
                    start: start,
                    end: from
                })
            );
        }
        if (crossEnd) {
            // Unavailable after 'to'
            list.push(
                Appointment.newUnavailableSlot({
                    start: to,
                    end: end
                })
            );
        }

        if (crossStart && crossEnd) {
            // Full day free
            list.push(
                Appointment.newFreeSlot({
                    start: from,
                    end: to
                })
            );
        }
        else if (crossStart) {
            // Free slot until mid point
            list.push(
                Appointment.newFreeSlot({
                    start: from,
                    end: end
                })
            );
        }
        else if (crossEnd) {
            // Free slot from mid point
            list.push(
                Appointment.newFreeSlot({
                    start: start,
                    end: to
                })
            );
        }
    }
    
    // In the complex cases, is easy that the 
    // order gets inversed because of the if-else natural order
    // so ensure goes correct
    return list.sort(exports.sortAppointments);
};

},{"../models/Appointment":70,"moment":false}],116:[function(require,module,exports){
/**
    Bootknock: Set of Knockout Binding Helpers for Bootstrap js components (jquery plugins)
    
    Dependencies: jquery
    Injected dependencies: knockout
**/
'use strict';

// Dependencies
var $ = require('jquery');
// DI i18n library
exports.i18n = null;

function createHelpers(ko) {
    var helpers = {};

    /** Popover Binding **/
    helpers.popover = {
        update: function(element, valueAccessor) {
            var srcOptions = ko.unwrap(valueAccessor());

            // Duplicating options object to pass to popover without
            // overwrittng source configuration
            var options = $.extend(true, {}, srcOptions);
            
            // Unwrapping content text
            options.content = ko.unwrap(srcOptions.content);
            
            if (options.content) {
            
                // Localize:
                options.content = 
                    exports.i18n && exports.i18n.t(options.content) ||
                    options.content;
                
                // To get the new options, we need destroy it first:
                $(element).popover('destroy').popover(options);

                // Se muestra si el elemento tiene el foco
                if ($(element).is(':focus'))
                    $(element).popover('show');

            } else {
                $(element).popover('destroy');
            }
        }
    };
    
    return helpers;
}

/**
    Plug helpers in the provided Knockout instance
**/
function plugIn(ko, prefix) {
    var name,
        helpers = createHelpers(ko);
    
    for(var h in helpers) {
        if (helpers.hasOwnProperty && !helpers.hasOwnProperty(h))
            continue;

        name = prefix ? prefix + h[0].toUpperCase() + h.slice(1) : h;
        ko.bindingHandlers[name] = helpers[h];
    }
}

exports.plugIn = plugIn;
exports.createBindingHelpers = createHelpers;

},{}],117:[function(require,module,exports){
/**
    Knockout Binding Helper for the Bootstrap Switch plugin.
    
    Dependencies: jquery, bootstrap, bootstrap-switch
    Injected dependencies: knockout
    
    IMPORTANT NOTES:
    - A console error of type "object has not that property" will happen if specified
        a non existant option in the binding. The error looks strange when using the minified file.
    - The order of options in the binding matters when combining with disabled and readonly
        options: if the element is disabled:true or readonly:true, any attempt to change the
        value will fail silently, so if the same binding update changes disabled to false
        and the state, the 'disabled' change must happens before the 'state' change so both
        are successfully updated. For that, just specify 'disabled' before 'state' in the bindings
        definition.
**/
'use strict';

// Dependencies
var $ = require('jquery');
require('bootstrap');
require('bootstrap-switch');

/**
    Create and plug-in the Binding in the provided Knockout instance
**/
exports.plugIn = function plugIn(ko, prefix) {

    ko.bindingHandlers[prefix ? prefix + 'switch' : 'switch'] = {
        init: function(element, valueAccessor) {
            // Create plugin instance
            $(element).bootstrapSwitch();
            
            //console.log('switch init', ko.toJS(valueAccessor()));

            // Updating value on plugin changes
            $(element).on('switchChange.bootstrapSwitch', function (e, state) {
                var v = valueAccessor() || {};
                //console.log('switchChange', ko.toJS(v));
                
                // changed?
                var oldState = !!ko.unwrap(v.state),
                    newState = !!state;
                // Only update on change
                if (oldState !== newState) {
                    if (ko.isObservable(v.state)) {
                        if (ko.isWriteableObservable(v.state)) {
                            v.state(newState);
                        }
                    } else {
                        v.state = newState;
                    }
                }
            });
        },
        update: function(element, valueAccessor) {
            // Get options to be applied to the plugin instance
            var srcOptions = valueAccessor();
            
            var options = srcOptions || {};

            // Unwrapping every option value, getting a duplicated
            // plain object
            options = ko.toJS(options);
            //console.log('switch update', options);

            var $el = $(element);
            // Update every option in the plugin
            Object.keys(options).forEach(function(key) {
                $el.bootstrapSwitch(key, options[key]);
            });
        }
    };
};

},{}],118:[function(require,module,exports){
/**
    Allow attach availability loading and displaying capabilities
    to a datepicker component as part of an activity.
    
    It attaches handlers so it loads and update availability whenever
    the displayed month change, but it returns a method to do it
    on demand, like in the first load after choose a 'current date'
**/
'use strict';

var $ = require('jquery'),
    moment = require('moment');

exports.create = function createDatepickerAvailability(app, $datepicker, isLoading) {
    // Cache DOM elements
    var daysElements = $datepicker.datepicker('getDaysElements');
    // Cache last month showed, to double check later and don't load an already
    // displayed month
    var prevMonth = null;
    
    // Listen to cache changes in order to force a data load (to avoid invalid
    // availability being displayed after an apt was modified)
    app.model.calendar.on('clearCache', function(dates) {
        if (!dates) {
            prevMonth = null;
        }
        else {
            dates.some(function(date) {
                if (date.getMonth() === prevMonth) {
                    prevMonth = null;
                    return true;
                }
            });
        }
    });
    
    /**
        It tags, if the month changed, the calendar with the Date Availability.
        The refresh param forces the process even if the same month than previously tagged/rendered
    **/
    var tagAvailability = function tagAvailability(date, refresh) {
        var month = date.getMonth();
        // Avoid dupes
        if (month === prevMonth && !refresh) return;
        prevMonth = month;
        
        // We need to know the range of dates being displayed on the
        // monthly calendar, from the first week day of first month week
        // to 6 full weeks.
        var start = moment(date).clone().startOf('month').startOf('week'),
            end = start.clone().add(6, 'weeks');

        // Switch loading flag
        if (isLoading)
            isLoading(true);
        
        // Request the data
        app.model.calendar.getDatesAvailability(start, end)
        .then(function(resultByDates) {
            // We are still in the same showed month? (loading is async, so could have changed)
            if (month !== $datepicker.datepicker('getViewDate').getMonth()) return;

            // We received a set of DateAvailability objects per date (iso string key)
            // Iterate every day element, and use its date avail from the result
            daysElements.each(function() {
                // jshint maxcomplexity:10
                var $dateTd = $(this),
                    id = $dateTd.data('date-time'),
                    dateAvail = resultByDates[moment(id).format('YYYY-MM-DD')];   

                // Integrity check to avoid edge case exceptions (must not happens, but stronger code)
                if (!id || !dateAvail) return;
                
                // Remove any previous 'tag-' class from the cell classNames and keep for later change
                var cellClass = $dateTd.attr('class').replace(/(^|\s)tag-[^\s]+/, '');

                // Set a date cell class based on its availability
                var cls = '';
                switch(dateAvail.availableTag()) {
                    case 'past':
                        cls = 'tag-muted';
                        break;
                    case 'full':
                        cls = 'tag-blank';
                        break;
                    case 'medium':
                        cls = 'tag-dark';
                        break;
                    case 'low':
                        cls = 'tag-warning';
                        break;
                    case 'none':
                        cls = 'tag-danger';
                        break;
                }
                $dateTd.attr('class', cellClass + ' ' + cls);
            });
        })
        .catch(function(err) {
            app.modals.showError({
                title: 'Error loading availability',
                error: err
            });
        }.bind(this))
        .then(function() {
            // Finally
            if (isLoading)
                isLoading(false);
        }.bind(this));
    };
    
    // Handler to auto load/update availability for displayed day
    $datepicker.on('viewDateChanged', function(e, d) {
        if (d.viewMode === 'days') {
            tagAvailability(d.viewDate);
        }
    });
    
    return tagAvailability;
};

},{"moment":false}],119:[function(require,module,exports){
/**
    Espace a string for use on a RegExp.
    Usually, to look for a string in a text multiple times
    or with some expressions, some common are 
    look for a text 'in the beginning' (^)
    or 'at the end' ($).
    
    Author: http://stackoverflow.com/users/151312/coolaj86 and http://stackoverflow.com/users/9410/aristotle-pagaltzis
    Link: http://stackoverflow.com/a/6969486
**/
'use strict';

// Referring to the table here:
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
// these characters should be escaped
// \ ^ $ * + ? . ( ) | { } [ ]
// These characters only have special meaning inside of brackets
// they do not need to be escaped, but they MAY be escaped
// without any adverse effects (to the best of my knowledge and casual testing)
// : ! , = 
// my test "~!@#$%^&*(){}[]`/=?+\|-_;:'\",<.>".match(/[\#]/g)

var specials = [
    // order matters for these
      "-"
    , "["
    , "]"
    // order doesn't matter for any of these
    , "/"
    , "{"
    , "}"
    , "("
    , ")"
    , "*"
    , "+"
    , "?"
    , "."
    , "\\"
    , "^"
    , "$"
    , "|"
  ]

  // I choose to escape every character with '\'
  // even though only some strictly require it when inside of []
, regex = RegExp('[' + specials.join('\\') + ']', 'g')
;

var escapeRegExp = function (str) {
return str.replace(regex, "\\$&");
};

module.exports = escapeRegExp;

// test escapeRegExp("/path/to/res?search=this.that")

},{}],120:[function(require,module,exports){
/**
* escapeSelector
*
* source: http://kjvarga.blogspot.com.es/2009/06/jquery-plugin-to-escape-css-selector.html
*
* Escape all special jQuery CSS selector characters in *selector*.
* Useful when you have a class or id which contains special characters
* which you need to include in a selector.
*/
'use strict';

var specials = [
  '#', '&', '~', '=', '>', 
  "'", ':', '"', '!', ';', ','
];
var regexSpecials = [
  '.', '*', '+', '|', '[', ']', '(', ')', '/', '^', '$'
];
var sRE = new RegExp(
  '(' + specials.join('|') + '|\\' + regexSpecials.join('|\\') + ')', 'g'
);

module.exports = function(selector) {
  return selector.replace(sRE, '\\$1');
};

},{}],121:[function(require,module,exports){
/** getDateWithoutTime utility.
    Returns a new Date instance with time at zeroes
    and the same date as the input.
    It returns current date if no valid date or string passed.
**/
'use strict';

module.exports = function getDateWithoutTime(date) {
    if (!date) {
        date = new Date();
    }
    else if (!(date instanceof Date)) {
        date = new Date(date);
    }

    return new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        0, 0, 0
    );
};

},{}],122:[function(require,module,exports){
/**
    Get a given value wrapped in an observable or returns
    it if its already an observable or just a function.
**/
'use strict';
var ko = require('knockout');

module.exports = function getObservable(obsOrValue) {
    if (typeof(obsOrValue) === 'function')
        return obsOrValue;
    else
        return ko.observable(obsOrValue);
};

},{"knockout":false}],123:[function(require,module,exports){
/**
    Read a page's GET URL variables and return them as an associative array.
**/
'user strict';
//global window

module.exports = function getUrlQuery(url) {

    url = url || window.location.href;

    var vars = [], hash,
        queryIndex = url.indexOf('?');
    if (queryIndex > -1) {
        var hashes = url.slice(queryIndex + 1).split('&');
        for(var i = 0; i < hashes.length; i++)
        {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }
    }
    return vars;
};

},{}],124:[function(require,module,exports){
// jQuery plugin to set multiline text in an element,
// by replacing \n by <br/> with careful to avoid XSS attacks.
// http://stackoverflow.com/a/13082028
'use strict';

var $ = require('jquery');

$.fn.multiline = function(text) {
    this.text(text);
    this.html(this.html().replace(/\n/g,'<br/>'));
    return this;
};

},{}],125:[function(require,module,exports){
/**
    Set of utilities to define Javascript Properties
    independently of the browser.
    
    Allows to define getters and setters.
    
    Adapted code from the original created by Jeff Walden
    http://whereswalden.com/2010/04/16/more-spidermonkey-changes-ancient-esoteric-very-rarely-used-syntax-for-creating-getters-and-setters-is-being-removed/
**/
'use strict';

function accessorDescriptor(field, fun)
{
    var desc = { enumerable: true, configurable: true };
    desc[field] = fun;
    return desc;
}

function defineGetter(obj, prop, get)
{
    if (Object.defineProperty)
        return Object.defineProperty(obj, prop, accessorDescriptor("get", get));
    if (Object.prototype.__defineGetter__)
        return obj.__defineGetter__(prop, get);

    throw new Error("browser does not support getters");
}

function defineSetter(obj, prop, set)
{
    if (Object.defineProperty)
        return Object.defineProperty(obj, prop, accessorDescriptor("set", set));
    if (Object.prototype.__defineSetter__)
        return obj.__defineSetter__(prop, set);

    throw new Error("browser does not support setters");
}

module.exports = {
    defineGetter: defineGetter,
    defineSetter: defineSetter
};

},{}],126:[function(require,module,exports){
/**
    Remove the accent and special characters from a text
    replacing each character for its basic equivalent.
    Useful to performs punctuation-insensitive text searchs.
**/
'use strict';

var map = {'':'A','':'A','':'A','':'A','':'A','':'A','':'AE','':'C','':'E','':'E','':'E','':'E','':'I','':'I','':'I','':'I','':'D','':'N','':'O','':'O','':'O','':'O','':'O','':'O','':'U','':'U','':'U','':'U','':'Y','':'s','':'a','':'a','':'a','':'a','':'a','':'a','':'ae','':'c','':'e','':'e','':'e','':'e','':'i','':'i','':'i','':'i','':'n','':'o','':'o','':'o','':'o','':'o','':'o','':'u','':'u','':'u','':'u','':'y','':'y','':'A','':'a','':'A','':'a','':'A','':'a','':'C','':'c','':'C','':'c','':'C','':'c','':'C','':'c','':'D','':'d','':'D','':'d','':'E','':'e','':'E','':'e','':'E','':'e','':'E','':'e','':'E','':'e','':'G','':'g','':'G','':'g','':'G','':'g','':'G','':'g','':'H','':'h','':'H','':'h','':'I','':'i','':'I','':'i','':'I','':'i','':'I','':'i','':'I','':'i','':'IJ','':'ij','':'J','':'j','':'K','':'k','':'L','':'l','':'L','':'l','':'L','':'l','':'L','':'l','':'L','':'l','':'N','':'n','':'N','':'n','':'N','':'n','':'n','':'O','':'o','':'O','':'o','':'O','':'o','':'OE','':'oe','':'R','':'r','':'R','':'r','':'R','':'r','':'S','':'s','':'S','':'s','':'S','':'s','':'S','':'s','':'T','':'t','':'T','':'t','':'T','':'t','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'W','':'w','':'Y','':'y','':'Y','':'Z','':'z','':'Z','':'z','':'Z','':'z','':'s','':'f','':'O','':'o','':'U','':'u','':'A','':'a','':'I','':'i','':'O','':'o','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'A','':'a','':'AE','':'ae','':'O','':'o'};

module.exports = function removeAccent(str) {

    var res = '', c;
    for (var i = 0, l = str.length; i < l; i++) {
        c = str.charAt(i);
        res += map[c] || c;
    }
    return res;
};

},{}],127:[function(require,module,exports){
/**
    It scroll all needed elements in the page to make the
    target element to appear in the screen, if possible.
    
    It scrolls all the element ancestors (that may have
    or not a scrolling context).
    
    Only vertically.
    TODO: make it horizontal too.
**/
//global window
'use strict';

var $ = require('jquery');

// @param el:DOMElement|jQuery
// @param options:Object {
//      topOffset:int  Offset scroll from the top
// }
module.exports = function scrollToElement(el, options) {
    //jshint maxcomplexity:10
    var parent = $(el).parent();

    var topOffset = options && options.topOffset || 0;
    var animation = options && options.animation;
    
    var atRoot = false;

    do {
        // Go out on detached elements:
        if (!parent || !parent.length) return;
        // Check if root element (ends loop and has different rules for scrolling)
        atRoot = parent.get(0) === document.documentElement;
        
        // Relative position of the element is calculated in a different way
        // when at the root, so take care of that
        var relativeTop = atRoot ? el.position().top : el.offset().top;
        
        // IMPORTANT: elementTop with offset is used as is when atRoot
        // because the next scrollingTop calculating make it fail
        var elementTop = relativeTop - topOffset;
        var scrollingTop = elementTop + parent.scrollTop() - parent.offset().top;

        if (atRoot) {
            // IMPORTANT: special case, on the root
            // we can just use window.scroll or scrollTop for animation
            // BUT with a different amount, the elementTop
            if (animation)
                $('html,body').stop().animate({ scrollTop: elementTop }, animation);
            else
                window.scroll(0, elementTop);
        }
        else {
            if (animation)
                parent.stop().animate({ scrollTop: scrollingTop }, animation);
            else
                parent.scrollTop(scrollingTop);
        }

        parent = parent.parent();
    } while(!atRoot);
};

},{}],128:[function(require,module,exports){
/**
    DomItemsManager class, that manage a collection 
    of HTML/DOM items under a root/container, where
    only one element at the time is visible, providing
    tools to uniquerly identify the items,
    to create or update new items (through 'inject'),
    get the current, find by the ID and more.
**/
'use strict';

var $ = require('jquery');
var escapeSelector = require('../escapeSelector');

function DomItemsManager(settings) {

    this.idAttributeName = settings.idAttributeName || 'id';
    this.allowDuplicates = !!settings.allowDuplicates || false;
    this.root = settings.root || 'body';
    this.$root = null;
    // Define in ms the delay in a switch of items (prepare next ->delay-> hide current, show next)
    // NOTE: as of testing in iOS 8.3 iPad2 (slow), 140ms ended being a good default
    // to avoid some flickering effects, enough to let initialization logic to finish before
    // being showed, allow some common async redirects when executing an item logic but
    // enough quick to not being visually perceived the delay.
    // NOTE: on tests on Nexus 5 Android 5.1 with Chrome engine, 40ms was enought to have all the previous
    // benefits, but was too quick for iOS (even 100ms was too quick for iOS 8.3).
    this.switchDelay = settings.switchDelay || 140;
}

module.exports = DomItemsManager;

DomItemsManager.prototype.getAllItems = function getAllItems() {
    return this.$root.children('[' + this.idAttributeName + ']');
};

DomItemsManager.prototype.find = function find(containerName, root) {
    var $root = $(root || this.$root);
    return $root.children('[' + this.idAttributeName + '="' + escapeSelector(containerName) + '"]');
};

DomItemsManager.prototype.getActive = function getActive() {
    return this.$root.children('[' + this.idAttributeName + ']:visible');
};

/**
    It adds the item in the html provided (can be only the element or 
    contained in another or a full html page).
    Replaces any existant if duplicates are not allowed.
**/
DomItemsManager.prototype.inject = function inject(name, html) {

    // Filtering input html (can be partial or full pages)
    // http://stackoverflow.com/a/12848798
    html = html.replace(/^[\s\S]*<body.*?>|<\/body>[\s\S]*$/g, '');

    // Creating a wrapper around the html
    // (can be provided the innerHtml or outerHtml, doesn't matters with next approach)
    var $html = $('<div/>', { html: html }),
        // We look for the container element (when the outerHtml is provided)
        $c = this.find(name, $html);

    if ($c.length === 0) {
        // Its innerHtml, so the wrapper becomes the container itself
        $c = $html.attr(this.idAttributeName, name);
    }

    if (!this.allowDuplicates) {
        // No more than one container instance can exists at the same time
        // We look for any existent one and its replaced with the new
        var $prev = this.find(name);
        if ($prev.length > 0) {
            $prev.replaceWith($c);
            $c = $prev;
        }
    }

    // Add to the document
    // (on the case of duplicated found, this will do nothing, no worry)
    $c.appendTo(this.$root);
};

/** 
    The switch method receive the items to interchange as active or current,
    the 'from' and 'to', and the shell instance that MUST be used
    to notify each event that involves the item:
    willClose, willOpen, ready, opened, closed.
    It receives as latest parameter the 'notification' object that must be
    passed with the event so handlers has context state information.
    
    It's designed to be able to manage transitions, but this default
    implementation is as simple as 'show the new and hide the old'.
**/
DomItemsManager.prototype.switch = function switchActiveItem($from, $to, shell, state) {

    var toName = state.route.name;
    //console.log('switch to', toName);
    
    this.disableAccess();
    
    function hideit() {
        var fromIsHidden = $from.is('[hidden]');
        if ($from.length > 0 && !fromIsHidden) {
            shell.emit(shell.events.willClose, $from, state);
            // Do 'unfocus' on the hidden element after notify 'willClose'
            // for better UX: hidden elements are not reachable and has good
            // side effects like hidding the on-screen keyboard if an input was
            // focused
            $from.find(':focus').blur();
            // hide and notify it ended
            $from
            .attr('hidden', 'hidden')
            // For browser that don't support attr
            .css('display', 'none')
            // Reset z-index to avoid overlapping effect
            .css('z-index', '');

            shell.emit(shell.events.closed, $from, state);
        }
        else {
            // Just unfocus to avoid keyboard problems
            $from.find(':focus').blur();
        }
    }

    var toIsHidden = $to.is('[hidden]'); // !$to.is(':visible')

    if (toIsHidden) {
        shell.emit(shell.events.willOpen, $to, state);
        // Put outside screen
        /* DONE ALREADY in the CSS class assigned to items
        $to.css({
            position: 'absolute',
            zIndex: -1,
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        });*/
        $to.css('zIndex', -1);

        // Show it:
        $to
        .removeAttr('hidden')
        // For browser that don't support attr
        .css('display', 'block');

        // Its enough visible and in DOM to perform initialization tasks
        // that may involve layout information
        shell.emit(shell.events.itemReady, $to, state);
        
        //console.log('SWITCH ready done, wait', toName);

        // Finish in a small delay, enough to allow some initialization
        // set-up that take some time to finish avoiding flickering effects
        setTimeout(function() {
            //console.log('SWITCH entering hide-show for', toName, shell.currentRoute.name);
            //console.log('ending switch to', toName, 'and current is', shell.currentRoute.name);
            // Race condition, redirection in the middle, abort:
            if (toName !== shell.currentRoute.name)
                return;
            
            // Hide the from
            hideit();
            
            // Ends opening, reset transitional styles
            /* SETUP IS ALREADY CORRECT in the CSS class assigned to items
            $to.css({
                position: '',
                top: '',
                bottom: '',
                left: '',
                right: '',
                zIndex: 2
            });
            */
            $to.css('zIndex', 2);
            
            this.enableAccess();
            
            //console.log('SWITCH ended for', toName);

            // When its completely opened
            shell.emit(shell.events.opened, $to, state);
        }.bind(this), this.switchDelay);
    } else {
        //console.log('ending switch to', toName, 'and current is', shell.currentRoute.name, 'INSTANT (to was visible)');
        // Race condition, redirection in the middle, abort:
        if (toName !== shell.currentRoute.name)
            return;
        
        // Its ready; maybe it was but sub-location
        // or state change need to be communicated
        shell.emit(shell.events.itemReady, $to, state);
        
        this.enableAccess();
        
        hideit();
    }
};

/**
    Initializes the list of items. No more than one
    must be opened/visible at the same time, so at the 
    init all the elements are closed waiting to set
    one as the active or the current one.
    
    Execute after DOM ready.
**/
DomItemsManager.prototype.init = function init() {
    // On ready, get the root element:
    this.$root = $(this.root || 'body');

    this.getAllItems()
    .attr('hidden', 'hidden')
    // For browser that don't support attr
    .css('display', 'none');
    
    // A layer to visually hide an opening item while not completed opened
    $('<div class="items-backstage"/>').css({
        background: this.$root.css('background-color') || 'white',
        position: 'absolute',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        zIndex: 0
    }).appendTo(this.$root);
    
    // A layer to disable access to an item (disabling events)
    // NOTE: Tried CSS pointer-events:none has some strange side-effects: auto scroll-up.
    // TODO: After some testing with this, scroll-up happens again with this (??)
    var $disableLayer = $('<div class="items-disable-layer"/>').css({
        background: 'White',
        opacity: 0,
        position: 'absolute',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        zIndex: -1
    }).appendTo(this.$root);
    this.disableAccess = function() {
        $disableLayer.css('zIndex', 90900);
    };
    this.enableAccess = function() {
        $disableLayer.css('zIndex', -2);
    };
};

},{"../escapeSelector":120}],129:[function(require,module,exports){
/**
    Javascritp Shell for SPAs.
**/
/*global window, document */
'use strict';

/** DI entry points for default builds. Most dependencies can be
    specified in the constructor settings for per-instance setup.
**/
var deps = require('./dependencies');

/** Constructor **/

function Shell(settings) {
    //jshint maxcomplexity:14
    
    deps.EventEmitter.call(this);

    this.$ = settings.jquery || deps.jquery;
    this.$root = this.$(settings.root);
    this.baseUrl = settings.baseUrl || '';
    // With forceHashbang=true:
    // - fragments URLs cannot be used to scroll to an element (default browser behavior),
    //   they are defaultPrevented to avoid confuse the routing mechanism and current URL.
    // - pressed links to fragments URLs are not routed, they are skipped silently
    //   except when they are a hashbang (#!). This way, special links
    //   that performn js actions doesn't conflits.
    // - all URLs routed through the shell includes a hashbang (#!), the shell ensures
    //   that happens by appending the hashbang to any URL passed in (except the standard hash
    //   that are skipt).
    this.forceHashbang = settings.forceHashbang || false;
    this.linkEvent = settings.linkEvent || 'click';
    this.parseUrl = (settings.parseUrl || deps.parseUrl).bind(this, this.baseUrl);
    this.absolutizeUrl = (settings.absolutizeUrl || deps.absolutizeUrl).bind(this, this.baseUrl);

    this.history = settings.history || window.history;

    this.indexName = settings.indexName || 'index';
    
    this.items = settings.domItemsManager;

    // loader can be disabled passing 'null', so we must
    // ensure to not use the default on that cases:
    this.loader = typeof(settings.loader) === 'undefined' ? deps.loader : settings.loader;
    // loader setup
    if (this.loader)
        this.loader.baseUrl = this.baseUrl;

    // Definition of events that this object can trigger,
    // its value can be customized but any listener needs
    // to keep updated to the correct event string-name used.
    // The items manipulation events MUST be triggered
    // by the 'items.switch' function
    this.events = {
        willOpen: 'shell-will-open',
        willClose: 'shell-will-close',
        itemReady: 'shell-item-ready',
        closed: 'shell-closed',
        opened: 'shell-opened'
    };
    
    /**
        A function to decide if the
        access is allowed (returns 'null')
        or not (return a state object with information
        that will be passed to the 'nonAccessName' item;
        the 'route' property on the state is automatically filled).
        
        The default buit-in just allow everything 
        by just returning 'null' all the time.
        
        It receives as parameter the state object,
        that almost contains the 'route' property with
        information about the URL.
    **/
    this.accessControl = settings.accessControl || deps.accessControl;
    // What item load on non access
    this.nonAccessName = settings.nonAccessName || 'index';
    
    // Access to the current route
    this.currentRoute = null;
    // Access to referrer/previous route
    this.referrerRoute = null;
}

// Shell inherits from EventEmitter
Shell.prototype = Object.create(deps.EventEmitter.prototype, {
    constructor: {
        value: Shell,
        enumerable: false,
        writable: true,
        configurable: true
    }
});

module.exports = Shell;


/** API definition **/

Shell.prototype.go = function go(url, state) {

    if (this.forceHashbang) {
        if (!/^#!/.test(url)) {
            url = '#!' + url;
        }
    }
    else {
        url = this.absolutizeUrl(url);
    }
    this.history.pushState(state, undefined, url);
    // pushState do NOT trigger the popstate event, so
    return this.replace(state);
};

Shell.prototype.goBack = function goBack(state, steps) {
    steps = 0 - (steps || 1);
    // If there is nothing to go-back or not enought
    // 'back' steps, go to the index
    if (steps < 0 && Math.abs(steps) >= this.history.length) {
        this.go(this.indexName);
    }
    else {
        // On replace, the passed state is merged with
        // the one that comes from the saved history
        // entry (it 'pops' when doing the history.go())
        this._pendingStateUpdate = state;
        this.history.go(steps);
    }
};

/**
    Process the given state in order to get the current state
    based on that or the saved in history, merge it with
    any updated state pending and adds the route information,
    returning an state object suitable to use.
**/
Shell.prototype.getUpdatedState = function getUpdatedState(state) {
    /*jshint maxcomplexity: 8 */
    
    // For current uses, any pendingStateUpdate is used as
    // the state, rather than the provided one
    state = this._pendingStateUpdate || state || this.history.state || {};
    
    // TODO: more advanced uses must be to use the 'state' to
    // recover the UI state, with any message from other UI
    // passing in a way that allow update the state, not
    // replace it (from pendingStateUpdate).
    /*
    // State or default state
    state = state || this.history.state || {};
    // merge pending updated state
    this.$.extend(state, this._pendingStateUpdate);
    // discard the update
    */
    this._pendingStateUpdate = null;
    
    // Doesn't matters if state includes already 
    // 'route' information, need to be overwritten
    // to match the current one.
    // NOTE: previously, a check prevented this if
    // route property exists, creating infinite loops
    // on redirections from activity.show since 'route' doesn't
    // match the new desired location
    
    // Detect if is a hashbang URL or an standard one.
    // Except if the app is forced to use hashbang.
    var isHashBang = /#!/.test(location.href) || this.forceHashbang;
    
    var link = (
        isHashBang ?
        location.hash :
        location.pathname
    ) + (location.search || '');
    
    // Set the route
    state.route = this.parseUrl(link);
    
    return state;
};

Shell.prototype.replace = function replace(state) {
    
    state = this.getUpdatedState(state);

    // Use the index on root calls
    if (state.route.root === true) {
        state.route = this.parseUrl(this.indexName);
    }
    
    this.referrerRoute = this.currentRoute;
    this.currentRoute = state.route;
    //console.log('shell replace', state.route);

    // Access control
    var accessError = this.accessControl(state.route);
    if (accessError) {
        return this.go(this.nonAccessName, accessError);
    }

    // Locating the container
    var $cont = this.items.find(state.route.name);
    var shell = this;
    var promise = null;

    if ($cont && $cont.length) {
        promise = new Promise(function(resolve, reject) {
            try {

                var $oldCont = shell.items.getActive();
                $oldCont = $oldCont.not($cont);
                shell.items.switch($oldCont, $cont, shell, state);
                //console.log('shell replace after switch', state.route);

                resolve(); //? resolve(act);
            }
            catch (ex) {
                reject(ex);
            }
        });
    }
    else {
        if (this.loader) {
            // load and inject the content in the page
            // then try the replace again
            promise = this.loader.load(state.route).then(function(html) {
                // Add to the items (the manager takes care you
                // add only the item, if there is one)
                shell.items.inject(state.route.name, html);
                // Double check that the item was added and is ready
                // to avoid an infinite loop because a request not returning
                // the item and the 'replace' trying to load it again, and again, and..
                if (shell.items.find(state.route.name).length)
                    return shell.replace(state);
            });
        }
        else {
            var err = new Error('Page not found (' + state.route.name + ')');
            console.warn('Shell Page not found, state:', state);
            promise = Promise.reject(err);
            
            // To avoid being in an inexistant URL (generating inconsistency between
            // current view and URL, creating bad history entries),
            // a goBack is executed, just after the current pipe ends
            // TODO: implement redirect that cut current processing rather than execute delayed
            setTimeout(function() {
                this.goBack();
            }.bind(this), 1);
        }
    }
    
    var thisShell = this;
    promise.catch(function(err) {
        if (!(err instanceof Error))
            err = new Error(err);

        // Log error, 
        console.error('Shell, unexpected error.', err);
        // notify as an event
        thisShell.emit('error', err);
        // and continue propagating the error
        return err;
    });

    return promise;
};

Shell.prototype.run = function run() {

    var shell = this;

    // Catch popstate event to update shell replacing the active container.
    // Allows polyfills to provide a different but equivalent event name
    this.$(window).on(this.history.popstateEvent || 'popstate', function(event) {
        
        var state = event.state || 
            (event.originalEvent && event.originalEvent.state) || 
            shell.history.state;

        // get state for current. To support polyfills, we use the general getter
        // history.state as fallback (they must be the same on browsers supporting History API)
        shell.replace(state);
    });

    // TODO: Review if all this next still is usable and has use cases, since the project
    // now uses fastclick library to avoid the iOS delay, using again click against tap event.
    //
    // Catch all links in the page (not only $root ones) and like-links.
    // IMPORTANT: the timeout and linkWorking is a kind of hack/workaround because of:
    // - iOS click delay: changing linkEvent to be 'tap click' (jqm tap event) or 
    //   more standard but simplistic 'touchend click', only on iOS if possible, the
    //   iOS click delay can be avoided, letting the touch event to trigger this Shell handler
    //   and preventing the click from happening to avoid double execution
    //   (thanks to linkWorking and setTimeout).
    //   A broken alternative would be to use only one event, like 'tap' or 'touchend', but
    //   they fall down when a touch gesture happens in the limit of a link/element because
    //   a touchstart happens out of our target link -failing touchend and tap since don't 
    //   get triggered in our link- but the browser/webview still executes (and inmediatly)
    //   the 'click' event on the link. It seems an edge case but is easier to make it happens
    //   than it seems. It's the bug that forced to implement this workaournd :-/
    // - And additionally: it prevents two 'clicks' from happening excessive fast because
    //   some kind of a second unwanted touch happening very fast, making
    //   a click by mistake on a different link on the loaded new page.
    var linkWorking = null,
        // OLD: iOS 300ms delay, a bit increased to avoid problems.
        // NOTE: as of inclusion of fastclick in the main project, reduced
        // this delay to avoid being noticeable on some edge cases, but still
        // preserving because other not verified use cases (like on a touch on a link that dynamically
        // changes being perceived as two quick consecutive clicks, executing two actions in one and that being unwanted)
        linkWorkingDelay = 80; // 340; // ms
    //DEBUG var linkEvent = this.linkEvent;
    this.$(document).on(this.linkEvent, '[href], [data-href]', function(e) {
        //DEBUG console.log('Shell on event', e.type, linkWorking);
        // If working, avoid everything:
        if (linkWorking) return false;
        linkWorking = setTimeout(function() {
            linkWorking = null;
        }, linkWorkingDelay);

        var $t = shell.$(this),
            href = $t.attr('href') || $t.data('href');
        
        //DEBUG console.log('Shell on', linkEvent, e.type, 'href', href, 'element', $t);

        // Do nothing if the URL contains the protocol
        if (/^[a-z]+:/i.test(href)) {
            return;
        }
        else if (shell.forceHashbang && /^#([^!]|$)/.test(href)) {
            // Standard hash, but not hashbang: avoid routing and default behavior
            e.preventDefault();
            // Trigger special event on the shell, so external scripts can do
            // something, like trying to implement standard scroll behavior or any
            // Pass in: source fragment link, element that receive the original event and
            // the original event.
            shell.emit('fragmentNavigation', href, this, e);
            return;
        }

        e.preventDefault();

        // Executed delayed to avoid handler collisions, because
        // of the new page modifying the element and other handlers
        // reading it attributes and applying logic on the updated link
        // as if was the old one (example: shared links, like in a
        // global navbar, that modifies with the new page).
        setTimeout(function() {
            shell.go(href);
        }, 1);
    });

    // Initiallize state
    this.items.init();
    // Route to the current url/state
    this.replace();
};

},{"./dependencies":131}],130:[function(require,module,exports){
/**
    absolutizeUrl utility 
    that ensures the url provided
    being in the path of the given baseUrl
**/
'use strict';

var sanitizeUrl = require('./sanitizeUrl'),
    escapeRegExp = require('../escapeRegExp');

function absolutizeUrl(baseUrl, url) {

    // sanitize before check
    url = sanitizeUrl(url);

    // Check if use the base already
    var matchBase = new RegExp('^' + escapeRegExp(baseUrl), 'i');
    if (matchBase.test(url)) {
        return url;
    }

    // build and sanitize
    return sanitizeUrl(baseUrl + url);
}

module.exports = absolutizeUrl;

},{"../escapeRegExp":119,"./sanitizeUrl":136}],131:[function(require,module,exports){
/**
    External dependencies for Shell in a separate module
    to use as DI, needs setup before call the Shell.js
    module class
**/
'use strict';

module.exports = {
    parseUrl: null,
    absolutizeUrl: null,
    jquery: null,
    loader: null,
    accessControl: function allowAll(/*name*/) {
        // allow access by default
        return null;
    },
    EventEmitter: null
};

},{}],132:[function(require,module,exports){
/**
    Simple implementation of the History API using only hashbangs URLs,
    doesn't matters the browser support.
    Used to avoid from setting URLs that has not an end-point,
    like in local environments without a server doing url-rewriting,
    in phonegap apps, or to completely by-pass browser support because
    is buggy (like Android <= 4.1).
    
    NOTES:
    - Browser must support 'hashchange' event.
    - Browser must has support for standard JSON class.
    - Relies on sessionstorage for persistance, supported by all browsers and webviews 
      for a enough long time now.
    - Similar approach as History.js polyfill, but simplified, appending a fake query
      parameter '_suid=0' to the hash value (actual query goes before the hash, but
      we need it inside).
    - For simplification, only the state is persisted, the 'title' parameter is not
      used at all (the same as major browsers do, so is not a problem); in this line,
      only history entries with state are persisted.
      
    TODO replaceState does not work as expected, it creates a history entry rather than replace it
        A solution idea is to perform a browser go(-1) and the then hash change (push), but the go back
        must bypass the events notification.
**/
//global location
'use strict';
var $ = require('jquery'),
    sanitizeUrl = require('./sanitizeUrl'),
    getUrlQuery = require('../getUrlQuery');

// Init: Load saved copy from sessionStorage
var session = sessionStorage.getItem('hashbangHistory.store');
// Or create a new one
if (!session) {
    session = {
        // States array where each index is the SUID code and the
        // value is just the value passed as state on pushState/replaceState
        states: []
    };
}
else {
    session = JSON.parse(session);
}


/**
    Get the SUID number
    from a hash string
**/
function getSuid(hash) {
    
    var suid = +getUrlQuery(hash)._suid;
    if (isNaN(suid))
        return null;
    else
        return suid;
}

function setSuid(hash, suid) {
    
    // We need the query, since we need 
    // to replace the _suid (may exist)
    // and recreate the query in the
    // returned hash-url
    var qs = getUrlQuery(hash);
    qs.push('_suid');
    qs._suid = suid;

    var query = [];
    for(var i = 0; i < qs.length; i++) {
        query.push(qs[i] + '=' + encodeURIComponent(qs[qs[i]]));
    }
    query = query.join('&');
    
    if (query) {
        var index = hash.indexOf('?');
        if (index > -1)
            hash = hash.substr(0, index);
        hash += '?' + query;
    }

    return hash;
}

/**
    Ask to persist the session data.
    It is done with a timeout in order to avoid
    delay in the current task mainly any handler
    that acts after a History change.
**/
function persist() {
    // Enough time to allow routing tasks,
    // most animations from finish and the UI
    // being responsive.
    // Because sessionStorage is synchronous.
    setTimeout(function() {
        sessionStorage.setItem('hashbangHistory.store', JSON.stringify(session));
    }, 1500);
}

/**
    Returns the given state or null
    if is an empty object.
**/
function checkState(state) {
    
    if (state) {
        // is empty?
        if (Object.keys(state).length > 0) {
            // No
            return state;
        }
        // its empty
        return null;
    }
    // Anything else
    return state;
}

/**
    Get a canonical representation
    of the URL so can be compared
    with success.
**/
function cannonicalUrl(url) {
    
    // Avoid some bad or problematic syntax
    url = sanitizeUrl(url || '');
    
    // Get the hash part
    var ihash = url.indexOf('#');
    if (ihash > -1) {
        url = url.substr(ihash + 1);
    }
    // Maybe a hashbang URL, remove the
    // 'bang' (the hash was removed already)
    url = url.replace(/^!/, '');

    return url;
}

/**
    Tracks the latest URL
    being pushed or replaced by
    the API.
    This allows later to avoid
    trigger the popstate event,
    since must NOT be triggered
    as a result of that API methods
**/
var latestPushedReplacedUrl = null;

/**
    History Polyfill
**/
var hashbangHistory = {
    pushState: function pushState(state, title, url) {

        // cleanup url
        url = cannonicalUrl(url);
        
        // save new state for url
        state = checkState(state) || null;
        if (state !== null) {
            // save state
            session.states.push(state);
            var suid = session.states.length - 1;
            // update URL with the suid
            url = setSuid(url, suid);
            // call to persist the updated session
            persist();
        }
        
        latestPushedReplacedUrl = url;
        
        // update location to track history:
        location.hash = '#!' + url;
    },
    replaceState: function replaceState(state, title, url) {
        
        // cleanup url
        url = cannonicalUrl(url);
        
        // it has saved state?
        var suid = getSuid(url),
            hasOldState = suid !== null;

        // save new state for url
        state = checkState(state) || null;
        // its saved if there is something to save
        // or something to destroy
        if (state !== null || hasOldState) {
            // save state
            if (hasOldState) {
                // replace existing state
                session.states[suid] = state;
                // the url remains the same
            }
            else {
                // create state
                session.states.push(state);
                suid = session.states.length - 1;
                // update URL with the suid
                url = setSuid(url, suid);
            }
            // call to persist the updated session
            persist();
        }
        
        latestPushedReplacedUrl = url;

        // update location to track history:
        location.hash = '#!' + url;
    },
    get state() {
        
        var suid = getSuid(location.hash);
        return (
            suid !== null ?
            session.states[suid] :
            null
        );
    },
    get length() {
        return window.history.length;
    },
    go: function go(offset) {
        window.history.go(offset);
    },
    back: function back() {
        window.history.back();
    },
    forward: function forward() {
        window.history.forward();
    }
};

// Attach hashcange event to trigger History API event 'popstate'
var $w = $(window);
$w.on('hashchange', function(e) {
    
    var url = e.originalEvent.newURL;
    url = cannonicalUrl(url);
    
    // An URL being pushed or replaced
    // must NOT trigger popstate
    if (url === latestPushedReplacedUrl)
        return;
    
    // get state from history entry
    // for the updated URL, if any
    // (can have value when traversing
    // history).
    var suid = getSuid(url),
        state = null;
    
    if (suid !== null)
        state = session.states[suid];

    $w.trigger(new $.Event('popstate', {
        state: state
    }), 'hashbangHistory');
});

// For HistoryAPI capable browsers, we need
// to capture the native 'popstate' event that
// gets triggered on our push/replaceState because
// of the location change, but too on traversing
// the history (back/forward).
// We will lock the event except when is
// the one we trigger.
//
// NOTE: to this trick to work, this must
// be the first handler attached for this
// event, so can block all others.
// ALTERNATIVE: instead of this, on the
// push/replaceState methods detect if
// HistoryAPI is native supported and
// use replaceState there rather than
// a hash change.
$w.on('popstate', function(e, source) {
    
    // Ensuring is the one we trigger
    if (source === 'hashbangHistory')
        return;
    
    // In other case, block:
    e.preventDefault();
    e.stopImmediatePropagation();
});

// Expose API
module.exports = hashbangHistory;

},{"../getUrlQuery":123,"./sanitizeUrl":136}],133:[function(require,module,exports){
/**
    Default build of the Shell component.
    It returns the Shell class as a module property,
    setting up the built-in modules as its dependencies,
    and the external 'jquery' and 'events' (for the EventEmitter).
    It returns too the built-it DomItemsManager class as a property for convenience.
**/
'use strict';

var deps = require('./dependencies'),
    DomItemsManager = require('./DomItemsManager'),
    parseUrl = require('./parseUrl'),
    absolutizeUrl = require('./absolutizeUrl'),
    $ = require('jquery'),
    loader = require('./loader'),
    EventEmitter = require('events').EventEmitter;

$.extend(deps, {
    parseUrl: parseUrl,
    absolutizeUrl: absolutizeUrl,
    jquery: $,
    loader: loader,
    EventEmitter: EventEmitter
});

// Dependencies are ready, we can load the class:
var Shell = require('./Shell');

exports.Shell = Shell;
exports.DomItemsManager = DomItemsManager;

},{"./DomItemsManager":128,"./Shell":129,"./absolutizeUrl":130,"./dependencies":131,"./loader":134,"./parseUrl":135,"events":false}],134:[function(require,module,exports){
/**
    Loader utility to load Shell items on demand with AJAX
**/
'use strict';

var $ = require('jquery');

module.exports = {
    
    baseUrl: '/',
    
    load: function load(route) {
        return new Promise(function(resolve, reject) {
            console.log('Shell loading on demand', route.name, route);
            $.ajax({
                url: module.exports.baseUrl + route.name + '.html',
                cache: false
                // We are loading the program and no loader screen in place,
                // so any in between interaction will be problematic.
                //async: false
            }).then(resolve, reject);
        });
    }
};

},{}],135:[function(require,module,exports){
/**
    parseUrl function detecting
    the main parts of the URL in a
    convenience way for routing.
**/
'use strict';

var getUrlQuery = require('../getUrlQuery'),
    escapeRegExp = require('../escapeRegExp');

function parseUrl(baseUrl, link) {

    link = link || '';

    var rawUrl = link;

    // hashbang support: remove the #! or single # and use the rest as the link
    link = link.replace(/^#!/, '').replace(/^#/, '');
    
    // remove optional initial slash or dot-slash
    link = link.replace(/^\/|^\.\//, '');

    // URL Query as an object, empty object if no query
    var query = getUrlQuery(link || '?');

    // remove query from the rest of URL to parse
    link = link.replace(/\?.*$/, '');

    // Remove the baseUrl to get the app base.
    var path = link.replace(new RegExp('^' + escapeRegExp(baseUrl), 'i'), '');

    // Get first segment or page name (anything until a slash or extension beggining)
    var match = /^\/?([^\/\.]+)[^\/]*(\/.*)*$/.exec(path);

    var parsed = {
        root: true,
        name: null,
        segments: null,
        path: null,
        url: rawUrl,
        query: query
    };

    if (match) {
        parsed.root = false;
        if (match[1]) {
            parsed.name = match[1];

            if (match[2]) {
                parsed.path = match[2];
                parsed.segments = match[2].replace(/^\//, '').split('/');
            }
            else {
                parsed.path = '/';
                parsed.segments = [];
            }
        }
    }

    return parsed;
}

module.exports = parseUrl;
},{"../escapeRegExp":119,"../getUrlQuery":123}],136:[function(require,module,exports){
/**
    sanitizeUrl utility that ensures
    that problematic parts get removed.
    
    As for now it does:
    - removes parent directory syntax
    - removes duplicated slashes
**/
'use strict';

function sanitizeUrl(url) {
    return url.replace(/\.{2,}/g, '').replace(/\/{2,}/g, '/');
}

module.exports = sanitizeUrl;
},{}],137:[function(require,module,exports){
/**
    Small utility to search a text fragment using
    case insensitive, accent/symbol insensitive.
**/
'use strict';

var removeAccent = require('./removeAccent');

module.exports = function textSearch(search, text) {

    var s = removeAccent(search || '').toLowerCase(),
        t = removeAccent(text || '').toLowerCase();

    return t.indexOf(s) > -1;
};

},{"./removeAccent":126}],138:[function(require,module,exports){
/** AppointmentCard view model.
    It provides data and method to visualize and 
    edit and appointment card, with booking, event
    or placeholder information
**/

var ko = require('knockout'),
    moment = require('moment'),
    getObservable = require('../utils/getObservable'),
    Appointment = require('../models/Appointment'),
    AppointmentView = require('../viewmodels/AppointmentView'),
    ModelVersion = require('../utils/ModelVersion'),
    getDateWithoutTime = require('../utils/getDateWithoutTime'),
    PricingEstimateDetail = require('../models/PricingEstimateDetail');

function AppointmentCardViewModel(params) {
    /*jshint maxstatements: 40*/

    this.sourceItem = getObservable(params.sourceItem);
    var app = this.app = ko.unwrap(params.app);

    this.editMode = getObservable(params.editMode);
    this.editedVersion = ko.observable(null);
    
    this.isSaving = ko.observable(false);
    this.isLoading = getObservable(params.isLoading);
    this.isLocked = ko.computed(function() {
        return this.isSaving() || this.isLoading();
    }, this);
    
    this.item = ko.observable(AppointmentView(this.sourceItem(), app));
    
    this.allowBookUnavailableTime = ko.observable(false);
    
    this.currentID = ko.pureComputed(function() {
        var it = this.item();
        return it && it.id() || 0;
    }, this);
    
    this.currentDatetime = ko.pureComputed(function() {
        return this.item() && this.item().startTime() || new Date();
    }, this);
    
    this.currentDate = ko.pureComputed(function() {
        return getDateWithoutTime(this.item() && this.item().startTime());
    }, this);
    
    this.isNew = ko.computed(function() {
        var id = this.currentID();
        return id === Appointment.specialIds.newBooking || id === Appointment.specialIds.newEvent;
    }, this);
    
    this.isBooking = ko.computed(function() {
        return this.item() && this.item().sourceBooking();
    }, this);
    
    /* Return true if is an event object but not a booking */
    this.isEvent = ko.computed(function() {
        return this.item() && this.item().sourceEvent() && !this.item().sourceBooking();
    }, this);
    
    this.headerClass = ko.pureComputed(function() {
        return (
            this.isBooking() ? (this.editMode() ? 'Card-title--warning' : 'Card-title--primary') :
            this.isEvent() ? 'Card-title--danger' :
            ''
        );
    }, this);
    
    this.newAppointmentVisible = ko.pureComputed(function() {
        var id = this.currentID();
        return id === Appointment.specialIds.free || id === Appointment.specialIds.emptyDate || id === Appointment.specialIds.unavailable;
    }, this);
    
    this.editScheduleVisible = ko.pureComputed(function() {
        return this.currentID() === Appointment.specialIds.unavailable;
    }, this);
    
    this.submitText = ko.pureComputed(function() {
        var v = this.editedVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        this.isNew() && this.isBooking() ?
                            'Book' :
                            'Save changes'
                        : 'Saved'
        );
    }, this);

    /**
        If the sourceItem changes, is set as the item value
        discarding any model version and reverting
        editMode to false
    **/
    this.sourceItem.subscribe(function(sourceItem) {
        this.item(AppointmentView(sourceItem, app));
        this.editedVersion(null);
        this.editMode(false);

        // If the new item is a new one, set edit mode
        if (this.isNew()) {
            this.editMode(true);
        }
    }, this);

    /**
        Enter and finish edit:
        Create version and save data
    **/
    this.editMode.subscribe(function(isEdit) {
        if (this.currentID() <= 0 && !this.isNew()) {
            return;
        }
        if (isEdit) {
            // Create and set a version to be edited
            var version = new ModelVersion(this.sourceItem());
            version.version.sourceEvent(this.sourceItem().sourceEvent());
            version.version.sourceBooking(this.sourceItem().sourceBooking());
            this.editedVersion(version);
            this.item(AppointmentView(version.version, app));
            
            if (this.isNew() && this.isEvent()) {
                // Some defaults for events
                this.item().sourceEvent().availabilityTypeID(0); // Unavailable
                this.item().isAllDay(false);
                this.item().sourceEvent().eventTypeID(3); // Appointment/block-time
                this.item().summary('');
            }
        }
        else {
            this.item(AppointmentView(this.sourceItem(), app));
        }
    }, this);

    this.edit = function edit() {
        if (this.isLocked()) return;

        // A subscribed handler ensure to do the needed tasks
        this.editMode(true);
    }.bind(this);
    
    this.save = function save() {
        if (this.isLocked()) return;

        // There is a version? Push changes!
        var version = this.editedVersion();

        if (version && version.areDifferent()) {
            this.isSaving(true);
            app.model.calendar.setAppointment(version.version, this.allowBookUnavailableTime())
            .then(function(savedApt) {
                // Do not do a version push, just update with remote
                //version.push({ evenIfObsolete: true });
                // Update with remote data, the original appointment in the version,
                // not the currentAppointment or in the index in the list to avoid
                // race-conditions
                version.original.model.updateWith(savedApt);
                // Do a pull so original and version gets the exact same data
                version.pull({ evenIfNewer: true });

                // Go out edit mode
                this.editMode(false);
                
                // Notify
                if (this.isBooking()) {
                    
                    var msg = this.item().customer().firstName() + ' will receive an e-mail confirmation.';
                    
                    app.modals.showNotification({
                        title: 'Confirmed!',
                        message: msg
                    });
                }
                
            }.bind(this))
            .catch(function(err) {
                // The version data keeps untouched, user may want to retry
                // or made changes on its un-saved data.
                // Show error
                app.modals.showError({
                    title: 'There was an error saving the data.',
                    error: err
                });
                // Don't replicate error, allow always
            })
            .then(function() {
                // ALWAYS:
                this.isSaving(false);
            }.bind(this));
        }
    }.bind(this);

    this.cancel = function cancel() {
        if (this.isLocked()) return;

        if (this.editedVersion()) {
            // Discard previous version
            this.editedVersion().pull({ evenIfNewer: true });
        }
        // Out of edit mode
        this.editMode(false);
    }.bind(this);

    /**
        External actions
    **/
    var editFieldOn = function editFieldOn(activity, data) {

        // Include appointment to recover state on return:
        data.appointment = this.item().model.toPlainObject(true);
        
        data.cancelLink = this.cancelLink;
        
        if (this.progress &&
            !this.progress.ended) {
            data.progress = this.progress;
            var step = data.progress.step || 1,
                total = data.progress.total || 1;
            // TODO I18N
            data.title = step + ' of ' + total;
            data.navTitle = null;
        } else {
            // keep data.progress so it does not restart the process after
            // an edition. The passIn already resets that on new calls
            data.progress = this.progress;
            // Edition title:
            data.title = null;
            data.navTitle = this.isBooking() ? 'Booking' : 'Event';
        }

        app.shell.go(activity, data);
    }.bind(this);

    this.pickDateTime = function pickDateTime() {
        if (this.isLocked()) return;

        editFieldOn('datetimePicker', {
            selectedDatetime: this.item().startTime(),
            datetimeField: 'startTime',
            headerText: 'Select the start time',
            requiredDuration: this.item().getServiceDurationMinutes()
        });
    }.bind(this);

    this.pickEndDateTime = function pickEndDateTime() {
        if (this.isLocked()) return;

        editFieldOn('datetimePicker', {
            selectedDatetime: this.item().endTime(),
            datetimeField: 'endTime',
            headerText: 'Select the end time'
        });
    }.bind(this);

    this.pickClient = function pickClient() {
        if (this.isLocked()) return;

        editFieldOn('clients', {
            selectClient: true,
            selectedClientID: this.item().sourceBooking().bookingRequest().customerUserID()
        });
    }.bind(this);

    this.pickService = function pickService() {
        if (this.isLocked()) return;

        editFieldOn('freelancerPricing/' + this.item().jobTitleID(), {
            selectPricing: true,
            selectedPricing: this.item().pricing()
            .map(function(pricing) {
                return {
                    freelancerPricingID: ko.unwrap(pricing.freelancerPricingID),
                    totalPrice: ko.unwrap(pricing.totalPrice)
                };
            })
        });
    }.bind(this);

    this.changePrice = function changePrice() {
        if (this.isLocked()) return;
        // TODO
    }.bind(this);

    this.pickLocation = function pickLocation() {
        if (this.isLocked()) return;

        editFieldOn('serviceAddresses/' + this.item().jobTitleID(), {
            selectAddress: true,
            selectedAddressID: this.item().addressID()
        });
    }.bind(this);

    var textFieldsHeaders = {
        preNotesToClient: 'Notes to client',
        postNotesToClient: 'Notes to client (afterwards)',
        preNotesToSelf: 'Notes to self',
        postNotesToSelf: 'Booking summary',
        summary: 'What?'
    };

    this.editTextField = function editTextField(field) {
        if (this.isLocked()) return;

        editFieldOn('textEditor', {
            request: 'textEditor',
            field: field,
            title: this.isNew() ? 'New booking' : 'Booking',
            header: textFieldsHeaders[field],
            text: this.item()[field]()
        });
    }.bind(this);
    
    // pass this ready model view as an API to the outside
    if (typeof(params.api) === 'function') {
        params.api(this);
    }
    
    // Calculate the endTime given an appointment duration, retrieved
    // from the selected service
    ko.computed(function calculateEndTime() {
        var duration = this.item().serviceDurationMinutes(),
            start = moment(this.item().startTime()),
            end;

        if (this.isBooking() &&
            start.isValid()) {
            end = start.add(duration, 'minutes').toDate();
            this.item().endTime(end);
        }
    }, this)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
}

/**
    It manages incoming data provided by external activities given
    the requestData received by the activity hosting this view instance.
    Used to manage the data returned by calls to edit data in
    external activities.
**/
AppointmentCardViewModel.prototype.passIn = function passIn(requestData) {
    /*jshint maxcomplexity:20,maxstatements:40 */
    
    // If the request includes an appointment plain object, that's an
    // in-editing appointment so put it in place (to restore a previous edition)
    if (requestData.appointment) {
        // Set the edit mode (it performs any required
        // set-up if we are not still in edit mode).
        this.editMode(true);
        // Sets the data
        this.item()
        .model.updateWith(requestData.appointment);
    }
    else if (!this.isNew()) {
        // On any other case, and to prevent a bad editMode state,
        // set off edit mode discarding unsaved data:
        this.cancel();
    }

    /// Manage specific single data from externally provided
    
    // It comes back from the textEditor.
    if (requestData.request === 'textEditor') {
        this.item()[requestData.field](requestData.text);
    }
    if (requestData.selectClient === true) {
        this.item().customerUserID(requestData.selectedClientID);
    }
    if (typeof(requestData.selectedDatetime) !== 'undefined') {
        var field = requestData.datetimeField;
        this.item()[field](requestData.selectedDatetime);
        this.allowBookUnavailableTime(requestData.allowBookUnavailableTime);
    }
    if (requestData.selectedJobTitleID) {
        this.item().jobTitleID(requestData.selectedJobTitleID);
    }
    if (requestData.selectAddress === true) {
        this.item().addressID(requestData.selectedAddressID);
    }
    if (requestData.selectPricing === true) {
        this.item().pricing(
            requestData.selectedPricing.map(function(pricing) {
                return new PricingEstimateDetail(pricing);
            })
        );
    }
    
    if (this.isNew()) {
        if (requestData && requestData.cancelLink) {
            this.cancelLink = requestData.cancelLink;
        }
        else {
            // Using the Referrer URL as the link when cancelling the task
            var referrerUrl = this.app.shell.referrerRoute;
            referrerUrl = referrerUrl && referrerUrl.url || 'calendar';

            this.cancelLink = referrerUrl;
        }
    }

    // Special behavior for adding a booking: it requires a guided creation
    // through a progress path
    if (this.currentID() === Appointment.specialIds.newBooking) {
        if (!requestData.progress) {
            // Start!
            this.progress = {
                step: 1,
                total: 4,
                ended: false
            };
            // First step
            this.pickClient(); //._delayed(50)();
        }
        else if (requestData.progress) {
            this.progress = requestData.progress;
            var step = this.progress.step || 1;
            if (step < 2) {
                // Second step
                this.progress.step = 2;
                this.pickService();//._delayed(50)();
            }
            else if (step < 3) {
                // Thrid step
                requestData.progress.step = 3;
                this.pickDateTime();//._delayed(50)();
            }
            else if (step < 4) {
                requestData.progress.step = 4;
                this.pickLocation();//._delayed(50)();
            }
            else {
                // Steps finished, not it enters in revision mode before
                // finally save/create the booking, but remove the progress info
                // to avoid problems editing fields.
                this.progress.ended = true;
            }
        }
    } else {
        // Reset progress
        this.progress = null;
    }
};


module.exports = AppointmentCardViewModel;

},{"../models/Appointment":70,"../models/PricingEstimateDetail":90,"../utils/ModelVersion":110,"../utils/getDateWithoutTime":121,"../utils/getObservable":122,"../viewmodels/AppointmentView":139,"knockout":false,"moment":false}],139:[function(require,module,exports){
/**
    Appointment View model that wraps an Appointment
    model instance extended with extra methods connected
    to related data
**/
'use strict';

var ko = require('knockout');

module.exports = function AppointmentView(appointment, app) {
    if (appointment._isAppointmentView) return appointment;
    appointment._isAppointmentView = true;

    appointment.customer = ko.computed(function() {
        var b = this.sourceBooking();
        if (!b) return null;
        
        var cid = this.customerUserID();
        if (cid) {
            return app.model.customers.getObservableItem(cid, true)();
        }
        return null;
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    appointment.address = ko.computed(function() {
        var aid = this.addressID(),
            jid = this.jobTitleID();
        if (aid && jid) {
            return app.model.serviceAddresses.getObservableItem(jid, aid, true)();
        }
        return null;
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });

    appointment.addressSummary = ko.computed(function() {
        var eventData = this.sourceEvent();
        var add = this.address();
        return add && add.singleLine() || eventData && eventData.location() || '';
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    /* Property with the pricing array plus information about the
        freelancerPricing.
    */
    appointment.pricingWithInfo = ko.computed(function() {
        var b = this.sourceBooking();
        if (!b) return [];

        var jid = this.jobTitleID(),
            details = this.pricing();

        return details.map(function(det) {
            return PricingEstimateDetailView(det, jid, app);
        });
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 60 } });

    appointment.servicesSummary = ko.computed(function() {
        return this.pricingWithInfo()
        .map(function(service) {
            return service.freelancerPricing().name();
        }).join(', ');
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    // TODO Review for any change of compute the full service duration
    // ServiceDuration as function, because is needed for cases when cannot wait for the 
    // rated computed
    appointment.getServiceDurationMinutes = function() {
        var pricing = this.pricingWithInfo();
        var sum = pricing.reduce(function(prev, service) {
            return prev + service.freelancerPricing().serviceDurationMinutes();
        }, 0);
        return sum;
    };
    // ServiceDuration as computed so can be observed for changes
    appointment.serviceDurationMinutes = ko.computed(function() {
        return this.getServiceDurationMinutes();
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    // TODO Review if calculation of fees and that is needed
    ko.computed(function() {
        var pricing = appointment.pricing();
        this.price(pricing.reduce(function(prev, cur) {
            return prev + cur.totalPrice();
        }, 0));
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });

    return appointment;
};

function PricingEstimateDetailView(pricingEstimateDetail, jobTitleID, app) {

    pricingEstimateDetail.freelancerPricing = ko.computed(function() {
        var pid = this.freelancerPricingID();
        return app.model.freelancerPricing
            .getObservableItem(jobTitleID, pid, true)();
    }, pricingEstimateDetail)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });

    return pricingEstimateDetail;
}

},{"knockout":false}],140:[function(require,module,exports){
/**
    Simple View Model with main credentials for
    use in a form, with validation.
    Used by Login and Signup activities
**/
'use strict';

var ko = require('knockout');

function FormCredentials() {

    this.username = ko.observable('');
    this.password = ko.observable('');
    
    // validate username as an email
    var emailRegexp = /^[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+@[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+$/;
    this.username.error = ko.observable('');
    this.username.subscribe(function(v) {
        if (v) {
            if (emailRegexp.test(v)) {
                this.username.error('');
            }
            else {
                this.username.error('Is not a valid email');
            }
        }
        else {
            this.username.error('Required');
        }
    }.bind(this));
    
    // required password
    this.password.error = ko.observable('');
    this.password.subscribe(function(v) {
        var err = '';
        if (!v)
            err = 'Required';
        
        this.password.error(err);
    }.bind(this));
}

module.exports = FormCredentials;

},{"knockout":false}],141:[function(require,module,exports){
/** NavAction view model.
    It allows set-up per activity for the AppNav action button.
**/
var Model = require('../models/Model');

function NavAction(values) {
    
    Model(this);
    
    this.model.defProperties({
        link: '',
        icon: '',
        text: '',
        // 'Test' is the header title but placed in the button/action
        isTitle: false,
        // 'Link' is the element ID of a modal (starts with a #)
        isModal: false,
        // 'Link' is a Shell command, like 'goBack 2'
        isShell: false,
        // Set if the element is a menu button, in that case 'link'
        // will be the ID of the menu (contained in the page; without the hash), using
        // the text and icon but special meaning for the text value 'menu'
        // on icon property that will use the standard menu icon.
        isMenu: false,
        // Custom function as event handler for button click.
        // The standard link gets disabled with this
        handler: null
    }, values);
    
    this.runHandler = function runHandler(obj, event) {
        var handler = this.handler();
        if (handler) {
            event.stopImmediatePropagation();
            event.preventDefault();
            handler.call(this, event, obj);
        }
    }.bind(this);
}

module.exports = NavAction;

// Set of view utilities to get the link for the expected html attributes

NavAction.prototype.getHref = function getHref() {
    return (
        (this.handler() || this.isMenu() || this.isModal() || this.isShell()) ?
        '#' :
        this.link()
    );
};

NavAction.prototype.getModalTarget = function getModalTarget() {
    return (
        (this.handler() || this.isMenu() || !this.isModal() || this.isShell()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getShellCommand = function getShellCommand() {
    return (
        (this.handler() || this.isMenu() || !this.isShell()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getMenuID = function getMenuID() {
    return (
        (this.handler() || !this.isMenu()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getMenuLink = function getMenuLink() {
    return (
        (this.handler() || !this.isMenu()) ?
        '' :
        '#' + this.link()
    );
};

/** Static, shared actions **/
NavAction.goHome = new NavAction({
    link: '/',
    icon: 'fa ion ion-stats-bars'
});

NavAction.goBack = new NavAction({
    link: 'goBack',
    icon: 'fa ion ion-ios-arrow-left',
    isShell: true
});

NavAction.menuIn = new NavAction({
    link: 'menuIn',
    icon: 'menu',
    isMenu: true
});

NavAction.menuOut = new NavAction({
    link: 'menuOut',
    icon: 'menu',
    isMenu: true
});

NavAction.menuNewItem = new NavAction({
    link: 'menuNewItem',
    icon: 'fa ion ion-ios-plus-empty',
    isMenu: true
});

NavAction.goHelpIndex = new NavAction({
    link: '#helpIndex',
    text: 'help',
    isModal: true
});

NavAction.goLogin = new NavAction({
    link: '/login',
    text: 'log-in'
});

NavAction.goLogout = new NavAction({
    link: '/logout',
    text: 'log-out'
});

NavAction.goSignup = new NavAction({
    link: '/signup',
    text: 'sign-up'
});

},{"../models/Model":87}],142:[function(require,module,exports){
/** NavBar view model.
    It allows customize the NavBar per activity.
**/
var Model = require('../models/Model');
    //NavAction = require('./NavAction');

function NavBar(values) {
    
    Model(this);
    
    this.model.defProperties({
        // Title showed in the center
        // When the title is 'null', the app logo is showed in place,
        // on empty text, the empty text is showed and no logo.
        title: '',
        // NavAction instance:
        leftAction: null,
        // NavAction instance:
        rightAction: null
    }, values);
}

module.exports = NavBar;

},{"../models/Model":87}],143:[function(require,module,exports){
/** OnboardingProgress view model.
    It tracks the onboarding information and methods
    to update views to that state
**/
var Model = require('../models/Model'),
    ko = require('knockout');

function OnboardingProgress(values) {

    Model(this);
    
    this.model.defProperties({
        group: '',
        stepNumber: -1,
        steps: []
    }, values);
    
    this.totalSteps = ko.pureComputed(function() {
        // 'Zero' step is a welcome, not accounted:
        return this.steps().length - 1;
    }, this);
    
    this.stepName = ko.pureComputed(function() {
        var num = this.stepNumber(),
            tot = this.steps().length;

        if (tot > 0 &&
            num > -1 &&
            num < tot) {
            var name = this.steps()[num] || '';
            return name;
        }
        else {
            return null;
        }
    }, this);
    
    this.stepUrl = ko.pureComputed(function() {
        var url = this.stepName();
        if (url && !/^\//.test(url))
            url = '/' + url;
        return url;
    }, this);

    this.stepReference = ko.pureComputed(function() {
        return this.group() + ':' + this.stepName();
    }, this);
    
    this.progressText = ko.pureComputed(function() {
        // TODO L18N
        return this.stepNumber() + ' of ' + this.totalSteps();
    }, this);
    
    this.inProgress = ko.pureComputed(function() {
        return !!this.stepUrl();
    }, this);
}

module.exports = OnboardingProgress;

OnboardingProgress.prototype.setStepByName = function setStepByName(name) {
    var stepIndex = this.steps().indexOf(name);
    if (stepIndex > -1) {
        this.stepNumber(stepIndex);
        return true;
    }
    return false;
};

/**
    Static list of all the steps groups for the app
**/
OnboardingProgress.predefinedStepGroups = {
    // Scheduling onboarding, aka welcome
    welcome: [
        'welcome',
        'addJobTitles',
        // disabled on 2015-06-16 as of #575 comments
        //'freelancerPricing',
        //'serviceAddresses',
        'weeklySchedule',
        'contactInfo'
    ],
    marketplace: [
    ],
    payment: [
    ]
};

},{"../models/Model":87,"knockout":false}],144:[function(require,module,exports){
/**
    TimeSlot view model (aka: CalendarSlot) for use
    as part of the template/component time-slot-tile or activities
    providing data for the template.
**/
'use strict';

var getObservable = require('../utils/getObservable');

function TimeSlotViewModel(params) {
    /*jshint maxcomplexity:9*/

    this.startTime = getObservable(params.startTime || null);
    this.endTime = getObservable(params.endTime || null);
    this.subject = getObservable(params.subject || null);
    this.description = getObservable(params.description || null);
    this.link = getObservable(params.link || null);
    this.actionIcon = getObservable(params.actionIcon || null);
    this.actionText = getObservable(params.actionText || null);
    this.classNames = getObservable(params.classNames || null);
}

module.exports = TimeSlotViewModel;

var numeral = require('numeral'),
    Appointment = require('../models/Appointment');

/**
    Static constructor to convert an Appointment model into 
    a TimeSlot instance following UI criteria for preset values/setup.
**/
TimeSlotViewModel.fromAppointment = function fromAppointment(apt) {
    /*jshint maxcomplexity:10 */
    
    // Commented the option to detect and not link unavail slots:
    //var unavail = Appointment.specialIds.unavailable === apt.id();
    //var link = null;
    //if (!unavail)
    var link = '#!appointment/' + apt.startTime().toISOString() + '/' + apt.id();
    
    if (apt.id() === Appointment.specialIds.preparationTime) {
        // Special link case: it goes to scheduling preferences to allow quick edit
        // the preparation time slots
        link = '#!schedulingPreferences?mustReturn=1';
    }

    var classNames = null;
    if (Appointment.specialIds.free === apt.id()) {
        classNames = 'Tile--tag-gray-lighter ';
    }
    else if (apt.id() > 0 && apt.sourceBooking()) {
        if (apt.sourceBooking().confirmedDateID())
            classNames = 'Tile--tag-primary ' ;
        else
            // is a request:
            classNames = 'Tile--tag-warning ';
        
        classNames += 'ItemAddonTile--largerContent ';
    }
    else {
        // any block event, preparation time slots
        classNames = 'Tile--tag-danger ';
    }

    return new TimeSlotViewModel({
        startTime: apt.startTime,
        endTime: apt.endTime,
        subject: apt.summary,
        description: apt.description,
        link: link,
        actionIcon: (apt.sourceBooking() ? null : apt.sourceEvent() ? 'fa ion ion-ios-arrow-right' : !apt.id() ? 'fa ion ion-plus' : null),
        actionText: (
            apt.sourceBooking() && 
            apt.sourceBooking().bookingRequest() && 
            apt.sourceBooking().bookingRequest().pricingEstimate() ? 
            numeral(apt.sourceBooking().bookingRequest().pricingEstimate().totalPrice() || 0).format('$0.00') :
            null
        ),
        classNames: classNames
    });
};

},{"../models/Appointment":70,"../utils/getObservable":122,"numeral":false}],145:[function(require,module,exports){
/**
    UserJobProfileViewModel: loads data and keep state
    to display the listing of job titles from the 
    user job profile.
**/
'use strict';

var ko = require('knockout');

function UserJobProfileViewModel(app) {
    
    // Load and save job title info
    var jobTitlesIndex = {};
    function syncJobTitle(jobTitleID) {
        return app.model.jobTitles.getJobTitle(jobTitleID)
        .then(function(jobTitle) {
            jobTitlesIndex[jobTitleID] = jobTitle;

            // TODO: errors? not-found job title?
        });
    }
    // Creates a 'jobTitle' observable on the userJobTitle
    // model to have access to a cached jobTitle model.
    function attachJobTitle(userJobTitle) {
        userJobTitle.jobTitle = ko.computed(function(){
            return jobTitlesIndex[this.jobTitleID()];
        }, userJobTitle);
    }
    
    this.userJobProfile = ko.observableArray([]);
    // Updated using the live list, for background updates
    app.model.userJobProfile.list.subscribe(function(list) {
        // We need the job titles info before end
        Promise.all(list.map(function(userJobTitle) {
            return syncJobTitle(userJobTitle.jobTitleID());
        }))
        .then(function() {
            // Create jobTitle property before update
            // observable with the profile
            list.forEach(attachJobTitle);

            this.userJobProfile(list);

            this.isLoading(false);
            this.isSyncing(false);
            this.thereIsError(false);
        }.bind(this))
        .catch(showLoadingError);
    }, this);

    this.isFirstTime = ko.observable(true);
    this.isLoading = ko.observable(false);
    this.isSyncing = ko.observable(false);
    this.thereIsError = ko.observable(false);
    this.baseUrl = ko.observable('/jobtitles');
    
    this.selectJobTitle = function(jobTitle) {
        // Gollow the next link:
        app.shell.go(this.baseUrl() + '/' + jobTitle.jobTitleID());
        // This function can be replaced by custom handling.
        // Stop events
        return false;
    }.bind(this);
    
    var showLoadingError = function showLoadingError(err) {
        app.modals.showError({
            title: 'An error happening when loading your job profile.',
            error: err && err.error || err
        });
        
        this.isLoading(false);
        this.isSyncing(false);
        this.thereIsError(true);
    }.bind(this);

    // Loading and sync of data
    this.sync = function sync() {
        var firstTime = this.isFirstTime();
        this.isFirstTime(false);

        if (firstTime) {
            this.isLoading(true);
        }
        else {
            this.isSyncing(true);
        }

        // Keep data updated:
        app.model.userJobProfile.syncList()
        .catch(showLoadingError);

    }.bind(this);
}

module.exports = UserJobProfileViewModel;

},{"knockout":false}]},{},[39])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYWNjb3VudC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYWRkSm9iVGl0bGVzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9hZGRyZXNzRWRpdG9yLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9hcHBvaW50bWVudC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYm9va01lQnV0dG9uLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jYWxlbmRhci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvY2FsZW5kYXJTeW5jaW5nLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jbGllbnRFZGl0b3IuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2NsaWVudHMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2Ntcy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvY29udGFjdEZvcm0uanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2NvbnRhY3RJbmZvLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jb252ZXJzYXRpb24uanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2RhdGV0aW1lUGlja2VyLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9mYXFzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9mZWVkYmFjay5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvZmVlZGJhY2tGb3JtLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9mcmVlbGFuY2VyUHJpY2luZy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvZnJlZWxhbmNlclByaWNpbmdFZGl0b3IuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2hvbWUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2luYm94LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9pbmRleC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvam9idGl0bGVzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9sZWFybk1vcmUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2xvZ2luLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9sb2dvdXQuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL293bmVySW5mby5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvcHJpdmFjeVNldHRpbmdzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zY2hlZHVsaW5nLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zY2hlZHVsaW5nUHJlZmVyZW5jZXMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3NlcnZpY2VBZGRyZXNzZXMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3NpZ251cC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvdGV4dEVkaXRvci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvd2Vla2x5U2NoZWR1bGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3dlbGNvbWUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHAtY29tcG9uZW50cy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcC1uYXZiYXIuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHAuYWN0aXZpdGllcy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcC5tb2RhbHMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHAuc2hlbGwuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC1hY2NvdW50LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuYm9va2luZ3MuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5jYWxlbmRhci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuY2FsZW5kYXJTeW5jaW5nLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuY3VzdG9tZXJzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuZmVlZGJhY2suanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLmhvbWVBZGRyZXNzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuam9iVGl0bGVzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5tYXJrZXRwbGFjZVByb2ZpbGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5tZXNzYWdpbmcuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5vbmJvYXJkaW5nLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwucG9zdGFsQ29kZXMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5wcmljaW5nVHlwZXMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5wcml2YWN5U2V0dGluZ3MuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5zY2hlZHVsaW5nUHJlZmVyZW5jZXMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwudXNlckpvYlByb2ZpbGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC51c2VyUHJvZmlsZS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL2NvbXBvbmVudHMvQWN0aXZpdHkuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9jb21wb25lbnRzL0RhdGVQaWNrZXIuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9jb21wb25lbnRzL1NtYXJ0TmF2QmFyLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbG9jYWxlcy9lbi1VUy1MQy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGFscy90aW1lUGlja2VyLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0FkZHJlc3MuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvQXBwb2ludG1lbnQuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvQm9va2luZy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Cb29raW5nUmVxdWVzdC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Cb29raW5nU3VtbWFyeS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9DYWxlbmRhckV2ZW50LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0NhbGVuZGFyU3luY2luZy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9DdXN0b21lci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9EYXRlQXZhaWxhYmlsaXR5LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0ZyZWVsYW5jZXJQcmljaW5nLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0dldE1vcmUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvSm9iVGl0bGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvSm9iVGl0bGVQcmljaW5nVHlwZS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9MaXN0Vmlld0l0ZW0uanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTWFpbEZvbGRlci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9NYXJrZXRwbGFjZVByb2ZpbGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTWVzc2FnZS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9NZXNzYWdlVmlldy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Nb2RlbC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9QZXJmb3JtYW5jZVN1bW1hcnkuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvUHJpY2luZ0VzdGltYXRlLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1ByaWNpbmdFc3RpbWF0ZURldGFpbC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9QcmljaW5nVHlwZS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Qcml2YWN5U2V0dGluZ3MuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvU2NoZWR1bGluZ1ByZWZlcmVuY2VzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1NpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9UaHJlYWQuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVXBjb21pbmdCb29raW5nc1N1bW1hcnkuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVXNlci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL21vZGVscy9Vc2VySm9iVGl0bGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVm9jRWxlbWVudEVudW0uanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy9tb2RlbHMvV2Vla0RheVNjaGVkdWxlLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvQ2FjaGVDb250cm9sLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvRGF0ZUNhY2hlLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvRnVuY3Rpb24ucHJvdG90eXBlLl9kZWxheWVkLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvRnVuY3Rpb24ucHJvdG90eXBlLl9pbmhlcml0cy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL0Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lLXBvbHlmaWxsLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvR3JvdXBMaXN0UmVtb3RlTW9kZWwuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9JbmRleGVkR3JvdXBMaXN0Q2FjaGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9JbmRleGVkTGlzdENhY2hlLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvTGlzdFJlbW90ZU1vZGVsLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvTW9kZWxWZXJzaW9uLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvUmVtb3RlTW9kZWwuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9SZXN0LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvVGltZS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2FjY2Vzc0NvbnRyb2wuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9hdmFpbGFiaWxpdHlDYWxjdWxhdGlvbi5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2Jvb3Rrbm9ja0JpbmRpbmdIZWxwZXJzLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvYm9vdHN0cmFwU3dpdGNoQmluZGluZy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2RhdGVwaWNrZXJBdmFpbGFiaWxpdHkuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9lc2NhcGVSZWdFeHAuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9lc2NhcGVTZWxlY3Rvci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2dldERhdGVXaXRob3V0VGltZS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2dldE9ic2VydmFibGUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9nZXRVcmxRdWVyeS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL2pxdWVyeS5tdWx0aWxpbmUuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9qc1Byb3BlcnRpZXNUb29scy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3JlbW92ZUFjY2VudC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3Njcm9sbFRvRWxlbWVudC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3NoZWxsL0RvbUl0ZW1zTWFuYWdlci5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3NoZWxsL1NoZWxsLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvYWJzb2x1dGl6ZVVybC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3NoZWxsL2RlcGVuZGVuY2llcy5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3NoZWxsL2hhc2hiYW5nSGlzdG9yeS5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3NoZWxsL2luZGV4LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvbG9hZGVyLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvcGFyc2VVcmwuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy91dGlscy9zaGVsbC9zYW5pdGl6ZVVybC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3V0aWxzL3RleHRTZWFyY2guanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0FwcG9pbnRtZW50Q2FyZC5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwb2ludG1lbnRWaWV3LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9Gb3JtQ3JlZGVudGlhbHMuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL05hdkFjdGlvbi5qcyIsIkM6L1Byb3hlY3Rvcy9Mb2Nvbm9taWNzL3N0eWxlZ3VpZGUvcHJvdG90eXBlcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvTmF2QmFyLmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9PbmJvYXJkaW5nUHJvZ3Jlc3MuanMiLCJDOi9Qcm94ZWN0b3MvTG9jb25vbWljcy9zdHlsZWd1aWRlL3Byb3RvdHlwZXMvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL1RpbWVTbG90LmpzIiwiQzovUHJveGVjdG9zL0xvY29ub21pY3Mvc3R5bGVndWlkZS9wcm90b3R5cGVzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9Vc2VySm9iUHJvZmlsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICAgIEFjY291bnQgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBY2NvdW50QWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICBcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignQWNjb3VudCcpO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuIiwiLyoqXHJcbiAgICBBZGRKb2JUaXRsZXMgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxucmVxdWlyZSgnanF1ZXJ5LXVpJyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQWRkSm9iVGl0bGVzQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJyk7XHJcbiAgICBcclxuICAgIC8vIFNldHVwIGF1dG9jb21wbGV0ZVxyXG4gICAgdmFyIGFjID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2FkZEpvYlRpdGxlcy1zZWFyY2gnKTtcclxuICAgIHZhciB2dyA9IHRoaXMudmlld01vZGVsO1xyXG4gICAgLy8gQXV0b2NvbXBsZXRlIHBvc2l0aW9ucyBhbmQgYWRkIHRvIHRoZSBsaXN0XHJcbiAgICBhYy5hdXRvY29tcGxldGUoe1xyXG4gICAgICAgIHNvdXJjZTogZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdncuc2VhcmNoQnkocmVxdWVzdC50ZXJtKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhdXRvRm9jdXM6IGZhbHNlLFxyXG4gICAgICAgIG1pbkxlbmd0aDogMCxcclxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcclxuICAgICAgICAgICAgLy8gTm8gdmFsdWUsIG5vIGFjdGlvbiA6KFxyXG4gICAgICAgICAgICBpZiAoIXVpIHx8ICF1aS5pdGVtIHx8ICF1aS5pdGVtLnZhbHVlKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2dy5hZGRJdGVtKHVpLml0ZW0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcclxuICAgICAgICAgICAgaWYgKCF1aSB8fCAhdWkuaXRlbSB8fCAhdWkuaXRlbS5wb3NpdGlvblNpbmd1bGFyKTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0aGUgbGFiZWwgaW4gdGV4dGJveCwgbm90IHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAkKHRoaXMpLnZhbCh1aS5pdGVtLnBvc2l0aW9uU2luZ3VsYXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUudXBkYXRlTmF2QmFyU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVOYXZCYXJTdGF0ZSgpIHtcclxuXHJcbiAgICB2YXIgcmVmZXJyZXIgPSB0aGlzLmFwcC5zaGVsbC5yZWZlcnJlclJvdXRlO1xyXG4gICAgcmVmZXJyZXIgPSByZWZlcnJlciAmJiByZWZlcnJlci51cmwgfHwgJy9zY2hlZHVsaW5nJztcclxuICAgIHZhciBsaW5rID0gdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rIHx8IHJlZmVycmVyO1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuYXBwLm1vZGVsLm9uYm9hcmRpbmcudXBkYXRlTmF2QmFyKHRoaXMubmF2QmFyKSkge1xyXG4gICAgICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgbGluayk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcblxyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgLy8gUmVzZXRcclxuICAgIHRoaXMudmlld01vZGVsLnNlYXJjaFRleHQoJycpO1xyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVzLnJlbW92ZUFsbCgpO1xyXG4gICAgXHJcbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XHJcbn07XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcbiAgICBcclxuICAgIHRoaXMuaXNTZWFyY2hpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuaXNMb2NrZWQgPSB0aGlzLmlzU2F2aW5nO1xyXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICB0aGlzLmpvYlRpdGxlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICBcclxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5pblByb2dyZXNzKCkgP1xyXG4gICAgICAgICAgICAgICAgJ1NhdmUgYW5kIGNvbnRpbnVlJyA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnc2F2aW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICdTYXZlJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy51bnNhdmVkQ2hhbmdlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmpvYlRpdGxlcygpLmxlbmd0aDtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc2VhcmNoQnkgPSBmdW5jdGlvbiBzZWFyY2hCeSh0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5yZXN0LmdldCgnam9iLXRpdGxlcy9hdXRvY29tcGxldGUnLCB7IHNlYXJjaDogdGV4dCB9KVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHsgZXJyb3I6IGVyciB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goKSB7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hCeSh0aGlzLnNlYXJjaFRleHQoKSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuYWRkSXRlbSA9IGZ1bmN0aW9uIGFkZEl0ZW0oaXRlbSkge1xyXG4gICAgICAgIC8vIEFkZCB0byB0aGUgbGlzdCwgaWYgaXMgbm90IGFscmVhZHkgaW4gaXRcclxuICAgICAgICB2YXIgZm91bmRJbmRleCA9IHRoaXMuZmluZEl0ZW0oaXRlbSk7XHJcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuam9iVGl0bGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoVGV4dCgpO1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSXRlbSh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaFRleHQoJycpO1xyXG4gICAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgTG9vayBmb3IgYW4gaXRlbSBpbiB0aGUgY3VycmVudCBsaXN0LCByZXR1cm5pbmdcclxuICAgICAgICBpdHMgaW5kZXggaW4gdGhlIGxpc3Qgb3IgLTEgaWYgbm90aGluZy5cclxuICAgICoqL1xyXG4gICAgdGhpcy5maW5kSXRlbSA9IGZ1bmN0aW9uIGZpbmRJdGVtKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcclxuICAgICAgICB0aGlzLmpvYlRpdGxlcygpLnNvbWUoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGpvYlRpdGxlLnZhbHVlICE9PSAwICYmXHJcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlID09PSBqb2JUaXRsZS52YWx1ZSB8fFxyXG4gICAgICAgICAgICAgICAgaXRlbS5sYWJlbCA9PT0gam9iVGl0bGUubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kSW5kZXg7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShqb2JUaXRsZSkge1xyXG4gICAgICAgIHZhciByZW1vdmVJbmRleCA9IHRoaXMuZmluZEl0ZW0oam9iVGl0bGUpO1xyXG4gICAgICAgIGlmIChyZW1vdmVJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuam9iVGl0bGVzLnNwbGljZShyZW1vdmVJbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xyXG4gICAgICAgIHRoaXMuaXNTYXZpbmcodHJ1ZSk7XHJcblxyXG4gICAgICAgIFByb21pc2UuYWxsKHRoaXMuam9iVGl0bGVzKCkubWFwKGZ1bmN0aW9uKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwudXNlckpvYlByb2ZpbGUuY3JlYXRlVXNlckpvYlRpdGxlKHtcclxuICAgICAgICAgICAgICAgIGpvYlRpdGxlSUQ6IGpvYlRpdGxlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgam9iVGl0bGVOYW1lOiBqb2JUaXRsZS5sYWJlbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigvKnJlc3VsdHMqLykge1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaFRleHQoJycpO1xyXG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gUmVzZXQgbGlzdFxyXG4gICAgICAgICAgICB0aGlzLmpvYlRpdGxlcy5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChhcHAubW9kZWwub25ib2FyZGluZy5pblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgIGFwcC5tb2RlbC5vbmJvYXJkaW5nLmdvTmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXBwLnN1Y2Nlc3NTYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaFRleHQoJycpO1xyXG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdJbXBvc3NpYmxlIHRvIGFkZCBvbmUgb3IgbW9yZSBqb2IgdGl0bGVzJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgQWRkcmVzc0VkaXRvciBhY3Rpdml0eVxyXG4gICAgXHJcbiAgICBUT0RPOiBNb2RlbFZlcnNpb24gaXMgTk9UIGJlaW5nIHVzZWQsIHNvIG5vIGdldHRpbmcgdXBkYXRlcyBpZiBzZXJ2ZXIgdXBkYXRlc1xyXG4gICAgdGhlIGRhdGEgYWZ0ZXIgbG9hZCAoZGF0YSBsb2FkIGlzIHJlcXVlc3RlZCBidXQgZ2V0IGZpcnN0IGZyb20gY2FjaGUpLiBVc2VcclxuICAgIHZlcnNpb24gYW5kIGdldCBzeW5jJ2VkIGRhdGEgd2hlbiByZWFkeSwgYW5kIGFkZGl0aW9uYWxseSBub3RpZmljYXRpb24gdG9cclxuICAgIG92ZXJyaWRlIGNoYW5nZXMgaWYgc2VydmVyIGRhdGEgaXMgZGlmZmVyZW50IHRoYXQgYW55IGxvY2FsIGNoYW5nZS5cclxuXHJcbiAgICBUT0RPOiBUaGUgVVJMIHN0cnVjdHVyZSBhbmQgaG93IHBhcmFtcyBhcmUgcmVhZCBpcyByZWFkeSB0byBhbGxvd1xyXG4gICAgZWRpdGlvbiBvZiBkaWZmZXJlbnQga2luZCBvZiBhZGRyZXNzZXMsIGJ1dCBhY3R1YWxseSBvbmx5IHNlcnZpY2UgYWRkcmVzc2VzXHJcbiAgICBhcmUgZnVsbHkgc3VwcG9ydGVkLCBzaW5jZSAnaG9tZSBhZGRyZXNzJyBpcyBlZGl0ZWQgaW4gY29udGFjdEluZm8gYW5kXHJcbiAgICAnYmlsbGluZyBhZGRyZXNzZXMnIGFyZSBub3QgdXNlZCBjdXJyZW50bHksIGJ1dCB3aGVuIG5lZWRlZCwgdGhlIHN1cHBvcnQgZm9yIHRoaXNcclxuICAgIGxhc3Qgd2lsbCBuZWVkIHRvIGJlIGNvbXBsZXRlZC4gQWxsIHRoZSBBUEkgY2FsbHMgcmlnaHQgbm93IGFyZVxyXG4gICAgZm9yIG1vZGVsLnNlcnZpY2VBZGRkcmVzc2VzIGZvciBleGFtcGxlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgQWRkcmVzcyA9IHJlcXVpcmUoJy4uL21vZGVscy9BZGRyZXNzJyksXHJcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBZGRyZXNzRWRpdG9yQWN0aXZpdHkoKSB7XHJcblxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0xvY2F0aW9ucycpO1xyXG4gICAgXHJcbiAgICAvLyBSZW1vdGUgcG9zdGFsIGNvZGUgbG9vay11cFxyXG4gICAgLy8gTk9URTogY29waWVkIHRoZSBjb2RlIGluc2lkZSB0aGUgcG9zdGFsQ29kZSBjb21wdXRlZCBoYW5kbGVyIGluIGNvbnRhY3RJbmZvLmpzIHdpdGggc2xpZ2h0IGNoYW5nZXNcclxuICAgIHZhciBhcHAgPSB0aGlzLmFwcCxcclxuICAgICAgICB2aWV3TW9kZWwgPSB0aGlzLnZpZXdNb2RlbDtcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmFkZHJlc3MsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oYWRkcmVzcykge1xyXG4gICAgICAgICAgICBpZiAoYWRkcmVzcyAmJlxyXG4gICAgICAgICAgICAgICAhYWRkcmVzcy5wb3N0YWxDb2RlLl9oYXNMb29rdXApIHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3MucG9zdGFsQ29kZS5faGFzTG9va3VwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gT24gY2hhbmdlIHRvIGEgdmFsaWQgY29kZSwgZG8gcmVtb3RlIGxvb2stdXBcclxuICAgICAgICAgICAgICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0YWxDb2RlID0gdGhpcy5wb3N0YWxDb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3RhbENvZGUgJiYgIS9eXFxzKiQvLnRlc3QocG9zdGFsQ29kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLm1vZGVsLnBvc3RhbENvZGVzLmdldEl0ZW0ocG9zdGFsQ29kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmNpdHkoaW5mby5jaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VDb2RlKGluZm8uc3RhdGVQcm92aW5jZUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoaW5mby5zdGF0ZVByb3ZpbmNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmVycm9yTWVzc2FnZXMucG9zdGFsQ29kZSgnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MuY2l0eSgnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VDb2RlKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwZWN0ZWQgZXJyb3JzLCBhIHNpbmdsZSBtZXNzYWdlLCBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBvYnNlcnZhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gdHlwZW9mKGVycikgPT09ICdzdHJpbmcnID8gZXJyIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2cgfHwgZXJyICYmIGVyci5yZXNwb25zZUpTT04gJiYgZXJyLnJlc3BvbnNlSlNPTi5lcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwuZXJyb3JNZXNzYWdlcy5wb3N0YWxDb2RlKG1zZyB8fCBlcnIucmVzcG9uc2VKU09OLmVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2cgdG8gY29uc29sZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLCBvbiByZWd1bGFyIHVzZSBhbiBlcnJvciBvbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3N0YWwgY29kZSBpcyBub3QgY3JpdGljYWwgYW5kIGNhbiBiZSB0cmFuc3BhcmVudDsgaWYgdGhlcmUgYXJlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpdml0eSBvciBhdXRoZW50aWZpY2F0aW9uIGVycm9ycyB3aWxsIHRocm93IG9uIHNhdmluZyB0aGUgYWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZlciBlcnJvciB2YWxpZGF0aW5nIFppcCBDb2RlJywgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgYWRkcmVzcylcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGV4Y2Vzc2l2ZSByZXF1ZXN0cyBieSBzZXR0aW5nIGEgdGltZW91dCBzaW5jZSB0aGUgbGF0ZXN0IGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyB0aW1lb3V0OiAyMDAsIG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBvZiB0aGUgc2F2ZSBvcGVyYXRpb25cclxuICAgIHRoaXMudmlld01vZGVsLm9uU2F2ZSA9IGZ1bmN0aW9uKGFkZHJlc3NJRCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLnJldHVybk5ld0FzU2VsZWN0ZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gR28gdG8gcHJldmlvdXMgYWN0aXZpdHkgdGhhdCByZXF1aXJlZFxyXG4gICAgICAgICAgICAvLyB0byBzZWxlY3QgYW4gYWRkcmVzc1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REYXRhLmFkZHJlc3NJRCA9IGFkZHJlc3NJRDtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmVndWxhciBzYXZlXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN1Y2Nlc3NTYXZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnVwZGF0ZU5hdkJhclN0YXRlID0gZnVuY3Rpb24gdXBkYXRlTmF2QmFyU3RhdGUoKSB7XHJcblxyXG4gICAgdmFyIGxpbmsgPSB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmsgfHwgJy9zZXJ2aWNlQWRkcmVzc2VzLycgKyB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKCk7XHJcbiAgICBcclxuICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgbGluayk7XHJcbn07XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjEwICAgIFxyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgLy8gUmVzZXRcclxuICAgIHRoaXMudmlld01vZGVsLndhc1JlbW92ZWQoZmFsc2UpO1xyXG4gICAgXHJcbiAgICAvLyBQYXJhbXMgICAgXHJcbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHMgfHwgW107XHJcblxyXG4gICAgdmFyIGtpbmQgPSBwYXJhbXNbMF0gfHwgJycsXHJcbiAgICAgICAgaXNTZXJ2aWNlID0ga2luZCA9PT0gQWRkcmVzcy5raW5kLnNlcnZpY2UsXHJcbiAgICAgICAgam9iVGl0bGVJRCA9IGlzU2VydmljZSA/IHBhcmFtc1sxXSB8MCA6IDAsXHJcbiAgICAgICAgYWRkcmVzc0lEID0gaXNTZXJ2aWNlID8gcGFyYW1zWzJdIHwwIDogcGFyYW1zWzFdIHwwLFxyXG4gICAgICAgIC8vIE9ubHkgdXNlZCBvbiBzZXJ2aWNlIGFkZHJlc3MgY3JlYXRpb24sIGluc3RlYWQgYW4gSUQgd2UgZ2V0XHJcbiAgICAgICAgLy8gYSBzdHJpbmcgZm9yICdzZXJ2aWNlQXJlYScgb3IgJ3NlcnZpY2VMb2NhdGlvbicpXHJcbiAgICAgICAgc2VydmljZVR5cGUgPSBwYXJhbXNbMl0gfHwgJyc7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoam9iVGl0bGVJRCk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzSUQoYWRkcmVzc0lEKTtcclxuICAgIFxyXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xyXG5cclxuICAgIGlmIChhZGRyZXNzSUQpIHtcclxuICAgICAgICAvLyBHZXQgdGhlIGFkZHJlc3NcclxuICAgICAgICB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldEl0ZW1WZXJzaW9uKGpvYlRpdGxlSUQsIGFkZHJlc3NJRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAoYWRkcmVzc1ZlcnNpb24pIHtcclxuICAgICAgICAgICAgaWYgKGFkZHJlc3NWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzVmVyc2lvbihhZGRyZXNzVmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXIoJ0VkaXQgTG9jYXRpb24nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NWZXJzaW9uKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdVbmtub3cgbG9jYXRpb24gb3Igd2FzIGRlbGV0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE5ldyBhZGRyZXNzXHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc1ZlcnNpb24odGhpcy5hcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5uZXdJdGVtVmVyc2lvbih7XHJcbiAgICAgICAgICAgIGpvYlRpdGxlSUQ6IGpvYlRpdGxlSURcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoc2VydmljZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnc2VydmljZUFyZWEnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUFyZWEodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzKCkuaXNTZXJ2aWNlTG9jYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdBZGQgYSBzZXJ2aWNlIGFyZWEnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzZXJ2aWNlTG9jYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUFyZWEoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUxvY2F0aW9uKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdBZGQgYSBzZXJ2aWNlIGxvY2F0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3MoKS5pc1NlcnZpY2VBcmVhKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUxvY2F0aW9uKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdBZGQgYSBsb2NhdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHRoaXMuaGVhZGVyID0ga28ub2JzZXJ2YWJsZSgnRWRpdCBMb2NhdGlvbicpO1xyXG4gICAgXHJcbiAgICAvLyBMaXN0IG9mIHBvc3NpYmxlIGVycm9yIG1lc3NhZ2VzIHJlZ2lzdGVyZWRcclxuICAgIC8vIGJ5IG5hbWVcclxuICAgIHRoaXMuZXJyb3JNZXNzYWdlcyA9IHtcclxuICAgICAgICBwb3N0YWxDb2RlOiBrby5vYnNlcnZhYmxlKCcnKVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIHRoaXMuYWRkcmVzc0lEID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIFxyXG4gICAgdGhpcy5hZGRyZXNzVmVyc2lvbiA9IGtvLm9ic2VydmFibGUobnVsbCk7XHJcbiAgICB0aGlzLmFkZHJlc3MgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmFkZHJlc3NWZXJzaW9uKCk7XHJcbiAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYudmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIHRoaXMuaXNMb2FkaW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNMb2FkaW5nO1xyXG4gICAgdGhpcy5pc1NhdmluZyA9IGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnN0YXRlLmlzU2F2aW5nO1xyXG4gICAgdGhpcy5pc0RlbGV0aW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNEZWxldGluZztcclxuXHJcbiAgICB0aGlzLndhc1JlbW92ZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRGVsZXRpbmcoKSB8fCBhcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zdGF0ZS5pc0xvY2tlZCgpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNOZXcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFkZCA9IHRoaXMuYWRkcmVzcygpO1xyXG4gICAgICAgIHJldHVybiAhYWRkIHx8ICFhZGQudXBkYXRlZERhdGUoKTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuYWRkcmVzc1ZlcnNpb24oKTtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXHJcbiAgICAgICAgICAgICAgICAnTG9hZGluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgICAgICdTYXZpbmcgY2hhbmdlcycgOiBcclxuICAgICAgICAgICAgICAgICAgICB2ICYmIHYuYXJlRGlmZmVyZW50KCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2F2ZSBjaGFuZ2VzJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlZCdcclxuICAgICAgICApO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy51bnNhdmVkQ2hhbmdlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuYWRkcmVzc1ZlcnNpb24oKTtcclxuICAgICAgICByZXR1cm4gdiAmJiB2LmFyZURpZmZlcmVudCgpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuZGVsZXRlVGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmlzRGVsZXRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ0RlbGV0aW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgJ0RlbGV0ZSdcclxuICAgICAgICApO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnNldEl0ZW0odGhpcy5hZGRyZXNzKCkubW9kZWwudG9QbGFpbk9iamVjdCgpKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCBzZXJ2ZXIgZGF0YS5cclxuICAgICAgICAgICAgdGhpcy5hZGRyZXNzKCkubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgLy8gUHVzaCB2ZXJzaW9uIHNvIGl0IGFwcGVhcnMgYXMgc2F2ZWRcclxuICAgICAgICAgICAgdGhpcy5hZGRyZXNzVmVyc2lvbigpLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgc2F2ZSwgZnVuY3Rpb24gcHJvdmlkZWQgYnkgdGhlIGFjdGl2aXR5IG9uIHNldC11cFxyXG4gICAgICAgICAgICB0aGlzLm9uU2F2ZShzZXJ2ZXJEYXRhLmFkZHJlc3NJRCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgc2F2aW5nLicsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5jb25maXJtUmVtb3ZhbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwcC5tb2RhbHMuY29uZmlybSh7XHJcbiAgICAgICAgICAgIHRpdGxlOiAnRGVsZXRlIGxvY2F0aW9uJyxcclxuICAgICAgICAgICAgbWVzc2FnZTogJ0FyZSB5b3Ugc3VyZT8gVGhlIG9wZXJhdGlvbiBjYW5ub3QgYmUgdW5kb25lLicsXHJcbiAgICAgICAgICAgIHllczogJ0RlbGV0ZScsXHJcbiAgICAgICAgICAgIG5vOiAnS2VlcCdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuZGVsSXRlbSh0aGlzLmpvYlRpdGxlSUQoKSwgdGhpcy5hZGRyZXNzSUQoKSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy53YXNSZW1vdmVkKHRydWUpO1xyXG4gICAgICAgICAgICAvLyBHbyBvdXQgdGhlIGRlbGV0ZWQgbG9jYXRpb25cclxuICAgICAgICAgICAgYXBwLnNoZWxsLmdvQmFjaygpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGRlbGV0aW5nLicsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBUeXBlZCB2YWx1ZSBiaW5kaW5nIHJhdGhlciB0aGFuIGh0bWwgYmluZGluZyBhbGxvdyB0byBhdm9pZFxyXG4gICAgICAgIHByb2JsZW1zIGJlY2F1c2UgdGhlIGRhdGEgaW4gaHRtbCBhcmUgc3RyaW5nIHZhbHVlcyB3aGlsZVxyXG4gICAgICAgIHRoZSBhY3R1YWwgZGF0YSBmcm9tIHRoZSBtb2RlbCBpcyBhIG51bWJlci5cclxuICAgICAgICBDYXVzZSBwcm9ibGVtcyBvbiBzb21lIGVkZ2UgY2FzZXMgbWF0Y2hpbmcgdmFsdWVzIGFuZCB3aXRoXHJcbiAgICAgICAgZGV0ZWN0aW9uIG9mIGNoYW5nZXMgaW4gdGhlIGRhdGEgKGJlY2F1c2UgdGhlIGJpbmRpbmcgY29taW5nIGZyb20gdGhlXHJcbiAgICAgICAgY29udHJvbCBhc3NpZ25pbmcgYSBzdHJpbmcgdG8gdGhlIHZhbHVlKS5cclxuICAgICoqL1xyXG4gICAgdGhpcy5zZXJ2aWNlUmFkaXVzT3B0aW9ucyA9IGtvLm9ic2VydmFibGVBcnJheShbXHJcbiAgICAgICAgeyB2YWx1ZTogMC41LCBsYWJlbDogJzAuNSBtaWxlcycgfSxcclxuICAgICAgICB7IHZhbHVlOiAxLjAsIGxhYmVsOiAnMSBtaWxlJyB9LFxyXG4gICAgICAgIHsgdmFsdWU6IDIuMCwgbGFiZWw6ICcyIG1pbGVzJyB9LFxyXG4gICAgICAgIHsgdmFsdWU6IDMuMCwgbGFiZWw6ICczIG1pbGVzJyB9LFxyXG4gICAgICAgIHsgdmFsdWU6IDQuMCwgbGFiZWw6ICc0IG1pbGVzJyB9LFxyXG4gICAgICAgIHsgdmFsdWU6IDUuMCwgbGFiZWw6ICc1IG1pbGVzJyB9LFxyXG4gICAgICAgIHsgdmFsdWU6IDEwLCBsYWJlbDogJzEwIG1pbGVzJyB9LFxyXG4gICAgICAgIHsgdmFsdWU6IDI1LCBsYWJlbDogJzI1IG1pbGVzJyB9LFxyXG4gICAgICAgIHsgdmFsdWU6IDUwLCBsYWJlbDogJzUwIG1pbGVzJyB9LFxyXG4gICAgXSk7XHJcbn1cclxuIiwiLyoqIENhbGVuZGFyIGFjdGl2aXR5ICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXHJcbiAgICBBcHBvaW50bWVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9BcHBvaW50bWVudCcpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgZ2V0RGF0ZVdpdGhvdXRUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0RGF0ZVdpdGhvdXRUaW1lJyk7XHJcblxyXG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL0RhdGVQaWNrZXInKTtcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBcHBvaW50bWVudEFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5GcmVlbGFuY2VyOyAgICBcclxuICAgIHRoaXMubWVudUl0ZW0gPSAnY2FsZW5kYXInO1xyXG4gICAgXHJcbiAgICB0aGlzLiRhcHBvaW50bWVudFZpZXcgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2FsZW5kYXJBcHBvaW50bWVudFZpZXcnKTtcclxuICAgIHRoaXMuJGNob29zZU5ldyA9ICQoJyNjYWxlbmRhckNob29zZU5ldycpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgZGVmYXVsdCBsZWZ0QWN0aW9uL2JhY2tBY3Rpb24gc2V0dGluZ3NcclxuICAgIC8vIGxhdGVyIHVzZWQgdG8gaW5zdGFudGlhdGUgYSBuZXcgTmF2QWN0aW9uIHRoYXQgd2lsbFxyXG4gICAgLy8gZHluYW1pY2FsbHkgY2hhbmdlIGRlcGVuZGluZyBvbiB2aWV3TW9kZWwgZGF0YS5cclxuICAgIHZhciBiYWNrQWN0aW9uU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGluazogJ2NhbGVuZGFyLycsIC8vIFByZXNlcnZlIGxhc3Qgc2xhc2gsIGZvciBsYXRlciB1c2VcclxuICAgICAgICBpY29uOiBBY3Rpdml0eS5OYXZBY3Rpb24uZ29CYWNrLmljb24oKSxcclxuICAgICAgICBpc1RpdGxlOiB0cnVlLFxyXG4gICAgICAgIHRleHQ6ICdDYWxlbmRhcidcclxuICAgIH07XHJcbiAgICB0aGlzLm5hdkJhciA9IG5ldyBBY3Rpdml0eS5OYXZCYXIoe1xyXG4gICAgICAgIHRpdGxlOiAnJyxcclxuICAgICAgICBsZWZ0QWN0aW9uOiBuZXcgQWN0aXZpdHkuTmF2QWN0aW9uKGJhY2tBY3Rpb25TZXR0aW5ncyksXHJcbiAgICAgICAgcmlnaHRBY3Rpb246IEFjdGl2aXR5Lk5hdkFjdGlvbi5nb0hlbHBJbmRleFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTmF2QmFyIG11c3QgdXBkYXRlIGRlcGVuZGluZyBvbiBlZGl0TW9kZSBzdGF0ZSAodG8gYWxsb3cgY2FuY2VsIGFuZCBnb0JhY2spXHJcbiAgICAvLyBhbmQgYXBwb2ludG1lbnQgZGF0ZSAob24gcmVhZC1vbmx5LCB0byBnbyBiYWNrIHRvIGNhbGVuZGFyIG9uIGN1cnJlbnQgZGF0ZSlcclxuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBlZGl0TW9kZSA9IHRoaXMudmlld01vZGVsLmVkaXRNb2RlKCksXHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50RGF0ZSgpO1xyXG5cclxuICAgICAgICBpZiAoZWRpdE1vZGUpIHtcclxuICAgICAgICAgICAgLy8gSXMgY2FuY2VsIGFjdGlvblxyXG5cclxuICAgICAgICAgICAgdmFyIGNhbmNlbExpbmsgPSB0aGlzLnZpZXdNb2RlbC5hcHBvaW50bWVudENhcmRWaWV3KCk7XHJcbiAgICAgICAgICAgIGNhbmNlbExpbmsgPSBjYW5jZWxMaW5rICYmIGNhbmNlbExpbmsucHJvZ3Jlc3MgJiYgY2FuY2VsTGluay5wcm9ncmVzcy5jYW5jZWxMaW5rO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0VG9DYW5jZWxBY3Rpb24odGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLCBjYW5jZWxMaW5rIHx8IHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJcyBnbyB0byBjYWxlbmRhci9kYXRlIGFjdGlvblxyXG4gICAgICAgICAgICB2YXIgZGVmTGluayA9IGJhY2tBY3Rpb25TZXR0aW5ncy5saW5rLFxyXG4gICAgICAgICAgICAgICAgZGVmQmFja1RleHQgPSBiYWNrQWN0aW9uU2V0dGluZ3MudGV4dDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBsaW5rID0gZGF0ZSA/IGRlZkxpbmsgKyBkYXRlLnRvSVNPU3RyaW5nKCkgOiBkZWZMaW5rO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IGRhdGUgPyBtb21lbnQoZGF0ZSkuZm9ybWF0KCdkZGRkIFsoXU0vRFspXScpIDogZGVmQmFja1RleHQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkubW9kZWwudXBkYXRlV2l0aCgkLmV4dGVuZCh7fSwgYmFja0FjdGlvblNldHRpbmdzLCB7XHJcbiAgICAgICAgICAgICAgICBsaW5rOiBsaW5rLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG51bGxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICBcclxuICAgIC8vIE9uIGNoYW5naW5nIHRoZSBjdXJyZW50IGFwcG9pbnRtZW50OlxyXG4gICAgLy8gLSBVcGRhdGUgVVJMIHRvIG1hdGNoIHRoZSBhcHBvaW50bWVudCBjdXJyZW50bHkgc2hvd2VkXHJcbiAgICAvLyAtIEF0dGFjaCBoYW5kbGVycyB0byBJRCBhbmQgU3RhcnRUaW1lIHNvIHdlIGxvYWQgZGF0YSBmb3IgdGhlIG5ld1xyXG4gICAgLy8gICBkYXRlIHdoZW4gaXQgY2hhbmdlcyAoSUQgY2hhbmdlcyBvbiBjcmVhdGUgYSBib29raW5nLCBTdGFydFRpbWUgb25cclxuICAgIC8vICAgZWRpdGlvbikuXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5jdXJyZW50QXBwb2ludG1lbnQsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGFwdCkge1xyXG4gICAgICAgICAgICBpZiAoIWFwdClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmICgoYXB0LmlkKCkgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubmV3Qm9va2luZyB8fFxyXG4gICAgICAgICAgICAgICAgYXB0LmlkKCkgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubmV3RXZlbnQpICYmXHJcbiAgICAgICAgICAgICAgICAhYXB0Ll9faWREYXRlSGFuZGxlcnNBdHRhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgYXB0Ll9faWREYXRlSGFuZGxlcnNBdHRhY2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldklEID0gYXB0LmlkKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBXaXRoIGV4cGxpY2l0IHN1YnNjcmliZSBhbmQgbm90IGEgY29tcHV0ZWQgYmVjYXVzZSB3ZVxyXG4gICAgICAgICAgICAgICAgLy8gbXVzdCBhdm9pZCB0aGUgZmlyc3QgdGltZSBleGVjdXRpb24gKGNyZWF0ZXMgYW4gaW5maW5pdGUgbG9vcClcclxuICAgICAgICAgICAgICAgIGFwdC5pZC5zdWJzY3JpYmUoZnVuY3Rpb24gcmVsb2NhdGVMaXN0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGFwdC5pZCgpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZJRCA+IDAgfHwgaWQgPD0gMCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZJRCA9IGlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnNldEN1cnJlbnQobnVsbCwgaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnVwZGF0ZVVybCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0uYmluZCh0aGlzKS5fZGVsYXllZCgxMClcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IGRlbGF5ZWQgUkVRVUlSRUQgdG8gYXZvaWQgdHJpcGxlIGxvYWRpbmcgKGFjdGl2aXR5LnNob3cpIG9uIGZpcnN0IGxvYWQgdHJpZ2dlcmVkIGJ5IGEgY2xpY2sgZXZlbnQuXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eToxMCAqL1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgLy8gUHJlcGFyZSBjYW5jZWxMaW5rLCBiZWZvcmUgYW55IGF0dGVtcHQgb2YgaW50ZXJuYWwgVVJMIHJld3JpdGluZ1xyXG4gICAgaWYgKCF0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmspIHtcclxuICAgICAgICB2YXIgcmVmZXJyZXIgPSB0aGlzLmFwcC5zaGVsbC5yZWZlcnJlclJvdXRlO1xyXG4gICAgICAgIHJlZmVycmVyID0gcmVmZXJyZXIgJiYgcmVmZXJyZXIudXJsO1xyXG4gICAgICAgIC8vIFNldCBhIGRlZmF1bHQgYW5kIGF2b2lkIGxpbmtzIHRvIHRoaXMgc2FtZSBwYWdlLCBwcmV2ZW50aW5nIGluZmluaXRlIGxvb3BzXHJcbiAgICAgICAgaWYgKHJlZmVycmVyICYmIC9cXC8/YXBwb2ludG1lbnRcXC8vaS50ZXN0KHJlZmVycmVyKSlcclxuICAgICAgICAgICAgcmVmZXJyZXIgPSAnL2NhbGVuZGFyJztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmsgPSByZWZlcnJlcjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHMxID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHNbMF0sXHJcbiAgICAgICAgczIgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50c1sxXSxcclxuICAgICAgICBzMyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yb3V0ZSAmJiBvcHRpb25zLnJvdXRlLnNlZ21lbnRzWzJdLFxyXG4gICAgICAgIGRhdGUsXHJcbiAgICAgICAgZGF0ZXRpbWUsXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgdHlwZTtcclxuXHJcbiAgICB2YXIgaXNOdW1iZXIgPSAvXlxcLT9cXGQrJC87XHJcbiAgICBpZiAoaXNOdW1iZXIudGVzdChzMSkpIHtcclxuICAgICAgICAvLyBmaXJzdCBwYXJhbWV0ZXIgaXMgYW4gSURcclxuICAgICAgICBpZCA9IHMxIHwwO1xyXG4gICAgICAgIHR5cGUgPSBzMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRhdGUgPSBnZXREYXRlV2l0aG91dFRpbWUoczEpO1xyXG4gICAgICAgIGRhdGV0aW1lID0gczEgJiYgbmV3IERhdGUoczEpIHx8IGRhdGU7XHJcbiAgICAgICAgaWQgPSBzMiB8MDtcclxuICAgICAgICB0eXBlID0gczM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBzZXR1cENhcmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBUaGUgY2FyZCBjb21wb25lbnQgbmVlZHMgdG8gYmUgdXBkYXRlZCBvbiBsb2FkXHJcbiAgICAgICAgLy8gd2l0aCBhbnkgb3B0aW9uIHBhc3NlZCB0byB0aGUgYWN0aXZpdHkgc2luY2UgdGhlIGNvbXBvbmVudFxyXG4gICAgICAgIC8vIGlzIGFibGUgdG8gdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBhY3Rpdml0aWVzIGl0IGhhcyByZXF1ZXN0ZWRcclxuICAgICAgICAvLyAodG8gcmVxdWVzdCBpbmZvcm1hdGlvbiBlZGl0aW9uKVxyXG4gICAgICAgIHZhciBjYXJkQXBpID0gdGhpcy52aWV3TW9kZWwuYXBwb2ludG1lbnRDYXJkVmlldygpO1xyXG4gICAgICAgIGlmIChjYXJkQXBpKSB7XHJcbiAgICAgICAgICAgIC8vIFByZXNldCB0aGUgc3RhcnRUaW1lIHRvIHRoZSBvbmUgZ2l2ZW4gYnkgdGhlIHJlcXVlc3REYXRhIFVSTCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIC8vIHdoZW4gbm90IGluIGFuIGV4aXN0ZW50IGFwcG9pbnRtZW50LCBqdXN0IGJlY2F1c2U6XHJcbiAgICAgICAgICAgIC8vIC0gT24gYSBuZXcgYm9va2luZyB3ZSBjYW4gcHJlc2V0IHRoZSBkYXRlIGluIHRoZSAnc2VsZWN0IGRhdGUtdGltZScgc3RlcFxyXG4gICAgICAgICAgICAvLyAtIE9uIGEgbmV3IGV2ZW50IHdlIGNhbiBwcmVzZXQgdGhlIGRhdGUgYW5kIHRpbWUgaW4gdGhlIGNhcmRcclxuICAgICAgICAgICAgLy8gLSBPbiB0aGUgb3RoZXIgc3BlY2lhbCBjYXJkcywgaXRzIGFsbG93cyB0byBwYXNzIHRoZSBkYXRldGltZSB0byB0aGUgbGlua3NcclxuICAgICAgICAgICAgLy8gICBmb3IgY3JlYXRpb24gb2YgYSBuZXcgYm9va2luZy9ldmVudC5cclxuICAgICAgICAgICAgaWYgKHRoaXMudmlld01vZGVsLmFwcG9pbnRtZW50Q2FyZFZpZXcoKS5jdXJyZW50SUQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hcHBvaW50bWVudENhcmRWaWV3KCkuaXRlbSgpLnN0YXJ0VGltZShkYXRldGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNhcmRBcGkucGFzc0luKHRoaXMucmVxdWVzdERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgbWF5IGhhcHBlbiB0aGF0IHRoZSBiaW5kaW5nIGlzIG5vdCByZWFkeSwgbm8gY2FyZEFwaSBhdmFpbGFibGVcclxuICAgICAgICAgICAgLy8gYnV0IHdlIG5lZWQgaXQsIGF0dGVtcHQgYWdhaW4gaW4gc2hvcnQgc28gY2FyZCBpcyByZWFkeTpcclxuICAgICAgICAgICAgc2V0VGltZW91dChzZXR1cENhcmQsIDgwKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuc2V0Q3VycmVudChkYXRlLCBpZCwgdHlwZSlcclxuICAgIC50aGVuKHNldHVwQ2FyZCk7XHJcbn07XHJcblxyXG52YXIgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKTtcclxuXHJcbmZ1bmN0aW9uIGZpbmRBcHBvaW50bWVudEluTGlzdChsaXN0LCBpZCkge1xyXG4gICAgdmFyIGZvdW5kID0gbnVsbCxcclxuICAgICAgICBpbmRleCA9IC0xO1xyXG4gICAgbGlzdC5zb21lKGZ1bmN0aW9uKGFwdCwgaSkge1xyXG4gICAgICAgIGlmIChhcHQuaWQoKSA9PT0gaWQpIHtcclxuICAgICAgICAgICAgZm91bmQgPSBhcHQ7XHJcbiAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGl0ZW06IGZvdW5kLFxyXG4gICAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgfTtcclxufVxyXG5cclxudmFyIENhbGVuZGFyRXZlbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ2FsZW5kYXJFdmVudCcpLFxyXG4gICAgQm9va2luZyA9IHJlcXVpcmUoJy4uL21vZGVscy9Cb29raW5nJyk7XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcbiAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgIHRoaXMuY3VycmVudERhdGUgPSBrby5vYnNlcnZhYmxlKG5ldyBEYXRlKCkpO1xyXG4gICAgdGhpcy5jdXJyZW50SUQgPSBrby5vYnNlcnZhYmxlKDApO1xyXG4gICAgdGhpcy5jdXJyZW50SW5kZXggPSBrby5vYnNlcnZhYmxlKDApO1xyXG4gICAgdGhpcy5lZGl0TW9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIFxyXG4gICAgdGhpcy5kYXRlQXZhaWxhYmlsaXR5ID0ga28ub2JzZXJ2YWJsZSgpO1xyXG4gICAgdGhpcy5hcHBvaW50bWVudHMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRhdGVBdmFpbCA9IHRoaXMuZGF0ZUF2YWlsYWJpbGl0eSgpO1xyXG4gICAgICAgIHJldHVybiBkYXRlQXZhaWwgJiYgZGF0ZUF2YWlsLmFwcG9pbnRtZW50c0xpc3QoKSB8fCBbXTsgICAgICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBUbyBhY2Nlc3MgdGhlIGNvbXBvbmVudCBBUEkgd2UgdXNlIG5leHQgb2JzZXJ2YWJsZSxcclxuICAgIC8vIHVwZGF0ZWQgYnkgdGhlIGNvbXBvbmVudCB3aXRoIGl0cyB2aWV3XHJcbiAgICB0aGlzLmFwcG9pbnRtZW50Q2FyZFZpZXcgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG5cclxuICAgIHZhciBsb2FkaW5nQXBwb2ludG1lbnQgPSBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgIGlkOiBBcHBvaW50bWVudC5zcGVjaWFsSWRzLmxvYWRpbmcsXHJcbiAgICAgICAgc3VtbWFyeTogJ0xvYWRpbmcuLi4nXHJcbiAgICB9KTtcclxuICAgIHZhciBuZXdFbXB0eURhdGVBcHBvaW50bWVudCA9IGZ1bmN0aW9uIG5ld0VtcHR5RGF0ZUFwcG9pbnRtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy5lbXB0eURhdGUsXHJcbiAgICAgICAgICAgIHN1bW1hcnk6ICdZb3UgaGF2ZSBub3RoaW5nIHNjaGVkdWxlZCcsXHJcbiAgICAgICAgICAgIHN0YXJ0VGltZTogdGhpcy5jdXJyZW50RGF0ZSgpLFxyXG4gICAgICAgICAgICBlbmRUaW1lOiBtb21lbnQodGhpcy5jdXJyZW50RGF0ZSgpKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgdmFyIG5ld1VuYXZhaWxhYmxlQXBwb2ludG1lbnQgPSBmdW5jdGlvbiBuZXdVbmF2YWlsYWJsZUFwcG9pbnRtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy51bmF2YWlsYWJsZSxcclxuICAgICAgICAgICAgc3VtbWFyeTogJ1lvdWByZSB1bmF2YWlsYWJsZSBhbGwgZGF5JyxcclxuICAgICAgICAgICAgc3RhcnRUaW1lOiB0aGlzLmN1cnJlbnREYXRlKCksXHJcbiAgICAgICAgICAgIGVuZFRpbWU6IG1vbWVudCh0aGlzLmN1cnJlbnREYXRlKCkpLmFkZCgxLCAnZGF5cycpLnRvRGF0ZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICB2YXIgbmV3RnJlZUFwcG9pbnRtZW50ID0gZnVuY3Rpb24gbmV3RnJlZUFwcG9pbnRtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy5mcmVlLFxyXG4gICAgICAgICAgICBzdW1tYXJ5OiAnRnJlZScsXHJcbiAgICAgICAgICAgIHN0YXJ0VGltZTogdGhpcy5jdXJyZW50RGF0ZSgpLFxyXG4gICAgICAgICAgICBlbmRUaW1lOiBtb21lbnQodGhpcy5jdXJyZW50RGF0ZSgpKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgdmFyIG5ld0V2ZW50QXBwb2ludG1lbnQgPSBmdW5jdGlvbiBuZXdFdmVudEFwcG9pbnRtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdFdmVudCxcclxuICAgICAgICAgICAgc3VtbWFyeTogJ05ldyBldmVudC4uLicsXHJcbiAgICAgICAgICAgIHNvdXJjZUV2ZW50OiBuZXcgQ2FsZW5kYXJFdmVudCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIG5ld0Jvb2tpbmdBcHBvaW50bWVudCA9IGZ1bmN0aW9uIG5ld0Jvb2tpbmdBcHBvaW50bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFwcG9pbnRtZW50KHtcclxuICAgICAgICAgICAgaWQ6IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubmV3Qm9va2luZyxcclxuICAgICAgICAgICAgc3VtbWFyeTogJ05ldyBib29raW5nLi4uJyxcclxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IG5ldyBDYWxlbmRhckV2ZW50KCksXHJcbiAgICAgICAgICAgIHNvdXJjZUJvb2tpbmc6IG5ldyBCb29raW5nKClcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY3VycmVudEFwcG9pbnRtZW50ID0ga28ub2JzZXJ2YWJsZShsb2FkaW5nQXBwb2ludG1lbnQpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlVXJsID0gZnVuY3Rpb24gdXBkYXRlVXJsKCkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSBVUkwgdG8gbWF0Y2ggdGhlIGFwcG9pbnRtZW50IElEIGFuZFxyXG4gICAgICAgIC8vIHRyYWNrIGl0IHN0YXRlXHJcbiAgICAgICAgLy8gR2V0IElEIGZyb20gVVJMLCB0byBhdm9pZCBkbyBhbnl0aGluZyBpZiB0aGUgc2FtZS5cclxuICAgICAgICB2YXIgYXB0ID0gdGhpcy5jdXJyZW50QXBwb2ludG1lbnQoKSxcclxuICAgICAgICAgICAgYXB0SWQgPSBhcHQuaWQoKSxcclxuICAgICAgICAgICAgZm91bmQgPSAvYXBwb2ludG1lbnRcXC8oW15cXC9dKylcXC8oXFwtP1xcZCspL2kuZXhlYyh3aW5kb3cubG9jYXRpb24pLFxyXG4gICAgICAgICAgICB1cmxJZCA9IGZvdW5kICYmIGZvdW5kWzJdIHwwLFxyXG4gICAgICAgICAgICB1cmxEYXRlID0gZm91bmQgJiYgZm91bmRbMV0sXHJcbiAgICAgICAgICAgIGN1ckRhdGVTdHIgPSBnZXREYXRlV2l0aG91dFRpbWUoYXB0LnN0YXJ0VGltZSgpKS50b0lTT1N0cmluZygpO1xyXG5cclxuICAgICAgICBpZiAoIWZvdW5kIHx8XHJcbiAgICAgICAgICAgIHVybElkICE9PSBhcHRJZC50b1N0cmluZygpIHx8XHJcbiAgICAgICAgICAgIHVybERhdGUgIT09IGN1ckRhdGVTdHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdhcyBhbiBpbmNvbXBsZXRlIFVSTCwganVzdCByZXBsYWNlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICAgICAgaWYgKHVybElkID09PSAnJylcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsICdhcHBvaW50bWVudC8nICsgY3VyRGF0ZVN0ciArICcvJyArIGFwdElkKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgJ2FwcG9pbnRtZW50LycgKyBjdXJEYXRlU3RyICsgJy8nICsgYXB0SWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nb1ByZXZpb3VzID0gZnVuY3Rpb24gZ29QcmV2aW91cygpIHtcclxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSgpKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY3VycmVudEluZGV4KCkgLSAxO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIC8vIEdvIHByZXZpb3VzIGRhdGVcclxuICAgICAgICAgICAgdmFyIG0gPSBtb21lbnQodGhpcy5jdXJyZW50RGF0ZSgpKTtcclxuICAgICAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbSA9IG1vbWVudChuZXcgRGF0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJldkRhdGUgPSBtLnN1YnRyYWN0KDEsICdkYXlzJykudG9EYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudChwcmV2RGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBHbyBwcmV2aW91cyBpdGVtIGluIHRoZSBsaXN0LCBieSBjaGFuZ2luZyBjdXJyZW50SURcclxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCAlIHRoaXMuYXBwb2ludG1lbnRzKCkubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgYXB0ID0gdGhpcy5hcHBvaW50bWVudHMoKVtpbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SUQoYXB0LmlkKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBcHBvaW50bWVudChhcHQpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVybCgpO1xyXG4gICAgICAgICAgICAvLyBDb21wbGV0ZSBsb2FkLWRvdWJsZSBjaGVjazogdGhpcy5zZXRDdXJyZW50KGFwdC5zdGFydFRpbWUoKSwgYXB0LmlkKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nb05leHQgPSBmdW5jdGlvbiBnb05leHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUoKSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY3VycmVudEluZGV4KCkgKyAxO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5hcHBvaW50bWVudHMoKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gR28gbmV4dCBkYXRlXHJcbiAgICAgICAgICAgIHZhciBtID0gbW9tZW50KHRoaXMuY3VycmVudERhdGUoKSk7XHJcbiAgICAgICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIG0gPSBtb21lbnQobmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5leHREYXRlID0gbS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50KG5leHREYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEdvIG5leHQgaXRlbSBpbiB0aGUgbGlzdCwgYnkgY2hhbmdpbmcgY3VycmVudElEXHJcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggJSB0aGlzLmFwcG9pbnRtZW50cygpLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGFwdCA9IHRoaXMuYXBwb2ludG1lbnRzKClbaW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudElEKGFwdC5pZCgpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QXBwb2ludG1lbnQoYXB0KTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVVcmwoKTtcclxuICAgICAgICAgICAgLy8gQ29tcGxldGUgbG9hZC1kb3VibGUgY2hlY2s6IHRoaXMuc2V0Q3VycmVudChhcHQuc3RhcnRUaW1lKCksIGFwdC5pZCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIENoYW5naW5nIHRoZSBjdXJyZW50IHZpZXdlZCBkYXRhIGJ5IGRhdGUgYW5kIGlkXHJcbiAgICAqKi9cclxuXHJcbiAgICB0aGlzLmdldFNwZWNpYWxJdGVtID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgc3dpdGNoIChpZCkge1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvL2Nhc2UgLTE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RW1wdHlEYXRlQXBwb2ludG1lbnQoKTtcclxuICAgICAgICAgICAgY2FzZSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLmZyZWU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnJlZUFwcG9pbnRtZW50KCk7XHJcbiAgICAgICAgICAgIGNhc2UgQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdFdmVudDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwcG9pbnRtZW50KCk7XHJcbiAgICAgICAgICAgIGNhc2UgQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdCb29raW5nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Jvb2tpbmdBcHBvaW50bWVudCgpO1xyXG4gICAgICAgICAgICBjYXNlIEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubG9hZGluZzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkaW5nQXBwb2ludG1lbnQ7XHJcbiAgICAgICAgICAgIGNhc2UgQXBwb2ludG1lbnQuc3BlY2lhbElkcy51bmF2YWlsYWJsZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdVbmF2YWlsYWJsZUFwcG9pbnRtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuc2V0SXRlbUZyb21DdXJyZW50TGlzdCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIC8qanNoaW50IG1heGRlcHRoOjYsbWF4Y29tcGxleGl0eTo4Ki9cclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuYXBwb2ludG1lbnRzKCksXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICBpdGVtO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCwgcmVzcGVjdCBzcGVjaWFsIElEcywgZXhjZXB0IHRoZSAnbm8gYXBwdHMnOlxyXG4gICAgICAgIGlmIChpZCA8IC0xKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldFNwZWNpYWxJdGVtKGlkKTtcclxuICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gTm8gaXRlbSBJRCwgZW1wdHkgbGlzdDpcclxuICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgLy8gU2hvdyBhcyBlbXB0eSBvciBmdWxsLXVuYXZhaWxhYmxlOlxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRlQXZhaWxhYmlsaXR5KCkud29ya0RheU1pbnV0ZXMoKSA9PT0gMClcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXdVbmF2YWlsYWJsZUFwcG9pbnRtZW50KCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXdFbXB0eURhdGVBcHBvaW50bWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgZ2V0dGluZyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdFxyXG4gICAgICAgICAgICBpdGVtID0gbGlzdFswXTtcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gV2l0aCBhbnkgSUQgdmFsdWVcclxuICAgICAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggdGhlIElEXHJcbiAgICAgICAgICAgICAgICBpZiAoaWQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGl0ZW0gaW4gY2FjaGVkIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmaW5kQXBwb2ludG1lbnRJbkxpc3QobGlzdCwgaWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQuaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gZm91bmQuaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBmb3VuZC5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgdGhlIGZpcnN0IGl0ZW0gd2lsbCBiZSB1c2VkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5nZXRTcGVjaWFsSXRlbShpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50SUQoaXRlbS5pZCgpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleChpbmRleCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QXBwb2ludG1lbnQoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgX3NldEN1cnJlbnQgPSBmdW5jdGlvbiBzZXRDdXJyZW50KGRhdGUsIGlkLCB0eXBlKSB7XHJcbiAgICAgICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eTo4XHJcbiAgICAgICAgLy8gSU1QT1JUQU5UOiB0aGUgZGF0ZSB0byB1c2UgbXVzdCBiZSBldmVyXHJcbiAgICAgICAgLy8gYSBuZXcgb2JqZWN0IHJhdGhlciB0aGFuIHRoZSByZWZlcmVuY2VkIG9uZSB0b1xyXG4gICAgICAgIC8vIGF2b2lkIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgc2FtZSBvYmplY3QgaXMgbXV0YXRlZFxyXG4gICAgICAgIC8vIGFuZCBjb21wYXJpc2lvbnMgY2FuIGZhaWwuIFxyXG4gICAgICAgIC8vIGdldERhdGVXaXRob3V0VGltZSBlbnN1cmUgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGV2ZXIuXHJcbiAgICAgICAgZGF0ZSA9IGRhdGUgJiYgZ2V0RGF0ZVdpdGhvdXRUaW1lKGRhdGUpIHx8IG51bGw7XHJcbiAgICAgICAgaWYgKGRhdGUpXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUoZGF0ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFkYXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChpZCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW90ZSBzZWFyY2ggZm9yIGlkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm90Rm91bmQgPSBmdW5jdGlvbiBub3RGb3VuZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZXRDdXJyZW50KG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpZHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnYm9va2luZycpXHJcbiAgICAgICAgICAgICAgICAgICAgaWRzLmJvb2tpbmdJRCA9IGlkO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGlkcy5jYWxlbmRhckV2ZW50SUQgPSBpZDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5jYWxlbmRhci5nZXRBcHBvaW50bWVudChpZHMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGEgbG9hZCBmb3IgdGhlIGl0ZW0gZGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0RGF0ZSA9IGdldERhdGVXaXRob3V0VGltZShpdGVtLnN0YXJ0VGltZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NldEN1cnJlbnQoaXREYXRlLCBpdGVtLmlkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKG5vdEZvdW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgSURzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NldEN1cnJlbnQobmV3IERhdGUoKSwgaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gZGF0ZSwgbm8gSUQsIGxvYWQgdG9kYXlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc2V0Q3VycmVudChuZXcgRGF0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwuY2FsZW5kYXIuZ2V0RGF0ZUF2YWlsYWJpbGl0eShkYXRlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0ZUF2YWlsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGVBdmFpbGFiaWxpdHkoZGF0ZUF2YWlsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SXRlbUZyb21DdXJyZW50TGlzdChpZCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0Vycm9yIGxvYWRpbmcgY2FsZW5kYXIgZXZlbnRzLic7XHJcbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci5lcnJvciB8fCBlcnJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdmFyIHByb21pc2VTZXRDdXJyZW50ID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB0aGlzLnNldEN1cnJlbnQgPSBmdW5jdGlvbiBzZXRDdXJyZW50KGRhdGUsIGlkLCB0eXBlKSB7XHJcbiAgICAgICAgLy8gTk9URTogRG8gbm90aGluZyBpZiBpcyBhbHJlYWR5IGluIGxvYWRpbmcgcHJvY2Vzc1xyXG4gICAgICAgIC8vIFRPRE86IHJldmlldyBpZiBpcyBiZXR0ZXIgdG8gY2FuY2VsIGN1cnJlbnQgYW5kIGNvbnRpbnVlIG9yXHJcbiAgICAgICAgLy8ganVzdCB0aGUgY3VycmVudCBxdWV1ZSBmb3Igd2hlbiBpdCdzIGZpbmlzaC5cclxuICAgICAgICAvLyBJZiBzZXQgYXMgJ2FsbG93IGNvbmN1cnJlbnQnXHJcbiAgICAgICAgLy8gdGhlIGlzTG9hZGluZyBtYXkgYmUgbm90IGVub3VnaCB0byBjb250cm9sIHRoZSBzZXZlcmFsIGxvYWRpbmdzXHJcbiAgICAgICAgcHJvbWlzZVNldEN1cnJlbnQgPSBwcm9taXNlU2V0Q3VycmVudC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3NldEN1cnJlbnQoZGF0ZSwgaWQsIHR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlU2V0Q3VycmVudDtcclxuICAgIH07XHJcbn1cclxuIiwiLyoqXHJcbiAgICBCb29rTWVCdXR0b24gYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBCb29rTWVCdXR0b25BY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIFxyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5GcmVlbGFuY2VyO1xyXG5cclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycpO1xyXG4gICAgXHJcbiAgICAvLyBBdXRvIHNlbGVjdCB0ZXh0IG9uIHRleHRhcmVhLCBmb3IgYmV0dGVyICdjb3B5J1xyXG4gICAgLy8gTk9URTogdGhlICdzZWxlY3QnIG11c3QgaGFwcGVuIG9uIGNsaWNrLCBubyB0b3VjaCwgbm90IGZvY3VzLFxyXG4gICAgLy8gb25seSAnY2xpY2snIGlzIHJlbGlhYmxlIGFuZCBidWctZnJlZS5cclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuJGFjdGl2aXR5LFxyXG4gICAgICAgIGV2ZW50OiAnY2xpY2snLFxyXG4gICAgICAgIHNlbGVjdG9yOiAndGV4dGFyZWEnLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5tYXJrZXRwbGFjZVByb2ZpbGUsXHJcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLnRhc2sgPT09ICdzYXZlJykgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gJ0Vycm9yIGxvYWRpbmcgZGF0YSB0byBidWlsZCB0aGUgQnV0dG9uLic7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLnRhc2sgJiYgZXJyLmVycm9yIHx8IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcclxuICAgIFxyXG4gICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XHJcbiAgICB0aGlzLmFwcC5tb2RlbC5tYXJrZXRwbGFjZVByb2ZpbGUuc3luYygpO1xyXG4gICAgXHJcbiAgICAvLyBTZXQgdGhlIGpvYiB0aXRsZVxyXG4gICAgdmFyIGpvYklEID0gc3RhdGUucm91dGUuc2VnbWVudHNbMF0gfDA7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYklEKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuXHJcbiAgICB2YXIgbWFya2V0cGxhY2VQcm9maWxlID0gYXBwLm1vZGVsLm1hcmtldHBsYWNlUHJvZmlsZTtcclxuICAgIFxyXG4gICAgLy8gQWN0dWFsIGRhdGEgZm9yIHRoZSBmb3JtOlxyXG4gICAgXHJcbiAgICAvLyBSZWFkLW9ubHkgYm9va0NvZGVcclxuICAgIHRoaXMuYm9va0NvZGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbWFya2V0cGxhY2VQcm9maWxlLmRhdGEuYm9va0NvZGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xyXG4gICAgXHJcbiAgICAvLyBCdXR0b24gdHlwZSwgY2FuIGJlOiAnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJywgJ2xpbmsnXHJcbiAgICB0aGlzLnR5cGUgPSBrby5vYnNlcnZhYmxlKCdtZWRpdW0nKTtcclxuXHJcbiAgICB0aGlzLmlzTG9ja2VkID0gbWFya2V0cGxhY2VQcm9maWxlLmlzTG9ja2VkO1xyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0aW9uIG9mIHRoZSBidXR0b24gY29kZVxyXG4gICAgXHJcbiAgICB2YXIgYnV0dG9uVGVtcGxhdGUgPVxyXG4gICAgICAgICc8IS0tIGJlZ2luIExvY29ub21pY3MgYm9vay1tZS1idXR0b24gLS0+JyArXHJcbiAgICAgICAgJzxhIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2tcIj48aW1nIGFsdD1cIlwiIHN0eWxlPVwiYm9yZGVyOm5vbmVcIiAvPjwvYT4nICsgXHJcbiAgICAgICAgJzwhLS0gZW5kIExvY29ub21pY3MgYm9vay1tZS1idXR0b24gLS0+JztcclxuICAgIFxyXG4gICAgdmFyIGxpbmtUZW1wbGF0ZSA9XHJcbiAgICAgICAgJzwhLS0gYmVnaW4gTG9jb25vbWljcyBib29rLW1lLWJ1dHRvbiAtLT4nICtcclxuICAgICAgICAnPGE+PHNwYW4+PC9zcGFuPjwvYT4nICtcclxuICAgICAgICAnPCEtLSBlbmQgTG9jb25vbWljcyBib29rLW1lLWJ1dHRvbiAtLT4nO1xyXG5cclxuICAgIHRoaXMuYnV0dG9uSHRtbENvZGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG1hcmtldHBsYWNlUHJvZmlsZS5pc0xvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xvYWRpbmcuLi4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUoKSxcclxuICAgICAgICAgICAgICAgIHRwbCA9IGJ1dHRvblRlbXBsYXRlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsaW5rJylcclxuICAgICAgICAgICAgICAgIHRwbCA9IGxpbmtUZW1wbGF0ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzaXRlVXJsID0gJCgnaHRtbCcpLmF0dHIoJ2RhdGEtc2l0ZS11cmwnKSxcclxuICAgICAgICAgICAgICAgIGxpbmtVcmwgPSBzaXRlVXJsICsgJy9ib29rLycgKyB0aGlzLmJvb2tDb2RlKCkgKyAnLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICcvJyxcclxuICAgICAgICAgICAgICAgIGltZ1VybCA9IHNpdGVVcmwgKyAnL2ltZy9leHRlcm4vYm9vay1tZS1idXR0b24tJyArIHR5cGUgKyAnLnBuZyc7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29kZSA9IGdlbmVyYXRlQnV0dG9uQ29kZSh7XHJcbiAgICAgICAgICAgICAgICB0cGw6IHRwbCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQ2xpY2sgaGVyZSB0byBib29rIG1lIG5vdyAob24gbG9jb25vbWljcy5jb20pJyxcclxuICAgICAgICAgICAgICAgIGxpbmtVcmw6IGxpbmtVcmwsXHJcbiAgICAgICAgICAgICAgICBpbWdVcmw6IGltZ1VybFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBUT0RPIENvcHkgZmVhdHVyZTsgd2lsbCBuZWVkIGEgbmF0aXZlIHBsdWdpblxyXG4gICAgdGhpcy5jb3B5Q29kZSA9IGZ1bmN0aW9uKCkgeyB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnNlbmRCeUVtYWlsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gVE9ETyBTZW5kIGJ5IGVtYWlsLCB3aXRoIHdpbmRvdy5vcGVuKCdtYWlsdG86JmJvZHk9Y29kZScpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVCdXR0b25Db2RlKG9wdGlvbnMpIHtcclxuXHJcbiAgICB2YXIgJGJ0biA9ICQoJC5wYXJzZUhUTUwoJzxkaXY+JyArIG9wdGlvbnMudHBsICsgJzwvZGl2PicpKTtcclxuXHJcbiAgICAkYnRuXHJcbiAgICAuZmluZCgnYScpXHJcbiAgICAuYXR0cignaHJlZicsIG9wdGlvbnMubGlua1VybClcclxuICAgIC5maW5kKCdzcGFuJylcclxuICAgIC50ZXh0KG9wdGlvbnMubGFiZWwpO1xyXG4gICAgJGJ0blxyXG4gICAgLmZpbmQoJ2ltZycpXHJcbiAgICAuYXR0cignc3JjJywgb3B0aW9ucy5pbWdVcmwpXHJcbiAgICAuYXR0cignYWx0Jywgb3B0aW9ucy5sYWJlbCk7XHJcblxyXG4gICAgcmV0dXJuICRidG4uaHRtbCgpO1xyXG59XHJcbiIsIi8qKiBDYWxlbmRhciBhY3Rpdml0eSAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgZ2V0RGF0ZVdpdGhvdXRUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0RGF0ZVdpdGhvdXRUaW1lJyk7XHJcblxyXG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL0RhdGVQaWNrZXInKTtcclxudmFyIGRhdGVwaWNrZXJBdmFpbGFiaWxpdHkgPSByZXF1aXJlKCcuLi91dGlscy9kYXRlcGlja2VyQXZhaWxhYmlsaXR5Jyk7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ2FsZW5kYXJBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIoJ0NhbGVuZGFyJyk7XHJcblxyXG4gICAgLyogR2V0dGluZyBlbGVtZW50cyAqL1xyXG4gICAgdGhpcy4kZGF0ZXBpY2tlciA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjYWxlbmRhckRhdGVQaWNrZXInKTtcclxuICAgIHRoaXMuJGRhaWx5VmlldyA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjYWxlbmRhckRhaWx5VmlldycpO1xyXG4gICAgdGhpcy4kZGF0ZVRpdGxlID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnLkNhbGVuZGFyRGF0ZUhlYWRlciA+IC5idG4nKTtcclxuICAgIHRoaXMuJGNob29zZU5ldyA9ICQoJyNjYWxlbmRhckNob29zZU5ldycpO1xyXG4gICAgXHJcbiAgICAvKiBJbml0IGNvbXBvbmVudHMgKi9cclxuICAgIHRoaXMuJGRhdGVwaWNrZXIuc2hvdygpLmRhdGVwaWNrZXIoeyBleHRyYUNsYXNzZXM6ICdEYXRlUGlja2VyLS10YWdnZWQnIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLnRhZ0F2YWlsYWJpbGl0eSA9IGRhdGVwaWNrZXJBdmFpbGFiaWxpdHkuY3JlYXRlKHRoaXMuYXBwLCB0aGlzLiRkYXRlcGlja2VyLCB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcpO1xyXG5cclxuICAgIC8qIEV2ZW50IGhhbmRsZXJzICovXHJcbiAgICAvLyBDaGFuZ2VzIG9uIGN1cnJlbnREYXRlXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5jdXJyZW50RGF0ZSxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihkYXRlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1kYXRlID0gbW9tZW50KGRhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtZGF0ZS5pc1ZhbGlkKCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzb0RhdGUgPSBtZGF0ZS50b0lTT1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZGF0ZXBpY2tlciBzZWxlY3RlZCBkYXRlIG9uIGRhdGUgY2hhbmdlIChmcm9tIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgZGlmZmVyZW50IHNvdXJjZSB0aGFuIHRoZSBkYXRlcGlja2VyIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2Ugbm90IGZyb20gdGhlIHdpZGdldD9cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kZGF0ZXBpY2tlci5kYXRlcGlja2VyKCdnZXRWYWx1ZScpLnRvSVNPU3RyaW5nKCkgIT09IGlzb0RhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignc2V0VmFsdWUnLCBkYXRlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gY3VycmVudERhdGUgY2hhbmdlcywgdXBkYXRlIHRoZSBVUkxcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzYXZlIGEgdXNlZnVsIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRE9VQlQ6IHB1c2ggb3IgcmVwbGFjZSBzdGF0ZT8gKG1vcmUgaGlzdG9yeSBlbnRyaWVzIG9yIHRoZSBzYW1lPylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCAnY2FsZW5kYXIvJyArIGlzb0RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBET05FXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgZmFpbCwgYmFkIGRhdGUgb3Igbm90IGRhdGUgYXQgYWxsXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZ2V0RGF0ZVdpdGhvdXRUaW1lKCkpO1xyXG5cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFN3aXBlIGRhdGUgb24gZ2VzdHVyZVxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy4kZGFpbHlWaWV3LFxyXG4gICAgICAgIGV2ZW50OiAnc3dpcGVsZWZ0IHN3aXBlcmlnaHQnLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpciA9IGUudHlwZSA9PT0gJ3N3aXBlbGVmdCcgPyAnbmV4dCcgOiAncHJldic7XHJcblxyXG4gICAgICAgICAgICAvLyBIYWNrIHRvIHNvbHZlIHRoZSBmcmVlenktc3dpcGUgYW5kIHRhcC1hZnRlciBidWcgb24gSlFNOlxyXG4gICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKCd0b3VjaGVuZCcpO1xyXG4gICAgICAgICAgICAvLyBDaGFuZ2UgZGF0ZVxyXG4gICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyLmRhdGVwaWNrZXIoJ21vdmVWYWx1ZScsIGRpciwgJ2RhdGUnKTtcclxuXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTaG93aW5nIGRhdGVwaWNrZXIgd2hlbiBwcmVzc2luZyB0aGUgdGl0bGVcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuJGRhdGVUaXRsZSxcclxuICAgICAgICBldmVudDogJ2NsaWNrJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIudG9nZ2xlQ2xhc3MoJ2lzLXZpc2libGUnKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVXBkYXRpbmcgdmlldyBkYXRlIHdoZW4gcGlja2VkIGFub3RoZXIgb25lXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRkYXRlcGlja2VyLFxyXG4gICAgICAgIGV2ZW50OiAnZGF0ZUNoYW5nZWQnLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUudmlld01vZGUgPT09ICdkYXlzJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZ2V0RGF0ZVdpdGhvdXRUaW1lKGUuZGF0ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTZXQgZGF0ZSB0byB0b2RheVxyXG4gICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZ2V0RGF0ZVdpdGhvdXRUaW1lKCkpO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gRGF0ZSBmcm9tIHRoZSBwYXJhbWV0ZXIsIGZhbGxiYWNrIHRvIHRvZGF5XHJcbiAgICB2YXIgc2RhdGUgPSBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHMgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50c1swXSxcclxuICAgICAgICBkYXRlO1xyXG4gICAgaWYgKHNkYXRlKSB7XHJcbiAgICAgICAgLy8gUGFyc2luZyBkYXRlIGZyb20gSVNPIGZvcm1hdFxyXG4gICAgICAgIHZhciBtZGF0ZSA9IG1vbWVudChzZGF0ZSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaXMgdmFsaWQsIGFuZCBlbnN1cmUgaXMgZGF0ZSBhdCAxMkFNXHJcbiAgICAgICAgZGF0ZSA9IG1kYXRlLmlzVmFsaWQoKSA/IGdldERhdGVXaXRob3V0VGltZShtZGF0ZS50b0RhdGUoKSkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoIWRhdGUpXHJcbiAgICAgICAgLy8gVG9kYXk6XHJcbiAgICAgICAgZGF0ZSA9IGdldERhdGVXaXRob3V0VGltZSgpO1xyXG4gICAgXHJcbiAgICAvLyBSZXNldCB0byBmb3JjZSBuZXcgZGF0YSBsb2FkIChjYW4gaGFwcGVucyBpZiBzY2hlZHVsZSB3YXMgY2hhbmdlIG9yIGFueXRoaW5nIGluIHRoZSBtaWRkbGUpXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5wcmV2aW91c0RhdGUgPSBudWxsO1xyXG4gICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZGF0ZSk7XHJcbiAgICAvLyBGb3JjZSBhIHJlZnJlc2ggb2YgdGFnc1xyXG4gICAgdGhpcy50YWdBdmFpbGFiaWxpdHkoZGF0ZSwgdHJ1ZSk7XHJcbn07XHJcblxyXG52YXIgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKSxcclxuICAgIFRpbWVTbG90Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9UaW1lU2xvdCcpO1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHRoaXMuY3VycmVudERhdGUgPSBrby5vYnNlcnZhYmxlKGdldERhdGVXaXRob3V0VGltZSgpKTtcclxuICAgIHZhciBmdWxsRGF5RnJlZSA9IFtBcHBvaW50bWVudC5uZXdGcmVlU2xvdCh7IGRhdGU6IHRoaXMuY3VycmVudERhdGUoKSB9KV07XHJcbiAgICAvLyBUaGUgJ2ZyZWUnIGV2ZW50IG11c3QgdXBkYXRlIHdpdGggYW55IGNoYW5nZSBpbiBjdXJyZW50RGF0ZVxyXG4gICAgdGhpcy5jdXJyZW50RGF0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgICAgIGlmIChkYXRlKSB7XHJcbiAgICAgICAgICAgIGZ1bGxEYXlGcmVlWzBdLnN0YXJ0VGltZShkYXRlKTtcclxuICAgICAgICAgICAgZnVsbERheUZyZWVbMF0uZW5kVGltZShkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAvLyBzbG90c1NvdXJjZSBzYXZlIHRoZSBkYXRhIGFzIHByb2Nlc3NlZCBieSBhIHJlcXVlc3Qgb2YgXHJcbiAgICAvLyBkYXRhIGJlY2F1c2UgYSBkYXRlIGNoYW5nZS5cclxuICAgIC8vIEl0J3MgdXBkYXRlZCBieSBjaGFuZ2VzIG9uIGN1cnJlbnREYXRlIHRoYXQgcGVyZm9ybXMgdGhlIHJlbW90ZSBsb2FkaW5nXHJcbiAgICB0aGlzLnNsb3RzU291cmNlID0ga28ub2JzZXJ2YWJsZShmdWxsRGF5RnJlZSk7XHJcbiAgICAvLyBzbG90cyBjb21wdXRlZCwgdXNpbmcgc2xvdHNTb3VyY2UuXHJcbiAgICAvLyBBcyBjb21wdXRlZCBpbiBvcmRlciB0byBhbGxvdyBhbnkgb3RoZXIgb2JzZXJ2YWJsZSBjaGFuZ2VcclxuICAgIC8vIGZyb20gdHJpZ2dlciB0aGUgY3JlYXRpb24gb2YgYSBuZXcgdmFsdWVcclxuICAgIHRoaXMuc2xvdHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHNTb3VyY2UoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBIaWRlIHVuYXZhaWxhYmxlIHNsb3RzLCBleGNlcHQgaWYgdGhlcmUgaXMgb25seSBvbmUgc2xvdCAoc28gdGhlcmVcclxuICAgICAgICAvLyBpcyBldmVyIHNvbWV0aGluZyBkaXNwbGF5ZWQpXHJcbiAgICAgICAgaWYgKHNsb3RzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgc2xvdHMgPSBzbG90cy5maWx0ZXIoZnVuY3Rpb24oc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsb3QuaWQoKSAhPT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy51bmF2YWlsYWJsZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzbG90cy5tYXAoVGltZVNsb3RWaWV3TW9kZWwuZnJvbUFwcG9pbnRtZW50KTtcclxuXHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgY3VycmVudCBzbG90cyBvbiBkYXRlIGNoYW5nZVxyXG4gICAgLy8gcHJldmlvdXNEYXRlIGlzIHB1YmxpYyB0byBhbGxvdyBiZWluZyByZXNldCBvbiBhIG5ldyBzaG93IChkaXNjYXJkIG9sZCBkYXRhXHJcbiAgICAvLyBieSBmb3JjaW5nIGEgbG9hZClcclxuICAgIHRoaXMucHJldmlvdXNEYXRlID0gdGhpcy5jdXJyZW50RGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB0aGlzLmN1cnJlbnREYXRlLnN1YnNjcmliZShmdW5jdGlvbiAoZGF0ZSkge1xyXG5cclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IFRoZSBkYXRlIG9iamVjdCBtYXkgYmUgcmV1c2VkIGFuZCBtdXRhdGVkIGJldHdlZW4gY2FsbHNcclxuICAgICAgICAvLyAobW9zdGx5IGJlY2F1c2UgdGhlIHdpZGdldCBJIHRoaW5rKSwgc28gaXMgYmV0dGVyIHRvIGNyZWF0ZVxyXG4gICAgICAgIC8vIGEgY2xvbmUgYW5kIGF2b2lkIGdldHRpbmcgcmFjZS1jb25kaXRpb25zIGluIHRoZSBkYXRhIGRvd25sb2FkaW5nLlxyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKGRhdGUudG9JU09TdHJpbmcoKSkpO1xyXG5cclxuICAgICAgICAvLyBBdm9pZCBkdXBsaWNhdGVkIG5vdGlmaWNhdGlvbiwgdW4tY2hhbmdlZCBkYXRlXHJcbiAgICAgICAgaWYgKGRhdGUudG9JU09TdHJpbmcoKSA9PT0gdGhpcy5wcmV2aW91c0RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByZXZpb3VzRGF0ZSA9IGRhdGUudG9JU09TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXBwLm1vZGVsLmNhbGVuZGFyLmdldERhdGVBdmFpbGFiaWxpdHkoZGF0ZSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihkYXRlQXZhaWwpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogRmlyc3QsIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB3ZSBhcmVcclxuICAgICAgICAgICAgLy8gaW4gdGhlIHNhbWUgZGF0ZSBzdGlsbCwgYmVjYXVzZSBzZXZlcmFsIGxvYWRpbmdzXHJcbiAgICAgICAgICAgIC8vIGNhbiBoYXBwZW4gYXQgYSB0aW1lIChjaGFuZ2luZyBxdWlja2x5IGZyb20gZGF0ZSB0byBkYXRlXHJcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgd2FpdCBmb3IgZmluaXNoKSwgYXZvaWRpbmcgYSByYWNlLWNvbmRpdGlvblxyXG4gICAgICAgICAgICAvLyB0aGF0IGNyZWF0ZSBmbGlja2VyaW5nIGVmZmVjdHMgb3IgcmVwbGFjZSB0aGUgZGF0ZSBldmVudHNcclxuICAgICAgICAgICAgLy8gYnkgdGhlIGV2ZW50cyBmcm9tIG90aGVyIGRhdGUsIGJlY2F1c2UgaXQgdG9va3MgbW9yZSBhbiBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBzdGlsbCB0aGlzIGhhcyB0aGUgbWlub3IgYnVnIG9mIGxvc2luZyB0aGUgaXNMb2FkaW5nXHJcbiAgICAgICAgICAgIC8vIGlmIGEgcHJldmlvdXMgdHJpZ2dlcmVkIGxvYWQgc3RpbGwgZGlkbid0IGZpbmlzaGVkOyBpdHMgbWlub3JcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpcyB2ZXJ5IHJhcmUgdGhhdCBoYXBwZW5zLCBtb3ZpbmcgdGhpcyBzdHVmZlxyXG4gICAgICAgICAgICAvLyB0byBhIHNwZWNpYWwgYXBwTW9kZWwgZm9yIG1peGVkIGJvb2tpbmdzIGFuZCBldmVudHMgd2l0aCBcclxuICAgICAgICAgICAgLy8gcGVyIGRhdGUgY2FjaGUgdGhhdCBpbmNsdWRlcyBhIHZpZXcgb2JqZWN0IHdpdGggaXNMb2FkaW5nIHdpbGxcclxuICAgICAgICAgICAgLy8gZml4IGl0IGFuZCByZWR1Y2UgdGhpcyBjb21wbGV4aXR5LlxyXG4gICAgICAgICAgICBpZiAoZGF0ZS50b0lTT1N0cmluZygpICE9PSB0aGlzLmN1cnJlbnREYXRlKCkudG9JU09TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmFjZSBjb25kaXRpb24sIG5vdCB0aGUgc2FtZSEhIG91dDpcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNvdXJjZTpcclxuICAgICAgICAgICAgdGhpcy5zbG90c1NvdXJjZShkYXRlQXZhaWwubGlzdCgpKTtcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gU2hvdyBmcmVlIG9uIGVycm9yXHJcbiAgICAgICAgICAgIHRoaXMuc2xvdHNTb3VyY2UoZnVsbERheUZyZWUpO1xyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbXNnID0gJ0Vycm9yIGxvYWRpbmcgY2FsZW5kYXIgZXZlbnRzLic7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci5lcnJvciB8fCBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufVxyXG4iLCIvKipcclxuICAgIENhbGVuZGFyU3luY2luZyBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIENhbGVuZGFyU3luY2luZ0FjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XHJcblxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnc2NoZWR1bGluZydcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBBZGRpbmcgYXV0by1zZWxlY3QgYmVoYXZpb3IgdG8gdGhlIGV4cG9ydCBVUkxcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjYWxlbmRhclN5bmMtaWNhbEV4cG9ydFVybCcpLFxyXG4gICAgICAgIGV2ZW50OiAnY2xpY2snLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5jYWxlbmRhclN5bmNpbmcsXHJcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBlcnIudGFzayA9PT0gJ3NhdmUnID8gJ0Vycm9yIHNhdmluZyBjYWxlbmRhciBzeW5jaW5nIHNldHRpbmdzLicgOiAnRXJyb3IgbG9hZGluZyBjYWxlbmRhciBzeW5jaW5nIHNldHRpbmdzLic7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLnRhc2sgJiYgZXJyLmVycm9yIHx8IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcclxuICAgIFxyXG4gICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XHJcbiAgICB0aGlzLmFwcC5tb2RlbC5jYWxlbmRhclN5bmNpbmcuc3luYygpO1xyXG4gICAgLy8gRGlzY2FyZCBhbnkgcHJldmlvdXMgdW5zYXZlZCBlZGl0XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5kaXNjYXJkKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcblxyXG4gICAgdmFyIGNhbGVuZGFyU3luY2luZyA9IGFwcC5tb2RlbC5jYWxlbmRhclN5bmNpbmc7XHJcblxyXG4gICAgdmFyIHN5bmNWZXJzaW9uID0gY2FsZW5kYXJTeW5jaW5nLm5ld1ZlcnNpb24oKTtcclxuICAgIHN5bmNWZXJzaW9uLmlzT2Jzb2xldGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGl0SXMpIHtcclxuICAgICAgICBpZiAoaXRJcykge1xyXG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXHJcbiAgICAgICAgICAgIC8vIEZVVFVSRTogd2FybiBhYm91dCBhIG5ldyByZW1vdGUgdmVyc2lvbiBhc2tpbmdcclxuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcclxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcclxuICAgICAgICAgICAgLy8gd2l0aCBhIDUwOTpDb25mbGljdCBzdGF0dXMgKGl0cyBib2R5IG11c3QgY29udGFpbiB0aGVcclxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxyXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbW90ZSBvbmVzOlxyXG4gICAgICAgICAgICBzeW5jVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEFjdHVhbCBkYXRhIGZvciB0aGUgZm9ybTpcclxuICAgIHRoaXMuc3luYyA9IHN5bmNWZXJzaW9uLnZlcnNpb247XHJcblxyXG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xvY2tlZCgpIHx8IHRoaXMuaXNSZXNldGluZygpO1xyXG4gICAgfSwgY2FsZW5kYXJTeW5jaW5nKTtcclxuXHJcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnc2F2aW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICdTYXZlJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCBjYWxlbmRhclN5bmNpbmcpO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlc2V0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmlzUmVzZXRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ3Jlc2V0aW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgJ1Jlc2V0IFByaXZhdGUgVVJMJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCBjYWxlbmRhclN5bmNpbmcpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRpc2NhcmQgPSBmdW5jdGlvbiBkaXNjYXJkKCkge1xyXG4gICAgICAgIHN5bmNWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICBzeW5jVmVyc2lvbi5wdXNoU2F2ZSgpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gICAgICAgIGNhbGVuZGFyU3luY2luZy5yZXNldEV4cG9ydFVybCgpO1xyXG4gICAgfTtcclxufVxyXG4iLCIvKipcclxuICAgIENsaWVudEVkaXRpb24gYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyIGlzID0gcmVxdWlyZSgnaXNfanMnKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBDbGllbnRFZGl0aW9uQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICBcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ2NsaWVudHMnLCB7XHJcbiAgICAgICAgYmFja0xpbms6ICdjbGllbnRzJ1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIElmIHRoZXJlIGlzIGEgY2hhbmdlIG9uIHRoZSBjbGllbnRJRCwgdGhlIHVwZGF0ZXMgbXVzdCBtYXRjaFxyXG4gICAgLy8gdGhhdCAoaWYgaXMgbm90IGFscmVhZHkgdGhhdClcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmNsaWVudElELFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChjbGllbnRJRCkge1xyXG4gICAgICAgICAgICBpZiAoIWNsaWVudElEKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gL2NsaWVudEVkaXRvclxcLyhcXC0/XFxkKykvaS5leGVjKHdpbmRvdy5sb2NhdGlvbiksXHJcbiAgICAgICAgICAgICAgICB1cmxJRCA9IGZvdW5kICYmIGZvdW5kWzFdIHwwO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgaXMgZGlmZmVyZW50IFVSTCBhbmQgY3VycmVudCBJRFxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kIHx8XHJcbiAgICAgICAgICAgICAgICB1cmxJRCAhPT0gY2xpZW50SUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgVVJMXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCAnY2xpZW50RWRpdG9yLycgKyBjbGllbnRJRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBvZiB0aGUgc2F2ZSBvcGVyYXRpb25cclxuICAgIHRoaXMudmlld01vZGVsLm9uU2F2ZSA9IGZ1bmN0aW9uKGNsaWVudElEKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEucmV0dXJuTmV3QXNTZWxlY3RlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAvLyBHbyB0byBwcmV2aW91cyBhY3Rpdml0eSB0aGF0IHJlcXVpcmVkXHJcbiAgICAgICAgICAgIC8vIHRvIHNlbGVjdCBhIGNsaWVudFxyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REYXRhLmNsaWVudElEID0gY2xpZW50SUQ7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgc2F2ZVxyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdWNjZXNzU2F2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxuQS5wcm90b3R5cGUudXBkYXRlTmF2QmFyU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVOYXZCYXJTdGF0ZSgpIHtcclxuXHJcbiAgICB2YXIgcmVmZXJyZXIgPSB0aGlzLmFwcC5zaGVsbC5yZWZlcnJlclJvdXRlO1xyXG4gICAgcmVmZXJyZXIgPSByZWZlcnJlciAmJiByZWZlcnJlci51cmwgfHwgJy9jbGllbnRzJztcclxuICAgIHZhciBsaW5rID0gdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rIHx8IHJlZmVycmVyO1xyXG4gICAgXHJcbiAgICB0aGlzLmNvbnZlcnRUb0NhbmNlbEFjdGlvbih0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCksIGxpbmspO1xyXG59O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDgqL1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcbiAgICBcclxuICAgIC8vIHJlc2V0XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRJRCgwKTtcclxuICAgIFxyXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xyXG5cclxuICAgIC8vIHBhcmFtc1xyXG4gICAgdmFyIHBhcmFtcyA9IHN0YXRlICYmIHN0YXRlLnJvdXRlICYmIHN0YXRlLnJvdXRlLnNlZ21lbnRzIHx8IFtdO1xyXG4gICAgXHJcbiAgICB2YXIgY2xpZW50SUQgPSBwYXJhbXNbMF0gfDA7XHJcbiAgICBcclxuICAgIGlmIChjbGllbnRJRCkge1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmNsaWVudElEKGNsaWVudElEKTtcclxuICAgICAgICBcclxuICAgICAgICAvKnRoaXMudmlld01vZGVsLmNsaWVudC5zeW5jKGNsaWVudElEKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIGNsaWVudCBkYXRhJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTsqL1xyXG5cclxuICAgICAgICB0aGlzLmFwcC5tb2RlbC5jdXN0b21lcnMuY3JlYXRlSXRlbVZlcnNpb24oY2xpZW50SUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNsaWVudFZlcnNpb24pIHtcclxuICAgICAgICAgICAgaWYgKGNsaWVudFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmNsaWVudFZlcnNpb24oY2xpZW50VmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXIoJ0VkaXQgQ2xpZW50Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRWZXJzaW9uKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdVbmtub3cgY2xpZW50IG9yIHdhcyBkZWxldGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgY2xpZW50IGRhdGEnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgcmVxdWVzdCBwYXJhbWV0ZXJzIHRoYXQgYWxsb3cgcHJlc2V0IGN1c3RvbWVyIGluZm9ybWF0aW9uXHJcbiAgICAgICAgLy8gKHVzZWQgd2hlbiB0aGUgY3VzdG9tZXIgaXMgY3JlYXRlZCBiYXNlZCBvbiBhbiBleGlzdGVudCBtYXJrZXRwbGFjZSB1c2VyKVxyXG4gICAgICAgIHZhciBwcmVzZXREYXRhID0gdGhpcy5yZXF1ZXN0RGF0YS5wcmVzZXREYXRhIHx8IHt9O1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzZXQgYW4gZXhwbGljaXQgJ2ZhbHNlJyB2YWx1ZSBvbiBlZGl0YWJsZVxyXG4gICAgICAgIC8vIGZpZWxkIChhcyB3aGVuIHRoZXJlIGlzIG5vdCBkYXRhIGdpdmVuKSwgc2V0IHRvIHRydWUgc28gY2FuIGJlIGVkaXRlZFxyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYmVjYXVzZSBhIGdpdmVuIG1hcmtldHBsYWNlIHVzZXIgd2lsbCBjb21lIHdpdGggZWRpdGFibGU6ZmFsc2VcclxuICAgICAgICAvLyBhbmQgbmVlZCB0byBiZSBwcmVzZXJ2ZWQsIHdoaWxlIG9uIHJlZ3VsYXIgJ25ldyBjbGllbnQnIGFsbCBkYXRhIGlzIHNldCBieSBcclxuICAgICAgICAvLyB0aGUgZnJlZWxhbmNlci5cclxuICAgICAgICBpZiAocHJlc2V0RGF0YS5lZGl0YWJsZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcHJlc2V0RGF0YS5lZGl0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKnRoaXMudmlld01vZGVsLmNsaWVudC5uZXdJdGVtKHByZXNldERhdGEpOyovXHJcbiAgICAgICAgLy8gTmV3IGNsaWVudFxyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmNsaWVudFZlcnNpb24odGhpcy5hcHAubW9kZWwuY3VzdG9tZXJzLm5ld0l0ZW0ocHJlc2V0RGF0YSkpO1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlcignQWRkIGEgQ2xpZW50Jyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRXh0cmEgcHJlc2V0IGRhdGFcclxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5uZXdGb3JTZWFyY2hUZXh0KSB7XHJcbiAgICAgICAgICAgIGNsaWVudERhdGFGcm9tU2VhcmNoVGV4dCh0aGlzLnJlcXVlc3REYXRhLm5ld0ZvclNlYXJjaFRleHQgfHwgJycsIHRoaXMudmlld01vZGVsLmNsaWVudCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIFNtYWxsIHV0aWxpdHkgdGhhdCBqdXN0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cclxuICAgIHN0cmluZyBzZWVtcyBhIHBvc3NpYmxlIHBob25lIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgTk9URTogSXMgTk9UIGFuIGV4YXVzdGl2ZSBwaG9uZSB2YWxpZGF0aW9uIGNoZWNrLCBqdXN0XHJcbiAgICBjaGVja3MgaXMgdGhlcmUgYXJlIHNldmVyYWwgbnVtYmVycyBzbyB0aGVyZSBpcyBhIGNoYW5jZVxyXG4gICAgdG8gYmUgYSBwaG9uZS4gVGhlcmUgYXJlIHN0cmlja2VyIGNoZWNrcyAoYW5ub3RhdGVkKSBidXRcclxuICAgIGNhbiBmYWlsIG9uIHNvbWUgc2l0dWF0aW9ucyAoc3dpdGNoYm9hcmQgbnVtYmVycykgb3IgaW5cclxuICAgIGRpZmZlcmVudCBsb2NhbGVzLlxyXG4qKi9cclxuZnVuY3Rpb24gc2VlbXNBUGhvbmVOdW1iZXIoc3RyKSB7XHJcbiAgICAvLyBQb3NzaWJsZSBzdHJpY2tlciBjb21wYXJpc2lvblxyXG4gICAgLy8gcmV0dXJuIGlzLm5hbnBQaG9uZShzdHIpIHx8IGlzLmVwcFBob25lKHN0cik7XHJcbiAgICBcclxuICAgIC8vIEp1c3QgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0aHJlZSBjb25zZWN1dGl2ZSBudW1iZXJzLFxyXG4gICAgLy8gdGhlbiAnbWF5JyBiZSBhIHBob25lIG51bWJlciAobWF5IGJlIGFueXRoaW5nIGVsc2UsIGJ1dFxyXG4gICAgLy8gc2luY2Ugc29tZSBzcGVjaWFsIHBob25lIG51bWJlcnMgY2FuIGhhdmUgbGV0dGVycyBvciBzaWducyxcclxuICAgIC8vIHRoaXMgaXMganVzdCBhIHZlcnkgbGF4IGFuZCBjb25zZXJ2YXRpdmUgKHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcykgY2hlY2suXHJcbiAgICByZXR1cm4gKC9cXGR7Myx9LykudGVzdChzdHIgfHwgJycpO1xyXG59XHJcblxyXG4vKipcclxuICAgIFVzZSB0aGUgcHJvdmlkZWQgc2VhcmNoIHRleHQgYXMgdGhlIGluaXRpYWwgdmFsdWVcclxuICAgIGZvcjogbmFtZSwgZW1haWwgb3IgcGhvbmUgKHdoYXQgZml0cyBiZXR0ZXIpXHJcbioqL1xyXG5mdW5jdGlvbiBjbGllbnREYXRhRnJvbVNlYXJjaFRleHQodHh0LCBjbGllbnQpIHtcclxuICAgIGlmIChpcy5lbWFpbCh0eHQpKSB7XHJcbiAgICAgICAgY2xpZW50LmVtYWlsKHR4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzZWVtc0FQaG9uZU51bWJlcih0eHQpKSB7XHJcbiAgICAgICAgY2xpZW50LnBob25lKHR4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaW5rIGlzIHRoZSBmdWxsbmFtZSwgc3BsaXRpbmcgYnkgd2hpdGUgc3BhY2VcclxuICAgICAgICB2YXIgbmFtZVBhcnRzID0gdHh0LnNwbGl0KCcgJywgMik7XHJcbiAgICAgICAgY2xpZW50LmZpcnN0TmFtZShuYW1lUGFydHNbMF0pO1xyXG4gICAgICAgIGlmIChuYW1lUGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBjbGllbnQubGFzdE5hbWUobmFtZVBhcnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gVE9ETyBGb3Igc3BhbmlzaCAob3IgYW55IGxvY2FsZSB3aXRoIHNlY29uZExhc3ROYW1lKVxyXG4gICAgICAgICAgICAvLyBtdXN0IHRyeSB0byBkZXRlY3QgdGhlIHNlY29uZCBsYXN0IG5hbWU/XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcbiAgICAvKmpzaGludCBtYXhzdGF0ZW1lbnRzOjgwICovXHJcbiAgICBcclxuICAgIHRoaXMuY2xpZW50SUQgPSBrby5vYnNlcnZhYmxlKDApO1xyXG4gICAgXHJcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgdGhpcy5jbGllbnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmNsaWVudFZlcnNpb24oKTtcclxuICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gdi52ZXJzaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgLy90aGlzLmNsaWVudCA9IGFwcC5tb2RlbC5jdXN0b21lcnMuY3JlYXRlV2lsZGNhcmRJdGVtKCk7XHJcblxyXG4gICAgdGhpcy5oZWFkZXIgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBhcHAubW9kZWwuY3VzdG9tZXJzLnN0YXRlLmlzTG9hZGluZztcclxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLmN1c3RvbWVycy5zdGF0ZS5pc1N5bmNpbmc7XHJcbiAgICB0aGlzLmlzU2F2aW5nID0gYXBwLm1vZGVsLmN1c3RvbWVycy5zdGF0ZS5pc1NhdmluZztcclxuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgYXBwLm1vZGVsLmN1c3RvbWVycy5zdGF0ZS5pc0xvY2tlZCgpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxldGluZygpXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgdGhpcy5pc1JlYWRPbmx5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcclxuICAgICAgICByZXR1cm4gYyAmJiAhYy5lZGl0YWJsZSgpO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5pc0RlbGV0aW5nID0gYXBwLm1vZGVsLmN1c3RvbWVycy5zdGF0ZS5pc0RlbGV0aW5nO1xyXG5cclxuICAgIHRoaXMud2FzUmVtb3ZlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuaXNOZXcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xyXG4gICAgICAgIHJldHVybiAhYyB8fCAhYy51cGRhdGVkRGF0ZSgpO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5jbGllbnRWZXJzaW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ0xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnU2F2aW5nIGNoYW5nZXMnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc05ldygpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FkZCBjbGllbnQnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiAmJiB2LmFyZURpZmZlcmVudCgpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlIGNoYW5nZXMnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlZCdcclxuICAgICAgICApO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy51bnNhdmVkQ2hhbmdlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuY2xpZW50VmVyc2lvbigpO1xyXG4gICAgICAgIHJldHVybiB2ICYmIHYuYXJlRGlmZmVyZW50KCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5kZWxldGVUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxldGluZygpID8gXHJcbiAgICAgICAgICAgICAgICAnRGVsZXRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICAnRGVsZXRlJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgYXBwLm1vZGVsLmN1c3RvbWVycy5zZXRJdGVtKHRoaXMuY2xpZW50KCkubW9kZWwudG9QbGFpbk9iamVjdCgpKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCBzZXJ2ZXIgZGF0YS5cclxuICAgICAgICAgICAgdGhpcy5jbGllbnQoKS5tb2RlbC51cGRhdGVXaXRoKHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICAvLyBQdXNoIHZlcnNpb24gc28gaXQgYXBwZWFycyBhcyBzYXZlZFxyXG4gICAgICAgICAgICB0aGlzLmNsaWVudFZlcnNpb24oKS5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBzYXZlLCBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgYWN0aXZpdHkgb24gc2V0LXVwXHJcbiAgICAgICAgICAgIHRoaXMub25TYXZlKHNlcnZlckRhdGEuY3VzdG9tZXJVc2VySUQpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHNhdmluZy4nLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuY29uZmlybVJlbW92YWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcHAubW9kYWxzLmNvbmZpcm0oe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0RlbGV0ZSBjbGllbnQnLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXJlIHlvdSBzdXJlPyBUaGUgb3BlcmF0aW9uIGNhbm5vdCBiZSB1bmRvbmUuJyxcclxuICAgICAgICAgICAgeWVzOiAnRGVsZXRlJyxcclxuICAgICAgICAgICAgbm86ICdLZWVwJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBhcHAubW9kZWwuY3VzdG9tZXJzLmRlbEl0ZW0odGhpcy5jbGllbnRJRCgpKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLndhc1JlbW92ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIEdvIG91dCB0aGUgZGVsZXRlZCBsb2NhdGlvblxyXG4gICAgICAgICAgICBhcHAuc2hlbGwuZ29CYWNrKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZGVsZXRpbmcuJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIC8vIEJpcnRoIG1vbnRoIGRheVxyXG4gICAgLy8gVE9ETyBsMTBuXHJcbiAgICB0aGlzLm1vbnRocyA9IGtvLm9ic2VydmFibGVBcnJheShbXHJcbiAgICAgICAgeyBpZDogMSwgbmFtZTogJ0phbnVhcnknfSxcclxuICAgICAgICB7IGlkOiAyLCBuYW1lOiAnRmVicnVhcnknfSxcclxuICAgICAgICB7IGlkOiAzLCBuYW1lOiAnTWFyY2gnfSxcclxuICAgICAgICB7IGlkOiA0LCBuYW1lOiAnQXByaWwnfSxcclxuICAgICAgICB7IGlkOiA1LCBuYW1lOiAnTWF5J30sXHJcbiAgICAgICAgeyBpZDogNiwgbmFtZTogJ0p1bmUnfSxcclxuICAgICAgICB7IGlkOiA3LCBuYW1lOiAnSnVseSd9LFxyXG4gICAgICAgIHsgaWQ6IDgsIG5hbWU6ICdBdWd1c3QnfSxcclxuICAgICAgICB7IGlkOiA5LCBuYW1lOiAnU2VwdGVtYmVyJ30sXHJcbiAgICAgICAgeyBpZDogMTAsIG5hbWU6ICdPY3RvYmVyJ30sXHJcbiAgICAgICAgeyBpZDogMTEsIG5hbWU6ICdOb3ZlbWJlcid9LFxyXG4gICAgICAgIHsgaWQ6IDEyLCBuYW1lOiAnRGVjZW1iZXInfVxyXG4gICAgXSk7XHJcbiAgICAvLyBXZSBuZWVkIHRvIHVzZSBhIHNwZWNpYWwgb2JzZXJ2YWJsZSBpbiB0aGUgZm9ybSwgdGhhdCB3aWxsXHJcbiAgICAvLyB1cGRhdGUgdGhlIGJhY2stZW5kIHByb2ZpbGUuYmlydGhNb250aFxyXG4gICAgdGhpcy5zZWxlY3RlZEJpcnRoTW9udGggPSBrby5jb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcclxuICAgICAgICAgICAgaWYgKGMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaXJ0aE1vbnRoID0gYy5iaXJ0aE1vbnRoKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmlydGhNb250aCA/IHRoaXMubW9udGhzKClbYmlydGhNb250aCAtIDFdIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbihtb250aCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY2xpZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChjKVxyXG4gICAgICAgICAgICAgICAgYy5iaXJ0aE1vbnRoKG1vbnRoICYmIG1vbnRoLmlkIHx8IG51bGwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3duZXI6IHRoaXNcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vbnRoRGF5cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICBmb3IgKHZhciBpZGF5ID0gMTsgaWRheSA8PSAzMTsgaWRheSsrKSB7XHJcbiAgICAgICAgdGhpcy5tb250aERheXMucHVzaChpZGF5KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRXh0cmEgZm9yIGJ1dHRvbiBhZGRvbnNcclxuICAgIHRoaXMudmFsaWRFbWFpbCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuY2xpZW50KCk7XHJcbiAgICAgICAgaWYgKGMpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSBjLmVtYWlsKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpcy5lbWFpbChlKSA/IGUgOiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy52YWxpZFBob25lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcclxuICAgICAgICBpZiAoYykge1xyXG4gICAgICAgICAgICB2YXIgZSA9IGMucGhvbmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNlZW1zQVBob25lTnVtYmVyKGUpID8gZSA6ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgLy8gUHVibGljIFNlYXJjaFxyXG4gICAgXHJcbiAgICB2YXIgZm91bmRQdWJsaWNVc2VyID0gZnVuY3Rpb24gZm91bmRQdWJsaWNVc2VyKHVzZXIpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIHN0aWxsIG1hdGNoZXMgY3VycmVudCB2aWV3IGRhdGFcclxuICAgICAgICB2YXIgYyA9IHRoaXMuY2xpZW50KCk7XHJcbiAgICAgICAgaWYgKCFjKSByZXR1cm47XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRG9uJ3Qgb2ZmZXIgaWYgaXMgYWxyZWFkeSB0aGF0IHVzZXIhXHJcbiAgICAgICAgaWYgKGMuY3VzdG9tZXJVc2VySUQoKSA9PT0gdXNlci5jdXN0b21lclVzZXJJRCkgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE5PVEU6IGF2b2lkaW5nIHVzZSBmdWxsTmFtZSBiZWNhdXNlIGl0IGNhbiBtYWtlIG1vcmUgdGhhbiBvbmUgY29uZmxpY3RpbmdcclxuICAgICAgICAvLyByZXN1bHRzLCBiZWluZyBub3QgZW5vdWdoIHRoZSBuYW1lIHRvIGNvbmZpcm0gdGhlIHVzZXIgKHVzZSB0aGUgc2VhcmNoIGZvciB0aGF0KVxyXG4gICAgICAgIC8vICBjLmZ1bGxOYW1lKCkgPT09IHVzZXIuZnVsbE5hbWUgfHxcclxuICAgICAgICBpZiAoYy5lbWFpbCgpID09PSB1c2VyLmVtYWlsIHx8XHJcbiAgICAgICAgICAgIGMucGhvbmUoKSA9PT0gdXNlci5waG9uZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gTm90aWZ5IHVzZXJcclxuICAgICAgICAgICAgdmFyIG1zZyA9ICdXZWB2ZSBmb3VuZCBhbiBleGlzdGluZyByZWNvcmQgZm9yIHswfS4gV291bGQgeW91IGxpa2UgdG8gYWRkIGhpbSB0byB5b3VyIGNsaWVudHM/Jy5yZXBsYWNlKC9cXHswXFx9L2csIHVzZXIuZmlyc3ROYW1lKTtcclxuICAgICAgICAgICAgYXBwLm1vZGFscy5jb25maXJtKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnQ3VzdG9tZXIgZm91bmQgYXQgbG9jb25vbWljcy5jb20nLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWNlcHRlZFxyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBjdXJyZW50IHVzZXIgZGF0YVxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IGtlZXAgbm90ZXNBYm91dEN1c3RvbWVyXHJcbiAgICAgICAgICAgICAgICB2YXIgbm90ZXMgPSBjLm5vdGVzQWJvdXRDdXN0b21lcigpO1xyXG4gICAgICAgICAgICAgICAgYy5tb2RlbC51cGRhdGVXaXRoKHVzZXIpO1xyXG4gICAgICAgICAgICAgICAgYy5ub3Rlc0Fib3V0Q3VzdG9tZXIobm90ZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRJRCh1c2VyLmN1c3RvbWVyVXNlcklEKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkZWQsIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBXaGVuIGZpbGVyaW5nIGhhcyBubyByZXN1bHRzOlxyXG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xyXG4gICAgICAgIGlmICghYykgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE5PVEU6IGRpc2NhcmRlZCB0aGUgZnVsbE5hbWUgYmVjYXVzZSBzZXZlcmFsIHJlc3VsdHMgY2FuIGJlIHJldHJpZXZlZCxcclxuICAgICAgICAvLyBiZXR0ZXIgdXNlIHRoZSBzZWFyY2ggZm9yIHRoYXQgYW5kIGRvdWJsZSBjaGVjayBlbnRyaWVzXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGVtYWlsID0gYy5lbWFpbCgpLFxyXG4gICAgICAgICAgICAvL2Z1bGxOYW1lID0gYy5mdWxsTmFtZSgpLFxyXG4gICAgICAgICAgICBwaG9uZSA9IGMucGhvbmUoKTtcclxuICAgICAgICBpZiAoIWVtYWlsICYmICFwaG9uZSAvKiFmdWxsTmFtZSAmJiAqLykgcmV0dXJuO1xyXG5cclxuICAgICAgICBhcHAubW9kZWwuY3VzdG9tZXJzLnB1YmxpY1NlYXJjaCh7XHJcbiAgICAgICAgICAgIC8vZnVsbE5hbWU6IGZ1bGxOYW1lLFxyXG4gICAgICAgICAgICBlbWFpbDogZW1haWwsXHJcbiAgICAgICAgICAgIHBob25lOiBwaG9uZVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocikge1xyXG4gICAgICAgICAgICBpZiAociAmJiByWzBdKSBmb3VuZFB1YmxpY1VzZXIoclswXSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXJzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCB0aGlzKVxyXG4gICAgLy8gQXZvaWQgZXhjZXNzaXZlIHJlcXVlc3QgYnkgc2V0dGluZyBhIHRpbWVvdXQgc2luY2UgdGhlIGxhdGVzdCBjaGFuZ2VcclxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgdGltZW91dDogNDAwLCBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnIH0gfSk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBjbGllbnRzIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXHJcbiAgICB0ZXh0U2VhcmNoID0gcmVxdWlyZSgnLi4vdXRpbHMvdGV4dFNlYXJjaCcpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIENsaWVudHNBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdDbGllbnRzJywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnY21zJ1xyXG4gICAgfSk7XHJcbiAgICAvLyBTYXZlIGRlZmF1bHRzIHRvIHJlc3RvcmUgb24gdXBkYXRlTmF2QmFyU3RhdGUgd2hlbiBuZWVkZWQ6XHJcbiAgICB0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uID0gdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLm1vZGVsLnRvUGxhaW5PYmplY3QoKTtcclxuICAgIFxyXG4gICAgLy8gR2V0dGluZyBlbGVtZW50c1xyXG4gICAgdGhpcy4kaW5kZXggPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2xpZW50c0luZGV4Jyk7XHJcbiAgICB0aGlzLiRsaXN0VmlldyA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjbGllbnRzTGlzdFZpZXcnKTtcclxuXHJcbiAgICAvLyBIYW5kbGVyIHRvIGdvIGJhY2sgd2l0aCB0aGUgc2VsZWN0ZWQgY2xpZW50IHdoZW4gXHJcbiAgICAvLyB0aGVyZSBpcyBvbmUgc2VsZWN0ZWQgYW5kIHJlcXVlc3REYXRhIGlzIGZvclxyXG4gICAgLy8gJ3NlbGVjdCBtb2RlJ1xyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRDbGllbnQsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKHRoZVNlbGVjdGVkQ2xpZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSByZXF1ZXN0IGFuZFxyXG4gICAgICAgICAgICAvLyBpdCByZXF1ZXN0ZWQgdG8gc2VsZWN0IGEgY2xpZW50LFxyXG4gICAgICAgICAgICAvLyBhbmQgYSBzZWxlY3RlZCBjbGllbnRcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0Q2xpZW50ID09PSB0cnVlICYmXHJcbiAgICAgICAgICAgICAgICB0aGVTZWxlY3RlZENsaWVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIHNlbGVjdGVkIGNsaWVudCBpbiB0aGUgaW5mb1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZENsaWVudElEID0gdGhlU2VsZWN0ZWRDbGllbnQuY3VzdG9tZXJVc2VySUQoKTtcclxuICAgICAgICAgICAgICAgIC8vIEFuZCBnbyBiYWNrXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyBMYXN0LCBjbGVhciByZXF1ZXN0RGF0YVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLnJldHVyblJlcXVlc3QgPSBmdW5jdGlvbiByZXR1cm5SZXF1ZXN0KCkge1xyXG4gICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xyXG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eTo4XHJcbiAgICBcclxuICAgIHZhciBpdElzID0gdGhpcy52aWV3TW9kZWwuaXNTZWxlY3Rpb25Nb2RlKCk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsLmhlYWRlclRleHQoaXRJcyA/ICdTZWxlY3QgYSBjbGllbnQnIDogJycpO1xyXG5cclxuICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLnRpdGxlKSB7XHJcbiAgICAgICAgLy8gUmVwbGFjZSB0aXRsZSBieSB0aXRsZSBpZiByZXF1aXJlZFxyXG4gICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKHRoaXMucmVxdWVzdERhdGEudGl0bGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVGl0bGUgbXVzdCBiZSBlbXB0eVxyXG4gICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKCcnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKSB7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0VG9DYW5jZWxBY3Rpb24odGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLCB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmspO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gUmVzZXQgdG8gZGVmYXVsdHMsIG9yIGdpdmVuIHRpdGxlOlxyXG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5tb2RlbC51cGRhdGVXaXRoKHRoaXMuZGVmYXVsdExlZnRBY3Rpb24pO1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLm5hdlRpdGxlKVxyXG4gICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCh0aGlzLnJlcXVlc3REYXRhLm5hdlRpdGxlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGl0SXMgJiYgIXRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgIC8vIFVzZXMgYSBjdXN0b20gaGFuZGxlciBzbyBpdCByZXR1cm5zIGtlZXBpbmcgdGhlIGdpdmVuIHN0YXRlOlxyXG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5oYW5kbGVyKHRoaXMucmV0dXJuUmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXRJcykge1xyXG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5oYW5kbGVyKG51bGwpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICAvLyBPbiBldmVyeSBzaG93LCBzZWFyY2ggZ2V0cyByZXNldGVkXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5zZWFyY2hUZXh0KCcnKTtcclxuICAgIHRoaXMudmlld01vZGVsLnNlbGVjdGVkQ2xpZW50KG51bGwpO1xyXG4gICAgdGhpcy52aWV3TW9kZWwucmVxdWVzdERhdGEgPSB0aGlzLnJlcXVlc3REYXRhO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBpdCBjb21lcyBmcm9tIGEgY2xpZW50RWRpdG9yIHRoYXRcclxuICAgIC8vIHJlY2VpdmVkIHRoZSBmbGFnICdyZXR1cm5OZXdBc1NlbGVjdGVkJyBhbmQgYSBcclxuICAgIC8vIGNsaWVudElEOiB3ZSB3ZXJlIGluIHNlbGVjdGlvbiBtb2RlLT5jcmVhdGluZyBjbGllbnQtPm11c3RcclxuICAgIC8vIHJldHVybiB0aGUganVzdCBjcmVhdGVkIGNsaWVudCB0byB0aGUgcHJldmlvdXMgcGFnZVxyXG4gICAgaWYgKHN0YXRlLnJldHVybk5ld0FzU2VsZWN0ZWQgPT09IHRydWUgJiZcclxuICAgICAgICBzdGF0ZS5jbGllbnRJRCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHBlcmZvcm0gYW4gYWN0aXZpdHkgY2hhbmdlIGJ1dCBhbGxvdyB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vIHRvIHN0b3AgZmlyc3RcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUucmV0dXJuTmV3QXNTZWxlY3RlZDtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZENsaWVudElEID0gc3RhdGUuY2xpZW50SUQ7XHJcbiAgICAgICAgICAgIC8vIEFuZCBnbyBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgICAgICB9LmJpbmQodGhpcyksIDEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGF2b2lkIHRoZSByZXN0IG9wZXJhdGlvbnNcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNldCBzZWxlY3Rpb246XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5pc1NlbGVjdGlvbk1vZGUoc3RhdGUuc2VsZWN0Q2xpZW50ID09PSB0cnVlKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XHJcbiAgICBcclxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxyXG4gICAgdGhpcy5hcHAubW9kZWwuY3VzdG9tZXJzLnN5bmMoKVxyXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgdGhlIGNsaWVudHMgbGlzdCcsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcblxyXG4gICAgdGhpcy5oZWFkZXJUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcblxyXG4gICAgLy8gRXNwZWNpYWwgbW9kZSB3aGVuIGluc3RlYWQgb2YgcGljayBhbmQgZWRpdCB3ZSBhcmUganVzdCBzZWxlY3RpbmdcclxuICAgIC8vICh3aGVuIGVkaXRpbmcgYW4gYXBwb2ludG1lbnQpXHJcbiAgICB0aGlzLmlzU2VsZWN0aW9uTW9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG5cclxuICAgIC8vIEZ1bGwgbGlzdCBvZiBjbGllbnRzXHJcbiAgICB0aGlzLmNsaWVudHMgPSBhcHAubW9kZWwuY3VzdG9tZXJzLmxpc3Q7XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5jdXN0b21lcnMuc3RhdGUuaXNMb2FkaW5nO1xyXG4gICAgdGhpcy5pc1N5bmNpbmcgPSBhcHAubW9kZWwuY3VzdG9tZXJzLnN0YXRlLmlzU3luY2luZztcclxuICAgIFxyXG4gICAgLy8gU2VhcmNoIHRleHQsIHVzZWQgdG8gZmlsdGVyICdjbGllbnRzJ1xyXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICBcclxuICAgIC8vIFV0aWxpdHkgdG8gZ2V0IGEgZmlsdGVyZWQgbGlzdCBvZiBjbGllbnRzIGJhc2VkIG9uIGNsaWVudHNcclxuICAgIHRoaXMuZ2V0RmlsdGVyZWRMaXN0ID0gZnVuY3Rpb24gZ2V0RmlsdGVyZWRMaXN0KCkge1xyXG4gICAgICAgIHZhciBzID0gKHRoaXMuc2VhcmNoVGV4dCgpIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIFNlYXJjaCB0aGUgY2xpZW50IGJ5OlxyXG4gICAgICAgIC8vIC0gZnVsbCBuYW1lXHJcbiAgICAgICAgLy8gLSAoZWxzZSkgZW1haWxcclxuICAgICAgICAvLyAtIChlbHNlKSBwaG9uZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudHMoKS5maWx0ZXIoZnVuY3Rpb24oY2xpZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghY2xpZW50KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHRleHRTZWFyY2gocywgY2xpZW50LmZ1bGxOYW1lKCkpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRleHRTZWFyY2gocywgY2xpZW50LmVtYWlsKCkpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRleHRTZWFyY2gocywgY2xpZW50LnBob25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEZpbHRlcmVkIGxpc3Qgb2YgY2xpZW50c1xyXG4gICAgdGhpcy5maWx0ZXJlZENsaWVudHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJlZExpc3QoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBHcm91cGVkIGxpc3Qgb2YgZmlsdGVyZWQgY2xpZW50c1xyXG4gICAgdGhpcy5ncm91cGVkQ2xpZW50cyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIC8vIFNvcnRpbmcgbGlzdCwgaW4gYSBjcm9zcyBicm93c2VyIHdheSAoaW4gRmlyZWZveCwganVzdCBBID4gQiB3b3JrcywgYnV0IG5vdCBvbiB3ZWJraXQvYmxpbmspXHJcbiAgICAgICAgdmFyIGNsaWVudHMgPSB0aGlzLmZpbHRlcmVkQ2xpZW50cygpLnNvcnQoZnVuY3Rpb24oY2xpZW50QSwgY2xpZW50Qikge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGNsaWVudEEuZmlyc3ROYW1lKCkudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgIGIgPSBjbGllbnRCLmZpcnN0TmFtZSgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGEgPiBiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZ3JvdXBzID0gW10sXHJcbiAgICAgICAgICAgIGxhdGVzdEdyb3VwID0gbnVsbCxcclxuICAgICAgICAgICAgbGF0ZXN0TGV0dGVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xyXG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gKGNsaWVudC5maXJzdE5hbWUoKVswXSB8fCAnJykudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKGxldHRlciAhPT0gbGF0ZXN0TGV0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsYXRlc3RHcm91cCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXI6IGxldHRlcixcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRzOiBbY2xpZW50XVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGxhdGVzdEdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGxhdGVzdExldHRlciA9IGxldHRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhdGVzdEdyb3VwLmNsaWVudHMucHVzaChjbGllbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cHM7XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIFxyXG4gICAgLy8vIFB1YmxpYyBzZWFyY2hcclxuICAgIHRoaXMucHVibGljU2VhcmNoUmVzdWx0cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICB0aGlzLnB1YmxpY1NlYXJjaFJ1bm5pbmcgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgLy8gV2hlbiBmaWxlcmluZyBoYXMgbm8gcmVzdWx0czpcclxuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkgeyAgICBcclxuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLmZpbHRlcmVkQ2xpZW50cygpLFxyXG4gICAgICAgICAgICBzZWFyY2hUZXh0ID0gdGhpcy5zZWFyY2hUZXh0KCksXHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBzZWFyY2ggdGV4dCBhbmQgbm8gcmVzdWx0cyBmcm9tIGxvY2FsIGZpbHRlcmluZ1xyXG4gICAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDAgJiYgc2VhcmNoVGV4dCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIHJlc3VsdHNcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNTZWFyY2hSZXN1bHRzKFtdKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBhcHAubW9kZWwuY3VzdG9tZXJzLnB1YmxpY1NlYXJjaCh7XHJcbiAgICAgICAgICAgICAgICBmdWxsTmFtZTogc2VhcmNoVGV4dCxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiBzZWFyY2hUZXh0LFxyXG4gICAgICAgICAgICAgICAgcGhvbmU6IHNlYXJjaFRleHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUnVubmluZyhyZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmVxdWVzdC50aGVuKGZ1bmN0aW9uKHIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUmVzdWx0cyhyKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hlbiBvbiByZW1vdGUgY2xpZW50cyBzZWFyY2gnLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsd2F5czpcclxuICAgICAgICAgICAgICAgIC8vIGlmIHN0aWxsIHRoZSBzYW1lLCBpdCBlbmRlZCB0aGVuIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHVibGljU2VhcmNoUnVubmluZygpID09PSByZXF1ZXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUnVubmluZyhudWxsKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUmVzdWx0cyhbXSk7XHJcbiAgICAgICAgICAgIC8vIENhbmNlbGxpbmcgYW55IHBlbmRpbmcgcmVxdWVzdCwgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gYW53YW50ZWQgcmVzdWx0cyB3aGVuIGZpbmlzaFxyXG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5wdWJsaWNTZWFyY2hSdW5uaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ICYmXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnhociAmJlxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC54aHIuYWJvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QueGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY1NlYXJjaFJ1bm5pbmcobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKVxyXG4gICAgLy8gQXZvaWQgZXhjZXNzaXZlIHJlcXVlc3QgYnkgc2V0dGluZyBhIHRpbWVvdXQgc2luY2UgdGhlIGxhdGVzdCBjaGFuZ2VcclxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgdGltZW91dDogNDAwLCBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnIH0gfSk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEFkZCBhIGNsaWVudCBmcm9tIHRoZSBwdWJsaWMvcmVtb3RlIHNlYXJjaCByZXN1bHRzXHJcbiAgICAqKi9cclxuICAgIHRoaXMuYWRkUmVtb3RlQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50LCBldmVudCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gY2xpZW50Lm1vZGVsICYmIGNsaWVudC5tb2RlbC50b1BsYWluT2JqZWN0KCkgfHwgY2xpZW50O1xyXG4gICAgICAgIHZhciByZXF1ZXN0ID0gJC5leHRlbmQoe30sIHRoaXMucmVxdWVzdERhdGEsIHtcclxuICAgICAgICAgICAgcHJlc2V0RGF0YTogZGF0YSxcclxuICAgICAgICAgICAgcmV0dXJuTmV3QXNTZWxlY3RlZDogdGhpcy5pc1NlbGVjdGlvbk1vZGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFwcC5zaGVsbC5nbygnY2xpZW50RWRpdG9yJywgcmVxdWVzdCk7XHJcblxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIENhbGwgdGhlIGFjdGl2aXR5IHRvIGFkZCBhIG5ldyBjbGllbnQsIHBhc3NpbmcgdGhlIGN1cnJlbnRcclxuICAgICAgICBzZWFyY2ggdGV4dCBzbyBjYW4gYmUgdXNlZCBhcyBpbml0aWFsIG5hbWUvZW1haWwvcGhvbmVcclxuICAgICoqL1xyXG4gICAgdGhpcy5hZGROZXcgPSBmdW5jdGlvbihkYXRhLCBldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAkLmV4dGVuZCh7fSwgdGhpcy5yZXF1ZXN0RGF0YSwge1xyXG4gICAgICAgICAgICBuZXdGb3JTZWFyY2hUZXh0OiB0aGlzLnNlYXJjaFRleHQoKSxcclxuICAgICAgICAgICAgcmV0dXJuTmV3QXNTZWxlY3RlZDogdGhpcy5pc1NlbGVjdGlvbk1vZGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFwcC5zaGVsbC5nbygnY2xpZW50RWRpdG9yJywgcmVxdWVzdCk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgLy8vIFNlbGVjdGlvbnNcclxuICAgIFxyXG4gICAgdGhpcy5zZWxlY3RlZENsaWVudCA9IGtvLm9ic2VydmFibGUobnVsbCk7XHJcbiAgICBcclxuICAgIHRoaXMuc2VsZWN0Q2xpZW50ID0gZnVuY3Rpb24oc2VsZWN0ZWRDbGllbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENsaWVudChzZWxlY3RlZENsaWVudCk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBDTVMgYWN0aXZpdHlcclxuICAgIChDbGllbnQgTWFuYWdlbWVudCBTeXN0ZW0pXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ21zQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICBcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIoJ0NsaWVudCBtYW5hZ2VtZW50Jyk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG5cclxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxyXG4gICAgdGhpcy5hcHAubW9kZWwuY3VzdG9tZXJzLnN5bmMoKVxyXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgdGhlIGNsaWVudHMgbGlzdCcsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG52YXIgbnVtZXJhbCA9IHJlcXVpcmUoJ251bWVyYWwnKTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuICAgIFxyXG4gICAgdGhpcy5jbGllbnRzID0gYXBwLm1vZGVsLmN1c3RvbWVycy5saXN0O1xyXG5cclxuICAgIHRoaXMuY2xpZW50c0NvdW50ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjcyA9IHRoaXMuY2xpZW50cygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjcyA8PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gJzAgY2xpZW50cyc7XHJcbiAgICAgICAgZWxzZSBpZiAoY3MgPT09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiAnMSBjbGllbnQnO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwoY3MubGVuZ3RoIHwwKS5mb3JtYXQoJzAsMCcpICsgJyBjbGllbnRzJztcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgQ29udGFjdEZvcm0gYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcclxuICAgIFZvY0VsZW1lbnRFbnVtID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ZvY0VsZW1lbnRFbnVtJyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ29udGFjdEZvcm1BY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIFxyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIFxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICBcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignVGFsayB0byB1cycpO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucmVxdWVzdERhdGEucm91dGUuc2VnbWVudHMgfHwgW107XHJcbiAgICB2YXIgZWxlbWVudE5hbWUgPSBwYXJhbXNbMF0gfHwgJycsXHJcbiAgICAgICAgZWxlbWVudElEID0gVm9jRWxlbWVudEVudW1bZWxlbWVudE5hbWVdIHwwO1xyXG4gICAgXHJcbiAgICBpZiAoIWVsZW1lbnROYW1lKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0ZlZWRiYWNrIFN1cHBvcnQ6IEFjY2Vzc2luZyB3aXRob3V0IHNwZWNpZnkgYW4gZWxlbWVudCwgdXNpbmcgR2VuZXJhbCAoMCknKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFWb2NFbGVtZW50RW51bS5oYXNPd25Qcm9wZXJ0eShlbGVtZW50TmFtZSkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGZWVkYmFjayBTdXBwb3J0OiBnaXZlbiBhIGJhZCBWT0MgRWxlbWVudCBuYW1lOicsIGVsZW1lbnROYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnZpZXdNb2RlbC52b2NFbGVtZW50SUQoZWxlbWVudElEKTtcclxufTtcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuICAgIFxyXG4gICAgdGhpcy5tZXNzYWdlID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICB0aGlzLndhc1NlbnQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuaXNTZW5kaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICB0aGlzLnZvY0VsZW1lbnRJRCA9IGtvLm9ic2VydmFibGUoMCk7XHJcblxyXG4gICAgdmFyIHVwZGF0ZVdhc1NlbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLndhc1NlbnQoZmFsc2UpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5tZXNzYWdlLnN1YnNjcmliZSh1cGRhdGVXYXNTZW50KTtcclxuICAgIFxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzU2VuZGluZygpID8gJ1NlbmRpbmcuLicgOiB0aGlzLndhc1NlbnQoKSA/ICdTZW50JyA6ICdTZW5kJztcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiBzZW5kKCkge1xyXG4gICAgICAgIHRoaXMuaXNTZW5kaW5nKHRydWUpO1xyXG4gICAgICAgIGFwcC5tb2RlbC5mZWVkYmFjay5wb3N0U3VwcG9ydCh7XHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSgpLFxyXG4gICAgICAgICAgICB2b2NFbGVtZW50SUQ6IHRoaXMudm9jRWxlbWVudElEKClcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBhZnRlciBiZWluZyBzZW50XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSgnJyk7XHJcbiAgICAgICAgICAgIHRoaXMud2FzU2VudCh0cnVlKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciBzZW5kaW5nIHlvdXIgZmVlZGJhY2snLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBBbHdheXNcclxuICAgICAgICAgICAgdGhpcy5pc1NlbmRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBDb250YWN0SW5mbyBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIENvbnRhY3RJbmZvQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ093bmVyIGluZm9ybWF0aW9uJywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnb3duZXJJbmZvJ1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmRlZmF1bHROYXZCYXIgPSB0aGlzLm5hdkJhci5tb2RlbC50b1BsYWluT2JqZWN0KCk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLnVzZXJQcm9maWxlLFxyXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgY29udGFjdCBkYXRhLicgOiAnRXJyb3IgbG9hZGluZyBjb250YWN0IGRhdGEuJztcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLmhvbWVBZGRyZXNzLFxyXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgYWRkcmVzcyBkZXRhaWxzLicgOiAnRXJyb3IgbG9hZGluZyBhZGRyZXNzIGRldGFpbHMuJztcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIE9uIGNoYW5nZSB0byBhIHZhbGlkIGNvZGUsIGRvIHJlbW90ZSBsb29rLXVwXHJcbiAgICAvLyBOT1RFOiB1c2luZyBkaXJlY3RseSBhIGNvbXB1dGVkIHJhdGhlciB0aGFuIHRoZSByZWdpc3RlckhhbmRsZXIgdG8gdXNlXHJcbiAgICAvLyB0aGUgcmF0ZUxpbWl0IGV4dGVuZGVyIHRoYXQgYXZvaWRzIGV4Y2VzaXZlIHJlcXVlc3QgYmVpbmcgcGVyZm9ybWVkIG9uIGNoYW5nZXMuXHJcbiAgICAvLyBOT1RFOiB0aGUgY29kZSBpbnNpZGUgdGhlIGhhbmRsZXIgaXMgbW9zdGx5IHRoZSBzYW1lIGFzIGluIGFkZHJlc3NFZGl0b3IgZm9yIHRoZSBzYW1lIGxvb2stdXAuXHJcbiAgICB2YXIgYXBwID0gdGhpcy5hcHAsXHJcbiAgICAgICAgdmlld01vZGVsID0gdGhpcy52aWV3TW9kZWw7XHJcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcG9zdGFsQ29kZSA9IHRoaXMucG9zdGFsQ29kZSgpLFxyXG4gICAgICAgICAgICBhZGRyZXNzID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKHBvc3RhbENvZGUgJiYgIS9eXFxzKiQvLnRlc3QocG9zdGFsQ29kZSkpIHtcclxuICAgICAgICAgICAgYXBwLm1vZGVsLnBvc3RhbENvZGVzLmdldEl0ZW0ocG9zdGFsQ29kZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmNpdHkoaW5mby5jaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VDb2RlKGluZm8uc3RhdGVQcm92aW5jZUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoaW5mby5zdGF0ZVByb3ZpbmNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmVycm9yTWVzc2FnZXMucG9zdGFsQ29kZSgnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3MuY2l0eSgnJyk7XHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VDb2RlKCcnKTtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoJycpO1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0ZWQgZXJyb3JzLCBhIHNpbmdsZSBtZXNzYWdlLCBzZXRcclxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBvYnNlcnZhYmxlXHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gdHlwZW9mKGVycikgPT09ICdzdHJpbmcnID8gZXJyIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChtc2cgfHwgZXJyICYmIGVyci5yZXNwb25zZUpTT04gJiYgZXJyLnJlc3BvbnNlSlNPTi5lcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwuZXJyb3JNZXNzYWdlcy5wb3N0YWxDb2RlKG1zZyB8fCBlcnIucmVzcG9uc2VKU09OLmVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgdG8gY29uc29sZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLCBvbiByZWd1bGFyIHVzZSBhbiBlcnJvciBvbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3N0YWwgY29kZSBpcyBub3QgY3JpdGljYWwgYW5kIGNhbiBiZSB0cmFuc3BhcmVudDsgaWYgdGhlcmUgYXJlIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpdml0eSBvciBhdXRoZW50aWZpY2F0aW9uIGVycm9ycyB3aWxsIHRocm93IG9uIHNhdmluZyB0aGUgYWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZlciBlcnJvciB2YWxpZGF0aW5nIFppcCBDb2RlJywgZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcy52aWV3TW9kZWwuYWRkcmVzcylcclxuICAgIC8vIEF2b2lkIGV4Y2Vzc2l2ZSByZXF1ZXN0cyBieSBzZXR0aW5nIGEgdGltZW91dCBzaW5jZSB0aGUgbGF0ZXN0IGNoYW5nZVxyXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyB0aW1lb3V0OiAyMDAsIG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcgfSB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuYXBwLm1vZGVsLm9uYm9hcmRpbmcudXBkYXRlTmF2QmFyKHRoaXMubmF2QmFyKSkge1xyXG4gICAgICAgIC8vIFJlc2V0XHJcbiAgICAgICAgdGhpcy5uYXZCYXIubW9kZWwudXBkYXRlV2l0aCh0aGlzLmRlZmF1bHROYXZCYXIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICAvLyBEaXNjYXJkIGFueSBwcmV2aW91cyB1bnNhdmVkIGVkaXRcclxuICAgIHRoaXMudmlld01vZGVsLmRpc2NhcmQoKTtcclxuICAgIFxyXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xyXG4gICAgXHJcbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcclxuICAgIHRoaXMuYXBwLm1vZGVsLnVzZXJQcm9maWxlLnN5bmMoKTtcclxuICAgIHRoaXMuYXBwLm1vZGVsLmhvbWVBZGRyZXNzLnN5bmMoKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuXHJcbiAgICB0aGlzLmhlYWRlclRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSA/XHJcbiAgICAgICAgICAgICdIb3cgY2FuIHdlIHJlYWNoIHlvdT8nIDpcclxuICAgICAgICAgICAgJ0NvbnRhY3QgaW5mb3JtYXRpb24nO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIExpc3Qgb2YgcG9zc2libGUgZXJyb3IgbWVzc2FnZXMgcmVnaXN0ZXJlZFxyXG4gICAgLy8gYnkgbmFtZVxyXG4gICAgdGhpcy5lcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgICAgIHBvc3RhbENvZGU6IGtvLm9ic2VydmFibGUoJycpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBVc2VyIFByb2ZpbGVcclxuICAgIHZhciB1c2VyUHJvZmlsZSA9IGFwcC5tb2RlbC51c2VyUHJvZmlsZTtcclxuICAgIHZhciBwcm9maWxlVmVyc2lvbiA9IHVzZXJQcm9maWxlLm5ld1ZlcnNpb24oKTtcclxuICAgIHByb2ZpbGVWZXJzaW9uLmlzT2Jzb2xldGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGl0SXMpIHtcclxuICAgICAgICBpZiAoaXRJcykge1xyXG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXHJcbiAgICAgICAgICAgIC8vIEZVVFVSRTogd2FybiBhYm91dCBhIG5ldyByZW1vdGUgdmVyc2lvbiBhc2tpbmdcclxuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcclxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcclxuICAgICAgICAgICAgLy8gd2l0aCBhIDUwOTpDb25mbGljdCBzdGF0dXMgKGl0cyBib2R5IG11c3QgY29udGFpbiB0aGVcclxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxyXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbW90ZSBvbmVzOlxyXG4gICAgICAgICAgICBwcm9maWxlVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEFjdHVhbCBkYXRhIGZvciB0aGUgZm9ybTpcclxuICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGVWZXJzaW9uLnZlcnNpb247XHJcbiAgICBcclxuICAgIC8vIFRPRE8gbDEwblxyXG4gICAgdGhpcy5tb250aHMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW1xyXG4gICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdKYW51YXJ5J30sXHJcbiAgICAgICAgeyBpZDogMiwgbmFtZTogJ0ZlYnJ1YXJ5J30sXHJcbiAgICAgICAgeyBpZDogMywgbmFtZTogJ01hcmNoJ30sXHJcbiAgICAgICAgeyBpZDogNCwgbmFtZTogJ0FwcmlsJ30sXHJcbiAgICAgICAgeyBpZDogNSwgbmFtZTogJ01heSd9LFxyXG4gICAgICAgIHsgaWQ6IDYsIG5hbWU6ICdKdW5lJ30sXHJcbiAgICAgICAgeyBpZDogNywgbmFtZTogJ0p1bHknfSxcclxuICAgICAgICB7IGlkOiA4LCBuYW1lOiAnQXVndXN0J30sXHJcbiAgICAgICAgeyBpZDogOSwgbmFtZTogJ1NlcHRlbWJlcid9LFxyXG4gICAgICAgIHsgaWQ6IDEwLCBuYW1lOiAnT2N0b2Jlcid9LFxyXG4gICAgICAgIHsgaWQ6IDExLCBuYW1lOiAnTm92ZW1iZXInfSxcclxuICAgICAgICB7IGlkOiAxMiwgbmFtZTogJ0RlY2VtYmVyJ31cclxuICAgIF0pO1xyXG4gICAgLy8gV2UgbmVlZCB0byB1c2UgYSBzcGVjaWFsIG9ic2VydmFibGUgaW4gdGhlIGZvcm0sIHRoYXQgd2lsbFxyXG4gICAgLy8gdXBkYXRlIHRoZSBiYWNrLWVuZCBwcm9maWxlLmJpcnRoTW9udGhcclxuICAgIHRoaXMuc2VsZWN0ZWRCaXJ0aE1vbnRoID0ga28uY29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYmlydGhNb250aCA9IHRoaXMucHJvZmlsZS5iaXJ0aE1vbnRoKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBiaXJ0aE1vbnRoID8gdGhpcy5tb250aHMoKVtiaXJ0aE1vbnRoIC0gMV0gOiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKG1vbnRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZmlsZS5iaXJ0aE1vbnRoKG1vbnRoICYmIG1vbnRoLmlkIHx8IG51bGwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3duZXI6IHRoaXNcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vbnRoRGF5cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICBmb3IgKHZhciBpZGF5ID0gMTsgaWRheSA8PSAzMTsgaWRheSsrKSB7XHJcbiAgICAgICAgdGhpcy5tb250aERheXMucHVzaChpZGF5KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSG9tZSBBZGRyZXNzXHJcbiAgICB2YXIgaG9tZUFkZHJlc3MgPSBhcHAubW9kZWwuaG9tZUFkZHJlc3M7XHJcbiAgICB2YXIgaG9tZUFkZHJlc3NWZXJzaW9uID0gaG9tZUFkZHJlc3MubmV3VmVyc2lvbigpO1xyXG4gICAgaG9tZUFkZHJlc3NWZXJzaW9uLmlzT2Jzb2xldGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGl0SXMpIHtcclxuICAgICAgICBpZiAoaXRJcykge1xyXG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXHJcbiAgICAgICAgICAgIC8vIEZVVFVSRTogd2FybiBhYm91dCBhIG5ldyByZW1vdGUgdmVyc2lvbiBhc2tpbmdcclxuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcclxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcclxuICAgICAgICAgICAgLy8gd2l0aCBhIDUwOTpDb25mbGljdCBzdGF0dXMgKGl0cyBib2R5IG11c3QgY29udGFpbiB0aGVcclxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxyXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbW90ZSBvbmVzOlxyXG4gICAgICAgICAgICBob21lQWRkcmVzc1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XHJcbiAgICB0aGlzLmFkZHJlc3MgPSBob21lQWRkcmVzc1ZlcnNpb24udmVyc2lvbjtcclxuXHJcbiAgICAvLyBDb250cm9sIG9ic2VydmFibGVzOiBzcGVjaWFsIGJlY2F1c2UgbXVzdCBhIG1peFxyXG4gICAgLy8gb2YgdGhlIGJvdGggcmVtb3RlIG1vZGVscyB1c2VkIGluIHRoaXMgdmlld21vZGVsXHJcbiAgICB0aGlzLmlzTG9ja2VkID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLmlzTG9ja2VkKCkgfHwgaG9tZUFkZHJlc3MuaXNMb2NrZWQoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUuaXNMb2FkaW5nKCkgfHwgaG9tZUFkZHJlc3MuaXNMb2FkaW5nKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUuaXNTYXZpbmcoKSB8fCBob21lQWRkcmVzcy5pc1NhdmluZygpO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSA/XHJcbiAgICAgICAgICAgICAgICAnU2F2ZSBhbmQgY29udGludWUnIDpcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnc2F2aW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICdTYXZlJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgLy8gQWN0aW9uc1xyXG5cclxuICAgIHRoaXMuZGlzY2FyZCA9IGZ1bmN0aW9uIGRpc2NhcmQoKSB7XHJcbiAgICAgICAgcHJvZmlsZVZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgICAgIGhvbWVBZGRyZXNzVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIHByb2ZpbGVWZXJzaW9uLnB1c2hTYXZlKCksXHJcbiAgICAgICAgICAgIGhvbWVBZGRyZXNzVmVyc2lvbi5wdXNoU2F2ZSgpXHJcbiAgICAgICAgXSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSkge1xyXG4gICAgICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuZ29OZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcHAuc3VjY2Vzc1NhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgQ29udmVyc2F0aW9uIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ29udmVyc2F0aW9uQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICBcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0luYm94Jywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnaW5ib3gnXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcblxyXG4gICAgLy8gUmVzZXRcclxuICAgIHRoaXMudmlld01vZGVsLnRocmVhZElEKDApO1xyXG4gICAgdGhpcy52aWV3TW9kZWwudGhyZWFkKG51bGwpO1xyXG5cclxuICAgIC8vIFBhcmFtc1xyXG4gICAgdmFyIHBhcmFtcyA9IHN0YXRlICYmIHN0YXRlLnJvdXRlICYmIHN0YXRlLnJvdXRlLnNlZ21lbnRzIHx8IFtdLFxyXG4gICAgICAgIHRocmVhZElEID0gcGFyYW1zWzBdIHwwO1xyXG5cclxuICAgIHRoaXMudmlld01vZGVsLnRocmVhZElEKHRocmVhZElEKTtcclxuICAgIFxyXG4gICAgLy8gTG9hZCB0aGUgZGF0YVxyXG4gICAgaWYgKHRocmVhZElEKSB7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwudGhyZWFkLnN5bmModGhyZWFkSUQpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgbG9hZGluZyBjb252ZXJzYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0NvbnZlcnNhdGlvbiBOb3QgRm91bmQnXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcblxyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBhcHAubW9kZWwubWVzc2FnaW5nLnN0YXRlLmlzTG9hZGluZztcclxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5zdGF0ZS5pc1N5bmNpbmc7XHJcbiAgICB0aGlzLmlzU2F2aW5nID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5zdGF0ZS5pc1NhdmluZztcclxuXHJcbiAgICB0aGlzLnRocmVhZElEID0ga28ub2JzZXJ2YWJsZShudWxsKTtcclxuICAgIHRoaXMudGhyZWFkID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5jcmVhdGVXaWxkY2FyZEl0ZW0oKTtcclxuXHJcbiAgICB0aGlzLnN1YmplY3QgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRocmVhZCgpO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgP1xyXG4gICAgICAgICAgICAgICAgJ0xvYWRpbmcuLi4nIDpcclxuICAgICAgICAgICAgICAgIG0gJiYgKG0uc3ViamVjdCgpIHx8ICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykgfHwgJ0NvbnZlcnNhdGlvbiB3aXRob3V0IHN1YmplY3QnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBJZiB0aGUgbGFzdCBtZXNzYWdlIHJlZmVyZW5jZSBhIGJvb2tpbmcsIGlzXHJcbiAgICAvLyBhY2Nlc3NlZCB3aXRoOlxyXG4gICAgdGhpcy5ib29raW5nSUQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IHRoaXMudGhyZWFkKCkgJiYgdGhpcy50aHJlYWQoKS5tZXNzYWdlcygpWzBdO1xyXG4gICAgICAgIGlmIChtc2cgJiZcclxuICAgICAgICAgICAgKG1zZy5hdXhUKCkgfHwgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdib29raW5nJyAmJlxyXG4gICAgICAgICAgICBtc2cuYXV4SUQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbXNnLmF1eElEKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG4iLCIvKipcclxuICAgIGRhdGV0aW1lUGlja2VyIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgVGltZSA9IHJlcXVpcmUoJy4uL3V0aWxzL1RpbWUnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAgZ2V0RGF0ZVdpdGhvdXRUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0RGF0ZVdpdGhvdXRUaW1lJyk7XHJcblxyXG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL0RhdGVQaWNrZXInKTtcclxudmFyIGRhdGVwaWNrZXJBdmFpbGFiaWxpdHkgPSByZXF1aXJlKCcuLi91dGlscy9kYXRlcGlja2VyQXZhaWxhYmlsaXR5Jyk7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gRGF0ZXRpbWVQaWNrZXJBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCcnLCB7XHJcbiAgICAgICAgaGVscElkOiAnZGF0ZXRpbWVQaWNrZXJIZWxwJ1xyXG4gICAgfSk7XHJcbiAgICAvLyBTYXZlIGRlZmF1bHRzIHRvIHJlc3RvcmUgb24gdXBkYXRlTmF2QmFyU3RhdGUgd2hlbiBuZWVkZWQ6XHJcbiAgICB0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uID0gdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLm1vZGVsLnRvUGxhaW5PYmplY3QoKTtcclxuICAgIFxyXG4gICAgLy8gR2V0dGluZyBlbGVtZW50c1xyXG4gICAgdGhpcy4kZGF0ZVBpY2tlciA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNkYXRldGltZVBpY2tlckRhdGVQaWNrZXInKTtcclxuICAgIHRoaXMuJHRpbWVQaWNrZXIgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjZGF0ZXRpbWVQaWNrZXJUaW1lUGlja2VyJyk7XHJcbiAgICBcclxuXHJcbiAgICAvKiBJbml0IGNvbXBvbmVudHMgKi9cclxuICAgIHRoaXMuJGRhdGVQaWNrZXIuc2hvdygpLmRhdGVwaWNrZXIoeyBleHRyYUNsYXNzZXM6ICdEYXRlUGlja2VyLS10YWdnZWQnIH0pO1xyXG4gICAgdGhpcy50YWdBdmFpbGFiaWxpdHkgPSBkYXRlcGlja2VyQXZhaWxhYmlsaXR5LmNyZWF0ZSh0aGlzLmFwcCwgdGhpcy4kZGF0ZVBpY2tlciwgdGhpcy52aWV3TW9kZWwuaXNMb2FkaW5nKTtcclxuICAgIFxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy4kZGF0ZVBpY2tlcixcclxuICAgICAgICBldmVudDogJ2RhdGVDaGFuZ2VkJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLnZpZXdNb2RlID09PSAnZGF5cycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnNlbGVjdGVkRGF0ZShlLmRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWREYXRlLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kRGF0ZURhdGEoZGF0ZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gUmV0dXJuIHRoZSBzZWxlY3RlZCBkYXRlLXRpbWVcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLnNlbGVjdGVkRGF0ZXRpbWUsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGRhdGV0aW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghZGF0ZXRpbWUpIHJldHVybjtcclxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgc2VsZWN0ZWQgZGF0ZXRpbWUgaW4gdGhlIGluZm9cclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZERhdGV0aW1lID0gZGF0ZXRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lID0gdGhpcy52aWV3TW9kZWwuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKCk7XHJcbiAgICAgICAgICAgIC8vIEFuZCBnbyBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gICAgXHJcbi8vICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuLy8gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwucGlja2VkVGltZSxcclxuLy8gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKHQpIHtcclxuLy8gICAgICAgICAgICBpZiAodCkge1xyXG4vLyAgICAgICAgICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgRGF0ZSkpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGRhdGUtdGltZVxyXG4vLyAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzcGFuID0gbW9tZW50LmR1cmF0aW9uKHQpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgdCA9IG1vbWVudCh0aGlzLnNlbGVjdGVkRGF0ZSgpKS5zdGFydE9mKCdkYXknKS5hZGQodGltZXNwYW4pLnRvRGF0ZSgpO1xyXG4vLyAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKHRydWUpO1xyXG4vLyAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXRpbWUodCk7XHJcbi8vICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgfS5iaW5kKHRoaXMudmlld01vZGVsKVxyXG4vLyAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5yZXR1cm5SZXF1ZXN0ID0gZnVuY3Rpb24gcmV0dXJuUmVxdWVzdCgpIHtcclxuICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIC8vIEZpcnN0IGxvYWQgb2YgdG9kYXkgZGF0YVxyXG4gICAgdGhpcy5iaW5kRGF0ZURhdGEodGhpcy52aWV3TW9kZWwuc2VsZWN0ZWREYXRlKCkpXHJcbiAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBPbmNlIGZpbmlzaGVkLCBsb2FkIHRoZSB3aG9sZSBtb250aFxyXG4gICAgICAgIHRoaXMudGFnQXZhaWxhYmlsaXR5KHRoaXMudmlld01vZGVsLnNlbGVjdGVkRGF0ZSgpKTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUudXBkYXRlTmF2QmFyU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVOYXZCYXJTdGF0ZSgpIHtcclxuICAgIFxyXG4gICAgdmFyIGhlYWRlciA9IHRoaXMucmVxdWVzdERhdGEuaGVhZGVyVGV4dDtcclxuICAgIHRoaXMudmlld01vZGVsLmhlYWRlclRleHQoaGVhZGVyIHx8ICdTZWxlY3QgZGF0ZSBhbmQgdGltZScpO1xyXG5cclxuICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLnRpdGxlKSB7XHJcbiAgICAgICAgLy8gUmVwbGFjZSB0aXRsZVxyXG4gICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKHRoaXMucmVxdWVzdERhdGEudGl0bGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVGl0bGUgbXVzdCBiZSBlbXB0eVxyXG4gICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKCcnKTtcclxuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCh0aGlzLnJlcXVlc3REYXRhLm5hdlRpdGxlIHx8ICcnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFJlc2V0IHRvIGRlZmF1bHRzLCBvciBnaXZlbiB0aXRsZTpcclxuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkubW9kZWwudXBkYXRlV2l0aCh0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uKTtcclxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5uYXZUaXRsZSlcclxuICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLnRleHQodGhpcy5yZXF1ZXN0RGF0YS5uYXZUaXRsZSk7XHJcbiAgICAgICAgLy8gVXNlcyBhIGN1c3RvbSBoYW5kbGVyIHNvIGl0IHJldHVybnMga2VlcGluZyB0aGUgZ2l2ZW4gc3RhdGU6XHJcbiAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLmhhbmRsZXIodGhpcy5yZXR1cm5SZXF1ZXN0KTtcclxuICAgIH1cclxufTtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XHJcbiAgICAvLyBSZXNldFxyXG4gICAgdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWREYXRldGltZShudWxsKTtcclxuICAgIHRoaXMudmlld01vZGVsLnBpY2tlZFRpbWUobnVsbCk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUoZmFsc2UpO1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcclxuICAgIFxyXG4gICAgLy8gUGFyYW1ldGVyczogcGFzcyBhIHJlcXVpcmVkIGR1cmF0aW9uXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXF1aXJlZER1cmF0aW9uKHRoaXMucmVxdWVzdERhdGEucmVxdWlyZWREdXJhdGlvbiB8MCk7XHJcblxyXG4gICAgLy8gUHJlc2VsZWN0IGEgZGF0ZSwgb3IgY3VycmVudCBkYXRlXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5zZWxlY3RlZERhdGUoZ2V0RGF0ZVdpdGhvdXRUaW1lKHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWREYXRldGltZSkpO1xyXG4gICAgdGhpcy4kZGF0ZVBpY2tlci5kYXRlcGlja2VyKCdzZXRWYWx1ZScsIHRoaXMudmlld01vZGVsLnNlbGVjdGVkRGF0ZSgpLCB0cnVlKTtcclxuICAgIFxyXG4gICAgaWYgKCF0aGlzLl9fZmlyc3RTaG93RG9uZSkge1xyXG4gICAgICAgIHRoaXMuX19maXJzdFNob3dEb25lID0gdHJ1ZTtcclxuICAgICAgICAvLyBGb3JjZSBmaXJzdCByZWZyZXNoIG9uIGRhdGVwaWNrZXIgdG8gYWxsb3dcclxuICAgICAgICAvLyBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgb24gZmlyc3QgdGltZTpcclxuICAgICAgICB0aGlzLiRkYXRlUGlja2VyLmRhdGVwaWNrZXIoJ2ZpbGwnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xyXG59O1xyXG5cclxuQS5wcm90b3R5cGUuYmluZERhdGVEYXRhID0gZnVuY3Rpb24gYmluZERhdGVEYXRhKGRhdGUpIHtcclxuXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5hcHAubW9kZWwuY2FsZW5kYXIuZ2V0RGF0ZUF2YWlsYWJpbGl0eShkYXRlKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmRhdGVBdmFpbChkYXRhKTtcclxuICAgICAgICBcclxuICAgICAgICAvKnZhciBzZGF0ZSA9IG1vbWVudChkYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5zbG90cyhkYXRhLnNsb3RzLm1hcChmdW5jdGlvbihzbG90KSB7XHJcbiAgICAgICAgICAgIC8vIEZyb20gc3RyaW5nIHRvIERhdGVcclxuICAgICAgICAgICAgdmFyIGRhdGVzbG90ID0gbmV3IERhdGUoc2RhdGUgKyAnVCcgKyBzbG90KTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVzbG90O1xyXG4gICAgICAgIH0pKTsqL1xyXG4gICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgYXZhaWxhYmlsaXR5JyxcclxuICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gRmluYWxseVxyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHRoaXMuaGVhZGVyVGV4dCA9IGtvLm9ic2VydmFibGUoJ1NlbGVjdCBhIHRpbWUnKTtcclxuICAgIHRoaXMuc2VsZWN0ZWREYXRlID0ga28ub2JzZXJ2YWJsZShnZXREYXRlV2l0aG91dFRpbWUoKSk7XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy5yZXF1aXJlZER1cmF0aW9uID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIFxyXG4gICAgdGhpcy5kdXJhdGlvbkRpc3BsYXkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGZ1bGxNaW51dGVzID0gdGhpcy5yZXF1aXJlZER1cmF0aW9uKCk7XHJcbiAgICAgICAgaWYgKGZ1bGxNaW51dGVzIDw9IDApXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuXHJcbiAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihmdWxsTWludXRlcyAvIDYwKSxcclxuICAgICAgICAgICAgbWludXRlcyA9IGZ1bGxNaW51dGVzICUgNjAsXHJcbiAgICAgICAgICAgIHRleHQgPSAnJztcclxuXHJcbiAgICAgICAgaWYgKGhvdXJzID4gMClcclxuICAgICAgICAgICAgdGV4dCArPSBtb21lbnQuZHVyYXRpb24oeyBob3VyczogaG91cnMgfSkuaHVtYW5pemUoKSArICcgJztcclxuICAgICAgICBpZiAobWludXRlcyA+IDApXHJcbiAgICAgICAgICAgIHRleHQgKz0gbW9tZW50LmR1cmF0aW9uKHsgbWludXRlczogbWludXRlcyB9KS5odW1hbml6ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuZGF0ZUF2YWlsID0ga28ub2JzZXJ2YWJsZSgpO1xyXG4gICAgdGhpcy5ncm91cGVkU2xvdHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXF1aXJlZER1cmF0aW9uID0gdGhpcy5yZXF1aXJlZER1cmF0aW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLypcclxuICAgICAgICAgIGJlZm9yZSAxMjowMHBtIChub29uKSA9IG1vcm5pbmdcclxuICAgICAgICAgIGFmdGVybm9vbjogMTI6MDBwbSB1bnRpbCA1OjAwcG1cclxuICAgICAgICAgIGV2ZW5pbmc6IDU6MDBwbSAtIDExOjU5cG1cclxuICAgICAgICAqL1xyXG4gICAgICAgIC8vIFNpbmNlIHNsb3RzIG11c3QgYmUgZm9yIHRoZSBzYW1lIGRhdGUsXHJcbiAgICAgICAgLy8gdG8gZGVmaW5lIHRoZSBncm91cHMgcmFuZ2VzIHVzZSB0aGUgZmlyc3QgZGF0ZVxyXG4gICAgICAgIHZhciBkYXRlUGFydCA9IHRoaXMuZGF0ZUF2YWlsKCkgJiYgdGhpcy5kYXRlQXZhaWwoKS5kYXRlKCkgfHwgbmV3IERhdGUoKTtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBncm91cDogJ01vcm5pbmcnLFxyXG4gICAgICAgICAgICAgICAgc2xvdHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRzOiBuZXcgVGltZShkYXRlUGFydCwgMCwgMCksXHJcbiAgICAgICAgICAgICAgICBlbmRzOiBuZXcgVGltZShkYXRlUGFydCwgMTIsIDApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwOiAnQWZ0ZXJub29uJyxcclxuICAgICAgICAgICAgICAgIHNsb3RzOiBbXSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0czogbmV3IFRpbWUoZGF0ZVBhcnQsIDEyLCAwKSxcclxuICAgICAgICAgICAgICAgIGVuZHM6IG5ldyBUaW1lKGRhdGVQYXJ0LCAxNywgMClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdFdmVuaW5nJyxcclxuICAgICAgICAgICAgICAgIHNsb3RzOiBbXSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0czogbmV3IFRpbWUoZGF0ZVBhcnQsIDE3LCAwKSxcclxuICAgICAgICAgICAgICAgIGVuZHM6IG5ldyBUaW1lKGRhdGVQYXJ0LCAyNCwgMClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIC8vIFBvcHVsYXRlIGdyb3VwcyB3aXRoIHRoZSB0aW1lIHNsb3RzXHJcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5kYXRlQXZhaWwoKSAmJiB0aGlzLmRhdGVBdmFpbCgpLmdldEZyZWVUaW1lU2xvdHMocmVxdWlyZWREdXJhdGlvbikgfHwgW107XHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0byBvcmdhbml6ZSBieSBncm91cFxyXG4gICAgICAgIHNsb3RzLmZvckVhY2goZnVuY3Rpb24oc2xvdCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRmlsdGVyIHNsb3RzIGJ5IHRoZSBpbmNyZW1lbnQgc2l6ZSBwcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIC8qdmFyIHRvdGFsTWludXRlcyA9IG1vbWVudC5kdXJhdGlvbihzbG90KS5hc01pbnV0ZXMoKSB8MDtcclxuICAgICAgICAgICAgaWYgKHRvdGFsTWludXRlcyAlIGluY1NpemUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSovXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBldmVyeSBncm91cFxyXG4gICAgICAgICAgICBncm91cHMuc29tZShmdW5jdGlvbihncm91cCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgbWF0Y2hlcyB0aGUgZ3JvdXAsIHB1c2ggdG8gaXRcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBnbyBvdXQgb2YgZ3JvdXBzIGl0ZXJhdGlvbiBxdWlja2x5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2xvdCA+PSBncm91cC5zdGFydHMgJiZcclxuICAgICAgICAgICAgICAgICAgICBzbG90IDwgZ3JvdXAuZW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnNsb3RzLnB1c2goc2xvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xyXG5cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNlbGVjdGVkRGF0ZXRpbWUgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNlbGVjdERhdGV0aW1lID0gZnVuY3Rpb24oc2VsZWN0ZWREYXRldGltZSwgZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRldGltZShzZWxlY3RlZERhdGV0aW1lKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBUaW1lIFBpY2tlclxyXG5cclxuICAgIHRoaXMucGlja2VkVGltZSA9IGtvLm9ic2VydmFibGUoKTtcclxuICAgIHRoaXMuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0UGlja2VkRGF0ZXRpbWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXMucGlja2VkVGltZSgpO1xyXG4gICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICAgICAgICAvLyBCdWlsZCBkYXRlLXRpbWVcclxuICAgICAgICAgICAgdmFyIHRpbWVzcGFuID0gbW9tZW50LmR1cmF0aW9uKHQpO1xyXG4gICAgICAgICAgICB0ID0gbW9tZW50KHRoaXMuc2VsZWN0ZWREYXRlKCkpLnN0YXJ0T2YoJ2RheScpLmFkZCh0aW1lc3BhbikudG9EYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5zZXRQaWNrZWRBc1NlbGVjdGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGV0aW1lKHRoaXMuZ2V0UGlja2VkRGF0ZXRpbWUoKSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuc2hvd1RpbWVQaWNrZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcHAubW9kYWxzLnNob3dUaW1lUGlja2VyKHtcclxuICAgICAgICAgICAgdGl0bGU6ICdCb29rIGFuIHVuYXZhaWxhYmxlIHRpbWUnLFxyXG4gICAgICAgICAgICBzZWxlY3RlZFRpbWU6IG51bGwsXHJcbiAgICAgICAgICAgIHVuc2V0TGFiZWw6ICdDYW5jZWwnXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihwaWNrZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAocGlja2VkVmFsdWUudGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrZWRUaW1lKHBpY2tlZFZhbHVlLnRpbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQaWNrZWRBc1NlbGVjdGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBKdXN0IG1vZGFsIHdhcyBkaXNtaXNzZWQsIHNvIHBpY2tlciB3YXMgcmVqZWN0ZWQgYnV0IG5vdCBhbiBlcnJvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgRmFxcyBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEZhcXNBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIFxyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKCk7XHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcclxuICAgIFxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdUYWxrIHRvIHVzJyk7XHJcbiAgICBcclxuICAgIC8vIFRlc3RpbmdEYXRhXHJcbiAgICBzZXRTb21lVGVzdGluZ0RhdGEodGhpcy52aWV3TW9kZWwpO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5zZWFyY2hUZXh0KCcnKTtcclxufTtcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoKSB7XHJcblxyXG4gICAgdGhpcy5mYXFzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuICAgIHRoaXMuc2VhcmNoVGV4dCA9IGtvLm9ic2VydmFibGUoJycpO1xyXG4gICAgXHJcbiAgICB0aGlzLmZpbHRlcmVkRmFxcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoVGV4dCgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFxcygpLmZpbHRlcihmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdiAmJiB2LnRpdGxlKCkgfHwgJyc7XHJcbiAgICAgICAgICAgIG4gKz0gdiAmJiB2LmRlc2NyaXB0aW9uKCkgfHwgJyc7XHJcbiAgICAgICAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuLmluZGV4T2YocykgPiAtMTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvTW9kZWwnKTtcclxuZnVuY3Rpb24gRmFxKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGlkOiAwLFxyXG4gICAgICAgIHRpdGxlOiAnJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogJydcclxuICAgIH0sIHZhbHVlcyk7XHJcbn1cclxuXHJcbi8qKiBURVNUSU5HIERBVEEgKiovXHJcbmZ1bmN0aW9uIHNldFNvbWVUZXN0aW5nRGF0YSh2aWV3TW9kZWwpIHtcclxuICAgIFxyXG4gICAgdmFyIHRlc3RkYXRhID0gW1xyXG4gICAgICAgIG5ldyBGYXEoe1xyXG4gICAgICAgICAgICBpZDogMSxcclxuICAgICAgICAgICAgdGl0bGU6ICdIb3cgZG8gSSBzZXQgdXAgYSBtYXJrZXRwbGFjZSBwcm9maWxlPycsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRGVzY3JpcHRpb24gYWJvdXQgaG93IEkgc2V0IHVwIGEgbWFya2V0cGxhY2UgcHJvZmlsZSdcclxuICAgICAgICB9KSxcclxuICAgICAgICBuZXcgRmFxKHtcclxuICAgICAgICAgICAgaWQ6IDIsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnQW5vdGhlciBmYXEnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Fub3RoZXIgZGVzY3JpcHRpb24nXHJcbiAgICAgICAgfSlcclxuICAgIF07XHJcbiAgICB2aWV3TW9kZWwuZmFxcyh0ZXN0ZGF0YSk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBGZWVkYmFjayBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEZlZWRiYWNrQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICBcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignVGFsayB0byB1cycpO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuIiwiLyoqXHJcbiAgICBGZWVkYmFja0Zvcm0gYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcclxuICAgIFZvY0VsZW1lbnRFbnVtID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ZvY0VsZW1lbnRFbnVtJyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gRmVlZGJhY2tGb3JtQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICBcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1RhbGsgdG8gdXMnKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIHZhciBwYXJhbXMgPSB0aGlzLnJlcXVlc3REYXRhLnJvdXRlLnNlZ21lbnRzIHx8IFtdO1xyXG4gICAgdmFyIGVsZW1lbnROYW1lID0gcGFyYW1zWzBdIHx8ICcnLFxyXG4gICAgICAgIGVsZW1lbnRJRCA9IFZvY0VsZW1lbnRFbnVtW2VsZW1lbnROYW1lXSB8MDtcclxuICAgIFxyXG4gICAgaWYgKCFlbGVtZW50TmFtZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdGZWVkYmFjayBJZGVhczogQWNjZXNzaW5nIGZlZWRiYWNrIHdpdGhvdXQgc3BlY2lmeSBhbiBlbGVtZW50LCB1c2luZyBHZW5lcmFsICgwKScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIVZvY0VsZW1lbnRFbnVtLmhhc093blByb3BlcnR5KGVsZW1lbnROYW1lKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZlZWRiYWNrIElkZWFzOiBnaXZlbiBhIGJhZCBWT0MgRWxlbWVudCBuYW1lOicsIGVsZW1lbnROYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnZpZXdNb2RlbC52b2NFbGVtZW50SUQoZWxlbWVudElEKTtcclxufTtcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuICAgIFxyXG4gICAgdGhpcy5tZXNzYWdlID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICB0aGlzLmJlY29tZUNvbGxhYm9yYXRvciA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy53YXNTZW50ID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICB0aGlzLmlzU2VuZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy52b2NFbGVtZW50SUQgPSBrby5vYnNlcnZhYmxlKDApO1xyXG5cclxuICAgIHZhciB1cGRhdGVXYXNTZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy53YXNTZW50KGZhbHNlKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIHRoaXMubWVzc2FnZS5zdWJzY3JpYmUodXBkYXRlV2FzU2VudCk7XHJcbiAgICB0aGlzLmJlY29tZUNvbGxhYm9yYXRvci5zdWJzY3JpYmUodXBkYXRlV2FzU2VudCk7XHJcbiAgICBcclxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbmRpbmcoKSA/ICdTZW5kaW5nLi4nIDogdGhpcy53YXNTZW50KCkgPyAnU2VudCcgOiAnU2VuZCc7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcclxuICAgICAgICB0aGlzLmlzU2VuZGluZyh0cnVlKTtcclxuICAgICAgICBhcHAubW9kZWwuZmVlZGJhY2sucG9zdElkZWEoe1xyXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UoKSxcclxuICAgICAgICAgICAgYmVjb21lQ29sbGFib3JhdG9yOiB0aGlzLmJlY29tZUNvbGxhYm9yYXRvcigpLFxyXG4gICAgICAgICAgICB2b2NFbGVtZW50SUQ6IHRoaXMudm9jRWxlbWVudElEKClcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBhZnRlciBiZWluZyBzZW50XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSgnJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYmVjb21lQ29sbGFib3JhdG9yKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy53YXNTZW50KHRydWUpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHNlbmRpbmcgeW91ciBmZWVkYmFjaycsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIEFsd2F5c1xyXG4gICAgICAgICAgICB0aGlzLmlzU2VuZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufVxyXG4iLCIvKipcclxuICAgIEZyZWVsYW5jZXIgUHJpY2luZyBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcclxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEZyZWVsYW5jZXJQcmljaW5nQWN0aXZpdHkoKSB7XHJcblxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdKb2IgVGl0bGUnLCB7XHJcbiAgICAgICAgYmFja0xpbms6ICcvc2NoZWR1bGluZydcclxuICAgIH0pO1xyXG4gICAgLy8gU2F2ZSBkZWZhdWx0cyB0byByZXN0b3JlIG9uIHVwZGF0ZU5hdkJhclN0YXRlIHdoZW4gbmVlZGVkOlxyXG4gICAgdGhpcy5kZWZhdWx0TGVmdEFjdGlvbiA9IHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5tb2RlbC50b1BsYWluT2JqZWN0KCk7XHJcblxyXG4gICAgLy8gT24gY2hhbmdpbmcgam9iVGl0bGVJRDpcclxuICAgIC8vIC0gbG9hZCBwcmljaW5nXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlELFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAgICAgaWYgKGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEIGFuZCBwcmljaW5nIHR5cGVzLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhleSBhcmUgZXNzZW50aWFsIGRhdGFcclxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwucHJpY2luZ1R5cGVzLmdldExpc3QoKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgam9iVGl0bGUgPSBkYXRhWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgZm9yIHVzZSBpbiB0aGUgdmlld1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlKGpvYlRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbmF2YmFyIChtYXkgaW5kaWNhdGUgdGhlIGpvYlRpdGxlIG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBwcmljaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLmdldExpc3Qoam9iVGl0bGVJRCk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLmFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5hc01vZGVsKGxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgcHJlc2V0cyBzZWxlY3Rpb24gZnJvbSByZXF1ZXN0RGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVzZXQgPSB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkUHJpY2luZyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRQcmljaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgaXNTZWxlY3RlZCBwcm9wZXJ0eSB0byBlYWNoIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlU2VsZWN0ZWQgPSBwcmVzZXQuc29tZShmdW5jdGlvbihwcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByLmZyZWVsYW5jZXJQcmljaW5nSUQgPT09IGl0ZW0uZnJlZWxhbmNlclByaWNpbmdJRCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaXNTZWxlY3RlZCA9IGtvLm9ic2VydmFibGUocHJlU2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZVNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxpc3QobGlzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZy4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwubGlzdChbXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEdvIGJhY2sgd2l0aCB0aGUgc2VsZWN0ZWQgcHJpY2luZyB3aGVuIHRyaWdnZXJlZCBpbiB0aGUgZm9ybS92aWV3XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXR1cm5TZWxlY3RlZCA9IGZ1bmN0aW9uKHByaWNpbmcsIGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAvLyBQYXNzIHRoZSBzZWxlY3RlZCBjbGllbnQgaW4gdGhlIGluZm9cclxuICAgICAgICB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkUHJpY2luZyA9IHByaWNpbmc7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZEpvYlRpdGxlSUQgPSBqb2JUaXRsZUlEO1xyXG4gICAgICAgIC8vIEFuZCBnbyBiYWNrXHJcbiAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnJldHVyblJlcXVlc3QgPSBmdW5jdGlvbiByZXR1cm5SZXF1ZXN0KCkge1xyXG4gICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xyXG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eToxMFxyXG4gICAgXHJcbiAgICB2YXIgaXRJcyA9IHRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZSgpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXJUZXh0KGl0SXMgPyAnU2VsZWN0IHNlcnZpY2VzJyA6ICdTZXJ2aWNlcycpO1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuYXBwLm1vZGVsLm9uYm9hcmRpbmcudXBkYXRlTmF2QmFyKHRoaXMubmF2QmFyKSkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS50aXRsZSkge1xyXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRpdGxlIGJ5IHRpdGxlIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKHRoaXMucmVxdWVzdERhdGEudGl0bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGl0bGUgbXVzdCBiZSBlbXB0eVxyXG4gICAgICAgICAgICB0aGlzLm5hdkJhci50aXRsZSgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRUb0NhbmNlbEFjdGlvbih0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCksIHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0byBkZWZhdWx0cywgb3IgZ2l2ZW4gdGl0bGU6XHJcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5tb2RlbC51cGRhdGVXaXRoKHRoaXMuZGVmYXVsdExlZnRBY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5uYXZUaXRsZSlcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KHRoaXMucmVxdWVzdERhdGEubmF2VGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGppZCA9IHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoKSxcclxuICAgICAgICAgICAgICAgIGpuYW1lID0gdGhpcy52aWV3TW9kZWwuam9iVGl0bGUoKSAmJiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZSgpLnNpbmd1bGFyTmFtZSgpIHx8ICdTY2hlZHVsaW5nJztcclxuXHJcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5saW5rKGppZCA/ICcvam9idGl0bGVzLycgKyBqaWQgOiAnL3NjaGVkdWxpbmcnKTtcclxuICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLnRleHQoam5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGl0SXMgJiYgIXRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgICAgICAvLyBVc2VzIGEgY3VzdG9tIGhhbmRsZXIgc28gaXQgcmV0dXJucyBrZWVwaW5nIHRoZSBnaXZlbiBzdGF0ZTpcclxuICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLmhhbmRsZXIodGhpcy5yZXR1cm5SZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkuaGFuZGxlcihudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgXHJcbiAgICAvLyBSZXNldDogYXZvaWRpbmcgZXJyb3JzIGJlY2F1c2UgcGVyc2lzdGVkIGRhdGEgZm9yIGRpZmZlcmVudCBJRCBvbiBsb2FkaW5nXHJcbiAgICAvLyBvciBvdXRkYXRlZCBpbmZvIGZvcmNpbmcgdXBkYXRlXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKDApO1xyXG4gICAgdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRQcmljaW5nLnJlbW92ZUFsbCgpO1xyXG4gICAgdGhpcy52aWV3TW9kZWwucmVxdWVzdERhdGEgPSB0aGlzLnJlcXVlc3REYXRhO1xyXG5cclxuICAgIHRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZSh0aGlzLnJlcXVlc3REYXRhLnNlbGVjdFByaWNpbmcgPT09IHRydWUpO1xyXG4gICAgXHJcbiAgICAvLyBQYXJhbXNcclxuICAgIHZhciBwYXJhbXMgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cztcclxuICAgIHZhciBqb2JUaXRsZUlEID0gcGFyYW1zWzBdIHwwO1xyXG4gICAgaWYgKGpvYlRpdGxlSUQgPT09IDAgJiYgb3B0aW9ucy5zZWxlY3RlZEpvYlRpdGxlSUQgPiAwKVxyXG4gICAgICAgIGpvYlRpdGxlSUQgPSBvcHRpb25zLnNlbGVjdGVkSm9iVGl0bGVJRCB8MDtcclxuXHJcbiAgICB2YXIgaXNBZGRpdGlvbk1vZGUgPSBwYXJhbXNbMF0gPT09ICduZXcnIHx8IHBhcmFtc1sxXSA9PT0gJ25ldyc7XHJcbiAgICBpZiAoaXNBZGRpdGlvbk1vZGUpIHtcclxuICAgICAgICAvLyBTZXRzIHJlZmVycmVyIGFzIGNhbmNlbExpbmtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcy5hcHAuc2hlbGwucmVmZXJyZXJSb3V0ZTtcclxuICAgICAgICByZWYgPSByZWYgJiYgcmVmLnVybCB8fCAnLyc7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rID0gcmVmO1xyXG4gICAgICAgIC8vIFNldCBmb3IgZWRpdG9yIGxpbmtzIGluIHRoZSB2aWV3XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY2FuY2VsTGluayhyZWYpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU2V0IHRoaXMgcGFnZSBhcyBjYW5jZWxMaW5rIGZvciBlZGl0b3IgbGlua3MgaW4gdGhlIHZpZXdcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5jYW5jZWxMaW5rKCcvZnJlZWxhbmNlclByaWNpbmcvJyArIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuaXNBZGRpdGlvbk1vZGUoaXNBZGRpdGlvbk1vZGUpO1xyXG4gICAgXHJcbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRChqb2JUaXRsZUlEKTtcclxuICAgIFxyXG4gICAgaWYgKGpvYlRpdGxlSUQgPT09IDApIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZXMuc3luYygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIFVzZXJKb2JQcm9maWxlID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9Vc2VySm9iUHJvZmlsZScpO1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHRoaXMuaGVhZGVyVGV4dCA9IGtvLm9ic2VydmFibGUoJ1NlcnZpY2VzJyk7XHJcbiAgICBcclxuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XHJcbiAgICB0aGlzLmpvYlRpdGxlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcclxuICAgIHRoaXMuaXNBZGRpdGlvbk1vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMuY2FuY2VsTGluayA9IGtvLm9ic2VydmFibGUobnVsbCk7XHJcbiAgICBcclxuICAgIHRoaXMuam9iVGl0bGVzID0gbmV3IFVzZXJKb2JQcm9maWxlKGFwcCk7XHJcbiAgICB0aGlzLmpvYlRpdGxlcy5iYXNlVXJsKCcvZnJlZWxhbmNlclByaWNpbmcnKTtcclxuICAgIHRoaXMuam9iVGl0bGVzLnNlbGVjdEpvYlRpdGxlID0gZnVuY3Rpb24oam9iVGl0bGUpIHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmpvYlRpdGxlSUQoam9iVGl0bGUuam9iVGl0bGVJRCgpKTtcclxuICAgICAgICB2YXIgdXJsID0gJ2ZyZWVsYW5jZXJQcmljaW5nLycgKyBqb2JUaXRsZS5qb2JUaXRsZUlEKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBZGRpdGlvbk1vZGUoKSlcclxuICAgICAgICAgICAgdXJsICs9ICcvbmV3JztcclxuICAgICAgICAvLyBwdXNoU3RhdGUgY2Fubm90IGJlIHVzZWQgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCB0aGUgXHJcbiAgICAgICAgLy8gc2VsZWN0aW9uIGxvZ2ljIChvbiBuZXctYm9va2luZyBwcm9ncmVzcylcclxuICAgICAgICAvLyBUT0RPOiBjb21tZW50ZWQgdW50aWwgdGhlIGJ1ZyB3aXRoIHJlcGxhY2VTdGF0ZSBpbiBIYXNoYmFuZ0hpc3RvcnkgaXMgZml4ZWRcclxuICAgICAgICAvL2FwcC5zaGVsbC5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCB1cmwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmxpc3QgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG5cclxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLnN0YXRlLmlzTG9hZGluZygpIHx8XHJcbiAgICAgICAgICAgIGFwcC5tb2RlbC5wcmljaW5nVHlwZXMuc3RhdGUuaXNMb2FkaW5nKCkgfHxcclxuICAgICAgICAgICAgYXBwLm1vZGVsLmpvYlRpdGxlcy5zdGF0ZS5pc0xvYWRpbmcoKVxyXG4gICAgICAgICk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaXNMb2NrZWQgPSB0aGlzLmlzTG9hZGluZztcclxuXHJcbiAgICAvLyBFc3BlY2lhbCBtb2RlIHdoZW4gaW5zdGVhZCBvZiBwaWNrIGFuZCBlZGl0IHdlIGFyZSBqdXN0IHNlbGVjdGluZ1xyXG4gICAgdGhpcy5pc1NlbGVjdGlvbk1vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICAnU2F2ZSBhbmQgY29udGludWUnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBHcm91cGVkIGxpc3Qgb2YgcHJpY2luZ3M6XHJcbiAgICAvLyBEZWZpbmVkIGdyb3VwcyBieSBwcmljaW5nIHR5cGVcclxuICAgIHRoaXMuZ3JvdXBlZFByaWNpbmcgPSBrby5jb21wdXRlZChmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMubGlzdCgpO1xyXG4gICAgICAgIHZhciBpc1NlbGVjdGlvbiA9IHRoaXMuaXNTZWxlY3Rpb25Nb2RlKCk7XHJcbiAgICAgICAgdmFyIGdyb3VwTmFtZVByZWZpeCA9IGlzU2VsZWN0aW9uID8gJ1NlbGVjdCAnIDogJyc7XHJcblxyXG4gICAgICAgIHZhciBncm91cHMgPSBbXSxcclxuICAgICAgICAgICAgZ3JvdXBzTGlzdCA9IFtdO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0FkZGl0aW9uTW9kZSgpKSB7XHJcbiAgICAgICAgICAgIGdyb3VwcyA9IF8uZ3JvdXBCeShsaXN0LCBmdW5jdGlvbihwcmljaW5nSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaWNpbmdJdGVtLnByaWNpbmdUeXBlSUQoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBpbmRleGVkIG9iamVjdCBpbnRvIGFuIGFycmF5IHdpdGggc29tZSBtZXRhLWRhdGFcclxuICAgICAgICAgICAgZ3JvdXBzTGlzdCA9IE9iamVjdC5rZXlzKGdyb3VwcykubWFwKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaWNpbmc6IGdyb3Vwc1trZXldLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIHByaWNpbmcgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHAubW9kZWwucHJpY2luZ1R5cGVzLmdldE9ic2VydmFibGVJdGVtKGtleSlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBnci5ncm91cCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cE5hbWVQcmVmaXggKyAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSgpICYmIHRoaXMudHlwZSgpLnBsdXJhbE5hbWUoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VydmljZXMnXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0sIGdyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBncjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNpbmNlIHRoZSBncm91cHNMaXN0IGlzIGJ1aWx0IGZyb20gdGhlIGV4aXN0ZW50IHByaWNpbmcgaXRlbXNcclxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmVjb3JkcyBmb3Igc29tZSBwcmljaW5nIHR5cGUgKG9yIG5vdGhpbmcgd2hlblxyXG4gICAgICAgIC8vIGp1c3QgY3JlYXRlZCB0aGUgam9iIHRpdGxlKSwgdGhhdCB0eXBlcy9ncm91cHMgYXJlIG5vdCBpbmNsdWRlZCxcclxuICAgICAgICAvLyBzbyByZXZpZXcgYW5kIGluY2x1ZGUgbm93LlxyXG4gICAgICAgIC8vIE5PVEU6IGFzIGEgZ29vZCBzaWRlIGVmZmVjdCBvZiB0aGlzIGFwcHJvYWNoLCBwcmljaW5nIHR5cGVzIHdpdGhcclxuICAgICAgICAvLyBzb21lIHByaWNpbmcgd2lsbCBhcHBlYXIgZmlyc3QgaW4gdGhlIGxpc3QgKG5lYXJlc3QgdG8gdGhlIHRvcClcclxuICAgICAgICB2YXIgcHJpY2luZ1R5cGVzID0gdGhpcy5qb2JUaXRsZSgpICYmIHRoaXMuam9iVGl0bGUoKS5wcmljaW5nVHlwZXMoKTtcclxuICAgICAgICBpZiAocHJpY2luZ1R5cGVzICYmIHByaWNpbmdUeXBlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcHJpY2luZ1R5cGVzLmZvckVhY2goZnVuY3Rpb24gKGpvYlR5cGUpIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVJRCA9IGpvYlR5cGUucHJpY2luZ1R5cGVJRCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90IGlmIGFscmVhZHkgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIGlmIChncm91cHMuaGFzT3duUHJvcGVydHkodHlwZUlEKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaWNpbmc6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGFwcC5tb2RlbC5wcmljaW5nVHlwZXMuZ2V0T2JzZXJ2YWJsZUl0ZW0odHlwZUlEKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGdyLmdyb3VwID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwTmFtZVByZWZpeCArIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlKCkgJiYgdGhpcy50eXBlKCkucGx1cmFsTmFtZSgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZXJ2aWNlcydcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSwgZ3IpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdyb3Vwc0xpc3QucHVzaChncik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdyb3Vwc0xpc3Q7XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5zZWxlY3RlZFByaWNpbmcgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG4gICAgLyoqXHJcbiAgICAgICAgVG9nZ2xlIHRoZSBzZWxlY3Rpb24gc3RhdHVzIG9mIGEgcHJpY2luZywgYWRkaW5nXHJcbiAgICAgICAgb3IgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgJ3NlbGVjdGVkUHJpY2luZycgYXJyYXkuXHJcbiAgICAqKi9cclxuICAgIHRoaXMudG9nZ2xlUHJpY2luZ1NlbGVjdGlvbiA9IGZ1bmN0aW9uKHByaWNpbmcpIHtcclxuXHJcbiAgICAgICAgdmFyIGluSW5kZXggPSAtMSxcclxuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRQcmljaW5nKCkuc29tZShmdW5jdGlvbihzZWxlY3RlZFByaWNpbmcsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFByaWNpbmcgPT09IHByaWNpbmcpIHtcclxuICAgICAgICAgICAgICAgIGluSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHByaWNpbmcuaXNTZWxlY3RlZCghaXNTZWxlY3RlZCk7XHJcblxyXG4gICAgICAgIGlmIChpc1NlbGVjdGVkKVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUHJpY2luZy5zcGxpY2UoaW5JbmRleCwgMSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUHJpY2luZy5wdXNoKHByaWNpbmcpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm9uYm9hcmRpbmdOZXh0UmVhZHkgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaXNpbiA9IGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSxcclxuICAgICAgICAgICAgaGFzUHJpY2luZyA9IHRoaXMubGlzdCgpLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGlzaW4gJiYgaGFzUHJpY2luZztcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBFbmRzIHRoZSBzZWxlY3Rpb24gcHJvY2VzcywgcmVhZHkgdG8gY29sbGVjdCBzZWxlY3Rpb25cclxuICAgICAgICBhbmQgcGFzc2luZyBpdCB0byB0aGUgcmVxdWVzdGVyIGFjdGl2aXR5LlxyXG4gICAgICAgIFdvcmtzIHRvbyB0byBwYXNzIHRvIHRoZSBuZXh0IG9uYm9hcmRpbmcgc3RlcFxyXG4gICAgKiovXHJcbiAgICB0aGlzLmVuZFNlbGVjdGlvbiA9IGZ1bmN0aW9uKGRhdGEsIGV2ZW50KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSkge1xyXG4gICAgICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5nb05leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJ1biBtZXRob2QgaW5qZWN0ZWQgYnkgdGhlIGFjdGl2aXR5IHRvIHJldHVybiBhIFxyXG4gICAgICAgICAgICAvLyBzZWxlY3RlZCBhZGRyZXNzOlxyXG4gICAgICAgICAgICB0aGlzLnJldHVyblNlbGVjdGVkKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFByaWNpbmcoKS5tYXAoZnVuY3Rpb24ocHJpY2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyZWVsYW5jZXJQcmljaW5nSUQ6IGtvLnVud3JhcChwcmljaW5nLmZyZWVsYW5jZXJQcmljaW5nSUQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFByaWNlOiBrby51bndyYXAocHJpY2luZy5wcmljZSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmpvYlRpdGxlSUQoKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5lZGl0UHJpY2luZyA9IGZ1bmN0aW9uKHByaWNpbmcpIHtcclxuICAgICAgICBhcHAuc2hlbGwuZ28oJ2ZyZWVsYW5jZXJQcmljaW5nRWRpdG9yLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICcvJyArIHByaWNpbmcuZnJlZWxhbmNlclByaWNpbmdJRCgpKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgSGFuZGxlciBmb3IgdGhlIGxpc3R2aWV3IGl0ZW1zLCBtYW5hZ2luZyBlZGl0aW9uIGFuZCBzZWxlY3Rpb24gZGVwZW5kaW5nIG9uIGN1cnJlbnQgbW9kZVxyXG4gICAgKiovXHJcbiAgICB0aGlzLnRhcFByaWNpbmcgPSBmdW5jdGlvbihwcmljaW5nLCBldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0aW9uTW9kZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlUHJpY2luZ1NlbGVjdGlvbihwcmljaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWRpdFByaWNpbmcocHJpY2luZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnRhcE5ld1ByaWNpbmcgPSBmdW5jdGlvbihncm91cCwgZXZlbnQpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdXJsID0gJyMhZnJlZWxhbmNlclByaWNpbmdFZGl0b3IvJyArIHRoaXMuam9iVGl0bGVJRCgpICsgJy9uZXcvJyArIChncm91cC50eXBlKCkgJiYgZ3JvdXAudHlwZSgpLnByaWNpbmdUeXBlSUQoKSk7XHJcblxyXG4gICAgICAgIC8vIFBhc3Npbmcgb3JpZ2luYWwgZGF0YSwgZm9yIGluLXByb2dyZXNzIHByb2Nlc3MgKGFzIG5ldy1ib29raW5nKVxyXG4gICAgICAgIC8vIGFuZCB0aGUgc2VsZWN0ZWQgdGl0bGUgc2luY2UgdGhlIFVSTCBjb3VsZCBub3QgYmUgdXBkYXRlZCBwcm9wZXJseVxyXG4gICAgICAgIC8vIChzZWUgdGhlIGFub3RhdGVkIGNvbW1lbnQgYWJvdXQgcmVwbGFjZVN0YXRlIGJ1ZyBvbiB0aGlzIGZpbGUpXHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAkLmV4dGVuZCh7fSwgdGhpcy5yZXF1ZXN0RGF0YSwge1xyXG4gICAgICAgICAgICBzZWxlY3RlZEpvYlRpdGxlSUQ6IHRoaXMuam9iVGl0bGVJRCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNhbmNlbExpbmspIHtcclxuICAgICAgICAgICAgJC5leHRlbmQocmVxdWVzdCwge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsTGluazogdGhpcy5jYW5jZWxMaW5rKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFdoZW4gaW4gc2VsZWN0aW9uIG1vZGU6XHJcbiAgICAgICAgLy8gQWRkIGN1cnJlbnQgc2VsZWN0aW9uIGFzIHByZXNlbGVjdGlvbiwgc28gY2FuIGJlIHJlY292ZXJlZCBsYXRlciBhbmQgXHJcbiAgICAgICAgLy8gdGhlIGVkaXRvciBjYW4gYWRkIHRoZSBuZXcgcHJpY2luZyB0byB0aGUgbGlzdFxyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0aW9uTW9kZSgpKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2VsZWN0ZWRQcmljaW5nID0gdGhpcy5zZWxlY3RlZFByaWNpbmcoKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHByaWNpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJlZWxhbmNlclByaWNpbmdJRDoga28udW53cmFwKHByaWNpbmcuZnJlZWxhbmNlclByaWNpbmdJRCksXHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxQcmljZToga28udW53cmFwKHByaWNpbmcudG90YWxQcmljZSlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXBwLnNoZWxsLmdvKHVybCwgcmVxdWVzdCk7XHJcblxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBGcmVlbGFuY2VyUHJpY2luZ0VkaXRvciBhY3Rpdml0eVxyXG4gICAgXHJcbiAgICBUT0RPOiBNb2RlbFZlcnNpb24gaXMgTk9UIGJlaW5nIHVzZWQsIHNvIG5vIGdldHRpbmcgdXBkYXRlcyBpZiBzZXJ2ZXIgdXBkYXRlc1xyXG4gICAgdGhlIGRhdGEgYWZ0ZXIgbG9hZCAoZGF0YSBsb2FkIGlzIHJlcXVlc3RlZCBidXQgZ2V0IGZpcnN0IGZyb20gY2FjaGUpLiBVc2VcclxuICAgIHZlcnNpb24gYW5kIGdldCBzeW5jJ2VkIGRhdGEgd2hlbiByZWFkeSwgYW5kIGFkZGl0aW9uYWxseSBub3RpZmljYXRpb24gdG9cclxuICAgIG92ZXJyaWRlIGNoYW5nZXMgaWYgc2VydmVyIGRhdGEgaXMgZGlmZmVyZW50IHRoYXQgYW55IGxvY2FsIGNoYW5nZS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxyXG4gICAgUHJpY2luZ1R5cGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvUHJpY2luZ1R5cGUnKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBGcmVlbGFuY2VyUHJpY2luZ0VkaXRvckFjdGl2aXR5KCkge1xyXG5cclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTZXJ2aWNlcycpO1xyXG4gICAgXHJcbiAgICAvLy8gR28gb3V0IGFmdGVyIHNhdmUgc3VjY2VzZnVsbHkgYW4gaXRlbS5cclxuICAgIC8vLyBQcmljaW5nIGlzIGEgcGxhaW4gb2JqZWN0XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5vblNhdmUgPSBmdW5jdGlvbihwcmljaW5nKSB7XHJcbiAgICAgICAgLy8gR28gYmFjayBvbiBzYXZlLlxyXG4gICAgICAgIC8vIElmIHdlIGNvbWVzIHdpdGggYSBzZWxlY3Rpb24gb2YgcHJpY2luZywgd2UgbXVzdCBhZGQgdGhlIG5ldyBvbmVcclxuICAgICAgICAvLyB0aGVyZSBhbmQganVzdCBnbyBiYWNrIChmcmVlbGFuY2VyUHJpY2luZyBpcyBpbiBzZWxlY3Rpb24gbW9kZSkga2VlcGluZ1xyXG4gICAgICAgIC8vIGFueSByZXF1ZXN0RGF0YSBmb3IgaW4tcHJvZ3Jlc3Mgc3RhdGUuXHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRQcmljaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIElzIGFuIGFycmF5IG9mIHBsYWluIG9iamVjdHMgb2YganVzdCBJRCBhbmQgdG90YWxQcmljZVxyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkUHJpY2luZy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGZyZWVsYW5jZXJQcmljaW5nSUQ6IHByaWNpbmcuZnJlZWxhbmNlclByaWNpbmdJRCxcclxuICAgICAgICAgICAgICAgIHRvdGFsUHJpY2U6IHByaWNpbmcudG90YWxQcmljZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSnVzdCBleGVjdXRlIHRoZSBzdGFuZGFyZCBzYXZlIHByb2Nlc3NcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3VjY2Vzc1NhdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUudXBkYXRlTmF2QmFyU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVOYXZCYXJTdGF0ZSgpIHtcclxuXHJcbiAgICB2YXIgbGluayA9IHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayB8fCAnL2ZyZWVsYW5jZXJQcmljaW5nLycgKyB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKCk7XHJcbiAgICBcclxuICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgbGluayk7XHJcbn07XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjEwICAgIFxyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvLyBSZXNldFxyXG4gICAgdGhpcy52aWV3TW9kZWwud2FzUmVtb3ZlZChmYWxzZSk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5mcmVlbGFuY2VyUHJpY2luZ1ZlcnNpb24obnVsbCk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5wcmljaW5nVHlwZShudWxsKTtcclxuXHJcbiAgICAvLyBQYXJhbXNcclxuICAgIHZhciBwYXJhbXMgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cyB8fCBbXTtcclxuXHJcbiAgICB2YXIgam9iVGl0bGVJRCA9IHBhcmFtc1swXSB8MCxcclxuICAgICAgICAvLyBQYXJhbWV0ZXIgWzFdIGNhbiBiZSAnbmV3JyBmb2xsb3dlZCBieSBhIHByaWNpbmdUeXBlSUQgYXMgWzJdXHJcbiAgICAgICAgcHJpY2luZ1R5cGVJRCA9IHBhcmFtc1sxXSA9PT0gJ25ldycgPyBwYXJhbXNbMl0gfDAgOiAwLFxyXG4gICAgICAgIC8vIE9yIGEgcHJpY2luZ0lEXHJcbiAgICAgICAgZnJlZWxhbmNlclByaWNpbmdJRCA9IHBhcmFtc1sxXSB8MDtcclxuXHJcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYlRpdGxlSUQpO1xyXG4gICAgdGhpcy52aWV3TW9kZWwuZnJlZWxhbmNlclByaWNpbmdJRChmcmVlbGFuY2VyUHJpY2luZ0lEKTtcclxuICAgIFxyXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBUaGUgcHJpY2luZyByZWNvcmQgbmVlZHMgc29tZSBzcGVjaWFsIHNldC11cCBhZnRlciBjcmVhdGlvbi9sb2FkaW5nIGFuZCBiZWZvcmVcclxuICAgICAgICBiZWluZyBwcmVzZW50ZWQgdG8gdGhlIHVzZXIsIGJlY2F1c2Ugc3BlY2lhbCB2YWx1ZS1ydWxlcy5cclxuICAgICoqL1xyXG4gICAgdmFyIHByaWNpbmdTZXR1cCA9IGZ1bmN0aW9uIHByaWNpbmdTZXR1cCgpIHtcclxuICAgICAgICAvLyBQcmljaW5nIGZpZWxkcyB0aGF0IGhhcyBhIHNwZWNpYWwgaW5pdGlhbCB2YWx1ZVxyXG4gICAgICAgIHZhciBjID0gdGhpcy52aWV3TW9kZWwuY3VycmVudCgpO1xyXG4gICAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgICAgIC8vIE5hbWU6IG11c3QgYmUgdGhlIFByaWNpbmdUeXBlLmZpeGVkTmFtZSBldmVyIGlmIGFueSwgb3JcclxuICAgICAgICAgICAgLy8gICB0aGUgbmFtZSBzYXZlZCBpbiB0aGUgcHJpY2luZyBvclxyXG4gICAgICAgICAgICAvLyAgIHRoZSBzdWdnZXN0ZWROYW1lIGFzIGxhc3QgZmFsbGJhY2tcclxuICAgICAgICAgICAgYy5wcmljaW5nLm5hbWUoYy50eXBlLmZpeGVkTmFtZSgpIHx8IGMucHJpY2luZy5uYW1lKCkgfHwgYy50eXBlLnN1Z2dlc3RlZE5hbWUoKSk7XHJcbiAgICAgICAgICAgIC8vIFJlcXVpcmVkIGNhbGwgYWZ0ZXIgbG9hZGluZyBhIHByaWNpbmcgdG8gcmVmbGVjdCBkYXRhIGNvcnJlY3RseSAoY2Fubm90IGJlIGF1dG9tYXRlZClcclxuICAgICAgICAgICAgYy5wcmljaW5nLnJlZnJlc2hOb1ByaWNlUmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB2YXIgc2hvd0ludmFsaWRSZXF1ZXN0RXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0ludmFsaWQgcmVxdWVzdCcsXHJcbiAgICAgICAgICAgIGVycm9yOiB7IGpvYlRpdGxlSUQ6IGpvYlRpdGxlSUQsIHByaWNpbmdUeXBlSUQ6IHByaWNpbmdUeXBlSUQsIGZyZWVsYW5jZXJQcmljaW5nSUQ6IGZyZWVsYW5jZXJQcmljaW5nSUQgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIE9uIGNsb3NlIG1vZGFsLCBnbyBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjaygpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuaXNMb2FkaW5nKHRydWUpO1xyXG4gICAgaWYgKHByaWNpbmdUeXBlSUQpIHtcclxuICAgICAgICAvLyBMb2FkIHRoZSBwcmljaW5nIFR5cGVcclxuICAgICAgICB0aGlzLmFwcC5tb2RlbC5wcmljaW5nVHlwZXMuZ2V0SXRlbShwcmljaW5nVHlwZUlEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnByaWNpbmdUeXBlKHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gTmV3IHByaWNpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbih0aGlzLmFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5uZXdJdGVtVmVyc2lvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgam9iVGl0bGVJRDogam9iVGl0bGVJRCxcclxuICAgICAgICAgICAgICAgICAgICBwcmljaW5nVHlwZUlEOiBwcmljaW5nVHlwZUlEXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBwcmljaW5nU2V0dXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNob3dJbnZhbGlkUmVxdWVzdEVycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZnJlZWxhbmNlclByaWNpbmdJRCkge1xyXG4gICAgICAgIC8vIEdldCB0aGUgcHJpY2luZ1xyXG4gICAgICAgIHRoaXMuYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLmdldEl0ZW1WZXJzaW9uKGpvYlRpdGxlSUQsIGZyZWVsYW5jZXJQcmljaW5nSUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbikge1xyXG4gICAgICAgICAgICBpZiAoZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBwcmljaW5nIHR5cGUgYmVmb3JlIHB1dCB0aGUgdmVyc2lvblxyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0byBsZXQgdGhlICdjYXRjaCcgdG8gZ2V0IGFueSBlcnJvclxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRJdGVtKGZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbi52ZXJzaW9uLnByaWNpbmdUeXBlSUQoKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcmljaW5nVHlwZSh0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uKGZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNpbmdTZXR1cCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0ludmFsaWRSZXF1ZXN0RXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hvd0ludmFsaWRSZXF1ZXN0RXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nLicsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gT24gY2xvc2UgbW9kYWwsIGdvIGJhY2tcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjaygpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzaG93SW52YWxpZFJlcXVlc3RFcnJvcigpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czogMzUqL1xyXG5cclxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICAvLyBtYW5hZ2VkIG1hbnVhbGx5IGluc3RlYWQgb2ZcclxuICAgIC8vYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLnN0YXRlLmlzTG9hZGluZztcclxuICAgIHRoaXMuaXNTYXZpbmcgPSBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuc3RhdGUuaXNTYXZpbmc7XHJcbiAgICB0aGlzLmlzU3luY2luZyA9IGFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5zdGF0ZS5pc1N5bmNpbmc7XHJcbiAgICB0aGlzLmlzRGVsZXRpbmcgPSBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuc3RhdGUuaXNEZWxldGluZztcclxuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XHJcbiAgICB0aGlzLmZyZWVsYW5jZXJQcmljaW5nSUQgPSBrby5vYnNlcnZhYmxlKDApO1xyXG4gICAgLy8gTDEwTlxyXG4gICAgdGhpcy5tb25leVN5bWJvbCA9IGtvLm9ic2VydmFibGUoJyQnKTtcclxuICAgIFxyXG4gICAgdGhpcy5wcmljaW5nVHlwZSA9IGtvLm9ic2VydmFibGUobmV3IFByaWNpbmdUeXBlKCkpO1xyXG5cclxuICAgIHRoaXMuZnJlZWxhbmNlclByaWNpbmdWZXJzaW9uID0ga28ub2JzZXJ2YWJsZShudWxsKTtcclxuICAgIHRoaXMuZnJlZWxhbmNlclByaWNpbmcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbigpO1xyXG4gICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2LnZlcnNpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5oZWFkZXIgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdMb2FkaW5nLi4uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mcmVlbGFuY2VyUHJpY2luZ1ZlcnNpb24oKSkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMucHJpY2luZ1R5cGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHQgJiYgdC5zaW5ndWxhck5hbWUoKSB8fCAnU2VydmljZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1Vua25vdyBzZXJ2aWNlIG9yIHdhcyBkZWxldGVkJztcclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIC8vIFF1aWNrZXIgYWNjZXNzIGluIGZvcm0sIHVuZGVyIGEgJ3dpdGgnXHJcbiAgICB0aGlzLmN1cnJlbnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnByaWNpbmdUeXBlKCksXHJcbiAgICAgICAgICAgIHAgPSB0aGlzLmZyZWVsYW5jZXJQcmljaW5nKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHQgJiYgcCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogdCxcclxuICAgICAgICAgICAgICAgIHByaWNpbmc6IHBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLndhc1JlbW92ZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRGVsZXRpbmcoKSB8fCBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuc3RhdGUuaXNMb2NrZWQoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzTmV3ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5mcmVlbGFuY2VyUHJpY2luZygpO1xyXG4gICAgICAgIHJldHVybiBwICYmICFwLnVwZGF0ZWREYXRlKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbigpO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICdMb2FkaW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXHJcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmluZyBjaGFuZ2VzJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgIHYgJiYgdi5hcmVEaWZmZXJlbnQoKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlIGNoYW5nZXMnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmVkJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLnVuc2F2ZWRDaGFuZ2VzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5mcmVlbGFuY2VyUHJpY2luZ1ZlcnNpb24oKTtcclxuICAgICAgICByZXR1cm4gdiAmJiB2LmFyZURpZmZlcmVudCgpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuZGVsZXRlVGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmlzRGVsZXRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ0RlbGV0aW5nLi4uJyA6IFxyXG4gICAgICAgICAgICAgICAgJ0RlbGV0ZSdcclxuICAgICAgICApO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLnNldEl0ZW0odGhpcy5mcmVlbGFuY2VyUHJpY2luZygpLm1vZGVsLnRvUGxhaW5PYmplY3QoKSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZXJzaW9uIHdpdGggc2VydmVyIGRhdGEuXHJcbiAgICAgICAgICAgIHRoaXMuZnJlZWxhbmNlclByaWNpbmcoKS5tb2RlbC51cGRhdGVXaXRoKHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICAvLyBQdXNoIHZlcnNpb24gc28gaXQgYXBwZWFycyBhcyBzYXZlZFxyXG4gICAgICAgICAgICB0aGlzLmZyZWVsYW5jZXJQcmljaW5nVmVyc2lvbigpLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFmdGVyIHNhdmUgbG9naWMgcHJvdmlkZWQgYnkgdGhlIGFjdGl2aXR5LCBpbmplY3RlZCBpbiB0aGUgdmlldzpcclxuICAgICAgICAgICAgdGhpcy5vblNhdmUoc2VydmVyRGF0YSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgc2F2aW5nLicsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5jb25maXJtUmVtb3ZhbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIFRPRE8gQmV0dGVyIGwxMG4gb3IgcmVwbGFjZSBieSBhIG5ldyBwcmVzZXQgZmllbGQgb24gcHJpY2luZ1R5cGUuZGVsZXRlTGFiZWxcclxuICAgICAgICB2YXIgcCA9IHRoaXMucHJpY2luZ1R5cGUoKTtcclxuICAgICAgICBhcHAubW9kYWxzLmNvbmZpcm0oe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0RlbGV0ZSAnICsgKHAgJiYgcC5zaW5ndWxhck5hbWUoKSksXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdBcmUgeW91IHN1cmU/IFRoZSBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nLFxyXG4gICAgICAgICAgICB5ZXM6ICdEZWxldGUnLFxyXG4gICAgICAgICAgICBubzogJ0tlZXAnXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGFwcC5tb2RlbC5mcmVlbGFuY2VyUHJpY2luZy5kZWxJdGVtKHRoaXMuam9iVGl0bGVJRCgpLCB0aGlzLmZyZWVsYW5jZXJQcmljaW5nSUQoKSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy53YXNSZW1vdmVkKHRydWUpO1xyXG4gICAgICAgICAgICAvLyBHbyBvdXQgdGhlIGRlbGV0ZWQgbG9jYXRpb25cclxuICAgICAgICAgICAgYXBwLnNoZWxsLmdvQmFjaygpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGRlbGV0aW5nLicsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgSG9tZSBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcclxuICAgIEFwcG9pbnRtZW50VmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvQXBwb2ludG1lbnRWaWV3Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gSG9tZUFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIC8vIG51bGwgZm9yIGxvZ29cclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcihudWxsKTtcclxuICAgIFxyXG4gICAgLy8gR2V0dGluZyBlbGVtZW50c1xyXG4gICAgdGhpcy4kbmV4dEJvb2tpbmcgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjaG9tZU5leHRCb29raW5nJyk7XHJcbiAgICB0aGlzLiR1cGNvbWluZ0Jvb2tpbmdzID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2hvbWVVcGNvbWluZ0Jvb2tpbmdzJyk7XHJcbiAgICB0aGlzLiRpbmJveCA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNob21lSW5ib3gnKTtcclxuICAgIHRoaXMuJHBlcmZvcm1hbmNlID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2hvbWVQZXJmb3JtYW5jZScpO1xyXG4gICAgdGhpcy4kZ2V0TW9yZSA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNob21lR2V0TW9yZScpO1xyXG4gICAgXHJcbiAgICAvLyBUZXN0aW5nRGF0YVxyXG4gICAgc2V0U29tZVRlc3RpbmdEYXRhKHRoaXMudmlld01vZGVsKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgXHJcbiAgICB2YXIgdiA9IHRoaXMudmlld01vZGVsLFxyXG4gICAgICAgIGFwcCA9IHRoaXMuYXBwLFxyXG4gICAgICAgIGFwcE1vZGVsID0gdGhpcy5hcHAubW9kZWw7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLmNvbXBsZXRlZE9uYm9hcmRpbmcpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMucmVxdWVzdERhdGEuY29tcGxldGVkT25ib2FyZGluZykge1xyXG4gICAgICAgICAgICBjYXNlICd3ZWxjb21lJzogLy8gU2NoZWR1bGUgY29tcGxldGVcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93Tm90aWZpY2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NvbmdyYXRzJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnWW91XFwncmUgYWxsIHJlYWR5IHRvIHN0YXJ0IHNjaGVkdWxpbmcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGllbnRzLiBDbGljayArIHRvIHN0YXJ0IGFkZGluZyBib29raW5ncyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuZCBjbGllbnRzLidcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgcHJlYXBhcmVTaG93RXJyb3JGb3IgPSBmdW5jdGlvbiBwcmVhcGFyZVNob3dFcnJvckZvcih0aXRsZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGRhdGFcclxuICAgIGlmICh2LnVwY29taW5nQm9va2luZ3MuaXRlbXMoKS5sZW5ndGgpIHtcclxuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MuaXNTeW5jaW5nKHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLmlzTG9hZGluZyh0cnVlKTtcclxuICAgIH1cclxuICAgIGFwcE1vZGVsLmJvb2tpbmdzLmdldFVwY29taW5nQm9va2luZ3MoKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24odXBjb21pbmcpIHtcclxuXHJcbiAgICAgICAgaWYgKHVwY29taW5nLm5leHRCb29raW5nSUQpIHtcclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzSUQgPSB2Lm5leHRCb29raW5nKCkgJiYgdi5uZXh0Qm9va2luZygpLnNvdXJjZUJvb2tpbmcoKS5ib29raW5nSUQoKTtcclxuICAgICAgICAgICAgaWYgKHVwY29taW5nLm5leHRCb29raW5nSUQgIT09IHByZXZpb3VzSUQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2Lm5leHRCb29raW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2Lm5leHRCb29raW5nLmlzU3luY2luZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHYubmV4dEJvb2tpbmcuaXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXBwTW9kZWwuY2FsZW5kYXIuZ2V0QXBwb2ludG1lbnQoeyBib29raW5nSUQ6IHVwY29taW5nLm5leHRCb29raW5nSUQgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGFwdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYubmV4dEJvb2tpbmcobmV3IEFwcG9pbnRtZW50VmlldyhhcHQsIGFwcCkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChwcmVhcGFyZVNob3dFcnJvckZvcignRXJyb3IgbG9hZGluZyBuZXh0IGJvb2tpbmcnKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHlcclxuICAgICAgICAgICAgICAgICAgICB2Lm5leHRCb29raW5nLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5uZXh0Qm9va2luZy5pc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHYubmV4dEJvb2tpbmcobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MudG9kYXkucXVhbnRpdHkodXBjb21pbmcudG9kYXkucXVhbnRpdHkpO1xyXG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy50b2RheS50aW1lKHVwY29taW5nLnRvZGF5LnRpbWUgJiYgbmV3IERhdGUodXBjb21pbmcudG9kYXkudGltZSkpO1xyXG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy50b21vcnJvdy5xdWFudGl0eSh1cGNvbWluZy50b21vcnJvdy5xdWFudGl0eSk7XHJcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLnRvbW9ycm93LnRpbWUodXBjb21pbmcudG9tb3Jyb3cudGltZSAmJiBuZXcgRGF0ZSh1cGNvbWluZy50b21vcnJvdy50aW1lKSk7XHJcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLm5leHRXZWVrLnF1YW50aXR5KHVwY29taW5nLm5leHRXZWVrLnF1YW50aXR5KTtcclxuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MubmV4dFdlZWsudGltZSh1cGNvbWluZy5uZXh0V2Vlay50aW1lICYmIG5ldyBEYXRlKHVwY29taW5nLm5leHRXZWVrLnRpbWUpKTtcclxuICAgIH0pXHJcbiAgICAuY2F0Y2gocHJlYXBhcmVTaG93RXJyb3JGb3IoJ0Vycm9yIGxvYWRpbmcgdXBjb21pbmcgYm9va2luZ3MnKSlcclxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIEZpbmFsbHlcclxuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBNZXNzYWdlc1xyXG4gICAgdmFyIE1lc3NhZ2VWaWV3ID0gcmVxdWlyZSgnLi4vbW9kZWxzL01lc3NhZ2VWaWV3Jyk7XHJcbiAgICBpZiAodi5pbmJveC5tZXNzYWdlcygpLmxlbmd0aClcclxuICAgICAgICB2LmluYm94LmlzU3luY2luZyh0cnVlKTtcclxuICAgIGVsc2VcclxuICAgICAgICB2LmluYm94LmlzTG9hZGluZyh0cnVlKTtcclxuICAgIGFwcE1vZGVsLm1lc3NhZ2luZy5nZXRMaXN0KClcclxuICAgIC50aGVuKGZ1bmN0aW9uKHRocmVhZHMpIHtcclxuICAgICAgICB2LmluYm94Lm1lc3NhZ2VzKHRocmVhZHMoKS5tYXAoTWVzc2FnZVZpZXcuZnJvbVRocmVhZC5iaW5kKG51bGwsIGFwcCkpKTtcclxuICAgIH0pXHJcbiAgICAuY2F0Y2gocHJlYXBhcmVTaG93RXJyb3JGb3IoJ0Vycm9yIGxvYWRpbmcgbGF0ZXN0IG1lc3NhZ2VzJykpXHJcbiAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBGaW5hbGx5XHJcbiAgICAgICAgdi5pbmJveC5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHYuaW5ib3guaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcbnZhciBVcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeSA9IHJlcXVpcmUoJy4uL21vZGVscy9VcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeScpLFxyXG4gICAgTWFpbEZvbGRlciA9IHJlcXVpcmUoJy4uL21vZGVscy9NYWlsRm9sZGVyJyksXHJcbiAgICBQZXJmb3JtYW5jZVN1bW1hcnkgPSByZXF1aXJlKCcuLi9tb2RlbHMvUGVyZm9ybWFuY2VTdW1tYXJ5JyksXHJcbiAgICBHZXRNb3JlID0gcmVxdWlyZSgnLi4vbW9kZWxzL0dldE1vcmUnKTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcclxuXHJcbiAgICB0aGlzLnVwY29taW5nQm9va2luZ3MgPSBuZXcgVXBjb21pbmdCb29raW5nc1N1bW1hcnkoKTtcclxuICAgIHRoaXMudXBjb21pbmdCb29raW5ncy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMudXBjb21pbmdCb29raW5ncy5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLm5leHRCb29raW5nID0ga28ub2JzZXJ2YWJsZShudWxsKTtcclxuICAgIHRoaXMubmV4dEJvb2tpbmcuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICB0aGlzLm5leHRCb29raW5nLmlzU3luY2luZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgXHJcbiAgICB0aGlzLmluYm94ID0gbmV3IE1haWxGb2xkZXIoe1xyXG4gICAgICAgIHRvcE51bWJlcjogNFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmluYm94LmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy5pbmJveC5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIFxyXG4gICAgdGhpcy5wZXJmb3JtYW5jZSA9IG5ldyBQZXJmb3JtYW5jZVN1bW1hcnkoKTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRNb3JlID0gbmV3IEdldE1vcmUoKTtcclxufVxyXG5cclxuLyoqIFRFU1RJTkcgREFUQSAqKi9cclxuZnVuY3Rpb24gc2V0U29tZVRlc3RpbmdEYXRhKHZpZXdNb2RlbCkge1xyXG4gICAgXHJcbiAgICB2aWV3TW9kZWwucGVyZm9ybWFuY2UuZWFybmluZ3MuY3VycmVudEFtb3VudCgyNDAwKTtcclxuICAgIHZpZXdNb2RlbC5wZXJmb3JtYW5jZS5lYXJuaW5ncy5uZXh0QW1vdW50KDYyMDAuNTQpO1xyXG4gICAgdmlld01vZGVsLnBlcmZvcm1hbmNlLnRpbWVCb29rZWQucGVyY2VudCgwLjkzKTtcclxuICAgIFxyXG4gICAgdmlld01vZGVsLmdldE1vcmUubW9kZWwudXBkYXRlV2l0aCh7XHJcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBmYWxzZSxcclxuICAgICAgICBwYXltZW50czogdHJ1ZSxcclxuICAgICAgICBwcm9maWxlOiB0cnVlLFxyXG4gICAgICAgIGNvb3A6IGZhbHNlXHJcbiAgICB9KTtcclxufVxyXG4iLCIvKipcclxuICAgIEluYm94IGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNZXNzYWdlVmlldyA9IHJlcXVpcmUoJy4uL21vZGVscy9NZXNzYWdlVmlldycpLFxyXG4gICAgdGV4dFNlYXJjaCA9IHJlcXVpcmUoJy4uL3V0aWxzL3RleHRTZWFyY2gnKTtcclxuXHJcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBJbmJveEFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICBcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignSW5ib3gnKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgXHJcbiAgICAvLyBNZXNzYWdlc1xyXG4gICAgdGhpcy5hcHAubW9kZWwubWVzc2FnaW5nLmdldExpc3QoKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24odGhyZWFkcykge1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLnNvdXJjZVRocmVhZHModGhyZWFkcygpKTtcclxuICAgIH0uYmluZCh0aGlzKSlcclxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIG1lc3NhZ2VzJyxcclxuICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuICAgIFxyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBhcHAubW9kZWwubWVzc2FnaW5nLnN0YXRlLmlzTG9hZGluZztcclxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5zdGF0ZS5pc1N5bmNpbmc7XHJcblxyXG4gICAgdGhpcy5zb3VyY2VUaHJlYWRzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuICAgIFxyXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICBcclxuICAgIC8vIE5PVEU6IHNpbmNlIGN1cnJlbnQgQVBJLWNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24gb25seSBnZXRzXHJcbiAgICAvLyB0aGUgbGF0ZXN0IG1lc3NhZ2Ugd2l0aCBnZXRMaXN0LCB0aGUgc2VhcmNoIGlzIGRvbmUgaW4gdGhlXHJcbiAgICAvLyBib2R5VGV4dCBvZiB0aGUgbGFzdCBtZXNzYWdlIChhZGRpdGlvbmFsbHkgdG8gdGhlIHRocmVhZCBzdWJqZWN0KVxyXG4gICAgLy8gZXZlbiBpZiB0aGlzIGltcGxlbWVudGF0aW9uIHRyeSB0byBpdGVyYXRlIGFsbCBtZXNzYWdlcy5cclxuICAgIHRoaXMudGhyZWFkcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXMuc291cmNlVGhyZWFkcygpLFxyXG4gICAgICAgICAgICBzID0gdGhpcy5zZWFyY2hUZXh0KCk7XHJcblxyXG4gICAgICAgIGlmICghdClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIGVsc2UgaWYgKCFzKVxyXG4gICAgICAgICAgICByZXR1cm4gdC5tYXAoTWVzc2FnZVZpZXcuZnJvbVRocmVhZC5iaW5kKG51bGwsIGFwcCkpO1xyXG4gICAgICAgIGVsc2UgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gdC5maWx0ZXIoZnVuY3Rpb24odGhyZWFkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgc3ViamVjdFxyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0ZXh0U2VhcmNoKHMsIHRocmVhZC5zdWJqZWN0KCkpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGNvbnRlbnQgb2YgbWVzc2FnZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBzdG9wcyBvbiBmaXJzdCAndHJ1ZScgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyZWFkLm1lc3NhZ2VzKCkuc29tZShmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0ZXh0U2VhcmNoKHMsIG1zZy5ib2R5VGV4dCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgICAgIH0pLm1hcChNZXNzYWdlVmlldy5mcm9tVGhyZWFkLmJpbmQobnVsbCwgYXBwKSk7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG4iLCIvKipcclxuICAgIEluZGV4IGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gSW5kZXhBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAvLyBBbnkgdXNlciBjYW4gYWNjZXNzIHRoaXNcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSBudWxsO1xyXG4gICAgXHJcbiAgICAvLyBudWxsIGZvciBsb2dvXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIobnVsbCk7XHJcbiAgICB0aGlzLm5hdkJhci5yaWdodEFjdGlvbihudWxsKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcbiAgICBcclxuICAgIC8vIEl0IGNoZWNrcyBpZiB0aGUgdXNlciBpcyBsb2dnZWQgc28gdGhlbiBcclxuICAgIC8vIHRoZWlyICdsb2dnZWQgaW5kZXgnIGlzIHRoZSBkYXNoYm9hcmQgbm90IHRoaXNcclxuICAgIC8vIHBhZ2UgdGhhdCBpcyBmb2N1c2VkIG9uIGFub255bW91cyB1c2Vyc1xyXG4gICAgaWYgKCF0aGlzLmFwcC5tb2RlbC51c2VyKCkuaXNBbm9ueW1vdXMoKSkge1xyXG4gICAgICAgIHRoaXMuYXBwLmdvRGFzaGJvYXJkKCk7XHJcbiAgICB9XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgSm9idGl0bGVzIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gSm9idGl0bGVzQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycsIHtcclxuICAgICAgICBiYWNrTGluazogJy9zY2hlZHVsaW5nJ1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIE9uIGNoYW5naW5nIGpvYlRpdGxlSUQ6XHJcbiAgICAvLyAtIGxvYWQgYWRkcmVzc2VzXHJcbiAgICAvLyAtIGxvYWQgam9iIHRpdGxlIGluZm9ybWF0aW9uXHJcbiAgICAvLyAtIGxvYWQgcHJpY2luZ1xyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoam9iVGl0bGVJRCkge1xyXG4gICAgICAgICAgICAgICAgLy8vLy8vLy8vLy8vXHJcbiAgICAgICAgICAgICAgICAvLyBBZGRyZXNzZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuZ2V0TGlzdChqb2JUaXRsZUlEKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obGlzdCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gdGhpcy5hcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5hc01vZGVsKGxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NlcyhsaXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIGFkZHJlc3Nlcy4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy9cclxuICAgICAgICAgICAgICAgIC8vIFByaWNpbmcvU2VydmljZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLmdldExpc3Qoam9iVGl0bGVJRClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGxpc3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nLmFzTW9kZWwobGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucHJpY2luZyhsaXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHNlcnZpY2VzLicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL1xyXG4gICAgICAgICAgICAgICAgLy8gSm9iIFRpdGxlXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgZGF0YSBmb3IgdGhlIEpvYiB0aXRsZSBJRFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwuam9iVGl0bGVzLmdldEpvYlRpdGxlKGpvYlRpdGxlSUQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihqb2JUaXRsZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaWxsIGluIGpvYiB0aXRsZSBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVOYW1lKGpvYlRpdGxlLnNpbmd1bGFyTmFtZSgpKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgam9iIHRpdGxlLicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzZXMoW10pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucHJpY2luZyhbXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZU5hbWUoJ0pvYiBUaXRsZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XHJcblxyXG4gICAgLy8gUmVzZXQ6IGF2b2lkaW5nIGVycm9ycyBiZWNhdXNlIHBlcnNpc3RlZCBkYXRhIGZvciBkaWZmZXJlbnQgSUQgb24gbG9hZGluZ1xyXG4gICAgLy8gb3Igb3V0ZGF0ZWQgaW5mbyBmb3JjaW5nIHVwZGF0ZVxyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCgwKTtcclxuXHJcbiAgICAvLyBQYXJhbWV0ZXJzXHJcbiAgICB2YXIgcGFyYW1zID0gc3RhdGUgJiYgc3RhdGUucm91dGUgJiYgc3RhdGUucm91dGUuc2VnbWVudHMgfHwge307XHJcbiAgICBcclxuICAgIC8vIFNldCB0aGUgam9iIHRpdGxlXHJcbiAgICB2YXIgam9iSUQgPSBwYXJhbXNbMF0gfDA7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYklEKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuICAgIFxyXG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIHRoaXMuam9iVGl0bGVOYW1lID0ga28ub2JzZXJ2YWJsZSgnSm9iIFRpdGxlJyk7XHJcbiAgICBcclxuICAgIHRoaXMuYWRkcmVzc2VzID0ga28ub2JzZXJ2YWJsZShbXSk7XHJcbiAgICB0aGlzLnByaWNpbmcgPSBrby5vYnNlcnZhYmxlKFtdKTtcclxuXHJcbiAgICAvLyBDb21wdXRlZCBzaW5jZSBpdCBjYW4gY2hlY2sgc2V2ZXJhbCBleHRlcm5hIGxvYWRpbmdzXHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBhcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zdGF0ZS5pc0xvYWRpbmcoKSB8fFxyXG4gICAgICAgICAgICBhcHAubW9kZWwuZnJlZWxhbmNlclByaWNpbmcuc3RhdGUuaXNMb2FkaW5nKClcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuYWRkcmVzc2VzQ291bnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVE9ETyBsMTBuLlxyXG4gICAgICAgIC8vIFVzZSBpMThuZXh0IHBsdXJhbCBsb2NhbGl6YXRpb24gc3VwcG9ydCByYXRoZXIgdGhhbiB0aGlzIG1hbnVhbC5cclxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmFkZHJlc3NlcygpLmxlbmd0aCxcclxuICAgICAgICAgICAgb25lID0gJzEgbG9jYXRpb24nLFxyXG4gICAgICAgICAgICBtb3JlID0gJyBsb2NhdGlvbnMnO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjb3VudCA9PT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIG9uZTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIC8vIFNtYWxsIG51bWJlcnMsIG5vIG5lZWQgZm9yIGZvcm1hdHRpbmdcclxuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgbW9yZTtcclxuXHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5wcmljaW5nQ291bnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVE9ETyBsMTBuLlxyXG4gICAgICAgIC8vIFVzZSBpMThuZXh0IHBsdXJhbCBsb2NhbGl6YXRpb24gc3VwcG9ydCByYXRoZXIgdGhhbiB0aGlzIG1hbnVhbC5cclxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLnByaWNpbmcoKS5sZW5ndGgsXHJcbiAgICAgICAgICAgIG9uZSA9ICcxIHNlcnZpY2UnLFxyXG4gICAgICAgICAgICBtb3JlID0gJyBzZXJ2aWNlcyc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gb25lO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgLy8gU21hbGwgbnVtYmVycywgbm8gbmVlZCBmb3IgZm9ybWF0dGluZ1xyXG4gICAgICAgICAgICByZXR1cm4gY291bnQgKyBtb3JlO1xyXG5cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbn1cclxuIiwiLyoqXHJcbiAgICBMZWFybk1vcmUgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIExlYXJuTW9yZUFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSBudWxsO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIC8vIG51bGwgZm9yIGxvZ29cclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcihudWxsKTtcclxuICAgIHRoaXMubmF2QmFyLnJpZ2h0QWN0aW9uKG51bGwpO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiZcclxuICAgICAgICBvcHRpb25zLnJvdXRlLnNlZ21lbnRzICYmXHJcbiAgICAgICAgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcm9maWxlKG9wdGlvbnMucm91dGUuc2VnbWVudHNbMF0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKCkge1xyXG4gICAgdGhpcy5wcm9maWxlID0ga28ub2JzZXJ2YWJsZSgnY3VzdG9tZXInKTtcclxufVxyXG4iLCIvKipcclxuICAgIExvZ2luIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gTG9naW5BY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuQW5vbnltb3VzO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignTG9nIGluJyk7XHJcbiAgICB0aGlzLm5hdkJhci5yaWdodEFjdGlvbihudWxsKTtcclxuICAgIFxyXG4gICAgLy8gUGVyZm9ybSBsb2ctaW4gcmVxdWVzdCB3aGVuIGlzIHJlcXVlc3RlZCBieSB0aGUgZm9ybTpcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmlzTG9naW5nSW4sXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gbG9naW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHN0YXRlOlxyXG4gICAgICAgICAgICAgICAgdmFyICRidG4gPSB0aGlzLiRhY3Rpdml0eS5maW5kKCdbdHlwZT1cInN1Ym1pdFwiXScpO1xyXG4gICAgICAgICAgICAgICAgJGJ0bi5idXR0b24oJ2xvYWRpbmcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBlcnJvciBzbyBtYWtlcyBjbGVhciB3ZVxyXG4gICAgICAgICAgICAgICAgLy8gYXJlIGF0dGVtcHRpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxvZ2luRXJyb3IoJycpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBlbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9naW5nSW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICRidG4uYnV0dG9uKCdyZXNldCcpO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFmdGVyIGNsZWFuLXVwIGVycm9yICh0byBmb3JjZSBzb21lIHZpZXcgdXBkYXRlcyksXHJcbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSBhbmQgYWJvcnQgb24gZXJyb3JcclxuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNoZWNraW5nIGVycm9yIG9uIGVhY2ggZmllbGRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlbC51c2VybmFtZS5lcnJvcigpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucGFzc3dvcmQuZXJyb3IoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxvZ2luRXJyb3IoJ1JldmlldyB5b3VyIGRhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5sb2dpbihcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC51c2VybmFtZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnBhc3N3b3JkKClcclxuICAgICAgICAgICAgICAgICkudGhlbihmdW5jdGlvbigvKmxvZ2luRGF0YSovKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxvZ2luRXJyb3IoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZGVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmb3JtIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC51c2VybmFtZSgnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucGFzc3dvcmQoJycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5nb0Rhc2hib2FyZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBlcnIgJiYgZXJyLnJlc3BvbnNlSlNPTiAmJiBlcnIucmVzcG9uc2VKU09OLmVycm9yTWVzc2FnZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgJiYgZXJyLnN0YXR1c1RleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgdXNlcm5hbWUgb3IgcGFzc3dvcmQnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kZWQoKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBGb2N1cyBmaXJzdCBiYWQgZmllbGQgb24gZXJyb3JcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmxvZ2luRXJyb3IsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIExvZ2luIGlzIGVhc3kgc2luY2Ugd2UgbWFyayBib3RoIHVuaXF1ZSBmaWVsZHNcclxuICAgICAgICAgICAgLy8gYXMgZXJyb3Igb24gbG9naW5FcnJvciAoaXRzIGEgZ2VuZXJhbCBmb3JtIGVycm9yKVxyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCc6aW5wdXQnKS5nZXQoMCk7XHJcbiAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBpbnB1dC5ibHVyKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG52YXIgRm9ybUNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9Gb3JtQ3JlZGVudGlhbHMnKTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcclxuXHJcbiAgICB2YXIgY3JlZGVudGlhbHMgPSBuZXcgRm9ybUNyZWRlbnRpYWxzKCk7ICAgIFxyXG4gICAgdGhpcy51c2VybmFtZSA9IGNyZWRlbnRpYWxzLnVzZXJuYW1lO1xyXG4gICAgdGhpcy5wYXNzd29yZCA9IGNyZWRlbnRpYWxzLnBhc3N3b3JkO1xyXG5cclxuICAgIHRoaXMubG9naW5FcnJvciA9IGtvLm9ic2VydmFibGUoJycpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzTG9naW5nSW4gPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIFxyXG4gICAgdGhpcy5wZXJmb3JtTG9naW4gPSBmdW5jdGlvbiBwZXJmb3JtTG9naW4oKSB7XHJcblxyXG4gICAgICAgIHRoaXMuaXNMb2dpbmdJbih0cnVlKTsgICAgICAgIFxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgTG9nb3V0IGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gTG9nb3V0QWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICB0aGlzLmFwcC5tb2RlbC5sb2dvdXQoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIEFub255bW91cyB1c2VyIGFnYWluXHJcbiAgICAgICAgdmFyIG5ld0Fub24gPSB0aGlzLmFwcC5tb2RlbC51c2VyKCkuY29uc3RydWN0b3IubmV3QW5vbnltb3VzKCk7XHJcbiAgICAgICAgdGhpcy5hcHAubW9kZWwudXNlcigpLm1vZGVsLnVwZGF0ZVdpdGgobmV3QW5vbik7XHJcblxyXG4gICAgICAgIC8vIEdvIGluZGV4XHJcbiAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ28oJy8nKTtcclxuICAgICAgICBcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgT3duZXJJbmZvIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gT3duZXJJbmZvQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7XHJcbiAgICBcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignQWNjb3VudCcsIHtcclxuICAgICAgICBiYWNrTGluazogJ2FjY291bnQnXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcbiIsIi8qKlxyXG4gICAgUHJpdmFjeVNldHRpbmdzIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gUHJpdmFjeVNldHRpbmdzQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcclxuXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0FjY291bnQnLCB7XHJcbiAgICAgICAgYmFja0xpbms6ICdhY2NvdW50J1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLnByaXZhY3lTZXR0aW5ncyxcclxuICAgICAgICBldmVudDogJ2Vycm9yJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgdmFyIG1zZyA9IGVyci50YXNrID09PSAnc2F2ZScgPyAnRXJyb3Igc2F2aW5nIHByaXZhY3kgc2V0dGluZ3MuJyA6ICdFcnJvciBsb2FkaW5nIHByaXZhY3kgc2V0dGluZ3MuJztcclxuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XHJcbiAgICB0aGlzLmFwcC5tb2RlbC5wcml2YWN5U2V0dGluZ3Muc3luYygpO1xyXG4gICAgLy8gRGlzY2FyZCBhbnkgcHJldmlvdXMgdW5zYXZlZCBlZGl0XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5kaXNjYXJkKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcblxyXG4gICAgdmFyIHByaXZhY3lTZXR0aW5ncyA9IGFwcC5tb2RlbC5wcml2YWN5U2V0dGluZ3M7XHJcblxyXG4gICAgdmFyIHNldHRpbmdzVmVyc2lvbiA9IHByaXZhY3lTZXR0aW5ncy5uZXdWZXJzaW9uKCk7XHJcbiAgICBzZXR0aW5nc1ZlcnNpb24uaXNPYnNvbGV0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oaXRJcykge1xyXG4gICAgICAgIGlmIChpdElzKSB7XHJcbiAgICAgICAgICAgIC8vIG5ldyB2ZXJzaW9uIGZyb20gc2VydmVyIHdoaWxlIGVkaXRpbmdcclxuICAgICAgICAgICAgLy8gRlVUVVJFOiB3YXJuIGFib3V0IGEgbmV3IHJlbW90ZSB2ZXJzaW9uIGFza2luZ1xyXG4gICAgICAgICAgICAvLyBjb25maXJtYXRpb24gdG8gbG9hZCB0aGVtIG9yIGRpc2NhcmQgYW5kIG92ZXJ3cml0ZSB0aGVtO1xyXG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBpcyBuZWVkIG9uIHNhdmUoKSwgYW5kIG9uIHNlcnZlciByZXNwb25zZVxyXG4gICAgICAgICAgICAvLyB3aXRoIGEgNTA5OkNvbmZsaWN0IHN0YXR1cyAoaXRzIGJvZHkgbXVzdCBjb250YWluIHRoZVxyXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgdmVyc2lvbikuXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0IG5vdywganVzdCBvdmVyd3JpdGUgY3VycmVudCBjaGFuZ2VzIHdpdGhcclxuICAgICAgICAgICAgLy8gcmVtb3RlIG9uZXM6XHJcbiAgICAgICAgICAgIHNldHRpbmdzVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEFjdHVhbCBkYXRhIGZvciB0aGUgZm9ybTpcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5nc1ZlcnNpb24udmVyc2lvbjtcclxuXHJcbiAgICB0aGlzLmlzTG9ja2VkID0gcHJpdmFjeVNldHRpbmdzLmlzTG9ja2VkO1xyXG5cclxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXHJcbiAgICAgICAgICAgICAgICAnbG9hZGluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgICAgICdzYXZpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHByaXZhY3lTZXR0aW5ncyk7XHJcbiAgICBcclxuICAgIHRoaXMuZGlzY2FyZCA9IGZ1bmN0aW9uIGRpc2NhcmQoKSB7XHJcbiAgICAgICAgc2V0dGluZ3NWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xyXG4gICAgICAgIHNldHRpbmdzVmVyc2lvbi5wdXNoU2F2ZSgpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgU2NoZWR1bGluZyBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxyXG4gICAgVXNlckpvYlByb2ZpbGVWaWV3TW9kZWwgPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL1VzZXJKb2JQcm9maWxlJyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gU2NoZWR1bGluZ0FjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVXNlckpvYlByb2ZpbGVWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJyk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG5cclxuICAgIHRoaXMudmlld01vZGVsLnN5bmMoKTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBTY2hlZHVsaW5nUHJlZmVyZW5jZXMgYWN0aXZpdHlcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFNjaGVkdWxpbmdQcmVmZXJlbmNlc0FjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XHJcblxyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnc2NoZWR1bGluZydcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5zY2hlZHVsaW5nUHJlZmVyZW5jZXMsXHJcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSBlcnIudGFzayA9PT0gJ3NhdmUnID8gJ0Vycm9yIHNhdmluZyBzY2hlZHVsaW5nIHByZWZlcmVuY2VzLicgOiAnRXJyb3IgbG9hZGluZyBzY2hlZHVsaW5nIHByZWZlcmVuY2VzLic7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLnRhc2sgJiYgZXJyLmVycm9yIHx8IGVyclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcclxuICAgIFxyXG4gICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XHJcbiAgICB0aGlzLmFwcC5tb2RlbC5zY2hlZHVsaW5nUHJlZmVyZW5jZXMuc3luYygpO1xyXG4gICAgLy8gRGlzY2FyZCBhbnkgcHJldmlvdXMgdW5zYXZlZCBlZGl0XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5kaXNjYXJkKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XHJcblxyXG4gICAgdmFyIHNjaGVkdWxpbmdQcmVmZXJlbmNlcyA9IGFwcC5tb2RlbC5zY2hlZHVsaW5nUHJlZmVyZW5jZXM7XHJcblxyXG4gICAgdmFyIHByZWZzVmVyc2lvbiA9IHNjaGVkdWxpbmdQcmVmZXJlbmNlcy5uZXdWZXJzaW9uKCk7XHJcbiAgICBwcmVmc1ZlcnNpb24uaXNPYnNvbGV0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oaXRJcykge1xyXG4gICAgICAgIGlmIChpdElzKSB7XHJcbiAgICAgICAgICAgIC8vIG5ldyB2ZXJzaW9uIGZyb20gc2VydmVyIHdoaWxlIGVkaXRpbmdcclxuICAgICAgICAgICAgLy8gRlVUVVJFOiB3YXJuIGFib3V0IGEgbmV3IHJlbW90ZSB2ZXJzaW9uIGFza2luZ1xyXG4gICAgICAgICAgICAvLyBjb25maXJtYXRpb24gdG8gbG9hZCB0aGVtIG9yIGRpc2NhcmQgYW5kIG92ZXJ3cml0ZSB0aGVtO1xyXG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBpcyBuZWVkIG9uIHNhdmUoKSwgYW5kIG9uIHNlcnZlciByZXNwb25zZVxyXG4gICAgICAgICAgICAvLyB3aXRoIGEgNTA5OkNvbmZsaWN0IHN0YXR1cyAoaXRzIGJvZHkgbXVzdCBjb250YWluIHRoZVxyXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgdmVyc2lvbikuXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0IG5vdywganVzdCBvdmVyd3JpdGUgY3VycmVudCBjaGFuZ2VzIHdpdGhcclxuICAgICAgICAgICAgLy8gcmVtb3RlIG9uZXM6XHJcbiAgICAgICAgICAgIHByZWZzVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEFjdHVhbCBkYXRhIGZvciB0aGUgZm9ybTpcclxuICAgIHRoaXMucHJlZnMgPSBwcmVmc1ZlcnNpb24udmVyc2lvbjtcclxuXHJcbiAgICB0aGlzLmlzTG9ja2VkID0gc2NoZWR1bGluZ1ByZWZlcmVuY2VzLmlzTG9ja2VkO1xyXG5cclxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXHJcbiAgICAgICAgICAgICAgICAnbG9hZGluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgICAgICdzYXZpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHNjaGVkdWxpbmdQcmVmZXJlbmNlcyk7XHJcbiAgICBcclxuICAgIHRoaXMuZGlzY2FyZCA9IGZ1bmN0aW9uIGRpc2NhcmQoKSB7XHJcbiAgICAgICAgcHJlZnNWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xyXG4gICAgICAgIHByZWZzVmVyc2lvbi5wdXNoU2F2ZSgpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmluY3JlbWVudHNFeGFtcGxlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzdHIgPSAnZS5nLiAnLFxyXG4gICAgICAgICAgICBpbmNTaXplID0gdGhpcy5pbmNyZW1lbnRzU2l6ZUluTWludXRlcygpLFxyXG4gICAgICAgICAgICBtID0gbW9tZW50KHsgaG91cjogMTAsIG1pbnV0ZTogMCB9KSxcclxuICAgICAgICAgICAgaG91cnMgPSBbbS5mb3JtYXQoJ0hIOm1tJyldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGhvdXJzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBtLmFkZChpbmNTaXplLCAnbWludXRlcycpXHJcbiAgICAgICAgICAgICAgICAuZm9ybWF0KCdISDptbScpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0ciArPSBob3Vycy5qb2luKCcsICcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgXHJcbiAgICB9LCB0aGlzLnByZWZzKTtcclxufVxyXG4iLCIvKipcclxuICAgIFNlcnZpY2UgQWRkcmVzc2VzIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gU2VydmljZUFkZHJlc3Nlc0FjdGl2aXR5KCkge1xyXG5cclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkZyZWVsYW5jZXI7XHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xyXG4gICAgLy8gRGVmYXVsdHMgc2V0dGluZ3MgZm9yIG5hdkJhci5cclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignSm9iIFRpdGxlJywge1xyXG4gICAgICAgIGJhY2tMaW5rOiAnL3NjaGVkdWxpbmcnXHJcbiAgICB9KTtcclxuICAgIC8vIFNhdmUgZGVmYXVsdHMgdG8gcmVzdG9yZSBvbiB1cGRhdGVOYXZCYXJTdGF0ZSB3aGVuIG5lZWRlZDpcclxuICAgIHRoaXMuZGVmYXVsdExlZnRBY3Rpb24gPSB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkubW9kZWwudG9QbGFpbk9iamVjdCgpO1xyXG5cclxuICAgIC8vIE9uIGNoYW5naW5nIGpvYlRpdGxlSUQ6XHJcbiAgICAvLyAtIGxvYWQgYWRkcmVzc2VzXHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlELFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAgICAgaWYgKGpvYlRpdGxlSUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBmb3IgdXNlIGluIHRoZSB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGUoam9iVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBuYXZiYXIgKG1heSBpbmRpY2F0ZSB0aGUgam9iVGl0bGUgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGFkZHJlc3Nlc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldExpc3Qoam9iVGl0bGVJRCk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmFzTW9kZWwobGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc291cmNlQWRkcmVzc2VzKGxpc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnNvdXJjZUFkZHJlc3NlcyhbXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEdvIGJhY2sgd2l0aCB0aGUgc2VsZWN0ZWQgYWRkcmVzcyB3aGVuIHRyaWdnZXJlZCBpbiB0aGUgZm9ybS92aWV3XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXR1cm5TZWxlY3RlZCA9IGZ1bmN0aW9uKGFkZHJlc3NJRCwgam9iVGl0bGVJRCkge1xyXG4gICAgICAgIC8vIFBhc3MgdGhlIHNlbGVjdGVkIGNsaWVudCBpbiB0aGUgaW5mb1xyXG4gICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRBZGRyZXNzSUQgPSBhZGRyZXNzSUQ7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZEpvYlRpdGxlSUQgPSBqb2JUaXRsZUlEO1xyXG4gICAgICAgIC8vIEFuZCBnbyBiYWNrXHJcbiAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnJldHVyblJlcXVlc3QgPSBmdW5jdGlvbiByZXR1cm5SZXF1ZXN0KCkge1xyXG4gICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xyXG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eToxMFxyXG5cclxuICAgIHZhciBpdElzID0gdGhpcy52aWV3TW9kZWwuaXNTZWxlY3Rpb25Nb2RlKCk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsLmhlYWRlclRleHQoaXRJcyA/ICdTZWxlY3Qgb3IgYWRkIGEgc2VydmljZSBsb2NhdGlvbicgOiAnTG9jYXRpb25zJyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmFwcC5tb2RlbC5vbmJvYXJkaW5nLnVwZGF0ZU5hdkJhcih0aGlzLm5hdkJhcikpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEudGl0bGUpIHtcclxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aXRsZSBieSB0aXRsZSBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICB0aGlzLm5hdkJhci50aXRsZSh0aGlzLnJlcXVlc3REYXRhLnRpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRpdGxlIG11c3QgYmUgZW1wdHlcclxuICAgICAgICAgICAgdGhpcy5uYXZCYXIudGl0bGUoJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRUb0NhbmNlbEFjdGlvbih0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCksIHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0byBkZWZhdWx0cywgb3IgZ2l2ZW4gdGl0bGU6XHJcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5tb2RlbC51cGRhdGVXaXRoKHRoaXMuZGVmYXVsdExlZnRBY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5uYXZUaXRsZSlcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KHRoaXMucmVxdWVzdERhdGEubmF2VGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGppZCA9IHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoKSxcclxuICAgICAgICAgICAgICAgIGpuYW1lID0gdGhpcy52aWV3TW9kZWwuam9iVGl0bGUoKSAmJiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZSgpLnNpbmd1bGFyTmFtZSgpIHx8ICdTY2hlZHVsaW5nJztcclxuXHJcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5saW5rKGppZCA/ICcvam9idGl0bGVzLycgKyBqaWQgOiAnL3NjaGVkdWxpbmcnKTtcclxuICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLnRleHQoam5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGl0SXMgJiYgIXRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgICAgICAvLyBVc2VzIGEgY3VzdG9tIGhhbmRsZXIgc28gaXQgcmV0dXJucyBrZWVwaW5nIHRoZSBnaXZlbiBzdGF0ZTpcclxuICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLmhhbmRsZXIodGhpcy5yZXR1cm5SZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xyXG4gICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkuaGFuZGxlcihudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIFJlc2V0OiBhdm9pZGluZyBlcnJvcnMgYmVjYXVzZSBwZXJzaXN0ZWQgZGF0YSBmb3IgZGlmZmVyZW50IElEIG9uIGxvYWRpbmdcclxuICAgIC8vIG9yIG91dGRhdGVkIGluZm8gZm9yY2luZyB1cGRhdGVcclxuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoMCk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXF1ZXN0RGF0YSA9IHRoaXMucmVxdWVzdERhdGE7XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuaXNTZWxlY3Rpb25Nb2RlKG9wdGlvbnMuc2VsZWN0QWRkcmVzcyA9PT0gdHJ1ZSk7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRJRChvcHRpb25zLmNsaWVudElEIHx8IG51bGwpO1xyXG5cclxuICAgIHZhciBwYXJhbXMgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cztcclxuICAgIHZhciBqb2JUaXRsZUlEID0gcGFyYW1zWzBdIHwwO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBpdCBjb21lcyBmcm9tIGFuIGFkZHJlc3NFZGl0b3IgdGhhdFxyXG4gICAgLy8gcmVjZWl2ZWQgdGhlIGZsYWcgJ3JldHVybk5ld0FzU2VsZWN0ZWQnIGFuZCBhblxyXG4gICAgLy8gYWRkcmVzc0lEOiB3ZSB3ZXJlIGluIHNlbGVjdGlvbiBtb2RlLT5jcmVhdGluZyBhZGRyZXNzLT5tdXN0XHJcbiAgICAvLyByZXR1cm4gdGhlIGp1c3QgY3JlYXRlZCBhZGRyZXNzIHRvIHRoZSBwcmV2aW91cyBwYWdlXHJcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5OZXdBc1NlbGVjdGVkID09PSB0cnVlICYmXHJcbiAgICAgICAgb3B0aW9ucy5hZGRyZXNzSUQpIHtcclxuICAgICAgICBcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5yZXR1cm5OZXdBc1NlbGVjdGVkO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5yZXR1cm5TZWxlY3RlZChvcHRpb25zLmFkZHJlc3NJRCwgam9iVGl0bGVJRCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCAxKTtcclxuICAgICAgICAvLyBxdWljayByZXR1cm5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRChqb2JUaXRsZUlEKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XHJcbiAgICBcclxuICAgIGlmIChqb2JUaXRsZUlEID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVzLnN5bmMoKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBVc2VySm9iUHJvZmlsZSA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvVXNlckpvYlByb2ZpbGUnKTtcclxuXHJcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcclxuXHJcbiAgICB0aGlzLmhlYWRlclRleHQgPSBrby5vYnNlcnZhYmxlKCdMb2NhdGlvbnMnKTtcclxuICAgIFxyXG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcclxuICAgIHRoaXMuam9iVGl0bGUgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgLy8gRXNwZWNpYWwgbW9kZSB3aGVuIGluc3RlYWQgb2YgcGljayBhbmQgZWRpdCB3ZSBhcmUganVzdCBzZWxlY3RpbmdcclxuICAgIC8vICh3aGVuIGVkaXRpbmcgYW4gYXBwb2ludG1lbnQpXHJcbiAgICB0aGlzLmlzU2VsZWN0aW9uTW9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgLy8gT3B0aW9uYWxseSwgc29tZSB0aW1lcyBhIGNsaWVudElEIGNhbiBiZSBwYXNzZWQgaW4gb3JkZXIgdG8gY3JlYXRlXHJcbiAgICAvLyBhIGxvY2F0aW9uIGZvciB0aGF0IGNsaWVudCB3aGVyZSBwZXJmb3JtIGEgd29yay5cclxuICAgIHRoaXMuY2xpZW50SUQgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xyXG4gICAgXHJcbiAgICB0aGlzLmpvYlRpdGxlcyA9IG5ldyBVc2VySm9iUHJvZmlsZShhcHApO1xyXG4gICAgdGhpcy5qb2JUaXRsZXMuYmFzZVVybCgnL3NlcnZpY2VBZGRyZXNzJyk7XHJcbiAgICB0aGlzLmpvYlRpdGxlcy5zZWxlY3RKb2JUaXRsZSA9IGZ1bmN0aW9uKGpvYlRpdGxlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5qb2JUaXRsZUlEKGpvYlRpdGxlLmpvYlRpdGxlSUQoKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIExpc3Qgb2YgYWRkcmVzc2VzXHJcbiAgICB0aGlzLnNvdXJjZUFkZHJlc3NlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICB0aGlzLmFkZHJlc3NlcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5zb3VyY2VBZGRyZXNzZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGlvbk1vZGUoKSkge1xyXG4gICAgICAgICAgICAvLyBGaWx0ZXIgYnkgc2VydmljZSBhZGRyZXNzZXMgKGV4Y2x1ZGluZyBzZXJ2aWNlIGFyZWEpXHJcbiAgICAgICAgICAgIGxpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbihhZGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGQuaXNTZXJ2aWNlTG9jYXRpb24oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNTeW5jaW5nKCk7XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhZGQgPSBhcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zdGF0ZS5pc0xvYWRpbmcoKSxcclxuICAgICAgICAgICAgam9icyA9IHRoaXMuam9iVGl0bGVzLmlzTG9hZGluZygpO1xyXG4gICAgICAgIHJldHVybiBhZGQgfHwgam9icztcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmdvTmV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChhcHAubW9kZWwub25ib2FyZGluZy5pblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuZ29OZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNlbGVjdEFkZHJlc3MgPSBmdW5jdGlvbihzZWxlY3RlZEFkZHJlc3MsIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3Rpb25Nb2RlKCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gUnVuIG1ldGhvZCBpbmplY3RlZCBieSB0aGUgYWN0aXZpdHkgdG8gcmV0dXJuIGEgXHJcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkIGFkZHJlc3M6XHJcbiAgICAgICAgICAgIHRoaXMucmV0dXJuU2VsZWN0ZWQoXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3MuYWRkcmVzc0lEKCksXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3Muam9iVGl0bGVJRCgpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcHAuc2hlbGwuZ28oJ2FkZHJlc3NFZGl0b3Ivc2VydmljZS8nICtcclxuICAgICAgICAgICAgICAgIHRoaXMuam9iVGl0bGVJRCgpICtcclxuICAgICAgICAgICAgICAgICcvJyArIHNlbGVjdGVkQWRkcmVzcy5hZGRyZXNzSUQoKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5hZGRTZXJ2aWNlTG9jYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdXJsID0gJyMhYWRkcmVzc0VkaXRvci9zZXJ2aWNlLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICcvc2VydmljZUxvY2F0aW9uJztcclxuICAgICAgICB2YXIgcmVxdWVzdCA9ICQuZXh0ZW5kKHt9LCB0aGlzLnJlcXVlc3REYXRhLCB7XHJcbiAgICAgICAgICAgIHJldHVybk5ld0FzU2VsZWN0ZWQ6IHRoaXMuaXNTZWxlY3Rpb25Nb2RlKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBhcHAuc2hlbGwuZ28odXJsLCByZXF1ZXN0KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5hZGRTZXJ2aWNlQXJlYSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB1cmwgPSAnIyFhZGRyZXNzRWRpdG9yL3NlcnZpY2UvJyArIHRoaXMuam9iVGl0bGVJRCgpICsgJy9zZXJ2aWNlQXJlYSc7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAkLmV4dGVuZCh7fSwgdGhpcy5yZXF1ZXN0RGF0YSwge1xyXG4gICAgICAgICAgICByZXR1cm5OZXdBc1NlbGVjdGVkOiB0aGlzLmlzU2VsZWN0aW9uTW9kZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXBwLnNoZWxsLmdvKHVybCwgcmVxdWVzdCk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuYWRkQ2xpZW50TG9jYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdXJsID0gJyMhYWRkcmVzc0VkaXRvci9zZXJ2aWNlLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICcvY2xpZW50TG9jYXRpb24vJyArIHRoaXMuY2xpZW50SUQoKTtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9ICQuZXh0ZW5kKHt9LCB0aGlzLnJlcXVlc3REYXRhLCB7XHJcbiAgICAgICAgICAgIHJldHVybk5ld0FzU2VsZWN0ZWQ6IHRoaXMuaXNTZWxlY3Rpb25Nb2RlKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBhcHAuc2hlbGwuZ28odXJsLCByZXF1ZXN0KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5vbmJvYXJkaW5nTmV4dFJlYWR5ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGlzaW4gPSBhcHAubW9kZWwub25ib2FyZGluZy5pblByb2dyZXNzKCksXHJcbiAgICAgICAgICAgIGhhc0l0ZW1zID0gdGhpcy5zb3VyY2VBZGRyZXNzZXMoKS5sZW5ndGggPiAwO1xyXG5cclxuICAgICAgICByZXR1cm4gaXNpbiAmJiBoYXNJdGVtcztcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgU2lnbnVwIGFjdGl2aXR5XHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gU2lnbnVwQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLkFub255bW91cztcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICAvLyBudWxsIGZvciBMb2dvXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIobnVsbCk7XHJcbiAgICB0aGlzLm5hdkJhci5yaWdodEFjdGlvbihudWxsKTtcclxuICAgIFxyXG4gICAgLy8gUGVyZm9ybSBzaWduLXVwIHJlcXVlc3Qgd2hlbiBpcyByZXF1ZXN0ZWQgYnkgdGhlIGZvcm06XHJcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XHJcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5pc1NpZ25pbmdVcCxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIGlmICh2ID09PSB0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBzaWdudXBcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgc3RhdGU6XHJcbiAgICAgICAgICAgICAgICB2YXIgJGJ0biA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJ1t0eXBlPVwic3VibWl0XCJdJyk7XHJcbiAgICAgICAgICAgICAgICAkYnRuLmJ1dHRvbignbG9hZGluZycpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGVycm9yIHNvIG1ha2VzIGNsZWFyIHdlXHJcbiAgICAgICAgICAgICAgICAvLyBhcmUgYXR0ZW1wdGluZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc2lnbnVwRXJyb3IoJycpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBlbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmlzU2lnbmluZ1VwKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAkYnRuLmJ1dHRvbigncmVzZXQnKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZnRlciBjbGVhbi11cCBlcnJvciAodG8gZm9yY2Ugc29tZSB2aWV3IHVwZGF0ZXMpLFxyXG4gICAgICAgICAgICAgICAgLy8gdmFsaWRhdGUgYW5kIGFib3J0IG9uIGVycm9yXHJcbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjaGVja2luZyBlcnJvciBvbiBlYWNoIGZpZWxkXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3TW9kZWwudXNlcm5hbWUuZXJyb3IoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnBhc3N3b3JkLmVycm9yKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5zaWdudXBFcnJvcignUmV2aWV3IHlvdXIgZGF0YScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLnNpZ251cChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC51c2VybmFtZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnBhc3N3b3JkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucHJvZmlsZSgpXHJcbiAgICAgICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24oc2lnbnVwRGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5zaWdudXBFcnJvcignJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBvbmJvYXJkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwub25ib2FyZGluZy5zZXRTdGVwKHNpZ251cERhdGEub25ib2FyZGluZ1N0ZXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZm9ybSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwudXNlcm5hbWUoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnBhc3N3b3JkKCcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAuZ29EYXNoYm9hcmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gZXJyICYmIGVyci5yZXNwb25zZUpTT04gJiYgZXJyLnJlc3BvbnNlSlNPTi5lcnJvck1lc3NhZ2UgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyICYmIGVyci5zdGF0dXNUZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc2lnbnVwRXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmRlZCgpO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEZvY3VzIGZpcnN0IGJhZCBmaWVsZCBvbiBlcnJvclxyXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xyXG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuc2lnbnVwRXJyb3IsXHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIFNpZ251cCBpcyBlYXN5IHNpbmNlIHdlIG1hcmsgYm90aCB1bmlxdWUgZmllbGRzXHJcbiAgICAgICAgICAgIC8vIGFzIGVycm9yIG9uIHNpZ251cEVycm9yIChpdHMgYSBnZW5lcmFsIGZvcm0gZXJyb3IpXHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJzppbnB1dCcpLmdldCgwKTtcclxuICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGlucHV0LmJsdXIoKTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuXHJcbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICBcclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiZcclxuICAgICAgICBvcHRpb25zLnJvdXRlLnNlZ21lbnRzICYmXHJcbiAgICAgICAgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcm9maWxlKG9wdGlvbnMucm91dGUuc2VnbWVudHNbMF0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbnZhciBGb3JtQ3JlZGVudGlhbHMgPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL0Zvcm1DcmVkZW50aWFscycpO1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKCkge1xyXG5cclxuICAgIHZhciBjcmVkZW50aWFscyA9IG5ldyBGb3JtQ3JlZGVudGlhbHMoKTsgICAgXHJcbiAgICB0aGlzLnVzZXJuYW1lID0gY3JlZGVudGlhbHMudXNlcm5hbWU7XHJcbiAgICB0aGlzLnBhc3N3b3JkID0gY3JlZGVudGlhbHMucGFzc3dvcmQ7XHJcblxyXG4gICAgdGhpcy5zaWdudXBFcnJvciA9IGtvLm9ic2VydmFibGUoJycpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzU2lnbmluZ1VwID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICBcclxuICAgIHRoaXMucGVyZm9ybVNpZ251cCA9IGZ1bmN0aW9uIHBlcmZvcm1TaWdudXAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuaXNTaWduaW5nVXAodHJ1ZSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5wcm9maWxlID0ga28ub2JzZXJ2YWJsZSgnY3VzdG9tZXInKTtcclxufVxyXG4iLCIvKipcclxuICAgIHRleHRFZGl0b3IgYWN0aXZpdHlcclxuKiovXHJcbi8vZ2xvYmFsIHdpbmRvd1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxyXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcblxyXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gVGV4dEVkaXRvckFjdGl2aXR5KCkge1xyXG4gICAgXHJcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5Mb2dnZWRVc2VyO1xyXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcclxuICAgIC8vIFRpdGxlIGlzIGVtcHR5LCBzaW5jZSB3ZSBhcmUgaW4gJ2dvIGJhY2snIG1vZGUgYWxsIHRoZSB0aW1lIGhlcmVcclxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignJyk7XHJcbiAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkuaGFuZGxlcihmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xyXG4gICAgfS5iaW5kKHRoaXMudmlld01vZGVsKSk7XHJcbiAgICBcclxuICAgIC8vIEdldHRpbmcgZWxlbWVudHNcclxuICAgIHRoaXMuJHRleHRhcmVhID0gdGhpcy4kYWN0aXZpdHkuZmluZCgndGV4dGFyZWEnKTtcclxuICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLiR0ZXh0YXJlYS5nZXQoMCk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZXIgZm9yIHRoZSAnc2F2ZWQnIGV2ZW50IHNvIHRoZSBhY3Rpdml0eVxyXG4gICAgLy8gcmV0dXJucyBiYWNrIHRvIHRoZSByZXF1ZXN0ZXIgYWN0aXZpdHkgZ2l2aW5nIGl0XHJcbiAgICAvLyB0aGUgbmV3IHRleHRcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLFxyXG4gICAgICAgIGV2ZW50OiAnc2F2ZWQnLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGluZm8gd2l0aCB0aGUgbmV3IHRleHRcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS50ZXh0ID0gdGhpcy52aWV3TW9kZWwudGV4dCgpO1xyXG4gICAgICAgICAgICAvLyBhbmQgcGFzcyBpdCBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcclxuICAgICAgICB9LmJpbmQodGhpcylcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGVyIHRoZSBjYW5jZWwgZXZlbnRcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLFxyXG4gICAgICAgIGV2ZW50OiAnY2FuY2VsJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuLCBub3RoaW5nIGNoYW5nZWRcclxuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgLy8gU2V0IG5hdmlnYXRpb24gdGl0bGUgb3Igbm90aGluZ1xyXG4gICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLnRleHQodGhpcy5yZXF1ZXN0RGF0YS5uYXZUaXRsZSB8fCAnJyk7XHJcbiAgICBcclxuICAgIC8vIEZpZWxkIGhlYWRlclxyXG4gICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyVGV4dCh0aGlzLnJlcXVlc3REYXRhLmhlYWRlcik7XHJcbiAgICB0aGlzLnZpZXdNb2RlbC50ZXh0KHRoaXMucmVxdWVzdERhdGEudGV4dCk7XHJcbiAgICAgICAgXHJcbiAgICAvLyBJbm1lZGlhdGUgZm9jdXMgdG8gdGhlIHRleHRhcmVhIGZvciBiZXR0ZXIgdXNhYmlsaXR5XHJcbiAgICB0aGlzLnRleHRhcmVhLmZvY3VzKCk7XHJcbiAgICB0aGlzLiR0ZXh0YXJlYS5jbGljaygpO1xyXG4gICAgLy8gSU1QT1JUQU5UOiBXT1JLQVJPVU5EOiBmb3IgaU9TOiBvbiBpT1MgKGNoZWNrZWQgdXAgdG8gOC4zLCAyMDE1LTA1LTIwKSwgdGhlIG9wZW5pbmcgb2YgdGhlIHZpcnR1YWwga2V5Ym9hcmRcclxuICAgIC8vIG1ha2VzIGEgc2Nyb2xsIGRvd24gb2YgdGhlIHZpZXdwb3J0LCBoaWRpbmcgdGhlIHRleHQgZmllbGQsIGhlYWRlciwgYW55dGhpbmcsIGFuZCBvbmx5IHRoZVxyXG4gICAgLy8gYmxhbmsgYXJlYSBnZXRzIHNob3dlZC4gVGhhdCBiYWQgYXV0b3Njcm9sbCBjYW4gYmUgZml4ZWQgb24gdGhpcyBzaW5nbGUgY2FzZSB3aXRoIG5leHQgdHJpY2tcclxuICAgIC8vIHdpdGhvdXQgZmxpY2tlcmluZyBvciBiYWQgZWZmZWN0cyAoYW5kIGFsdGVybmF0aXZlLCBnZW5lcmljIGFwcHJvYWNoIGlzIGRvIGl0IG9uIHRoZSBrZXlib2FyZFNob3dcclxuICAgIC8vIGV2ZW50LCBidXQgdGhlcmUgYSBmbGlja2VyaW5nIGhhcHBlbnMgYW5kIG1heSBhZmZlY3QgY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm8gbmVlZCBvciBjYW4gYmUgd29yc2VcclxuICAgIC8vIGlmIGZpZWxkIHZpc2liaWxpdHkgYW5kIGFjdHVhbCBzY3JvbGwgaXMgbm90IGNoZWNrZWQpOlxyXG4gICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKCkge1xyXG5cclxuICAgIHRoaXMuaGVhZGVyVGV4dCA9IGtvLm9ic2VydmFibGUoJ1RleHQnKTtcclxuXHJcbiAgICAvLyBUZXh0IHRvIGVkaXRcclxuICAgIHRoaXMudGV4dCA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cclxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgnY2FuY2VsJyk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgnc2F2ZWQnKTtcclxuICAgIH07XHJcbn1cclxuXHJcblZpZXdNb2RlbC5faW5oZXJpdHMoRXZlbnRFbWl0dGVyKTtcclxuIiwiLyoqXHJcbiAgICBXZWVrbHlTY2hlZHVsZSBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFdlZWtseVNjaGVkdWxlQWN0aXZpdHkoKSB7XHJcbiAgICBcclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBcclxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuRnJlZWxhbmNlcjtcclxuXHJcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1NjaGVkdWxpbmcnLCB7XHJcbiAgICAgICAgYmFja0xpbms6ICdzY2hlZHVsaW5nJ1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmRlZmF1bHROYXZCYXIgPSB0aGlzLm5hdkJhci5tb2RlbC50b1BsYWluT2JqZWN0KCk7XHJcbiAgICBcclxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcclxuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLnNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSxcclxuICAgICAgICBldmVudDogJ2Vycm9yJyxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgdmFyIG1zZyA9IGVyci50YXNrID09PSAnc2F2ZScgPyAnRXJyb3Igc2F2aW5nIHlvdXIgd2Vla2x5IHNjaGVkdWxlLicgOiAnRXJyb3IgbG9hZGluZyB5b3VyIHdlZWtseSBzY2hlZHVsZS4nO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci50YXNrICYmIGVyci5lcnJvciB8fCBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICB9KTtcclxufSk7XHJcblxyXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XHJcblxyXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuYXBwLm1vZGVsLm9uYm9hcmRpbmcudXBkYXRlTmF2QmFyKHRoaXMubmF2QmFyKSkge1xyXG4gICAgICAgIC8vIFJlc2V0XHJcbiAgICAgICAgdGhpcy5uYXZCYXIubW9kZWwudXBkYXRlV2l0aCh0aGlzLmRlZmF1bHROYXZCYXIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xyXG4gICAgXHJcbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XHJcbiAgICBcclxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxyXG4gICAgdGhpcy5hcHAubW9kZWwuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLnN5bmMoKTtcclxuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxyXG4gICAgdGhpcy52aWV3TW9kZWwuZGlzY2FyZCgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xyXG5cclxuICAgIHZhciBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUgPSBhcHAubW9kZWwuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlO1xyXG5cclxuICAgIHZhciBzY2hlZHVsZVZlcnNpb24gPSBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUubmV3VmVyc2lvbigpO1xyXG4gICAgc2NoZWR1bGVWZXJzaW9uLmlzT2Jzb2xldGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGl0SXMpIHtcclxuICAgICAgICBpZiAoaXRJcykge1xyXG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXHJcbiAgICAgICAgICAgIC8vIEZVVFVSRTogd2FybiBhYm91dCBhIG5ldyByZW1vdGUgdmVyc2lvbiBhc2tpbmdcclxuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcclxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcclxuICAgICAgICAgICAgLy8gd2l0aCBhIDUwOTpDb25mbGljdCBzdGF0dXMgKGl0cyBib2R5IG11c3QgY29udGFpbiB0aGVcclxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxyXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbW90ZSBvbmVzOlxyXG4gICAgICAgICAgICBzY2hlZHVsZVZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XHJcbiAgICB0aGlzLnNjaGVkdWxlID0gc2NoZWR1bGVWZXJzaW9uLnZlcnNpb247XHJcblxyXG4gICAgdGhpcy5pc0xvY2tlZCA9IHNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5pc0xvY2tlZDtcclxuICAgIHRoaXMuaXNTYXZpbmcgPSBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUuaXNTYXZpbmc7XHJcblxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSA/XHJcbiAgICAgICAgICAgICAgICAnU2F2ZSBhbmQgY29udGludWUnIDpcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnbG9hZGluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSk7XHJcbiAgICBcclxuICAgIHRoaXMuZGlzY2FyZCA9IGZ1bmN0aW9uIGRpc2NhcmQoKSB7XHJcbiAgICAgICAgc2NoZWR1bGVWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICBzY2hlZHVsZVZlcnNpb24ucHVzaFNhdmUoKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoYXBwLm1vZGVsLm9uYm9hcmRpbmcuaW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5nb05leHQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yLCBtYW5hZ2VkIG9uIGV2ZW50XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qKlxyXG4gICAgV2VsY29tZSBhY3Rpdml0eVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xyXG5cclxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFdlbGNvbWVBY3Rpdml0eSgpIHtcclxuICAgIFxyXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuTG9nZ2VkVXNlcjtcclxuICAgIFxyXG4gICAgdmFyIGFwcCA9IHRoaXMuYXBwO1xyXG4gICAgXHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHtcclxuICAgICAgICBzdGFydE9uYm9hcmRpbmc6IGZ1bmN0aW9uIHN0YXJ0T25ib2FyZGluZygpIHtcclxuICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuZ29OZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5uYXZCYXIgPSBuZXcgQWN0aXZpdHkuTmF2QmFyKHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICBsZWZ0QWN0aW9uOiBBY3Rpdml0eS5OYXZBY3Rpb24uZ29Mb2dvdXQsXHJcbiAgICAgICAgcmlnaHRBY3Rpb246IG51bGxcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcclxuIiwiLyoqXHJcbiAgICBSZWdpc3RyYXRpb24gb2YgY3VzdG9tIGh0bWwgY29tcG9uZW50cyB1c2VkIGJ5IHRoZSBBcHAuXHJcbiAgICBBbGwgd2l0aCAnYXBwLScgYXMgcHJlZml4LlxyXG4gICAgXHJcbiAgICBTb21lIGRlZmluaXRpb25zIG1heSBiZSBpbmNsdWRlZCBvbi1saW5lIHJhdGhlciB0aGFuIG9uIHNlcGFyYXRlZFxyXG4gICAgZmlsZXMgKHZpZXdtb2RlbHMpLCB0ZW1wbGF0ZXMgYXJlIGxpbmtlZCBzbyBuZWVkIHRvIGJlIFxyXG4gICAgaW5jbHVkZWQgaW4gdGhlIGh0bWwgZmlsZSB3aXRoIHRoZSBzYW1lIElEIHRoYXQgcmVmZXJlbmNlZCBoZXJlLFxyXG4gICAgdXN1YWxseSB1c2luZyBhcyBET00gSUQgdGhlIHNhbWUgbmFtZSBhcyB0aGUgY29tcG9uZW50IHdpdGggc3VmaXggJy10ZW1wbGF0ZScuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgcHJvcFRvb2xzID0gcmVxdWlyZSgnLi91dGlscy9qc1Byb3BlcnRpZXNUb29scycpLFxyXG4gICAgZ2V0T2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0T2JzZXJ2YWJsZScpO1xyXG5cclxuZXhwb3J0cy5yZWdpc3RlckFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgXHJcbiAgICAvLy8gbmF2YmFyLWFjdGlvblxyXG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlcignYXBwLW5hdmJhci1hY3Rpb24nLCB7XHJcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ25hdmJhci1hY3Rpb24tdGVtcGxhdGUnIH0sXHJcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcclxuXHJcbiAgICAgICAgICAgIHByb3BUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ2FjdGlvbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYWN0aW9uICYmIHBhcmFtcy5uYXZCYXIoKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5hdkJhcigpW3BhcmFtcy5hY3Rpb25dKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLy8gdW5sYWJlbGVkLWlucHV0XHJcbiAgICBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdhcHAtdW5sYWJlbGVkLWlucHV0Jywge1xyXG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICd1bmxhYmVsZWQtaW5wdXQtdGVtcGxhdGUnIH0sXHJcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5wbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSA9IGdldE9ic2VydmFibGUocGFyYW1zLmRpc2FibGUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHVzZXJBdHRyID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuYXR0cik7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0ciA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gdXNlckF0dHIoKSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgYXR0ciwge1xyXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5wbGFjZWhvbGRlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMudHlwZSk7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUoKSB8fCAndGV4dCc7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLy8gZmVlZGJhY2stZW50cnlcclxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1mZWVkYmFjay1lbnRyeScsIHtcclxuICAgICAgICB0ZW1wbGF0ZTogeyBlbGVtZW50OiAnZmVlZGJhY2stZW50cnktdGVtcGxhdGUnIH0sXHJcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvbiA9IGdldE9ic2VydmFibGUocGFyYW1zLnNlY3Rpb24gfHwgJycpO1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnL2ZlZWRiYWNrRm9ybS8nICsgdGhpcy5zZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLy8gZmVlZGJhY2stZW50cnlcclxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC10aW1lLXNsb3QtdGlsZScsIHtcclxuICAgICAgICB0ZW1wbGF0ZTogeyBlbGVtZW50OiAndGltZS1zbG90LXRpbGUtdGVtcGxhdGUnIH0sXHJcbiAgICAgICAgdmlld01vZGVsOiByZXF1aXJlKCcuL3ZpZXdtb2RlbHMvVGltZVNsb3QnKVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vLyBsb2FkaW5nLXNwaW5uZXJcclxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1sb2FkaW5nLXNwaW5uZXInLCB7XHJcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ2xvYWRpbmctc3Bpbm5lci10ZW1wbGF0ZScgfSxcclxuICAgICAgICB2aWV3TW9kZWw6IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgICAgICAgICB2YXIgYmFzZSA9ICdsb2FkaW5nU3Bpbm5lcic7XHJcbiAgICAgICAgICAgIHRoaXMubW9kID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMubW9kIHx8ICcnKTtcclxuICAgICAgICAgICAgdGhpcy5jc3NDbGFzcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gYmFzZSxcclxuICAgICAgICAgICAgICAgICAgICBtb2RzID0gKHRoaXMubW9kKCkgfHwgJycpLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgYyArPSAnICcgKyBiYXNlICsgJy0tJyArIG1vZHMuam9pbignICcgKyBiYXNlICsgJy0tJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8vIGFwcG9pbnRtZW50LWNhcmRcclxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1hcHBvaW50bWVudC1jYXJkJywge1xyXG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICdhcHBvaW50bWVudC1jYXJkLXRlbXBsYXRlJyB9LFxyXG4gICAgICAgIHZpZXdNb2RlbDogcmVxdWlyZSgnLi92aWV3bW9kZWxzL0FwcG9pbnRtZW50Q2FyZCcpXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8vIGpvYiB0aXRsZXMgbGlzdFxyXG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlcignYXBwLWpvYi10aXRsZXMtbGlzdCcsIHtcclxuICAgICAgICB0ZW1wbGF0ZTogeyBlbGVtZW50OiAnam9iLXRpdGxlcy1saXN0LXRlbXBsYXRlJyB9LFxyXG4gICAgICAgIHZpZXdNb2RlbDogZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuam9iVGl0bGVzID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuam9iVGl0bGVzIHx8IFtdKTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RKb2JUaXRsZSA9IHBhcmFtcy5zZWxlY3RKb2JUaXRsZSB8fCBmdW5jdGlvbigpIHt9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG4iLCIvKipcclxuICAgIE5hdmJhciBleHRlbnNpb24gb2YgdGhlIEFwcCxcclxuICAgIGFkZHMgdGhlIGVsZW1lbnRzIHRvIG1hbmFnZSBhIHZpZXcgbW9kZWxcclxuICAgIGZvciB0aGUgTmF2QmFyIGFuZCBhdXRvbWF0aWMgY2hhbmdlc1xyXG4gICAgdW5kZXIgc29tZSBtb2RlbCBjaGFuZ2VzIGxpa2UgdXNlciBsb2dpbi9sb2dvdXRcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXHJcbiAgICBOYXZCYXIgPSByZXF1aXJlKCcuL3ZpZXdtb2RlbHMvTmF2QmFyJyksXHJcbiAgICBOYXZBY3Rpb24gPSByZXF1aXJlKCcuL3ZpZXdtb2RlbHMvTmF2QWN0aW9uJyk7XHJcblxyXG5leHBvcnRzLmV4dGVuZHMgPSBmdW5jdGlvbiAoYXBwKSB7XHJcbiAgICBcclxuICAgIC8vIFJFVklFVzogc3RpbGwgbmVlZGVkPyBNYXliZSB0aGUgcGVyIGFjdGl2aXR5IG5hdkJhciBtZWFuc1xyXG4gICAgLy8gdGhpcyBpcyBub3QgbmVlZGVkLiBTb21lIHByZXZpb3VzIGxvZ2ljIHdhcyBhbHJlYWR5IHJlbW92ZWRcclxuICAgIC8vIGJlY2F1c2Ugd2FzIHVzZWxlc3MuXHJcbiAgICAvL1xyXG4gICAgLy8gQWRqdXN0IHRoZSBuYXZiYXIgc2V0dXAgZGVwZW5kaW5nIG9uIGN1cnJlbnQgdXNlcixcclxuICAgIC8vIHNpbmNlIGRpZmZlcmVudCB0aGluZ3MgYXJlIG5lZWQgZm9yIGxvZ2dlZC1pbi9vdXQuXHJcbiAgICBmdW5jdGlvbiBhZGp1c3RVc2VyQmFyKCkge1xyXG5cclxuICAgICAgICB2YXIgdXNlciA9IGFwcC5tb2RlbC51c2VyKCk7XHJcblxyXG4gICAgICAgIGlmICh1c2VyLmlzQW5vbnltb3VzKCkpIHtcclxuICAgICAgICAgICAgYXBwLm5hdkJhcigpLmxlZnRBY3Rpb24oTmF2QWN0aW9uLm1lbnVPdXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENvbW1lbnRlZCBsaW5lcywgdXNlZCBwcmV2aW91c2x5IGJ1dCB1bnVzZWQgbm93LCBpdCBtdXN0IGJlIGVub3VnaCB3aXRoIHRoZSB1cGRhdGVcclxuICAgIC8vIHBlciBhY3Rpdml0eSBjaGFuZ2VcclxuICAgIC8vYXBwLm1vZGVsLnVzZXIoKS5pc0Fub255bW91cy5zdWJzY3JpYmUodXBkYXRlU3RhdGVzT25Vc2VyQ2hhbmdlKTtcclxuICAgIC8vYXBwLm1vZGVsLnVzZXIoKS5vbmJvYXJkaW5nU3RlcC5zdWJzY3JpYmUodXBkYXRlU3RhdGVzT25Vc2VyQ2hhbmdlKTtcclxuICAgIFxyXG4gICAgYXBwLm5hdkJhciA9IGtvLm9ic2VydmFibGUobnVsbCk7XHJcbiAgICBcclxuICAgIHZhciByZWZyZXNoTmF2ID0gZnVuY3Rpb24gcmVmcmVzaE5hdigpIHtcclxuICAgICAgICAvLyBUcmlnZ2VyIGV2ZW50IHRvIGZvcmNlIGEgY29tcG9uZW50IHVwZGF0ZVxyXG4gICAgICAgICQoJy5BcHBOYXYnKS50cmlnZ2VyKCdjb250ZW50Q2hhbmdlJyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGF1dG9SZWZyZXNoTmF2ID0gZnVuY3Rpb24gYXV0b1JlZnJlc2hOYXYoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGFjdGlvbikge1xyXG4gICAgICAgICAgICBhY3Rpb24udGV4dC5zdWJzY3JpYmUocmVmcmVzaE5hdik7XHJcbiAgICAgICAgICAgIGFjdGlvbi5pc1RpdGxlLnN1YnNjcmliZShyZWZyZXNoTmF2KTtcclxuICAgICAgICAgICAgYWN0aW9uLmljb24uc3Vic2NyaWJlKHJlZnJlc2hOYXYpO1xyXG4gICAgICAgICAgICBhY3Rpb24uaXNNZW51LnN1YnNjcmliZShyZWZyZXNoTmF2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIFVwZGF0ZSB0aGUgbmF2IG1vZGVsIHVzaW5nIHRoZSBBY3Rpdml0eSBkZWZhdWx0c1xyXG4gICAgKiovXHJcbiAgICBhcHAudXBkYXRlQXBwTmF2ID0gZnVuY3Rpb24gdXBkYXRlQXBwTmF2KGFjdGl2aXR5LCBzdGF0ZSkge1xyXG5cclxuICAgICAgICAvLyBpZiB0aGUgYWN0aXZpdHkgaGFzIGl0cyBvd25cclxuICAgICAgICBpZiAoJ25hdkJhcicgaW4gYWN0aXZpdHkpIHtcclxuICAgICAgICAgICAgLy8gVXNlIHNwZWNpYWxpemllZCBhY3Rpdml0eSBiYXIgZGF0YVxyXG4gICAgICAgICAgICBhcHAubmF2QmFyKGFjdGl2aXR5Lm5hdkJhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdCBvbmVcclxuICAgICAgICAgICAgYXBwLm5hdkJhcihuZXcgTmF2QmFyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUucm91dGUgJiYgc3RhdGUucm91dGUucXVlcnkgJiZcclxuICAgICAgICAgICAgc3RhdGUucm91dGUucXVlcnkubXVzdFJldHVybikge1xyXG4gICAgICAgICAgICAvLyBMZWZ0IGFjdGlvbiBmb3JjZWQgdG8gYmUgYSBnby1iYWNrXHJcbiAgICAgICAgICAgIGFwcC5uYXZCYXIoKS5sZWZ0QWN0aW9uKE5hdkFjdGlvbi5nb0JhY2spO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETyBEb3VibGUgY2hlY2sgaWYgbmVlZGVkLlxyXG4gICAgICAgIC8vIExhdGVzdCBjaGFuZ2VzLCB3aGVuIG5lZWRlZFxyXG4gICAgICAgIGFkanVzdFVzZXJCYXIoKTtcclxuICAgICAgICBcclxuICAgICAgICByZWZyZXNoTmF2KCk7XHJcbiAgICAgICAgYXV0b1JlZnJlc2hOYXYoYXBwLm5hdkJhcigpLmxlZnRBY3Rpb24oKSk7XHJcbiAgICAgICAgYXV0b1JlZnJlc2hOYXYoYXBwLm5hdkJhcigpLnJpZ2h0QWN0aW9uKCkpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBVcGRhdGUgdGhlIGFwcCBtZW51IHRvIGhpZ2hsaWdodCB0aGVcclxuICAgICAgICBnaXZlbiBsaW5rIG5hbWVcclxuICAgICoqL1xyXG4gICAgYXBwLnVwZGF0ZU1lbnUgPSBmdW5jdGlvbiB1cGRhdGVNZW51KG5hbWUpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgJG1lbnUgPSAkKCcuQXBwLW1lbnVzIC5uYXZiYXItY29sbGFwc2UnKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZW1vdmUgYW55IGFjdGl2ZVxyXG4gICAgICAgICRtZW51XHJcbiAgICAgICAgLmZpbmQoJ2xpJylcclxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgIC8vIEFkZCBhY3RpdmVcclxuICAgICAgICAkbWVudVxyXG4gICAgICAgIC5maW5kKCcuZ28tJyArIG5hbWUpXHJcbiAgICAgICAgLmNsb3Nlc3QoJ2xpJylcclxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgIC8vIEhpZGUgbWVudVxyXG4gICAgICAgICRtZW51XHJcbiAgICAgICAgLmZpbHRlcignOnZpc2libGUnKVxyXG4gICAgICAgIC5jb2xsYXBzZSgnaGlkZScpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBwLnNldHVwTmF2QmFyQmluZGluZyA9IGZ1bmN0aW9uIHNldHVwTmF2QmFyQmluZGluZygpIHtcclxuICAgICAgICB2YXIgc2l0ZVVybCA9ICQoJ2h0bWwnKS5hdHRyKCdkYXRhLXNpdGUtdXJsJyk7XHJcbiAgICAgICAgLy8gU2V0IG1vZGVsIGZvciB0aGUgQXBwTmF2XHJcbiAgICAgICAgYXBwLm5hdkJhckJpbmRpbmcgPSB7XHJcbiAgICAgICAgICAgIG5hdkJhcjogYXBwLm5hdkJhcixcclxuICAgICAgICAgICAgLy8gVVJMLCBrZWVwIHVwZGF0ZWQgd2l0aCBhbnkgc2l0ZSBjaGFuZ2VcclxuICAgICAgICAgICAgcGhvdG9Vcmw6IGtvLm9ic2VydmFibGUoc2l0ZVVybCArICcvZW4tVVMvUHJvZmlsZS9QaG90by8nKSxcclxuICAgICAgICAgICAgLy8gSXQncyBsYXRlciBmaWxsZWQgd2l0aCBhIGNhbGwgdG8gdGhlIG1vZGVsIG9uY2UgbG9hZGVkIGFuZCByZWFkeVxyXG4gICAgICAgICAgICB1c2VyTmFtZToga28ub2JzZXJ2YWJsZSgnTWUnKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyhhcHAubmF2QmFyQmluZGluZywgJCgnLkFwcE5hdicpLmdldCgwKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBQZXJmb3JtcyB0aGUgJ2JhY2snIHRhc2sgZnJvbSB0aGUgbmF2YmFyIGxpbmssIGlmIGFueS5cclxuICAgICAgICBUaGF0IGlzLCB0cmlnZ2VyIHRoZSBsZWZ0IGFjdGlvbi5cclxuICAgICAgICBGYWxsYmFjayB0byBzaGVsbCBnb0JhY2tcclxuICAgICoqL1xyXG4gICAgYXBwLnBlcmZvcm1zTmF2QmFyQmFjayA9IGZ1bmN0aW9uIHBlcmZvcm1zTmF2QmFyQmFjayhvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG5hdiA9IHRoaXMubmF2QmFyKCksXHJcbiAgICAgICAgICAgIGxlZnQgPSBuYXYgJiYgbmF2LmxlZnRBY3Rpb24oKSxcclxuICAgICAgICAgICAgJGJ0biA9ICQoJy5TbWFydE5hdkJhci1lZGdlLmxlZnQgPiBhLlNtYXJ0TmF2QmFyLWJ0bicpO1xyXG5cclxuICAgICAgICAvLyBUaGVyZSBpcyBhbiBhY3Rpb24sIHRyaWdnZXIgbGlrZSBhIGNsaWNrIHNvIGFsbCB0aGUgaGFuZGxlcnNcclxuICAgICAgICAvLyBhdHRhY2hlZCBvbiBzcGFyZSBwbGFjZXMgZG8gdGhlaXIgd29yazpcclxuICAgICAgICBpZiAobGVmdCAmJiAhbGVmdC5pc01lbnUoKSkge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KCdjbGljaycpO1xyXG4gICAgICAgICAgICBldmVudC5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgJGJ0bi50cmlnZ2VyKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaGVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNoZWxsLmdvQmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEl0IHNob3dzIGFuIHVub2J0cnVzaXZlIG5vdGlmaWNhdGlvbiBvbiB0aGUgbmF2YmFyIHBsYWNlLCB0aGF0XHJcbiAgICAgICAgaGlkZXMgYWZ0ZXIgYSBzaG9ydCB0aW1lb3V0XHJcbiAgICAqKi9cclxuICAgIHZhciBsYXN0Tm90aWZpY2F0aW9uVGltZXIgPSBudWxsO1xyXG4gICAgYXBwLnNob3dOYXZCYXJOb3RpZmljYXRpb24gPSBmdW5jdGlvbiBzaG93TmF2QmFyTm90aWZpY2F0aW9uKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IHNldHRpbmdzICYmIHNldHRpbmdzLm1lc3NhZ2UgfHwgJ0hlbGxvIFdvcmxkIScsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gc2V0dGluZ3MgJiYgc2V0dGluZ3MuZHVyYXRpb24gfHwgMjAwMCxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gc2V0dGluZ3MgJiYgc2V0dGluZ3MudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDQwMCxcclxuICAgICAgICAgICAgJGVsID0gJCgnLkFwcE5hdiAuU21hcnROYXZCYXItbm90aWZpY2F0aW9uJyk7XHJcblxyXG4gICAgICAgICRlbC50ZXh0KG1zZyk7XHJcbiAgICAgICAgJGVsLmZhZGVJbih0cmFuc2l0aW9uRHVyYXRpb24pXHJcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTWFudWFsIGhpZGUgb24gY2xpY2tpbmdcclxuICAgICAgICAgICAgJGVsXHJcbiAgICAgICAgICAgIC5vZmYoJ2NsaWNrLm1hbnVhbEhpZGUnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrLm1hbnVhbEhpZGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRlbC5mYWRlT3V0KHRyYW5zaXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQXV0byBoaWRlIGFmdGVyIHRpbWVvdXRcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGxhc3ROb3RpZmljYXRpb25UaW1lcik7XHJcbiAgICAgICAgICAgIGxhc3ROb3RpZmljYXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkZWwuZmFkZU91dCh0cmFuc2l0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAkKHRoaXMpLmRlcXVldWUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgTGlzdCBvZiBhY3Rpdml0aWVzIGxvYWRlZCBpbiB0aGUgQXBwLFxyXG4gICAgYXMgYW4gb2JqZWN0IHdpdGggdGhlIGFjdGl2aXR5IG5hbWUgYXMgdGhlIGtleVxyXG4gICAgYW5kIHRoZSBjb250cm9sbGVyIGFzIHZhbHVlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XHJcbnZhciBFbXB0eUFjdGl2aXR5ID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBFbXB0eUFjdGl2aXR5KCkge1xyXG5cclxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IG51bGw7XHJcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHt9O1xyXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAnX3Rlc3QnOiBFbXB0eUFjdGl2aXR5LFxyXG4gICAgJ2NhbGVuZGFyJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NhbGVuZGFyJyksXHJcbiAgICAnZGF0ZXRpbWVQaWNrZXInOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvZGF0ZXRpbWVQaWNrZXInKSxcclxuICAgICdjbGllbnRzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NsaWVudHMnKSxcclxuICAgICdmcmVlbGFuY2VyUHJpY2luZyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9mcmVlbGFuY2VyUHJpY2luZycpLFxyXG4gICAgJ3NlcnZpY2VBZGRyZXNzZXMnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvc2VydmljZUFkZHJlc3NlcycpLFxyXG4gICAgJ3RleHRFZGl0b3InOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvdGV4dEVkaXRvcicpLFxyXG4gICAgJ2hvbWUnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvaG9tZScpLFxyXG4gICAgJ2FwcG9pbnRtZW50JzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2FwcG9pbnRtZW50JyksXHJcbiAgICAnaW5kZXgnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvaW5kZXgnKSxcclxuICAgICdsb2dpbic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9sb2dpbicpLFxyXG4gICAgJ2xvZ291dCc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9sb2dvdXQnKSxcclxuICAgICdsZWFybk1vcmUnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvbGVhcm5Nb3JlJyksXHJcbiAgICAnc2lnbnVwJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3NpZ251cCcpLFxyXG4gICAgJ2NvbnRhY3RJbmZvJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NvbnRhY3RJbmZvJyksXHJcbiAgICAnd2VsY29tZSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy93ZWxjb21lJyksXHJcbiAgICAnYWRkcmVzc0VkaXRvcic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9hZGRyZXNzRWRpdG9yJyksXHJcbiAgICAnYWNjb3VudCc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9hY2NvdW50JyksXHJcbiAgICAnaW5ib3gnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvaW5ib3gnKSxcclxuICAgICdjb252ZXJzYXRpb24nOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvY29udmVyc2F0aW9uJyksXHJcbiAgICAnc2NoZWR1bGluZyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9zY2hlZHVsaW5nJyksXHJcbiAgICAnam9idGl0bGVzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2pvYnRpdGxlcycpLFxyXG4gICAgJ2ZlZWRiYWNrJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2ZlZWRiYWNrJyksXHJcbiAgICAnZmFxcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9mYXFzJyksXHJcbiAgICAnZmVlZGJhY2tGb3JtJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2ZlZWRiYWNrRm9ybScpLFxyXG4gICAgJ2NvbnRhY3RGb3JtJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NvbnRhY3RGb3JtJyksXHJcbiAgICAnY21zJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NtcycpLFxyXG4gICAgJ2NsaWVudEVkaXRvcic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9jbGllbnRFZGl0b3InKSxcclxuICAgICdzY2hlZHVsaW5nUHJlZmVyZW5jZXMnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvc2NoZWR1bGluZ1ByZWZlcmVuY2VzJyksXHJcbiAgICAnY2FsZW5kYXJTeW5jaW5nJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NhbGVuZGFyU3luY2luZycpLFxyXG4gICAgJ3dlZWtseVNjaGVkdWxlJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3dlZWtseVNjaGVkdWxlJyksXHJcbiAgICAnYm9va01lQnV0dG9uJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2Jvb2tNZUJ1dHRvbicpLFxyXG4gICAgJ293bmVySW5mbyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9vd25lckluZm8nKSxcclxuICAgICdwcml2YWN5U2V0dGluZ3MnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvcHJpdmFjeVNldHRpbmdzJyksXHJcbiAgICAnYWRkSm9iVGl0bGVzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2FkZEpvYlRpdGxlcycpLFxyXG4gICAgJ2ZyZWVsYW5jZXJQcmljaW5nRWRpdG9yJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2ZyZWVsYW5jZXJQcmljaW5nRWRpdG9yJylcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqIEdsb2JhbCBkZXBlbmRlbmNpZXMgKiovXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbnJlcXVpcmUoJ2pxdWVyeS1tb2JpbGUnKTtcclxucmVxdWlyZSgnLi91dGlscy9qcXVlcnkubXVsdGlsaW5lJyk7XHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcbmtvLmJpbmRpbmdIYW5kbGVycy5mb3JtYXQgPSByZXF1aXJlKCdrby9mb3JtYXRCaW5kaW5nJykuZm9ybWF0QmluZGluZztcclxudmFyIGJvb3Rrbm9jayA9IHJlcXVpcmUoJy4vdXRpbHMvYm9vdGtub2NrQmluZGluZ0hlbHBlcnMnKTtcclxucmVxdWlyZSgnLi91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUuX2luaGVyaXRzJyk7XHJcbnJlcXVpcmUoJy4vdXRpbHMvRnVuY3Rpb24ucHJvdG90eXBlLl9kZWxheWVkJyk7XHJcbi8vIFBvbHlmaWxsIGZvciB1c2VmdWwgbm9uLXN0YW5kYXJkIGZlYXR1cmUgRnVuY3Rpb24ubmFtZSBmb3IgSUU5K1xyXG4vLyAoZmVhdHVyZSB1c2VkIHRvIHNpbXBsaWZ5IGNyZWF0aW9uIG9mIEFjdGl2aXRpZXMgYW5kIE1vZGVscylcclxucmVxdWlyZSgnLi91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUubmFtZS1wb2x5ZmlsbCcpO1xyXG4vLyBQcm9taXNlIHBvbHlmaWxsLCBzbyBpdHMgbm90ICdyZXF1aXJlJ2QgcGVyIG1vZHVsZTpcclxucmVxdWlyZSgnZXM2LXByb21pc2UnKS5wb2x5ZmlsbCgpO1xyXG5cclxudmFyIGxheW91dFVwZGF0ZUV2ZW50ID0gcmVxdWlyZSgnbGF5b3V0VXBkYXRlRXZlbnQnKTtcclxudmFyIEFwcE1vZGVsID0gcmVxdWlyZSgnLi9hcHBtb2RlbC9BcHBNb2RlbCcpO1xyXG5cclxuLy8gUmVnaXN0ZXIgdGhlIHNwZWNpYWwgbG9jYWxlXHJcbnJlcXVpcmUoJy4vbG9jYWxlcy9lbi1VUy1MQycpO1xyXG5cclxudmFyIGF0dGFjaEZhc3RDbGljayA9IHJlcXVpcmUoJ2Zhc3RjbGljaycpLmF0dGFjaDtcclxuXHJcbi8qKlxyXG4gICAgQSBzZXQgb2YgZml4ZXMvd29ya2Fyb3VuZHMgZm9yIEJvb3RzdHJhcCBiZWhhdmlvci9wbHVnaW5zXHJcbiAgICB0byBiZSBleGVjdXRlZCBiZWZvcmUgQm9vdHN0cmFwIGlzIGluY2x1ZGVkL2V4ZWN1dGVkLlxyXG4gICAgRm9yIGV4YW1wbGUsIGJlY2F1c2Ugb2YgZGF0YS1iaW5kaW5nIHJlbW92aW5nL2NyZWF0aW5nIGVsZW1lbnRzLFxyXG4gICAgc29tZSBvbGQgcmVmZXJlbmNlcyB0byByZW1vdmVkIGl0ZW1zIG1heSBnZXQgYWxpdmUgYW5kIG5lZWQgdXBkYXRlLFxyXG4gICAgb3IgcmUtZW5hYmxpbmcgc29tZSBiZWhhdmlvcnMuXHJcbioqL1xyXG5mdW5jdGlvbiBwcmVCb290c3RyYXBXb3JrYXJvdW5kcygpIHtcclxuICAgIC8vIEludGVybmFsIEJvb3RzdHJhcCBzb3VyY2UgdXRpbGl0eVxyXG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRyaWdnZXIpIHtcclxuICAgICAgICB2YXIgaHJlZixcclxuICAgICAgICAgICAgdGFyZ2V0ID0gJHRyaWdnZXIuYXR0cignZGF0YS10YXJnZXQnKSB8fFxyXG4gICAgICAgICAgICAoaHJlZiA9ICR0cmlnZ2VyLmF0dHIoJ2hyZWYnKSkgJiYgXHJcbiAgICAgICAgICAgIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpOyAvLyBzdHJpcCBmb3IgaWU3XHJcblxyXG4gICAgICAgIHJldHVybiAkKHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEJ1ZzogbmF2YmFyLWNvbGxhcHNlIGVsZW1lbnRzIGhvbGQgYSByZWZlcmVuY2UgdG8gdGhlaXIgb3JpZ2luYWxcclxuICAgIC8vICR0cmlnZ2VyLCBidXQgdGhhdCB0cmlnZ2VyIGNhbiBjaGFuZ2Ugb24gZGlmZmVyZW50ICdjbGlja3MnIG9yXHJcbiAgICAvLyBnZXQgcmVtb3ZlZCB0aGUgb3JpZ2luYWwsIHNvIGl0IG11c3QgcmVmZXJlbmNlIHRoZSBuZXcgb25lXHJcbiAgICAvLyAodGhlIGxhdGVzdHMgY2xpY2tlZCwgYW5kIG5vdCB0aGUgY2FjaGVkIG9uZSB1bmRlciB0aGUgJ2RhdGEnIEFQSSkuICAgIFxyXG4gICAgLy8gTk9URTogaGFuZGxlciBtdXN0IGV4ZWN1dGUgYmVmb3JlIHRoZSBCb290c3RyYXAgaGFuZGxlciBmb3IgdGhlIHNhbWVcclxuICAgIC8vIGV2ZW50IGluIG9yZGVyIHRvIHdvcmsuXHJcbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGkud29ya2Fyb3VuZCcsICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkdCA9ICQodGhpcyksXHJcbiAgICAgICAgICAgICR0YXJnZXQgPSBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdCksXHJcbiAgICAgICAgICAgIGRhdGEgPSAkdGFyZ2V0ICYmICR0YXJnZXQuZGF0YSgnYnMuY29sbGFwc2UnKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBhbnlcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSB0cmlnZ2VyIGluIHRoZSBkYXRhIHJlZmVyZW5jZTpcclxuICAgICAgICAgICAgZGF0YS4kdHJpZ2dlciA9ICR0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPbiBlbHNlLCBub3RoaW5nIHRvIGRvLCBhIG5ldyBDb2xsYXBzZSBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyB3aXRoIHRoZSBjb3JyZWN0IHRhcmdldCwgdGhlIGZpcnN0IHRpbWVcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICAgIEFwcCBzdGF0aWMgY2xhc3NcclxuKiovXHJcbnZhciBhcHAgPSB7XHJcbiAgICBzaGVsbDogcmVxdWlyZSgnLi9hcHAuc2hlbGwnKSxcclxuICAgIFxyXG4gICAgLy8gTmV3IGFwcCBtb2RlbCwgdGhhdCBzdGFydHMgd2l0aCBhbm9ueW1vdXMgdXNlclxyXG4gICAgbW9kZWw6IG5ldyBBcHBNb2RlbCgpLFxyXG4gICAgXHJcbiAgICAvKiogTG9hZCBhY3Rpdml0aWVzIGNvbnRyb2xsZXJzIChub3QgaW5pdGlhbGl6ZWQpICoqL1xyXG4gICAgYWN0aXZpdGllczogcmVxdWlyZSgnLi9hcHAuYWN0aXZpdGllcycpLFxyXG4gICAgXHJcbiAgICBtb2RhbHM6IHJlcXVpcmUoJy4vYXBwLm1vZGFscycpLFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBKdXN0IHJlZGlyZWN0IHRoZSBiZXR0ZXIgcGxhY2UgZm9yIGN1cnJlbnQgdXNlciBhbmQgc3RhdGUuXHJcbiAgICAgICAgTk9URTogSXRzIGEgZGVsYXllZCBmdW5jdGlvbiwgc2luY2Ugb24gbWFueSBjb250ZXh0cyBuZWVkIHRvXHJcbiAgICAgICAgd2FpdCBmb3IgdGhlIGN1cnJlbnQgJ3JvdXRpbmcnIGZyb20gZW5kIGJlZm9yZSBkbyB0aGUgbmV3XHJcbiAgICAgICAgaGlzdG9yeSBjaGFuZ2UuXHJcbiAgICAgICAgVE9ETzogTWF5YmUsIHJhdGhlciB0aGFuIGRlbGF5IGl0LCBjYW4gc3RvcCBjdXJyZW50IHJvdXRpbmdcclxuICAgICAgICAoY2hhbmdlcyBvbiBTaGVsbCByZXF1aXJlZCkgYW5kIHBlcmZvcm0gdGhlIG5ldy5cclxuICAgICAgICBUT0RPOiBNYXliZSBhbHRlcm5hdGl2ZSB0byBwcmV2aW91cywgdG8gcHJvdmlkZSBhICdyZXBsYWNlJ1xyXG4gICAgICAgIGluIHNoZWxsIHJhdGhlciB0aGFuIGEgZ28sIHRvIGF2b2lkIGFwcGVuZCByZWRpcmVjdCBlbnRyaWVzXHJcbiAgICAgICAgaW4gdGhlIGhpc3RvcnksIHRoYXQgY3JlYXRlIHRoZSBwcm9ibGVtIG9mICdicm9rZW4gYmFjayBidXR0b24nXHJcbiAgICAqKi9cclxuICAgIGdvRGFzaGJvYXJkOiBmdW5jdGlvbiBnb0Rhc2hib2FyZCgpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBUbyBhdm9pZCBpbmZpbml0ZSBsb29wcyBpZiB3ZSBhbHJlYWR5IGFyZSBwZXJmb3JtaW5nIFxyXG4gICAgICAgIC8vIGEgZ29EYXNoYm9hcmQgdGFzaywgd2UgZmxhZyB0aGUgZXhlY3V0aW9uXHJcbiAgICAgICAgLy8gYmVpbmcgY2FyZSBvZiB0aGUgZGVsYXkgaW50cm9kdWNlZCBpbiB0aGUgZXhlY3V0aW9uXHJcbiAgICAgICAgaWYgKGdvRGFzaGJvYXJkLl9nb2luZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZWxheWVkIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBpbi10aGUtbWlkZGxlXHJcbiAgICAgICAgICAgIC8vIHRhc2tzOiBqdXN0IGFsbG93aW5nIGN1cnJlbnQgcm91dGluZyB0byBmaW5pc2hcclxuICAgICAgICAgICAgLy8gYmVmb3JlIHBlcmZvcm0gdGhlICdyZWRpcmVjdCdcclxuICAgICAgICAgICAgLy8gVE9ETzogY2hhbmdlIGJ5IGEgcmVhbCByZWRpcmVjdCB0aGF0IGlzIGFibGUgdG9cclxuICAgICAgICAgICAgLy8gY2FuY2VsIHRoZSBjdXJyZW50IGFwcC5zaGVsbCByb3V0aW5nIHByb2Nlc3MuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBnb0Rhc2hib2FyZC5fZ29pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvbmJvYXJkaW5nID0gdGhpcy5tb2RlbC5vbmJvYXJkaW5nLnN0ZXBVcmwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob25ib2FyZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlbGwuZ28ob25ib2FyZGluZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWxsLmdvKCdob21lJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSnVzdCBiZWNhdXNlIGlzIGRlbGF5ZWQsIG5lZWRzXHJcbiAgICAgICAgICAgICAgICAvLyB0byBiZSBzZXQgb2ZmIGFmdGVyIGFuIGlubWVkaWF0ZSB0byBcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBpcyBzZXQgb2ZmIGFmdGVyIGFueSBvdGhlciBhdHRlbXB0XHJcbiAgICAgICAgICAgICAgICAvLyB0byBhZGQgYSBkZWxheWVkIGdvRGFzaGJvYXJkOlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBnb0Rhc2hib2FyZC5fZ29pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKiBDb250aW51ZSBhcHAgY3JlYXRpb24gd2l0aCB0aGluZ3MgdGhhdCBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSBhcHAgKiovXHJcblxyXG5yZXF1aXJlKCcuL2FwcC1uYXZiYXInKS5leHRlbmRzKGFwcCk7XHJcblxyXG5yZXF1aXJlKCcuL2FwcC1jb21wb25lbnRzJykucmVnaXN0ZXJBbGwoKTtcclxuXHJcbmFwcC5nZXRBY3Rpdml0eSA9IGZ1bmN0aW9uIGdldEFjdGl2aXR5KG5hbWUpIHtcclxuICAgIHZhciBhY3Rpdml0eSA9IHRoaXMuYWN0aXZpdGllc1tuYW1lXTtcclxuICAgIGlmIChhY3Rpdml0eSkge1xyXG4gICAgICAgIHZhciAkYWN0ID0gdGhpcy5zaGVsbC5pdGVtcy5maW5kKG5hbWUpO1xyXG4gICAgICAgIGlmICgkYWN0ICYmICRhY3QubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gYWN0aXZpdHkuaW5pdCgkYWN0LCB0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuYXBwLmdldEFjdGl2aXR5Q29udHJvbGxlckJ5Um91dGUgPSBmdW5jdGlvbiBnZXRBY3Rpdml0eUNvbnRyb2xsZXJCeVJvdXRlKHJvdXRlKSB7XHJcbiAgICAvLyBGcm9tIHRoZSByb3V0ZSBvYmplY3QsIHRoZSBpbXBvcnRhbnQgcGllY2UgaXMgcm91dGUubmFtZVxyXG4gICAgLy8gdGhhdCBjb250YWlucyB0aGUgYWN0aXZpdHkgbmFtZSBleGNlcHQgaWYgaXMgdGhlIHJvb3RcclxuICAgIHZhciBhY3ROYW1lID0gcm91dGUubmFtZSB8fCB0aGlzLnNoZWxsLmluZGV4TmFtZTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZpdHkoYWN0TmFtZSk7XHJcbn07XHJcblxyXG4vLyBhY2Nlc3NDb250cm9sIHNldHVwOiBjYW5ub3QgYmUgc3BlY2lmaWVkIG9uIFNoZWxsIGNyZWF0aW9uIGJlY2F1c2VcclxuLy8gZGVwZW5kcyBvbiB0aGUgYXBwIGluc3RhbmNlXHJcbmFwcC5zaGVsbC5hY2Nlc3NDb250cm9sID0gcmVxdWlyZSgnLi91dGlscy9hY2Nlc3NDb250cm9sJykoYXBwKTtcclxuXHJcbi8vIFNob3J0Y3V0IHRvIFVzZXJUeXBlIGVudW1lcmF0aW9uIHVzZWQgdG8gc2V0IHBlcm1pc3Npb25zXHJcbmFwcC5Vc2VyVHlwZSA9IHJlcXVpcmUoJy4vbW9kZWxzL1VzZXInKS5Vc2VyVHlwZTtcclxuXHJcbi8vIE5ldyBtZXRob2QgZm9yIGNvbW1vbiBmb3JtcyBiZWhhdmlvciBhZnRlciBhIHN1Y2Nlc3NmdWwgc2F2ZSBvcGVyYXRpb24sXHJcbi8vIHRoZSBhY3Rpdml0eSBnb2VzIGJhY2sgKGZvbGxvd2luZyB0aGUgbmF2YmFyIGJhY2stbGluayBvciBzaGVsbC5nb0JhY2soKSlcclxuLy8gYW5kIG5vdGlmeWluZyB3aXRoIGEgdGVtcG9yYXJ5IHVub2J0cnVzaXZlIG5hdmJhciBub3RpZmljYXRpb25cclxuYXBwLnN1Y2Nlc3NTYXZlID0gZnVuY3Rpb24gc3VjY2Vzc1NhdmUoc2V0dGluZ3MpIHtcclxuICAgIC8vIGRlZmF1bHRzXHJcbiAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHtcclxuICAgICAgICBtZXNzYWdlOiAnWW91ciBjaGFuZ2VzIGhhdmUgYmVlbiBzYXZlZCcsXHJcbiAgICAgICAgbGluazogbnVsbFxyXG4gICAgfSwgc2V0dGluZ3MpO1xyXG4gICAgXHJcbiAgICAvLyBzaG93IG5vdGlmaWNhdGlvblxyXG4gICAgdGhpcy5zaG93TmF2QmFyTm90aWZpY2F0aW9uKHNldHRpbmdzKTtcclxuICAgIFxyXG4gICAgLy8gcmVxdWVzdGVkIGxpbmsgb3IgY3VycmVudCBhY3Rpdml0eSBnbyBiYWNrXHJcbiAgICBpZiAoc2V0dGluZ3MubGluaylcclxuICAgICAgICB0aGlzLnNoZWxsLmdvKHNldHRpbmdzLmxpbmspO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHRoaXMucGVyZm9ybXNOYXZCYXJCYWNrKHsgc2lsZW50TW9kZTogdHJ1ZSB9KTtcclxufTtcclxuXHJcbi8qKiBBcHAgSW5pdCAqKi9cclxudmFyIGFwcEluaXQgPSBmdW5jdGlvbiBhcHBJbml0KCkge1xyXG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czo1MCxtYXhjb21wbGV4aXR5OjE2ICovXHJcbiAgICBcclxuICAgIGF0dGFjaEZhc3RDbGljayhkb2N1bWVudC5ib2R5KTtcclxuICAgIFxyXG4gICAgLy8gRW5hYmxpbmcgdGhlICdsYXlvdXRVcGRhdGUnIGpRdWVyeSBXaW5kb3cgZXZlbnQgdGhhdCBoYXBwZW5zIG9uIHJlc2l6ZSBhbmQgdHJhbnNpdGlvbmVuZCxcclxuICAgIC8vIGFuZCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5IGJ5IGFueSBzY3JpcHQgdG8gbm90aWZ5IGNoYW5nZXMgb24gbGF5b3V0IHRoYXRcclxuICAgIC8vIG1heSByZXF1aXJlIGFkanVzdG1lbnRzIG9uIG90aGVyIHNjcmlwdHMgdGhhdCBsaXN0ZW4gdG8gaXQuXHJcbiAgICAvLyBUaGUgZXZlbnQgaXMgdGhyb3R0bGUsIGd1YXJhbnRpbmcgdGhhdCB0aGUgbWlub3IgaGFuZGxlcnMgYXJlIGV4ZWN1dGVkIHJhdGhlclxyXG4gICAgLy8gdGhhbiBhIGxvdCBvZiB0aGVtIGluIHNob3J0IHRpbWUgZnJhbWVzIChhcyBoYXBwZW4gd2l0aCAncmVzaXplJyBldmVudHMpLlxyXG4gICAgbGF5b3V0VXBkYXRlRXZlbnQubGF5b3V0VXBkYXRlRXZlbnQgKz0gJyBvcmllbnRhdGlvbmNoYW5nZSc7XHJcbiAgICBsYXlvdXRVcGRhdGVFdmVudC5vbigpO1xyXG4gICAgXHJcbiAgICAvLyBLZXlib2FyZCBwbHVnaW4gZXZlbnRzIGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIGpRdWVyeSBldmVudHMsIGJ1dCBuZWVkZWQgdG9cclxuICAgIC8vIHRyaWdnZXIgYSBsYXlvdXRVcGRhdGUsIHNvIGhlcmUgYXJlIGNvbm5lY3RlZCwgbWFpbmx5IGZpeGluZyBidWdzIG9uIGlPUyB3aGVuIHRoZSBrZXlib2FyZFxyXG4gICAgLy8gaXMgaGlkZGluZy5cclxuICAgIHZhciB0cmlnTGF5b3V0ID0gZnVuY3Rpb24gdHJpZ0xheW91dCgpIHtcclxuICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignbGF5b3V0VXBkYXRlJyk7XHJcbiAgICB9O1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZHNob3cnLCB0cmlnTGF5b3V0KTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRoaWRlJywgdHJpZ0xheW91dCk7XHJcblxyXG4gICAgLy8gaU9TLTcrIHN0YXR1cyBiYXIgZml4LiBBcHBseSBvbiBwbHVnaW4gbG9hZGVkIChjb3Jkb3ZhL3Bob25lZ2FwIGVudmlyb25tZW50KVxyXG4gICAgLy8gYW5kIGluIGFueSBzeXN0ZW0sIHNvIGFueSBvdGhlciBzeXN0ZW1zIGZpeCBpdHMgc29sdmVkIHRvbyBpZiBuZWVkZWQgXHJcbiAgICAvLyBqdXN0IHVwZGF0aW5nIHRoZSBwbHVnaW4gKGZ1dHVyZSBwcm9vZikgYW5kIGVuc3VyZSBob21vZ2VuZW91cyBjcm9zcyBwbGFmdGZvcm0gYmVoYXZpb3IuXHJcbiAgICBpZiAod2luZG93LlN0YXR1c0Jhcikge1xyXG4gICAgICAgIC8vIEZpeCBpT1MtNysgb3ZlcmxheSBwcm9ibGVtXHJcbiAgICAgICAgLy8gSXMgaW4gY29uZmlnLnhtbCB0b28sIGJ1dCBzZWVtcyBub3QgdG8gd29yayB3aXRob3V0IG5leHQgY2FsbDpcclxuICAgICAgICB3aW5kb3cuU3RhdHVzQmFyLm92ZXJsYXlzV2ViVmlldyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZvcmNlIGFuIHVwZGF0ZSBkZWxheWVkIHRvIGVuc3VyZSB1cGRhdGUgYWZ0ZXIgc29tZSB0aGluZ3MgZGlkIGFkZGl0aW9uYWwgd29ya1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignbGF5b3V0VXBkYXRlJyk7XHJcbiAgICB9LCAyMDApO1xyXG4gICAgXHJcbiAgICAvLyBCb290c3RyYXBcclxuICAgIHByZUJvb3RzdHJhcFdvcmthcm91bmRzKCk7XHJcbiAgICByZXF1aXJlKCdib290c3RyYXAnKTtcclxuICAgIFxyXG4gICAgLy8gTG9hZCBLbm9ja291dCBiaW5kaW5nIGhlbHBlcnNcclxuICAgIGJvb3Rrbm9jay5wbHVnSW4oa28pO1xyXG4gICAgcmVxdWlyZSgnLi91dGlscy9ib290c3RyYXBTd2l0Y2hCaW5kaW5nJykucGx1Z0luKGtvKTtcclxuICAgIFxyXG4gICAgLy8gUGx1Z2lucyBzZXR1cFxyXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMgJiYgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCkge1xyXG4gICAgICAgIC8vIEV4cGxpY2l0ZWx5LCB3ZSBXQU5UIGF1dG8gc2Nyb2xsIG9uIGtleWJvYXJkIHNob3cgdXAuXHJcbiAgICAgICAgLy8gQ2FuIGJlIGRpc2FibGVkIG9ubHkgaWYgdGhlcmUgaXMgYSBqYXZhc2NyaXB0IHNvbHV0aW9uIHRvIGF1dG9zY3JvbGxcclxuICAgICAgICAvLyBvbiBpbnB1dCBmb2N1cywgZWxzZSBhIGJ1ZyB3aWxsIGhhcHBlbiBzcGVjaWFsbHkgb24gaU9TIHdoZXJlIGlucHV0XHJcbiAgICAgICAgLy8gZmllbGRzIGdldHMgaGlkZGVuIGJ5IHRoZSBvbiBzY3JlZW4ga2V5Ym9hcmQuXHJcbiAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5kaXNhYmxlU2Nyb2xsKGZhbHNlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRWFzeSBsaW5rcyB0byBzaGVsbCBhY3Rpb25zLCBsaWtlIGdvQmFjaywgaW4gaHRtbCBlbGVtZW50c1xyXG4gICAgLy8gRXhhbXBsZTogPGJ1dHRvbiBkYXRhLXNoZWxsPVwiZ29CYWNrIDJcIj5HbyAyIHRpbWVzIGJhY2s8L2J1dHRvbj5cclxuICAgIC8vIE5PVEU6IEltcG9ydGFudCwgcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIHNoZWxsLnJ1biB0byBiZSBleGVjdXRlZFxyXG4gICAgLy8gYmVmb3JlIGl0cyAnY2F0Y2ggYWxsIGxpbmtzJyBoYW5kbGVyXHJcbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnW2RhdGEtc2hlbGxdJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIC8vIFVzaW5nIGF0dHIgcmF0aGVyIHRoYW4gdGhlICdkYXRhJyBBUEkgdG8gZ2V0IHVwZGF0ZWRcclxuICAgICAgICAvLyBET00gdmFsdWVzXHJcbiAgICAgICAgdmFyIGNtZGxpbmUgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtc2hlbGwnKSB8fCAnJyxcclxuICAgICAgICAgICAgYXJncyA9IGNtZGxpbmUuc3BsaXQoJyAnKSxcclxuICAgICAgICAgICAgY21kID0gYXJnc1swXTtcclxuXHJcbiAgICAgICAgaWYgKGNtZCAmJiB0eXBlb2YoYXBwLnNoZWxsW2NtZF0pID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGFwcC5zaGVsbFtjbWRdLmFwcGx5KGFwcC5zaGVsbCwgYXJncy5zbGljZSgxKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDYW5jZWwgYW55IG90aGVyIGFjdGlvbiBvbiB0aGUgbGluaywgdG8gYXZvaWQgZG91YmxlIGxpbmtpbmcgcmVzdWx0c1xyXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIE9uIENvcmRvdmEvUGhvbmVnYXAgYXBwLCBzcGVjaWFsIHRhcmdldHMgbXVzdCBiZSBjYWxsZWQgdXNpbmcgdGhlIHdpbmRvdy5vcGVuXHJcbiAgICAvLyBBUEkgdG8gZW5zdXJlIGlzIGNvcnJlY3RseSBvcGVuZWQgb24gdGhlIEluQXBwQnJvd3NlciAoX2JsYW5rKSBvciBzeXN0ZW0gZGVmYXVsdFxyXG4gICAgLy8gYnJvd3NlciAoX3N5c3RlbSkuXHJcbiAgICBpZiAod2luZG93LmNvcmRvdmEpIHtcclxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnW3RhcmdldD1cIl9ibGFua1wiXSwgW3RhcmdldD1cIl9zeXN0ZW1cIl0nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKHRoaXMuZ2V0QXR0cmlidXRlKCdocmVmJyksIHRoaXMuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSk7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gV2hlbiBhbiBhY3Rpdml0eSBpcyByZWFkeSBpbiB0aGUgU2hlbGw6XHJcbiAgICBhcHAuc2hlbGwub24oYXBwLnNoZWxsLmV2ZW50cy5pdGVtUmVhZHksIGZ1bmN0aW9uKCRhY3QsIHN0YXRlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTXVzdCBiZSB0aGUgc2FtZTpcclxuICAgICAgICB2YXIgcm91dGVOYW1lID0gYXBwLnNoZWxsLmN1cnJlbnRSb3V0ZS5uYW1lO1xyXG4gICAgICAgIHZhciBhY3ROYW1lID0gJGFjdC5kYXRhKCdhY3Rpdml0eScpO1xyXG4gICAgICAgIC8vIElmIG5vdCwgc29tZSByYWNlIGNvbmRpdGlvbiwgbm90IHRoZSBzYW1lIHBhZ2UgZ28gb3V0XHJcbiAgICAgICAgaWYgKHJvdXRlTmFtZSAhPT0gYWN0TmFtZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBDb25uZWN0IHRoZSAnYWN0aXZpdGllcycgY29udHJvbGxlcnMgdG8gdGhlaXIgdmlld3NcclxuICAgICAgICB2YXIgYWN0aXZpdHkgPSBhcHAuZ2V0QWN0aXZpdHkoYWN0TmFtZSk7XHJcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgJ3Nob3cnIGxvZ2ljIG9mIHRoZSBhY3Rpdml0eSBjb250cm9sbGVyOlxyXG4gICAgICAgIGFjdGl2aXR5LnNob3coc3RhdGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoZSBzaG93IGxvZ2ljIG1heSBkbyBhIHJlZGlyZWN0LCBsb2FkaW5nIG90aGVyIGFjdGl2aXR5LCBkb3VibGUgY2hlY2tcclxuICAgICAgICByb3V0ZU5hbWUgPSBhcHAuc2hlbGwuY3VycmVudFJvdXRlLm5hbWU7XHJcbiAgICAgICAgaWYgKHJvdXRlTmFtZSAhPT0gYWN0TmFtZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgbWVudVxyXG4gICAgICAgIHZhciBtZW51SXRlbSA9IGFjdGl2aXR5Lm1lbnVJdGVtIHx8IGFjdE5hbWU7XHJcbiAgICAgICAgYXBwLnVwZGF0ZU1lbnUobWVudUl0ZW0pO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgYXBwIG5hdmlnYXRpb25cclxuICAgICAgICBhcHAudXBkYXRlQXBwTmF2KGFjdGl2aXR5LCBzdGF0ZSk7XHJcbiAgICB9KTtcclxuICAgIC8vIFdoZW4gYW4gYWN0aXZpdHkgaXMgaGlkZGVuXHJcbiAgICBhcHAuc2hlbGwub24oYXBwLnNoZWxsLmV2ZW50cy5jbG9zZWQsIGZ1bmN0aW9uKCRhY3QpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb25uZWN0IHRoZSAnYWN0aXZpdGllcycgY29udHJvbGxlcnMgdG8gdGhlaXIgdmlld3NcclxuICAgICAgICB2YXIgYWN0TmFtZSA9ICRhY3QuZGF0YSgnYWN0aXZpdHknKTtcclxuICAgICAgICB2YXIgYWN0aXZpdHkgPSBhcHAuZ2V0QWN0aXZpdHkoYWN0TmFtZSk7XHJcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgJ2hpZGUnIGxvZ2ljIG9mIHRoZSBhY3Rpdml0eSBjb250cm9sbGVyOlxyXG4gICAgICAgIGlmIChhY3Rpdml0eS5oaWRlKVxyXG4gICAgICAgICAgICBhY3Rpdml0eS5oaWRlKCk7XHJcbiAgICB9KTtcclxuICAgIC8vIENhdGNoIGVycm9ycyBvbiBpdGVtL3BhZ2UgbG9hZGluZywgc2hvd2luZy4uXHJcbiAgICBhcHAuc2hlbGwub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3IoeyBlcnJvcjogZXJyIH0pO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFNjcm9sbCB0byBlbGVtZW50IHdoZW4gY2xpY2tpbmcgYSB1c3VhbCBmcmFnbWVudCBsaW5rIChub3QgYSBwYWdlIGxpbmspXHJcbiAgICB2YXIgc2Nyb2xsVG9FbGVtZW50ID0gcmVxdWlyZSgnLi91dGlscy9zY3JvbGxUb0VsZW1lbnQnKTtcclxuICAgIGFwcC5zaGVsbC5vbignZnJhZ21lbnROYXZpZ2F0aW9uJywgZnVuY3Rpb24oaHJlZikge1xyXG4gICAgICAgIC8vIENoZWNrIGxpbmssIGF2b2lkaW5nIGVtcHR5IGxpbmtzXHJcbiAgICAgICAgLy8gKGhyZWYgY29tZXMgd2l0aCB0aGUgaW5pdGlhbCBoYXNoIGV2ZXIsIHNvIGVtcHR5IGlzIGp1c3QgJyMnKVxyXG4gICAgICAgIGlmIChocmVmID09PSAnIycpIHtcclxuICAgICAgICAgICAgLy8gTm90aWZ5IGZvciBkZWJ1Z2dpbmcsIGJlY2F1c2UgdGhpcyBtYXkgYmUgdW53YW50ZWRcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICAgICAgJ05hdmlnYXRpb24gdG8gYW4gZW1wdHkgZnJhZ21lbnQsIHRoaXMgbWF5IGJlIG5vdCB3YW50ZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgJ0ZvciByb290IGxpbmtzLCB1c2UgXCIvXCI7IG9uIHNjcmlwdCBoYW5kbGVkIGxpbmtzLCBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0OyAnICtcclxuICAgICAgICAgICAgICAgICdBIHRvdWNoIGV2ZW50IHdhcyBsaXN0ZW5lZCBvbiBhIGxpbmssIGJ1dCBub3QgdGhlIGNsaWNrIGV2ZW50LidcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIExvY2F0ZSB0YXJnZXRcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9ICQoaHJlZik7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTbW9vdGggc2Nyb2xsaW5nIHdpdGggYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxUb0VsZW1lbnQodGFyZ2V0LCB7IGFuaW1hdGlvbjogeyBkdXJhdGlvbjogMzAwIH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gTmF2YmFyIGJpbmRpbmdcclxuICAgIGFwcC5zZXR1cE5hdkJhckJpbmRpbmcoKTtcclxuICAgIFxyXG4gICAgdmFyIFNtYXJ0TmF2QmFyID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1NtYXJ0TmF2QmFyJyk7XHJcbiAgICB2YXIgbmF2QmFycyA9IFNtYXJ0TmF2QmFyLmdldEFsbCgpO1xyXG4gICAgLy8gQ3JlYXRlcyBhbiBldmVudCBieSBsaXN0ZW5pbmcgdG8gaXQsIHNvIG90aGVyIHNjcmlwdHMgY2FuIHRyaWdnZXJcclxuICAgIC8vIGEgJ2NvbnRlbnRDaGFuZ2UnIGV2ZW50IHRvIGZvcmNlIGEgcmVmcmVzaCBvZiB0aGUgbmF2YmFyICh0byBcclxuICAgIC8vIGNhbGN1bGF0ZSBhbmQgYXBwbHkgYSBuZXcgc2l6ZSk7IGV4cGVjdGVkIGZyb20gZHluYW1pYyBuYXZiYXJzXHJcbiAgICAvLyB0aGF0IGNoYW5nZSBpdCBjb250ZW50IGJhc2VkIG9uIG9ic2VydmFibGVzLlxyXG4gICAgbmF2QmFycy5mb3JFYWNoKGZ1bmN0aW9uKG5hdmJhcikge1xyXG4gICAgICAgICQobmF2YmFyLmVsKS5vbignY29udGVudENoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBuYXZiYXIucmVmcmVzaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIExpc3RlbiBmb3IgbWVudSBldmVudHMgKGNvbGxhcHNlIGluIFNtYXJ0TmF2QmFyKVxyXG4gICAgLy8gdG8gYXBwbHkgdGhlIGJhY2tkcm9wOyBhZGQgYW5vdGhlciBjbGFzcywgZXhwbGljaXQgZm9yIGtub3cgdGhlIG1lbnUvbmF2IGlzIG9wZW5lZFxyXG4gICAgdmFyIHRvZ2dsaW5nQmFja2Ryb3AgPSBmYWxzZTtcclxuICAgICQoZG9jdW1lbnQpLm9uKCdzaG93LmJzLmNvbGxhcHNlIGhpZGUuYnMuY29sbGFwc2UnLCAnLkFwcE5hdiAubmF2YmFyLWNvbGxhcHNlJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmICghdG9nZ2xpbmdCYWNrZHJvcCkge1xyXG4gICAgICAgICAgICB0b2dnbGluZ0JhY2tkcm9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSBlLnR5cGUgPT09ICdzaG93JztcclxuICAgICAgICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCd1c2UtYmFja2Ryb3AnLCBlbmFibGVkKTtcclxuICAgICAgICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCdoYXMtYXBwTmF2LW9wZW4nLCBlbmFibGVkKTtcclxuICAgICAgICAgICAgLy8gSGlkZSBhbnkgb3RoZXIgb3BlbmVkIGNvbGxhcHNlXHJcbiAgICAgICAgICAgICQoJy5jb2xsYXBzaW5nLCAuY29sbGFwc2UuaW4nKS5jb2xsYXBzZSgnaGlkZScpO1xyXG4gICAgICAgICAgICB0b2dnbGluZ0JhY2tkcm9wID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ2F0Y2ggdW5jYXRjaCBtb2RlbCBlcnJvcnNcclxuICAgIGFwcC5tb2RlbC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBBZGRpdGlvbmFsIGZvcm0gZWxlbWVudHMgYXR0cmlidXRlIGFuZCBiZWhhdmlvcjogZGF0YS1hdXRvc2VsZWN0PXRydWVcclxuICAgIC8vIHNldHMgdG8gYXV0b21hdGljYWxseSBzZWxlY3QgdGhlIHRleHQgY29udGVudCBvZiBhbiBpbnB1dCB0ZXh0IGNvbnRyb2xcclxuICAgIC8vIHdoZW4gZ2V0cyB0aGUgZm9jdXNcclxuICAgICQoZG9jdW1lbnQpLm9uKCdmb2N1cycsICdbZGF0YS1hdXRvc2VsZWN0PVwidHJ1ZVwiXScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICQodGhpcykuc2VsZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQXBwIGluaXQ6XHJcbiAgICB2YXIgYWxlcnRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3IgbG9hZGluZycsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXBwLm1vZGVsLmluaXQoKVxyXG4gICAgLnRoZW4oYXBwLnNoZWxsLnJ1bi5iaW5kKGFwcC5zaGVsbCksIGFsZXJ0RXJyb3IpXHJcbiAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBNYXJrIHRoZSBwYWdlIGFzIHJlYWR5XHJcbiAgICAgICAgJCgnaHRtbCcpLmFkZENsYXNzKCdpcy1yZWFkeScpO1xyXG4gICAgICAgIC8vIEFzIGFwcCwgaGlkZXMgc3BsYXNoIHNjcmVlblxyXG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29ubmVjdCB1c2VybmFtZSBpbiBuYXZiYXJcclxuICAgICAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBhcHAubW9kZWwudXNlclByb2ZpbGUuZGF0YS5maXJzdE5hbWUoKTtcclxuICAgICAgICAgICAgYXBwLm5hdkJhckJpbmRpbmcudXNlck5hbWUobiB8fCAnTWUnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBPbmJvYXJkaW5nIG1vZGVsIG5lZWRzIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuaW5pdChhcHApO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBvbmJvYXJkaW5nIHN0ZXAgdG8gcmVkaXJlY3QgdGhlcmUgb24gYXBwIHN0YXJ0XHJcbiAgICAgICAgdmFyIHN0ZXAgPSBhcHAubW9kZWwudXNlcigpLm9uYm9hcmRpbmdTdGVwKCk7XHJcbiAgICAgICAgaWYgKHN0ZXAgJiYgXHJcbiAgICAgICAgICAgIGFwcC5tb2RlbC5vbmJvYXJkaW5nLnNldFN0ZXAoc3RlcCkpIHtcclxuICAgICAgICAgICAgdmFyIHVybCA9IGFwcC5tb2RlbC5vbmJvYXJkaW5nLnN0ZXBVcmwoKTtcclxuICAgICAgICAgICAgYXBwLnNoZWxsLmdvKHVybCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIGFsZXJ0RXJyb3IpO1xyXG5cclxuICAgIC8vIERFQlVHXHJcbiAgICB3aW5kb3cuYXBwID0gYXBwO1xyXG59O1xyXG5cclxuLy8gQXBwIGluaXQgb24gcGFnZSByZWFkeSBhbmQgcGhvbmVnYXAgcmVhZHlcclxuaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XHJcbiAgICAvLyBPbiBET00tUmVhZHkgZmlyc3RcclxuICAgICQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gUGFnZSBpcyByZWFkeSwgZGV2aWNlIGlzIHRvbz9cclxuICAgICAgICAvLyBOb3RlOiBDb3Jkb3ZhIGVuc3VyZXMgdG8gY2FsbCB0aGUgaGFuZGxlciBldmVuIGlmIHRoZVxyXG4gICAgICAgIC8vIGV2ZW50IHdhcyBhbHJlYWR5IGZpcmVkLCBzbyBpcyBnb29kIHRvIGRvIGl0IGluc2lkZVxyXG4gICAgICAgIC8vIHRoZSBkb20tcmVhZHkgYW5kIHdlIGFyZSBlbnN1cmluZyB0aGF0IGV2ZXJ5dGhpbmcgaXNcclxuICAgICAgICAvLyByZWFkeS5cclxuICAgICAgICAkKGRvY3VtZW50KS5vbignZGV2aWNlcmVhZHknLCBhcHBJbml0KTtcclxuICAgIH0pO1xyXG59IGVsc2Uge1xyXG4gICAgLy8gT25seSBvbiBET00tUmVhZHksIGZvciBpbiBicm93c2VyIGRldmVsb3BtZW50XHJcbiAgICAkKGFwcEluaXQpO1xyXG59XHJcbiIsIi8qKlxyXG4gICAgQWNjZXNzIHRvIHVzZSBnbG9iYWwgQXBwIE1vZGFsc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuXHJcbi8qKlxyXG4gICAgR2VuZXJhdGVzIGEgdGV4dCBtZXNzYWdlLCB3aXRoIG5ld2xpbmVzIGlmIG5lZWRlZCwgZGVzY3JpYmluZyB0aGUgZXJyb3JcclxuICAgIG9iamVjdCBwYXNzZWQuXHJcbiAgICBAcGFyYW0gZXJyOmFueSBBcyBhIHN0cmluZywgaXMgcmV0dXJuZWQgJ2FzIGlzJzsgYXMgZmFsc3ksIGl0IHJldHVybiBhIGdlbmVyaWNcclxuICAgIG1lc3NhZ2UgZm9yICd1bmtub3cgZXJyb3InOyBhcyBvYmplY3QsIGl0IGludmVzdGlnYXRlIHdoYXQgdHlwZSBvZiBlcnJvciBpcyB0b1xyXG4gICAgcHJvdmlkZSB0aGUgbW9yZSBtZWFuaW5mdWwgcmVzdWx0LCB3aXRoIGZhbGxiYWNrIHRvIEpTT04uc3RyaW5naWZ5IHByZWZpeGVkXHJcbiAgICB3aXRoICdUZWNobmljYWwgZGV0YWlsczonLlxyXG4gICAgT2JqZWN0cyByZWNvZ25pemVkOlxyXG4gICAgLSBYSFIvalF1ZXJ5IGZvciBKU09OIHJlc3BvbnNlczoganVzdCBvYmplY3RzIHdpdGggcmVzcG9uc2VKU09OIHByb3BlcnR5LCBpc1xyXG4gICAgICB1c2VkIGFzIHRoZSAnZXJyJyBvYmplY3QgYW5kIHBhc3NlZCB0byB0aGUgb3RoZXIgb2JqZWN0IHRlc3RzLlxyXG4gICAgLSBPYmplY3Qgd2l0aCAnZXJyb3JNZXNzYWdlJyAoc2VydmVyLXNpZGUgZm9ybWF0dGVkIGVycm9yKS5cclxuICAgIC0gT2JqZWN0IHdpdGggJ21lc3NhZ2UnIHByb3BlcnR5LCBsaWtlIHRoZSBzdGFuZGFyZCBFcnJvciBjbGFzcyBhbmQgRXhjZXB0aW9uIG9iamVjdHMuXHJcbiAgICAtIE9iamVjdCB3aXRoICduYW1lJyBwcm9wZXJ0eSwgbGlrZSB0aGUgc3RhbmRhcmQgRXhjZXB0aW9uIG9iamVjdHMuIFRoZSBuYW1lLCBpZiBhbnksXHJcbiAgICAgIGlzIHNldCBhcyBwcmVmaXggZm9yIHRoZSAnbWVzc2FnZScgcHJvcGVydHkgdmFsdWUuXHJcbiAgICAtIE9iamVjdCB3aXRoICdlcnJvcnMnIHByb3BlcnR5LiBFYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IG9yIG9iamVjdCBvd24ga2V5c1xyXG4gICAgICBpcyBhcHBlbmRlZCB0byB0aGUgZXJyb3JNZXNzYWdlIG9yIG1lc3NhZ2Ugc2VwYXJhdGVkIGJ5IG5ld2xpbmUuXHJcbioqL1xyXG5leHBvcnRzLmdldEVycm9yTWVzc2FnZUZyb20gPSBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2VGcm9tKGVyciwgZGVmYXVsdFRleHQpIHtcclxuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6MTQsIG1heGRlcHRoOjUqL1xyXG5cclxuICAgIGRlZmF1bHRUZXh0ID0gZGVmYXVsdFRleHQgfHwgJ1Vua25vdyBlcnJvcic7XHJcbiAgICBcclxuICAgIGlmICghZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRUZXh0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mKGVycikgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGVyciB8fCBkZWZhdWx0VGV4dDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIElmIGlzIGEgWEhSIG9iamVjdCwgdXNlIGl0cyByZXNwb25zZSBhcyB0aGUgZXJyb3IuXHJcbiAgICAgICAgZXJyID0gZXJyLnJlc3BvbnNlSlNPTiB8fCBlcnI7XHJcblxyXG4gICAgICAgIHZhciBtc2cgPSBlcnIubmFtZSAmJiAoZXJyLm5hbWUgKyAnOiAnKSB8fCAnJztcclxuICAgICAgICBtc2cgKz0gZXJyLmVycm9yTWVzc2FnZSB8fCBlcnIubWVzc2FnZSB8fCAnJztcclxuXHJcbiAgICAgICAgaWYgKGVyci5lcnJvcnMpIHtcclxuICAgICAgICAgICAgbXNnICs9ICdcXG4nICsgZXhwb3J0cy5zdHJpbmdpZnlFcnJvcnNMaXN0KGVyci5lcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQXZvaWRpbmcgdGhhdCBlbiBlcnJvciBjb252ZXJ0aW5nIHRoZSBvYmplY3QgKGNpcmN1bGFyIHJlZmVyZW5jZXMpXHJcbiAgICAgICAgICAgIC8vIGJyZWFrcyB0aGUgZXJyb3IgY29udHJvbCFcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBqc2VyciA9IEpTT04uc3RyaW5naWZ5KGVycik7XHJcbiAgICAgICAgICAgICAgICAvLyBBdm9pZGluZyB0aGF0IGVtcHR5IHJlc3VsdHMgKGVtcHR5IHN0cmluZyBvciBlbXB0eSBvYmplY3Qgd2hlbiB0aGVyZVxyXG4gICAgICAgICAgICAgICAgLy8gaXMgbm8gZGV0YWlscyB0byBzaG93KSBtYWtlcyB1cyB0byBzaG93IGFuIGFubm95aW5nICd0ZWNobmljYWwgZGV0YWlscydcclxuICAgICAgICAgICAgICAgIHZhciBoYXNNb3JlSW5mbyA9IGpzZXJyICYmIGpzZXJyICE9PSAne30nO1xyXG4gICAgICAgICAgICAgICAgLy8gVG9vIGlmIHRoZXJlIGlzIG5vIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGUgb25lIGV4dHJhY3RlZCB0byBidWlsZCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UsIHNpbmNlIG9uIHRoYXQgY2FzZXMgdGhlICd0ZWNobmljYWwgZGV0YWlscycgd2lsbCBiZSBqdXN0IGEgXHJcbiAgICAgICAgICAgICAgICAvLyBqc29uIGZvcm1hdHRlZCBvZiB0aGUgc2FtZSBkaXNwbGF5ZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc01vcmVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgaW5pdGlhbGx5LCByZS1lbmFibGVkIG9ubHkgaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYW4gdGhlIG9uZXMgZnJvbSB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc01vcmVJbmZvID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VQcm9wZXJ0aWVzTGlzdCA9IFsnbmFtZScsICdlcnJvck1lc3NhZ2UnLCAnbWVzc2FnZScsICdlcnJvcnMnXTtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhlcnIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlUHJvcGVydGllc0xpc3QuaW5kZXhPZihrZXkpID09PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc01vcmVJbmZvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW9yZUluZm8pXHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9ICdcXG5cXG5UZWNobmljYWwgZGV0YWlsczogJyArIGpzZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ltcG9zc2libGUgdG8gc3RyaW5naWZ5IEpTT04gZXJyb3InLCBlcnIsIGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1zZyB8fCBkZWZhdWx0VGV4dDtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydHMuc3RyaW5naWZ5RXJyb3JzTGlzdCA9IGZ1bmN0aW9uIChlcnJvcnMpIHtcclxuICAgIHZhciBtc2cgPSAnJztcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9ycykpIHtcclxuICAgICAgICBtc2cgPSBlcnJvcnMuam9pbignXFxuJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBtc2cgPSBPYmplY3Qua2V5cyhlcnJvcnMpLm1hcChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yc1trZXldLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgIH0pLmpvaW4oJ1xcbicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1zZztcclxufTtcclxuXHJcbi8qKlxyXG4gICAgU2hvdyBhbiBlcnJvciBtb2RhbCB0byBub3RpZnkgdGhlIHVzZXIuXHJcbiAgICBAcGFyYW0gb3B0aW9uczpPYmplY3Qge1xyXG4gICAgICAgIG1lc3NhZ2U6c3RyaW5nIERFUFJFQ0FURUQuIE9wdGlvbmFsLiBJbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlLlxyXG4gICAgICAgIGVycm9yOnN0cmluZyBPcHRpb25hbC4gRXJyb3IvRXhjZXB0aW9uL1hIUiBvYmplY3QsIHVzZWQgdG8gYXV0b1xyXG4gICAgICAgICAgICBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZS4gSXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyICdtZXNzYWdlJ1xyXG4gICAgICAgICAgICBvcHRpb24sIGRpc2NhcmRpbmcgYW4gZXJyb3Igb2JqZWN0L3N0cmluZyBpcyBwYXNzZWQuXHJcbiAgICAgICAgICAgIEl0IHJlcGxhY2VzICdtZXNzYWdlJyBzaW5jZSBjYW4gZG8gdGhlIHNhbWUgYW5kIG1vcmUuXHJcbiAgICAgICAgdGl0bGU6c3RyaW5nIE9wdGlvbmFsLiBUaGUgdGV4dCB0byBzaG93IGluIHRoZSBtb2RhbCdzIGhlYWRlcixcclxuICAgICAgICAgICAgd2l0aCBmYWxsYmFjayB0byB0aGUgTW9kYWwncyBkZWZhdWx0IHRpdGxlLlxyXG4gICAgfVxyXG4gICAgQHJldHVybnMgUHJvbWlzZS4gSXQgcmVzb2x2ZXMgd2hlbiB0aGUgbW9kYWwgaXMgZGlzbWlzc2VkL2Nsb3NlZC5cclxuICAgIE5vIGZvcm1hbCByZWplY3Rpb24gaGFwcGVucy5cclxuKiovXHJcbmV4cG9ydHMuc2hvd0Vycm9yID0gZnVuY3Rpb24gc2hvd0Vycm9yTW9kYWwob3B0aW9ucykge1xyXG4gICAgXHJcbiAgICB2YXIgbW9kYWwgPSAkKCcjZXJyb3JNb2RhbCcpLFxyXG4gICAgICAgIGhlYWRlciA9IG1vZGFsLmZpbmQoJyNlcnJvck1vZGFsLWxhYmVsJyksXHJcbiAgICAgICAgYm9keSA9IG1vZGFsLmZpbmQoJyNlcnJvck1vZGFsLWJvZHknKTtcclxuICAgIFxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIC8vIEZhbGxiYWNrIGVycm9yIG1lc3NhZ2VcclxuICAgIHZhciBtc2cgPSBib2R5LmRhdGEoJ2RlZmF1bHQtdGV4dCcpO1xyXG5cclxuICAgIC8vIEVycm9yIG1lc3NhZ2UgZnJvbSBnaXZlbiBlcnJvciBvYmplY3QsIHdpdGggZmFsbGJhY2sgdG8gZGVmYXVsdCBvbmUuXHJcbiAgICAvLyBERVBSRUNBVEVEIHRlbXBvcmFybHkgdXNpbmcgdGhlICdtZXNzYWdlJyBvcHRpb24uXHJcbiAgICBtc2cgPSBleHBvcnRzLmdldEVycm9yTWVzc2FnZUZyb20ob3B0aW9ucy5lcnJvciB8fCBvcHRpb25zLm1lc3NhZ2UsIG1zZyk7XHJcblxyXG4gICAgYm9keS5tdWx0aWxpbmUobXNnKTtcclxuXHJcbiAgICBoZWFkZXIudGV4dChvcHRpb25zLnRpdGxlIHx8IGhlYWRlci5kYXRhKCdkZWZhdWx0LXRleHQnKSk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XHJcbiAgICAgICAgbW9kYWwubW9kYWwoJ3Nob3cnKTtcclxuICAgICAgICBtb2RhbC5vbignaGlkZS5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgU2hvdyBjb25maXJtYXRpb24gbW9kYWwgd2l0aCB0d28gYnV0dG9ucy5cclxuICAgIEBwYXJhbSBvcHRpb25zOm9iamVjdCB7XHJcbiAgICAgICAgdGl0bGU6c3RyaW5nIEhlYWRlciB0aXRsZSB0ZXh0XHJcbiAgICAgICAgbWVzc2FnZTpzdHJpbmcgTWVzc2FnZSB0ZXh0XHJcbiAgICAgICAgeWVzOnN0cmluZyBZZXMgYnV0dG9uIGxhYmVsXHJcbiAgICAgICAgbm86c3RyaW5nIE5vIGJ1dHRvbiBsYWJlbFxyXG4gICAgfVxyXG4gICAgQHJldHVybnMgUHJvbWlzZS4gSXQgcmVzb2x2ZXMgaWYgYnV0dG9uICd5ZXMnIHByZXNzZWRcclxuICAgIGFuZCByZWplY3Qgb24gYnV0dG9uICdubycgcHJlc3NlZCBvciBtb2RhbCBkaXNtaXNzZWQvY2xvc2VkLlxyXG4qKi9cclxuZXhwb3J0cy5jb25maXJtID0gZnVuY3Rpb24gY29uZmlybShvcHRpb25zKSB7XHJcbiAgICBcclxuICAgIHZhciBtb2RhbCA9ICQoJyNjb25maXJtTW9kYWwnKSxcclxuICAgICAgICBoZWFkZXIgPSBtb2RhbC5maW5kKCcjY29uZmlybU1vZGFsLWxhYmVsJyksXHJcbiAgICAgICAgYm9keSA9IG1vZGFsLmZpbmQoJyNjb25maXJtTW9kYWwtYm9keScpLFxyXG4gICAgICAgIHllc0J0biA9IG1vZGFsLmZpbmQoJyNjb25maXJtTW9kYWwteWVzQnRuJyksXHJcbiAgICAgICAgbm9CdG4gPSBtb2RhbC5maW5kKCcjY29uZmlybU1vZGFsLW5vQnRuJyk7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLy8gRmFsbGJhY2sgZXJyb3IgbWVzc2FnZVxyXG4gICAgdmFyIHRpdGxlID0gaGVhZGVyLmRhdGEoJ2RlZmF1bHQtdGV4dCcpLFxyXG4gICAgICAgIG1zZyA9IGJvZHkuZGF0YSgnZGVmYXVsdC10ZXh0JyksXHJcbiAgICAgICAgeWVzID0geWVzQnRuLmRhdGEoJ2RlZmF1bHQtdGV4dCcpLFxyXG4gICAgICAgIG5vID0gbm9CdG4uZGF0YSgnZGVmYXVsdC10ZXh0Jyk7XHJcblxyXG4gICAgYm9keS5tdWx0aWxpbmUob3B0aW9ucy5tZXNzYWdlIHx8IG1zZyk7XHJcbiAgICBoZWFkZXIudGV4dChvcHRpb25zLnRpdGxlIHx8IHRpdGxlKTtcclxuICAgIHllc0J0bi50ZXh0KG9wdGlvbnMueWVzIHx8IHllcyk7XHJcbiAgICBub0J0bi50ZXh0KG9wdGlvbnMubm8gfHwgbm8pO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBtb2RhbC5tb2RhbCgnc2hvdycpO1xyXG4gICAgICAgIHllc0J0bi5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vQnRuLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBtb2RhbC5vbignaGlkZS5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBTaG93IGFuIGluZm9ybWF0aW9uIG1vZGFsIHRvIG5vdGlmeSB0aGUgdXNlciBhYm91dCBzb21ldGhpbmcuXHJcbiAgICBAcGFyYW0gb3B0aW9uczpPYmplY3Qge1xyXG4gICAgICAgIG1lc3NhZ2U6c3RyaW5nLiBJbmZvcm1hdGl2ZSBtZXNzYWdlLlxyXG4gICAgICAgIHRpdGxlOnN0cmluZyBPcHRpb25hbC4gVGhlIHRleHQgdG8gc2hvdyBpbiB0aGUgbW9kYWwncyBoZWFkZXIsXHJcbiAgICAgICAgICAgIHdpdGggZmFsbGJhY2sgdG8gdGhlIE1vZGFsJ3MgZGVmYXVsdCB0aXRsZS5cclxuICAgIH1cclxuICAgIEByZXR1cm5zIFByb21pc2UuIEl0IHJlc29sdmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRpc21pc3NlZC9jbG9zZWQuXHJcbiAgICBObyBmb3JtYWwgcmVqZWN0aW9uIGhhcHBlbnMuXHJcbioqL1xyXG5leHBvcnRzLnNob3dOb3RpZmljYXRpb24gPSBmdW5jdGlvbiBzaG93Tm90aWZpY2F0aW9uKG9wdGlvbnMpIHtcclxuICAgIFxyXG4gICAgdmFyIG1vZGFsID0gJCgnI25vdGlmaWNhdGlvbk1vZGFsJyksXHJcbiAgICAgICAgaGVhZGVyID0gbW9kYWwuZmluZCgnI25vdGlmaWNhdGlvbk1vZGFsLWxhYmVsJyksXHJcbiAgICAgICAgYm9keSA9IG1vZGFsLmZpbmQoJyNub3RpZmljYXRpb25Nb2RhbC1ib2R5Jyk7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIC8vIEZhbGxiYWNrIG1lc3NhZ2VcclxuICAgIHZhciBtc2cgPSBvcHRpb25zLm1lc3NhZ2UgfHwgYm9keS5kYXRhKCdkZWZhdWx0LXRleHQnKTtcclxuXHJcbiAgICBib2R5Lm11bHRpbGluZShtc2cpO1xyXG5cclxuICAgIGhlYWRlci50ZXh0KG9wdGlvbnMudGl0bGUgfHwgaGVhZGVyLmRhdGEoJ2RlZmF1bHQtdGV4dCcpKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcclxuICAgICAgICBtb2RhbC5tb2RhbCgnc2hvdycpO1xyXG4gICAgICAgIG1vZGFsLm9uKCdoaWRlLmJzLm1vZGFsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0cy5zaG93VGltZVBpY2tlciA9IHJlcXVpcmUoJy4vbW9kYWxzL3RpbWVQaWNrZXInKS5zaG93O1xyXG4iLCIvKipcclxuICAgIFNldHVwIG9mIHRoZSBzaGVsbCBvYmplY3QgdXNlZCBieSB0aGUgYXBwXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcclxuXHJcbi8vdmFyIEhpc3RvcnkgPSByZXF1aXJlKCcuL2FwcC1zaGVsbC1oaXN0b3J5JykuY3JlYXRlKGJhc2VVcmwpO1xyXG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vdXRpbHMvc2hlbGwvaGFzaGJhbmdIaXN0b3J5Jyk7XHJcblxyXG4vLyBTaGVsbCBkZXBlbmRlbmNpZXNcclxudmFyIHNoZWxsID0gcmVxdWlyZSgnLi91dGlscy9zaGVsbC9pbmRleCcpLFxyXG4gICAgU2hlbGwgPSBzaGVsbC5TaGVsbCxcclxuICAgIERvbUl0ZW1zTWFuYWdlciA9IHNoZWxsLkRvbUl0ZW1zTWFuYWdlcjtcclxuXHJcbi8vdmFyIGlPUyA9IC8oaVBhZHxpUGhvbmV8aVBvZCkvZy50ZXN0KCBuYXZpZ2F0b3IudXNlckFnZW50ICk7XHJcblxyXG4vLyBDcmVhdGluZyB0aGUgc2hlbGw6XHJcbnZhciBzaGVsbCA9IG5ldyBTaGVsbCh7XHJcblxyXG4gICAgLy8gU2VsZWN0b3IsIERPTSBlbGVtZW50IG9yIGpRdWVyeSBvYmplY3QgcG9pbnRpbmdcclxuICAgIC8vIHRoZSByb290IG9yIGNvbnRhaW5lciBmb3IgdGhlIHNoZWxsIGl0ZW1zXHJcbiAgICByb290OiAnYm9keScsXHJcblxyXG4gICAgLy8gSWYgaXMgbm90IGluIHRoZSBzaXRlIHJvb3QsIHRoZSBiYXNlIFVSTCBpcyByZXF1aXJlZDpcclxuICAgIGJhc2VVcmw6IGJhc2VVcmwsXHJcbiAgICBcclxuICAgIGZvcmNlSGFzaGJhbmc6IHRydWUsXHJcblxyXG4gICAgaW5kZXhOYW1lOiAnaW5kZXgnLFxyXG5cclxuICAgIGxpbmtFdmVudDogJ2NsaWNrJyxcclxuXHJcbiAgICAvLyBObyBuZWVkIGZvciBsb2FkZXIsIGV2ZXJ5dGhpbmcgY29tZXMgYnVuZGxlZFxyXG4gICAgbG9hZGVyOiBudWxsLFxyXG5cclxuICAgIC8vIEhpc3RvcnkgUG9seWZpbGw6XHJcbiAgICBoaXN0b3J5OiBIaXN0b3J5LFxyXG5cclxuICAgIC8vIEEgRG9tSXRlbXNNYW5hZ2VyIG9yIGVxdWl2YWxlbnQgb2JqZWN0IGluc3RhbmNlIG5lZWRzIHRvXHJcbiAgICAvLyBiZSBwcm92aWRlZDpcclxuICAgIGRvbUl0ZW1zTWFuYWdlcjogbmV3IERvbUl0ZW1zTWFuYWdlcih7XHJcbiAgICAgICAgaWRBdHRyaWJ1dGVOYW1lOiAnZGF0YS1hY3Rpdml0eSdcclxuICAgIH0pXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzaGVsbDtcclxuIiwiLyoqIFxyXG4gICAgQXBwTW9kZWwgZXh0ZW5zaW9uLFxyXG4gICAgZm9jdXNlZCBvbiB0aGUgQWNjb3VudCByZWxhdGVkIEFQSXM6XHJcbiAgICAtIGxvZ2luXHJcbiAgICAtIGxvZ291dFxyXG4gICAgLSBzaWdudXBcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyk7XHJcblxyXG5leHBvcnRzLnBsdWdJbiA9IGZ1bmN0aW9uIChBcHBNb2RlbCkge1xyXG4gICAgLyoqXHJcbiAgICAgICAgVHJ5IHRvIHBlcmZvcm0gYW4gYXV0b21hdGljIGxvZ2luIGlmIHRoZXJlIGlzIGEgbG9jYWxcclxuICAgICAgICBjb3B5IG9mIGNyZWRlbnRpYWxzIHRvIHVzZSBvbiB0aGF0LFxyXG4gICAgICAgIGNhbGxpbmcgdGhlIGxvZ2luIG1ldGhvZCB0aGF0IHNhdmUgdGhlIHVwZGF0ZWRcclxuICAgICAgICBkYXRhIGFuZCBwcm9maWxlLlxyXG4gICAgKiovXHJcbiAgICBBcHBNb2RlbC5wcm90b3R5cGUudHJ5TG9naW4gPSBmdW5jdGlvbiB0cnlMb2dpbigpIHtcclxuICAgICAgICAvLyBHZXQgc2F2ZWQgY3JlZGVudGlhbHNcclxuICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnY3JlZGVudGlhbHMnKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgb25lcywgdHJ5IHRvIGxvZy1pblxyXG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgbG9naW4gd2l0aCB0aGF0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2dpbihcclxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFscy51c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFscy5wYXNzd29yZFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2F2ZWQgY3JlZGVudGlhbHMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIFBlcmZvcm1zIGEgbG9naW4gYXR0ZW1wdCB3aXRoIHRoZSBBUEkgYnkgdXNpbmdcclxuICAgICAgICB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMuXHJcbiAgICAqKi9cclxuICAgIEFwcE1vZGVsLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uIGxvZ2luKHVzZXJuYW1lLCBwYXNzd29yZCkge1xyXG5cclxuICAgICAgICAvLyBSZXNldCB0aGUgZXh0cmEgaGVhZGVycyB0byBhdHRlbXB0IHRoZSBsb2dpblxyXG4gICAgICAgIHRoaXMucmVzdC5leHRyYUhlYWRlcnMgPSBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN0LnBvc3QoJ2xvZ2luJywge1xyXG4gICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcclxuICAgICAgICAgICAgcmV0dXJuUHJvZmlsZTogdHJ1ZVxyXG4gICAgICAgIH0pLnRoZW4ocGVyZm9ybUxvY2FsTG9naW4odGhpcywgdXNlcm5hbWUsIHBhc3N3b3JkKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIFBlcmZvcm1zIGEgbG9nb3V0LCByZW1vdmluZyBjYWNoZWQgY3JlZGVudGlhbHNcclxuICAgICAgICBhbmQgcHJvZmlsZSBzbyB0aGUgYXBwIGNhbiBiZSBmaWxsZWQgdXAgd2l0aFxyXG4gICAgICAgIG5ldyB1c2VyIGluZm9ybWF0aW9uLlxyXG4gICAgICAgIEl0IGNhbGxzIHRvIHRoZSBBUEkgbG9nb3V0IGNhbGwgdG9vLCB0byByZW1vdmVcclxuICAgICAgICBhbnkgc2VydmVyLXNpZGUgc2Vzc2lvbiBhbmQgbm90aWZpY2F0aW9uXHJcbiAgICAgICAgKHJlbW92ZXMgdGhlIGNvb2tpZSB0b28sIGZvciBicm93c2VyIGVudmlyb25tZW50XHJcbiAgICAgICAgdGhhdCBtYXkgdXNlIGl0KS5cclxuICAgICoqL1xyXG4gICAgLy8gRlVUVVJFOiBUT1JFVklFVyBpZiB0aGUgL2xvZ291dCBjYWxsIGNhbiBiZSByZW1vdmVkLlxyXG4gICAgQXBwTW9kZWwucHJvdG90eXBlLmxvZ291dCA9IGZ1bmN0aW9uIGxvZ291dCgpIHtcclxuXHJcbiAgICAgICAgLy8gTG9jYWwgYXBwIGNsb3NlIHNlc3Npb25cclxuICAgICAgICB0aGlzLnJlc3QuZXh0cmFIZWFkZXJzID0gbnVsbDtcclxuICAgICAgICBsb2NhbGZvcmFnZS5yZW1vdmVJdGVtKCdjcmVkZW50aWFscycpO1xyXG4gICAgICAgIGxvY2FsZm9yYWdlLnJlbW92ZUl0ZW0oJ3Byb2ZpbGUnKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBMb2NhbCBkYXRhIGNsZWFuLXVwIVxyXG4gICAgICAgIHRoaXMuY2xlYXJMb2NhbERhdGEoKTtcclxuXHJcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3YWl0IHRoZSByZXN1bHQgb2YgdGhlIFJFU1Qgb3BlcmF0aW9uXHJcbiAgICAgICAgdGhpcy5yZXN0LnBvc3QoJ2xvZ291dCcpO1xyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIEF0dGVtcHRzIHRvIGNyZWF0ZSBhIHVzZXIgYWNjb3VudCwgZ2V0dGluZyBsb2dnZWRcclxuICAgICAgICBpZiBzdWNjZXNzZnVsbHkgbGlrZSB3aGVuIGRvaW5nIGEgbG9naW4gY2FsbC5cclxuICAgICoqL1xyXG4gICAgQXBwTW9kZWwucHJvdG90eXBlLnNpZ251cCA9IGZ1bmN0aW9uIHNpZ251cCh1c2VybmFtZSwgcGFzc3dvcmQsIHByb2ZpbGVUeXBlKSB7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBleHRyYSBoZWFkZXJzIHRvIGF0dGVtcHQgdGhlIHNpZ251cFxyXG4gICAgICAgIHRoaXMucmVzdC5leHRyYUhlYWRyZXMgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIHRoZSBzYW1lIGFzIGluIGEgbG9naW4sIGFuZFxyXG4gICAgICAgIC8vIHdlIGRvIHRoZSBzYW1lIGFzIHRoZXJlIHRvIGdldCB0aGUgdXNlciBsb2dnZWRcclxuICAgICAgICAvLyBvbiB0aGUgYXBwIG9uIHNpZ24tdXAgc3VjY2Vzcy5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN0LnBvc3QoJ3NpZ251cD91dG1fc291cmNlPWFwcCcsIHtcclxuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcbiAgICAgICAgICAgIHByb2ZpbGVUeXBlOiBwcm9maWxlVHlwZSxcclxuICAgICAgICAgICAgcmV0dXJuUHJvZmlsZTogdHJ1ZVxyXG4gICAgICAgIH0pLnRoZW4ocGVyZm9ybUxvY2FsTG9naW4odGhpcywgdXNlcm5hbWUsIHBhc3N3b3JkKSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcGVyZm9ybUxvY2FsTG9naW4odGhpc0FwcE1vZGVsLCB1c2VybmFtZSwgcGFzc3dvcmQpIHtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24obG9nZ2VkKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBwcmV2aW91cyBsb2NhbCBkYXRhIGlmIGFueTpcclxuICAgICAgICByZXR1cm4gdGhpc0FwcE1vZGVsLmNsZWFyTG9jYWxEYXRhKClcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHVzZSBhdXRob3JpemF0aW9uIGtleSBmb3IgZWFjaFxyXG4gICAgICAgICAgICAvLyBuZXcgUmVzdCByZXF1ZXN0XHJcbiAgICAgICAgICAgIHRoaXNBcHBNb2RlbC5yZXN0LmV4dHJhSGVhZGVycyA9IHtcclxuICAgICAgICAgICAgICAgIGFsdTogbG9nZ2VkLnVzZXJJRCxcclxuICAgICAgICAgICAgICAgIGFsazogbG9nZ2VkLmF1dGhLZXlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFzeW5jIGxvY2FsIHNhdmUsIGRvbid0IHdhaXRcclxuICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgnY3JlZGVudGlhbHMnLCB7XHJcbiAgICAgICAgICAgICAgICB1c2VySUQ6IGxvZ2dlZC51c2VySUQsXHJcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICBhdXRoS2V5OiBsb2dnZWQuYXV0aEtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBMb2NhbCBuYW1lIGtlcHQgaW4gc3luYyB3aXRoIHNldC11cCBhdCBBcHBNb2RlbC51c2VyUHJvZmlsZVxyXG4gICAgICAgICAgICBsb2NhbGZvcmFnZS5zZXRJdGVtKCdwcm9maWxlJywgbG9nZ2VkLnByb2ZpbGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHVzZXIgZGF0YVxyXG4gICAgICAgICAgICB0aGlzQXBwTW9kZWwudXNlcigpLm1vZGVsLnVwZGF0ZVdpdGgobG9nZ2VkLnByb2ZpbGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlZDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuIiwiLyoqIEJvb2tpbmdzXHJcblxyXG4gICAgSU1QT1JUQU5UISEhISBBUEkgbm90IHRvIHVzZSBkaXJlY3RseSBieSB0aGUgYXBwLCBidXQgdGhyb3VnaCBhcHBNb2RlbC5jYWxlbmRhciAoaXQgaGFzIGNhY2hlIGFuZCBtb3JlKVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEJvb2tpbmcgPSByZXF1aXJlKCcuLi9tb2RlbHMvQm9va2luZycpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG5cclxuICAgIHZhciBhcGkgPSB7XHJcbiAgICAgICAgcmVtb3RlOiB7XHJcbiAgICAgICAgICAgIHJlc3Q6IGFwcE1vZGVsLnJlc3QsXHJcbiAgICAgICAgICAgIGdldEJvb2tpbmdzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ2Jvb2tpbmdzJywgZmlsdGVycylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJhd0l0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd0l0ZW1zICYmIHJhd0l0ZW1zLm1hcChmdW5jdGlvbihyYXdJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9va2luZyhyYXdJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhcGkuZ2V0Qm9va2luZ3NCeURhdGVzID0gZnVuY3Rpb24gZ2V0Qm9va2luZ3NCeURhdGVzKGRhdGUsIGVuZCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGVuZCA9IGVuZCB8fCBtb21lbnQoZGF0ZSkuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZW1vdGUgbG9hZGluZyBkYXRhXHJcbiAgICAgICAgcmV0dXJuIGFwaS5yZW1vdGUuZ2V0Qm9va2luZ3Moe1xyXG4gICAgICAgICAgICBzdGFydDogZGF0ZSxcclxuICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGJvb2tpbmdzKSB7XHJcbiAgICAgICAgICAgIC8vIFB1dCBpbiBjYWNoZSAodGhleSBhcmUgYWxyZWFkeSBtb2RlbCBpbnN0YW5jZXMpXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBrby5vYnNlcnZhYmxlQXJyYXkoYm9va2luZ3MpO1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG9ic2VydmFibGUgYXJyYXlcclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEdldCB1cGNvbWluZyBib29raW5ncyBtZXRhLWluZm9ybWF0aW9uIGZvciBkYXNoYm9hcmQgcGFnZVxyXG4gICAgKiovXHJcbiAgICBhcGkuZ2V0VXBjb21pbmdCb29raW5ncyA9IGZ1bmN0aW9uIGdldFVwY29taW5nQm9va2luZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1cGNvbWluZy1ib29raW5ncycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgYSBzcGVjaWZpYyBib29raW5nIGJ5IElEXHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXRCb29raW5nID0gZnVuY3Rpb24gZ2V0Qm9va2luZyhpZCkge1xyXG4gICAgICAgIGlmICghaWQpIHJldHVybiBQcm9taXNlLnJlamVjdCgnVGhlIGJvb2tpbmdJRCBpcyByZXF1aXJlZCB0byBnZXQgYSBib29raW5nJyk7XHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdib29raW5ncy8nICsgaWQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oYm9va2luZykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvb2tpbmcoYm9va2luZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBDb252ZXJ0cyBhbiBBcHBvaW50bWVudCBtb2RlbCBpbnRvIGEgc2ltcGxpZmllZFxyXG4gICAgICAgIGJvb2tpbmcgcGxhaW4gb2JqZWN0LCBzdWl0YWJsZSB0byBSRVNUIEFQSSBmb3IgZWRpdGlvblxyXG4gICAgKiovXHJcbiAgICBhcGkuYXBwb2ludG1lbnRUb1NpbXBsaWZpZWRCb29raW5nID0gZnVuY3Rpb24oYXB0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm9va2luZ0lEOiBhcHQuc291cmNlQm9va2luZygpLmJvb2tpbmdJRCgpLFxyXG4gICAgICAgICAgICBjdXN0b21lclVzZXJJRDogYXB0LmN1c3RvbWVyVXNlcklEKCksXHJcbiAgICAgICAgICAgIGFkZHJlc3NJRDogYXB0LmFkZHJlc3NJRCgpLFxyXG4gICAgICAgICAgICBzdGFydFRpbWU6IGFwdC5zdGFydFRpbWUoKSxcclxuICAgICAgICAgICAgcHJpY2luZzogYXB0LnByaWNpbmcoKS5tYXAoZnVuY3Rpb24ocHJpY2luZykge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZm9yIG5vdywgdGhlIFJFU1QgQVBJIGFsbG93IG9ubHkgYSBsaXN0IG9mIElEcyxcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBvYmplY3RzLCBzbyBuZXh0IGxpbmUgaXMgcmVwbGFjZWQ6XHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBwcmljaW5nLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpY2luZy5mcmVlbGFuY2VyUHJpY2luZ0lEKCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBwcmVOb3Rlc1RvQ2xpZW50OiBhcHQucHJlTm90ZXNUb0NsaWVudCgpLFxyXG4gICAgICAgICAgICBwcmVOb3Rlc1RvU2VsZjogYXB0LnByZU5vdGVzVG9TZWxmKCksXHJcbiAgICAgICAgICAgIHBvc3ROb3Rlc1RvQ2xpZW50OiBhcHQucG9zdE5vdGVzVG9DbGllbnQoKSxcclxuICAgICAgICAgICAgcG9zdE5vdGVzVG9TZWxmOiBhcHQucG9zdE5vdGVzVG9TZWxmKClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICAgIENvbnZlcnN0IGEgQm9va2luZyBtb2RlbCBpbnRvIGEgc2ltcGxpZmllZFxyXG4gICAgICAgIGJvb2tpbmcgcGxhaW4gb2JqZWN0LCBzdWl0YWJsZSB0byBSRVNUIEFQSSBmb3IgZWRpdGlvblxyXG4gICAgKiovXHJcbiAgICBhcGkuYm9va2luZ1RvU2ltcGxpZmllZEJvb2tpbmcgPSBmdW5jdGlvbihib29raW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm9va2luZ0lEOiBib29raW5nKCkuYm9va2luZ0lEKCksXHJcbiAgICAgICAgICAgIGN1c3RvbWVyVXNlcklEOiBib29raW5nLmN1c3RvbWVyVXNlcklEKCksXHJcbiAgICAgICAgICAgIGFkZHJlc3NJRDogYm9va2luZy5hZGRyZXNzSUQoKSxcclxuICAgICAgICAgICAgc3RhcnRUaW1lOiBib29raW5nLnN0YXJ0VGltZSgpLFxyXG4gICAgICAgICAgICBwcmljaW5nOiBib29raW5nLmJvb2tpbmdSZXF1ZXN0KCkucHJpY2luZ0VzdGltYXRlKCkuZGV0YWlscygpLnByaWNpbmdcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwcmljaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBmb3Igbm93LCB0aGUgUkVTVCBBUEkgYWxsb3cgb25seSBhIGxpc3Qgb2YgSURzLFxyXG4gICAgICAgICAgICAgICAgLy8gbm90IG9iamVjdHMsIHNvIG5leHQgbGluZSBpcyByZXBsYWNlZDpcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHByaWNpbmcubW9kZWwudG9QbGFpbk9iamVjdCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmljaW5nLmZyZWVsYW5jZXJQcmljaW5nSUQoKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHByZU5vdGVzVG9DbGllbnQ6IGJvb2tpbmcucHJlTm90ZXNUb0NsaWVudCgpLFxyXG4gICAgICAgICAgICBwcmVOb3Rlc1RvU2VsZjogYm9va2luZy5wcmVOb3Rlc1RvU2VsZigpLFxyXG4gICAgICAgICAgICBwb3N0Tm90ZXNUb0NsaWVudDogYm9va2luZy5wb3N0Tm90ZXNUb0NsaWVudCgpLFxyXG4gICAgICAgICAgICBwb3N0Tm90ZXNUb1NlbGY6IGJvb2tpbmcucG9zdE5vdGVzVG9TZWxmKClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgQ3JlYXRlcy91cGRhdGVzIGEgYm9va2luZywgZ2l2ZW4gYSBzaW1wbGlmaWVkIGJvb2tpbmdcclxuICAgICAgICBvYmplY3Qgb3IgYW4gQXBwb2ludG1lbnQgbW9kZWwgb3IgYSBCb29raW5nIG1vZGVsXHJcbiAgICAqKi9cclxuICAgIGFwaS5zZXRCb29raW5nID0gZnVuY3Rpb24gc2V0Qm9va2luZyhib29raW5nLCBhbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUpIHsgICAgXHJcbiAgICAgICAgYm9va2luZyA9IGJvb2tpbmcuYm9va2luZ0lEID9cclxuICAgICAgICAgICAgYXBpLmJvb2tpbmdUb1NpbXBsaWZpZWRCb29raW5nKGJvb2tpbmcpIDpcclxuICAgICAgICAgICAgYm9va2luZy5zb3VyY2VCb29raW5nID9cclxuICAgICAgICAgICAgICAgIGFwaS5hcHBvaW50bWVudFRvU2ltcGxpZmllZEJvb2tpbmcoYm9va2luZykgOlxyXG4gICAgICAgICAgICAgICAgYm9va2luZ1xyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgdmFyIGlkID0gYm9va2luZy5ib29raW5nSUQgfHwgJycsXHJcbiAgICAgICAgICAgIG1ldGhvZCA9IGlkID8gJ3B1dCcgOiAncG9zdCc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYm9va2luZy5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUgPSBhbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUgfHwgZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0W21ldGhvZF0oJ2ZyZWVsYW5jZXItYm9va2luZ3MvJyArIGlkLCBib29raW5nKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckJvb2tpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29raW5nKHNlcnZlckJvb2tpbmcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKipcclxuICAgIEl0IG9mZmVycyBhY2Nlc3MgdG8gY2FsZW5kYXIgZWxlbWVudHMgKGFwcG9pbnRtZW50cykgYW5kIGF2YWlsYWJpbGl0eVxyXG4gICAgXHJcbiAgICBBcHBvaW50bWVudHMgaXMgYW4gYWJzdHJhY3Rpb24gYXJvdW5kIGNhbGVuZGFyIGV2ZW50c1xyXG4gICAgdGhhdCBiZWhhdmUgYXMgYm9va2luZ3Mgb3IgYXMgZXZlbnRzICh3aGVyZSBib29raW5ncyBhcmUgYnVpbHRcclxuICAgIG9uIHRvcCBvZiBhbiBldmVudCBpbnN0YW5jZSAtLWEgYm9va2luZyByZWNvcmQgbXVzdCBoYXZlIGV2ZXIgYSBjb25maXJtZWREYXRlSUQgZXZlbnQpLlxyXG4gICAgXHJcbiAgICBXaXRoIHRoaXMgYXBwTW9kZWwsIHRoZSBBUElzIHRvIG1hbmFnZSBldmVudHMmYm9va2luZ3MgYXJlIGNvbWJpbmVkIHRvIG9mZmVyIHJlbGF0ZWRcclxuICAgIHJlY29yZHMgZWFzaWVyIGluIEFwcG9pbnRtZW50cyBvYmplY3RzLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEFwcG9pbnRtZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FwcG9pbnRtZW50JyksXHJcbiAgICBEYXRlQXZhaWxhYmlsaXR5ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0RhdGVBdmFpbGFiaWxpdHknKSxcclxuICAgIERhdGVDYWNoZSA9IHJlcXVpcmUoJy4uL3V0aWxzL0RhdGVDYWNoZScpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXHJcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoJyksXHJcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIEFwaSgpIHtcclxuICAgICAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldE1heExpc3RlbmVycygzMCk7XHJcbiAgICB9XHJcbiAgICBBcGkuX2luaGVyaXRzKEV2ZW50RW1pdHRlcik7XHJcbiAgICBcclxuICAgIHZhciBhcGkgPSBuZXcgQXBpKCk7XHJcbiAgICBcclxuICAgIHZhciBjYWNoZSA9IG5ldyBEYXRlQ2FjaGUoe1xyXG4gICAgICAgIE1vZGVsOiBEYXRlQXZhaWxhYmlsaXR5LFxyXG4gICAgICAgIHR0bDogeyBtaW51dGVzOiAxMCB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgYXBpLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdjbGVhckNhY2hlJyk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IGEgZ2VuZXJpYyBjYWxlbmRhciBhcHBvaW50bWVudCBvYmplY3QsIG1hZGUgb2YgZXZlbnRzIGFuZC9vciBib29raW5ncyxcclxuICAgICAgICBkZXBlbmRpbmcgb24gdGhlIGdpdmVuIElEIGluIHRoZSBpZHMgb2JqZWN0LlxyXG4gICAgICAgIFxyXG4gICAgICAgIFRPRE86IGdldHMgc2luZ2xlIGFwdCBmcm9tIHRoZSBEYXRlQ2FjaGVcclxuICAgICoqL1xyXG4gICAgYXBpLmdldEFwcG9pbnRtZW50ID0gZnVuY3Rpb24gZ2V0QXBwb2ludG1lbnQoaWRzKSB7XHJcblxyXG4gICAgICAgIGlmIChpZHMuY2FsZW5kYXJFdmVudElEKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5jYWxlbmRhckV2ZW50cy5nZXRFdmVudChpZHMuY2FsZW5kYXJFdmVudElEKVxyXG4gICAgICAgICAgICAudGhlbihBcHBvaW50bWVudC5mcm9tQ2FsZW5kYXJFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlkcy5ib29raW5nSUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmJvb2tpbmdzLmdldEJvb2tpbmcoaWRzLmJvb2tpbmdJRClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYm9va2luZykge1xyXG4gICAgICAgICAgICAgICAgLy8gQW4gYXBwb2ludG1lbnQgZm9yIGJvb2tpbmcgbmVlZHMgdGhlIGNvbmZpcm1lZCBldmVudCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLmdldEV2ZW50KGJvb2tpbmcuY29uZmlybWVkRGF0ZUlEKCkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tQm9va2luZyhib29raW5nLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1VucmVjb2duaXplZCBJRCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5zZXRBcHBvaW50bWVudCA9IGZ1bmN0aW9uIHNldEFwcG9pbnRtZW50KGFwdCwgYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVE9ETzogU2F2aW5nIGFwdCBtdXN0IGludmFsaWRhdGUgdGhlIGNhY2hlIGFuZCBmb3JjZSBkYXRlXHJcbiAgICAgICAgLy8gYXZhaWxhYmlsaXR5IGNvbXB1dGF0aW9uIHdpdGggVUkgdXBkYXRlLCB3aGVuIHN0YXJ0IHRpbWUgb3Igc3RhcnQgZW5kIGNoYW5nZXMgXHJcbiAgICAgICAgLy8gKGV2ZXIgd2hlbiBpbnNlcnRpbmcgYXB0KSwgZm9yIHRoZSBwcmV2aW91cyBkYXRlIGFuZCB0aGUgbmV3IG9uZSAoaWYgZGF0ZSBjaGFuZ2VkKVxyXG4gICAgICAgIC8vIGFuZCBvbmx5IGRhdGUgYXZhaWxhYmlsaXR5IGNvbXB1dGF0aW9uIGlmIGRhdGUgaXMgdGhlIHNhbWUgYnV0IHRpbWUgY2hhbmdlZC5cclxuICAgICAgICAvLyBBbmQgdHJpZ2dlcnMgXCJ0aGlzLmVtaXQoJ2NsZWFyQ2FjaGUnKTtcIiBwYXNzaW5nIGFzIHBhcmFtZXRlciB0aGUgZGF0ZXMgYXJyYXkgdGhhdCBuZWVkcyByZWZyZXNoXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgaXMgYSBib29raW5nXHJcbiAgICAgICAgaWYgKGFwdC5zb3VyY2VCb29raW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmJvb2tpbmdzLnNldEJvb2tpbmcoYXB0LCBhbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGJvb2tpbmcpIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2xlYXJDYWNoZSwgZW5oYW5jZSBieSBkaXNjYXJkaW5nIG9ubHkgdGhlIGNhY2hlIGZvciB0aGUgcHJldmlvdXNcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBuZXcgZGF0ZVxyXG4gICAgICAgICAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0aGUgZXZlbnQgaW5mb3JtYXRpb24gdG9vXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuZ2V0RXZlbnQoYm9va2luZy5jb25maXJtZWREYXRlSUQoKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFwcG9pbnRtZW50LmZyb21Cb29raW5nKGJvb2tpbmcsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXB0LnNvdXJjZUV2ZW50KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLnNldEV2ZW50KGFwdClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tQ2FsZW5kYXJFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGFwcG9pbnRtZW50IG9iamVjdCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgYSBsaXN0IG9mIGdlbmVyaWMgY2FsZW5kYXIgYXBwb2ludG1lbnQgb2JqZWN0cywgbWFkZSBvZiBldmVudHMgYW5kL29yIGJvb2tpbmdzXHJcbiAgICAgICAgYnkgRGF0ZSwgZnJvbSB0aGUgcmVtb3RlIHNvdXJjZSBkaXJlY3RseS5cclxuICAgICAgICBVc2VkIGludGVybmFsbHkgb25seSwgdG8gZ2V0IGFwcG9pbnRtZW50cyB3aXRoIGFuZCB3aXRob3V0IGZyZWUvdW5hdmFpbGFibGVcclxuICAgICAgICBzbG90cyB1c2UgZ2V0RGF0ZUF2YWlsYWJpbGl0eVxyXG4gICAgKiovXHJcbiAgICB2YXIgZ2V0UmVtb3RlQXBwb2ludG1lbnRzQnlEYXRlID0gZnVuY3Rpb24gZ2V0UmVtb3RlQXBwb2ludG1lbnRzQnlEYXRlKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICBhcHBNb2RlbC5ib29raW5ncy5nZXRCb29raW5nc0J5RGF0ZXMoZGF0ZSksXHJcbiAgICAgICAgICAgIGFwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLmdldEV2ZW50c0J5RGF0ZXMoZGF0ZSlcclxuICAgICAgICBdKS50aGVuKGZ1bmN0aW9uKGdyb3VwKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gZ3JvdXBbMV0sXHJcbiAgICAgICAgICAgICAgICBib29raW5ncyA9IGdyb3VwWzBdLFxyXG4gICAgICAgICAgICAgICAgYXB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHMoKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGFwdHMgPSBBcHBvaW50bWVudC5saXN0RnJvbUNhbGVuZGFyRXZlbnRzQm9va2luZ3MoZXZlbnRzKCksIGJvb2tpbmdzKCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBhcHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgRmV0Y2ggYXBwb2ludG1lbnRzIGFuZCBzY2hlZHVsZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGRhdGUgZnJvbSByZW1vdGVcclxuICAgICAgICBpbiBhIGNvbnZlbmllbnQgb2JqZWN0IHRvIHVzZSB3aXRoIHRoZSBEYXRlQXZhaWxhYmlsaXR5IG1vZGVsLlxyXG4gICAgKiovXHJcbiAgICB2YXIgZ2V0UmVtb3RlRGF0ZUF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGdldFJlbW90ZURhdGVBdmFpbGFiaWxpdHkoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIGdldFJlbW90ZUFwcG9pbnRtZW50c0J5RGF0ZShkYXRlKSxcclxuICAgICAgICAgICAgYXBwTW9kZWwuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLmxvYWQoKSxcclxuICAgICAgICAgICAgYXBwTW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzLmxvYWQoKVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHZhciBhcHRzID0gcmVzdWx0WzBdLFxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSByZXN1bHRbMV0sXHJcbiAgICAgICAgICAgICAgICB3ZWVrRGF5U2NoZWR1bGUgPSBzZXR0aW5ncy53ZWVrRGF5c1tkYXRlLmdldERheSgpXSgpLFxyXG4gICAgICAgICAgICAgICAgcHJlZnMgPSByZXN1bHRbMl07XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0ZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxyXG4gICAgICAgICAgICAgICAgYXBwb2ludG1lbnRzTGlzdDogYXB0cyB8fCBbXSxcclxuICAgICAgICAgICAgICAgIHdlZWtEYXlTY2hlZHVsZTogd2Vla0RheVNjaGVkdWxlLFxyXG4gICAgICAgICAgICAgICAgc2NoZWR1bGluZ1ByZWZlcmVuY2VzOiBwcmVmc1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVJbmZvO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IHRoZSBhcHBvaW50bWVudHMgYW5kIGF2YWlsYWJpbGl0eSBmb3IgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAgICAgSXQgaGFzIGNhY2hlIGNvbnRyb2wsIGlmIHRoZXJlIGlzIGEgdmFsaWQgY29weSBpcyByZXR1cm5lZFxyXG4gICAgICAgIGF0IHRoZSBtb21lbnQsIGlmIGlzIHJlbG9hZGVkIGFuZCBleGlzdHMgb24gY2FjaGUsIHRoYXQgY29weSBpc1xyXG4gICAgICAgIHVwZGF0ZWQgc28gYWxsIHByZXZpb3VzIGluc3RhbmNlcyBnZXQgdGhlIHVwZGF0ZWQgZGF0YSB0b28uXHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXREYXRlQXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24gZ2V0RGF0ZUF2YWlsYWJpbGl0eShkYXRlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldFNpbmdsZShkYXRlKTtcclxuXHJcbiAgICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVtb3RlRGF0ZUF2YWlsYWJpbGl0eShkYXRlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRlSW5mbykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNhY2hlIGFuZCByZXR1biBkYXRhIGFzIGNsYXNzIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuc2V0KGRhdGUsIGRhdGVJbmZvKS5kYXRhO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBcclxuICAgIC8vLy8vL1xyXG4gICAgLy8gTkVXIE1VTFRJIERBVEVTIEFQSVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgYSBsaXN0IG9mIGdlbmVyaWMgY2FsZW5kYXIgYXBwb2ludG1lbnQgb2JqZWN0cywgbWFkZSBvZiBldmVudHMgYW5kL29yIGJvb2tpbmdzXHJcbiAgICAgICAgYnkgRGF0ZSwgZnJvbSB0aGUgcmVtb3RlIHNvdXJjZSBkaXJlY3RseS5cclxuICAgICAgICBVc2VkIGludGVybmFsbHkgb25seSwgdG8gZ2V0IGFwcG9pbnRtZW50cyB3aXRoIGFuZCB3aXRob3V0IGZyZWUvdW5hdmFpbGFibGVcclxuICAgICAgICBzbG90cyB1c2UgZ2V0RGF0ZUF2YWlsYWJpbGl0eVxyXG4gICAgKiovXHJcbiAgICB2YXIgZ2V0UmVtb3RlQXBwb2ludG1lbnRzQnlEYXRlcyA9IGZ1bmN0aW9uIGdldFJlbW90ZUFwcG9pbnRtZW50c0J5RGF0ZXMoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIGFwcE1vZGVsLmJvb2tpbmdzLmdldEJvb2tpbmdzQnlEYXRlcyhzdGFydCwgZW5kKSxcclxuICAgICAgICAgICAgYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuZ2V0RXZlbnRzQnlEYXRlcyhzdGFydCwgZW5kKVxyXG4gICAgICAgIF0pLnRoZW4oZnVuY3Rpb24oZ3JvdXApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBldmVudHMgPSBncm91cFsxXSxcclxuICAgICAgICAgICAgICAgIGJvb2tpbmdzID0gZ3JvdXBbMF0sXHJcbiAgICAgICAgICAgICAgICBhcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50cygpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYXB0cyA9IEFwcG9pbnRtZW50Lmxpc3RGcm9tQ2FsZW5kYXJFdmVudHNCb29raW5ncyhldmVudHMoKSwgYm9va2luZ3MoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEdyb3VwIGFwdHMgYnkgZGF0ZVxyXG4gICAgICAgICAgICB2YXIgZ3JvdXBlZCA9IF8uZ3JvdXBCeShhcHRzLCBmdW5jdGlvbihhcHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb21lbnQoYXB0LnN0YXJ0VGltZSgpKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIHRoZSBkYXRlcyBpbiB0aGUgcmFuZ2UgYXJlIGZpbGxlZCwgd2l0aCBlbXB0eSBhcnJheXMgaW4gdGhlIGhvbGVzLlxyXG4gICAgICAgICAgICAvLyBOT1RFOiB0aGlzIHdheSBvZiBmaXJzdCBncm91cCBhcHRzIGFuZCB0aGVuIGZpbGwgZ2FwcyBtYWtlcyB0aGUgcmVzdWx0aW5nIG9iamVjdFxyXG4gICAgICAgICAgICAvLyB0byBkaXNwbGF5IHByb3BlcnRpZXMgb3V0IG9mIG9yZGVyIChpZiBzb21lIGhvbGUgbmVlZGVkIGJlaW5nIGZpbGxlZCBvdXQpLlxyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0YXJ0KTtcclxuICAgICAgICAgICAgd2hpbGUgKGRhdGUgPD0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwZWQuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICAgICAgICAgICAgICBncm91cGVkW2tleV0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGRhdGU6XHJcbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBGZXRjaCBhcHBvaW50bWVudHMgYW5kIHNjaGVkdWxlIGluZm9ybWF0aW9uIGZvciB0aGUgZGF0ZXMgZnJvbSByZW1vdGVcclxuICAgICAgICBpbiBhIGNvbnZlbmllbnQgb2JqZWN0IHRvIHVzZSB3aXRoIHRoZSBEYXRlQXZhaWxhYmlsaXR5IG1vZGVsXHJcbiAgICAgICAgKHJldHVybnMgYW4gYXJyYXkgb2YgdGhlbSkuXHJcbiAgICAqKi9cclxuICAgIHZhciBnZXRSZW1vdGVEYXRlc0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGdldFJlbW90ZURhdGVzQXZhaWxhYmlsaXR5KHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICBnZXRSZW1vdGVBcHBvaW50bWVudHNCeURhdGVzKHN0YXJ0LCBlbmQpLFxyXG4gICAgICAgICAgICBhcHBNb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUubG9hZCgpLFxyXG4gICAgICAgICAgICBhcHBNb2RlbC5zY2hlZHVsaW5nUHJlZmVyZW5jZXMubG9hZCgpXHJcbiAgICAgICAgXSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgICAgdmFyIGFwdHNEYXRlcyA9IHJlc3VsdFswXSxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gcmVzdWx0WzFdLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9LFxyXG4gICAgICAgICAgICAgICAgcHJlZnMgPSByZXN1bHRbMl07XHJcblxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcHRzRGF0ZXMpLmZvckVhY2goZnVuY3Rpb24oZGF0ZUtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBtb21lbnQoZGF0ZUtleSwgJ1lZWVktTU0tREQnKS50b0RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciB3ZWVrRGF5U2NoZWR1bGUgPSBzZXR0aW5ncy53ZWVrRGF5c1tkYXRlLmdldERheSgpXSgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcG9pbnRtZW50c0xpc3Q6IGFwdHNEYXRlc1tkYXRlS2V5XSB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICB3ZWVrRGF5U2NoZWR1bGU6IHdlZWtEYXlTY2hlZHVsZSxcclxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsaW5nUHJlZmVyZW5jZXM6IHByZWZzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdHNbZGF0ZUtleV0gPSBkYXRlSW5mbztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5nZXREYXRlc0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGdldERhdGVzQXZhaWxhYmlsaXR5KHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIGNhY2hlUmVzdWx0cyA9IGNhY2hlLmdldChzdGFydCwgZW5kKTtcclxuICAgICAgICAvLyBXZSBrbm93IHdoYXQgZGF0ZXMgd2UgbmVlZCBhbmQgd2hhdCBkYXRhIGlzIGNhY2hlZCBhbHJlYWR5XHJcbiAgICAgICAgLy8gSWYgYWxsIGNhY2hlZCwganVzdCByZXNvbHZlIHRvIGNhY2hlXHJcbiAgICAgICAgaWYgKGNhY2hlUmVzdWx0cy5taW5Ib2xlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVSZXN1bHRzLmJ5RGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlcXVlc3QgYWxsIGRhdGVzIGluIHRoZSByYW5nZSAoZXZlbiBpZiBzb21lIGNhY2hlZCBpbiBiZXR3ZWVuKVxyXG4gICAgICAgIHJldHVybiBnZXRSZW1vdGVEYXRlc0F2YWlsYWJpbGl0eShjYWNoZVJlc3VsdHMubWluSG9sZSwgY2FjaGVSZXN1bHRzLm1heEhvbGUpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xyXG4gICAgICAgICAgICAvLyBBZGQgcmVzdWx0cyB0byBjYWNoZSwgY3JlYXRpbmcgRGF0ZUF2YWlsYWJpbGl0eSBvYmplY3RcclxuICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGF0IHRvIHRoZSByZXN1bHRzZXRcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0cykuZm9yRWFjaChmdW5jdGlvbihkYXRlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZVJlc3VsdHMuYnlEYXRlW2RhdGVLZXldID0gY2FjaGUuc2V0KGRhdGVLZXksIHJlc3VsdHNbZGF0ZUtleV0pLmRhdGE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVSZXN1bHRzLmJ5RGF0ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuXHJcbiIsIi8qKiBFdmVudHNcclxuXHJcbiAgICBJTVBPUlRBTlQhISEhIEFQSSBub3QgdG8gdXNlIGRpcmVjdGx5IGJ5IHRoZSBhcHAsIGJ1dCB0aHJvdWdoIGFwcE1vZGVsLmNhbGVuZGFyIChpdCBoYXMgY2FjaGUgYW5kIG1vcmUpXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ2FsZW5kYXJFdmVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9DYWxlbmRhckV2ZW50JyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcblxyXG4gICAgdmFyIGFwaSA9IHtcclxuICAgICAgICByZW1vdGU6IHtcclxuICAgICAgICAgICAgcmVzdDogYXBwTW9kZWwucmVzdCxcclxuICAgICAgICAgICAgZ2V0Q2FsZW5kYXJFdmVudHM6IGZ1bmN0aW9uKGZpbHRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnZXZlbnRzJywgZmlsdGVycylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJhd0l0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd0l0ZW1zICYmIHJhd0l0ZW1zLm1hcChmdW5jdGlvbihyYXdJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXJFdmVudChyYXdJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhcGkuZ2V0RXZlbnRzQnlEYXRlcyA9IGZ1bmN0aW9uIGdldEV2ZW50c0J5RGF0ZXMoZGF0ZSwgZW5kKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZW5kID0gZW5kIHx8IG1vbWVudChkYXRlKS5jbG9uZSgpLmFkZCgxLCAnZGF5cycpLnRvRGF0ZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlbW90ZSBsb2FkaW5nIGRhdGFcclxuICAgICAgICByZXR1cm4gYXBpLnJlbW90ZS5nZXRDYWxlbmRhckV2ZW50cyh7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlLFxyXG4gICAgICAgICAgICBlbmQ6IGVuZFxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZXZlbnRzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBQdXQgaW4gYXJyYXkgKHRoZXkgYXJlIGFscmVhZHkgbW9kZWwgaW5zdGFuY2VzKVxyXG4gICAgICAgICAgICB2YXIgYXJyID0ga28ub2JzZXJ2YWJsZUFycmF5KGV2ZW50cyk7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgb2JzZXJ2YWJsZSBhcnJheVxyXG4gICAgICAgICAgICAvLyBUT0RPIFJldmlldyByZWFsbHkgaWYgaGFzIHNlbnNlIHRvIGhhdmUgYW4gb2JzZXJ2YWJsZSBhcnJheSwgdGFrZSBjYXJlIG9mIGl0cyB1c2UgKG9uIGFwcG9pbnRtZW50cyBtYWlubHkpXHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgYSBzcGVjaWZpYyBldmVudCBieSBJRFxyXG4gICAgKiovXHJcbiAgICBhcGkuZ2V0RXZlbnQgPSBmdW5jdGlvbiBnZXRFdmVudChpZCkge1xyXG4gICAgICAgIGlmICghaWQpIHJldHVybiBQcm9taXNlLnJlamVjdCgnVGhlIGNhbGVuZGFyRXZlbnRJRCBpcyByZXF1aXJlZCB0byBnZXQgYW4gZXZlbnQnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdldmVudHMvJyArIGlkKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXJFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcGkuYXBwb2ludG1lbnRUb1NpbXBsaWZpZWRFdmVudCA9IGZ1bmN0aW9uKGFwdCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBycnVsZSA9IGFwdC5zb3VyY2VFdmVudCgpLnJlY3VycmVuY2VSdWxlKCk7XHJcbiAgICAgICAgaWYgKHJydWxlKVxyXG4gICAgICAgICAgICBycnVsZSA9IGFwdC5zb3VyY2VFdmVudCgpLnJlY3VycmVuY2VSdWxlKCkubW9kZWwudG9QbGFpbk9iamVjdCgpO1xyXG5cclxuICAgICAgICB2YXIgb2NjcyA9IGFwdC5zb3VyY2VFdmVudCgpLnJlY3VycmVuY2VPY2N1cnJlbmNlcygpO1xyXG4gICAgICAgIGlmIChvY2NzKVxyXG4gICAgICAgICAgICBvY2NzID0gb2Njcy5tYXAoZnVuY3Rpb24ob2NjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2NjICYmIG9jYy5tb2RlbC50b1BsYWluT2JqZWN0KCkgfHwgbnVsbDtcclxuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKG9jYykgeyByZXR1cm4gb2NjICE9PSBudWxsOyB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBUaGUgc2FtZSBhcyBhcHQuc291cmNlRXZlbnQoKS5jYWxlbmRhckV2ZW50SUQoKVxyXG4gICAgICAgICAgICBjYWxlbmRhckV2ZW50SUQ6IGFwdC5pZCgpIDwgMCA/IDAgOiBhcHQuaWQoKSxcclxuICAgICAgICAgICAgZXZlbnRUeXBlSUQ6IGFwdC5zb3VyY2VFdmVudCgpLmV2ZW50VHlwZUlEKCksXHJcbiAgICAgICAgICAgIHN1bW1hcnk6IGFwdC5zdW1tYXJ5KCksXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBhcHQuZGVzY3JpcHRpb24oKSxcclxuICAgICAgICAgICAgYXZhaWxhYmlsaXR5VHlwZUlEOiBhcHQuc291cmNlRXZlbnQoKS5hdmFpbGFiaWxpdHlUeXBlSUQoKSxcclxuICAgICAgICAgICAgbG9jYXRpb246IGFwdC5hZGRyZXNzU3VtbWFyeSgpLFxyXG4gICAgICAgICAgICBzdGFydFRpbWU6IGFwdC5zdGFydFRpbWUoKSxcclxuICAgICAgICAgICAgZW5kVGltZTogYXB0LmVuZFRpbWUoKSxcclxuICAgICAgICAgICAgaXNBbGxEYXk6IGFwdC5zb3VyY2VFdmVudCgpLmlzQWxsRGF5KCksXHJcbiAgICAgICAgICAgIHJlY3VycmVuY2VSdWxlOiBycnVsZSxcclxuICAgICAgICAgICAgcmVjdXJyZW5jZU9jY3VycmVuY2VzOiBvY2NzXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgQ3JlYXRlcy91cGRhdGVzIGEgYm9va2luZywgZ2l2ZW4gYSBzaW1wbGlmaWVkIGJvb2tpbmdcclxuICAgICAgICBvYmplY3Qgb3IgYW4gQXBwb2ludG1lbnQgbW9kZWwgb3IgYSBCb29raW5nIG1vZGVsXHJcbiAgICAqKi9cclxuICAgIGFwaS5zZXRFdmVudCA9IGZ1bmN0aW9uIHNldEV2ZW50KGV2ZW50KSB7XHJcblxyXG4gICAgICAgIGV2ZW50ID0gZXZlbnQuY2FsZW5kYXJFdmVudElEID9cclxuICAgICAgICAgICAgZXZlbnQubW9kZWwudG9QbGFpbk9iamVjdCgpIDpcclxuICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQgP1xyXG4gICAgICAgICAgICAgICAgYXBpLmFwcG9pbnRtZW50VG9TaW1wbGlmaWVkRXZlbnQoZXZlbnQpIDpcclxuICAgICAgICAgICAgICAgIGV2ZW50XHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICB2YXIgaWQgPSBldmVudC5jYWxlbmRhckV2ZW50SUQgfHwgJycsXHJcbiAgICAgICAgICAgIG1ldGhvZCA9IGlkID8gJ3B1dCcgOiAncG9zdCc7XHJcblxyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0W21ldGhvZF0oJ2V2ZW50cycgKyAoaWQgPyAnLycgOiAnJykgKyBpZCwgZXZlbnQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhckV2ZW50KHNlcnZlckV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIENhbGVuZGFyIFN5bmNpbmcgYXBwIG1vZGVsXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgQ2FsZW5kYXJTeW5jaW5nID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NhbGVuZGFyU3luY2luZycpLFxyXG4gICAgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IG5ldyBDYWxlbmRhclN5bmNpbmcoKSxcclxuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGxvY2FsU3RvcmFnZU5hbWU6ICdjYWxlbmRhclN5bmNpbmcnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdjYWxlbmRhci1zeW5jaW5nJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ2NhbGVuZGFyLXN5bmNpbmcnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gRXh0ZW5kaW5nIHdpdGggdGhlIHNwZWNpYWwgQVBJIG1ldGhvZCAncmVzZXRFeHBvcnRVcmwnXHJcbiAgICByZW0uaXNSZXNldGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgcmVtLnJlc2V0RXhwb3J0VXJsID0gZnVuY3Rpb24gcmVzZXRFeHBvcnRVcmwoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmVtLmlzUmVzZXRpbmcodHJ1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ2NhbGVuZGFyLXN5bmNpbmcvcmVzZXQtZXhwb3J0LXVybCcpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odXBkYXRlZFN5bmNTZXR0aW5ncykge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGluZyB0aGUgY2FjaGVkIGRhdGFcclxuICAgICAgICAgICAgcmVtLmRhdGEubW9kZWwudXBkYXRlV2l0aCh1cGRhdGVkU3luY1NldHRpbmdzKTtcclxuICAgICAgICAgICAgcmVtLmlzUmVzZXRpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRTeW5jU2V0dGluZ3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlbTtcclxufTtcclxuIiwiLyoqIEN1c3RvbWVyc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEN1c3RvbWVyID0gcmVxdWlyZSgnLi4vbW9kZWxzL0N1c3RvbWVyJyk7XHJcblxyXG52YXIgTGlzdFJlbW90ZU1vZGVsID0gcmVxdWlyZSgnLi4vdXRpbHMvTGlzdFJlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgXHJcbiAgICB2YXIgYXBpID0gbmV3IExpc3RSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgbGlzdFR0bDogeyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgaXRlbUlkRmllbGQ6ICdjdXN0b21lclVzZXJJRCcsXHJcbiAgICAgICAgTW9kZWw6IEN1c3RvbWVyXHJcbiAgICB9KTtcclxuXHJcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdjdXN0b21lcnMnKTtcclxuICAgIGFwaS5hZGRSZXN0U3VwcG9ydChhcHBNb2RlbC5yZXN0LCAnY3VzdG9tZXJzJyk7XHJcbiAgICBcclxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUHVibGljIHNlYXJjaCBvZiB1c2VycywgcG9zc2libGUgY3VzdG9tZXJzIGJ5IHdlbGxcclxuICAgICAgICBrbm93IGZpZWxkcywgd2l0aCBmdWxsIHZhbHVlIG1hdGNoLlxyXG4gICAgKiovXHJcbiAgICB2YXIgcHVibGljU2VhcmNoUmVxdWVzdCA9IG51bGw7XHJcbiAgICBhcGkucHVibGljU2VhcmNoID0gZnVuY3Rpb24gcHVibGljU2VhcmNoKHNlYXJjaCkge1xyXG5cclxuICAgICAgICAvLyBPbmx5IG9uZSByZXF1ZXN0IGF0IGEgdGltZVxyXG4gICAgICAgIGlmIChwdWJsaWNTZWFyY2hSZXF1ZXN0ICYmXHJcbiAgICAgICAgICAgIHB1YmxpY1NlYXJjaFJlcXVlc3QuYWJvcnQpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHB1YmxpY1NlYXJjaFJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoYWJvcnRFcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFib3J0aW5nIHJlcXVlc3QnLCBhYm9ydEVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBhcHBNb2RlbC5yZXN0LmdldCgnY3VzdG9tZXJzL3B1YmxpYy1zZWFyY2gnLCBzZWFyY2gpO1xyXG4gICAgICAgIHB1YmxpY1NlYXJjaFJlcXVlc3QgPSByZXF1ZXN0LnhocjtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDYXRjaCAnYWJvcnQnIHRvIGF2b2lkIGNvbW11bmljYXRlIGEgZmFrZSBlcnJvciBpbiB0aGUgcHJvbWlzZTsgdGhlXHJcbiAgICAgICAgLy8gcHJvbWlzZSB3aWxsIGp1c3Qgc29sdmUgYXMgc3VjY2VzcyB3aXRoIGVtcHR5IGFycmF5LlxyXG4gICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5zdGF0dXNUZXh0ID09PSAnYWJvcnQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAvLyBSZXRocm93IG9ubHkgaWYgaXMgbm90IGFuICdhYm9ydCdcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gU2V0IGFnYWluLCByZW1vdmVkIGJ5IHRoZSBjYXRjaCByZXR1cm5lZCBwcm9taXNlXHJcbiAgICAgICAgcmVxdWVzdC54aHIgPSBwdWJsaWNTZWFyY2hSZXF1ZXN0O1xyXG5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIEZlZWRiYWNrXHJcbioqL1xyXG4vL2dsb2JhbCBuYXZpZ2F0b3Isd2luZG93XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcbiAgICBcclxuICAgIHZhciBnZXRVc2VyRGV2aWNlSW5mbyA9IGZ1bmN0aW9uIGdldFVzZXJEZXZpY2VJbmZvKCkge1xyXG4gICAgICAgIHZhciBkZXYgPSB3aW5kb3cuZGV2aWNlIHx8IHtcclxuICAgICAgICAgICAgcGxhdGZvcm06ICd3ZWInLFxyXG4gICAgICAgICAgICBtb2RlbDogJ3Vua25vdycsXHJcbiAgICAgICAgICAgIGNvcmRvdmE6ICcnLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiAnJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LFxyXG4gICAgICAgICAgICBwbGF0Zm9ybTogZGV2LnBsYXRmb3JtLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiBkZXYudmVyc2lvbixcclxuICAgICAgICAgICAgbW9kZWw6IGRldi5tb2RlbCxcclxuICAgICAgICAgICAgY29yZG92YTogZGV2LmNvcmRvdmFcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgICAgQHBhcmFtIHZhbHVlczpPYmplY3Qge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTpzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICB2b2NFbGVtZW50SUQ6aW50LFxyXG4gICAgICAgICAgICAgICAgYmVjb21lQ29sbGFib3JhdG9yOmJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICB1c2VyRGV2aWNlOnN0cmluZyAoYXV0b21hdGljKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKiovXHJcbiAgICAgICAgcG9zdElkZWE6IGZ1bmN0aW9uIHBvc3RJZGVhKHZhbHVlcykge1xyXG4gICAgICAgICAgICB2YWx1ZXMudXNlckRldmljZSA9IEpTT04uc3RyaW5naWZ5KGdldFVzZXJEZXZpY2VJbmZvKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wb3N0KCdmZWVkYmFjay9pZGVhcycsIHZhbHVlcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgICAgQHBhcmFtIHZhbHVlczpPYmplY3Qge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTpzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICB2b2NFbGVtZW50SUQ6aW50LFxyXG4gICAgICAgICAgICAgICAgdXNlckRldmljZTpzdHJpbmcgKGF1dG9tYXRpYylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIHBvc3RTdXBwb3J0OiBmdW5jdGlvbiBwb3N0U3VwcG9ydCh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnVzZXJEZXZpY2UgPSBKU09OLnN0cmluZ2lmeShnZXRVc2VyRGV2aWNlSW5mbygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucG9zdCgnZmVlZGJhY2svc3VwcG9ydCcsIHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuIiwiLyoqIEZyZWVsYW5jZXIgUHJpY2luZ1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEZyZWVsYW5jZXJQcmljaW5nID0gcmVxdWlyZSgnLi4vbW9kZWxzL0ZyZWVsYW5jZXJQcmljaW5nJyksXHJcbiAgICBHcm91cExpc3RSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0dyb3VwTGlzdFJlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG5cclxuICAgIHZhciBhcGkgPSBuZXcgR3JvdXBMaXN0UmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIC8vIENvbnNlcnZhdGl2ZSBjYWNoZSwganVzdCAxIG1pbnV0ZVxyXG4gICAgICAgIGxpc3RUdGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGdyb3VwSWRGaWVsZDogJ2pvYlRpdGxlSUQnLFxyXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAnZnJlZWxhbmNlclByaWNpbmdJRCcsXHJcbiAgICAgICAgTW9kZWw6IEZyZWVsYW5jZXJQcmljaW5nXHJcbiAgICB9KTtcclxuXHJcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdmcmVlbGFuY2VyLXByaWNpbmcvJyk7XHJcbiAgICBhcGkuYWRkUmVzdFN1cHBvcnQoYXBwTW9kZWwucmVzdCwgJ2ZyZWVsYW5jZXItcHJpY2luZy8nKTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKiogSG9tZSBBZGRyZXNzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4uL21vZGVscy9BZGRyZXNzJyk7XHJcblxyXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IG5ldyBBZGRyZXNzKCksXHJcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcclxuICAgICAgICBsb2NhbFN0b3JhZ2VOYW1lOiAnaG9tZUFkZHJlc3MnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdhZGRyZXNzZXMvaG9tZScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucHV0KCdhZGRyZXNzZXMvaG9tZScsIHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiByZW07XHJcbn07XHJcbiIsIi8qKiBGZXRjaCBKb2IgVGl0bGVzIGFuZCBQcmljaW5nIFR5cGVzIGluZm9ybWF0aW9uXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgbG9jYWxmb3JhZ2UgPSByZXF1aXJlKCdsb2NhbGZvcmFnZScpLFxyXG4gICAgSm9iVGl0bGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvSm9iVGl0bGUnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcblxyXG4gICAgdmFyIGFwaSA9IHtcclxuICAgICAgICAgICAgc3RhdGU6ICB7XHJcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhY2hlID0ge1xyXG4gICAgICAgICAgICBqb2JUaXRsZXM6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIGNhY2hlLmpvYlRpdGxlcyA9IHt9O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIFB1YmxpYyBBUElcclxuICAgICAgICBHZXQgYSBKb2IgVGl0bGUgaW5mb3JtYXRpb24gYnkgSURcclxuICAgICoqL1xyXG4gICAgYXBpLmdldEpvYlRpdGxlID0gZnVuY3Rpb24gZ2V0Sm9iVGl0bGUoaWQpIHtcclxuICAgICAgICBpZiAoIWlkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05lZWRzIGFuIElEIHRvIGdldCBhIEpvYiBUaXRsZScpO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCwgaW4tbWVtb3J5IGNhY2hlXHJcbiAgICAgICAgaWYgKGNhY2hlLmpvYlRpdGxlc1tpZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZS5qb2JUaXRsZXNbaWRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIFNlY29uZCwgbG9jYWwgc3RvcmFnZVxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnam9iVGl0bGVzLycgKyBpZClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oam9iVGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChqb2JUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIGluIG1lbW9yeSBhcyBNb2RlbCBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmpvYlRpdGxlc1tpZF0gPSBuZXcgSm9iVGl0bGUoam9iVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5qb2JUaXRsZXNbaWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcmQgYW5kIGxhc3QsIHJlbW90ZSBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdqb2ItdGl0bGVzLycgKyBpZClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmF3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGluIGxvY2FsIHN0b3JhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgnam9iVGl0bGVzLycgKyBpZCwgcmF3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgaW4gbWVtb3J5IGFzIE1vZGVsIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmpvYlRpdGxlc1tpZF0gPSBuZXcgSm9iVGl0bGUocmF3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuam9iVGl0bGVzW2lkXTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbn07XHJcbiIsIi8qKiBBcHBNb2RlbCwgY2VudHJhbGl6ZXMgYWxsIHRoZSBkYXRhIGZvciB0aGUgYXBwLFxyXG4gICAgY2FjaGluZyBhbmQgc2hhcmluZyBkYXRhIGFjcm9zcyBhY3Rpdml0aWVzIGFuZCBwZXJmb3JtaW5nXHJcbiAgICByZXF1ZXN0c1xyXG4qKi9cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIFJlc3QgPSByZXF1aXJlKCcuLi91dGlscy9SZXN0JyksXHJcbiAgICBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyksXHJcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcblxyXG5mdW5jdGlvbiBBcHBNb2RlbCgpIHtcclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMzApO1xyXG59XHJcblxyXG5BcHBNb2RlbC5faW5oZXJpdHMoRXZlbnRFbWl0dGVyKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXBwTW9kZWw7XHJcblxyXG5yZXF1aXJlKCcuL0FwcE1vZGVsLWFjY291bnQnKS5wbHVnSW4oQXBwTW9kZWwpO1xyXG5cclxuLyoqXHJcbiAgICBMb2FkIGNyZWRlbnRpYWxzIGZyb20gdGhlIGxvY2FsIHN0b3JhZ2UsIHdpdGhvdXQgZXJyb3IgaWYgdGhlcmUgaXMgbm90aGluZ1xyXG4gICAgc2F2ZWQuIElmIGxvYWQgcHJvZmlsZSBkYXRhIHRvbywgcGVyZm9ybWluZyBhbiB0cnlMb2dpbiBpZiBubyBsb2NhbCBkYXRhLlxyXG4qKi9cclxuQXBwTW9kZWwucHJvdG90eXBlLmxvYWRMb2NhbENyZWRlbnRpYWxzID0gZnVuY3Rpb24gbG9hZExvY2FsQ3JlZGVudGlhbHMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkgeyAvLyBOZXZlciByZWplY3RzOiAsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAvLyBDYWxsYmFjayB0byBqdXN0IHJlc29sdmUgd2l0aG91dCBlcnJvciAocGFzc2luZyBpbiB0aGUgZXJyb3JcclxuICAgICAgICAvLyB0byB0aGUgJ3Jlc29sdmUnIHdpbGwgbWFrZSB0aGUgcHJvY2VzcyB0byBmYWlsKSxcclxuICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhbiBlcnJvciBmb3IgdGhlXHJcbiAgICAgICAgLy8gYXBwIGluaXQsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc2F2ZWQgaW5mb3JtYXRpb25cclxuICAgICAgICAvLyB0aGUgYXBwIGhhcyBjb2RlIHRvIHJlcXVlc3QgYSBsb2dpbi5cclxuICAgICAgICB2YXIgcmVzb2x2ZUFueXdheSA9IGZ1bmN0aW9uKGRvZXNuTWF0dGVyKXsgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm5pbmcoJ0FwcCBNb2RlbCBJbml0IGVycicsIGRvZXNuTWF0dGVyKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNyZWRlbnRpYWxzIHNhdmVkXHJcbiAgICAgICAgbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnY3JlZGVudGlhbHMnKS50aGVuKGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbHMgJiZcclxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLnVzZXJJRCAmJlxyXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHMudXNlcm5hbWUgJiZcclxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLmF1dGhLZXkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgYXV0aG9yaXphdGlvbiBrZXkgZm9yIGVhY2hcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBSZXN0IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdC5leHRyYUhlYWRlcnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWx1OiBjcmVkZW50aWFscy51c2VySUQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxrOiBjcmVkZW50aWFscy5hdXRoS2V5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgY3JlZGVudGlhbHMhIEhhcyBiYXNpYyBwcm9maWxlIGRhdGE/XHJcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgdXNlclByb2ZpbGUgd2lsbCBsb2FkIGZyb20gbG9jYWwgc3RvcmFnZSBvbiB0aGlzIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0LCBhbmQgbGF6aWx5IHJlcXVlc3QgdXBkYXRlZCBkYXRhIGZyb20gcmVtb3RlIHNvIHdlIG5lZWRcclxuICAgICAgICAgICAgICAgIC8vIHRvIGNhdGNoIHJlbW90ZSBlcnJvcnMgd2l0aCBldmVudHNcclxuICAgICAgICAgICAgICAgIHRoaXMudXNlclByb2ZpbGUub25jZSgnZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW1wb3NzaWJsZSB0byBsb2FkIHlvdXIgZGF0YS4gUGxlYXNlIGNoZWNrIHlvdXIgSW50ZXJuZXQgY29ubmVjdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMudXNlclByb2ZpbGUubG9hZCgpLnRoZW4oZnVuY3Rpb24ocHJvZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgcHJvZmlsZSBjYWNoZWQgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgc3VjY2VzZnVsbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcHJvZmlsZSwgd2UgbmVlZCB0byByZXF1ZXN0IGl0IHRvIGJlIGFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gd29yayBjb3JyZWN0bHksIHNvIHdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgYSBsb2dpbiAodGhlIHRyeUxvZ2luIHByb2Nlc3MgcGVyZm9ybXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBsb2dpbiB3aXRoIHRoZSBzYXZlZCBjcmVkZW50aWFscyBhbmQgZmV0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb2ZpbGUgdG8gc2F2ZSBpdCBpbiB0aGUgbG9jYWwgY29weSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlMb2dpbigpLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZUFueXdheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCByZXNvbHZlQW55d2F5KVxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGV2ZW50IGNhdGNoIGFueSBlcnJvciBpZiBoYXBwZW5zLCBzbyBhdm9pZCB1bmNhdWdodCBleGNlcHRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgY29uc29sZSBieSBjYXRjaGluZyB0aGUgcHJvbWlzZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkgeyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEVuZCBzdWNjZXNzZnVsbHkuIE5vdCBsb2dnaW4gaXMgbm90IGFuIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgLy8gaXMganVzdCB0aGUgZmlyc3QgYXBwIHN0YXJ0LXVwXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyksIHJlc29sdmVBbnl3YXkpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbi8qKiBJbml0aWFsaXplIGFuZCB3YWl0IGZvciBhbnl0aGluZyB1cCAqKi9cclxuQXBwTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgXHJcbiAgICAvLyBMb2NhbCBkYXRhXHJcbiAgICAvLyBUT0RPIEludmVzdGlnYXRlIHdoeSBhdXRvbWF0aWMgc2VsZWN0aW9uIGFuIEluZGV4ZWREQiBhcmVcclxuICAgIC8vIGZhaWxpbmcgYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSB3b3JzZS1wZXJmb3JtYW5jZSBsb2NhbHN0b3JhZ2UgYmFjay1lbmRcclxuICAgIGxvY2FsZm9yYWdlLmNvbmZpZyh7XHJcbiAgICAgICAgbmFtZTogJ0xvY29ub21pY3NBcHAnLFxyXG4gICAgICAgIHZlcnNpb246IDAuMSxcclxuICAgICAgICBzaXplIDogNDk4MDczNiwgLy8gU2l6ZSBvZiBkYXRhYmFzZSwgaW4gYnl0ZXMuIFdlYlNRTC1vbmx5IGZvciBub3cuXHJcbiAgICAgICAgc3RvcmVOYW1lIDogJ2tleXZhbHVlcGFpcnMnLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uIDogJ0xvY29ub21pY3MgQXBwJyxcclxuICAgICAgICBkcml2ZXI6IGxvY2FsZm9yYWdlLkxPQ0FMU1RPUkFHRVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEZpcnN0LCBnZXQgYW55IHNhdmVkIGxvY2FsIGNvbmZpZ1xyXG4gICAgLy8gTk9URTogZm9yIG5vdywgdGhpcyBpcyBvcHRpb25hbCwgdG8gZ2V0IGEgc2F2ZWQgc2l0ZVVybCByYXRoZXIgdGhhbiB0aGVcclxuICAgIC8vIGRlZmF1bHQgb25lLCBpZiBhbnkuXHJcbiAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnY29uZmlnJylcclxuICAgIC50aGVuKGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIC8vIE9wdGlvbmFsIGNvbmZpZ1xyXG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29uZmlnLnNpdGVVcmwpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBodG1sIFVSTFxyXG4gICAgICAgICAgICAkKCdodG1sJykuYXR0cignZGF0YS1zaXRlLXVybCcsIGNvbmZpZy5zaXRlVXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5zaXRlVXJsID0gJCgnaHRtbCcpLmF0dHIoJ2RhdGEtc2l0ZS11cmwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5yZXN0ID0gbmV3IFJlc3QoY29uZmlnLnNpdGVVcmwgKyAnL2FwaS92MS9lbi1VUy8nKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZXR1cCBSZXN0IGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgICAgdGhpcy5yZXN0Lm9uQXV0aG9yaXphdGlvblJlcXVpcmVkID0gZnVuY3Rpb24ocmV0cnkpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudHJ5TG9naW4oKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIExvZ2dlZCEgSnVzdCByZXRyeVxyXG4gICAgICAgICAgICAgICAgcmV0cnkoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFdpdGggY29uZmlnIGxvYWRlZCBhbmQgUkVTVCByZWFkeSwgbG9hZCBhbGwgbW9kdWxlc1xyXG4gICAgICAgIHRoaXMubG9hZE1vZHVsZXMoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJbml0aWFsaXplOiBjaGVjayB0aGUgdXNlciBoYXMgbG9naW4gZGF0YSBhbmQgbmVlZGVkXHJcbiAgICAgICAgLy8gY2FjaGVkIGRhdGEsIHJldHVybiBpdHMgcHJvbWlzZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRMb2NhbENyZWRlbnRpYWxzKCk7XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuQXBwTW9kZWwucHJvdG90eXBlLmxvYWRNb2R1bGVzID0gZnVuY3Rpb24gbG9hZE1vZHVsZXMoKSB7XHJcblxyXG4gICAgdGhpcy51c2VyUHJvZmlsZSA9IHJlcXVpcmUoJy4vQXBwTW9kZWwudXNlclByb2ZpbGUnKS5jcmVhdGUodGhpcyk7XHJcbiAgICAvLyBOT1RFOiBBbGlhcyBmb3IgdGhlIHVzZXIgZGF0YVxyXG4gICAgLy8gVE9ETzpUT1JFVklFVyBpZiBjb250aW51ZSB0byBtYWtlcyBzZW5zZSB0byBrZWVwIHRoaXMgJ3VzZXIoKScgYWxpYXMsIGRvY3VtZW50XHJcbiAgICAvLyB3aGVyZSBpcyB1c2VkIGFuZCB3aHkgaXMgcHJlZmVycmVkIHRvIHRoZSBjYW5vbmljYWwgd2F5LlxyXG4gICAgdGhpcy51c2VyID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlclByb2ZpbGUuZGF0YTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMub25ib2FyZGluZyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwub25ib2FyZGluZycpLmNyZWF0ZSh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNjaGVkdWxpbmdQcmVmZXJlbmNlcyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5jYWxlbmRhclN5bmNpbmcgPSByZXF1aXJlKCcuL0FwcE1vZGVsLmNhbGVuZGFyU3luY2luZycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLm1hcmtldHBsYWNlUHJvZmlsZSA9IHJlcXVpcmUoJy4vQXBwTW9kZWwubWFya2V0cGxhY2VQcm9maWxlJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5ob21lQWRkcmVzcyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuaG9tZUFkZHJlc3MnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLnByaXZhY3lTZXR0aW5ncyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwucHJpdmFjeVNldHRpbmdzJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5ib29raW5ncyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuYm9va2luZ3MnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLmNhbGVuZGFyRXZlbnRzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5jYWxlbmRhckV2ZW50cycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuam9iVGl0bGVzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5qb2JUaXRsZXMnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLnVzZXJKb2JQcm9maWxlID0gcmVxdWlyZSgnLi9BcHBNb2RlbC51c2VySm9iUHJvZmlsZScpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuY2FsZW5kYXIgPSByZXF1aXJlKCcuL0FwcE1vZGVsLmNhbGVuZGFyJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5zZXJ2aWNlQWRkcmVzc2VzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5zZXJ2aWNlQWRkcmVzc2VzJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5mcmVlbGFuY2VyUHJpY2luZyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuZnJlZWxhbmNlclByaWNpbmcnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLnByaWNpbmdUeXBlcyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwucHJpY2luZ1R5cGVzJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgdGhpcy5tZXNzYWdpbmcgPSByZXF1aXJlKCcuL0FwcE1vZGVsLm1lc3NhZ2luZycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuY3VzdG9tZXJzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5jdXN0b21lcnMnKS5jcmVhdGUodGhpcyk7XHJcbiAgICB0aGlzLnBvc3RhbENvZGVzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5wb3N0YWxDb2RlcycpLmNyZWF0ZSh0aGlzKTtcclxuICAgIHRoaXMuZmVlZGJhY2sgPSByZXF1aXJlKCcuL0FwcE1vZGVsLmZlZWRiYWNrJykuY3JlYXRlKHRoaXMpO1xyXG4gICAgLy9VTlNUQUJMRTp0aGlzLmF2YWlsYWJpbGl0eSA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuYXZhaWxhYmlsaXR5JykuY3JlYXRlKHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBDbGVhciB0aGUgbG9jYWwgc3RvcmVkIGRhdGEsIGJ1dCB3aXRoIGNhcmVmdWwgZm9yIHRoZSBzcGVjaWFsXHJcbiAgICBjb25maWcgZGF0YSB0aGF0IGlzIGtlcHQuXHJcbioqL1xyXG5BcHBNb2RlbC5wcm90b3R5cGUuY2xlYXJMb2NhbERhdGEgPSBmdW5jdGlvbiBjbGVhckxvY2FsRGF0YSgpIHtcclxuICAgIC8vIEdldCBjb25maWdcclxuICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCdjb25maWcnKVxyXG4gICAgLnRoZW4oZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgLy8gQ2xlYXIgYWxsXHJcbiAgICAgICAgbG9jYWxmb3JhZ2UuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyBTZXQgY29uZmlnIGFnYWluXHJcbiAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0oJ2NvbmZpZycsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyaWdnZXIgbm90aWZpY2F0aW9uLCBzbyBvdGhlciBjb21wb25lbnRzXHJcbiAgICAgICAgLy8gY2FuIG1ha2UgZnVydGhlciBjbGVhbi11cCBvciB0cnkgc3luY2hyb25pemF0aW9ucyxcclxuICAgICAgICAvLyBmb3IgZXhhbXBsZSB0byBjbGVhbi11cCBpbi1tZW1vcnkgY2FjaGUuXHJcbiAgICAgICAgdGhpcy5lbWl0KCdjbGVhckxvY2FsRGF0YScpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufTtcclxuIiwiLyoqIE1hcmtldHBsYWNlUHJvZmlsZVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1hcmtldHBsYWNlUHJvZmlsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9NYXJrZXRwbGFjZVByb2ZpbGUnKTtcclxuXHJcbnZhciBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgdmFyIHJlbSA9IG5ldyBSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgZGF0YTogbmV3IE1hcmtldHBsYWNlUHJvZmlsZSgpLFxyXG4gICAgICAgIHR0bDogeyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ21hcmtldHBsYWNlUHJvZmlsZScsXHJcbiAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ21hcmtldHBsYWNlLXByb2ZpbGUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnB1dCgnbWFya2V0cGxhY2UtcHJvZmlsZScsIHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiByZW07XHJcbn07XHJcbiIsIi8qKiBBcHBNb2RlbCBmb3IgbWVzc2FnaW5nOiB0aHJlYWRzIGFuZCBtZXNzYWdlc1xyXG5cclxuICAgIE5PVEU6IEluaXRpYWwgYmFzaWMgaW1wbGVtZW50YXRpb25cclxuICAgIFRPRE86IFJlcXVpcmUgYWR2YW5jZWQgaW1wbGVtZW50YXRpb24sIGxvYWRpbmcgYSBsaW1pdGVkXHJcbiAgICAgICAgYW1vdW50IG9mIHJlY29yZHMgZm9yIHRocmVhZHMgYW5kIG1lc3NhZ2VzIHBlciB0aHJlYWRcclxuICAgICAgICB1c2luZyB0aGUgY3Vyc29yIHBhcmFtZXRlcnMgb2YgdGhlIFJFU1QgQVBJIHRvIG1hbmFnZVxyXG4gICAgICAgIHBhZ2luZyBsb2FkLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFRocmVhZCA9IHJlcXVpcmUoJy4uL21vZGVscy9UaHJlYWQnKSxcclxuICAgIENhY2hlQ29udHJvbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0NhY2hlQ29udHJvbCcpLFxyXG4gICAgTGlzdFJlbW90ZU1vZGVsID0gcmVxdWlyZSgnLi4vdXRpbHMvTGlzdFJlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgXHJcbiAgICB2YXIgYXBpID0gbmV3IExpc3RSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgbGlzdFR0bDogeyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgaXRlbUlkRmllbGQ6ICd0aHJlYWRJRCcsXHJcbiAgICAgICAgTW9kZWw6IFRocmVhZFxyXG4gICAgfSk7XHJcblxyXG4gICAgYXBpLmFkZExvY2FsZm9yYWdlU3VwcG9ydCgnbWVzc2FnaW5nJyk7XHJcbiAgICBhcGkuYWRkUmVzdFN1cHBvcnQoYXBwTW9kZWwucmVzdCwgJ21lc3NhZ2luZycpO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEJhc2ljIHN1cHBvcnQgaXMgZmV0Y2hpbmcgYWxsIHRocmVhZHMgd2l0aCB0aGUgbGF0ZXN0IG1lc3NhZ2Ugb2YgZWFjaCBvbmUuXHJcbiAgICAvLyBSZXBsYWNlIGdldEl0ZW0gYnVpbHQtaW4gdG8gZG8gbm9uIGxvY2FsbHkgc2F2ZWQsIGZldGNoIGZvciBhbGwgbWVzc2FnZXMgaW5cclxuICAgIC8vIGEgdGhyZWFkICh0aGUgdGhyZWFkIGlzIHRoZSBpdGVtKVxyXG4gICAgdmFyIGZ1bGxUaHJlYWRzQ2FjaGUgPSB7LypcclxuICAgICAgICB0aHJlYWRJRDogeyBjb250cm9sOiBDYWNoZUNvbnRyb2wsIHRocmVhZDogVGhyZWFkIH1cclxuICAgICovfTtcclxuICAgIHZhciBmZXRjaFRocmVhZFJlbW90ZSA9IGZ1bmN0aW9uKHRocmVhZElEKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtZXNzYWdpbmcvJyArIHRocmVhZElELCB7XHJcbiAgICAgICAgICAgIGxpbWl0OiAxMDAwIC8qIG1heCBtZXNzYWdlcyBpbiB0aGUgdGhyZWFkICovXHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbih0aHJlYWQpIHtcclxuICAgICAgICAgICAgaWYgKHRocmVhZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyZWFkID0gbmV3IFRocmVhZCh0aHJlYWQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZCA9IGZ1bGxUaHJlYWRzQ2FjaGVbdGhyZWFkSURdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5jb250cm9sLmxhdGVzdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLnRocmVhZCA9IHRocmVhZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsbFRocmVhZHNDYWNoZVt0aHJlYWRJRF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBDYWNoZUNvbnRyb2woeyB0dGw6IHsgbWludXRlczogMSB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlYWQ6IHRocmVhZFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsbFRocmVhZHNDYWNoZVt0aHJlYWRJRF0uY29udHJvbC5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocmVhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEZvdW5kJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgbWFya0FzRW5kZWRBbmRGb2xsb3dVcCA9IGZ1bmN0aW9uKGFueSkge1xyXG4gICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBhbnk7XHJcbiAgICB9O1xyXG4gICAgYXBpLmdldEl0ZW0gPSBmdW5jdGlvbiBnZXRJdGVtKHRocmVhZElEKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlZCA9IGZ1bGxUaHJlYWRzQ2FjaGVbdGhyZWFkSURdO1xyXG4gICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLnRocmVhZCkge1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkLmNvbnRyb2wubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFRocmVhZFJlbW90ZSh0aHJlYWRJRClcclxuICAgICAgICAgICAgICAgIC50aGVuKG1hcmtBc0VuZGVkQW5kRm9sbG93VXAsIG1hcmtBc0VuZGVkQW5kRm9sbG93VXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkLnRocmVhZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyh0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoVGhyZWFkUmVtb3RlKHRocmVhZElEKVxyXG4gICAgICAgICAgICAudGhlbihtYXJrQXNFbmRlZEFuZEZvbGxvd1VwLCBtYXJrQXNFbmRlZEFuZEZvbGxvd1VwKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgT25ib2FyZGluZyB0cmFja2luZyBpbmZvcm1hdGlvblxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE9uYm9hcmRpbmdQcm9ncmVzcyA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvT25ib2FyZGluZ1Byb2dyZXNzJyksXHJcbiAgICBOYXZBY3Rpb24gPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL05hdkFjdGlvbicpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIFxyXG4gICAgLy8gT25ib2FyZGluZyBtYW5hZ2VtZW50IGFuZCBzdGF0ZSwgaW5pdGlhbGx5IGVtcHR5IHNvIG5vIHByb2dyZXNzXHJcbiAgICB2YXIgYXBpID0gbmV3IE9uYm9hcmRpbmdQcm9ncmVzcygpO1xyXG4gICAgXHJcbiAgICAvLyBSZXF1aXJlcyBpbml0aWFsaXphdGlvbiB0byByZWNlaXZlIGFuZCBhcHAgaW5zdGFuY2VcclxuICAgIGFwaS5pbml0ID0gZnVuY3Rpb24gaW5pdChhcHApIHtcclxuICAgICAgICBhcGkuYXBwID0gYXBwO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gRXh0ZW5kZWQgd2l0aCBuZXcgbWV0aG9kc1xyXG5cclxuICAgIC8vIFNldCB0aGUgY29ycmVjdCBvbmJvYXJkaW5nIHByb2dyZXNzIGFuZCBzdGVwIGdpdmVuIGEgc3RlcCByZWZlcmVuY2VcclxuICAgIC8vICh1c3VhbGx5IGZyb20gZGF0YWJhc2UpXHJcbiAgICBhcGkuc2V0U3RlcCA9IGZ1bmN0aW9uKHN0ZXBSZWZlcmVuY2UpIHtcclxuICAgICAgICBpZiAoc3RlcFJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RlcEl0ZW1zID0gc3RlcFJlZmVyZW5jZS5zcGxpdCgnOicsIDIpLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBzdGVwSXRlbXNbMF0sXHJcbiAgICAgICAgICAgICAgICAvLyBzdGVwIGlzIHRoZSBzZWNvbmQgcGFydCwgb3IganVzdCB0aGUgc2FtZSBhc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZ1bGwgbmFtZSAodGhhdCBoYXBwZW5zIGZvciB0aGUgZmlyc3Qgc3RlcHMgdGhhdCBzaGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gbmFtZSB3aXRoIHRoZSBncm91cCBhbmQgb25seSBuZWVkIHRvIGRlZmluZSB0aGUgZ3JvdXAgbmFtZSlcclxuICAgICAgICAgICAgICAgIHN0ZXAgPSBzdGVwSXRlbXNbMV0gfHwgZ3JvdXA7XHJcblxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gc2V0IGN1cnJlbnQgc3RlcCwgZm9sbG93IHRvIGxvb2sgZm9yIGdyb3VwIGlmIGRvZXMgbm90IHN1Y2Nlc3NcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0U3RlcEJ5TmFtZShzdGVwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZWxzZTpcclxuICAgICAgICAgICAgLy8gTG9vayBmb3IgYSBncm91cCB0aGF0IG1hdGNoZXNcclxuICAgICAgICAgICAgdmFyIGdyb3VwU3RlcHMgPSBPbmJvYXJkaW5nUHJvZ3Jlc3MucHJlZGVmaW5lZFN0ZXBHcm91cHNbZ3JvdXBdO1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBTdGVwcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwcyhncm91cFN0ZXBzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0U3RlcEJ5TmFtZShzdGVwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vIHByb2dyZXNzOlxyXG4gICAgICAgIHRoaXMubW9kZWwucmVzZXQoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgZ2l2ZW4gbmF2YmFyIHdpdGggdGhlIGN1cnJlbnQgb25ib2FyZGluZyBpbmZvcm1hdGlvbiAob25seSBpZiBpbiBwcm9ncmVzcylcclxuICAgIGFwaS51cGRhdGVOYXZCYXIgPSBmdW5jdGlvbihuYXZCYXIpIHtcclxuICAgICAgICB2YXIgeWVwID0gdGhpcy5pblByb2dyZXNzKCk7XHJcbiAgICAgICAgaWYgKHllcCkge1xyXG4gICAgICAgICAgICAvLyBPbiAyMDE1LTA2LTE2ICM1NzUsIGNoYW5nZWQgZGVjaXNzaW9uIGZyb20gdXNlIGEgJ2dvIGJhY2snIGFjdGlvblxyXG4gICAgICAgICAgICAvLyAoY29tbWVudGVkIGluIGZvbGxvd2luZyBsaW5lcyk6XHJcbi8vICAgICAgICAgICAgbmF2QmFyLmxlZnRBY3Rpb24oTmF2QWN0aW9uLmdvQmFjay5tb2RlbC5jbG9uZSgpKTtcclxuLy8gICAgICAgICAgICBuYXZCYXIubGVmdEFjdGlvbigpLmhhbmRsZXIoZnVuY3Rpb24oKSB7XHJcbi8vICAgICAgICAgICAgICAgIGFwaS5nb1ByZXZpb3VzKCk7XHJcbi8vICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuLy8gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gdG8gdXNlIHRoZSBMb2ctb3V0IGFjdGlvblxyXG4gICAgICAgICAgICBuYXZCYXIubGVmdEFjdGlvbihOYXZBY3Rpb24uZ29Mb2dvdXQpO1xyXG5cclxuICAgICAgICAgICAgbmF2QmFyLnRpdGxlKHRoaXMucHJvZ3Jlc3NUZXh0KCkpOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geWVwO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmdvTmV4dCA9IGZ1bmN0aW9uIGdvTmV4dCgpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuc3RlcE51bWJlcigpO1xyXG5cclxuICAgICAgICBjdXJyZW50Kys7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50ID4gdGhpcy50b3RhbFN0ZXBzKCkpIHtcclxuICAgICAgICAgICAgLy8gSXQgZW5kZWQhIVxyXG4gICAgICAgICAgICB0aGlzLnN0ZXBOdW1iZXIoLTEpO1xyXG4gICAgICAgICAgICBhcHBNb2RlbC51c2VyUHJvZmlsZS5zYXZlT25ib2FyZGluZ1N0ZXAobnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvKCcvJywgeyBjb21wbGV0ZWRPbmJvYXJkaW5nOiBhcGkuZ3JvdXAoKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBuZXh0IHN0ZXBcclxuICAgICAgICAgICAgdGhpcy5zdGVwTnVtYmVyKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBhcHBNb2RlbC51c2VyUHJvZmlsZS5zYXZlT25ib2FyZGluZ1N0ZXAodGhpcy5zdGVwUmVmZXJlbmNlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nbyh0aGlzLnN0ZXBVcmwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmdvUHJldmlvdXMgPSBmdW5jdGlvbiBnb1ByZXZpb3VzKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGVwTnVtYmVyKCk7XHJcblxyXG4gICAgICAgIGN1cnJlbnQtLTtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPj0gMCAmJiBjdXJyZW50IDw9IHRoaXMudG90YWxTdGVwcygpKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBwcmV2aW91cyBzdGVwXHJcbiAgICAgICAgICAgIHRoaXMuc3RlcE51bWJlcihjdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcE51bWJlcigwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFwcE1vZGVsLnVzZXJQcm9maWxlLnNhdmVPbmJvYXJkaW5nU3RlcCh0aGlzLnN0ZXBSZWZlcmVuY2UoKSk7XHJcbiAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ28odGhpcy5zdGVwVXJsKCkpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIFBvc3RhbCBDb2RlLlxyXG5cclxuICAgIEFjY2VzcyB0aGUgQVBJIHRvIHZhbGlkYXRlIGFuZCByZXRyaWV2ZSBpbmZvcm1hdGlvbiBmb3IgYSBcclxuICAgIGdpdmVuIHBvc3RhbCBjb2RlLlxyXG4gICAgXHJcbiAgICBJdCBqdXN0IG9mZmVycyBhICdnZXQgcG9zdGFsIGNvZGUgaW5mbycgbWV0aG9kIHJldHVybmluZ1xyXG4gICAgYSBwbGFpbiBvYmplY3QgZnJvbSB0aGUgUkVTVCBlbmRwb2ludC5cclxuICAgIFxyXG4gICAgQ3JlYXRlcyBhbiBpbi1tZW1vcnkgY2FjaGUgZm9yIGZyZXF1ZW50bHkgdXNlZCBwb3N0YWwgY29kZXNcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcblxyXG4gICAgdmFyIGFwaSA9IHt9LFxyXG4gICAgICAgIGNhY2hlID0ge307XHJcbiAgICBcclxuICAgIGFwaS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbShwb3N0YWxDb2RlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcG9zdGFsQ29kZSA9IHBvc3RhbENvZGUgfHwgJyc7XHJcbiAgICAgICAgaWYgKC9eXFxzKiQvLnRlc3QocG9zdGFsQ29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdQb3N0YWwgQ29kZSBOb3QgVmFsaWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGVcclxuICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkocG9zdGFsQ29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZVtwb3N0YWxDb2RlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgncG9zdGFsLWNvZGVzLycgKyBwb3N0YWxDb2RlKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGluZm8pIHtcclxuICAgICAgICAgICAgLy8gU2F2ZSBjYWNoZVxyXG4gICAgICAgICAgICBpZiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVbcG9zdGFsQ29kZV0gPSBpbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJldHVyblxyXG4gICAgICAgICAgICByZXR1cm4gaW5mbztcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2FjaGUgPSB7fTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKiogUHJpY2luZyBUeXBlc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFByaWNpbmdUeXBlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ByaWNpbmdUeXBlJyk7XHJcblxyXG52YXIgTGlzdFJlbW90ZU1vZGVsID0gcmVxdWlyZSgnLi4vdXRpbHMvTGlzdFJlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG4gICAgXHJcbiAgICB2YXIgYXBpID0gbmV3IExpc3RSZW1vdGVNb2RlbCh7XHJcbiAgICAgICAgLy8gVHlwZXMgZG9lcyBub3QgY2hhbmdlcyB1c3VhbGx5LCBzbyBiaWcgdHRsXHJcbiAgICAgICAgbGlzdFR0bDogeyBkYXlzOiAxIH0sXHJcbiAgICAgICAgaXRlbUlkRmllbGQ6ICdwcmljaW5nVHlwZUlEJyxcclxuICAgICAgICBNb2RlbDogUHJpY2luZ1R5cGVcclxuICAgIH0pO1xyXG5cclxuICAgIGFwaS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQoJ3ByaWNpbmctdHlwZXMnKTtcclxuICAgIGFwaS5hZGRSZXN0U3VwcG9ydChhcHBNb2RlbC5yZXN0LCAncHJpY2luZy10eXBlcycpO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIFByaXZhY3kgU2V0dGluZ3NcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBQcml2YWN5U2V0dGluZ3MgPSByZXF1aXJlKCcuLi9tb2RlbHMvUHJpdmFjeVNldHRpbmdzJyk7XHJcblxyXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IG5ldyBQcml2YWN5U2V0dGluZ3MoKSxcclxuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGxvY2FsU3RvcmFnZU5hbWU6ICdwcml2YWN5U2V0dGluZ3MnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdwcml2YWN5LXNldHRpbmdzJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ3ByaXZhY3ktc2V0dGluZ3MnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcmVtO1xyXG59O1xyXG4iLCIvKipcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTY2hlZHVsaW5nUHJlZmVyZW5jZXMgPSByZXF1aXJlKCcuLi9tb2RlbHMvU2NoZWR1bGluZ1ByZWZlcmVuY2VzJyk7XHJcblxyXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IG5ldyBTY2hlZHVsaW5nUHJlZmVyZW5jZXMoKSxcclxuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGxvY2FsU3RvcmFnZU5hbWU6ICdzY2hlZHVsaW5nUHJlZmVyZW5jZXMnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdzY2hlZHVsaW5nLXByZWZlcmVuY2VzJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ3NjaGVkdWxpbmctcHJlZmVyZW5jZXMnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVjb21wdXRlIGF2YWlsYWJpbGl0eSBhcyBzaWRlIGVmZmVjdCBvZiBzY2hlZHVsaW5nIHByZWZlcmVuY2VzIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgIGFwcE1vZGVsLmNhbGVuZGFyLmNsZWFyQ2FjaGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIEZvcndhcmQgdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJlbS5jbGVhckNhY2hlKCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHJlbTtcclxufTtcclxuIiwiLyoqIFNlcnZpY2UgQWRkcmVzc2VzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4uL21vZGVscy9BZGRyZXNzJyksXHJcbiAgICBHcm91cExpc3RSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0dyb3VwTGlzdFJlbW90ZU1vZGVsJyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG5cclxuICAgIHZhciBhcGkgPSBuZXcgR3JvdXBMaXN0UmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIC8vIENvbnNlcnZhdGl2ZSBjYWNoZSwganVzdCAxIG1pbnV0ZVxyXG4gICAgICAgIGxpc3RUdGw6IHsgbWludXRlczogMSB9LFxyXG4gICAgICAgIGdyb3VwSWRGaWVsZDogJ2pvYlRpdGxlSUQnLFxyXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAnYWRkcmVzc0lEJyxcclxuICAgICAgICBNb2RlbDogQWRkcmVzc1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGFwaS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQoJ2FkZHJlc3Nlcy9zZXJ2aWNlLycpO1xyXG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdhZGRyZXNzZXMvc2VydmljZS8nKTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gYXBpO1xyXG59O1xyXG4iLCIvKipcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlJyksXHJcbiAgICBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbW90ZU1vZGVsJyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxuXHJcbi8vIFRoZSBzbG90IHNpemUgaXMgZml4ZWQgdG8gMTUgbWludXRlcyBieSBkZWZhdWx0LlxyXG4vLyBOT1RFOiBjdXJyZW50bHksIHRoZSBBUEkgb25seSBhbGxvd3MgMTUgbWludXRlcyBzbG90cyxcclxuLy8gYmVpbmcgdGhhdCBpbXBsaWNpdCwgYnV0IHBhcnQgb2YgdGhlIGNvZGUgaXMgcmVhZHkgZm9yIGV4cGxpY2l0IHNsb3RTaXplLlxyXG52YXIgZGVmYXVsdFNsb3RTaXplID0gMTU7XHJcbi8vIEEgbGlzdCBvZiB3ZWVrIGRheSBwcm9wZXJ0aWVzIG5hbWVzIGFsbG93ZWRcclxuLy8gdG8gYmUgcGFydCBvZiB0aGUgb2JqZWN0cyBkZXNjcmliaW5nIHdlZWtseSBzY2hlZHVsZVxyXG4vLyAoc2ltcGxpZmllZCBvciBjb21wbGV0ZS9zbG90IGJhc2VkKVxyXG4vLyBKdXN0IGxvd2VjYXNlZCBlbmdsaXNoIG5hbWVzXHJcbnZhciB3ZWVrRGF5UHJvcGVydGllcyA9IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknXTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XHJcbiAgICB2YXIgcmVtID0gbmV3IFJlbW90ZU1vZGVsKHtcclxuICAgICAgICBkYXRhOiBuZXcgU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlKCksXHJcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcclxuICAgICAgICBsb2NhbFN0b3JhZ2VOYW1lOiAnd2Vla2x5U2NoZWR1bGUnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdhdmFpbGFiaWxpdHkvd2Vla2x5LXNjaGVkdWxlJylcclxuICAgICAgICAgICAgLnRoZW4oZnJvbVdlZWtseVNjaGVkdWxlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XHJcbiAgICAgICAgICAgIHZhciBwbGFpbkRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAnYWxsLXRpbWUnOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICdqc29uLWRhdGEnOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmlzQWxsVGltZSgpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBwbGFpbkRhdGFbJ2FsbC10aW1lJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhWydqc29uLWRhdGEnXSA9IEpTT04uc3RyaW5naWZ5KHRvV2Vla2x5U2NoZWR1bGUodGhpcy5kYXRhLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucHV0KCdhdmFpbGFiaWxpdHkvd2Vla2x5LXNjaGVkdWxlJywgcGxhaW5EYXRhKVxyXG4gICAgICAgICAgICAudGhlbihmcm9tV2Vla2x5U2NoZWR1bGUpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZWNvbXB1dGUgYXZhaWxhYmlsaXR5IGFzIHNpZGUgZWZmZWN0IG9mIHNjaGVkdWxlXHJcbiAgICAgICAgICAgICAgICBhcHBNb2RlbC5jYWxlbmRhci5jbGVhckNhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3J3YXJkIHRoZSByZXN1bHRcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiByZW07XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmcm9tV2Vla2x5U2NoZWR1bGUod2Vla2x5U2NoZWR1bGUpIHtcclxuICAgIFxyXG4gICAgLy8gTmV3IHNpbXBsaWZpZWQgb2JqZWN0LCBhcyBhIHBsYWluIG9iamVjdCB3aXRoXHJcbiAgICAvLyB3ZWVrZGF5cyBwcm9wZXJ0aWVzIGFuZCBmcm9tLXRvIHByb3BlcnRpZXMgbGlrZTpcclxuICAgIC8vIHsgc3VuZGF5OiB7IGZyb206IDAsIHRvOiA2MCB9IH1cclxuICAgIC8vIFNpbmNlIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgY29uc3VtZWQgYnkgZmV0Y2gtcHVzaFxyXG4gICAgLy8gb3BlcmF0aW9ucywgYW5kIGxhdGVyIGJ5IGFuICdtb2RlbC51cGRhdGVXaXRoJyBvcGVyYXRpb24sXHJcbiAgICAvLyBzbyBwbGFpbiBpcyBzaW1wbGUgYW5kIGJldHRlciBvbiBwZXJmb3JtYW5jZTsgY2FuIGJlXHJcbiAgICAvLyBjb252ZXJ0ZWQgZWFzaWx5IHRvIHRoZSBTaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUgb2JqZWN0LlxyXG4gICAgdmFyIHNpbXBsZVdTID0ge1xyXG4gICAgICAgIHRpbWVab25lOiB3ZWVrbHlTY2hlZHVsZS50aW1lWm9uZSB8fCAnJ1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gT25seSBzdXBwb3J0cyAnYXZhaWxhYmxlJyBzdGF0dXMgd2l0aCBkZWZhdWx0ICd1bmF2YWlsYWJsZSdcclxuICAgIGlmICh3ZWVrbHlTY2hlZHVsZS5kZWZhdWx0U3RhdHVzICE9PSAndW5hdmFpbGFibGUnIHx8XHJcbiAgICAgICAgd2Vla2x5U2NoZWR1bGUuc3RhdHVzICE9PSAnYXZhaWxhYmxlJykge1xyXG4gICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgbmFtZTogJ2lucHV0LWZvcm1hdCcsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdXZWVrbHkgc2NoZWR1bGUsIGdpdmVuIHN0YXR1c2VzIG5vdCBzdXBwb3J0ZWQsIHN0YXR1czogJyArXHJcbiAgICAgICAgICAgIHdlZWtseVNjaGVkdWxlLnN0YXR1cyArICcsIGRlZmF1bHRTdGF0dXM6ICcgKyBcclxuICAgICAgICAgICAgd2Vla2x5U2NoZWR1bGUuZGVmYXVsdFN0YXR1c1xyXG4gICAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gZ2l2ZW4gc2xvdFNpemUgb3IgZGVmYXVsdFxyXG4gICAgdmFyIHNsb3RTaXplID0gKHdlZWtseVNjaGVkdWxlLnNsb3RTaXplIHx8IGRlZmF1bHRTbG90U2l6ZSkgfDA7XHJcblxyXG4gICAgLy8gUmVhZCBzbG90cyBwZXIgd2Vlay1kYXkgKHsgc2xvdHM6IHsgXCJzdW5kYXlcIjogW10gfSB9KVxyXG4gICAgT2JqZWN0LmtleXMod2Vla2x5U2NoZWR1bGUuc2xvdHMpXHJcbiAgICAuZm9yRWFjaChmdW5jdGlvbih3ZWVrZGF5KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVmVyaWZ5IGlzIGEgd2Vla2RheSBwcm9wZXJ0eSwgb3IgZXhpdCBlYXJseVxyXG4gICAgICAgIGlmICh3ZWVrRGF5UHJvcGVydGllcy5pbmRleE9mKHdlZWtkYXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXlzbG90cyA9IHdlZWtseVNjaGVkdWxlLnNsb3RzW3dlZWtkYXldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFdlIGdldCB0aGUgZmlyc3QgYXZhaWxhYmxlIHNsb3QgYW5kIHRoZSBsYXN0IGNvbnNlY3V0aXZlXHJcbiAgICAgICAgLy8gdG8gbWFrZSB0aGUgcmFuZ2VcclxuICAgICAgICB2YXIgZnJvbSA9IG51bGwsXHJcbiAgICAgICAgICAgIHRvID0gbnVsbCxcclxuICAgICAgICAgICAgcHJldmlvdXMgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyB0aW1lcyBhcmUgb3JkZXJlZCBpbiBhc2NlbmRpbmdcclxuICAgICAgICAvLyBhbmQgd2l0aCBmb3JtYXQgXCIwMDowMDowMFwiIHRoYXQgd2UgY29udmVydCB0byBtaW51dGVzXHJcbiAgICAgICAgLy8gKGVub3VnaCBwcmVjaXNpb24gZm9yIHNpbXBsaWZpZWQgd2Vla2x5IHNjaGVkdWxlKVxyXG4gICAgICAgIC8vIHVzaW5nIG1vbWVudC5kdXJhdGlvblxyXG4gICAgICAgIC8vIE5PVEU6IHVzaW5nICdzb21lJyByYXRoZXIgdGhhbiAnZm9yRWFjaCcgdG8gYmUgYWJsZVxyXG4gICAgICAgIC8vIHRvIGV4aXQgZWFybHkgZnJvbSB0aGUgaXRlcmF0aW9uIGJ5IHJldHVybmluZyAndHJ1ZSdcclxuICAgICAgICAvLyB3aGVuIHRoZSBlbmQgaXMgcmVhY2hlZC5cclxuICAgICAgICBkYXlzbG90cy5zb21lKGZ1bmN0aW9uKHNsb3QpIHtcclxuICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSBtb21lbnQuZHVyYXRpb24oc2xvdCkuYXNNaW51dGVzKCkgfDA7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgbm90IHN0aWxsIGEgJ2Zyb20nIHRpbWU6XHJcbiAgICAgICAgICAgIGlmIChmcm9tID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tID0gbWludXRlcztcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbWludXRlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBiZWdnaW5pbmcsIGNoZWNrIGlmIHRoaXMgaXMgY29uc2VjdXRpdmVcclxuICAgICAgICAgICAgICAgIC8vIHRvIHByZXZpb3VzLCBieSBjaGVja2luZyBwcmV2aW91cyBwbHVzIHNsb3RTaXplXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMgKyBzbG90U2l6ZSA9PT0gbWludXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBlbmRcclxuICAgICAgICAgICAgICAgICAgICB0byA9IG1pbnV0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV4dCBpdGVyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG1pbnV0ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBjb25zZWN1dGl2ZSwgd2UgYWxyZWFkeSBoYXMgYSByYW5nZSwgYW55XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBzbG90IGlzIGRpc2NhcmRlZCwgb3V0IG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZWNpc2lvbiBvZiB0aGUgc2ltcGxpZmllZCB3ZWVrbHkgc2NoZWR1bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGdvIG91dCB0aGUgaXRlcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IElmIGluIGEgZnV0dXJlIGEgbW9yZSBjb21wbGV0ZSBzY2hlZHVsZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgd3JvdGVuIHVzaW5nIG11bHRpcGxlIHJhbmdlcyByYXRoZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpdmlkdWFsIHNsb3RzLCB0aGlzIGlzIHRoZSBwbGFjZSB0byBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGluZywgcG9wdWxhdGluZyBhbiBhcnJheSBvZiBbe2Zyb20sIHRvfV0gOi0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTbG90cyBjaGVja2VkLCBjaGVjayB0aGUgcmVzdWx0XHJcbiAgICAgICAgaWYgKGZyb20gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBzaW1wbGVEYXkgPSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgdG86IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2ltcGxlV1Nbd2Vla2RheV0gPSBzaW1wbGVEYXk7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgcmFuZ2UhXHJcbiAgICAgICAgICAgIGlmICh0byAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGhhcyBhbiBlbmQhXHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNsb3Qgc2l6ZSB0byB0aGUgZW5kaW5nXHJcbiAgICAgICAgICAgICAgICBzaW1wbGVEYXkudG8gPSB0byArIHNsb3RTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc21hbGxlciByYW5nZSwganVzdCBvbmUgc2xvdCxcclxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgc2xvdCBzaXplIHRvIHRoZSBiZWdpbmluZ1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlRGF5LnRvID0gZnJvbSArIHNsb3RTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRG9uZSFcclxuICAgIHJldHVybiBzaW1wbGVXUztcclxufVxyXG5cclxuLyoqXHJcbiAgICBQYXNzIGluIGEgcGxhaW4gb2JqZWN0LCBub3QgYSBtb2RlbCxcclxuICAgIGdldHRpbmcgYW4gb2JqZWN0IHN1aXRhYmxlIGZvciB0aGUgQVBJIGVuZHBvaW50LlxyXG4qKi9cclxuZnVuY3Rpb24gdG9XZWVrbHlTY2hlZHVsZShzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUpIHtcclxuXHJcbiAgICB2YXIgc2xvdFNpemUgPSBkZWZhdWx0U2xvdFNpemU7XHJcbiAgICBcclxuICAgIC8vIEl0J3MgYnVpbGQgd2l0aCAnYXZhaWxhYmxlJyBhcyBleHBsaWNpdCBzdGF0dXM6XHJcbiAgICB2YXIgd2Vla2x5U2NoZWR1bGUgPSB7XHJcbiAgICAgICAgc3RhdHVzOiAnYXZhaWxhYmxlJyxcclxuICAgICAgICBkZWZhdWx0QXZhaWxhYmlsaXR5OiAndW5hdmFpbGFibGUnLFxyXG4gICAgICAgIHNsb3RzOiB7fSxcclxuICAgICAgICBzbG90U2l6ZTogc2xvdFNpemUsXHJcbiAgICAgICAgdGltZVpvbmU6IHNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS50aW1lWm9uZVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQZXIgd2Vla2RheVxyXG4gICAgT2JqZWN0LmtleXMoc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlKVxyXG4gICAgLmZvckVhY2goZnVuY3Rpb24od2Vla2RheSkge1xyXG5cclxuICAgICAgICAvLyBWZXJpZnkgaXMgYSB3ZWVrZGF5IHByb3BlcnR5LCBvciBleGl0IGVhcmx5XHJcbiAgICAgICAgaWYgKHdlZWtEYXlQcm9wZXJ0aWVzLmluZGV4T2Yod2Vla2RheSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaW1wbGVEYXkgPSBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGVbd2Vla2RheV07XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZXhwYW5kIHRoZSBzaW1wbGlmaWVkIHRpbWUgcmFuZ2VzIFxyXG4gICAgICAgIC8vIGluIHNsb3RzIG9mIHRoZSBzbG90U2l6ZVxyXG4gICAgICAgIC8vIFRoZSBlbmQgdGltZSB3aWxsIGJlIGV4Y2x1ZGVkLCBzaW5jZSBzbG90c1xyXG4gICAgICAgIC8vIGRlZmluZSBvbmx5IHRoZSBzdGFydCwgYmVpbmcgaW1wbGljaXQgdGhlIHNsb3RTaXplLlxyXG4gICAgICAgIHZhciBmcm9tID0gc2ltcGxlRGF5LmZyb20gfDAsXHJcbiAgICAgICAgICAgIHRvID0gc2ltcGxlRGF5LnRvIHwwO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHNsb3QgYXJyYXlcclxuICAgICAgICB3ZWVrbHlTY2hlZHVsZS5zbG90c1t3ZWVrZGF5XSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBJbnRlZ3JpdHkgdmVyaWZpY2F0aW9uXHJcbiAgICAgICAgaWYgKHRvID4gZnJvbSkge1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGJ5IHRoZSBzbG90U2l6ZSB1bnRpbCB3ZSByZWFjaFxyXG4gICAgICAgICAgICAvLyB0aGUgZW5kLCBub3QgaW5jbHVkaW5nIHRoZSAndG8nIHNpbmNlXHJcbiAgICAgICAgICAgIC8vIHNsb3RzIGluZGljYXRlIG9ubHkgdGhlIHN0YXJ0IG9mIHRoZSBzbG90XHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgYXNzdW1lZCB0byBmaWxsIGEgc2xvdFNpemUgc3RhcnRpbmdcclxuICAgICAgICAgICAgLy8gb24gdGhhdCBzbG90LXRpbWVcclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gZnJvbTtcclxuICAgICAgICAgICAgd2hpbGUgKHByZXZpb3VzIDwgdG8pIHtcclxuICAgICAgICAgICAgICAgIHdlZWtseVNjaGVkdWxlLnNsb3RzW3dlZWtkYXldLnB1c2gobWludXRlc1RvVGltZVN0cmluZyhwcmV2aW91cykpO1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgKz0gc2xvdFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEb25lIVxyXG4gICAgcmV0dXJuIHdlZWtseVNjaGVkdWxlO1xyXG59XHJcblxyXG4vKipcclxuICAgIGludGVybmFsIHV0aWxpdHkgZnVuY3Rpb24gJ3RvIHN0cmluZyB3aXRoIHR3byBkaWdpdHMgYWxtb3N0J1xyXG4qKi9cclxuZnVuY3Rpb24gdHdvRGlnaXRzKG4pIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyAxMCkgKyAnJyArIG4gJSAxMDtcclxufVxyXG5cclxuLyoqXHJcbiAgICBDb252ZXJ0IGEgbnVtYmVyIG9mIG1pbnV0ZXNcclxuICAgIGluIGEgc3RyaW5nIGxpa2U6IDAwOjAwOjAwIChob3VyczptaW51dGVzOnNlY29uZHMpXHJcbioqL1xyXG5mdW5jdGlvbiBtaW51dGVzVG9UaW1lU3RyaW5nKG1pbnV0ZXMpIHtcclxuICAgIHZhciBkID0gbW9tZW50LmR1cmF0aW9uKG1pbnV0ZXMsICdtaW51dGVzJyksXHJcbiAgICAgICAgaCA9IGQuaG91cnMoKSxcclxuICAgICAgICBtID0gZC5taW51dGVzKCksXHJcbiAgICAgICAgcyA9IGQuc2Vjb25kcygpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHR3b0RpZ2l0cyhoKSArICc6JyArXHJcbiAgICAgICAgdHdvRGlnaXRzKG0pICsgJzonICtcclxuICAgICAgICB0d29EaWdpdHMocylcclxuICAgICk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBNb2RlbCBBUEkgdG8gbWFuYWdlIHRoZSBjb2xsZWN0aW9uIG9mIEpvYiBUaXRsZXMgYXNzaWduZWRcclxuICAgIHRvIHRoZSBjdXJyZW50IHVzZXIgYW5kIGl0cyB3b3JraW5nIGRhdGEuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVXNlckpvYlRpdGxlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1VzZXJKb2JUaXRsZScpLFxyXG4gICAgQ2FjaGVDb250cm9sID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2FjaGVDb250cm9sJyksXHJcbiAgICBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xyXG5cclxuICAgIHZhciBhcGkgPSB7fSxcclxuICAgICAgICBkZWZhdWx0VHRsID0geyBtaW51dGVzOiAxIH0sXHJcbiAgICAgICAgY2FjaGUgPSB7XHJcbiAgICAgICAgICAgIC8vIEFycmF5IG9mIHVzZXIgam9iIHRpdGxlcyBtYWtpbmdcclxuICAgICAgICAgICAgLy8gaXRzIHByb2ZpbGVcclxuICAgICAgICAgICAgdXNlckpvYlByb2ZpbGU6IHtcclxuICAgICAgICAgICAgICAgIGNhY2hlOiBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiBkZWZhdWx0VHRsIH0pLFxyXG4gICAgICAgICAgICAgICAgbGlzdDogbnVsbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBJbmRleGVkIGxpc3QgYnkgam9iVGl0bGVJRCB0byB0aGUgdXNlciBqb2IgdGl0bGVzIG1vZGVsc1xyXG4gICAgICAgICAgICAvLyBpbiB0aGUgbGlzdCBhbmQgY2FjaGUgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgdXNlckpvYlRpdGxlczogey8qXHJcbiAgICAgICAgICAgICAgICBqb2JUaXRsZUlEOiB7IG1vZGVsOiBvYmplY3QsIGNhY2hlOiBDYWNoZUNvbnRyb2wgfVxyXG4gICAgICAgICAgICAqL31cclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBPYnNlcnZhYmxlIGxpc3RcclxuICAgIGFwaS5saXN0ID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuICAgIC8vIE5PVEU6IEJhc2ljIGltcGxlbWVudGF0aW9uLCB0byBlbmhhbmNlXHJcbiAgICBhcGkuc3luY0xpc3QgPSBmdW5jdGlvbiBzeW5jTGlzdCgpIHtcclxuICAgICAgICByZXR1cm4gYXBpLmdldFVzZXJKb2JQcm9maWxlKCkudGhlbihmdW5jdGlvbihsaXN0KSB7XHJcbiAgICAgICAgICAgIGFwaS5saXN0KGxpc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICBjYWNoZS51c2VySm9iUHJvZmlsZS5jYWNoZS5sYXRlc3QgPSBudWxsO1xyXG4gICAgICAgIGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QgPSBbXTtcclxuICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzID0ge307XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgQ29udmVydCByYXcgYXJyYXkgb2Ygam9iIHRpdGxlcyByZWNvcmRzIGludG9cclxuICAgICAgICBhbiBpbmRleGVkIGFycmF5IG9mIG1vZGVscywgYWN0dWFsbHkgYW4gb2JqZWN0XHJcbiAgICAgICAgd2l0aCBJRCBudW1iZXJzIGFzIHByb3BlcnRpZXMsXHJcbiAgICAgICAgYW5kIGNhY2hlIGl0IGluIG1lbW9yeS5cclxuICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWFwVG9Vc2VySm9iUHJvZmlsZShyYXdJdGVtcykge1xyXG4gICAgICAgIGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QgPSBbXTtcclxuICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzID0ge307XHJcblxyXG4gICAgICAgIGlmIChyYXdJdGVtcykge1xyXG4gICAgICAgICAgICByYXdJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKHJhd0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gbmV3IFVzZXJKb2JUaXRsZShyYXdJdGVtKTtcclxuICAgICAgICAgICAgICAgIGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QucHVzaChtKTtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmluZyBhbmQgaW5kZXhlZCBjb3B5IGFuZCBwZXIgaXRlbSBjYWNoZSBpbmZvXHJcbiAgICAgICAgICAgICAgICBzZXRHZXRVc2VySm9iVGl0bGVUb0NhY2hlKHJhd0l0ZW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG9ic2VydmFibGVcclxuICAgICAgICBhcGkubGlzdChjYWNoZS51c2VySm9iUHJvZmlsZS5saXN0KTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNhY2hlIHN0YXRlXHJcbiAgICAgICAgY2FjaGUudXNlckpvYlByb2ZpbGUuY2FjaGUubGF0ZXN0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IHRoZSBmdWxsIGpvYlByb2ZpbGUgZnJvbSBsb2NhbCBjb3B5LCB0aHJvd2luZyBhIFByb21pc2UgcmVqZWN0IGV4Y2VwdGlvbiBpZiBub3RoaW5nXHJcbiAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGdldFVzZXJKb2JQcm9maWxlRnJvbUxvY2FsKCkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCd1c2VySm9iUHJvZmlsZScpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odXNlckpvYlByb2ZpbGUpIHtcclxuICAgICAgICAgICAgaWYgKHVzZXJKb2JQcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwVG9Vc2VySm9iUHJvZmlsZSh1c2VySm9iUHJvZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0dXJuIG51bGwgc2luY2UgdGhlcmUgaXMgbm8gZGF0YSwgdGhlIHByb21pc2UgY2FuIGNhdGNoXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIGRhdGEgYW5kIGF0dGVtcHQgYSByZW1vdGVcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIFNldCBhIHJhdyB1c2VySm9iUHJvZmlsZSByZWNvcmQgKGZyb20gc2VydmVyKSBhbmQgc2V0IGl0IGluIHRoZVxyXG4gICAgICAgIGNhY2hlLCBjcmVhdGluZyBvciB1cGRhdGluZyB0aGUgbW9kZWwgKHNvIGFsbCB0aGUgdGltZSB0aGUgc2FtZSBtb2RlbCBpbnN0YW5jZVxyXG4gICAgICAgIGlzIHVzZWQpIGFuZCBjYWNoZSBjb250cm9sIGluZm9ybWF0aW9uLlxyXG4gICAgICAgIFJldHVybnMgdGhlIG1vZGVsIGluc3RhbmNlLlxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBzZXRHZXRVc2VySm9iVGl0bGVUb0NhY2hlKHJhd0l0ZW0pIHtcclxuICAgICAgICB2YXIgYyA9IGNhY2hlLnVzZXJKb2JUaXRsZXNbcmF3SXRlbS5qb2JUaXRsZUlEXSB8fCB7fTtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1vZGVsIGlmIGV4aXN0cywgc28gZ2V0IHJlZmxlY3RlZCB0byBhbnlvbmUgY29uc3VtaW5nIGl0XHJcbiAgICAgICAgaWYgKGMubW9kZWwpIHtcclxuICAgICAgICAgICAgYy5tb2RlbC5tb2RlbC51cGRhdGVXaXRoKHJhd0l0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSwgY3JlYXRlIG1vZGVsXHJcbiAgICAgICAgICAgIGMubW9kZWwgPSBuZXcgVXNlckpvYlRpdGxlKHJhd0l0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgY2FjaGUgY29udHJvbFxyXG4gICAgICAgIGlmIChjLmNhY2hlKSB7XHJcbiAgICAgICAgICAgIGMuY2FjaGUubGF0ZXN0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGMuY2FjaGUgPSBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiBkZWZhdWx0VHRsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHByb2ZpbGUgbGlzdCwgYWRkIG9yIHVwZGF0ZTpcclxuICAgICAgICB2YXIgZnVsbExpc3QgPSAgY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdDtcclxuICAgICAgICBpZiAoZnVsbExpc3QpIHtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gbnVsbDtcclxuICAgICAgICAgICAgZnVsbExpc3Quc29tZShmdW5jdGlvbihpdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0LmpvYlRpdGxlSUQoKSA9PT0gcmF3SXRlbS5qb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpdDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgZm91bmQubW9kZWwudXBkYXRlV2l0aChyYXdJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZ1bGxMaXN0LnB1c2goYy5tb2RlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RlbCwgdXBkYXRlZCBvciBqdXN0IGNyZWF0ZWRcclxuICAgICAgICByZXR1cm4gYy5tb2RlbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2V0IHRoZSBjb250ZW50IGZyb20gdGhlIGNhY2hlLCBmb3IgZnVsbCBwcm9maWxlXHJcbiAgICAgICAgYW5kIHNhdmUgaXQgaW4gbG9jYWwgc3RvcmFnZVxyXG4gICAgICAgIE5PVEUgSXQgaGFzIG5vIHNlbnNlIGluIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gKHByb2JsZW0gb2YgZmV0Y2hcclxuICAgICAgICBqb2IgdGl0bGUgd2l0aG91dCBhIGZ1bGwgam9iIHByb2ZpbGUgaW4gY2FjaGUvbG9jYWwpXHJcbiAgICAqKi9cclxuICAgIC8qZnVuY3Rpb24gc2F2ZUNhY2hlSW5Mb2NhbCgpIHtcclxuICAgICAgICB2YXIgcGxhaW4gPSBjYWNoZS51c2VySm9iUHJvZmlsZS5saXN0Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgIC8vIEVhY2ggaXRlbSBpcyBhIG1vZGVsLCBnZXQgaXQgaW4gcGxhaW46XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLm1vZGVsLnRvUGxhaW5PYmplY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsb2NhbGZvcmFnZS5zZXRJdGVtKCd1c2VySm9iUHJvZmlsZScsIHBsYWluKTtcclxuICAgIH0qL1xyXG4gICAgXHJcbiAgICAvLyBQcml2YXRlLCBmZXRjaCBmcm9tIHJlbW90ZVxyXG4gICAgdmFyIGZldGNoVXNlckpvYlByb2ZpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gVGhpcmQgYW5kIGxhc3QsIHJlbW90ZSBsb2FkaW5nXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2VyLWpvYi1wcm9maWxlJylcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmF3KSB7XHJcbiAgICAgICAgICAgIC8vIENhY2hlIGluIGxvY2FsIHN0b3JhZ2VcclxuICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgndXNlckpvYlByb2ZpbGUnLCByYXcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwVG9Vc2VySm9iUHJvZmlsZShyYXcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUHVibGljIEFQSVxyXG4gICAgICAgIEdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBVc2VySm9iVGl0bGUgZm9yXHJcbiAgICAgICAgYWxsIHRoZSBKb2JUaXRsZXMgYXNzaWduZWQgdG8gdGhlIGN1cnJlbnQgdXNlclxyXG4gICAgKiovXHJcbiAgICBhcGkuZ2V0VXNlckpvYlByb2ZpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSWYgbm8gY2FjaGUgb3IgbXVzdCByZXZhbGlkYXRlLCBnbyByZW1vdGVcclxuICAgICAgICAvLyAodGhlIGZpcnN0IGxvYWRpbmcgaXMgZXZlciAnbXVzdCByZXZhbGlkYXRlJylcclxuICAgICAgICBpZiAoY2FjaGUudXNlckpvYlByb2ZpbGUuY2FjaGUubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjYWNoZSwgaXMgZmlyc3QgbG9hZCwgc28gdHJ5IGxvY2FsXHJcbiAgICAgICAgICAgIGlmICghY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9jYWwgc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFVzZXJKb2JQcm9maWxlRnJvbUxvY2FsKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsYXVuY2ggcmVtb3RlIGZvciBzeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZVByb21pc2UgPSBmZXRjaFVzZXJKb2JQcm9maWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3RlIGZhbGxiYWNrOiBJZiBubyBsb2NhbCwgd2FpdCBmb3IgcmVtb3RlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhIDogcmVtb3RlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gY2FjaGUsIG5vIGxvY2FsLCBvciBvYnNvbGV0ZSwgZ28gcmVtb3RlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoVXNlckpvYlByb2ZpbGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgY2FjaGUgYW5kIGlzIHN0aWxsIHZhbGlkOlxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIFByaXZhdGUsIGZldGNoIGZyb20gcmVtb3RlXHJcbiAgICB2YXIgZmV0Y2hVc2VySm9iVGl0bGUgPSBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2VyLWpvYi1wcm9maWxlLycgKyBqb2JUaXRsZUlEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJhdykge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHRvIGNhY2hlIGFuZCBnZXQgbW9kZWxcclxuICAgICAgICAgICAgdmFyIG0gPSBzZXRHZXRVc2VySm9iVGl0bGVUb0NhY2hlKHJhdyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBjYWNoZSBzYXZpbmcgZm9yIHNpbmdsZSBqb2ItdGl0bGVzLCBjdXJyZW50bHlcclxuICAgICAgICAgICAgLy8gaXQgbmVlZHMgdG8gc2F2ZSB0aGUgcHJvZmlsZSBjYWNoZSwgdGhhdCBtYXkgbm90IGV4aXN0cyBpZlxyXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgcmVxdWVzdCBpcyBmb3IgYSBzaW5nbGUgam9iIHRpdGxlLlxyXG4gICAgICAgICAgICAvLyBOZXh0IGxpbmVzIGFyZSB0byBzYXZlIGZ1bGwgcHJvZmlsZSwgbm90IHZhbGlkIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWxcclxuICAgICAgICAgICAgLy9zYXZlQ2FjaGVJbkxvY2FsKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gbW9kZWxcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgcHVzaE5ld1VzZXJKb2JUaXRsZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xyXG4gICAgICAgIC8vIENyZWF0ZSBqb2IgdGl0bGUgaW4gcmVtb3RlXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucG9zdCgndXNlci1qb2ItcHJvZmlsZScsICQuZXh0ZW5kKHtcclxuICAgICAgICAgICAgam9iVGl0bGVJRDogMCxcclxuICAgICAgICAgICAgam9iVGl0bGVOYW1lOiAnJyxcclxuICAgICAgICAgICAgaW50cm86ICcnLFxyXG4gICAgICAgICAgICBjYW5jZWxsYXRpb25Qb2xpY3lJRDogbnVsbCxcclxuICAgICAgICAgICAgaW5zdGFudEJvb2tpbmc6IGZhbHNlXHJcbiAgICAgICAgfSwgdmFsdWVzKSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihyYXcpIHtcclxuICAgICAgICAgICAgLy8gU2F2ZSB0byBjYWNoZSBhbmQgZ2V0IG1vZGVsXHJcbiAgICAgICAgICAgIHZhciBtID0gc2V0R2V0VXNlckpvYlRpdGxlVG9DYWNoZShyYXcpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgY2FjaGUgc2F2aW5nIGZvciBzaW5nbGUgam9iLXRpdGxlcywgY3VycmVudGx5XHJcbiAgICAgICAgICAgIC8vIGl0IG5lZWRzIHRvIHNhdmUgdGhlIHByb2ZpbGUgY2FjaGUsIHRoYXQgbWF5IG5vdCBleGlzdHMgaWZcclxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHJlcXVlc3QgaXMgZm9yIGEgc2luZ2xlIGpvYiB0aXRsZS5cclxuICAgICAgICAgICAgLy8gTmV4dCBsaW5lcyBhcmUgdG8gc2F2ZSBmdWxsIHByb2ZpbGUsIG5vdCB2YWxpZCBoZXJlLlxyXG4gICAgICAgICAgICAvLyBTYXZlIGluIGxvY2FsXHJcbiAgICAgICAgICAgIC8vc2F2ZUNhY2hlSW5Mb2NhbCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmV0dXJuIG1vZGVsXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUHVibGljIEFQSVxyXG4gICAgICAgIEdldCBhIFVzZXJKb2JUaXRsZSByZWNvcmQgZm9yIHRoZSBnaXZlblxyXG4gICAgICAgIEpvYlRpdGxlSUQgYW5kIHRoZSBjdXJyZW50IHVzZXIuXHJcbiAgICAqKi9cclxuICAgIGFwaS5nZXRVc2VySm9iVGl0bGUgPSBmdW5jdGlvbiAoam9iVGl0bGVJRCkge1xyXG4gICAgICAgIC8vIFF1aWNrIGVycm9yXHJcbiAgICAgICAgaWYgKCFqb2JUaXRsZUlEKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0pvYiBUaXRsZSBJRCByZXF1aXJlZCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vIGNhY2hlIG9yIG11c3QgcmV2YWxpZGF0ZSwgZ28gcmVtb3RlXHJcbiAgICAgICAgaWYgKCFjYWNoZS51c2VySm9iVGl0bGVzW2pvYlRpdGxlSURdIHx8XHJcbiAgICAgICAgICAgIGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0uY2FjaGUubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hVc2VySm9iVGl0bGUoam9iVGl0bGVJRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IGNhY2hlXHJcbiAgICAgICAgICAgIGlmIChjYWNoZS51c2VySm9iVGl0bGVzW2pvYlRpdGxlSURdICYmXHJcbiAgICAgICAgICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzW2pvYlRpdGxlSURdLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0ubW9kZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kLCBsb2NhbCBzdG9yYWdlLCB3aGVyZSB3ZSBoYXZlIHRoZSBmdWxsIGpvYiBwcm9maWxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VXNlckpvYlByb2ZpbGVGcm9tTG9jYWwoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oLyp1c2VySm9iUHJvZmlsZSovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG5lZWQgZm9yIHRoZSBwYXJhbWV0ZXIsIHRoZSBkYXRhIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWVtb3J5IGFuZCBpbmRleGVkLCBsb29rIGZvciB0aGUgam9iIHRpdGxlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0ubW9kZWw7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gbG9jYWwgY29weSAoZXJyb3Igb24gcHJvbWlzZSksXHJcbiAgICAgICAgICAgICAgICAvLyBvciB0aGF0IGRvZXMgbm90IGNvbnRhaW5zIHRoZSBqb2IgdGl0bGUgKGVycm9yIG9uICd0aGVuJyk6XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlyZCBhbmQgbGFzdCwgcmVtb3RlIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmZXRjaFVzZXJKb2JUaXRsZS5iaW5kKG51bGwsIGpvYlRpdGxlSUQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5jcmVhdGVVc2VySm9iVGl0bGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHB1c2hOZXdVc2VySm9iVGl0bGUodmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLyoqIEFESVRJT05BTCBVVElMSVRJRVMgKiovXHJcbiAgICBhcGkuZ2V0VXNlckpvYlRpdGxlQW5kSm9iVGl0bGUgPSBmdW5jdGlvbiBnZXRVc2VySm9iVGl0bGVBbmRKb2JUaXRsZShqb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwaS5nZXRVc2VySm9iVGl0bGUoam9iVGl0bGVJRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbih1c2VySm9iVGl0bGUpIHtcclxuICAgICAgICAgICAgLy8gVmVyeSB1bmxpa2VseSBlcnJvclxyXG4gICAgICAgICAgICBpZiAoIXVzZXJKb2JUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdOb3QgRm91bmQnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExKREk6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdZb3UgaGF2ZSBub3QgdGhpcyBqb2IgdGl0bGUgaW4geW91ciBwcm9maWxlLiAnICsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdNYXliZSB3YXMgZGVsZXRlZCBmcm9tIHlvdXIgcHJvZmlsZSByZWNlbnRseS4nXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgam9iIHRpdGxlIGluZm8gdG9vXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICB1c2VySm9iVGl0bGUsXHJcbiAgICAgICAgICAgICAgICBhcHBNb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRClcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihhbGwpIHtcclxuICAgICAgICAgICAgdmFyIGpvYlRpdGxlID0gYWxsWzFdO1xyXG4gICAgICAgICAgICAvLyBWZXJ5IHVubGlrZWx5IGVycm9yXHJcbiAgICAgICAgICAgIGlmICgham9iVGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTm90IEZvdW5kJyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBMSkRJOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgam9iIHRpdGxlIGRvZXMgbm90IGV4aXN0LidcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGpvYlRpdGxlSUQ6IGpvYlRpdGxlSUQsXHJcbiAgICAgICAgICAgICAgICB1c2VySm9iVGl0bGU6IGFsbFswXSxcclxuICAgICAgICAgICAgICAgIGpvYlRpdGxlOiBqb2JUaXRsZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGFwaTtcclxufTtcclxuIiwiLyoqIFVzZXJQcm9maWxlXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVXNlciA9IHJlcXVpcmUoJy4uL21vZGVscy9Vc2VyJyk7XHJcblxyXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpLFxyXG4gICAgbG9jYWxmb3JhZ2UgPSByZXF1aXJlKCdsb2NhbGZvcmFnZScpO1xyXG5cclxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcclxuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xyXG4gICAgICAgIGRhdGE6IFVzZXIubmV3QW5vbnltb3VzKCksXHJcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IEtlZXAgdGhlIG5hbWUgaW4gc3luYyB3aXRoIHNldC11cCBhdCBBcHBNb2RlbC1hY2NvdW50XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3Byb2ZpbGUnLFxyXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdwcm9maWxlJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ3Byb2ZpbGUnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZW0uc2F2ZU9uYm9hcmRpbmdTdGVwID0gZnVuY3Rpb24gc2F2ZU9uYm9hcmRpbmdTdGVwKHN0ZXBSZWZlcmVuY2UpIHtcclxuICAgICAgICBpZiAodHlwZW9mKHN0ZXBSZWZlcmVuY2UpID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBzdGVwUmVmZXJlbmNlID0gcmVtLmRhdGEub25ib2FyZGluZ1N0ZXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbS5kYXRhLm9uYm9hcmRpbmdTdGVwKHN0ZXBSZWZlcmVuY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucHV0KCdwcm9maWxlL3RyYWNraW5nJywge1xyXG4gICAgICAgICAgICBvbmJvYXJkaW5nU3RlcDogc3RlcFJlZmVyZW5jZVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHN1Y2Nlc3MsIHNhdmUgcGVyc2lzdGVudCBsb2NhbCBjb3B5IG9mIHRoZSBkYXRhIHRvIGVuc3VyZSB0aGVcclxuICAgICAgICAgICAgLy8gbmV3IG9uYm9hcmRpbmdTdGVwIGlzIHNhdmVkXHJcbiAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0ocmVtLmxvY2FsU3RvcmFnZU5hbWUsIHJlbS5kYXRhLm1vZGVsLnRvUGxhaW5PYmplY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gcmVtO1xyXG59O1xyXG4iLCIvKipcclxuICAgIEFjdGl2aXR5IGJhc2UgY2xhc3NcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBOYXZBY3Rpb24gPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL05hdkFjdGlvbicpLFxyXG4gICAgTmF2QmFyID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9OYXZCYXInKTtcclxuXHJcbnJlcXVpcmUoJy4uL3V0aWxzL0Z1bmN0aW9uLnByb3RvdHlwZS5faW5oZXJpdHMnKTtcclxuXHJcbi8qKlxyXG4gICAgQWN0aXZpdHkgY2xhc3MgZGVmaW5pdGlvblxyXG4qKi9cclxuZnVuY3Rpb24gQWN0aXZpdHkoJGFjdGl2aXR5LCBhcHApIHtcclxuXHJcbiAgICB0aGlzLiRhY3Rpdml0eSA9ICRhY3Rpdml0eTtcclxuICAgIHRoaXMuYXBwID0gYXBwO1xyXG5cclxuICAgIC8vIERlZmF1bHQgYWNjZXNzIGxldmVsOiBhbnlvbmVcclxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSBhcHAuVXNlclR5cGUuTm9uZTtcclxuICAgIFxyXG4gICAgLy8gVE9ETzogRnV0dXJlIHVzZSBvZiBhIHZpZXdTdGF0ZSwgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXHJcbiAgICAvLyBvZiBwYXJ0IG9mIHRoZSB2aWV3TW9kZWwgdG8gYmUgdXNlZCBhcyB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZVxyXG4gICAgLy8gaGlzdG9yeSBhbmQgYmV0d2VlbiBhY3Rpdml0aWVzIGNhbGxzLlxyXG4gICAgdGhpcy52aWV3U3RhdGUgPSB7fTtcclxuICAgIFxyXG4gICAgLy8gT2JqZWN0IHRvIGhvbGQgdGhlIG9wdGlvbnMgcGFzc2VkIG9uICdzaG93JyBhcyBhIHJlc3VsdFxyXG4gICAgLy8gb2YgYSByZXF1ZXN0IGZyb20gYW5vdGhlciBhY3Rpdml0eVxyXG4gICAgdGhpcy5yZXF1ZXN0RGF0YSA9IG51bGw7XHJcblxyXG4gICAgLy8gRGVmYXVsdCBuYXZCYXIgb2JqZWN0LlxyXG4gICAgdGhpcy5uYXZCYXIgPSBuZXcgTmF2QmFyKHtcclxuICAgICAgICB0aXRsZTogbnVsbCwgLy8gbnVsbCBmb3IgbG9nb1xyXG4gICAgICAgIGxlZnRBY3Rpb246IG51bGwsXHJcbiAgICAgICAgcmlnaHRBY3Rpb246IG51bGxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBLbm9ja291dCBiaW5kaW5nIG9mIHZpZXdTdGF0ZSBkZWxheWVkIHRvIGZpcnN0IHNob3dcclxuICAgIC8vIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggc3ViY2xhc3NlcyByZXBsYWNpbmcgdGhlIHZpZXdTdGF0ZVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFjdGl2aXR5O1xyXG5cclxuLyoqXHJcbiAgICBTZXQtdXAgdmlzdWFsaXphdGlvbiBvZiB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zL3N0YXRlLFxyXG4gICAgd2l0aCBhIHJlc2V0IG9mIGN1cnJlbnQgc3RhdGUuXHJcbiAgICBNdXN0IGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIGFjdGl2aXR5IGlzIHB1dCBpbiB0aGUgY3VycmVudCB2aWV3LlxyXG4qKi9cclxuQWN0aXZpdHkucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcclxuICAgIC8vIFRPRE86IG11c3Qga2VlcCB2aWV3U3RhdGUgdXAgdG8gZGF0ZSB1c2luZyBvcHRpb25zL3N0YXRlLlxyXG4gICAgLy9jb25zb2xlLmxvZygnQWN0aXZpdHkgc2hvdycsIHRoaXMuY29uc3RydWN0b3IubmFtZSk7XHJcbiAgICBpZiAoIXRoaXMuX19iaW5kaW5nRG9uZSkge1xyXG4gICAgICAgIC8vIEEgdmlldyBtb2RlbCBhbmQgYmluZGluZ3MgYmVpbmcgYXBwbGllZCBpcyBldmVyIHJlcXVpcmVkXHJcbiAgICAgICAgLy8gZXZlbiBvbiBBY3Rpdml0aWVzIHdpdGhvdXQgbmVlZCBmb3IgYSB2aWV3IG1vZGVsLCBzaW5jZVxyXG4gICAgICAgIC8vIHRoZSB1c2Ugb2YgY29tcG9uZW50cyBhbmQgdGVtcGxhdGVzLCBvciBhbnkgb3RoZXIgZGF0YS1iaW5kXHJcbiAgICAgICAgLy8gc3ludGF4LCByZXF1aXJlcyB0byBiZSBpbiBhIGNvbnRleHQgd2l0aCBiaW5kaW5nIGVuYWJsZWQ6XHJcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyh0aGlzLnZpZXdNb2RlbCB8fCB7fSwgdGhpcy4kYWN0aXZpdHkuZ2V0KDApKTtcclxuICAgICAgICB0aGlzLl9fYmluZGluZ0RvbmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMucmVxdWVzdERhdGEgPSBvcHRpb25zO1xyXG4gICAgXHJcbiAgICAvLyBFbmFibGUgcmVnaXN0ZXJlZCBoYW5kbGVyc1xyXG4gICAgLy8gVmFsaWRhdGlvbiBvZiBlYWNoIHNldHRpbmdzIG9iamVjdCBpcyBwZXJmb3JtZWRcclxuICAgIC8vIG9uIHJlZ2lzdGVyZWQsIGF2b2lkZWQgaGVyZS5cclxuICAgIGlmICh0aGlzLl9oYW5kbGVycyAmJlxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzQXJlQ29ubmVjdGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpcyBhbiBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvblxyXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmV2ZW50ICYmIHNldHRpbmdzLnRhcmdldC5zdWJzY3JpYmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKHNldHRpbmdzLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gT2JzZXJ2YWJsZXMgaGFzIG5vdCBhICd1bnN1YnNjcmliZScgZnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAvLyB0aGV5IHJldHVybiBhbiBvYmplY3QgdGhhdCBtdXN0IGJlICdkaXNwb3NlZCcuXHJcbiAgICAgICAgICAgICAgICAvLyBTYXZpbmcgdGhhdCB3aXRoIHNldHRpbmdzIHRvIGFsbG93ICd1bnN1YnNjcmliZScgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElubWVkaWF0ZSBleGVjdXRpb246IGlmIGN1cnJlbnQgb2JzZXJ2YWJsZSB2YWx1ZSBpcyBkaWZmZXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIHRoYW4gcHJldmlvdXMgb25lLCBleGVjdXRlIHRoZSBoYW5kbGVyOlxyXG4gICAgICAgICAgICAgICAgLy8gKHRoaXMgYXZvaWQgdGhhdCBhIGNoYW5nZWQgc3RhdGUgZ2V0IG9taXR0ZWQgYmVjYXVzZSBoYXBwZW5lZFxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBzdWJzY3JpcHRpb24gd2FzIG9mZjsgaXQgbWVhbnMgYSBmaXJzdCB0aW1lIGV4ZWN1dGlvbiB0b28pLlxyXG4gICAgICAgICAgICAgICAgLy8gTk9URTogJ3VuZGVmaW5lZCcgdmFsdWUgb24gb2JzZXJ2YWJsZSBtYXkgY2F1c2UgdGhpcyB0byBmYWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuX2xhdGVzdFN1YnNjcmliZWRWYWx1ZSAhPT0gc2V0dGluZ3MudGFyZ2V0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYW5kbGVyLmNhbGwoc2V0dGluZ3MudGFyZ2V0LCBzZXR0aW5ncy50YXJnZXQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Muc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnRhcmdldC5vbihzZXR0aW5ncy5ldmVudCwgc2V0dGluZ3Muc2VsZWN0b3IsIHNldHRpbmdzLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLnRhcmdldC5vbikge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudGFyZ2V0Lm9uKHNldHRpbmdzLmV2ZW50LCBzZXR0aW5ncy5oYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjdGl2aXR5LnNob3c6IEJhZCByZWdpc3RlcmVkIGhhbmRsZXInLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBUbyBhdm9pZCBkb3VibGUgY29ubmVjdGlvbnM6XHJcbiAgICAgICAgLy8gTk9URTogbWF5IGhhcHBlbiB0aGF0ICdzaG93JyBnZXRzIGNhbGxlZCBzZXZlcmFsIHRpbWVzIHdpdGhvdXQgYSAnaGlkZSdcclxuICAgICAgICAvLyBpbiBiZXR3ZWVuLCBiZWNhdXNlICdzaG93JyBhY3RzIGFzIGEgcmVmcmVzaGVyIHJpZ2h0IG5vdyBldmVuIGZyb20gc2VnbWVudFxyXG4gICAgICAgIC8vIGNoYW5nZXMgZnJvbSB0aGUgc2FtZSBhY3Rpdml0eS5cclxuICAgICAgICB0aGlzLl9oYW5kbGVyc0FyZUNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIFBlcmZvcm0gdGFza3MgdG8gc3RvcCBhbnl0aGluZyBydW5uaW5nIG9yIHN0b3AgaGFuZGxlcnMgZnJvbSBsaXN0ZW5pbmcuXHJcbiAgICBNdXN0IGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIGFjdGl2aXR5IGlzIGhpZGRlbi9yZW1vdmVkIFxyXG4gICAgZnJvbSB0aGUgY3VycmVudCB2aWV3LlxyXG4qKi9cclxuQWN0aXZpdHkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xyXG4gICAgXHJcbiAgICAvLyBEaXNhYmxlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcclxuICAgIGlmICh0aGlzLl9oYW5kbGVycykge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYW4gb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLl9zdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLl9zdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBsYXRlc3Qgb2JzZXJ2YWJsZSB2YWx1ZSB0byBtYWtlIGEgY29tcGFyaXNpb25cclxuICAgICAgICAgICAgICAgIC8vIG5leHQgdGltZSBpcyBlbmFibGVkIHRvIGVuc3VyZSBpcyBleGVjdXRlZCBpZiB0aGVyZSB3YXNcclxuICAgICAgICAgICAgICAgIC8vIGEgY2hhbmdlIHdoaWxlIGRpc2FibGVkOlxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX2xhdGVzdFN1YnNjcmliZWRWYWx1ZSA9IHNldHRpbmdzLnRhcmdldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLnRhcmdldC5vZmYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zZWxlY3RvcilcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50YXJnZXQub2ZmKHNldHRpbmdzLmV2ZW50LCBzZXR0aW5ncy5zZWxlY3Rvciwgc2V0dGluZ3MuaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudGFyZ2V0Lm9mZihzZXR0aW5ncy5ldmVudCwgc2V0dGluZ3MuaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy50YXJnZXQucmVtb3ZlTGlzdGVuZXIoc2V0dGluZ3MuZXZlbnQsIHNldHRpbmdzLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQWN0aXZpdHkuaGlkZTogQmFkIHJlZ2lzdGVyZWQgaGFuZGxlcicsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzQXJlQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIFJlZ2lzdGVyIGEgaGFuZGxlciB0aGF0IGFjdHMgb24gYW4gZXZlbnQgb3Igc3Vic2NyaXB0aW9uIG5vdGlmaWNhdGlvbixcclxuICAgIHRoYXQgd2lsbCBiZSBlbmFibGVkIG9uIEFjdGl2aXR5LnNob3cgYW5kIGRpc2FibGVkIG9uIEFjdGl2aXR5LmhpZGUuXHJcblxyXG4gICAgQHBhcmFtIHNldHRpbmdzOm9iamVjdCB7XHJcbiAgICAgICAgdGFyZ2V0OiBqUXVlcnksIEV2ZW50RW1pdHRlciwgS25vY2tvdXQub2JzZXJ2YWJsZS4gUmVxdWlyZWRcclxuICAgICAgICBldmVudDogc3RyaW5nLiBFdmVudCBuYW1lIChjYW4gaGF2ZSBuYW1lc3BhY2VzLCBzZXZlcmFsIGV2ZW50cyBhbGxvd2VkKS4gSXRzIHJlcXVpcmVkIGV4Y2VwdCB3aGVuIHRoZSB0YXJnZXQgaXMgYW4gb2JzZXJ2YWJsZSwgdGhlcmUgbXVzdFxyXG4gICAgICAgICAgICBiZSBvbWl0dGVkLlxyXG4gICAgICAgIGhhbmRsZXI6IEZ1bmN0aW9uLiBSZXF1aXJlZCxcclxuICAgICAgICBzZWxlY3Rvcjogc3RyaW5nLiBPcHRpb25hbC4gRm9yIGpRdWVyeSBldmVudHMgb25seSwgcGFzc2VkIGFzIHRoZVxyXG4gICAgICAgICAgICBzZWxlY3RvciBmb3IgZGVsZWdhdGVkIGhhbmRsZXJzLlxyXG4gICAgfVxyXG4qKi9cclxuQWN0aXZpdHkucHJvdG90eXBlLnJlZ2lzdGVySGFuZGxlciA9IGZ1bmN0aW9uIHJlZ2lzdGVySGFuZGxlcihzZXR0aW5ncykge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo4ICovXHJcbiAgICBcclxuICAgIGlmICghc2V0dGluZ3MpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWdpc3RlciByZXF1aXJlIGEgc2V0dGluZ3Mgb2JqZWN0Jyk7XHJcbiAgICBcclxuICAgIGlmICghc2V0dGluZ3MudGFyZ2V0IHx8ICghc2V0dGluZ3MudGFyZ2V0Lm9uICYmICFzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBpcyBudWxsIG9yIG5vdCBhIGpRdWVyeSwgRXZlbnRFbW1pdGVyIG9yIE9ic2VydmFibGUgb2JqZWN0Jyk7XHJcbiAgICBcclxuICAgIGlmICh0eXBlb2Yoc2V0dGluZ3MuaGFuZGxlcikgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoIXNldHRpbmdzLmV2ZW50ICYmICFzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCBpcyBudWxsOyBpdFxcJ3MgcmVxdWlyZWQgZm9yIG5vbiBvYnNlcnZhYmxlIG9iamVjdHMnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9oYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzIHx8IFtdO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goc2V0dGluZ3MpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBTdGF0aWMgdXRpbGl0aWVzXHJcbioqL1xyXG4vLyBGb3IgY29tbW9kaXR5LCBjb21tb24gY2xhc3NlcyBhcmUgZXhwb3NlZCBhcyBzdGF0aWMgcHJvcGVydGllc1xyXG5BY3Rpdml0eS5OYXZCYXIgPSBOYXZCYXI7XHJcbkFjdGl2aXR5Lk5hdkFjdGlvbiA9IE5hdkFjdGlvbjtcclxuXHJcbi8vIFF1aWNrIGNyZWF0aW9uIG9mIGNvbW1vbiB0eXBlcyBvZiBOYXZCYXJcclxuQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhciA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25OYXZCYXIodGl0bGUpIHtcclxuICAgIHJldHVybiBuZXcgTmF2QmFyKHtcclxuICAgICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgICAgbGVmdEFjdGlvbjogTmF2QWN0aW9uLm1lbnVJbixcclxuICAgICAgICByaWdodEFjdGlvbjogTmF2QWN0aW9uLm1lbnVOZXdJdGVtXHJcbiAgICB9KTtcclxufTtcclxuXHJcbkFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIgPSBmdW5jdGlvbiBjcmVhdGVTdWJzZWN0aW9uTmF2QmFyKHRpdGxlLCBvcHRpb25zKSB7XHJcbiAgICBcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgXHJcbiAgICB2YXIgZ29CYWNrT3B0aW9ucyA9IHtcclxuICAgICAgICB0ZXh0OiB0aXRsZSxcclxuICAgICAgICBpc1RpdGxlOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChvcHRpb25zLmJhY2tMaW5rKSB7XHJcbiAgICAgICAgZ29CYWNrT3B0aW9ucy5saW5rID0gb3B0aW9ucy5iYWNrTGluaztcclxuICAgICAgICBnb0JhY2tPcHRpb25zLmlzU2hlbGwgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IE5hdkJhcih7XHJcbiAgICAgICAgdGl0bGU6ICcnLCAvLyBObyB0aXRsZVxyXG4gICAgICAgIGxlZnRBY3Rpb246IE5hdkFjdGlvbi5nb0JhY2subW9kZWwuY2xvbmUoZ29CYWNrT3B0aW9ucyksXHJcbiAgICAgICAgcmlnaHRBY3Rpb246IG9wdGlvbnMuaGVscElkID9cclxuICAgICAgICAgICAgTmF2QWN0aW9uLmdvSGVscEluZGV4Lm1vZGVsLmNsb25lKHtcclxuICAgICAgICAgICAgICAgIGxpbms6ICcjJyArIG9wdGlvbnMuaGVscElkXHJcbiAgICAgICAgICAgIH0pIDpcclxuICAgICAgICAgICAgTmF2QWN0aW9uLmdvSGVscEluZGV4XHJcbiAgICB9KTtcclxufTtcclxuXHJcbkFjdGl2aXR5LnByb3RvdHlwZS5jcmVhdGVDYW5jZWxBY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVDYW5jZWxBY3Rpb24oY2FuY2VsTGluaykge1xyXG4gICAgXHJcbiAgICB2YXIgYXBwID0gdGhpcy5hcHA7XHJcbiAgICBcclxuICAgIHZhciBhY3Rpb24gPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgICAgICBsaW5rOiBjYW5jZWxMaW5rLFxyXG4gICAgICAgIHRleHQ6ICdjYW5jZWwnLFxyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rKCksXHJcbiAgICAgICAgICAgICAgICBlb3B0aW9ucyA9IGV2ZW50ICYmIGV2ZW50Lm9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgZ29MaW5rID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluaylcclxuICAgICAgICAgICAgICAgICAgICBhcHAuc2hlbGwuZ28obGluayk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYXBwLnNoZWxsLmdvQmFjaygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQSBzaWxlbnRNb2RlIHBhc3NlZCB0byB0aGUgZXZlbnQgcmVxdWlyZXNcclxuICAgICAgICAgICAgLy8gYXZvaWQgdGhlIG1vZGFsICh1c2VkIHdoZW4gZXhlY3V0aW5nIGEgc2F2aW5nIHRhc2sgZm9yIGV4YW1wbGUpXHJcbiAgICAgICAgICAgIGlmIChlb3B0aW9ucy5zaWxlbnRNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBnb0xpbmsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gTDE4TlxyXG4gICAgICAgICAgICAgICAgYXBwLm1vZGFscy5jb25maXJtKHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NhbmNlbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0FyZSB5b3Ugc3VyZT8nLFxyXG4gICAgICAgICAgICAgICAgICAgIHllczogJ1llcycsXHJcbiAgICAgICAgICAgICAgICAgICAgbm86ICdObydcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25maXJtZWQgY2FuY2VsbGF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIGdvTGluaygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYWN0aW9uO1xyXG59O1xyXG5cclxuQWN0aXZpdHkucHJvdG90eXBlLmNvbnZlcnRUb0NhbmNlbEFjdGlvbiA9IGZ1bmN0aW9uIGNvbnZlcnRUb0NhbmNlbEFjdGlvbihhY3Rpb25Nb2RlbCwgY2FuY2VsTGluaykge1xyXG4gICAgdmFyIGNhbmNlbCA9IHRoaXMuY3JlYXRlQ2FuY2VsQWN0aW9uKGNhbmNlbExpbmspO1xyXG4gICAgYWN0aW9uTW9kZWwubW9kZWwudXBkYXRlV2l0aChjYW5jZWwpO1xyXG4gICAgLy8gRFVERTogaGFuZGxlciBpcyBjcGllZCBieSB1cGRhdGVXaXRoP1xyXG4gICAgYWN0aW9uTW9kZWwuaGFuZGxlcihjYW5jZWwuaGFuZGxlcigpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgU2luZ2xldG9uIGhlbHBlclxyXG4qKi9cclxudmFyIHNpbmdsZW50b25JbnN0YW5jZXMgPSB7fTtcclxudmFyIGNyZWF0ZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbihBY3Rpdml0eUNsYXNzLCAkYWN0aXZpdHksIGFwcCkge1xyXG4gICAgXHJcbiAgICBpZiAoc2luZ2xlbnRvbkluc3RhbmNlc1tBY3Rpdml0eUNsYXNzLm5hbWVdIGluc3RhbmNlb2YgQWN0aXZpdHlDbGFzcykge1xyXG4gICAgICAgIHJldHVybiBzaW5nbGVudG9uSW5zdGFuY2VzW0FjdGl2aXR5Q2xhc3MubmFtZV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgcyA9IG5ldyBBY3Rpdml0eUNsYXNzKCRhY3Rpdml0eSwgYXBwKTtcclxuICAgICAgICBzaW5nbGVudG9uSW5zdGFuY2VzW0FjdGl2aXR5Q2xhc3MubmFtZV0gPSBzO1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG59O1xyXG4vLyBFeGFtcGxlIG9mIHVzZVxyXG4vL2V4cG9ydHMuaW5pdCA9IGNyZWF0ZVNpbmdsZXRvbi5iaW5kKG51bGwsIEFjdGl2aXR5Q2xhc3MpO1xyXG5cclxuLyoqXHJcbiAgICBTdGF0aWMgbWV0aG9kIGV4dGVuZHMgdG8gaGVscCBpbmhlcml0YW5jZS5cclxuICAgIEFkZGl0aW9uYWxseSwgaXQgYWRkcyBhIHN0YXRpYyBpbml0IG1ldGhvZCByZWFkeSBmb3IgdGhlIG5ldyBjbGFzc1xyXG4gICAgdGhhdCBnZW5lcmF0ZXMvcmV0cmlldmVzIHRoZSBzaW5nbGV0b24uXHJcbioqL1xyXG5BY3Rpdml0eS5leHRlbmRzID0gZnVuY3Rpb24gZXh0ZW5kc0FjdGl2aXR5KENsYXNzRm4pIHtcclxuICAgIFxyXG4gICAgQ2xhc3NGbi5faW5oZXJpdHMoQWN0aXZpdHkpO1xyXG4gICAgXHJcbiAgICBDbGFzc0ZuLmluaXQgPSBjcmVhdGVTaW5nbGV0b24uYmluZChudWxsLCBDbGFzc0ZuKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIENsYXNzRm47XHJcbn07XHJcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBEYXRlUGlja2VyIEpTIENvbXBvbmVudCwgd2l0aCBzZXZlcmFsXHJcbiAqIG1vZGVzIGFuZCBvcHRpb25hbCBpbmxpbmUtcGVybWFuZW50IHZpc3VhbGl6YXRpb24uXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE0IExvY29ub21pY3MgQ29vcC5cclxuICpcclxuICogQmFzZWQgb246XHJcbiAqIGJvb3RzdHJhcC1kYXRlcGlja2VyLmpzIFxyXG4gKiBodHRwOi8vd3d3LmV5ZWNvbi5yby9ib290c3RyYXAtZGF0ZXBpY2tlclxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTsgXHJcblxyXG52YXIgY2xhc3NlcyA9IHtcclxuICAgIGNvbXBvbmVudDogJ0RhdGVQaWNrZXInLFxyXG4gICAgbW9udGhzOiAnRGF0ZVBpY2tlci1tb250aHMnLFxyXG4gICAgZGF5czogJ0RhdGVQaWNrZXItZGF5cycsXHJcbiAgICBtb250aERheTogJ2RheScsXHJcbiAgICBtb250aDogJ21vbnRoJyxcclxuICAgIHllYXI6ICd5ZWFyJyxcclxuICAgIHllYXJzOiAnRGF0ZVBpY2tlci15ZWFycycsXHJcbiAgICB3ZWVrRGF5czogJ0RhdGVQaWNrZXItd2Vla0RheXMnLFxyXG4gICAgYWN0aXZlOiAnYWN0aXZlJ1xyXG59O1xyXG5cclxudmFyIGV2ZW50cyA9IHtcclxuICAgIGRheVJlbmRlcmVkOiAnZGF5UmVuZGVyZWQnLFxyXG4gICAgZGF0ZUNoYW5nZWQ6ICdkYXRlQ2hhbmdlZCcsXHJcbiAgICBzaG93OiAnc2hvdycsXHJcbiAgICBoaWRlOiAnaGlkZScsXHJcbiAgICBkYXRlU2V0OiAnZGF0ZVNldCcsXHJcbiAgICAvLyBJTVBPUlRBTlQ6IFRyaWdnZXJlZCBhZnRlciBhIHZhbHVlIGlzIHNldCBvciB1cGRhdGVkIGluIHRoZSB2aWV3RGF0ZSBwcm9wZXJ0eVxyXG4gICAgLy8gd2l0aG91dCBjaGVjayBpZiB0aGUgc2FtZSBvciBub3QgKGJ1dCBvcGVyYXRpb25zIHVwZGF0aW5nIGl0IGhhcHBlbnMgb24gYSBjaGFuZ2UpXHJcbiAgICAvLyBBTkQgYWZ0ZXIgaXMgY2hhbmdlZCBhbmQgY2FsZW5kYXIgZmlsbGVkIChmaWxsIG1ldGhvZCBjYWxsZWQsIHNvIERPTSByZWZsZWN0cyB0aGUgbmV3IHZpZXdEYXRlKS5cclxuICAgIHZpZXdEYXRlQ2hhbmdlZDogJ3ZpZXdEYXRlQ2hhbmdlZCdcclxufTtcclxuXHJcbnZhciBEUEdsb2JhbCA9IHtcclxuICAgIG1vZGVzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbHNOYW1lOiAnZGF5cycsXHJcbiAgICAgICAgICAgIG5hdkZuYzogJ01vbnRoJyxcclxuICAgICAgICAgICAgbmF2U3RlcDogMVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjbHNOYW1lOiAnbW9udGhzJyxcclxuICAgICAgICAgICAgbmF2Rm5jOiAnRnVsbFllYXInLFxyXG4gICAgICAgICAgICBuYXZTdGVwOiAxXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNsc05hbWU6ICd5ZWFycycsXHJcbiAgICAgICAgICAgIG5hdkZuYzogJ0Z1bGxZZWFyJyxcclxuICAgICAgICAgICAgbmF2U3RlcDogMTBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2xzTmFtZTogJ2RheScsXHJcbiAgICAgICAgICAgIG5hdkZuYzogJ0RhdGUnLFxyXG4gICAgICAgICAgICBuYXZTdGVwOiAxXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIGRhdGVzOntcclxuICAgICAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiLCBcIlN1bmRheVwiXSxcclxuICAgICAgICBkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiXSxcclxuICAgICAgICBkYXlzTWluOiBbXCJTdVwiLCBcIk1cIiwgXCJUdVwiLCBcIldcIiwgXCJUaFwiLCBcIkZcIiwgXCJTYVwiLCBcIlN1XCJdLFxyXG4gICAgICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXHJcbiAgICAgICAgbW9udGhzU2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxyXG4gICAgfSxcclxuICAgIGlzTGVhcFllYXI6IGZ1bmN0aW9uICh5ZWFyKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKHllYXIgJSA0ID09PSAwKSAmJiAoeWVhciAlIDEwMCAhPT0gMCkpIHx8ICh5ZWFyICUgNDAwID09PSAwKSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xyXG4gICAgICAgIHJldHVybiBbMzEsIChEUEdsb2JhbC5pc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb250aF07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCl7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGZvcm1hdC5tYXRjaCgvWy5cXC9cXC1cXHNdLio/LyksXHJcbiAgICAgICAgICAgIHBhcnRzID0gZm9ybWF0LnNwbGl0KC9cXFcrLyk7XHJcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge3NlcGFyYXRvcjogc2VwYXJhdG9yLCBwYXJ0czogcGFydHN9O1xyXG4gICAgfSxcclxuICAgIHBhcnNlRGF0ZTogZnVuY3Rpb24oZGF0ZSwgZm9ybWF0KSB7XHJcbiAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxMSovXHJcbiAgICAgICAgdmFyIHBhcnRzID0gZGF0ZS5zcGxpdChmb3JtYXQuc2VwYXJhdG9yKSxcclxuICAgICAgICAgICAgdmFsO1xyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGRhdGUuc2V0SG91cnMoMCk7XHJcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKDApO1xyXG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcygwKTtcclxuICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcclxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSBmb3JtYXQucGFydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXkgPSBkYXRlLmdldERhdGUoKSwgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgY250ID0gZm9ybWF0LnBhcnRzLmxlbmd0aDsgaSA8IGNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApfHwxO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoKGZvcm1hdC5wYXJ0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RkJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW0nOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9IHZhbCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0TW9udGgodmFsIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3l5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IDIwMDAgKyB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoMjAwMCArIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3l5eXknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAwICwwICwwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgZm9ybWF0RGF0ZTogZnVuY3Rpb24oZGF0ZSwgZm9ybWF0KXtcclxuICAgICAgICB2YXIgdmFsID0ge1xyXG4gICAgICAgICAgICBkOiBkYXRlLmdldERhdGUoKSxcclxuICAgICAgICAgICAgbTogZGF0ZS5nZXRNb250aCgpICsgMSxcclxuICAgICAgICAgICAgeXk6IGRhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcclxuICAgICAgICAgICAgeXl5eTogZGF0ZS5nZXRGdWxsWWVhcigpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YWwuZGQgPSAodmFsLmQgPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5kO1xyXG4gICAgICAgIHZhbC5tbSA9ICh2YWwubSA8IDEwID8gJzAnIDogJycpICsgdmFsLm07XHJcbiAgICAgICAgZGF0ZSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGk9MCwgY250ID0gZm9ybWF0LnBhcnRzLmxlbmd0aDsgaSA8IGNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGUucHVzaCh2YWxbZm9ybWF0LnBhcnRzW2ldXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlLmpvaW4oZm9ybWF0LnNlcGFyYXRvcik7XHJcbiAgICB9LFxyXG4gICAgaGVhZFRlbXBsYXRlOiAnPHRoZWFkPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dHI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJwcmV2XCI+JmxzYXF1bzs8L3RoPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRoIGNvbHNwYW49XCI1XCIgY2xhc3M9XCJzd2l0Y2hcIj48L3RoPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwibmV4dFwiPiZyc2FxdW87PC90aD4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoZWFkPicsXHJcbiAgICBjb250VGVtcGxhdGU6ICc8dGJvZHk+PHRyPjx0ZCBjb2xzcGFuPVwiN1wiPjwvdGQ+PC90cj48L3Rib2R5PidcclxufTtcclxuRFBHbG9iYWwudGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc2VzLmNvbXBvbmVudCArICdcIj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc2VzLmRheXMgKyAnXCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCIgdGFibGUtY29uZGVuc2VkXCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEUEdsb2JhbC5oZWFkVGVtcGxhdGUrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0Ym9keT48L3Rib2R5PicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5tb250aHMgKyAnXCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEUEdsb2JhbC5jb250VGVtcGxhdGUrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy55ZWFycyArICdcIj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRFBHbG9iYWwuaGVhZFRlbXBsYXRlK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L3RhYmxlPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG5EUEdsb2JhbC5tb2Rlc1NldCA9IHtcclxuICAgICdkYXRlJzogRFBHbG9iYWwubW9kZXNbM10sXHJcbiAgICAnbW9udGgnOiBEUEdsb2JhbC5tb2Rlc1swXSxcclxuICAgICd5ZWFyJzogRFBHbG9iYWwubW9kZXNbMV0sXHJcbiAgICAnZGVjYWRlJzogRFBHbG9iYWwubW9kZXNbMl1cclxufTtcclxuXHJcbi8vIFBpY2tlciBvYmplY3RcclxudmFyIERhdGVQaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICAvKmpzaGludCBtYXhzdGF0ZW1lbnRzOjQwLG1heGNvbXBsZXhpdHk6MjQqL1xyXG4gICAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcclxuICAgIHRoaXMuZm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQob3B0aW9ucy5mb3JtYXR8fHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlLWZvcm1hdCcpfHwnbW0vZGQveXl5eScpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzSW5wdXQgPSB0aGlzLmVsZW1lbnQuaXMoJ2lucHV0Jyk7XHJcbiAgICB0aGlzLmNvbXBvbmVudCA9IHRoaXMuZWxlbWVudC5pcygnLmRhdGUnKSA/IHRoaXMuZWxlbWVudC5maW5kKCcuYWRkLW9uJykgOiBmYWxzZTtcclxuICAgIHRoaXMuaXNQbGFjZWhvbGRlciA9IHRoaXMuZWxlbWVudC5pcygnLmNhbGVuZGFyLXBsYWNlaG9sZGVyJyk7XHJcbiAgICBcclxuICAgIHRoaXMucGlja2VyID0gJChEUEdsb2JhbC50ZW1wbGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuaXNQbGFjZWhvbGRlciA/IHRoaXMuZWxlbWVudCA6ICdib2R5JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICQucHJveHkodGhpcy5jbGljaywgdGhpcykpO1xyXG4gICAgdGhpcy5waWNrZXIuYWRkQ2xhc3ModGhpcy5pc1BsYWNlaG9sZGVyID8gJycgOiAnZHJvcGRvd24tbWVudScpO1xyXG4gICAgaWYgKG9wdGlvbnMuZXh0cmFDbGFzc2VzKVxyXG4gICAgICAgIHRoaXMucGlja2VyLmFkZENsYXNzKG9wdGlvbnMuZXh0cmFDbGFzc2VzKTtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuaXNQbGFjZWhvbGRlcikge1xyXG4gICAgICAgIHRoaXMucGlja2VyLnNob3coKTtcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSA9PSAndG9kYXknKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKHtcclxuICAgICAgICAgICAgdHlwZTogZXZlbnRzLnNob3csXHJcbiAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5pc0lucHV0KSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uKHtcclxuICAgICAgICAgICAgZm9jdXM6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcclxuICAgICAgICAgICAgLy9ibHVyOiAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcyksXHJcbiAgICAgICAgICAgIGtleXVwOiAkLnByb3h5KHRoaXMudXBkYXRlLCB0aGlzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpe1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbignY2xpY2snLCAkLnByb3h5KHRoaXMuc2hvdywgdGhpcykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5vbignY2xpY2snLCAkLnByb3h5KHRoaXMuc2hvdywgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyogVG91Y2ggZXZlbnRzIHRvIHN3aXBlIGRhdGVzICovXHJcbiAgICB0aGlzLmVsZW1lbnRcclxuICAgIC5vbignc3dpcGVsZWZ0JywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLm1vdmVEYXRlKCduZXh0Jyk7XHJcbiAgICB9LmJpbmQodGhpcykpXHJcbiAgICAub24oJ3N3aXBlcmlnaHQnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMubW92ZURhdGUoJ3ByZXYnKTtcclxuICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgLyogU2V0LXVwIHZpZXcgbW9kZSAqL1xyXG4gICAgdGhpcy5taW5WaWV3TW9kZSA9IG9wdGlvbnMubWluVmlld01vZGV8fHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlLW1pbnZpZXdtb2RlJyl8fDA7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMubWluVmlld01vZGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLm1pblZpZXdNb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vbnRocyc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pblZpZXdNb2RlID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd5ZWFycyc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pblZpZXdNb2RlID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5WaWV3TW9kZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnZpZXdNb2RlID0gb3B0aW9ucy52aWV3TW9kZXx8dGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUtdmlld21vZGUnKXx8MDtcclxuICAgIGlmICh0eXBlb2YgdGhpcy52aWV3TW9kZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMudmlld01vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbW9udGhzJzpcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3llYXJzJzpcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuc3RhcnRWaWV3TW9kZSA9IHRoaXMudmlld01vZGU7XHJcbiAgICB0aGlzLndlZWtTdGFydCA9IG9wdGlvbnMud2Vla1N0YXJ0fHx0aGlzLmVsZW1lbnQuZGF0YSgnZGF0ZS13ZWVrc3RhcnQnKXx8MDtcclxuICAgIHRoaXMud2Vla0VuZCA9IHRoaXMud2Vla1N0YXJ0ID09PSAwID8gNiA6IHRoaXMud2Vla1N0YXJ0IC0gMTtcclxuICAgIHRoaXMub25SZW5kZXIgPSBvcHRpb25zLm9uUmVuZGVyO1xyXG4gICAgdGhpcy5maWxsRG93KCk7XHJcbiAgICB0aGlzLmZpbGxNb250aHMoKTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB0aGlzLnNob3dNb2RlKCk7XHJcbn07XHJcblxyXG5EYXRlUGlja2VyLnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBEYXRlUGlja2VyLFxyXG4gICAgXHJcbiAgICBfdHJpZ2dlclZpZXdEYXRlQ2hhbmdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdmlld01vZGVOYW1lID0gRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcihldmVudHMudmlld0RhdGVDaGFuZ2VkLCBbeyB2aWV3RGF0ZTogdGhpcy52aWV3RGF0ZSwgdmlld01vZGU6IHZpZXdNb2RlTmFtZSB9XSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG93OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdGhpcy5waWNrZXIuc2hvdygpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCgpIDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5wbGFjZSgpO1xyXG4gICAgICAgICQod2luZG93KVxyXG4gICAgICAgICAgICAub2ZmKCdyZXNpemUuZGF0ZXBpY2tlcicpXHJcbiAgICAgICAgICAgIC5vbigncmVzaXplLmRhdGVwaWNrZXInLCAkLnByb3h5KHRoaXMucGxhY2UsIHRoaXMpKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0lucHV0KSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAkKGRvY3VtZW50KVxyXG4gICAgICAgIC5vZmYoJ21vdXNlZG93bi5kYXRlcGlja2VyJylcclxuICAgICAgICAub24oJ21vdXNlZG93bi5kYXRlcGlja2VyJywgZnVuY3Rpb24oZXYpe1xyXG4gICAgICAgICAgICBpZiAoJChldi50YXJnZXQpLmNsb3Nlc3QoJy4nICsgY2xhc3Nlcy5jb21wb25lbnQpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50cy5zaG93LFxyXG4gICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGVcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5waWNrZXIuaGlkZSgpO1xyXG4gICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5kYXRlcGlja2VyJywgdGhpcy5wbGFjZSk7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZSA9IHRoaXMuc3RhcnRWaWV3TW9kZTtcclxuICAgICAgICB0aGlzLnNob3dNb2RlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5wdXQpIHtcclxuICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdtb3VzZWRvd24uZGF0ZXBpY2tlcicsIHRoaXMuaGlkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdGhpcy5zZXQoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50cy5oaWRlLFxyXG4gICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGVcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdGVkID0gRFBHbG9iYWwuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsIHRoaXMuZm9ybWF0KTtcclxuICAgICAgICBpZiAoIXRoaXMuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykucHJvcCgndmFsdWUnLCBmb3JtYXRlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnLCBmb3JtYXRlZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnByb3AoJ3ZhbHVlJywgZm9ybWF0ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcihldmVudHMuZGF0ZVNldCwgW3RoaXMuZGF0ZSwgZm9ybWF0ZWRdKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIFNldHMgYSBkYXRlIGFzIHZhbHVlIGFuZCBub3RpZnkgd2l0aCBhbiBldmVudC5cclxuICAgICAgICBQYXJhbWV0ZXIgZG9udE5vdGlmeSBpcyBvbmx5IGZvciBjYXNlcyB3aGVyZSB0aGUgY2FsZW5kYXIgb3JcclxuICAgICAgICBzb21lIHJlbGF0ZWQgY29tcG9uZW50IGdldHMgYWxyZWFkeSB1cGRhdGVkIGJ1dCB0aGUgaGlnaGxpZ2h0ZWRcclxuICAgICAgICBkYXRlIG5lZWRzIHRvIGJlIHVwZGF0ZWQgd2l0aG91dCBjcmVhdGUgaW5maW5pdGUgcmVjdXJzaW9uIFxyXG4gICAgICAgIGJlY2F1c2Ugb2Ygbm90aWZpY2F0aW9uLiBJbiBvdGhlciBjYXNlLCBkb250IHVzZS5cclxuICAgICoqL1xyXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKG5ld0RhdGUsIGRvbnROb3RpZnkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5ld0RhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShuZXdEYXRlLCB0aGlzLmZvcm1hdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUobmV3RGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSwgMSwgMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgLy8gVE9ETyBNdXN0IGNoZWNrIGRvbnROb3RpZnk/XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlclZpZXdEYXRlQ2hhbmdlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRvbnROb3RpZnkgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gTm90aWZ5OlxyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudHMuZGF0ZUNoYW5nZWQsXHJcbiAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXHJcbiAgICAgICAgICAgICAgICB2aWV3TW9kZTogRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldFZpZXdEYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3RGF0ZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG1vdmVWYWx1ZTogZnVuY3Rpb24oZGlyLCBtb2RlKSB7XHJcbiAgICAgICAgLy8gZGlyIGNhbiBiZTogJ3ByZXYnLCAnbmV4dCdcclxuICAgICAgICBpZiAoWydwcmV2JywgJ25leHQnXS5pbmRleE9mKGRpciAmJiBkaXIudG9Mb3dlckNhc2UoKSkgPT0gLTEpXHJcbiAgICAgICAgICAgIC8vIE5vIHZhbGlkIG9wdGlvbjpcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBkZWZhdWx0IG1vZGUgaXMgdGhlIGN1cnJlbnQgb25lXHJcbiAgICAgICAgbW9kZSA9IG1vZGUgP1xyXG4gICAgICAgICAgICBEUEdsb2JhbC5tb2Rlc1NldFttb2RlXSA6XHJcbiAgICAgICAgICAgIERQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdO1xyXG5cclxuICAgICAgICB0aGlzLmRhdGVbJ3NldCcgKyBtb2RlLm5hdkZuY10uY2FsbChcclxuICAgICAgICAgICAgdGhpcy5kYXRlLFxyXG4gICAgICAgICAgICB0aGlzLmRhdGVbJ2dldCcgKyBtb2RlLm5hdkZuY10uY2FsbCh0aGlzLmRhdGUpICsgXHJcbiAgICAgICAgICAgIG1vZGUubmF2U3RlcCAqIChkaXIgPT09ICdwcmV2JyA/IC0xIDogMSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5kYXRlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRlO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcGxhY2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XHJcbiAgICAgICAgdGhpcy5waWNrZXIuY3NzKHtcclxuICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wICsgdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG5ld0RhdGUpe1xyXG4gICAgICAgIHRoaXMuZGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShcclxuICAgICAgICAgICAgdHlwZW9mIG5ld0RhdGUgPT09ICdzdHJpbmcnID8gbmV3RGF0ZSA6ICh0aGlzLmlzSW5wdXQgPyB0aGlzLmVsZW1lbnQucHJvcCgndmFsdWUnKSA6IHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlJykpLFxyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSwgMSwgMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlclZpZXdEYXRlQ2hhbmdlKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXREYXlzRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMuZGF5cyArICcgLicgKyBjbGFzc2VzLm1vbnRoRGF5KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGZpbGxEb3c6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGRvd0NudCA9IHRoaXMud2Vla1N0YXJ0O1xyXG4gICAgICAgIHZhciBodG1sID0gJzx0ciBjbGFzcz1cIicgKyBjbGFzc2VzLndlZWtEYXlzICsgJ1wiPic7XHJcbiAgICAgICAgd2hpbGUgKGRvd0NudCA8IHRoaXMud2Vla1N0YXJ0ICsgNykge1xyXG4gICAgICAgICAgICBodG1sICs9ICc8dGggY2xhc3M9XCJkb3dcIj4nK0RQR2xvYmFsLmRhdGVzLmRheXNNaW5bKGRvd0NudCsrKSU3XSsnPC90aD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sICs9ICc8L3RyPic7XHJcbiAgICAgICAgdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLmRheXMgKyAnIHRoZWFkJykuYXBwZW5kKGh0bWwpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZmlsbE1vbnRoczogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IDEyKSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzZXMubW9udGggKyAnXCI+JytEUEdsb2JhbC5kYXRlcy5tb250aHNTaG9ydFtpKytdKyc8L3NwYW4+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLm1vbnRocyArICcgdGQnKS5hcHBlbmQoaHRtbCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBmaWxsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvKmpzaGludCBtYXhzdGF0ZW1lbnRzOjcwLCBtYXhjb21wbGV4aXR5OjI4Ki9cclxuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpLFxyXG4gICAgICAgICAgICB5ZWFyID0gZC5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBtb250aCA9IGQuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgY3VycmVudERhdGUgPSB0aGlzLmRhdGUudmFsdWVPZigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBmaXJzdCBkYXRlIHRvIHNob3csIHVzdWFsbHkgb24gcHJldmlvdXMgbW9udGg6XHJcbiAgICAgICAgdmFyIHByZXZNb250aCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLTEsIDI4LDAsMCwwLDApLFxyXG4gICAgICAgICAgICBsYXN0RGF5UHJldk1vbnRoID0gRFBHbG9iYWwuZ2V0RGF5c0luTW9udGgocHJldk1vbnRoLmdldEZ1bGxZZWFyKCksIHByZXZNb250aC5nZXRNb250aCgpKTtcclxuICAgICAgICAvLyBMMThOP1xyXG4gICAgICAgIHByZXZNb250aC5zZXREYXRlKGxhc3REYXlQcmV2TW9udGgpO1xyXG4gICAgICAgIHByZXZNb250aC5zZXREYXRlKGxhc3REYXlQcmV2TW9udGggLSAocHJldk1vbnRoLmdldERheSgpIC0gdGhpcy53ZWVrU3RhcnQgKyA3KSU3KTsgICAgICAgIFxyXG5cclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IEF2b2lkIGR1cGxpY2F0ZWQgd29yaywgYnkgY2hlY2tpbmcgd2UgYXJlIHN0aWxsIHNob3dpbmcgdGhlIHNhbWUgbW9udGgsXHJcbiAgICAgICAgLy8gc28gbm90IG5lZWQgdG8gJ3JlLXJlbmRlcicgZXZlcnl0aGluZywgb25seSBzd2FwIHRoZSBhY3RpdmUgZGF0ZVxyXG4gICAgICAgIGlmICh0aGlzLl9wcmV2RGF0ZSAmJiB0aGlzLl9wcmV2RGF0ZS5nZXRNb250aCgpID09PSB0aGlzLnZpZXdEYXRlLmdldE1vbnRoKCkpIHtcclxuICAgICAgICAgICAgdmFyIHRib2R5ID0gdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLmRheXMgKyAnIHRib2R5Jyk7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBhY3RpdmUgZGF0ZSBtYXJrXHJcbiAgICAgICAgICAgIC8vICh2aWV3RGF0ZSBoYXMgZWZmZWN0aXZlbHkgdGhlIHZhbHVlIG9mIHByZXZpb3VzIGFjdGl2ZSBkYXRlLCBidXQgZG9pbmcgYSBjbGFzcyBzZWFyY2ggd29rcyB0b28gOi0pXHJcbiAgICAgICAgICAgIHRib2R5LmZpbmQoJy4nICsgY2xhc3Nlcy5tb250aERheSArICcuJyArIGNsYXNzZXMuYWN0aXZlKVxyXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoY2xhc3Nlcy5hY3RpdmUpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIGRhdGUgbWFyayB0byBjdXJyZW50XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gbGFzdERheVByZXZNb250aCAtIHByZXZNb250aC5nZXREYXRlKCksXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGRpZmYgKyB0aGlzLmRhdGUuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgaXJvdyA9IChpbmRleCAvIDcpIHwwLFxyXG4gICAgICAgICAgICAgICAgaWNvbCA9IGluZGV4ICUgNztcclxuICAgICAgICAgICAgdGJvZHkuZmluZCgndHI6ZXEoJyArIGlyb3cgKyAnKSB0ZDplcSgnICsgaWNvbCArICcpJykuYWRkQ2xhc3MoY2xhc3Nlcy5hY3RpdmUpOyAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLl9wcmV2RGF0ZSA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpO1xyXG4gICAgICAgICAgICAvLyBET05FOlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ByZXZEYXRlID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSk7XHJcblxyXG4gICAgICAgIC8vIEhlYWRlclxyXG4gICAgICAgIHRoaXMucGlja2VyXHJcbiAgICAgICAgLmZpbmQoJy4nICsgY2xhc3Nlcy5kYXlzICsgJyB0aDplcSgxKScpXHJcbiAgICAgICAgLmh0bWwoRFBHbG9iYWwuZGF0ZXMubW9udGhzW21vbnRoXSArICcgJyArIHllYXIpO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgZW5kaW5nXHJcbiAgICAgICAgdmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHByZXZNb250aCk7XHJcbiAgICAgICAgbmV4dE1vbnRoLnNldERhdGUobmV4dE1vbnRoLmdldERhdGUoKSArIDQyKTtcclxuICAgICAgICBuZXh0TW9udGggPSBuZXh0TW9udGgudmFsdWVPZigpO1xyXG4gICAgICAgIHZhciBodG1sID0gW107XHJcbiAgICAgICAgdmFyIGNsc05hbWUsXHJcbiAgICAgICAgICAgIHByZXZZLFxyXG4gICAgICAgICAgICBwcmV2TTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuX2RheXNDcmVhdGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBiYXNlIGh0bWwgKGZpcnN0IHRpbWUgb25seSlcclxuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBmb3IodmFyIHIgPSAwOyByIDwgNjsgcisrKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sLnB1c2goJzx0cj4nKTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgYyA9IDA7IGMgPCA3OyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2goJzx0ZCBjbGFzcz1cIicgKyBjbGFzc2VzLm1vbnRoRGF5ICsgJ1wiPjxzcGFuPiZuYnNwOzwvc3Bhbj48L3RkPicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaHRtbC5wdXNoKCc8L3RyPicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMuZGF5cyArICcgdGJvZHknKS5lbXB0eSgpLmFwcGVuZChodG1sLmpvaW4oJycpKTtcclxuICAgICAgICAgICAgdGhpcy5fZGF5c0NyZWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGRheXMgdmFsdWVzICAgIFxyXG4gICAgICAgIHZhciB3ZWVrVHIgPSB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMuZGF5cyArICcgdGJvZHkgdHI6Zmlyc3QtY2hpbGQoKScpO1xyXG4gICAgICAgIHZhciBkYXlUZCA9IG51bGw7XHJcbiAgICAgICAgd2hpbGUocHJldk1vbnRoLnZhbHVlT2YoKSA8IG5leHRNb250aCkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFdlZWtEYXlJbmRleCA9IHByZXZNb250aC5nZXREYXkoKSAtIHRoaXMud2Vla1N0YXJ0O1xyXG5cclxuICAgICAgICAgICAgY2xzTmFtZSA9IHRoaXMub25SZW5kZXIocHJldk1vbnRoKTtcclxuICAgICAgICAgICAgcHJldlkgPSBwcmV2TW9udGguZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgcHJldk0gPSBwcmV2TW9udGguZ2V0TW9udGgoKTtcclxuICAgICAgICAgICAgaWYgKChwcmV2TSA8IG1vbnRoICYmICBwcmV2WSA9PT0geWVhcikgfHwgIHByZXZZIDwgeWVhcikge1xyXG4gICAgICAgICAgICAgICAgY2xzTmFtZSArPSAnIG9sZCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHByZXZNID4gbW9udGggJiYgcHJldlkgPT09IHllYXIpIHx8IHByZXZZID4geWVhcikge1xyXG4gICAgICAgICAgICAgICAgY2xzTmFtZSArPSAnIG5ldyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZNb250aC52YWx1ZU9mKCkgPT09IGN1cnJlbnREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjbHNOYW1lICs9ICcgJyArIGNsYXNzZXMuYWN0aXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkYXlUZCA9IHdlZWtUci5maW5kKCd0ZDplcSgnICsgY3VycmVudFdlZWtEYXlJbmRleCArICcpJyk7XHJcbiAgICAgICAgICAgIGRheVRkXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGNsYXNzZXMubW9udGhEYXkgKyAnICcgKyBjbHNOYW1lKVxyXG4gICAgICAgICAgICAuZGF0YSgnZGF0ZS10aW1lJywgcHJldk1vbnRoLnRvSVNPU3RyaW5nKCkpXHJcbiAgICAgICAgICAgIC5jaGlsZHJlbignc3BhbicpLnRleHQocHJldk1vbnRoLmdldERhdGUoKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBpY2tlci50cmlnZ2VyKGV2ZW50cy5kYXlSZW5kZXJlZCwgW2RheVRkXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBOZXh0IHdlZWs/XHJcbiAgICAgICAgICAgIGlmIChwcmV2TW9udGguZ2V0RGF5KCkgPT09IHRoaXMud2Vla0VuZCkge1xyXG4gICAgICAgICAgICAgICAgd2Vla1RyID0gd2Vla1RyLm5leHQoJ3RyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldk1vbnRoLnNldERhdGUocHJldk1vbnRoLmdldERhdGUoKSsxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJyZW50WWVhciA9IHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtb250aHMgPSB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMubW9udGhzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCd0aDplcSgxKScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKHllYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCdzcGFuJykucmVtb3ZlQ2xhc3MoY2xhc3Nlcy5hY3RpdmUpO1xyXG4gICAgICAgIGlmIChjdXJyZW50WWVhciA9PT0geWVhcikge1xyXG4gICAgICAgICAgICBtb250aHMuZXEodGhpcy5kYXRlLmdldE1vbnRoKCkpLmFkZENsYXNzKGNsYXNzZXMuYWN0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaHRtbCA9ICcnO1xyXG4gICAgICAgIHllYXIgPSBwYXJzZUludCh5ZWFyLzEwLCAxMCkgKiAxMDtcclxuICAgICAgICB2YXIgeWVhckNvbnQgPSB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMueWVhcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZCgndGg6ZXEoMSknKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHllYXIgKyAnLScgKyAoeWVhciArIDkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3RkJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgeWVhciAtPSAxO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0aGlzLl95ZWFyc0NyZWF0ZWQgIT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IC0xOyBpIDwgMTE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3Nlcy55ZWFyICsgKGkgPT09IC0xIHx8IGkgPT09IDEwID8gJyBvbGQnIDogJycpKyhjdXJyZW50WWVhciA9PT0geWVhciA/ICcgJyArIGNsYXNzZXMuYWN0aXZlIDogJycpKydcIj4nK3llYXIrJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgeWVhciArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB5ZWFyQ29udC5odG1sKGh0bWwpO1xyXG4gICAgICAgICAgICB0aGlzLl95ZWFyc0NyZWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB5ZWFyU3BhbiA9IHllYXJDb250LmZpbmQoJ3NwYW46Zmlyc3QtY2hpbGQoKScpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAtMTsgaSA8IDExOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJ5ZWFyJysoaSA9PT0gLTEgfHwgaSA9PT0gMTAgPyAnIG9sZCcgOiAnJykrKGN1cnJlbnRZZWFyID09PSB5ZWFyID8gJyAnICsgY2xhc3Nlcy5hY3RpdmUgOiAnJykrJ1wiPicreWVhcisnPC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICB5ZWFyU3BhblxyXG4gICAgICAgICAgICAgICAgLnRleHQoeWVhcilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5ZWFyJyArIChpID09PSAtMSB8fCBpID09PSAxMCA/ICcgb2xkJyA6ICcnKSArIChjdXJyZW50WWVhciA9PT0geWVhciA/ICcgJyArIGNsYXNzZXMuYWN0aXZlIDogJycpKTtcclxuICAgICAgICAgICAgICAgIHllYXIgKz0gMTtcclxuICAgICAgICAgICAgICAgIHllYXJTcGFuID0geWVhclNwYW4ubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgbW92ZURhdGU6IGZ1bmN0aW9uKGRpciwgbW9kZSkge1xyXG4gICAgICAgIC8vIGRpciBjYW4gYmU6ICdwcmV2JywgJ25leHQnXHJcbiAgICAgICAgaWYgKFsncHJldicsICduZXh0J10uaW5kZXhPZihkaXIgJiYgZGlyLnRvTG93ZXJDYXNlKCkpID09IC0xKVxyXG4gICAgICAgICAgICAvLyBObyB2YWxpZCBvcHRpb246XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gZGVmYXVsdCBtb2RlIGlzIHRoZSBjdXJyZW50IG9uZVxyXG4gICAgICAgIG1vZGUgPSBtb2RlIHx8IHRoaXMudmlld01vZGU7XHJcblxyXG4gICAgICAgIHRoaXMudmlld0RhdGVbJ3NldCcrRFBHbG9iYWwubW9kZXNbbW9kZV0ubmF2Rm5jXS5jYWxsKFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdEYXRlLFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdEYXRlWydnZXQnK0RQR2xvYmFsLm1vZGVzW21vZGVdLm5hdkZuY10uY2FsbCh0aGlzLnZpZXdEYXRlKSArIFxyXG4gICAgICAgICAgICBEUEdsb2JhbC5tb2Rlc1ttb2RlXS5uYXZTdGVwICogKGRpciA9PT0gJ3ByZXYnID8gLTEgOiAxKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlclZpZXdEYXRlQ2hhbmdlKCk7XHJcbiAgICAgICAgdGhpcy5zZXQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xpY2s6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjE2LCBtYXhzdGF0ZW1lbnRzOjMwKi9cclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gJChlLnRhcmdldCkuY2xvc2VzdCgnc3Bhbi5tb250aCwgc3Bhbi55ZWFyLCB0ZCwgdGgnKTtcclxuICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB2YXIgbW9udGgsIHllYXI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY29tcGxldGVNb250aFllYXIgPSBmdW5jdGlvbiBjb21wbGV0ZU1vbnRoWWVhcigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudHMuZGF0ZUNoYW5nZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGU6IERQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdLmNsc05hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd01vZGUoLTEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdzd2l0Y2gnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd01vZGUoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdwcmV2JykgfHxcclxuICAgICAgICAgICAgICAgIHRhcmdldC5oYXNDbGFzcygnbmV4dCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlRGF0ZSh0YXJnZXRbMF0uY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQuaGFzQ2xhc3MoY2xhc3Nlcy5tb250aCkpIHtcclxuICAgICAgICAgICAgICAgIG1vbnRoID0gdGFyZ2V0LnBhcmVudCgpLmZpbmQoJ3NwYW4nKS5pbmRleCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3RGF0ZS5zZXRNb250aChtb250aCk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZU1vbnRoWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclZpZXdEYXRlQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0Lmhhc0NsYXNzKGNsYXNzZXMueWVhcikpIHtcclxuICAgICAgICAgICAgICAgIHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdEYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGVNb250aFllYXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJWaWV3RGF0ZUNoYW5nZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC5oYXNDbGFzcyhjbGFzc2VzLm1vbnRoRGF5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXMoJy5kaXNhYmxlZCcpKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF5ID0gcGFyc2VJbnQodGFyZ2V0LnRleHQoKSwgMTApfHwxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gdGhpcy52aWV3RGF0ZS5nZXRNb250aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoICs9IHRhcmdldC5oYXNDbGFzcygnb2xkJykgPyAtMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5oYXNDbGFzcygnbmV3JykgPyAxIDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeWVhciA9IHRoaXMudmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgTWF0aC5taW4oMjgsIGRheSksMCwwLDAsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclZpZXdEYXRlQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50cy5kYXRlQ2hhbmdlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogdGhpcy5kYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZTogRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihlKXtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3dNb2RlOiBmdW5jdGlvbihkaXIpIHtcclxuICAgICAgICBpZiAoZGlyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGUgPSBNYXRoLm1heCh0aGlzLm1pblZpZXdNb2RlLCBNYXRoLm1pbigyLCB0aGlzLnZpZXdNb2RlICsgZGlyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGlja2VyLmZpbmQoJz5kaXYnKS5oaWRlKCkuZmlsdGVyKCcuJyArIGNsYXNzZXMuY29tcG9uZW50ICsgJy0nICsgRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuc2hvdygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuJC5mbi5kYXRlcGlja2VyID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XHJcbiAgICB2YXIgdmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICB2YXIgcmV0dXJuZWQ7XHJcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXHJcbiAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCdkYXRlcGlja2VyJyksXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0JyAmJiBvcHRpb247XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInLCAoZGF0YSA9IG5ldyBEYXRlUGlja2VyKHRoaXMsICQuZXh0ZW5kKHt9LCAkLmZuLmRhdGVwaWNrZXIuZGVmYXVsdHMsb3B0aW9ucykpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuZWQgPSBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgdmFscyk7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIG1ldGhvZD9cclxuICAgICAgICAgICAgaWYgKHR5cGVvZihyZXR1cm5lZCkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHbyBvdXQgdGhlIGxvb3AgdG8gcmV0dXJuIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudC1tZXRob2QgZXhlY3V0aW9uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRm9sbG93IG5leHQgbG9vcCBpdGVtXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mKHJldHVybmVkKSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgcmV0dXJuIHJldHVybmVkO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIC8vIGNoYWluaW5nOlxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzID0ge1xyXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKC8qZGF0ZSovKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59O1xyXG4kLmZuLmRhdGVwaWNrZXIuQ29uc3RydWN0b3IgPSBEYXRlUGlja2VyO1xyXG5cclxuLyoqIFB1YmxpYyBBUEkgKiovXHJcbmV4cG9ydHMuRGF0ZVBpY2tlciA9IERhdGVQaWNrZXI7XHJcbmV4cG9ydHMuZGVmYXVsdHMgPSBEUEdsb2JhbDtcclxuZXhwb3J0cy51dGlscyA9IERQR2xvYmFsO1xyXG4iLCIvKipcclxuICAgIFNtYXJ0TmF2QmFyIGNvbXBvbmVudC5cclxuICAgIFJlcXVpcmVzIGl0cyBDU1MgY291bnRlcnBhcnQuXHJcbiAgICBcclxuICAgIENyZWF0ZWQgYmFzZWQgb24gdGhlIHByb2plY3Q6XHJcbiAgICBcclxuICAgIFByb2plY3QtVHlzb25cclxuICAgIFdlYnNpdGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9jMnByb2RzL1Byb2plY3QtVHlzb25cclxuICAgIEF1dGhvcjogYzJwcm9kc1xyXG4gICAgTGljZW5zZTpcclxuICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gICAgQ29weXJpZ2h0IChjKSAyMDEzIGMycHJvZHNcclxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcclxuICAgIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cclxuICAgIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cclxuICAgIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mXHJcbiAgICB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXHJcbiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG4gICAgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXHJcbiAgICBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1JcclxuICAgIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxyXG4gICAgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cclxuICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbioqL1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5cclxuLyoqXHJcbiAgICBJbnRlcm5hbCB1dGlsaXR5LlxyXG4gICAgUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZm9yIGEgRE9NIG5vZGVcclxuKiovXHJcbnZhciBjbGVhck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgd2hpbGUobm9kZS5maXJzdENoaWxkKXtcclxuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIENhbGN1bGF0ZXMgYW5kIGFwcGxpZXMgdGhlIGJlc3Qgc2l6aW5nIGFuZCBkaXN0cmlidXRpb24gZm9yIHRoZSB0aXRsZVxyXG4gICAgZGVwZW5kaW5nIG9uIGNvbnRlbnQgYW5kIGJ1dHRvbnMuXHJcbiAgICBQYXNzIGluIHRoZSB0aXRsZSBlbGVtZW50LCBidXR0b25zIG11c3QgYmUgZm91bmQgYXMgc2libGluZ3Mgb2YgaXQuXHJcbioqL1xyXG52YXIgdGV4dGJveFJlc2l6ZSA9IGZ1bmN0aW9uIHRleHRib3hSZXNpemUoZWwpIHtcclxuICAgIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyOCwgbWF4Y29tcGxleGl0eToxMSAqL1xyXG4gICAgXHJcbiAgICB2YXIgbGVmdGJ0biA9IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCgnLlNtYXJ0TmF2QmFyLWVkZ2UubGVmdCcpWzBdO1xyXG4gICAgdmFyIHJpZ2h0YnRuID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuU21hcnROYXZCYXItZWRnZS5yaWdodCcpWzBdO1xyXG4gICAgaWYgKHR5cGVvZiBsZWZ0YnRuID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGxlZnRidG4gPSB7XHJcbiAgICAgICAgICAgIG9mZnNldFdpZHRoOiAwLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICcnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcmlnaHRidG4gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmlnaHRidG4gPSB7XHJcbiAgICAgICAgICAgIG9mZnNldFdpZHRoOiAwLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICcnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIG1hcmdpbiA9IE1hdGgubWF4KGxlZnRidG4ub2Zmc2V0V2lkdGgsIHJpZ2h0YnRuLm9mZnNldFdpZHRoKTtcclxuICAgIGVsLnN0eWxlLm1hcmdpbkxlZnQgPSBtYXJnaW4gKyAncHgnO1xyXG4gICAgZWwuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW4gKyAncHgnO1xyXG4gICAgdmFyIHRvb0xvbmcgPSAoZWwub2Zmc2V0V2lkdGggPCBlbC5zY3JvbGxXaWR0aCkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICBpZiAodG9vTG9uZykge1xyXG4gICAgICAgIGlmIChsZWZ0YnRuLm9mZnNldFdpZHRoIDwgcmlnaHRidG4ub2Zmc2V0V2lkdGgpIHtcclxuICAgICAgICAgICAgZWwuc3R5bGUubWFyZ2luTGVmdCA9IGxlZnRidG4ub2Zmc2V0V2lkdGggKyAncHgnO1xyXG4gICAgICAgICAgICBlbC5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gcmlnaHRidG4ub2Zmc2V0V2lkdGggKyAncHgnO1xyXG4gICAgICAgICAgICBlbC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvb0xvbmcgPSAoZWwub2Zmc2V0V2lkdGg8ZWwuc2Nyb2xsV2lkdGgpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgIGlmICh0b29Mb25nKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKCdhcnJvdycpLnRlc3QobGVmdGJ0bi5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUobGVmdGJ0bi5jaGlsZE5vZGVzWzFdKTtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLm1hcmdpbkxlZnQgPSAnMjZweCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoJ2Fycm93JykudGVzdChyaWdodGJ0bi5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUocmlnaHRidG4uY2hpbGROb2Rlc1sxXSk7XHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5tYXJnaW5SaWdodCA9ICcyNnB4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydHMudGV4dGJveFJlc2l6ZSA9IHRleHRib3hSZXNpemU7XHJcblxyXG4vKipcclxuICAgIFNtYXJ0TmF2QmFyIGNsYXNzLCBpbnN0YW50aWF0ZSB3aXRoIGEgRE9NIGVsZW1lbnRcclxuICAgIHJlcHJlc2VudGluZyBhIG5hdmJhci5cclxuICAgIEFQSTpcclxuICAgIC0gcmVmcmVzaDogdXBkYXRlcyB0aGUgY29udHJvbCB0YWtpbmcgY2FyZSBvZiB0aGUgbmVlZGVkXHJcbiAgICAgICAgd2lkdGggZm9yIHRpdGxlIGFuZCBidXR0b25zXHJcbioqL1xyXG52YXIgU21hcnROYXZCYXIgPSBmdW5jdGlvbiBTbWFydE5hdkJhcihlbCkge1xyXG4gICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xyXG4gICAgICAgIHZhciBoID0gJChlbCkuY2hpbGRyZW4oJ2gxJykuZ2V0KDApO1xyXG4gICAgICAgIGlmIChoKVxyXG4gICAgICAgICAgICB0ZXh0Ym94UmVzaXplKGgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJlZnJlc2goKTsgXHJcbn07XHJcblxyXG5leHBvcnRzLlNtYXJ0TmF2QmFyID0gU21hcnROYXZCYXI7XHJcblxyXG4vKipcclxuICAgIEdldCBpbnN0YW5jZXMgZm9yIGFsbCB0aGUgU21hcnROYXZCYXIgZWxlbWVudHMgaW4gdGhlIERPTVxyXG4qKi9cclxuZXhwb3J0cy5nZXRBbGwgPSBmdW5jdGlvbiBnZXRBbGwoKSB7XHJcbiAgICB2YXIgYWxsID0gJCgnLlNtYXJ0TmF2QmFyJyk7XHJcbiAgICByZXR1cm4gJC5tYXAoYWxsLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBuZXcgU21hcnROYXZCYXIoaXRlbSk7IH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBSZWZyZXNoIGFsbCBTbWFydE5hdkJhciBmb3VuZCBpbiB0aGUgZG9jdW1lbnQuXHJcbioqL1xyXG5leHBvcnRzLnJlZnJlc2hBbGwgPSBmdW5jdGlvbiByZWZyZXNoQWxsKCkge1xyXG4gICAgJCgnLlNtYXJ0TmF2QmFyID4gaDEnKS5lYWNoKGZ1bmN0aW9uKCkgeyB0ZXh0Ym94UmVzaXplKHRoaXMpOyB9KTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBDdXN0b20gTG9jb25vbWljcyAnbG9jYWxlJyBzdHlsZXMgZm9yIGRhdGUvdGltZXMuXHJcbiAgICBJdHMgYSBiaXQgbW9yZSAnY29vbCcgcmVuZGVyaW5nIGRhdGVzIDstKVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG4vLyBTaW5jZSB0aGUgdGFzayBvZiBkZWZpbmUgYSBsb2NhbGUgY2hhbmdlc1xyXG4vLyB0aGUgY3VycmVudCBnbG9iYWwgbG9jYWxlLCB3ZSBzYXZlIGEgcmVmZXJlbmNlXHJcbi8vIGFuZCByZXN0b3JlIGl0IGxhdGVyIHNvIG5vdGhpbmcgY2hhbmdlZC5cclxudmFyIGN1cnJlbnQgPSBtb21lbnQubG9jYWxlKCk7XHJcblxyXG5tb21lbnQubG9jYWxlKCdlbi1VUy1MQycsIHtcclxuICAgIG1lcmlkaWVtUGFyc2UgOiAvW2FwXVxcLj9cXC4/L2ksXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3AnIDogJ1AnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2EnIDogJ0EnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXldJyxcclxuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheV0nLFxyXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93XScsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW2xhc3RdIGRkZGQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ00vRCdcclxuICAgIH0sXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVDogJ2g6bW1hJyxcclxuICAgICAgICBMVFM6ICdoOm1tOnNzYScsXHJcbiAgICAgICAgTDogJ01NL0REL1lZWVknLFxyXG4gICAgICAgIGw6ICdNL0QvWVlZWScsXHJcbiAgICAgICAgTEw6ICdNTU1NIERvIFlZWVknLFxyXG4gICAgICAgIGxsOiAnTU1NIEQgWVlZWScsXHJcbiAgICAgICAgTExMOiAnTU1NTSBEbyBZWVlZIExUJyxcclxuICAgICAgICBsbGw6ICdNTU0gRCBZWVlZIExUJyxcclxuICAgICAgICBMTExMOiAnZGRkZCwgTU1NTSBEbyBZWVlZIExUJyxcclxuICAgICAgICBsbGxsOiAnZGRkLCBNTU0gRCBZWVlZIExUJ1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIFJlc3RvcmUgbG9jYWxlXHJcbm1vbWVudC5sb2NhbGUoY3VycmVudCk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG4vLyBpbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uICd0byBzdHJpbmcgd2l0aCB0d28gZGlnaXRzIGFsbW9zdCdcclxuZnVuY3Rpb24gdHdvRGlnaXRzKG4pIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyAxMCkgKyAnJyArIG4gJSAxMDtcclxufVxyXG5cclxuLyoqXHJcbiAgICBTaG93cyBhIHRpbWUgcGlja2VyLCBiYXNlZCBvbiBkaWZmZXJlbnQgZHJvcGRvd25zIGZvciBlYWNoIHRpbWUgcGFydC5cclxuICAgIFN1cHBvcnRzIGhvdXJzIGFuZCBtaW51dGVzICh3aXRoIGFtL3BtIGZvciBVUyBsb2NhbGUpXHJcbiAgICBAcGFyYW0gb3B0aW9uczpPYmplY3Qge1xyXG4gICAgICAgIHRpdGxlOnN0cmluZyBPcHRpb25hbC4gVGhlIHRleHQgdG8gc2hvdyBpbiB0aGUgbW9kYWwncyBoZWFkZXIsXHJcbiAgICAgICAgICAgIHdpdGggZmFsbGJhY2sgdG8gdGhlIE1vZGFsJ3MgZGVmYXVsdCB0aXRsZS5cclxuICAgIH1cclxuICAgIEByZXR1cm5zIFByb21pc2UuIEl0IHJlc29sdmVzIHdoZW4gYSBidXR0b24gaXMgcHJlc3NlZCwgd2l0aCBudWxsIG9uICd1bnNldCdcclxuICAgIGFuZCBhbiBvYmplY3Qgd2l0aCB7IHRpbWU6b2JqZWN0LCB0aW1lU3RyaW5nOnN0cmluZyB9IG9uICdzZWxlY3QnLlxyXG4gICAgVGhlIHRpbWUgb2JqZWN0IGlzIGp1c3QgYSBwbGFpbiBvYmplY3QgYXMgeyBob3VyczogMCwgbWludXRlczogMCwgc2Vjb25kczogMCB9XHJcbiAgICBJcyByZWplY3RlZCB3aGVuIHRoZSBtb2RhbCBpcyBkaXNtaXNzZWQvY2xvc2VkIHdpdGhvdXQgJ3Vuc2V0JyBvciAnc2VsZWN0Jy5cclxuKiovXHJcbmV4cG9ydHMuc2hvdyA9IGZ1bmN0aW9uIHNob3dUaW1lUGlja2VyKG9wdGlvbnMpIHtcclxuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6MTBcclxuXHJcbiAgICB2YXIgbW9kYWwgPSAkKCcjdGltZVBpY2tlck1vZGFsJyksXHJcbiAgICAgICAgdm0gPSBtb2RhbC5kYXRhKCd2aWV3bW9kZWwnKTtcclxuICAgIFxyXG4gICAgaWYgKCF2bSkge1xyXG4gICAgICAgIHZtID0gbmV3IFRpbWVQaWNrZXJNb2RlbCgpO1xyXG5cclxuICAgICAgICBrby5hcHBseUJpbmRpbmdzKHZtLCBtb2RhbC5nZXQoMCkpO1xyXG4gICAgICAgIG1vZGFsLmRhdGEoJ3ZpZXdtb2RlbCcsIHZtKTtcclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIFxyXG4gICAgLy8gRmFsbGJhY2sgdGl0bGVcclxuICAgIHZtLnRpdGxlKG9wdGlvbnMudGl0bGUgfHwgJ1NlbGVjdCB0aW1lJyk7XHJcbiAgICB2bS5zdGVwSW5NaW51dGVzKG9wdGlvbnMuc3RlcEluTWludXRlcyB8fCA1KTtcclxuICAgIGlmICh0eXBlb2Yob3B0aW9ucy5zZWxlY3RlZFRpbWUpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZtLnNlbGVjdGVkVGltZVN0cmluZyhvcHRpb25zLnNlbGVjdGVkVGltZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2bS5zZWxlY3RlZFRpbWUob3B0aW9ucy5zZWxlY3RlZFRpbWUgfHwge30pO1xyXG4gICAgfVxyXG4gICAgdm0udW5zZXRMYWJlbChvcHRpb25zLnVuc2V0TGFiZWwgfHwgJ1JlbW92ZScpO1xyXG4gICAgdm0uc2VsZWN0TGFiZWwob3B0aW9ucy5zZWxlY3RMYWJlbCB8fCAnU2VsZWN0Jyk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBIYW5kbGVyc1xyXG4gICAgICAgIHZhciB1bnNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICBtb2RhbC5tb2RhbCgnaGlkZScpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgIHRpbWU6IHZtLnNlbGVjdGVkVGltZSgpLFxyXG4gICAgICAgICAgICAgICAgdGltZVN0cmluZzogdm0uc2VsZWN0ZWRUaW1lU3RyaW5nKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1vZGFsLm1vZGFsKCdoaWRlJyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSnVzdCBjbG9zZWQgd2l0aG91dCBwaWNrIGFueXRoaW5nLCByZWplY3RzXHJcbiAgICAgICAgbW9kYWwub2ZmKCdoaWRlLmJzLm1vZGFsJyk7XHJcbiAgICAgICAgbW9kYWwub24oJ2hpZGUuYnMubW9kYWwnLCByZWplY3QpO1xyXG4gICAgICAgIG1vZGFsLm9mZignY2xpY2snLCAnLnRpbWVQaWNrZXJNb2RhbC11bnNldCcpO1xyXG4gICAgICAgIG1vZGFsLm9uKCdjbGljaycsICcudGltZVBpY2tlck1vZGFsLXVuc2V0JywgdW5zZXQpO1xyXG4gICAgICAgIG1vZGFsLm9mZignY2xpY2snLCAnLnRpbWVQaWNrZXJNb2RhbC1zZWxlY3QnKTtcclxuICAgICAgICBtb2RhbC5vbignY2xpY2snLCAnLnRpbWVQaWNrZXJNb2RhbC1zZWxlY3QnLCBzZWxlY3QpO1xyXG5cclxuICAgICAgICBtb2RhbC5tb2RhbCgnc2hvdycpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBUaW1lUGlja2VyTW9kZWwoKSB7XHJcbiAgICBcclxuICAgIC8vIFNldC11cCB2aWV3bW9kZWwgYW5kIGJpbmRpbmdcclxuICAgIHZhciB2bSA9IHtcclxuICAgICAgICB0aXRsZToga28ub2JzZXJ2YWJsZSgnJyksXHJcbiAgICAgICAgcGlja2VkSG91cjoga28ub2JzZXJ2YWJsZShudWxsKSxcclxuICAgICAgICBwaWNrZWRNaW51dGU6IGtvLm9ic2VydmFibGUobnVsbCksXHJcbiAgICAgICAgcGlja2VkQW1wbToga28ub2JzZXJ2YWJsZShudWxsKSxcclxuICAgICAgICBzdGVwSW5NaW51dGVzOiBrby5vYnNlcnZhYmxlKDUpLFxyXG4gICAgICAgIHVuc2V0TGFiZWw6IGtvLm9ic2VydmFibGUoJ1JlbW92ZScpLFxyXG4gICAgICAgIHNlbGVjdExhYmVsOiBrby5vYnNlcnZhYmxlKCdTZWxlY3QnKVxyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IE1ha2UgbG9jYWxpemF0aW9uIGNoYW5nZXMgd2l0aCBhbnkgYXBwIGxvY2FsZSBjaGFuZ2UsIHdpdGggdGltZWludGVydmFsLFxyXG4gICAgLy8gYXMgYSBjb21wdXRlZCBvciBjaGFuZ2VkIGJ5IGV2ZW50czpcclxuICAgIHZtLmxvY2FsZSA9IGtvLm9ic2VydmFibGUoeyBsYW5nOiAnZW4nLCByZWdpb246ICdVUycgfSk7XHJcblxyXG4gICAgdm0uaG91clZhbHVlcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZWdpb24gPSB0aGlzLmxvY2FsZSgpLnJlZ2lvbjtcclxuICAgICAgICB2YXIgc3RlcCA9ICh0aGlzLnN0ZXBJbk1pbnV0ZXMoKSAvIDYwKSB8MDtcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IGF2b2lkIGluZmluaXRlIGxvb3BzOlxyXG4gICAgICAgIGlmIChzdGVwIDw9IDApIHN0ZXAgPSAxO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXSxcclxuICAgICAgICAgICAgaTtcclxuICAgICAgICBpZiAocmVnaW9uID09PSAnVVMnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IDEyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgMTI7IGkgKz0gc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICB9LCB2bSk7XHJcbiAgICB2bS5taW51dGVWYWx1ZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAvL3ZhciByZWdpb24gPSB0aGlzLmxvY2FsZSgpLnJlZ2lvbjtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcEluTWludXRlcygpIHwwO1xyXG4gICAgICAgIC8vIElNUE9SVEFOVDogYXZvaWQgaW5maW5pdGUgbG9vcHM6XHJcbiAgICAgICAgaWYgKHN0ZXAgPD0gMCkgc3RlcCA9IDE7XHJcbiAgICAgICAgLy8gTm8gbWludXRlcz9cclxuICAgICAgICBpZiAoc3RlcCA+PSA2MCkgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgLy9pZiAocmVnaW9uID09PSAnVVMnKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2MDsgaSArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBpLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHR3b0RpZ2l0cyhpKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH0sIHZtKTtcclxuICAgIHZtLmFtcG1WYWx1ZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5sb2NhbGUoKS5yZWdpb247XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBpZiAocmVnaW9uID09PSAnVVMnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLCAvLyBhZGRlZCB0byBob3Vyc1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdBTSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAxMiwgLy8gYWRkZWQgdG8gaG91cnNcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnUE0nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfSwgdm0pO1xyXG5cclxuICAgIHZtLnNlbGVjdGVkVGltZSA9IGtvLmNvbXB1dGVkKHtcclxuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGhvdXJzOiB0aGlzLnBpY2tlZEhvdXIoKSArIHRoaXMucGlja2VkQW1wbSgpLFxyXG4gICAgICAgICAgICAgICAgbWludXRlczogdGhpcy5waWNrZWRNaW51dGUoKSxcclxuICAgICAgICAgICAgICAgIHNlY29uZHM6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YodikgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgZm9yIHRoZSB0aW1lIHBpY2tlci4gVmFsdWU6Jywgdik7XHJcbiAgICAgICAgICAgIHYgPSB2IHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gdGhpcy5sb2NhbGUoKS5yZWdpb247XHJcbiAgICAgICAgICAgIGlmIChyZWdpb24gPT09ICdVUycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja2VkSG91cigodi5ob3VycyAvIDEyKSB8MCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tlZE1pbnV0ZSh2Lm1pbnV0ZXMgfDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrZWRBbXBtKCh2LmhvdXJzICUgMTIpIHwwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja2VkSG91cih2LmhvdXJzIHwwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja2VkTWludXRlKHYubWludXRlcyB8MCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tlZEFtcG0oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB2bVxyXG4gICAgfSk7XHJcblxyXG4gICAgdm0uc2VsZWN0ZWRUaW1lU3RyaW5nID0ga28uY29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuc2VsZWN0ZWRUaW1lKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0d29EaWdpdHModC5ob3VycykgKyAnOicgKyB0d29EaWdpdHModC5taW51dGVzKSArICc6JyArIHR3b0RpZ2l0cyh0LnNlY29uZHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgdiA9IHYgfHwgJyc7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHYuc3BsaXQoJzonKTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRpbWUoe1xyXG4gICAgICAgICAgICAgICAgaG91cnM6IHBhcnRzWzBdIHwwLFxyXG4gICAgICAgICAgICAgICAgbWludXRlczogcGFydHNbMV0gfDAsXHJcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiBwYXJ0c1syXSB8MFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB2bVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB2bTtcclxufVxyXG4iLCIvKiogQWRkcmVzcyBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gQWRkcmVzcyh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBhZGRyZXNzSUQ6IDAsXHJcbiAgICAgICAgYWRkcmVzc05hbWU6ICcnLFxyXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXHJcbiAgICAgICAgdXNlcklEOiAwLFxyXG4gICAgICAgIGFkZHJlc3NMaW5lMTogbnVsbCxcclxuICAgICAgICBhZGRyZXNzTGluZTI6IG51bGwsXHJcbiAgICAgICAgcG9zdGFsQ29kZTogbnVsbCxcclxuICAgICAgICBjaXR5OiBudWxsLCAvLyBBdXRvZmlsbGVkIGJ5IHNlcnZlclxyXG4gICAgICAgIHN0YXRlUHJvdmluY2VDb2RlOiBudWxsLCAvLyBBdXRvZmlsbGVkIGJ5IHNlcnZlclxyXG4gICAgICAgIHN0YXRlUHJvdmluY2VOYW1lOiBudWxsLCAvLyBBdXRvZmlsbGVkIGJ5IHNlcnZlclxyXG4gICAgICAgIGNvdW50cnlDb2RlOiBudWxsLCAvLyBJU08gQWxwaGEtMiBjb2RlLCBFeC46ICdVUydcclxuICAgICAgICBsYXRpdHVkZTogbnVsbCxcclxuICAgICAgICBsb25naXR1ZGU6IG51bGwsXHJcbiAgICAgICAgc3BlY2lhbEluc3RydWN0aW9uczogbnVsbCxcclxuICAgICAgICBpc1NlcnZpY2VBcmVhOiBmYWxzZSxcclxuICAgICAgICBpc1NlcnZpY2VMb2NhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgc2VydmljZVJhZGl1czogMCxcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcclxuICAgICAgICBraW5kOiAnJyAvLyBBdXRvZmlsbGVkIGJ5IHNlcnZlclxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zaW5nbGVMaW5lID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxpc3QgPSBbXHJcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzc0xpbmUxKCksXHJcbiAgICAgICAgICAgIHRoaXMuY2l0eSgpLFxyXG4gICAgICAgICAgICB0aGlzLnBvc3RhbENvZGUoKSxcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZVByb3ZpbmNlQ29kZSgpXHJcbiAgICAgICAgXTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24odikgeyByZXR1cm4gISF2OyB9KS5qb2luKCcsICcpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIC8vIFRPRE86IG5lZWRlZD8gbDEwbj8gbXVzdCBiZSBwcm92aWRlZCBieSBzZXJ2ZXIgc2lkZT9cclxuICAgIHZhciBjb3VudHJpZXMgPSB7XHJcbiAgICAgICAgJ1VTJzogJ1VuaXRlZCBTdGF0ZXMnLFxyXG4gICAgICAgICdFUyc6ICdTcGFpbidcclxuICAgIH07XHJcbiAgICB0aGlzLmNvdW50cnlOYW1lID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvdW50cmllc1t0aGlzLmNvdW50cnlDb2RlKCldIHx8ICd1bmtub3cnO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgLy8gVXNlZnVsIEdQUyBvYmplY3Qgd2l0aCB0aGUgZm9ybWF0IHVzZWQgYnkgR29vZ2xlIE1hcHNcclxuICAgIHRoaXMubGF0bG5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGF0OiB0aGlzLmxhdGl0dWRlKCksXHJcbiAgICAgICAgICAgIGxuZzogdGhpcy5sb25naXR1ZGUoKVxyXG4gICAgICAgIH07XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGRyZXNzO1xyXG5cclxuLy8gUHVibGljIEVudW1lcmF0aW9uIGZvciB0aGUgJ2tpbmQnIHByb3BlcnR5OlxyXG5BZGRyZXNzLmtpbmQgPSB7XHJcbiAgICBob21lOiAnaG9tZScsXHJcbiAgICBiaWxsaW5nOiAnYmlsbGluZycsXHJcbiAgICBzZXJ2aWNlOiAnc2VydmljZSdcclxufTtcclxuIiwiLyoqIEFwcG9pbnRtZW50IG1vZGVsICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcclxuICAgIFByaWNpbmdFc3RpbWF0ZURldGFpbCA9IHJlcXVpcmUoJy4vUHJpY2luZ0VzdGltYXRlRGV0YWlsJyksXHJcbiAgICBDYWxlbmRhckV2ZW50ID0gcmVxdWlyZSgnLi9DYWxlbmRhckV2ZW50JyksXHJcbiAgICBCb29raW5nID0gcmVxdWlyZSgnLi9Cb29raW5nJyk7XHJcbiAgIFxyXG5mdW5jdGlvbiBBcHBvaW50bWVudCh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICAvLyBBbiBhcHBvaW50bWVudCBldmVyIHJlZmVyZW5jZXMgYW4gZXZlbnQsIGFuZCBpdHMgJ2lkJyBpcyBhIENhbGVuZGFyRXZlbnRJRFxyXG4gICAgICAgIC8vIGV2ZW4gaWYgb3RoZXIgY29tcGxlbWVudGFyeSBvYmplY3QgYXJlIHVzZWQgYXMgJ3NvdXJjZSdcclxuICAgICAgICBpZDogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBzdGFydFRpbWU6IG51bGwsXHJcbiAgICAgICAgZW5kVGltZTogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb21tb25FdmVudCBmaWVsZHM6XHJcbiAgICAgICAgc3VtbWFyeTogJ05ldyBib29raW5nJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICAvLyBFdmVudCBzcGVjaWZpYyBmaWVsZHM6XHJcbiAgICAgICAgaXNBbGxEYXk6IGZhbHNlLFxyXG5cclxuICAgICAgICAvLyBGaWVsZHMgc3BlY2lmaWMgZm9yIGJvb2tpbmdzXHJcbiAgICAgICAgcHJpY2U6IDAsXHJcbiAgICAgICAgLy8gQWN0dWFsIGJvb2tpbmdzIGZpZWxkcyB0byB1c2Ugb24gcG9zdC9wdXRcclxuICAgICAgICBjdXN0b21lclVzZXJJRDogbnVsbCxcclxuICAgICAgICBwcmljaW5nOiB7XHJcbiAgICAgICAgICAgIE1vZGVsOiBQcmljaW5nRXN0aW1hdGVEZXRhaWwsXHJcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZHJlc3NJRDogbnVsbCxcclxuICAgICAgICBwcmVOb3Rlc1RvQ2xpZW50OiBudWxsLFxyXG4gICAgICAgIHBvc3ROb3Rlc1RvQ2xpZW50OiBudWxsLFxyXG4gICAgICAgIHByZU5vdGVzVG9TZWxmOiBudWxsLFxyXG4gICAgICAgIHBvc3ROb3Rlc1RvU2VsZjogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBqb2JUaXRsZUlEOiAwLFxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcclxuICAgICAgICBcclxuICAgICAgICBzb3VyY2VFdmVudDoge1xyXG4gICAgICAgICAgICBNb2RlbDogQ2FsZW5kYXJFdmVudCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzb3VyY2VCb29raW5nOiB7XHJcbiAgICAgICAgICAgIE1vZGVsOiBCb29raW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9zb3VyY2VCb29raW5nUmVxdWVzdCwgbWF5YmUgZnV0dXJlP1xyXG4gICAgfSwgdmFsdWVzKTtcclxuXHJcbiAgICAvLyBTbWFydCB2aXN1YWxpemF0aW9uIG9mIGRhdGUgYW5kIHRpbWVcclxuICAgIHRoaXMuZGlzcGxheWVkRGF0ZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuc3RhcnRUaW1lKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5jYWxlbmRhcigpO1xyXG4gICAgICAgIFxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuZGlzcGxheWVkU3RhcnRUaW1lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBtb21lbnQodGhpcy5zdGFydFRpbWUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRpc3BsYXllZEVuZFRpbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLmVuZFRpbWUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRpc3BsYXllZFRpbWVSYW5nZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5ZWRTdGFydFRpbWUoKSArICctJyArIHRoaXMuZGlzcGxheWVkRW5kVGltZSgpO1xyXG4gICAgICAgIFxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXRTdGFydGVkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zdGFydFRpbWUoKSAmJiBuZXcgRGF0ZSgpID49IHRoaXMuc3RhcnRUaW1lKCkpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXRFbmRlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW5kVGltZSgpICYmIG5ldyBEYXRlKCkgPj0gdGhpcy5lbmRUaW1lKCkpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNOZXcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICghdGhpcy5pZCgpKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnN0YXRlSGVhZGVyID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XHJcbiAgICAgICAgaWYgKHRoaXMuaWQoKSA+IDAgJiYgdGhpcy5zb3VyY2VFdmVudCgpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VCb29raW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSAnQ2FsZW5kYXIgYmxvY2snO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXRTdGFydGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0RW5kZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnQ29tcGxldGVkJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnTm93JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSAnVXBjb21pbmcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFwcG9pbnRtZW50O1xyXG5cclxuLyoqXHJcbiAgICBDcmVhdGVzIGFuIGFwcG9pbnRtZW50IGluc3RhbmNlIGZyb20gYSBDYWxlbmRhckV2ZW50IG1vZGVsIGluc3RhbmNlXHJcbioqL1xyXG5BcHBvaW50bWVudC5mcm9tQ2FsZW5kYXJFdmVudCA9IGZ1bmN0aW9uIGZyb21DYWxlbmRhckV2ZW50KGV2ZW50KSB7XHJcbiAgICB2YXIgYXB0ID0gbmV3IEFwcG9pbnRtZW50KCk7XHJcbiAgICBcclxuICAgIC8vIEluY2x1ZGUgZXZlbnQgaW4gYXB0XHJcbiAgICBhcHQuaWQoZXZlbnQuY2FsZW5kYXJFdmVudElEKCkpO1xyXG4gICAgYXB0LnN0YXJ0VGltZShldmVudC5zdGFydFRpbWUoKSk7XHJcbiAgICBhcHQuZW5kVGltZShldmVudC5lbmRUaW1lKCkpO1xyXG4gICAgYXB0LnN1bW1hcnkoZXZlbnQuc3VtbWFyeSgpKTtcclxuICAgIGFwdC5kZXNjcmlwdGlvbihldmVudC5kZXNjcmlwdGlvbigpKTtcclxuICAgIGFwdC5pc0FsbERheShldmVudC5pc0FsbERheSgpKTtcclxuICAgIGFwdC5yZWFkT25seShldmVudC5yZWFkT25seSgpKTtcclxuICAgIGFwdC5zb3VyY2VFdmVudChldmVudCk7XHJcbiAgICBcclxuICAgIHJldHVybiBhcHQ7XHJcbn07XHJcblxyXG4vKipcclxuICAgIENyZWF0ZXMgYW4gYXBwb2ludG1lbnQgaW5zdGFuY2UgZnJvbSBhIEJvb2tpbmcgYW5kIGEgQ2FsZW5kYXJFdmVudCBtb2RlbCBpbnN0YW5jZXNcclxuKiovXHJcbkFwcG9pbnRtZW50LmZyb21Cb29raW5nID0gZnVuY3Rpb24gZnJvbUJvb2tpbmcoYm9va2luZywgZXZlbnQpIHtcclxuICAgIC8vIEluY2x1ZGUgZXZlbnQgaW4gYXB0XHJcbiAgICB2YXIgYXB0ID0gQXBwb2ludG1lbnQuZnJvbUNhbGVuZGFyRXZlbnQoZXZlbnQpO1xyXG4gICAgXHJcbiAgICAvLyBJbmNsdWRlIGJvb2tpbmcgaW4gYXB0XHJcbiAgICBhcHQuY3VzdG9tZXJVc2VySUQoYm9va2luZy5ib29raW5nUmVxdWVzdCgpLmN1c3RvbWVyVXNlcklEKCkpO1xyXG4gICAgYXB0LmFkZHJlc3NJRChib29raW5nLmJvb2tpbmdSZXF1ZXN0KCkuYWRkcmVzc0lEKCkpO1xyXG4gICAgYXB0LmpvYlRpdGxlSUQoYm9va2luZy5ib29raW5nUmVxdWVzdCgpLmpvYlRpdGxlSUQoKSk7XHJcbiAgICBhcHQucHJpY2luZyhib29raW5nLmJvb2tpbmdSZXF1ZXN0KCkucHJpY2luZ0VzdGltYXRlKCkuZGV0YWlscygpKTtcclxuICAgIGFwdC5wcmVOb3Rlc1RvQ2xpZW50KGJvb2tpbmcucHJlTm90ZXNUb0NsaWVudCgpKTtcclxuICAgIGFwdC5wb3N0Tm90ZXNUb0NsaWVudChib29raW5nLnBvc3ROb3Rlc1RvQ2xpZW50KCkpO1xyXG4gICAgYXB0LnByZU5vdGVzVG9TZWxmKGJvb2tpbmcucHJlTm90ZXNUb1NlbGYoKSk7XHJcbiAgICBhcHQucG9zdE5vdGVzVG9TZWxmKGJvb2tpbmcucG9zdE5vdGVzVG9TZWxmKCkpO1xyXG4gICAgXHJcbiAgICAvLyBPbiBib29raW5ncywgcmVhZE9ubHkgbXVzdCBzZXQgdG8gZmFsc2UgKGlzIHNlbnQgYXMgdHJ1ZSBldmVyIGZyb21cclxuICAgIC8vIHRoZSBzZXJ2ZXIsIHRvIHByZXZlbnQgZGlyZWN0IG1hbmlwdWxhdGlvbiBvZiB0aGUgZXZlbnQgdGhhdCBpcyBwYXJ0IG9mXHJcbiAgICAvLyBhIGJvb2tpbmdcclxuICAgIGFwdC5yZWFkT25seShmYWxzZSk7XHJcblxyXG4gICAgdmFyIHByaWNlcyA9IGJvb2tpbmcuYm9va2luZ1JlcXVlc3QoKSAmJiBib29raW5nLmJvb2tpbmdSZXF1ZXN0KCkucHJpY2luZ0VzdGltYXRlKCk7XHJcbiAgICBpZiAocHJpY2VzKSB7XHJcbiAgICAgICAgLy8gVE9ETyBTZXR0aW5nIGZyZWVsYW5jZXIgcHJpY2UsIGZvciBjdXN0b21lcnMgbXVzdCBiZVxyXG4gICAgICAgIC8vIGp1c3QgdG90YWxQcmljZSgpXHJcbiAgICAgICAgYXB0LnByaWNlKHByaWNlcy50b3RhbFByaWNlKCkgLSBwcmljZXMucEZlZVByaWNlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGFwdC5zb3VyY2VCb29raW5nKGJvb2tpbmcpO1xyXG5cclxuICAgIHJldHVybiBhcHQ7XHJcbn07XHJcblxyXG4vKipcclxuICAgIENyZWF0ZXMgYSBsaXN0IG9mIGFwcG9pbnRtZW50IGluc3RhbmNlcyBmcm9tIHRoZSBsaXN0IG9mIGV2ZW50cyBhbmQgYm9va2luZ3MuXHJcbiAgICBUaGUgYm9va2luZ3MgbGlzdCBtdXN0IGNvbnRhaW4gZXZlcnkgYm9va2luZyB0aGF0IGJlbG9uZ3MgdG8gdGhlIGV2ZW50cyBvZiB0eXBlXHJcbiAgICAnYm9va2luZycgZnJvbSB0aGUgbGlzdCBvZiBldmVudHMuXHJcbioqL1xyXG5BcHBvaW50bWVudC5saXN0RnJvbUNhbGVuZGFyRXZlbnRzQm9va2luZ3MgPSBmdW5jdGlvbiBsaXN0RnJvbUNhbGVuZGFyRXZlbnRzQm9va2luZ3MoZXZlbnRzLCBib29raW5ncykge1xyXG4gICAgcmV0dXJuIGV2ZW50cy5tYXAoZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICB2YXIgYm9va2luZyA9IG51bGw7XHJcbiAgICAgICAgYm9va2luZ3Muc29tZShmdW5jdGlvbihzZWFyY2hCb29raW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHNlYXJjaEJvb2tpbmcuY29uZmlybWVkRGF0ZUlEKCkgPT09IGV2ZW50LmNhbGVuZGFyRXZlbnRJRCgpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGJvb2tpbmcgPSBzZWFyY2hCb29raW5nO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGJvb2tpbmcpXHJcbiAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tQm9va2luZyhib29raW5nLCBldmVudCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gQXBwb2ludG1lbnQuZnJvbUNhbGVuZGFyRXZlbnQoZXZlbnQpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5BcHBvaW50bWVudC5zcGVjaWFsSWRzID0ge1xyXG4gICAgbG9hZGluZzogMCxcclxuICAgIGVtcHR5RGF0ZTogLTEsXHJcbiAgICBmcmVlOiAtMixcclxuICAgIG5ld0V2ZW50OiAtMyxcclxuICAgIG5ld0Jvb2tpbmc6IC00LFxyXG4gICAgdW5hdmFpbGFibGU6IC01LFxyXG4gICAgcHJlcGFyYXRpb25UaW1lOiAtNlxyXG59O1xyXG5cclxudmFyIFRpbWUgPSByZXF1aXJlKCcuLi91dGlscy9UaW1lJyk7XHJcbi8qKlxyXG4gICAgQ3JlYXRlcyBhbiBBcHBvaW50bWVudCBpbnN0YW5jZSB0aGF0IHJlcHJlc2VudHMgYSBjYWxlbmRhciBzbG90IG9mXHJcbiAgICBmcmVlL3NwYXJlIHRpbWUsIGZvciB0aGUgZ2l2ZW4gdGltZSByYW5nZSwgb3IgdGhlIGZ1bGwgZ2l2ZW4gZGF0ZS5cclxuICAgIEBwYXJhbSBvcHRpb25zOk9iamVjdCB7XHJcbiAgICAgICAgZGF0ZTpEYXRlLiBPcHRpb25hbC4gVXNlZCB0byBjcmVhdGUgYSBmdWxsIGRhdGUgc2xvdCBvciBkZWZhdWx0IGZvciBzdGFydC9lbmRcclxuICAgICAgICAgICAgdG8gZGF0ZSBzdGFydCBvciBkYXRlIGVuZFxyXG4gICAgICAgIHN0YXJ0OkRhdGUuIE9wdGlvbmFsLiBCZWdnaW5pbmcgb2YgdGhlIHNsb3RcclxuICAgICAgICBlbmQ6RGF0ZS4gT3B0aW9uYWwuIEVuZGluZyBvZiB0aGUgc2xvdFxyXG4gICAgICAgIHRleHQ6c3RyaW5nLiBPcHRpb25hbCBbJ0ZyZWUnXS4gVG8gYWxsb3cgZXh0ZXJuYWwgbG9jYWxpemF0aW9uIG9mIHRoZSB0ZXh0LlxyXG4gICAgfVxyXG4qKi9cclxuQXBwb2ludG1lbnQubmV3RnJlZVNsb3QgPSBmdW5jdGlvbiBuZXdGcmVlU2xvdChvcHRpb25zKSB7XHJcbiAgICBcclxuICAgIHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgbmV3IFRpbWUob3B0aW9ucy5kYXRlLCAwLCAwLCAwKSxcclxuICAgICAgICBlbmQgPSBvcHRpb25zLmVuZCB8fCBuZXcgVGltZShvcHRpb25zLmRhdGUsIDAsIDAsIDApO1xyXG5cclxuICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgIGlkOiBBcHBvaW50bWVudC5zcGVjaWFsSWRzLmZyZWUsXHJcblxyXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnQsXHJcbiAgICAgICAgZW5kVGltZTogZW5kLFxyXG5cclxuICAgICAgICBzdW1tYXJ5OiBvcHRpb25zLnRleHQgfHwgJ0ZyZWUnLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsXHJcbiAgICB9KTtcclxufTtcclxuXHJcbkFwcG9pbnRtZW50Lm5ld1VuYXZhaWxhYmxlU2xvdCA9IGZ1bmN0aW9uIG5ld1VuYXZhaWxhYmxlU2xvdChvcHRpb25zKSB7XHJcbiAgICBcclxuICAgIHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgbmV3IFRpbWUob3B0aW9ucy5kYXRlLCAwLCAwLCAwKSxcclxuICAgICAgICBlbmQgPSBvcHRpb25zLmVuZCB8fCBuZXcgVGltZShvcHRpb25zLmRhdGUsIDAsIDAsIDApO1xyXG5cclxuICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgIGlkOiBBcHBvaW50bWVudC5zcGVjaWFsSWRzLnVuYXZhaWxhYmxlLFxyXG5cclxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0LFxyXG4gICAgICAgIGVuZFRpbWU6IGVuZCxcclxuXHJcbiAgICAgICAgc3VtbWFyeTogb3B0aW9ucy50ZXh0IHx8ICdVbmF2YWlsYWJsZScsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGxcclxuICAgIH0pO1xyXG59O1xyXG5cclxuQXBwb2ludG1lbnQubmV3UHJlcGFyYXRpb25UaW1lU2xvdCA9IGZ1bmN0aW9uIG5ld1ByZXBhcmF0aW9uVGltZVNsb3Qob3B0aW9ucykge1xyXG5cclxuICAgIHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgbmV3IFRpbWUob3B0aW9ucy5kYXRlLCAwLCAwLCAwKSxcclxuICAgICAgICBlbmQgPSBvcHRpb25zLmVuZCB8fCBuZXcgVGltZShvcHRpb25zLmRhdGUsIDAsIDAsIDApO1xyXG5cclxuICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xyXG4gICAgICAgIGlkOiBBcHBvaW50bWVudC5zcGVjaWFsSWRzLnByZXBhcmF0aW9uVGltZSxcclxuXHJcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydCxcclxuICAgICAgICBlbmRUaW1lOiBlbmQsXHJcblxyXG4gICAgICAgIHN1bW1hcnk6IG9wdGlvbnMudGV4dCB8fCAnUHJlcGFyYXRpb24gdGltZScsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGxcclxuICAgIH0pO1xyXG59OyIsIi8qKiBCb29raW5nIG1vZGVsLlxyXG5cclxuICAgIERlc2NyaWJlcyBhIGJvb2tpbmcgd2l0aCByZWxhdGVkIEJvb2tpbmdSZXF1ZXN0IFxyXG4gICAgYW5kIFByaWNpbmdFc3RpbWF0ZSBvYmplY3RzLlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIEJvb2tpbmdSZXF1ZXN0ID0gcmVxdWlyZSgnLi9Cb29raW5nUmVxdWVzdCcpO1xyXG5cclxuZnVuY3Rpb24gQm9va2luZyh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBib29raW5nSUQ6IDAsXHJcbiAgICAgICAgYm9va2luZ1JlcXVlc3RJRDogMCxcclxuICAgICAgICBjb25maXJtZWREYXRlSUQ6IG51bGwsXHJcbiAgICAgICAgdG90YWxQcmljZVBhaWRCeUN1c3RvbWVyOiBudWxsLFxyXG4gICAgICAgIHRvdGFsU2VydmljZUZlZXNQYWlkQnlDdXN0b21lcjogbnVsbCxcclxuICAgICAgICB0b3RhbFBhaWRUb0ZyZWVsYW5jZXI6IG51bGwsXHJcbiAgICAgICAgdG90YWxTZXJ2aWNlRmVlc1BhaWRCeUZyZWVsYW5jZXI6IG51bGwsXHJcbiAgICAgICAgYm9va2luZ1N0YXR1c0lEOiBudWxsLFxyXG4gICAgICAgIHByaWNpbmdBZGp1c3RtZW50QXBwbGllZDogZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJlTm90ZXNUb0NsaWVudDogbnVsbCxcclxuICAgICAgICBwb3N0Tm90ZXNUb0NsaWVudDogbnVsbCxcclxuICAgICAgICBwcmVOb3Rlc1RvU2VsZjogbnVsbCxcclxuICAgICAgICBwb3N0Tm90ZXNUb1NlbGY6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV2aWV3ZWRCeUZyZWVsYW5jZXI6IGZhbHNlLFxyXG4gICAgICAgIHJldmlld2VkQnlDdXN0b21lcjogZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgYm9va2luZ1JlcXVlc3Q6IG5ldyBCb29raW5nUmVxdWVzdCgpXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvb2tpbmc7XHJcbiIsIi8qKlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgUHJpY2luZ0VzdGltYXRlID0gcmVxdWlyZSgnLi9QcmljaW5nRXN0aW1hdGUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQm9va2luZ1JlcXVlc3QodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgYm9va2luZ1JlcXVlc3RJRDogMCxcclxuICAgICAgICBib29raW5nVHlwZUlEOiAwLFxyXG4gICAgICAgIGN1c3RvbWVyVXNlcklEOiAwLFxyXG4gICAgICAgIGZyZWVsYW5jZXJVc2VySUQ6IDAsXHJcbiAgICAgICAgam9iVGl0bGVJRDogMCxcclxuICAgICAgICBwcmljaW5nRXN0aW1hdGVJRDogMCxcclxuICAgICAgICBib29raW5nUmVxdWVzdFN0YXR1c0lEOiAwLFxyXG4gICAgICAgIFxyXG4gICAgICAgIHNwZWNpYWxSZXF1ZXN0czogbnVsbCxcclxuICAgICAgICBwcmVmZXJyZWREYXRlSUQ6IG51bGwsXHJcbiAgICAgICAgYWx0ZXJuYXRpdmVEYXRlMUlEOiBudWxsLFxyXG4gICAgICAgIGFsdGVybmF0aXZlRGF0ZTJJRDogbnVsbCxcclxuICAgICAgICBhZGRyZXNzSUQ6IG51bGwsXHJcbiAgICAgICAgY2FuY2VsbGF0aW9uUG9saWN5SUQ6IG51bGwsXHJcbiAgICAgICAgaW5zdGFudEJvb2tpbmc6IGZhbHNlLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIHByaWNpbmdFc3RpbWF0ZTogbmV3IFByaWNpbmdFc3RpbWF0ZSgpXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59O1xyXG4iLCIvKiogQm9va2luZ1N1bW1hcnkgbW9kZWwgKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG4gICAgXHJcbmZ1bmN0aW9uIEJvb2tpbmdTdW1tYXJ5KHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIHF1YW50aXR5OiAwLFxyXG4gICAgICAgIGNvbmNlcHQ6ICcnLFxyXG4gICAgICAgIHRpbWU6IG51bGwsXHJcbiAgICAgICAgdGltZUZvcm1hdDogJyBbQF0gaDptbWEnXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG5cclxuICAgIHRoaXMucGhyYXNlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRpbWVGb3JtYXQoKSAmJiBcclxuICAgICAgICAgICAgdGhpcy50aW1lKCkgJiYgXHJcbiAgICAgICAgICAgIG1vbWVudCh0aGlzLnRpbWUoKSkuZm9ybWF0KHRoaXMudGltZUZvcm1hdCgpKSB8fFxyXG4gICAgICAgICAgICAnJzsgICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNlcHQoKSArIHQ7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLnVybCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdXJsID0gdGhpcy50aW1lKCkgJiZcclxuICAgICAgICAgICAgJy9jYWxlbmRhci8nICsgdGhpcy50aW1lKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfSwgdGhpcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm9va2luZ1N1bW1hcnk7XHJcbiIsIi8qKlxyXG4gICAgRXZlbnQgbW9kZWxcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qIEV4YW1wbGUgSlNPTiAocmV0dXJuZWQgYnkgdGhlIFJFU1QgQVBJKTpcclxue1xyXG4gIFwiRXZlbnRJRFwiOiAzNTMsXHJcbiAgXCJVc2VySURcIjogMTQxLFxyXG4gIFwiRXZlbnRUeXBlSURcIjogMyxcclxuICBcIlN1bW1hcnlcIjogXCJIb3VzZWtlZXBlciBzZXJ2aWNlcyBmb3IgSm9obiBELlwiLFxyXG4gIFwiQXZhaWxhYmlsaXR5VHlwZUlEXCI6IDMsXHJcbiAgXCJTdGFydFRpbWVcIjogXCIyMDE0LTAzLTI1VDA4OjAwOjAwWlwiLFxyXG4gIFwiRW5kVGltZVwiOiBcIjIwMTQtMDMtMjVUMTg6MDA6MDBaXCIsXHJcbiAgXCJLaW5kXCI6IDAsXHJcbiAgXCJJc0FsbERheVwiOiBmYWxzZSxcclxuICBcIlRpbWVab25lXCI6IFwiMDE6MDA6MDBcIixcclxuICBcIkxvY2F0aW9uXCI6IFwibnVsbFwiLFxyXG4gIFwiVXBkYXRlZERhdGVcIjogXCIyMDE0LTEwLTMwVDE1OjQ0OjQ5LjY1M1wiLFxyXG4gIFwiQ3JlYXRlZERhdGVcIjogbnVsbCxcclxuICBcIkRlc2NyaXB0aW9uXCI6IFwidGVzdCBkZXNjcmlwdGlvbiBvZiBhIFJFU1QgZXZlbnRcIixcclxuICBcIlJlY3VycmVuY2VSdWxlXCI6IHtcclxuICAgIFwiRnJlcXVlbmN5VHlwZUlEXCI6IDUwMixcclxuICAgIFwiSW50ZXJ2YWxcIjogMSxcclxuICAgIFwiVW50aWxcIjogXCIyMDE0LTA3LTAxVDAwOjAwOjAwXCIsXHJcbiAgICBcIkNvdW50XCI6IG51bGwsXHJcbiAgICBcIkVuZGluZ1wiOiBcImRhdGVcIixcclxuICAgIFwiU2VsZWN0ZWRXZWVrRGF5c1wiOiBbXHJcbiAgICAgIDEsXHJcbiAgICBdLFxyXG4gICAgXCJNb250aGx5V2Vla0RheVwiOiBmYWxzZSxcclxuICAgIFwiSW5jb21wYXRpYmxlXCI6IGZhbHNlLFxyXG4gICAgXCJUb29NYW55XCI6IGZhbHNlXHJcbiAgfSxcclxuICBcIlJlY3VycmVuY2VPY2N1cnJlbmNlc1wiOiBudWxsLFxyXG4gIFwiUmVhZE9ubHlcIjogZmFsc2VcclxufSovXHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG5mdW5jdGlvbiBSZWN1cnJlbmNlUnVsZSh2YWx1ZXMpIHtcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGZyZXF1ZW5jeVR5cGVJRDogMCxcclxuICAgICAgICBpbnRlcnZhbDogMSwgLy86SW50ZWdlclxyXG4gICAgICAgIHVudGlsOiBudWxsLCAvLzpEYXRlXHJcbiAgICAgICAgY291bnQ6IG51bGwsIC8vOkludGVnZXJcclxuICAgICAgICBlbmRpbmc6IG51bGwsIC8vIDpzdHJpbmcgUG9zc2libGUgdmFsdWVzIGFsbG93ZWQ6ICduZXZlcicsICdkYXRlJywgJ29jdXJyZW5jZXMnXHJcbiAgICAgICAgc2VsZWN0ZWRXZWVrRGF5czogW10sIC8vIDppbnRlZ2VyW10gMDpTdW5kYXlcclxuICAgICAgICBtb250aGx5V2Vla0RheTogZmFsc2UsXHJcbiAgICAgICAgaW5jb21wYXRpYmxlOiBmYWxzZSxcclxuICAgICAgICB0b29NYW55OiBmYWxzZVxyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gUmVjdXJyZW5jZU9jY3VycmVuY2UodmFsdWVzKSB7XHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBzdGFydFRpbWU6IG51bGwsIC8vOkRhdGVcclxuICAgICAgICBlbmRUaW1lOiBudWxsIC8vOkRhdGVcclxuICAgIH0sIHZhbHVlcyk7XHJcbn1cclxuICAgXHJcbmZ1bmN0aW9uIENhbGVuZGFyRXZlbnQodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICAvLyBTcGVjaWFsIHZhbHVlczogZGF0ZXMgbXVzdCBiZSBjb252ZXJ0ZWRcclxuICAgIC8vIHRvIGEgRGF0ZSBvYmplY3QuIFRoZXkgY29tZSBhcyBJU08gc3RyaW5nXHJcbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgc29tZXRoaW5nIGdlbmVyaWMsIG9yIGV2ZW4gaW4gTW9kZWwgZGVmaW5pdGlvbnMsXHJcbiAgICAvLyBhbmQgdXNlIGZvciB1cGRhdGVkL2NyZWF0ZWREYXRlIGFyb3VuZCBhbGwgdGhlIHByb2plY3RcclxuICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICB2YWx1ZXMuc3RhcnRUaW1lID0gdmFsdWVzLnN0YXJ0VGltZSAmJiBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlcy5zdGFydFRpbWUpKSB8fCBudWxsO1xyXG4gICAgICAgIHZhbHVlcy5lbmRUaW1lID0gdmFsdWVzLmVuZFRpbWUgJiYgbmV3IERhdGUoRGF0ZS5wYXJzZSh2YWx1ZXMuZW5kVGltZSkpIHx8IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBjYWxlbmRhckV2ZW50SUQ6IDAsXHJcbiAgICAgICAgdXNlcklEOiAwLFxyXG4gICAgICAgIGV2ZW50VHlwZUlEOiAzLFxyXG4gICAgICAgIHN1bW1hcnk6ICcnLFxyXG4gICAgICAgIGF2YWlsYWJpbGl0eVR5cGVJRDogMCxcclxuICAgICAgICBzdGFydFRpbWU6IG51bGwsXHJcbiAgICAgICAgZW5kVGltZTogbnVsbCxcclxuICAgICAgICBraW5kOiAwLFxyXG4gICAgICAgIGlzQWxsRGF5OiBmYWxzZSxcclxuICAgICAgICB0aW1lWm9uZTogJ1onLFxyXG4gICAgICAgIGxvY2F0aW9uOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcclxuICAgICAgICByZWFkT25seTogZmFsc2UsXHJcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGU6IHtcclxuICAgICAgICAgICAgTW9kZWw6IFJlY3VycmVuY2VSdWxlXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWN1cnJlbmNlT2NjdXJyZW5jZXM6IHtcclxuICAgICAgICAgICAgaXNBcnJheTogdHJ1ZSxcclxuICAgICAgICAgICAgTW9kZWw6IFJlY3VycmVuY2VPY2N1cnJlbmNlXHJcbiAgICAgICAgfVxyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDYWxlbmRhckV2ZW50O1xyXG5cclxuQ2FsZW5kYXJFdmVudC5SZWN1cnJlbmNlUnVsZSA9IFJlY3VycmVuY2VSdWxlO1xyXG5DYWxlbmRhckV2ZW50LlJlY3VycmVuY2VPY2N1cnJlbmNlID0gUmVjdXJyZW5jZU9jY3VycmVuY2U7XHJcbiIsIi8qKlxyXG4gICAgQ2FsZW5kYXJTeW5jaW5nIG1vZGVsLlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIENhbGVuZGFyU3luY2luZyh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGljYWxFeHBvcnRVcmw6ICcnLFxyXG4gICAgICAgIGljYWxJbXBvcnRVcmw6ICcnXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbGVuZGFyU3luY2luZztcclxuIiwiLyoqIEN1c3RvbWVyIG1vZGVsICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG5mdW5jdGlvbiBDdXN0b21lcih2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgY3VzdG9tZXJVc2VySUQ6IDAsXHJcbiAgICAgICAgXHJcbiAgICAgICAgZmlyc3ROYW1lOiAnJyxcclxuICAgICAgICBsYXN0TmFtZTogJycsXHJcbiAgICAgICAgc2Vjb25kTGFzdE5hbWU6ICcnLFxyXG4gICAgICAgIGVtYWlsOiAnJyxcclxuICAgICAgICBwaG9uZTogbnVsbCxcclxuICAgICAgICBjYW5SZWNlaXZlU21zOiBmYWxzZSxcclxuICAgICAgICBiaXJ0aE1vbnRoRGF5OiBudWxsLFxyXG4gICAgICAgIGJpcnRoTW9udGg6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgbm90ZXNBYm91dEN1c3RvbWVyOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIGVkaXRhYmxlOiBmYWxzZVxyXG4gICAgfSwgdmFsdWVzKTtcclxuXHJcbiAgICB0aGlzLmZ1bGxOYW1lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuZmlyc3ROYW1lKCkgfHwgJycpICsgJyAnICsgKHRoaXMubGFzdE5hbWUoKSB8fCAnJykpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuYmlydGhEYXkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmlydGhNb250aERheSgpICYmXHJcbiAgICAgICAgICAgIHRoaXMuYmlydGhNb250aCgpKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBUT0RPIGkxMG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmlydGhNb250aCgpICsgJy8nICsgdGhpcy5iaXJ0aE1vbnRoRGF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDdXN0b21lcjtcclxuIiwiLyoqXHJcbiAgICBLZWVwcyBhIGRhdGUgYXZhaWxhYmlsaXR5IG9iamVjdCB0aGF0IGluY2x1ZGVzIGEgbGlzdCBvZiBhcHBvaW50bWVudHNcclxuICAgIHRoYXQgZmlsbHMgYWxsIHRoZSB0aW1lcyBpbiB0aGUgZGF0ZSAoZm9sbG93aW5nIHRoZSB3ZWVrRGF5U2NoZWR1bGUgYW5kIGZyZWUvdW5hdmFpbGFibGVcclxuICAgIHRpbWVzKSBhbmQgc3VtbWFyeSBvZiB0aGUgYXZhaWxhYmlsaXR5IHN0YXR1cyBvZiB0aGUgZGF0ZS5cclxuICAgIFVwZGF0aW5nIHRoZSBtYWluIHByb3BlcnRpZXM6IGFwcG9pbnRtZW50c0xpc3QsIGRhdGUsIHdlZWtEYXlTY2hlZHVsZSwgdGhlIGNvbXBsZXRlXHJcbiAgICBsaXN0IGFuZCBzdW1tYXJpZXMgYXV0byBjYWxjdWxhdGUgdG8gc2hvdyB0aGUgcHJvcGVyIGxpc3RpbmcuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvTW9kZWwnKTtcclxudmFyIEFwcG9pbnRtZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FwcG9pbnRtZW50JyksXHJcbiAgICBXZWVrRGF5U2NoZWR1bGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvV2Vla0RheVNjaGVkdWxlJyksXHJcbiAgICBTY2hlZHVsaW5nUHJlZmVyZW5jZXMgPSByZXF1aXJlKCcuLi9tb2RlbHMvU2NoZWR1bGluZ1ByZWZlcmVuY2VzJyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIGF2YWlsYWJpbGl0eUNhbGN1bGF0aW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvYXZhaWxhYmlsaXR5Q2FsY3VsYXRpb24nKSxcclxuICAgIGdldERhdGVXaXRob3V0VGltZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldERhdGVXaXRob3V0VGltZScpO1xyXG5cclxuZnVuY3Rpb24gRGF0ZUF2YWlsYWJpbGl0eSh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBkYXRlOiBudWxsLCAvLyBEYXRlXHJcbiAgICAgICAgd2Vla0RheVNjaGVkdWxlOiB7XHJcbiAgICAgICAgICAgIE1vZGVsOiBXZWVrRGF5U2NoZWR1bGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFwcG9pbnRtZW50c0xpc3Q6IHtcclxuICAgICAgICAgICAgaXNBcnJheTogdHJ1ZSxcclxuICAgICAgICAgICAgTW9kZWw6IEFwcG9pbnRtZW50XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2hlZHVsaW5nUHJlZmVyZW5jZXM6IHtcclxuICAgICAgICAgICAgTW9kZWw6IFNjaGVkdWxpbmdQcmVmZXJlbmNlc1xyXG4gICAgICAgIH1cclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIDphcnJheTxBcHBvaW50bWVudD4gTGlzdCBvZiBhcHBvaW50bWVudHMgZm9yIGFsbCB0aGUgdGltZXMgaW4gdGhlIGRhdGUuXHJcbiAgICAgICAgSXQgaW50cm9kdWNlcyBmcmVlIGFuZCB1bmF2YWlsYWJsZSBhcHBvaW50bWVudHMgdXNpbmcgYXBwb2ludG1lbnRzTGlzdCBhcyBiYXNlXHJcbiAgICAgICAgZm9yIGFjdHVhbCAqYnVzeSogYXBwb2ludG1lbnRzIGFuZCB0aGUgcnVsZXMgb2Ygd2Vla0RheVNjaGVkdWxlXHJcbiAgICAqKi9cclxuICAgIHRoaXMubGlzdCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gYXZhaWxhYmlsaXR5Q2FsY3VsYXRpb24uZmlsbERheUF2YWlsYWJpbGl0eShcclxuICAgICAgICAgICAgdGhpcy5kYXRlKCksIHRoaXMuYXBwb2ludG1lbnRzTGlzdCgpLCB0aGlzLndlZWtEYXlTY2hlZHVsZSgpLCB0aGlzLnNjaGVkdWxpbmdQcmVmZXJlbmNlcygpXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIDppbnRcclxuICAgICAgICBOdW1iZXIgb2YgbWludXRlcyBzY2hlZHVsZWQgZm9yIHdvcmsgaW4gYSBnZW5lcmljL2VtcHR5IGRheVxyXG4gICAgICAgIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBhdCB3ZWVrRGF5U2NoZWR1bGUuXHJcbiAgICAqKi9cclxuICAgIHRoaXMud29ya0RheU1pbnV0ZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNjaGVkdWxlID0gdGhpcy53ZWVrRGF5U2NoZWR1bGUoKTtcclxuICAgICAgICAvLyBmcm9tLXRvIGFyZSBtaW51dGVzIG9mIHRoZSBkYXksIHNvIGl0cyBlYXN5IHRvIGNhbGN1bGF0ZVxyXG4gICAgICAgIHJldHVybiAoc2NoZWR1bGUudG8oKSAtIHNjaGVkdWxlLmZyb20oKSkgfDA7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICA6aW50XHJcbiAgICAgICAgTnVtYmVyIG9mIG1pbnV0ZXMgYXZhaWxhYmxlIHRvIGJlIHNjaGVkdWxlZCBpbiB0aGlzIGRhdGVcclxuICAgICAgICBpbnNpZGUgdGhlIHdvcmsgdGltZSAod2Vla0RheVNjaGVkdWxlLlxyXG4gICAgICAgIEl0J3MgdGhlIHN1bSBvZiBhbGwgJ0ZyZWUnIGFwcG9pbnRtZW50cyBpbiB0aGUgZGF0ZS5cclxuICAgICoqL1xyXG4gICAgdGhpcy5hdmFpbGFibGVNaW51dGVzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QoKS5yZWR1Y2UoZnVuY3Rpb24obWludXRlcywgYXB0KSB7XHJcbiAgICAgICAgICAgIGlmIChhcHQuaWQoKSA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy5mcmVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXQgPSBtb21lbnQoYXB0LmVuZFRpbWUoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgc3QgPSBtb21lbnQoYXB0LnN0YXJ0VGltZSgpKTtcclxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgKz0gZXQuZGlmZihzdCwgJ21pbnV0ZXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWludXRlcztcclxuICAgICAgICB9LCAwKTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIDppbnRcclxuICAgICAgICBQZXJjZW50YWdlIG51bWJlciBmcm9tIDAgdG8gMTAwIG9mIHRpbWVcclxuICAgICAgICBhdmFpbGFibGUgdGltZSBpbiB0aGUgZGF0ZSAoYXZhaWxhYmxlTWludXRlcyAvIHdvcmtEYXlNaW51dGVzKVxyXG4gICAgKiovXHJcbiAgICB0aGlzLmF2YWlsYWJsZVBlcmNlbnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKCh0aGlzLmF2YWlsYWJsZU1pbnV0ZXMoKSAvIHRoaXMud29ya0RheU1pbnV0ZXMoKSkgKiAxMDApKTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIDpzdHJpbmdcclxuICAgICAgICBBIHRleHQgdmFsdWUgZnJvbSBhbiBlbnVtZXJhdGlvbiB0aGF0IHJlcHJlc2VudHNcclxuICAgICAgICAgICAgcmFuZ2VzIG9mIGF2YWlsYWJsZVBlcmNlbnQsIHN1aXRhYmxlIGZvciBoaWdoIGxldmVsIHVzZSBhcyBDU1MgY2xhc3Nlcy5cclxuICAgICAgICAgICAgU3BlY2lhbCBjYXNlIG9uIHBhc3QgZGF0ZS10aW1lLCB3aGVuIGl0IHJldHVybnMgJ3Bhc3QnIHJhdGhlciB0aGFuIHRoZVxyXG4gICAgICAgICAgICBhdmFpbGFiaWxpdHksIHNpbmNlIHBhc3QgdGltZXMgYXJlIG5vdCBhdmFpbGFiaWxlIGZvciBhbnl0aGluZyBuZXcgKGNhbid0IGNoYW5nZSB0aGUgcGFzdCEgOy0pXHJcbiAgICAgICAgICAgIENhbiBiZTogJ25vbmUnLCAnbG93JywgJ21lZGl1bScsICdmdWxsJywgJ3Bhc3QnXHJcbiAgICAqKi9cclxuICAgIHRoaXMuYXZhaWxhYmxlVGFnID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwZXJjID0gdGhpcy5hdmFpbGFibGVQZXJjZW50KCksXHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmRhdGUoKSxcclxuICAgICAgICAgICAgdG9kYXkgPSBnZXREYXRlV2l0aG91dFRpbWUoKTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGUgPCB0b2RheSlcclxuICAgICAgICAgICAgcmV0dXJuICdwYXN0JztcclxuICAgICAgICBlbHNlIGlmIChwZXJjID49IDEwMClcclxuICAgICAgICAgICAgcmV0dXJuICdmdWxsJztcclxuICAgICAgICBlbHNlIGlmIChwZXJjID49IDUwKVxyXG4gICAgICAgICAgICByZXR1cm4gJ21lZGl1bSc7XHJcbiAgICAgICAgZWxzZSBpZiAocGVyYyA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiAnbG93JztcclxuICAgICAgICBlbHNlIC8vIDw9IDBcclxuICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBSZXRyaWV2ZSBhIGxpc3Qgb2YgZGF0ZS10aW1lcyB0aGF0IGFyZSBmcmVlLCBhdmFpbGFibGUgdG8gYmUgdXNlZCxcclxuICAgICAgICBpbiB0aGlzIGRhdGUgd2l0aCBhIHNlcGFyYXRpb24gYmV0d2VlbiBlYWNoIG9mIHRoZSBnaXZlbiBzbG90U2l6ZVxyXG4gICAgICAgIGluIG1pbnV0ZXMgb3IgdXNpbmcgdGhlIGRlZmF1bHQgZnJvbSB0aGUgc2NoZWR1bGluZyBwcmVmZXJlbmNlc1xyXG4gICAgICAgIGluY2x1ZGVkIGluIHRoZSBvYmplY3QuXHJcblxyXG4gICAgICAgIFRoZSBwYXJhbWV0ZXIgJ2R1cmF0aW9uJyAoaW4gbWludXRlcykgYWxsb3dzIHRoYXQgcmV0dXJuZWQgc2xvdHNcclxuICAgICAgICBhcmUgZnJlZSBhbG1vc3QgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi4gVGhpcyBhbGxvd3MgdG8gY2hvb3NlIHRpbWVzXHJcbiAgICAgICAgdGhhdCBmaXQgdGhlIG5lZWRlZCBzZXJ2aWNlIGR1cmF0aW9uLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLmdldEZyZWVUaW1lU2xvdHMgPSBmdW5jdGlvbiBnZXRGcmVlVGltZVNsb3RzKGR1cmF0aW9uLCBzbG90U2l6ZU1pbnV0ZXMpIHtcclxuICAgICAgICBcclxuICAgICAgICBzbG90U2l6ZU1pbnV0ZXMgPSBzbG90U2l6ZU1pbnV0ZXMgfHwgdGhpcy5zY2hlZHVsaW5nUHJlZmVyZW5jZXMoKS5pbmNyZW1lbnRzU2l6ZUluTWludXRlcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghZHVyYXRpb24pXHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gc2xvdFNpemVNaW51dGVzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5kYXRlKCksXHJcbiAgICAgICAgICAgIHRvZGF5ID0gZ2V0RGF0ZVdpdGhvdXRUaW1lKCk7XHJcbiAgICBcclxuICAgICAgICAvLyBRdWljayByZXR1cm4gaWYgd2l0aCBlbXB0eSBsaXN0IHdoZW5cclxuICAgICAgICAvLyAtIHBhc3QgZGF0ZSAobm8gdGltZSlcclxuICAgICAgICAvLyAtIG5vIGF2YWlsYWJsZSB0aW1lIChhbHJlYWR5IGNvbXB1dGVkKVxyXG4gICAgICAgIGlmIChkYXRlIDwgdG9kYXkgfHxcclxuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVNaW51dGVzKCkgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgc2xvdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBldmVyeSBmcmVlIGFwcG9pbnRtZW50XHJcbiAgICAgICAgICAgIHRoaXMubGlzdCgpLmZvckVhY2goZnVuY3Rpb24gKGFwdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwdC5pZCgpID09PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLmZyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90cy5wdXNoLmFwcGx5KHNsb3RzLCBjcmVhdGVUaW1lU2xvdHMoYXB0LnN0YXJ0VGltZSgpLCBhcHQuZW5kVGltZSgpLCBzbG90U2l6ZU1pbnV0ZXMsIGR1cmF0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc2xvdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRlQXZhaWxhYmlsaXR5O1xyXG5cclxuLyoqXHJcbiAgICBJdCBjcmVhdGVzIHNsb3RzIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzIGFuZCBzaXplIGZvciBlYWNoIG9uZS5cclxuICAgIFBhc3QgdGltZXMgYXJlIGF2b2lkZWQsIGJlY2F1c2UgYXJlIG5vdCBhdmFpbGFibGVcclxuKiovXHJcbmZ1bmN0aW9uIGNyZWF0ZVRpbWVTbG90cyhmcm9tLCB0bywgc2l6ZSwgZHVyYXRpb24pIHtcclxuICAgIHZhciBpID0gbW9tZW50KGZyb20pLFxyXG4gICAgICAgIGQsXHJcbiAgICAgICAgc2xvdHMgPSBbXSxcclxuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIGVub3VnaHQ7XHJcblxyXG4gICAgLy8gU2hvcnRjdXQgaWYgYmFkICd0bycgKGF2b2lkIGluZmluaXRlIGxvb3ApXHJcbiAgICBpZiAodG8gPD0gZnJvbSlcclxuICAgICAgICByZXR1cm4gc2xvdHM7XHJcblxyXG4gICAgd2hpbGUoaS50b0RhdGUoKSA8IHRvKSB7XHJcbiAgICAgICAgZCA9IGkuY2xvbmUoKS50b0RhdGUoKTtcclxuICAgICAgICBlbm91Z2h0ID0gaS5jbG9uZSgpLmFkZChkdXJhdGlvbiwgJ21pbnV0ZXMnKS50b0RhdGUoKTtcclxuICAgICAgICAvLyBDaGVjayB0aGF0OlxyXG4gICAgICAgIC8vIC0gaXMgbm90IGEgcGFzdCBkYXRlXHJcbiAgICAgICAgLy8gLSBpdCBoYXMgZW5vdWdodCB0aW1lIGluIGFkdmFuY2UgdG8gZmlsbCB0aGUgZXhwZWN0ZWQgZHVyYXRpb25cclxuICAgICAgICBpZiAoZCA+PSBub3cgJiZcclxuICAgICAgICAgICAgZW5vdWdodCA8PSB0bylcclxuICAgICAgICAgICAgc2xvdHMucHVzaChkKTtcclxuICAgICAgICAvLyBOZXh0IHNsb3RcclxuICAgICAgICBpLmFkZChzaXplLCAnbWludXRlcycpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gc2xvdHM7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBGcmVlbGFuY2VyIFByaWNpbmcgbW9kZWw6IG1hbmFnZXMgYW4gaW5kaXZpZHVhbFxyXG4gICAgcHJpY2luZy9wYWNrYWdlIGZyb20gdGhlIHVzZXIgYW5kIGEgc3BlY2lmaWMgam9iIHRpdGxlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgbnVtZXJhbCA9IHJlcXVpcmUoJ251bWVyYWwnKTtcclxuXHJcbmZ1bmN0aW9uIEZyZWVsYW5jZXJQcmljaW5nKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBmcmVlbGFuY2VyUHJpY2luZ0lEOiAwLFxyXG4gICAgICAgIGZyZWVsYW5jZXJVc2VySUQ6IDAsXHJcbiAgICAgICAgam9iVGl0bGVJRDogMCxcclxuICAgICAgICBwcmljaW5nVHlwZUlEOiAwLFxyXG4gICAgICAgIG5hbWU6ICcnLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxyXG4gICAgICAgIHByaWNlOiBudWxsLFxyXG4gICAgICAgIHNlcnZpY2VEdXJhdGlvbk1pbnV0ZXM6IG51bGwsXHJcbiAgICAgICAgZmlyc3RUaW1lQ2xpZW50c09ubHk6IGZhbHNlLFxyXG4gICAgICAgIG51bWJlck9mU2Vzc2lvbnM6IDEsXHJcbiAgICAgICAgcHJpY2VSYXRlOiBudWxsLFxyXG4gICAgICAgIHByaWNlUmF0ZVVuaXQ6ICdob3VyJyxcclxuICAgICAgICAvLyBTcGVjaWFsIHByb3BlcnR5LCBub3QgaW4gc291cmNlIGRhdGEganVzdCBvbmx5IGFuIGV4cGxpY2l0XHJcbiAgICAgICAgLy8gd2F5IHRvIGF2b2lkIHZhbGlkYXRpb24gb2YgcHJpY2VSYXRlIGlmIG5vdCBleHBsaWNpdCB2YWx1ZSBzZXRcclxuICAgICAgICBub1ByaWNlUmF0ZTogZmFsc2UsXHJcbiAgICAgICAgaXNQaG9uZTogZmFsc2UsXHJcbiAgICAgICAgLy8gQXJyYXkgb2YgaW50ZWdlcnMsIElEcyBvZiBzZXJ2aWNlQXR0cmlidXRlc1xyXG4gICAgICAgIHNlcnZpY2VBdHRyaWJ1dGVzOiBbXSxcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZJRChbJ2ZyZWVsYW5jZXJQcmljaW5nSUQnXSk7XHJcbiAgICBcclxuICAgIC8vIE9uZSB3YXkgZWZmZWN0OiBzZXQgcHJpY2VSYXRlIHRvIG51bGwgd2hlbiBzZXR0aW5nIG9uIG5vUHJpY2VSYXRlXHJcbiAgICAvLyBCdXQgbm90aGluZyBvbiBvZmYgYW5kIG5vIG90aGVyIHJlbGF0aW9ucyB0byBhdm9pZCBiYWQgc2lkZSBlZmZlY3RzLlxyXG4gICAgdGhpcy5ub1ByaWNlUmF0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oZW5hYmxlZCkge1xyXG4gICAgICAgIGlmIChlbmFibGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpY2VSYXRlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBBc2sgZm9yIGEgcmVmcmVzaCBvZiB0aGUgbm9QcmljZVJhdGUsIHRoYXQgbXVzdCBiZSAndHJ1ZScgaWYgdGhlIHJlY29yZCBleGlzdHMgYW5kXHJcbiAgICAgICAgaGFzIG5vIHByaWNlUmF0ZSAodG8gcmVtZW1iZXIgdGhlIHByZXZpb3VzIHZhbHVlIHNldCBieSB0aGUgdXNlciBhYm91dCBub1ByaWNlUmF0ZSkuXHJcbiAgICAgICAgSXQgZW5zdXJlIHRoYXQgdGhlIGludGVybmFsIHRpbWVzdGFtcCBrZWVwIHVudG91Y2hlZC5cclxuICAgICAgICBDYW5ub3QgYmUgYXV0b21hdGljLCBzbyBuZWVkIHRvIGJlIGNhbGxlZCBtYW51YWxseSBhZnRlciBhIGRhdGEgbG9hZCB0aGF0IGRvZXMgbm90XHJcbiAgICAgICAgd2FudCB0byByZWZsZWN0IHRoaXMgY2hhbmdlIGFzIGEgZGF0YSBjaGFuZ2UuXHJcbiAgICAqKi9cclxuICAgIHRoaXMucmVmcmVzaE5vUHJpY2VSYXRlID0gZnVuY3Rpb24gcmVmcmVzaE5vUHJpY2VSYXRlKCkge1xyXG4gICAgICAgIC8vIE5vdCBUbyBTdGF0ZSBQcmljZSBSYXRlOiBpZiBpcyBhIHNhdmVkIHByaWNpbmcsIG1hcmsgdGhlIG5vUHJpY2VSYXRlIGlmIHByaWNlIHJhdGUgaXNcclxuICAgICAgICAvLyBudWxsIG9yIDA7IGNhbm5vdCBiZSBkb25lIHdpdGggYSBzdWJzY3JpcHRpb24gb24gcHJpY2VSYXRlIGNoYW5nZXMgYmVjYXVzZSB3aWxsIGhhdmVcclxuICAgICAgICAvLyB0aGUgYmFkIHNpZGUgZWZmZWN0IG9mIGF1dG8gbWFyayBub1ByaWNlUmF0ZSBvbiBzZXR0aW5nIDAgb24gcHJpY2VSYXRlLCBicmVha2luZyB0aGVcclxuICAgICAgICAvLyBleHBsaWNpdCBwdXJwb3NlIG9mIHRoZSBub1ByaWNlUmF0ZSBjaGVja2JveDpcclxuICAgICAgICBpZiAodGhpcy5mcmVlbGFuY2VyUHJpY2luZ0lEKCkgJiYgKHRoaXMucHJpY2VSYXRlKCkgfDApIDw9IDApIHtcclxuICAgICAgICAgICAgdmFyIHRzID0gdGhpcy5tb2RlbC5kYXRhVGltZXN0YW1wKCk7XHJcbiAgICAgICAgICAgIHRoaXMubm9QcmljZVJhdGUodHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIFNldCBhZ2FpbiB0aW1lc3RhbXAgc28gdGhlIG1vZGVsIGFwcGVhciBhcyB1bnRvdWNoZWQuXHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuZGF0YVRpbWVzdGFtcCh0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBbHRlcm5hdGl2ZSBlZGl0aW9uIG9mIHRoZSBzZXJ2aWNlRHVyYXRpb25NaW51dGVzIGZpZWxkczpcclxuICAgIC8vIFNwbGl0ZWQgYXMgaG91cnMgYW5kIG1pbnV0ZXNcclxuICAgIHZhciBpcyA9IHJlcXVpcmUoJ2lzX2pzJyk7XHJcbiAgICB0aGlzLmR1cmF0aW9uSG91cnNQYXJ0ID0ga28ucHVyZUNvbXB1dGVkKHtcclxuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGZ1bGxNaW51dGVzID0gdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaXMubm90Lm51bWJlcihmdWxsTWludXRlcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKGZ1bGxNaW51dGVzfDApIC8gNjApIHwwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGhvdXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW51dGVzID0gdGhpcy5kdXJhdGlvbk1pbnV0ZXNQYXJ0KCkgfDA7XHJcbiAgICAgICAgICAgIC8vIFZhbHVlIGNvbWVzIGZyb20gdGV4dFxyXG4gICAgICAgICAgICBob3VycyA9IHBhcnNlSW50KGhvdXJzLCAxMCk7XHJcbiAgICAgICAgICAgIGlmIChpcy5ub3QubnVtYmVyKGhvdXJzKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZUR1cmF0aW9uTWludXRlcyhudWxsKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKChob3Vyc3wwKSAqIDYwICsgbWludXRlcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvd25lcjogdGhpc1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmR1cmF0aW9uTWludXRlc1BhcnQgPSBrby5wdXJlQ29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZnVsbE1pbnV0ZXMgPSB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpcy5ub3QubnVtYmVyKGZ1bGxNaW51dGVzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChmdWxsTWludXRlc3wwKSAlIDYwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKG1pbnV0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGhvdXJzID0gdGhpcy5kdXJhdGlvbkhvdXJzUGFydCgpIHwwO1xyXG4gICAgICAgICAgICAvLyBWYWx1ZSBjb21lcyBmcm9tIHRleHRcclxuICAgICAgICAgICAgbWludXRlcyA9IHBhcnNlSW50KG1pbnV0ZXMsIDEwKTtcclxuICAgICAgICAgICAgaWYgKGlzLm5vdC5udW1iZXIobWludXRlcykpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMobnVsbCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZUR1cmF0aW9uTWludXRlcyhob3VycyAqIDYwICsgKG1pbnV0ZXN8MCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3duZXI6IHRoaXNcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBcclxuICAgIC8vLyBWaXN1YWwgcmVwcmVzZW50YXRpb24gb2Ygc2V2ZXJhbCBmaWVsZHNcclxuICAgIFxyXG4gICAgdGhpcy5kdXJhdGlvblRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKSB8fCAwO1xyXG4gICAgICAgIC8vIFRPRE86IGwxMG5cclxuICAgICAgICByZXR1cm4gbWludXRlcyA/IG51bWVyYWwobWludXRlcykuZm9ybWF0KCcwLDAnKSArICcgbWludXRlcycgOiAnJztcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNlc3Npb25zQW5kRHVyYXRpb24gPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNlc3Npb25zID0gdGhpcy5udW1iZXJPZlNlc3Npb25zKCksXHJcbiAgICAgICAgICAgIGR1ciA9IHRoaXMuZHVyYXRpb25UZXh0KCk7XHJcbiAgICAgICAgaWYgKHNlc3Npb25zID4gMSlcclxuICAgICAgICAgICAgLy8gVE9ETzogbDEwblxyXG4gICAgICAgICAgICByZXR1cm4gc2Vzc2lvbnMgKyAnIHNlc3Npb25zLCAnICsgZHVyO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGR1cjtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuZGlzcGxheWVkUHJpY2UgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHByaWNlID0gdGhpcy5wcmljZSgpLFxyXG4gICAgICAgICAgICByYXRlID0gdGhpcy5wcmljZVJhdGUoKSxcclxuICAgICAgICAgICAgdW5pdCA9IHRoaXMucHJpY2VSYXRlVW5pdCgpLFxyXG4gICAgICAgICAgICByZXN1bHQgPSBwcmljZSB8fCByYXRlO1xyXG4gICAgICAgIC8vIEZvcm1hdHRpbmdcclxuICAgICAgICByZXN1bHQgPSBudW1lcmFsKHJlc3VsdCkuZm9ybWF0KCckMCwwJyk7XHJcbiAgICAgICAgLy8gSWYgaXMgbm90IHByaWNlIGJ1dCByYXRlLCBhZGQgdW5pdFxyXG4gICAgICAgIGlmICghcHJpY2UgJiYgcmF0ZSAmJiB1bml0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLycgKyB1bml0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgdGhpcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnJlZWxhbmNlclByaWNpbmc7XHJcbiIsIi8qKiBHZXRNb3JlIG1vZGVsICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBMaXN0Vmlld0l0ZW0gPSByZXF1aXJlKCcuL0xpc3RWaWV3SXRlbScpO1xyXG5cclxuZnVuY3Rpb24gR2V0TW9yZSh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGF2YWlsYWJpbGl0eTogZmFsc2UsXHJcbiAgICAgICAgcGF5bWVudHM6IGZhbHNlLFxyXG4gICAgICAgIHByb2ZpbGU6IGZhbHNlLFxyXG4gICAgICAgIGNvb3A6IHRydWVcclxuICAgIH0sIHZhbHVlcyk7XHJcblxyXG4gICAgdmFyIGF2YWlsYWJsZUl0ZW1zID0ge1xyXG4gICAgICAgIGF2YWlsYWJpbGl0eTogbmV3IExpc3RWaWV3SXRlbSh7XHJcbiAgICAgICAgICAgIGNvbnRlbnRMaW5lMTogJ0NvbXBsZXRlIHlvdXIgYXZhaWxhYmlsaXR5IHRvIGNyZWF0ZSBhIGNsZWFuZXIgY2FsZW5kYXInLFxyXG4gICAgICAgICAgICBtYXJrZXJJY29uOiAnZmEgZmEtZncgZmEtY2FsZW5kYXInXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgcGF5bWVudHM6IG5ldyBMaXN0Vmlld0l0ZW0oe1xyXG4gICAgICAgICAgICBjb250ZW50TGluZTE6ICdTdGFydCBhY2NlcHRpbmcgcGF5bWVudHMgdGhyb3VnaCBMb2Nvbm9taWNzJyxcclxuICAgICAgICAgICAgbWFya2VySWNvbjogJ2ZhIGlvbiBpb24tY2FyZCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBwcm9maWxlOiBuZXcgTGlzdFZpZXdJdGVtKHtcclxuICAgICAgICAgICAgY29udGVudExpbmUxOiAnQWN0aXZhdGUgeW91ciBwcm9maWxlIGluIHRoZSBtYXJrZXRwbGFjZScsXHJcbiAgICAgICAgICAgIG1hcmtlckljb246ICdmYSBpb24gaW9uLWNhc2gnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgY29vcDogbmV3IExpc3RWaWV3SXRlbSh7XHJcbiAgICAgICAgICAgIGNvbnRlbnRMaW5lMTogJ0xlYXJuIG1vcmUgYWJvdXQgb3VyIGNvb3BlcmF0aXZlJyxcclxuICAgICAgICAgICAgYWN0aW9uSWNvbjogJ2ZhIGZhLWdhdmVsJ1xyXG4gICAgICAgIH0pXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaXRlbXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgT2JqZWN0LmtleXMoYXZhaWxhYmxlSXRlbXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpc1trZXldKCkpXHJcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGF2YWlsYWJsZUl0ZW1zW2tleV0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdldE1vcmU7XHJcbiIsIi8qKiBKb2JUaXRsZSBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgSm9iVGl0bGVQcmljaW5nVHlwZSA9IHJlcXVpcmUoJy4vSm9iVGl0bGVQcmljaW5nVHlwZScpO1xyXG5cclxuZnVuY3Rpb24gSm9iVGl0bGUodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXHJcbiAgICAgICAgc2luZ3VsYXJOYW1lOiAnJyxcclxuICAgICAgICBwbHVyYWxOYW1lOiAnJyxcclxuICAgICAgICBhbGlhc2VzOiAnJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcclxuICAgICAgICBzZWFyY2hEZXNjcmlwdGlvbjogbnVsbCxcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxyXG4gICAgfSwgdmFsdWVzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZklEKFsnam9iVGl0bGVJRCddKTtcclxuXHJcbiAgICAvLyBUT0RPOiByZXZpZXcgaWYsIG5vdCByZWdpc3RlcmVkIGFzIGEgcHJvcGVydHksIHRoZSBsaXN0IGlzIHVwZGF0ZWRcclxuICAgIC8vIG9uIHN5bmNzIGJ5IHVzaW5nIG1vZGVsLnVwZGF0ZVdpdGhcclxuXHJcbiAgICAvLyBQcmljaW5nIFR5cGVzIHJlbGF0aW9uc2hpcCxcclxuICAgIC8vIGNvbGxlY3Rpb24gb2YgSm9iVGl0bGVQcmljaW5nVHlwZSBlbnRpdGllc1xyXG4gICAgdGhpcy5wcmljaW5nVHlwZXMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG4gICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMucHJpY2luZ1R5cGVzKSB7XHJcbiAgICAgICAgdmFsdWVzLnByaWNpbmdUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGpvYnByaWNpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmljaW5nVHlwZXMucHVzaChuZXcgSm9iVGl0bGVQcmljaW5nVHlwZShqb2JwcmljaW5nKSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKb2JUaXRsZTtcclxuIiwiLyoqXHJcbiAgICBEZWZpbmVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIEpvYlRpdGxlIGFuZCBhIFByaWNpbmdUeXBlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gSm9iVGl0bGVQcmljaW5nVHlwZSh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBwcmljaW5nVHlwZUlEOiAwLFxyXG4gICAgICAgIC8vIE5PVEU6IENsaWVudCBUeXBlIGlzIG1vc3RseSB1bnVzZWQgdG9kYXkgYnV0IGV4aXN0c1xyXG4gICAgICAgIC8vIG9uIGFsbCBkYXRhYmFzZSByZWNvcmRzLiBJdCB1c2VzIHRoZSBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgLy8gb2YgMSBhbGwgdGhlIHRpbWUgZm9yIG5vdy5cclxuICAgICAgICBjbGllbnRUeXBlSUQ6IDEsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmSUQoWydwcmljaW5nVHlwZUlEJywgJ2NsaWVudFR5cGVJRCddKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKb2JUaXRsZVByaWNpbmdUeXBlO1xyXG4iLCIvKiogTGlzdFZpZXdJdGVtIG1vZGVsLlxyXG5cclxuICAgIERlc2NyaWJlcyBhIGdlbmVyaWMgaXRlbSBvZiBhXHJcbiAgICBMaXN0VmlldyBjb21wb25lbnQuXHJcbiAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gTGlzdFZpZXdJdGVtKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIG1hcmtlckxpbmUxOiBudWxsLFxyXG4gICAgICAgIG1hcmtlckxpbmUyOiBudWxsLFxyXG4gICAgICAgIG1hcmtlckljb246IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29udGVudExpbmUxOiAnJyxcclxuICAgICAgICBjb250ZW50TGluZTI6IG51bGwsXHJcbiAgICAgICAgbGluazogJyMnLFxyXG5cclxuICAgICAgICBhY3Rpb25JY29uOiBudWxsLFxyXG4gICAgICAgIGFjdGlvblRleHQ6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgY2xhc3NOYW1lczogJydcclxuXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RWaWV3SXRlbTtcclxuIiwiLyoqIE1haWxGb2xkZXIgbW9kZWwgKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbmZ1bmN0aW9uIE1haWxGb2xkZXIodmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBtZXNzYWdlczogW10sXHJcbiAgICAgICAgdG9wTnVtYmVyOiAxMFxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgdGhpcy50b3AgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gdG9wKG51bSkge1xyXG4gICAgICAgIGlmIChudW0pIHRoaXMudG9wTnVtYmVyKG51bSk7XHJcbiAgICAgICAgcmV0dXJuIF8uZmlyc3QodGhpcy5tZXNzYWdlcygpLCB0aGlzLnRvcE51bWJlcigpKTtcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haWxGb2xkZXI7XHJcbiIsIi8qKiBNYXJrZXRwbGFjZVByb2ZpbGUgbW9kZWwgKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIE1hcmtldHBsYWNlUHJvZmlsZSh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgdXNlcklEOiAwLFxyXG4gICAgICAgIFxyXG4gICAgICAgIHB1YmxpY0JpbzogJycsXHJcbiAgICAgICAgZnJlZWxhbmNlclByb2ZpbGVVcmxTbHVnOiAnJyxcclxuICAgICAgICAvLyBUaGlzIGlzIGEgc2VydmVyLXNpZGUgY29tcHV0ZWQgdmFyaWFibGUgKHJlYWQtb25seSBmb3IgdGhlIHVzZXIpIGZvciBhIExvY29ub21pY3MgYWRkcmVzc1xyXG4gICAgICAgIC8vIGNyZWF0ZWQgdXNpbmcgdGhlIGZyZWVsYW5jZXJQcm9maWxlVXJsU2x1ZyBpZiBhbnkgb3IgdGhlIGZhbGxiYWNrIHN5c3RlbSBVUkwuXHJcbiAgICAgICAgZnJlZWxhbmNlclByb2ZpbGVVcmw6ICcnLFxyXG4gICAgICAgIC8vIFNwZWNpZnkgYW4gZXh0ZXJuYWwgd2Vic2l0ZSBvZiB0aGUgZnJlZWxhbmNlci5cclxuICAgICAgICBmcmVlbGFuY2VyV2Vic2l0ZVVybDogJycsXHJcbiAgICAgICAgLy8gU2VydmVyLXNpZGUgZ2VuZXJhdGVkIGNvZGUgdGhhdCBhbGxvd3MgdG8gaWRlbnRpZmljYXRlIHNwZWNpYWwgYm9va2luZyByZXF1ZXN0c1xyXG4gICAgICAgIC8vIGZyb20gdGhlIGJvb2stbWUtbm93IGJ1dHRvbi4gVGhlIHNlcnZlciBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgZXZlciBhIHZhbHVlIG9uIHRoaXMgZm9yIGZyZWVsYW5jZXJzLlxyXG4gICAgICAgIGJvb2tDb2RlOiAnJyxcclxuXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFya2V0cGxhY2VQcm9maWxlO1xyXG4iLCIvKiogTWVzc2FnZSBtb2RlbC5cclxuXHJcbiAgICBEZXNjcmliZXMgYSBtZXNzYWdlIHRoYXQgYmVsb25ncyB0byBhIFRocmVhZC5cclxuICAgIEEgbWVzc2FnZSBjb3VsZCBiZSBvZiBkaWZmZXJlbnQgdHlwZXMsXHJcbiAgICBhcyBpbnF1aXJpZXMsIGJvb2tpbmdzLCBib29raW5nIHJlcXVlc3RzLlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuZnVuY3Rpb24gTWVzc2FnZSh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBtZXNzYWdlSUQ6IDAsXHJcbiAgICAgICAgdGhyZWFkSUQ6IDAsXHJcbiAgICAgICAgc2VudEJ5VXNlcklEOiBudWxsLFxyXG4gICAgICAgIHR5cGVJRDogbnVsbCxcclxuICAgICAgICBhdXhUOiBudWxsLFxyXG4gICAgICAgIGF1eElEOiBudWxsLFxyXG4gICAgICAgIGJvZHlUZXh0OiAnJyxcclxuICAgICAgICBcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgLy8gU21hcnQgdmlzdWFsaXphdGlvbiBvZiBkYXRlIGFuZCB0aW1lXHJcbiAgICB0aGlzLmRpc3BsYXllZERhdGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLmNyZWF0ZWREYXRlKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5jYWxlbmRhcigpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuZGlzcGxheWVkVGltZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuY3JlYXRlZERhdGUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XHJcbiIsIi8qKiBNZXNzYWdlIG1vZGVsLlxyXG5cclxuICAgIERlc2NyaWJlcyBhIG1lc3NhZ2UgZnJvbSBhIE1haWxGb2xkZXIuXHJcbiAgICBBIG1lc3NhZ2UgY291bGQgYmUgb2YgZGlmZmVyZW50IHR5cGVzLFxyXG4gICAgYXMgaW5xdWlyaWVzLCBib29raW5ncywgYm9va2luZyByZXF1ZXN0cy5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxuXHJcbmZ1bmN0aW9uIE1lc3NhZ2VWaWV3KHZhbHVlcywgYXBwKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgaWQ6IDAsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgc3ViamVjdDogJycsXHJcbiAgICAgICAgY29udGVudDogbnVsbCxcclxuICAgICAgICBsaW5rOiAnIycsXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGFnOiAnJyxcclxuICAgICAgICBjbGFzc05hbWVzOiAnJyxcclxuICAgICAgICBcclxuICAgICAgICBzb3VyY2VUaHJlYWQ6IG51bGwsXHJcbiAgICAgICAgc291cmNlTWVzc2FnZTogbnVsbFxyXG5cclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIC8vIFNtYXJ0IHZpc3VhbGl6YXRpb24gb2YgZGF0ZSBhbmQgdGltZVxyXG4gICAgdGhpcy5kaXNwbGF5ZWREYXRlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBtb21lbnQodGhpcy5jcmVhdGVkRGF0ZSgpKS5sb2NhbGUoJ2VuLVVTLUxDJykuY2FsZW5kYXIoKTtcclxuICAgICAgICBcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRpc3BsYXllZFRpbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLmNyZWF0ZWREYXRlKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5mb3JtYXQoJ0xUJyk7XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMucXVpY2tEYXRlVGltZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuY3JlYXRlZERhdGUoKTtcclxuXHJcbiAgICAgICAgdmFyIG0gPSBtb21lbnQoZGF0ZSkubG9jYWxlKCdlbi1VUy1MQycpLFxyXG4gICAgICAgICAgICB0ID0gbW9tZW50KCkuc3RhcnRPZignZGF5Jyk7XHJcblxyXG4gICAgICAgIGlmIChtLmlzQWZ0ZXIodCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uZm9ybWF0KCdMVCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uZnJvbU5vdygpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmN1c3RvbWVyID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNvdXJjZU1lc3NhZ2UoKTtcclxuICAgICAgICBpZiAoIXMgfHwgIWFwcCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciBjaWQgPSBzLnNlbnRCeVVzZXJJRCgpO1xyXG4gICAgICAgIGlmIChjaWQpIHtcclxuICAgICAgICAgICAgaWYgKGNpZCA9PT0gYXBwLm1vZGVsLnVzZXJQcm9maWxlLmRhdGEudXNlcklEKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwLm1vZGVsLnVzZXJQcm9maWxlLmRhdGE7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwuY3VzdG9tZXJzLmdldE9ic2VydmFibGVJdGVtKGNpZCwgdHJ1ZSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LCB0aGlzKVxyXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiAyMCB9IH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VWaWV3O1xyXG5cclxuLyoqXHJcbiAgICBDcmVhdGVzIGEgTWVzc2FnZVZpZXcgaW5zdGFuY2UgZnJvbSBhIFRocmVhZCBpbnN0YW5jZS5cclxuICAgIEl0J3MgYmV0dGVyIHRvIGhhdmUgYWxtb3N0IG9uZSBtZXNzYWdlIGluIHRoZSB0aHJlYWQgKHRoZSBsYXRlc3RcclxuICAgIG9uZSBmaXJzdCwgb3IgdGhlIG9uZSB0byBoaWdobGlnaHQpIHRvIGJ1aWxkIGFcclxuICAgIG1vcmUgZGV0YWlsZWQgTWVzc2FnZVZpZXdcclxuKiovXHJcbk1lc3NhZ2VWaWV3LmZyb21UaHJlYWQgPSBmdW5jdGlvbihhcHAsIHRocmVhZCkge1xyXG4gICAgXHJcbiAgICB2YXIgbXNnID0gdGhyZWFkLm1lc3NhZ2VzKCk7XHJcbiAgICBtc2cgPSBtc2cgJiYgbXNnWzBdIHx8IG51bGw7XHJcbiAgICBcclxuICAgIC8vIFRPRE86IG1vcmUgZGlmZmVyZW50IHRhZy9jbGFzc2VzIGRlcGVuZGluZyBvbiBib29raW5nIHN0YXRlIGFzIHBlciBkZXNpZ25cclxuICAgIC8vIE5PVEU6IFRoYXQgcmVxdWlyZXMgdG8gbG9hZCB0aGUgYm9va2luZyBvciByZXF1ZXN0IGJ5IGF1eElEIGFuZCB3YWl0IGZvciBpdFxyXG4gICAgdmFyIHRhZywgY2xhc3NOYW1lcztcclxuICAgIGlmIChtc2cuYXV4VCgpID09PSAnQm9va2luZycpIHtcclxuICAgICAgICB0YWcgPSAnQm9va2luZyc7XHJcbiAgICAgICAgY2xhc3NOYW1lcyA9ICd0ZXh0LXN1Y2Nlc3MnO1xyXG4gICAgfSBlbHNlIGlmIChtc2cuYXV4VCgpID09PSAnQm9va2luZ1JlcXVlc3QnKSB7XHJcbiAgICAgICAgdGFnID0gJ0Jvb2tpbmcgcmVxdWVzdCc7XHJcbiAgICAgICAgY2xhc3NOYW1lcyA9ICd0ZXh0LXdhcm5pbmcnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWaWV3KHtcclxuICAgICAgICBzb3VyY2VUaHJlYWQ6IHRocmVhZCxcclxuICAgICAgICBzb3VyY2VNZXNzYWdlOiBtc2csXHJcbiAgICAgICAgaWQ6IHRocmVhZC50aHJlYWRJRCgpLFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiB0aHJlYWQuY3JlYXRlZERhdGUoKSxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogdGhyZWFkLnVwZGF0ZWREYXRlKCksXHJcbiAgICAgICAgc3ViamVjdDogdGhyZWFkLnN1YmplY3QoKSxcclxuICAgICAgICBjb250ZW50OiBtc2cgJiYgbXNnLmJvZHlUZXh0KCkgfHwgJycsXHJcbiAgICAgICAgbGluazogJyMhL2NvbnZlcnNhdGlvbi8nICsgdGhyZWFkLnRocmVhZElEKCksXHJcbiAgICAgICAgdGFnOiB0YWcsXHJcbiAgICAgICAgY2xhc3NOYW1lczogY2xhc3NOYW1lc1xyXG4gICAgfSwgYXBwKTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBNb2RlbCBjbGFzcyB0byBoZWxwIGJ1aWxkIG1vZGVscy5cclxuXHJcbiAgICBJcyBub3QgZXhhY3RseSBhbiAnT09QIGJhc2UnIGNsYXNzLCBidXQgcHJvdmlkZXNcclxuICAgIHV0aWxpdGllcyB0byBtb2RlbHMgYW5kIGEgbW9kZWwgZGVmaW5pdGlvbiBvYmplY3RcclxuICAgIHdoZW4gZXhlY3V0ZWQgaW4gdGhlaXIgY29uc3RydWN0b3JzIGFzOlxyXG4gICAgXHJcbiAgICAnJydcclxuICAgIGZ1bmN0aW9uIE15TW9kZWwoKSB7XHJcbiAgICAgICAgTW9kZWwodGhpcyk7XHJcbiAgICAgICAgLy8gTm93LCB0aGVyZSBpcyBhIHRoaXMubW9kZWwgcHJvcGVydHkgd2l0aFxyXG4gICAgICAgIC8vIGFuIGluc3RhbmNlIG9mIHRoZSBNb2RlbCBjbGFzcywgd2l0aCBcclxuICAgICAgICAvLyB1dGlsaXRpZXMgYW5kIG1vZGVsIHNldHRpbmdzLlxyXG4gICAgfVxyXG4gICAgJycnXHJcbiAgICBcclxuICAgIFRoYXQgYXV0byBjcmVhdGlvbiBvZiAnbW9kZWwnIHByb3BlcnR5IGNhbiBiZSBhdm9pZGVkXHJcbiAgICB3aGVuIHVzaW5nIHRoZSBvYmplY3QgaW5zdGFudGlhdGlvbiBzeW50YXggKCduZXcnIGtleXdvcmQpOlxyXG4gICAgXHJcbiAgICAnJydcclxuICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChvYmopO1xyXG4gICAgLy8gVGhlcmUgaXMgbm8gYSAnb2JqLm1vZGVsJyBwcm9wZXJ0eSwgY2FuIGJlXHJcbiAgICAvLyBhc3NpZ25lZCB0byB3aGF0ZXZlciBwcm9wZXJ0eSBvciBub3RoaW5nLlxyXG4gICAgJycnXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcbmtvLm1hcHBpbmcgPSByZXF1aXJlKCdrbm9ja291dC5tYXBwaW5nJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbnZhciBjbG9uZSA9IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIG9iaik7IH07XHJcbnZhciBjbG9uZVZhbHVlID0gZnVuY3Rpb24odmFsLCBkZWVwQ29weSkge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAqL1xyXG4gICAgaWYgKHR5cGVvZih2YWwpID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIEEgRGF0ZSBvYmplY3QgaXMgYSBzcGVjaWFsIGNhc2U6IGV2ZW4gYmVpbmdcclxuICAgICAgICAvLyBhbiBvYmplY3QsIHRyZWF0IGFzIGEgYmFzaWMgdHlwZSwgYmVpbmcgY29waWVkIGFzXHJcbiAgICAgICAgLy8gYSBuZXcgaW5zdGFuY2UgaW5kZXBlbmRlbnQgb2YgdGhlIGRlZXBDb3B5IG9wdGlvblxyXG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEEgZGF0ZSBjbG9uZVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVlcENvcHkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lVmFsdWUoaXRlbSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAmJiB2YWwubW9kZWwgaW5zdGFuY2VvZiBNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQSBtb2RlbCBjb3B5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLm1vZGVsLnRvUGxhaW5PYmplY3QoZGVlcENvcHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUGxhaW4gJ3N0YW5kYXJkJyBvYmplY3QgY2xvbmVcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZSh2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRlZXBDb3B5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyBTaGFsbG93IGNvcHlcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT24gZWxzZSwgbGVmdCB1bmRlZmluZWQsIG5vIHJlZmVyZW5jZXMsIG5vIGNsb25lcyxcclxuICAgICAgICAvLyBkaXNjYXJkZWQgdmFsdWVcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gQSBiYXNpYyB0eXBlIHZhbHVlIGlzIGFscmVhZHkgY29waWVkL2Nsb25lZCBieSBqYXZhc2NyaXB0XHJcbiAgICAgICAgLy8gb24gZXZlcnkgYXNzaWdubWVudFxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBNb2RlbChtb2RlbE9iamVjdCkge1xyXG4gICAgXHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZWwpKSB7XHJcbiAgICAgICAgLy8gRXhlY3V0ZWQgYXMgYSBmdW5jdGlvbiwgaXQgbXVzdCBjcmVhdGVcclxuICAgICAgICAvLyBhIE1vZGVsIGluc3RhbmNlXHJcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKG1vZGVsT2JqZWN0KTtcclxuICAgICAgICAvLyBhbmQgcmVnaXN0ZXIgYXV0b21hdGljYWxseSBhcyBwYXJ0XHJcbiAgICAgICAgLy8gb2YgdGhlIG1vZGVsT2JqZWN0IGluICdtb2RlbCcgcHJvcGVydHlcclxuICAgICAgICBtb2RlbE9iamVjdC5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGluc3RhbmNlXHJcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xyXG4gICAgfVxyXG4gXHJcbiAgICAvLyBJdCBpbmNsdWRlcyBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0XHJcbiAgICB0aGlzLm1vZGVsT2JqZWN0ID0gbW9kZWxPYmplY3Q7XHJcbiAgICAvLyBJdCBtYWludGFpbnMgYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIGZpZWxkc1xyXG4gICAgdGhpcy5wcm9wZXJ0aWVzTGlzdCA9IFtdO1xyXG4gICAgdGhpcy5maWVsZHNMaXN0ID0gW107XHJcbiAgICB0aGlzLnByb3BlcnRpZXNEZWZzID0ge307XHJcbiAgICB0aGlzLmZpZWxkc0RlZnMgPSB7fTtcclxuICAgIC8vIEl0IGFsbG93IHNldHRpbmcgdGhlICdrby5tYXBwaW5nLmZyb21KUycgbWFwcGluZyBvcHRpb25zXHJcbiAgICAvLyB0byBjb250cm9sIGNvbnZlcnNpb25zIGZyb20gcGxhaW4gSlMgb2JqZWN0cyB3aGVuIFxyXG4gICAgLy8gJ3VwZGF0ZVdpdGgnLlxyXG4gICAgdGhpcy5tYXBwaW5nT3B0aW9ucyA9IHt9O1xyXG4gICAgXHJcbiAgICAvLyBUaW1lc3RhbXAgd2l0aCB0aGUgZGF0ZSBvZiBsYXN0IGNoYW5nZVxyXG4gICAgLy8gaW4gdGhlIGRhdGEgKGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB3aGVuIGNoYW5nZXNcclxuICAgIC8vIGhhcHBlbnMgb24gcHJvcGVydGllczsgZmllbGRzIG9yIGFueSBvdGhlciBtZW1iZXJcclxuICAgIC8vIGFkZGVkIHRvIHRoZSBtb2RlbCBjYW5ub3QgYmUgb2JzZXJ2ZWQgZm9yIGNoYW5nZXMsXHJcbiAgICAvLyByZXF1aXJpbmcgbWFudWFsIHVwZGF0aW5nIHdpdGggYSAnbmV3IERhdGUoKScsIGJ1dCBpc1xyXG4gICAgLy8gYmV0dGVyIHRvIHVzZSBwcm9wZXJ0aWVzLlxyXG4gICAgLy8gSXRzIHJhdGVkIHRvIHplcm8ganVzdCB0byBhdm9pZCB0aGF0IGNvbnNlY3V0aXZlXHJcbiAgICAvLyBzeW5jaHJvbm91cyBjaGFuZ2VzIGVtaXQgbG90IG9mIG5vdGlmaWNhdGlvbnMsIHNwZWNpYWxseVxyXG4gICAgLy8gd2l0aCBidWxrIHRhc2tzIGxpa2UgJ3VwZGF0ZVdpdGgnLlxyXG4gICAgdGhpcy5kYXRhVGltZXN0YW1wID0ga28ub2JzZXJ2YWJsZShuZXcgRGF0ZSgpKS5leHRlbmQoeyByYXRlTGltaXQ6IDAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XHJcblxyXG4vKipcclxuICAgIEludGVybmFsIHV0aWxpdHkgdG8gbWFwIGEgdmFsdWUgZ2l2ZW4gaXRzIHByb3BlcnR5L2ZpZWxkXHJcbiAgICBkZWZpbml0aW9uXHJcbioqL1xyXG5mdW5jdGlvbiBwcmVwYXJlVmFsdWVCeURlZih2YWwsIGRlZikge1xyXG4gICAgaWYgKGRlZi5pc0FycmF5ICYmIFxyXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICBpZiAodHlwZW9mKHZhbCkgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICB2YWwgPSBbdmFsXTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHZhbCA9IFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlZiAmJiBkZWYuTW9kZWwpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBkZWYuTW9kZWwgfHxcclxuICAgICAgICAgICAgICAgICAgICBpdGVtID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mKGl0ZW0pID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICdhcyBpcydcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGVmLk1vZGVsKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIGRlZi5Nb2RlbCkgJiZcclxuICAgICAgICAgICAgICAgIHZhbCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mKHZhbCkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXcgZGVmLk1vZGVsKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEZWYoZ2l2ZW5WYWwsIGluaXRpYWxWYWwpIHtcclxuICAgIFxyXG4gICAgdmFyIGRlZixcclxuICAgICAgICBpc01vZGVsID0gZ2l2ZW5WYWwgJiYgZ2l2ZW5WYWwubW9kZWwgaW5zdGFuY2VvZiBNb2RlbCxcclxuICAgICAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShnaXZlblZhbCksXHJcbiAgICAgICAgaXNPYmplY3QgPSB0eXBlb2YoZ2l2ZW5WYWwpID09PSAnb2JqZWN0JyAmJiAhKGdpdmVuVmFsIGluc3RhbmNlb2YgRGF0ZSk7XHJcblxyXG4gICAgaWYgKGdpdmVuVmFsICE9PSBudWxsICYmICFpc01vZGVsICYmIGlzT2JqZWN0ICYmICFpc0FycmF5KSB7XHJcbiAgICAgICAgZGVmID0gZ2l2ZW5WYWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkZWYgPSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2l2ZW5WYWwsXHJcbiAgICAgICAgICAgIGlzQXJyYXk6IGlzQXJyYXlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpc01vZGVsKVxyXG4gICAgICAgICAgICBkZWYuTW9kZWwgPSBnaXZlblZhbC5jb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaW5pdGlhbFZhbCA9IHR5cGVvZihpbml0aWFsVmFsKSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWYuZGVmYXVsdFZhbHVlIDogaW5pdGlhbFZhbDtcclxuICAgIGRlZi5pbml0aWFsVmFsdWUgPSBwcmVwYXJlVmFsdWVCeURlZihpbml0aWFsVmFsLCBkZWYpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZGVmO1xyXG59XHJcblxyXG4vKipcclxuICAgIERlZmluZSBvYnNlcnZhYmxlIHByb3BlcnRpZXMgdXNpbmcgdGhlIGdpdmVuXHJcbiAgICBwcm9wZXJ0aWVzIG9iamVjdCBkZWZpbml0aW9uIHRoYXQgaW5jbHVkZXMgZGUgZGVmYXVsdCB2YWx1ZXMsXHJcbiAgICBhbmQgc29tZSBvcHRpb25hbCBpbml0aWFsVmFsdWVzIChub3JtYWxseSB0aGF0IGlzIHByb3ZpZGVkIGV4dGVybmFsbHlcclxuICAgIGFzIGEgcGFyYW1ldGVyIHRvIHRoZSBtb2RlbCBjb25zdHJ1Y3Rvciwgd2hpbGUgZGVmYXVsdCB2YWx1ZXMgYXJlXHJcbiAgICBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yKS5cclxuICAgIFRoYXQgcHJvcGVydGllcyBiZWNvbWUgbWVtYmVycyBvZiB0aGUgbW9kZWxPYmplY3QsIHNpbXBsaWZ5aW5nIFxyXG4gICAgbW9kZWwgZGVmaW5pdGlvbnMuXHJcbiAgICBcclxuICAgIEl0IHVzZXMgS25vY2tvdXQub2JzZXJ2YWJsZSBhbmQgb2JzZXJ2YWJsZUFycmF5LCBzbyBwcm9wZXJ0aWVzXHJcbiAgICBhcmUgZnVudGlvbnMgdGhhdCByZWFkcyB0aGUgdmFsdWUgd2hlbiBubyBhcmd1bWVudHMgb3Igc2V0cyB3aGVuXHJcbiAgICBvbmUgYXJndW1lbnQgaXMgcGFzc2VkIG9mLlxyXG4qKi9cclxuTW9kZWwucHJvdG90eXBlLmRlZlByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGluaXRpYWxWYWx1ZXMpIHtcclxuXHJcbiAgICBpbml0aWFsVmFsdWVzID0gaW5pdGlhbFZhbHVlcyB8fCB7fTtcclxuXHJcbiAgICB2YXIgbW9kZWxPYmplY3QgPSB0aGlzLm1vZGVsT2JqZWN0LFxyXG4gICAgICAgIHByb3BlcnRpZXNMaXN0ID0gdGhpcy5wcm9wZXJ0aWVzTGlzdCxcclxuICAgICAgICBkZWZzID0gdGhpcy5wcm9wZXJ0aWVzRGVmcyxcclxuICAgICAgICBkYXRhVGltZXN0YW1wID0gdGhpcy5kYXRhVGltZXN0YW1wO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCByZWdpc3RlciBkZWZpbml0aW9uXHJcbiAgICAgICAgdmFyIGRlZiA9IGNyZWF0ZURlZihwcm9wZXJ0aWVzW2tleV0sIGluaXRpYWxWYWx1ZXNba2V5XSk7XHJcbiAgICAgICAgZGVmc1trZXldID0gZGVmO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIG9ic2VydmFibGUgcHJvcGVydHlcclxuICAgICAgICBtb2RlbE9iamVjdFtrZXldID0gQXJyYXkuaXNBcnJheShkZWYuaW5pdGlhbFZhbHVlKSA/XHJcbiAgICAgICAgICAgIGtvLm9ic2VydmFibGVBcnJheShkZWYuaW5pdGlhbFZhbHVlKSA6XHJcbiAgICAgICAgICAgIGtvLm9ic2VydmFibGUoZGVmLmluaXRpYWxWYWx1ZSk7XHJcblxyXG4gICAgICAgIC8vIFJlbWVtYmVyIGRlZmF1bHRcclxuICAgICAgICBtb2RlbE9iamVjdFtrZXldLl9kZWZhdWx0VmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIC8vIHJlbWVtYmVyIGluaXRpYWxcclxuICAgICAgICBtb2RlbE9iamVjdFtrZXldLl9pbml0aWFsVmFsdWUgPSBkZWYuaW5pdGlhbFZhbHVlOyAgICBcclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgc3Vic2NyaWJlciB0byB1cGRhdGUgdGhlIHRpbWVzdGFtcCBvbiBjaGFuZ2VzXHJcbiAgICAgICAgbW9kZWxPYmplY3Rba2V5XS5zdWJzY3JpYmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRhdGFUaW1lc3RhbXAobmV3IERhdGUoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBpbnRlcm5hbCByZWdpc3RyeVxyXG4gICAgICAgIHByb3BlcnRpZXNMaXN0LnB1c2goa2V5KTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgdGltZXN0YW1wIGFmdGVyIHRoZSBidWxrIGNyZWF0aW9uLlxyXG4gICAgZGF0YVRpbWVzdGFtcChuZXcgRGF0ZSgpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgRGVmaW5lIGZpZWxkcyBhcyBwbGFpbiBtZW1iZXJzIG9mIHRoZSBtb2RlbE9iamVjdCB1c2luZ1xyXG4gICAgdGhlIGZpZWxkcyBvYmplY3QgZGVmaW5pdGlvbiB0aGF0IGluY2x1ZGVzIGRlZmF1bHQgdmFsdWVzLFxyXG4gICAgYW5kIHNvbWUgb3B0aW9uYWwgaW5pdGlhbFZhbHVlcy5cclxuICAgIFxyXG4gICAgSXRzIGxpa2UgZGVmUHJvcGVydGllcywgYnV0IGZvciBwbGFpbiBqcyB2YWx1ZXMgcmF0aGVyIHRoYW4gb2JzZXJ2YWJsZXMuXHJcbioqL1xyXG5Nb2RlbC5wcm90b3R5cGUuZGVmRmllbGRzID0gZnVuY3Rpb24gZGVmRmllbGRzKGZpZWxkcywgaW5pdGlhbFZhbHVlcykge1xyXG5cclxuICAgIGluaXRpYWxWYWx1ZXMgPSBpbml0aWFsVmFsdWVzIHx8IHt9O1xyXG5cclxuICAgIHZhciBtb2RlbE9iamVjdCA9IHRoaXMubW9kZWxPYmplY3QsXHJcbiAgICAgICAgZGVmcyA9IHRoaXMuZmllbGRzRGVmcyxcclxuICAgICAgICBmaWVsZHNMaXN0ID0gdGhpcy5maWVsZHNMaXN0O1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGZpZWxkcykuZWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDcmVhdGUgYW5kIHJlZ2lzdGVyIGRlZmluaXRpb25cclxuICAgICAgICB2YXIgZGVmID0gY3JlYXRlRGVmKGZpZWxkc1trZXldLCBpbml0aWFsVmFsdWVzW2tleV0pO1xyXG4gICAgICAgIGRlZnNba2V5XSA9IGRlZjtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDcmVhdGUgZmllbGQgd2l0aCBpbml0aWFsIHZhbHVlXHJcbiAgICAgICAgbW9kZWxPYmplY3Rba2V5XSA9IGRlZi5pbml0aWFsVmFsdWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBpbnRlcm5hbCByZWdpc3RyeVxyXG4gICAgICAgIGZpZWxkc0xpc3QucHVzaChrZXkpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFN0b3JlIHRoZSBsaXN0IG9mIGZpZWxkcyB0aGF0IG1ha2UgdGhlIElEL3ByaW1hcnkga2V5XHJcbiAgICBhbmQgY3JlYXRlIGFuIGFsaWFzICdpZCcgcHJvcGVydHkgdGhhdCByZXR1cm5zIHRoZVxyXG4gICAgdmFsdWUgZm9yIHRoZSBJRCBmaWVsZCBvciBhcnJheSBvZiB2YWx1ZXMgd2hlbiBtdWx0aXBsZVxyXG4gICAgZmllbGRzLlxyXG4qKi9cclxuTW9kZWwucHJvdG90eXBlLmRlZklEID0gZnVuY3Rpb24gZGVmSUQoZmllbGRzTmFtZXMpIHtcclxuICAgIFxyXG4gICAgLy8gU3RvcmUgdGhlIGxpc3RcclxuICAgIHRoaXMuaWRGaWVsZHNOYW1lcyA9IGZpZWxkc05hbWVzO1xyXG4gICAgXHJcbiAgICAvLyBEZWZpbmUgSUQgb2JzZXJ2YWJsZVxyXG4gICAgaWYgKGZpZWxkc05hbWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIC8vIFJldHVybnMgc2luZ2xlIHZhbHVlXHJcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzTmFtZXNbMF07XHJcbiAgICAgICAgdGhpcy5tb2RlbE9iamVjdC5pZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGRdKCk7XHJcbiAgICAgICAgfSwgdGhpcy5tb2RlbE9iamVjdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLm1vZGVsT2JqZWN0LmlkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRzTmFtZXMubWFwKGZ1bmN0aW9uKGZpZWxkTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGROYW1lXSgpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0sIHRoaXMubW9kZWxPYmplY3QpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAgICBBbGxvd3MgdG8gcmVnaXN0ZXIgYSBwcm9wZXJ0eSAocHJldmlvdXNseSBkZWZpbmVkKSBhcyBcclxuICAgIHRoZSBtb2RlbCB0aW1lc3RhbXAsIHNvIGdldHMgdXBkYXRlZCBvbiBhbnkgZGF0YSBjaGFuZ2VcclxuICAgIChrZWVwIGluIHN5bmMgd2l0aCB0aGUgaW50ZXJuYWwgZGF0YVRpbWVzdGFtcCkuXHJcbioqL1xyXG5Nb2RlbC5wcm90b3R5cGUucmVnVGltZXN0YW1wID0gZnVuY3Rpb24gcmVnVGltZXN0YW1wUHJvcGVydHkocHJvcGVydHlOYW1lKSB7XHJcblxyXG4gICAgdmFyIHByb3AgPSB0aGlzLm1vZGVsT2JqZWN0W3Byb3BlcnR5TmFtZV07XHJcbiAgICBpZiAodHlwZW9mKHByb3ApICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBvYnNlcnZhYmxlIHByb3BlcnR5IHdpdGggbmFtZSBbJyArIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgKyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ10gdG8gcmVnaXN0ZXIgYXMgdGltZXN0YW1wLidcclxuICAgICAgICk7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgc3Vic2NyaWJlciBvbiBpbnRlcm5hbCB0aW1lc3RhbXAgdG8ga2VlcFxyXG4gICAgLy8gdGhlIHByb3BlcnR5IHVwZGF0ZWRcclxuICAgIHRoaXMuZGF0YVRpbWVzdGFtcC5zdWJzY3JpYmUoZnVuY3Rpb24odGltZXN0YW1wKSB7XHJcbiAgICAgICAgcHJvcCh0aW1lc3RhbXApO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBhbmQgZmllbGRzXHJcbiAgICBvZiB0aGUgbW9kZWwgb2JqZWN0LCBqdXN0IHZhbHVlcy5cclxuICAgIFxyXG4gICAgQHBhcmFtIGRlZXBDb3B5OmJvb2wgSWYgbGVmdCB1bmRlZmluZWQsIGRvIG5vdCBjb3B5IG9iamVjdHMgaW5cclxuICAgIHZhbHVlcyBhbmQgbm90IHJlZmVyZW5jZXMuIElmIGZhbHNlLCBkbyBhIHNoYWxsb3cgY29weSwgc2V0dGluZ1xyXG4gICAgdXAgcmVmZXJlbmNlcyBpbiB0aGUgcmVzdWx0LiBJZiB0cnVlLCB0byBhIGRlZXAgY29weSBvZiBhbGwgb2JqZWN0cy5cclxuKiovXHJcbk1vZGVsLnByb3RvdHlwZS50b1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gdG9QbGFpbk9iamVjdChkZWVwQ29weSkge1xyXG5cclxuICAgIHZhciBwbGFpbiA9IHt9LFxyXG4gICAgICAgIG1vZGVsT2JqID0gdGhpcy5tb2RlbE9iamVjdDtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRWYWx1ZShwcm9wZXJ0eSwgdmFsKSB7XHJcbiAgICAgICAgdmFyIGNsb25lZFZhbHVlID0gY2xvbmVWYWx1ZSh2YWwsIGRlZXBDb3B5KTtcclxuICAgICAgICBpZiAodHlwZW9mKGNsb25lZFZhbHVlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcGxhaW5bcHJvcGVydHldID0gY2xvbmVkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJvcGVydGllc0xpc3QuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xyXG4gICAgICAgIC8vIFByb3BlcnRpZXMgYXJlIG9ic2VydmFibGVzLCBzbyBmdW5jdGlvbnMgd2l0aG91dCBwYXJhbXM6XHJcbiAgICAgICAgdmFyIHZhbCA9IG1vZGVsT2JqW3Byb3BlcnR5XSgpO1xyXG5cclxuICAgICAgICBzZXRWYWx1ZShwcm9wZXJ0eSwgdmFsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuZmllbGRzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgLy8gRmllbGRzIGFyZSBqdXN0IHBsYWluIG9iamVjdCBtZW1iZXJzIGZvciB2YWx1ZXMsIGp1c3QgY29weTpcclxuICAgICAgICB2YXIgdmFsID0gbW9kZWxPYmpbZmllbGRdO1xyXG5cclxuICAgICAgICBzZXRWYWx1ZShmaWVsZCwgdmFsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwbGFpbjtcclxufTtcclxuXHJcbk1vZGVsLnByb3RvdHlwZS51cGRhdGVXaXRoID0gZnVuY3Rpb24gdXBkYXRlV2l0aChkYXRhLCBkZWVwQ29weSkge1xyXG4gICAgXHJcbiAgICAvLyBXZSBuZWVkIGEgcGxhaW4gb2JqZWN0IGZvciAnZnJvbUpTJy5cclxuICAgIC8vIElmIGlzIGEgbW9kZWwsIGV4dHJhY3QgdGhlaXIgcHJvcGVydGllcyBhbmQgZmllbGRzIGZyb21cclxuICAgIC8vIHRoZSBvYnNlcnZhYmxlcyAoZnJvbUpTKSwgc28gd2Ugbm90IGdldCBjb21wdXRlZFxyXG4gICAgLy8gb3IgZnVuY3Rpb25zLCBqdXN0IHJlZ2lzdGVyZWQgcHJvcGVydGllcyBhbmQgZmllbGRzXHJcbiAgICB2YXIgdGltZXN0YW1wID0gbnVsbDtcclxuICAgIGlmIChkYXRhICYmIGRhdGEubW9kZWwgaW5zdGFuY2VvZiBNb2RlbCkge1xyXG5cclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCB0aGUgc2FtZSB0aW1lc3RhbXAsIHNvXHJcbiAgICAgICAgLy8gcmVtZW1iZXIgZm9yIGFmdGVyIHRoZSBmcm9tSlNcclxuICAgICAgICB0aW1lc3RhbXAgPSBkYXRhLm1vZGVsLmRhdGFUaW1lc3RhbXAoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZXBsYWNlIGRhdGEgd2l0aCBhIHBsYWluIGNvcHkgb2YgaXRzZWxmXHJcbiAgICAgICAgZGF0YSA9IGRhdGEubW9kZWwudG9QbGFpbk9iamVjdChkZWVwQ29weSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRhcmdldCA9IHRoaXMubW9kZWxPYmplY3QsXHJcbiAgICAgICAgZGVmcyA9IHRoaXMucHJvcGVydGllc0RlZnM7XHJcbiAgICB0aGlzLnByb3BlcnRpZXNMaXN0LmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcclxuICAgICAgICB2YXIgdmFsID0gZGF0YVtwcm9wZXJ0eV0sXHJcbiAgICAgICAgICAgIGRlZiA9IGRlZnNbcHJvcGVydHldO1xyXG4gICAgICAgIGlmICh0eXBlb2YodmFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XShwcmVwYXJlVmFsdWVCeURlZih2YWwsIGRlZikpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGRlZnMgPSB0aGlzLmZpZWxkc0RlZnM7XHJcbiAgICB0aGlzLmZpZWxkc0xpc3QuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xyXG4gICAgICAgIHZhciB2YWwgPSBkYXRhW2ZpZWxkXSxcclxuICAgICAgICAgICAgZGVmID0gZGVmc1tmaWVsZF07XHJcbiAgICAgICAgaWYgKHR5cGVvZih2YWwpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0YXJnZXRbZmllbGRdID0gcHJlcGFyZVZhbHVlQnlEZWYodmFsLCBkZWYpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNhbWUgdGltZXN0YW1wIGlmIGFueVxyXG4gICAgaWYgKHRpbWVzdGFtcClcclxuICAgICAgICB0aGlzLm1vZGVsT2JqZWN0Lm1vZGVsLmRhdGFUaW1lc3RhbXAodGltZXN0YW1wKTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgR2l2ZW4gYSBwbGFpbiBvYmplY3QgaW4gYSBhY2NlcHRlZCBpbXBvcnQgc3RydWN0dXJlXHJcbiAgICAobmV2ZXIgYSBNb2RlbCBpbnN0YW5jZSksIGl0IG1hcHNcclxuICAgIHRoZSBkYXRhIHRvIHRoZSBvYmplY3QgZm9sbG93aW5nIGEgc2V0IG9mIG1hcHBpbmcgb3B0aW9uc1xyXG4gICAgb2Yga28ubWFwcGluZy5cclxuICAgIElmIHRoZSBkYXRhIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGJ5ICd0b1BsYWluT2JqZWN0J1xyXG4gICAgdGhlbiB1c2UgJ3VwZGF0ZVdpdGgnIGJldHRlci5cclxuICAgIFxyXG4gICAgVE9ETzogUmV2aWV3LCBub3QgdXNlZCBzdGlsbCwgbm8gc3VyZSBpZiByZWFsbHkgdXNlZnVsIHRvIGRlcGVuZFxyXG4gICAgb24ga28ubWFwcGluZyBhbmQgdGhpcy5cclxuKiovXHJcbk1vZGVsLnByb3RvdHlwZS5tYXBEYXRhID0gZnVuY3Rpb24gbWFwRGF0YShkYXRhLCBvcHRpb25hbE1hcHBpbmcpIHtcclxuICAgIGtvLm1hcHBpbmcuZnJvbUpTKGRhdGEsIG9wdGlvbmFsTWFwcGluZyB8fCB0aGlzLm1hcHBpbmdPcHRpb25zLCB0aGlzLm1vZGVsT2JqZWN0KTtcclxufTtcclxuXHJcbk1vZGVsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKGRhdGEsIGRlZXBDb3B5KSB7XHJcbiAgICAvLyBHZXQgYSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0IGRhdGFcclxuICAgIHZhciBwbGFpbiA9IHRoaXMudG9QbGFpbk9iamVjdChkZWVwQ29weSk7XHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgaW5zdGFuY2UsIHVzaW5nIHRoZSBzb3VyY2UgcGxhaW4gb2JqZWN0XHJcbiAgICAvLyBhcyBpbml0aWFsIHZhbHVlc1xyXG4gICAgdmFyIGNsb25lZCA9IG5ldyB0aGlzLm1vZGVsT2JqZWN0LmNvbnN0cnVjdG9yKHBsYWluKTtcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjbG9uZWQgd2l0aCB0aGUgcHJvdmlkZWQgcGxhaW4gZGF0YSB1c2VkXHJcbiAgICAgICAgLy8gdG8gcmVwbGFjZSB2YWx1ZXMgb24gdGhlIGNsb25lZCBvbmUsIGZvciBxdWljayBvbmUtc3RlcCBjcmVhdGlvblxyXG4gICAgICAgIC8vIG9mIGRlcml2ZWQgb2JqZWN0cy5cclxuICAgICAgICBjbG9uZWQubW9kZWwudXBkYXRlV2l0aChkYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIG5vIGluaXRpYWwgZGlmZmVyZW50aWFsIGRhdGEsIGVuc3VyZSB0aGVcclxuICAgICAgICAvLyBzYW1lIHRpbWVzdGFtcCBzaW5jZSB0aGUgY2xvbmUgaXMgc3RpbGwgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2VcclxuICAgICAgICBjbG9uZWQubW9kZWwuZGF0YVRpbWVzdGFtcCh0aGlzLm1vZGVsT2JqZWN0Lm1vZGVsLmRhdGFUaW1lc3RhbXAoKSk7XHJcbiAgICB9XHJcbiAgICAvLyBDbG9uZWQgbW9kZWwgcmVhZHk6XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBVcGRhdGVzIHRoZSBkYXRhVGltZXN0YW1wIHRvIHRoZSBjdXJyZW50IHVuaXF1ZSBkYXRldGltZSxcclxuICAgIHNvIHRoZSBtb2RlbCBhcHBlYXIgYXMgdG91Y2hlZC91cGRhdGVkLCBldmVuIGlmIG5vdCBkYXRhIGNoYW5nZS5cclxuICAgIFVzZWZ1bCBzb21ldGltZXMgdG8gbWFrZSBhIGRpZmZlcmVuY2UgZnJvbSBhIGNsb25lZCBpbnN0YW5jZVxyXG4gICAgc28gYXBwZWFyIGRpZmZlcmVudC5cclxuICAgIE5PVEU6IHRoZSBkYXRldGltZSBzZXQgaXMgbm90IGV4YWN0bHkgdGhlIGN1cnJlbnQgb25lLCBpcyB0aGUgY3VycmVudFxyXG4gICAgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBwbHVzIG9uZSxcclxuICAgIHRvIGVuc3VyZSB0aGF0IHRoZSB0aW1lc3RhbXAgaXMgZGlmZmVyZW50IG9uIGVkZ2UgY2FzZXMgd2hlcmUgdGhpc1xyXG4gICAgbWV0aG9kIGlzIGNhbGxlZCBqdXN0IGFmdGVyIGEgY3JlYXRpb24gb3IgY2xvbmF0aW9uLCBiZWNhdXNlIHRoZSB3YXlcclxuICAgIGphdmFzY3JpcHQgd29ya3MgYW5kIHRoZSBsaW1pdGVkIG1pbGxpc2Vjb25kcyBwcmVjaXNpb24gb2YgdGhlIERhdGUgb2JqZWN0XHJcbiAgICB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHRoZSAndG91Y2hlZCcgZGF0ZSB3aWxsIGJlIHRoZSBzYW1lIGFzIGJlZm9yZSxcclxuICAgIHRoYXRzIGF2b2lkZWQgd2l0aCB0aGlzIHNpbXBsZSB0cmljaywgc28gcmVtYWlucyAndW5pcXVlJyBpbiB0aGUgY3VycmVudCBleGVjdXRpb24uXHJcbioqL1xyXG5Nb2RlbC5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbiB0b3VjaCgpIHtcclxuICAgIC8vIFdlIHVzZSB0aGUgZnVuY3Rpb24gd2F5IHRvIGdldCBtaWxsaXNlY29uZHMsIGFkZCAxIGFuZCBjcmVhdGUgaW5zdGFuY2VcclxuICAgIHRoaXMuZGF0YVRpbWVzdGFtcChuZXcgRGF0ZShEYXRlKCkgKyAxKSk7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFJlcGxhY2VzIGFsbCB0aGUgcHJvcGVydGllcyBhbmQgZmllbGRzIGRhdGEgaW4gdGhlIG1vZGVsIG9iamVjdFxyXG4gICAgd2l0aCB0aGUgZGVmYXVsdCBvbmVzIG9mIHRoZSBjb25zdHJ1Y3RvciwgcGx1cyBvcHRpb25hbCBuZXcgcHJlc2V0IGRhdGEuXHJcbioqL1xyXG5Nb2RlbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldChwcmVzZXRzKSB7XHJcbiAgICBcclxuICAgIHZhciBuZXdJbnN0YW5jZSA9IG5ldyB0aGlzLm1vZGVsT2JqZWN0LmNvbnN0cnVjdG9yKHByZXNldHMpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlV2l0aChuZXdJbnN0YW5jZSwgdHJ1ZSk7XHJcbn07XHJcbiIsIi8qKiBQZXJmb3JtYW5jZVN1bW1hcnkgbW9kZWwgKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIExpc3RWaWV3SXRlbSA9IHJlcXVpcmUoJy4vTGlzdFZpZXdJdGVtJyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcclxuICAgIG51bWVyYWwgPSByZXF1aXJlKCdudW1lcmFsJyk7XHJcblxyXG5mdW5jdGlvbiBQZXJmb3JtYW5jZVN1bW1hcnkodmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xyXG4gICAgXHJcbiAgICAvLyBUT0RPOiBkZWZpbmUgZWFybmluZ3MgYW5kIHRpbWVCb29raW5nIGFzIHByb3BlcnRpZXMgd2l0aCBkZWYuTW9kZWw/XHJcblxyXG4gICAgdGhpcy5lYXJuaW5ncyA9IG5ldyBFYXJuaW5ncyh2YWx1ZXMuZWFybmluZ3MpO1xyXG4gICAgXHJcbiAgICB2YXIgZWFybmluZ3NMaW5lID0gbmV3IExpc3RWaWV3SXRlbSgpO1xyXG4gICAgZWFybmluZ3NMaW5lLm1hcmtlckxpbmUxID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG51bSA9IG51bWVyYWwodGhpcy5jdXJyZW50QW1vdW50KCkpLmZvcm1hdCgnJDAsMCcpO1xyXG4gICAgICAgIHJldHVybiBudW07XHJcbiAgICB9LCB0aGlzLmVhcm5pbmdzKTtcclxuICAgIGVhcm5pbmdzTGluZS5jb250ZW50TGluZTEgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29uY2VwdCgpO1xyXG4gICAgfSwgdGhpcy5lYXJuaW5ncyk7XHJcbiAgICBlYXJuaW5nc0xpbmUubWFya2VyTGluZTIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbnVtID0gbnVtZXJhbCh0aGlzLm5leHRBbW91bnQoKSkuZm9ybWF0KCckMCwwJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bTtcclxuICAgIH0sIHRoaXMuZWFybmluZ3MpO1xyXG4gICAgZWFybmluZ3NMaW5lLmNvbnRlbnRMaW5lMiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDb25jZXB0KCk7XHJcbiAgICB9LCB0aGlzLmVhcm5pbmdzKTtcclxuICAgIFxyXG5cclxuICAgIHRoaXMudGltZUJvb2tlZCA9IG5ldyBUaW1lQm9va2VkKHZhbHVlcy50aW1lQm9va2VkKTtcclxuXHJcbiAgICB2YXIgdGltZUJvb2tlZExpbmUgPSBuZXcgTGlzdFZpZXdJdGVtKCk7XHJcbiAgICB0aW1lQm9va2VkTGluZS5tYXJrZXJMaW5lMSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBudW0gPSBudW1lcmFsKHRoaXMucGVyY2VudCgpKS5mb3JtYXQoJzAlJyk7XHJcbiAgICAgICAgcmV0dXJuIG51bTtcclxuICAgIH0sIHRoaXMudGltZUJvb2tlZCk7XHJcbiAgICB0aW1lQm9va2VkTGluZS5jb250ZW50TGluZTEgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25jZXB0KCk7XHJcbiAgICB9LCB0aGlzLnRpbWVCb29rZWQpO1xyXG4gICAgXHJcbiAgICBcclxuICAgIHRoaXMuaXRlbXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlbXMucHVzaChlYXJuaW5nc0xpbmUpO1xyXG4gICAgICAgIGl0ZW1zLnB1c2godGltZUJvb2tlZExpbmUpO1xyXG5cclxuICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZXJmb3JtYW5jZVN1bW1hcnk7XHJcblxyXG5mdW5jdGlvbiBFYXJuaW5ncyh2YWx1ZXMpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgIFxyXG4gICAgICAgICBjdXJyZW50QW1vdW50OiAwLFxyXG4gICAgICAgICBjdXJyZW50Q29uY2VwdFRlbXBsYXRlOiAnYWxyZWFkeSBwYWlkIHRoaXMgbW9udGgnLFxyXG4gICAgICAgICBuZXh0QW1vdW50OiAwLFxyXG4gICAgICAgICBuZXh0Q29uY2VwdFRlbXBsYXRlOiAncHJvamVjdGVkIHttb250aH0gZWFybmluZ3MnXHJcblxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgdGhpcy5jdXJyZW50Q29uY2VwdCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIG1vbnRoID0gbW9tZW50KCkuZm9ybWF0KCdNTU1NJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudENvbmNlcHRUZW1wbGF0ZSgpLnJlcGxhY2UoL1xce21vbnRoXFx9LywgbW9udGgpO1xyXG5cclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMubmV4dENvbmNlcHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBtb250aCA9IG1vbWVudCgpLmFkZCgxLCAnbW9udGgnKS5mb3JtYXQoJ01NTU0nKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29uY2VwdFRlbXBsYXRlKCkucmVwbGFjZSgvXFx7bW9udGhcXH0vLCBtb250aCk7XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRpbWVCb29rZWQodmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICBcclxuICAgICAgICBwZXJjZW50OiAwLFxyXG4gICAgICAgIGNvbmNlcHRUZW1wbGF0ZTogJ29mIGF2YWlsYWJsZSB0aW1lIGJvb2tlZCBpbiB7bW9udGh9J1xyXG4gICAgXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmNvbmNlcHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBtb250aCA9IG1vbWVudCgpLmFkZCgxLCAnbW9udGgnKS5mb3JtYXQoJ01NTU0nKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25jZXB0VGVtcGxhdGUoKS5yZXBsYWNlKC9cXHttb250aFxcfS8sIG1vbnRoKTtcclxuXHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG4iLCIvKipcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIFByaWNpbmdFc3RpbWF0ZURldGFpbCA9IHJlcXVpcmUoJy4vUHJpY2luZ0VzdGltYXRlRGV0YWlsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFByaWNpbmdFc3RpbWF0ZSh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBwcmljaW5nRXN0aW1hdGVJRDogMCxcclxuICAgICAgICBwcmljaW5nRXN0aW1hdGVSZXZpc2lvbjogMCxcclxuICAgICAgICBzZXJ2aWNlRHVyYXRpb25Ib3VyczogbnVsbCxcclxuICAgICAgICBmaXJzdFNlc3Npb25EdXJhdGlvbkhvdXJzOiBudWxsLFxyXG4gICAgICAgIHN1YnRvdGFsUHJpY2U6IG51bGwsXHJcbiAgICAgICAgZmVlUHJpY2U6IG51bGwsXHJcbiAgICAgICAgdG90YWxQcmljZTogbnVsbCxcclxuICAgICAgICBwRmVlUHJpY2U6IG51bGwsXHJcbiAgICAgICAgc3VidG90YWxSZWZ1bmRlZDogbnVsbCxcclxuICAgICAgICBmZWVSZWZ1bmRlZDogbnVsbCxcclxuICAgICAgICB0b3RhbFJlZnVuZGVkOiBudWxsLFxyXG4gICAgICAgIGRhdGVSZWZ1bmRlZDogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBkZXRhaWxzOiB7XHJcbiAgICAgICAgICAgIE1vZGVsOiBQcmljaW5nRXN0aW1hdGVEZXRhaWwsXHJcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59O1xyXG4iLCIvKipcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUHJpY2luZ0VzdGltYXRlRGV0YWlsKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIGZyZWVsYW5jZXJQcmljaW5nSUQ6IDAsXHJcbiAgICAgICAgZnJlZWxhbmNlclByaWNpbmdEYXRhSW5wdXQ6IG51bGwsXHJcbiAgICAgICAgY3VzdG9tZXJQcmljaW5nRGF0YUlucHV0OiBudWxsLFxyXG4gICAgICAgIGhvdXJseVByaWNlOiBudWxsLFxyXG4gICAgICAgIHN1YnRvdGFsUHJpY2U6IG51bGwsXHJcbiAgICAgICAgZmVlUHJpY2U6IG51bGwsXHJcbiAgICAgICAgdG90YWxQcmljZTogbnVsbCxcclxuICAgICAgICBzZXJ2aWNlRHVyYXRpb25Ib3VyczogbnVsbCxcclxuICAgICAgICBmaXJzdFNlc3Npb25EdXJhdGlvbkhvdXJzOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxyXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59O1xyXG4iLCIvKipcclxuICAgIFByaWNpbmcgVHlwZSBtb2RlbFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gUHJpY2luZ1R5cGUodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIHByaWNpbmdUeXBlSUQ6IDAsXHJcbiAgICAgICAgc2luZ3VsYXJOYW1lOiAnJyxcclxuICAgICAgICBwbHVyYWxOYW1lOiAnJyxcclxuICAgICAgICBzbHVnTmFtZTogJycsXHJcbiAgICAgICAgYWRkTmV3TGFiZWw6IG51bGwsXHJcbiAgICAgICAgZnJlZWxhbmNlckRlc2NyaXB0aW9uOiBudWxsLFxyXG4gICAgICAgIC8vIFByaWNlQ2FsY3VsYXRpb25UeXBlIGVudW1lcmF0aW9uIHZhbHVlOlxyXG4gICAgICAgIHByaWNlQ2FsY3VsYXRpb246IG51bGwsXHJcbiAgICAgICAgaXNBZGRvbjogZmFsc2UsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRm9ybSBUZXh0c1xyXG4gICAgICAgIG5hbWVQbGFjZUhvbGRlcjogbnVsbCxcclxuICAgICAgICBzdWdnZXN0ZWROYW1lOiBudWxsLFxyXG4gICAgICAgIGZpeGVkTmFtZTogbnVsbCxcclxuICAgICAgICBkdXJhdGlvbkxhYmVsOiBudWxsLFxyXG4gICAgICAgIHByaWNlTGFiZWw6IG51bGwsXHJcbiAgICAgICAgcHJpY2VOb3RlOiBudWxsLFxyXG4gICAgICAgIGZpcnN0VGltZUNsaWVudHNPbmx5TGFiZWw6IG51bGwsXHJcbiAgICAgICAgZGVzY3JpcHRpb25QbGFjZUhvbGRlcjogbnVsbCxcclxuICAgICAgICBwcmljZVJhdGVRdWFudGl0eUxhYmVsOiBudWxsLFxyXG4gICAgICAgIHByaWNlUmF0ZVVuaXRMYWJlbDogbnVsbCxcclxuICAgICAgICBub1ByaWNlUmF0ZUxhYmVsOiBudWxsLFxyXG4gICAgICAgIG51bWJlck9mU2Vzc2lvbnNMYWJlbDogbnVsbCxcclxuICAgICAgICBpblBlcnNvblBob25lTGFiZWw6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWN0aW9uIEFuZCBWYWxpZGF0aW9uIFRleHRzXHJcbiAgICAgICAgc3VjY2Vzc09uRGVsZXRlOiBudWxsLFxyXG4gICAgICAgIGVycm9yT25EZWxldGU6IG51bGwsXHJcbiAgICAgICAgc3VjY2Vzc09uU2F2ZTogbnVsbCxcclxuICAgICAgICBlcnJvck9uU2F2ZTogbnVsbCxcclxuICAgICAgICBwcmljZVJhdGVJc1JlcXVpcmVkVmFsaWRhdGlvbkVycm9yOiBudWxsLFxyXG4gICAgICAgIHByaWNlUmF0ZVVuaXRJc1JlcXVpcmVkVmFsaWRhdGlvbkVycm9yOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEhlbHAgVGV4dHNcclxuICAgICAgICBsZWFybk1vcmVMYWJlbDogbnVsbCxcclxuICAgICAgICBsZWFybk1vcmVUZXh0OiBudWxsLFxyXG4gICAgICAgIHByaWNlUmF0ZUxlYXJuTW9yZUxhYmVsOiBudWxsLFxyXG4gICAgICAgIHByaWNlUmF0ZUxlYXJuTW9yZVRleHQ6IG51bGwsXHJcbiAgICAgICAgbm9QcmljZVJhdGVMZWFybk1vcmVMYWJlbDogbnVsbCxcclxuICAgICAgICBub1ByaWNlUmF0ZUxlYXJuTW9yZVRleHQ6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkaXRpb25hbCBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgcmVxdWlyZUR1cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICBpbmNsdWRlU2VydmljZUF0dHJpYnV0ZXM6IGZhbHNlLFxyXG4gICAgICAgIGluY2x1ZGVTcGVjaWFsUHJvbW90aW9uOiBmYWxzZSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBMaXN0IFRleHRzXHJcbiAgICAgICAgLy8vIFN1bW1hcnlGb3JtYXQgaXMgdGhlIGRlZmF1bHQgZm9ybWF0IGZvciBzdW1tYXJpZXMgKHJlcXVpcmVkKSxcclxuICAgICAgICAvLy8gb3RoZXIgZm9ybWF0cyBhcmUgZ29vZCBmb3IgYmV0dGVyIGRldGFpbCwgYnV0IGRlcGVuZHNcclxuICAgICAgICAvLy8gb24gb3RoZXIgb3B0aW9ucyBjb25maWd1cmVkIHBlciB0eXBlLlxyXG4gICAgICAgIC8vLyBXaWxkY2FyZHM6XHJcbiAgICAgICAgLy8vIHswfTogZHVyYXRpb25cclxuICAgICAgICAvLy8gezF9OiBzZXNzaW9uc1xyXG4gICAgICAgIC8vLyB7Mn06IGlucGVyc29uL3Bob25lXHJcbiAgICAgICAgc3VtbWFyeUZvcm1hdDogbnVsbCxcclxuICAgICAgICBzdW1tYXJ5Rm9ybWF0TXVsdGlwbGVTZXNzaW9uczogbnVsbCxcclxuICAgICAgICBzdW1tYXJ5Rm9ybWF0Tm9EdXJhdGlvbjogbnVsbCxcclxuICAgICAgICBzdW1tYXJ5Rm9ybWF0TXVsdGlwbGVTZXNzaW9uc05vRHVyYXRpb246IG51bGwsXHJcbiAgICAgICAgd2l0aG91dFNlcnZpY2VBdHRyaWJ1dGVzQ3VzdG9tZXJNZXNzYWdlOiBudWxsLFxyXG4gICAgICAgIHdpdGhvdXRTZXJ2aWNlQXR0cmlidXRlc0ZyZWVsYW5jZXJNZXNzYWdlOiBudWxsLFxyXG4gICAgICAgIGZpcnN0VGltZUNsaWVudHNPbmx5TGlzdFRleHQ6IG51bGwsXHJcbiAgICAgICAgcHJpY2VSYXRlUXVhbnRpdHlMaXN0TGFiZWw6IG51bGwsXHJcbiAgICAgICAgcHJpY2VSYXRlVW5pdExpc3RMYWJlbDogbnVsbCxcclxuICAgICAgICBub1ByaWNlUmF0ZUxpc3RNZXNzYWdlOiBudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEJvb2tpbmcvUHJpY2luZ0VzdGltYXRlIFRleHRzXHJcbiAgICAgICAgLy8vIE5hbWVBbmRTdW1tYXJ5Rm9ybWF0IGlzIHRoZSBkZWZhdWx0IGZvcm1hdCBmb3Igc3VtbWFyaWVzIHdpdGggcGFja2FnZSBuYW1lIChyZXF1aXJlZCksXHJcbiAgICAgICAgLy8vIG90aGVyIGZvcm1hdHMgYXJlIGdvb2QgZm9yIGJldHRlciBkZXRhaWwsIGJ1dCBkZXBlbmRzXHJcbiAgICAgICAgLy8vIG9uIG90aGVyIG9wdGlvbnMgY29uZmlndXJlZCBwZXIgdHlwZS5cclxuICAgICAgICAvLy8gV2lsZGNhcmRzOlxyXG4gICAgICAgIC8vLyB7MH06IHBhY2thZ2UgbmFtZVxyXG4gICAgICAgIC8vLyB7MX06IGR1cmF0aW9uXHJcbiAgICAgICAgLy8vIHsyfTogc2Vzc2lvbnNcclxuICAgICAgICAvLy8gezN9OiBpbnBlcnNvbi9waG9uZVxyXG4gICAgICAgIG5hbWVBbmRTdW1tYXJ5Rm9ybWF0OiBudWxsLFxyXG4gICAgICAgIG5hbWVBbmRTdW1tYXJ5Rm9ybWF0TXVsdGlwbGVTZXNzaW9uczogbnVsbCxcclxuICAgICAgICBuYW1lQW5kU3VtbWFyeUZvcm1hdE5vRHVyYXRpb246IG51bGwsXHJcbiAgICAgICAgbmFtZUFuZFN1bW1hcnlGb3JtYXRNdWx0aXBsZVNlc3Npb25zTm9EdXJhdGlvbjogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZWNvcmQgbWFpbnRlbmFuY2VcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZJRChbJ3ByaWNpbmdUeXBlSUQnXSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJpY2luZ1R5cGU7XHJcblxyXG4vLyBFbnVtZXJhdGlvbjpcclxudmFyIFByaWNlQ2FsY3VsYXRpb25UeXBlID0ge1xyXG4gICAgRml4ZWRQcmljZTogMSxcclxuICAgIEhvdXJseVByaWNlOiAyXHJcbn07XHJcblxyXG5QcmljaW5nVHlwZS5QcmljZUNhbGN1bGF0aW9uVHlwZSA9IFByaWNlQ2FsY3VsYXRpb25UeXBlO1xyXG4iLCIvKipcclxuICAgIFByaXZhY3lTZXR0aW5ncyBtb2RlbFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gUHJpdmFjeVNldHRpbmdzKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICB1c2VySUQ6IDAsXHJcbiAgICAgICAgc21zQm9va2luZ0NvbW11bmljYXRpb246IGZhbHNlLFxyXG4gICAgICAgIHBob25lQm9va2luZ0NvbW11bmljYXRpb246IGZhbHNlLFxyXG4gICAgICAgIGxvY29ub21pY3NDb21tdW5pdHlDb21tdW5pY2F0aW9uOiBmYWxzZSxcclxuICAgICAgICBsb2Nvbm9taWNzRGJtQ2FtcGFpZ25zOiBmYWxzZSxcclxuICAgICAgICBwcm9maWxlU2VvUGVybWlzc2lvbjogZmFsc2UsXHJcbiAgICAgICAgbG9jb25vbWljc01hcmtldGluZ0NhbXBhaWduczogZmFsc2UsXHJcbiAgICAgICAgY29CcmFuZGVkUGFydG5lclBlcm1pc3Npb25zOiBmYWxzZSxcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZJRChbJ3VzZXJJRCddKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcml2YWN5U2V0dGluZ3M7XHJcbiIsIi8qKlxyXG4gICAgU2NoZWR1bGluZ1ByZWZlcmVuY2VzIG1vZGVsLlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcclxuXHJcbmZ1bmN0aW9uIFNjaGVkdWxpbmdQcmVmZXJlbmNlcyh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBhZHZhbmNlVGltZTogMjQsIC8vIEhvdXJzXHJcbiAgICAgICAgYmV0d2VlblRpbWU6IDAsIC8vIEhvdXJzXHJcbiAgICAgICAgaW5jcmVtZW50c1NpemVJbk1pbnV0ZXM6IDE1XHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVkdWxpbmdQcmVmZXJlbmNlcztcclxuIiwiLyoqXHJcbiAgICBTaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUgbW9kZWwuXHJcbiAgICBcclxuICAgIEl0cyAnc2ltcGxpZmllZCcgYmVjYXVzZSBpdCBwcm92aWRlcyBhbiBBUElcclxuICAgIGZvciBzaW1wbGUgdGltZSByYW5nZSBwZXIgd2VlayBkYXksXHJcbiAgICBhIHBhaXIgb2YgZnJvbS10byB0aW1lcy5cclxuICAgIEdvb2QgZm9yIGN1cnJlbnQgc2ltcGxlIFVJLlxyXG4gICAgXHJcbiAgICBUaGUgb3JpZ2luYWwgd2Vla2x5IHNjaGVkdWxlIGRlZmluZXMgdGhlIHNjaGVkdWxlXHJcbiAgICBpbiAxNSBtaW51dGVzIHNsb3RzLCBzbyBtdWx0aXBsZSB0aW1lIHJhbmdlcyBjYW5cclxuICAgIGV4aXN0cyBwZXIgd2VlayBkYXksIGp1c3QgbWFya2luZyBlYWNoIHNsb3RcclxuICAgIGFzIGF2YWlsYWJsZSBvciB1bmF2YWlsYWJsZS4gVGhlIEFwcE1vZGVsXHJcbiAgICB3aWxsIGZpbGwgdGhpcyBtb2RlbCBpbnN0YW5jZXMgcHJvcGVybHkgbWFraW5nXHJcbiAgICBhbnkgY29udmVyc2lvbiBmcm9tL3RvIHRoZSBzb3VyY2UgZGF0YS5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyksXHJcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIFdlZWtEYXlTY2hlZHVsZSA9IHJlcXVpcmUoJy4vV2Vla0RheVNjaGVkdWxlJyk7XHJcblxyXG4vKipcclxuICAgIEl0IGF0dGVtcHMgdG8gbG9jYXRlIGxvY2FsL3N5c3RlbSB0aW1lem9uZSxcclxuICAgIGdldHRpbmcgdGhlIGZpcnN0IElBTkEgdHppZCB0aGF0IG1hdGNoZXMgXHJcbiAgICBsb2NhbCBzZXR1cC5cclxuKiovXHJcbmZ1bmN0aW9uIGRldGVjdExvY2FsVGltZXpvbmUoKSB7XHJcbiAgICB2YXIgeWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICB3aW50ZXIgPSBuZXcgRGF0ZSh5ZWFyLCAxLCAxKSxcclxuICAgICAgICB3aW5PZmYgPSB3aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKSxcclxuICAgICAgICBzdW1tZXIgPSBuZXcgRGF0ZSh5ZWFyLCA2LCAxKSxcclxuICAgICAgICBzdW1PZmYgPSBzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKSxcclxuICAgICAgICBmb3VuZCA9IG51bGw7XHJcblxyXG4gICAgbW9tZW50LnR6Lm5hbWVzKCkuc29tZShmdW5jdGlvbih0eikge1xyXG4gICAgICAgIHZhciB6b25lID0gbW9tZW50LnR6LnpvbmUodHopO1xyXG4gICAgICAgIGlmICh6b25lLm9mZnNldCh3aW50ZXIpID09PSB3aW5PZmYgJiZcclxuICAgICAgICAgICAgem9uZS5vZmZzZXQoc3VtbWVyKSA9PT0gc3VtT2ZmKSB7XHJcbiAgICAgICAgICAgZm91bmQgPSB6b25lO1xyXG4gICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBmb3VuZDtcclxufVxyXG5cclxuLyoqXHJcbiAgICBNYWluIG1vZGVsIGRlZmluaW5nIHRoZSB3ZWVrIHNjaGVkdWxlXHJcbiAgICBwZXIgd2VlayBkYXRlLCBvciBqdXN0IHNldCBhbGwgZGF5cyB0aW1lc1xyXG4gICAgYXMgYXZhaWxhYmxlIHdpdGggYSBzaW5nbGUgZmxhZy5cclxuKiovXHJcbmZ1bmN0aW9uIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBzdW5kYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICBtb25kYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICB0dWVzZGF5OiBuZXcgV2Vla0RheVNjaGVkdWxlKCksXHJcbiAgICAgICAgd2VkbmVzZGF5OiBuZXcgV2Vla0RheVNjaGVkdWxlKCksXHJcbiAgICAgICAgdGh1cnNkYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICBmcmlkYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcclxuICAgICAgICBzYXR1cmRheTogbmV3IFdlZWtEYXlTY2hlZHVsZSgpLFxyXG4gICAgICAgIGlzQWxsVGltZTogZmFsc2UsXHJcbiAgICAgICAgdGltZVpvbmU6ICcnXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICAvLyBJbmRleCBhY2Nlc3NcclxuICAgIHRoaXMud2Vla0RheXMgPSBbXHJcbiAgICAgICAgdGhpcy5zdW5kYXksXHJcbiAgICAgICAgdGhpcy5tb25kYXksXHJcbiAgICAgICAgdGhpcy50dWVzZGF5LFxyXG4gICAgICAgIHRoaXMud2VkbmVzZGF5LFxyXG4gICAgICAgIHRoaXMudGh1cnNkYXksXHJcbiAgICAgICAgdGhpcy5mcmlkYXksXHJcbiAgICAgICAgdGhpcy5zYXR1cmRheVxyXG4gICAgXTtcclxuICAgIFxyXG4gICAgdGhpcy50aW1lWm9uZURpc3BsYXlOYW1lID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHR6aWQgPSB0aGlzLnRpbWVab25lKCksXHJcbiAgICAgICAgICAgIHR6ID0gbW9tZW50LnR6KHR6aWQpLFxyXG4gICAgICAgICAgICBuYW1lID0gdHoudHooKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyAhbW9tZW50LnR6LnpvbmVFeGlzdHMsIGp1c3QgY2hlY2sgdGhlIG5hbWUgaXMgZW5vdWdoXHJcbiAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbHR6ID0gZGV0ZWN0TG9jYWxUaW1lem9uZSgpO1xyXG4gICAgICAgICAgICBpZiAobG9jYWx0eilcclxuICAgICAgICAgICAgICAgIHR6ID0gbW9tZW50LnR6KGxvY2FsdHoubmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh0eilcclxuICAgICAgICAgICAgICAgIG5hbWUgPSB0ei50eigpO1xyXG4gICAgICAgICAgICBpZiAobmFtZSlcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lWm9uZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZSlcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7IC8vICsgJyAoJyArIHR6LnpvbmVBYmJyKCkgKyAnKSc7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGU7XHJcbiIsIi8qKiBUaHJlYWQgbW9kZWwuXHJcblxyXG4gICAgRGVzY3JpYmVzIGEgdGhyZWFkIG9mIG1lc3NhZ2VzLlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIE1lc3NhZ2UgPSByZXF1aXJlKCcuL01lc3NhZ2UnKTtcclxuXHJcbmZ1bmN0aW9uIFRocmVhZCh2YWx1ZXMpIHtcclxuICAgIFxyXG4gICAgTW9kZWwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICB0aHJlYWRJRDogMCxcclxuICAgICAgICBcclxuICAgICAgICBjdXN0b21lclVzZXJJRDogbnVsbCxcclxuICAgICAgICBmcmVlbGFuY2VyVXNlcklEOiBudWxsLFxyXG4gICAgICAgIGpvYlRpdGxlSUQ6IG51bGwsXHJcbiAgICAgICAgc3RhdHVzSUQ6IG51bGwsXHJcbiAgICAgICAgc3ViamVjdDogbnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBtZXNzYWdlczoge1xyXG4gICAgICAgICAgICBpc0FycmF5OiB0cnVlLFxyXG4gICAgICAgICAgICBNb2RlbDogTWVzc2FnZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwgICAgICAgIFxyXG4gICAgfSwgdmFsdWVzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaHJlYWQ7XHJcbiIsIi8qKiBVcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeSBtb2RlbCAqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxyXG4gICAgQm9va2luZ1N1bW1hcnkgPSByZXF1aXJlKCcuL0Jvb2tpbmdTdW1tYXJ5Jyk7XHJcblxyXG5mdW5jdGlvbiBVcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeSgpIHtcclxuXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgLy8gVE9ETzogZGVmaW5lIHRvZGF5LCB0b21vcnJvdyBhbmQgbmV4dFdlZWsgYXNcclxuICAgIC8vIHByb3BlcnRpZXMgd2l0aCBkZWZhdWx0IE1vZGVsP1xyXG4gICAgLy8gUmV2aWV3IGhvdyB1cGRhdGUgaGFwcGVucyBvbiBob21lL2Rhc2hib2FyZCwgaXQgY2FuIGhlbHBzXHJcbiAgICAvLyB0byBzaW1wbGlmeSB0aGF0XHJcblxyXG4gICAgdGhpcy50b2RheSA9IG5ldyBCb29raW5nU3VtbWFyeSh7XHJcbiAgICAgICAgY29uY2VwdDogJ21vcmUgdG9kYXknLFxyXG4gICAgICAgIHRpbWVGb3JtYXQ6ICcgW2VuZGluZyBAXSBoOm1tYSdcclxuICAgIH0pO1xyXG4gICAgdGhpcy50b21vcnJvdyA9IG5ldyBCb29raW5nU3VtbWFyeSh7XHJcbiAgICAgICAgY29uY2VwdDogJ3RvbW9ycm93JyxcclxuICAgICAgICB0aW1lRm9ybWF0OiAnIFtzdGFydGluZyBAXSBoOm1tYSdcclxuICAgIH0pO1xyXG4gICAgdGhpcy5uZXh0V2VlayA9IG5ldyBCb29raW5nU3VtbWFyeSh7XHJcbiAgICAgICAgY29uY2VwdDogJ25leHQgd2VlaycsXHJcbiAgICAgICAgdGltZUZvcm1hdDogbnVsbFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRoaXMuaXRlbXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9pZiAodGhpcy50b2RheS5xdWFudGl0eSgpKVxyXG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy50b2RheSk7XHJcbiAgICAgICAgLy9pZiAodGhpcy50b21vcnJvdy5xdWFudGl0eSgpKVxyXG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy50b21vcnJvdyk7XHJcbiAgICAgICAgLy9pZiAodGhpcy5uZXh0V2Vlay5xdWFudGl0eSgpKVxyXG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy5uZXh0V2Vlayk7XHJcblxyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXBjb21pbmdCb29raW5nc1N1bW1hcnk7XHJcbiIsIi8qKiBVc2VyIG1vZGVsICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxyXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XHJcblxyXG4vLyBFbnVtIFVzZXJUeXBlXHJcbnZhciBVc2VyVHlwZSA9IHtcclxuICAgIE5vbmU6IDAsXHJcbiAgICBBbm9ueW1vdXM6IDEsXHJcbiAgICBDdXN0b21lcjogMixcclxuICAgIEZyZWVsYW5jZXI6IDQsXHJcbiAgICBBZG1pbjogOCxcclxuICAgIExvZ2dlZFVzZXI6IDE0LFxyXG4gICAgVXNlcjogMTUsXHJcbiAgICBTeXN0ZW06IDE2XHJcbn07XHJcblxyXG5mdW5jdGlvbiBVc2VyKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICB1c2VySUQ6IDAsXHJcbiAgICAgICAgZW1haWw6ICcnLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGZpcnN0TmFtZTogJycsXHJcbiAgICAgICAgbGFzdE5hbWU6ICcnLFxyXG4gICAgICAgIHNlY29uZExhc3ROYW1lOiAnJyxcclxuICAgICAgICBidXNpbmVzc05hbWU6ICcnLFxyXG4gICAgICAgIFxyXG4gICAgICAgIGFsdGVybmF0aXZlRW1haWw6ICcnLFxyXG4gICAgICAgIHBob25lOiAnJyxcclxuICAgICAgICBjYW5SZWNlaXZlU21zOiAnJyxcclxuICAgICAgICBiaXJ0aE1vbnRoRGF5OiBudWxsLFxyXG4gICAgICAgIGJpcnRoTW9udGg6IG51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgaXNGcmVlbGFuY2VyOiBmYWxzZSxcclxuICAgICAgICBpc0N1c3RvbWVyOiBmYWxzZSxcclxuICAgICAgICBpc01lbWJlcjogZmFsc2UsXHJcbiAgICAgICAgaXNBZG1pbjogZmFsc2UsXHJcblxyXG4gICAgICAgIG9uYm9hcmRpbmdTdGVwOiBudWxsLFxyXG4gICAgICAgIGFjY291bnRTdGF0dXNJRDogMCxcclxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxyXG4gICAgfSwgdmFsdWVzKTtcclxuXHJcbiAgICB0aGlzLmZ1bGxOYW1lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBuYW1lUGFydHMgPSBbdGhpcy5maXJzdE5hbWUoKV07XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdE5hbWUoKSlcclxuICAgICAgICAgICAgbmFtZVBhcnRzLnB1c2godGhpcy5sYXN0TmFtZSgpKTtcclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRMYXN0TmFtZSgpKVxyXG4gICAgICAgICAgICBuYW1lUGFydHMucHVzaCh0aGlzLnNlY29uZExhc3ROYW1lKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmFtZVBhcnRzLmpvaW4oJyAnKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmJpcnRoRGF5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJpcnRoTW9udGhEYXkoKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmJpcnRoTW9udGgoKSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVE9ETyBpMTBuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpcnRoTW9udGgoKSArICcvJyArIHRoaXMuYmlydGhNb250aERheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMudXNlclR5cGUgPSBrby5wdXJlQ29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuaXNDdXN0b21lcigpLFxyXG4gICAgICAgICAgICAgICAgcCA9IHRoaXMuaXNGcmVlbGFuY2VyKCksXHJcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5pc0FkbWluKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgdXNlclR5cGUgPSAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbm9ueW1vdXMoKSlcclxuICAgICAgICAgICAgICAgIHVzZXJUeXBlID0gdXNlclR5cGUgfCBVc2VyVHlwZS5Bbm9ueW1vdXM7XHJcbiAgICAgICAgICAgIGlmIChjKVxyXG4gICAgICAgICAgICAgICAgdXNlclR5cGUgPSB1c2VyVHlwZSB8IFVzZXJUeXBlLkN1c3RvbWVyO1xyXG4gICAgICAgICAgICBpZiAocClcclxuICAgICAgICAgICAgICAgIHVzZXJUeXBlID0gdXNlclR5cGUgfCBVc2VyVHlwZS5GcmVlbGFuY2VyO1xyXG4gICAgICAgICAgICBpZiAoYSlcclxuICAgICAgICAgICAgICAgIHVzZXJUeXBlID0gdXNlclR5cGUgfCBVc2VyVHlwZS5BZG1pbjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyVHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qIE5PVEU6IE5vdCByZXF1aXJlZCBmb3Igbm93OlxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgfSwqL1xyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0Fub255bW91cyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJJRCgpIDwgMTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBJdCBtYXRjaGVzIGEgVXNlclR5cGUgZnJvbSB0aGUgZW51bWVyYXRpb24/XHJcbiAgICAqKi9cclxuICAgIHRoaXMuaXNVc2VyVHlwZSA9IGZ1bmN0aW9uIGlzVXNlclR5cGUodHlwZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy51c2VyVHlwZSgpICYgdHlwZSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXNlcjtcclxuXHJcblVzZXIuVXNlclR5cGUgPSBVc2VyVHlwZTtcclxuXHJcbi8qIENyZWF0aW50IGFuIGFub255bW91cyB1c2VyIHdpdGggc29tZSBwcmVzc2V0cyAqL1xyXG5Vc2VyLm5ld0Fub255bW91cyA9IGZ1bmN0aW9uIG5ld0Fub255bW91cygpIHtcclxuICAgIHJldHVybiBuZXcgVXNlcih7XHJcbiAgICAgICAgdXNlcklEOiAwLFxyXG4gICAgICAgIGVtYWlsOiAnJyxcclxuICAgICAgICBmaXJzdE5hbWU6ICcnLFxyXG4gICAgICAgIG9uYm9hcmRpbmdTdGVwOiBudWxsXHJcbiAgICB9KTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBVc2VySm9iVGl0bGUgbW9kZWwsIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGFuIHVzZXIgYW5kIGFcclxuICAgIGpvYiB0aXRsZSBhbmQgdGhlIG1haW4gZGF0YSBhdHRhY2hlZCB0byB0aGF0IHJlbGF0aW9uLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gVXNlckpvYlRpdGxlKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICB1c2VySUQ6IDAsXHJcbiAgICAgICAgam9iVGl0bGVJRDogMCxcclxuICAgICAgICBpbnRybzogbnVsbCxcclxuICAgICAgICBzdGF0dXNJRDogMCxcclxuICAgICAgICBjYW5jZWxsYXRpb25Qb2xpY3lJRDogMCxcclxuICAgICAgICBpbnN0YW50Qm9va2luZzogZmFsc2UsXHJcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmSUQoWyd1c2VySUQnLCAnam9iVGl0bGVJRCddKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBVc2VySm9iVGl0bGU7XHJcbiIsIi8qKlxyXG4gICAgRW51bWVyYXRpb24gb2YgcG9zc2libGUgdmFsdWVzIGZvciBWb2NFbGVtZW50SURzLCBcclxuICAgIHVzZWQgdG8gaWRlbnRpZnkgc2VjdGlvbnMvY29tcG9uZW50cyB3aGVuIHNlbmRpbmcgRmVlZGJhY2suXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdlbmVyYWw6IDAsXHJcbiAgICBucHM6IDEsXHJcbiAgICBzaWdudXA6IDIsXHJcbiAgICBjYWxlbmRhcjogMyxcclxuICAgIGluYm94OiA0LFxyXG4gICAgc2NoZWR1bGluZzogNSxcclxuICAgIGNtczogNixcclxuICAgIHBheW1lbnRzOiA3LFxyXG4gICAgcGVyZm9ybWFuY2U6IDgsXHJcbiAgICBtYXJrZXRwbGFjZVByb2ZpbGU6IDksXHJcbiAgICBtb2JpbGVGcmllbmRseTogMTAsIC8vIGVhc3kgb2YgdXNpbmcgbW9iaWxlL3RhYmxldCBhcHAvd2ViXHJcbiAgICBkZXNrdG9wRnJpZW5kbHk6IDExLCAvLyBlYXN5IG9mIHVzaW5nIGRlc2t0b3Agd2Vic2l0ZVxyXG4gICAgY29vcEJlbmVmaXRzOiAxMixcclxuICAgIGNvb3BGZWU6IDEzLFxyXG4gICAgc2Vuc2VPZkNvbW11bml0eTogMTQsXHJcbiAgICBjdXN0b21lclNlcnZpY2VBZ2VudHM6IDE1LFxyXG4gICAgaGVscFBhZ2VzOiAxNlxyXG59O1xyXG4iLCIvKipcclxuICAgIFN1Ym1vZGVsIHRoYXQgaXMgdXNlZCBvbiB0aGUgU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlXHJcbiAgICBkZWZpbmluZyBhIHNpbmdsZSB3ZWVrIGRheSBhdmFpbGFiaWxpdHkgcmFuZ2UuXHJcbiAgICBBIGZ1bGwgZGF5IG11c3QgaGF2ZSB2YWx1ZXMgZnJvbTowIHRvOjE0NDAsIG5ldmVyXHJcbiAgICBib3RoIGFzIHplcm8gYmVjYXVzZSB0aGF0cyBjb25zaWRlcmVkIGFzIG5vdCBhdmFpbGFibGUsXHJcbiAgICBzbyBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBpc0FsbERheSBwcm9wZXJ0eS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxuZnVuY3Rpb24gV2Vla0RheVNjaGVkdWxlKHZhbHVlcykge1xyXG5cclxuICAgIE1vZGVsKHRoaXMpO1xyXG5cclxuICAgIC8vIE5PVEU6IGZyb20tdG8gcHJvcGVyaWVzIGFzIG51bWJlcnNcclxuICAgIC8vIGZvciB0aGUgbWludXRlIG9mIHRoZSBkYXksIGZyb20gMCAoMDA6MDApIHRvIDE0MzkgKDIzOjU5KVxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBmcm9tOiAwLFxyXG4gICAgICAgIHRvOiAwXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBJdCBhbGxvd3MgdG8ga25vdyBpZiB0aGlzIHdlZWsgZGF5IGlzIFxyXG4gICAgICAgIGVuYWJsZWQgZm9yIHdlZWtseSBzY2hlZHVsZSwganVzdCBpdFxyXG4gICAgICAgIGhhcyBmcm9tLXRvIHRpbWVzLlxyXG4gICAgICAgIEl0IGFsbG93cyB0byBiZSBzZXQgYXMgdHJ1ZSBwdXR0aW5nXHJcbiAgICAgICAgYSBkZWZhdWx0IHJhbmdlICg5YS01cCkgb3IgZmFsc2UgXHJcbiAgICAgICAgc2V0dGluZyBib3RoIGFzIDBwLlxyXG4gICAgICAgIFxyXG4gICAgICAgIFNpbmNlIG9uIHdyaXRlIHR3byBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgbW9kaWZpZWQsIGFuZFxyXG4gICAgICAgIGJvdGggYXJlIHVzZWQgaW4gdGhlIHJlYWQsIGEgc2luZ2xlIGNoYW5nZSB0byB0aGUgXHJcbiAgICAgICAgdmFsdWUgd2lsbCB0cmlnZ2VyIHR3byBub3RpZmljYXRpb25zOyB0byBhdm9pZCB0aGF0LFxyXG4gICAgICAgIHRoZSBvYnNlcnZhYmxlIGlzIHJhdGUgbGltaXRlZCB3aXRoIGFuIGlubWVkaWF0ZSB2YWx1ZSxcclxuICAgICAgICBzb24gb25seSBvbmUgbm90aWZpY2F0aW9uIGlzIHJlY2VpdmVkLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLmlzRW5hYmxlZCA9IGtvLmNvbXB1dGVkKHtcclxuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIHR5cGVvZih0aGlzLmZyb20oKSkgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YodGhpcy50bygpKSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSgpIDwgdGhpcy50bygpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgcmFuZ2UgOWEgLSA1cFxyXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tSG91cig5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9Ib3VyKDE3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9Ib3VyKDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvd25lcjogdGhpc1xyXG4gICAgfSkuZXh0ZW5kKHsgcmF0ZUxpbWl0OiAwIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzQWxsRGF5ID0ga28uY29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIChcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSgpID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvKCkgPT09IDE0NDBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbigvKnZhbCovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbSgwKTtcclxuICAgICAgICAgICAgdGhpcy50bygxNDQwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KS5leHRlbmQoeyByYXRlTGltaXQ6IDAgfSk7XHJcbiAgICBcclxuICAgIC8vIEFkZGl0aW9uYWwgaW50ZXJmYWNlcyB0byBnZXQvc2V0IHRoZSBmcm9tL3RvIHRpbWVzXHJcbiAgICAvLyBieSB1c2luZyBhIGRpZmZlcmVudCBkYXRhIHVuaXQgb3IgZm9ybWF0LlxyXG4gICAgXHJcbiAgICAvLyBJbnRlZ2VyLCByb3VuZGVkLXVwLCBudW1iZXIgb2YgaG91cnNcclxuICAgIHRoaXMuZnJvbUhvdXIgPSBrby5jb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZnJvbSgpIC8gNjApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGhvdXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbSgoaG91cnMgKiA2MCkgfDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3duZXI6IHRoaXNcclxuICAgIH0pO1xyXG4gICAgdGhpcy50b0hvdXIgPSBrby5jb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy50bygpIC8gNjApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGhvdXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG8oKGhvdXJzICogNjApIHwwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gU3RyaW5nLCB0aW1lIGZvcm1hdCAoJ2hoOm1tJylcclxuICAgIHRoaXMuZnJvbVRpbWUgPSBrby5jb21wdXRlZCh7XHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaW51dGVzVG9UaW1lU3RyaW5nKHRoaXMuZnJvbSgpIHwwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbih0aW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbSh0aW1lU3RyaW5nVG9NaW51dGVzKHRpbWUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxuICAgIHRoaXMudG9UaW1lID0ga28uY29tcHV0ZWQoe1xyXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWludXRlc1RvVGltZVN0cmluZyh0aGlzLnRvKCkgfDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKHRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy50byh0aW1lU3RyaW5nVG9NaW51dGVzKHRpbWUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG93bmVyOiB0aGlzXHJcbiAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWVrRGF5U2NoZWR1bGU7XHJcblxyXG4vLy8vIFVUSUxTLFxyXG4vLyBUT0RPIE9yZ2FuaXplIG9yIGV4dGVybmFsaXplLiBzb21lIGNvcGllZCBmb3JtIGFwcG1vZGVsLi5cclxuLyoqXHJcbiAgICBpbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uICd0byBzdHJpbmcgd2l0aCB0d28gZGlnaXRzIGFsbW9zdCdcclxuKiovXHJcbmZ1bmN0aW9uIHR3b0RpZ2l0cyhuKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihuIC8gMTApICsgJycgKyBuICUgMTA7XHJcbn1cclxuXHJcbi8qKlxyXG4gICAgQ29udmVydCBhIG51bWJlciBvZiBtaW51dGVzXHJcbiAgICBpbiBhIHN0cmluZyBsaWtlOiAwMDowMDowMCAoaG91cnM6bWludXRlczpzZWNvbmRzKVxyXG4qKi9cclxuZnVuY3Rpb24gbWludXRlc1RvVGltZVN0cmluZyhtaW51dGVzKSB7XHJcbiAgICB2YXIgZCA9IG1vbWVudC5kdXJhdGlvbihtaW51dGVzLCAnbWludXRlcycpLFxyXG4gICAgICAgIGggPSBkLmhvdXJzKCksXHJcbiAgICAgICAgbSA9IGQubWludXRlcygpLFxyXG4gICAgICAgIHMgPSBkLnNlY29uZHMoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICB0d29EaWdpdHMoaCkgKyAnOicgK1xyXG4gICAgICAgIHR3b0RpZ2l0cyhtKSArICc6JyArXHJcbiAgICAgICAgdHdvRGlnaXRzKHMpXHJcbiAgICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aW1lU3RyaW5nVG9NaW51dGVzKHRpbWUpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24odGltZSkuYXNNaW51dGVzKCkgfDA7XHJcbn0iLCIvKipcclxuICAgIFV0aWxpdHkgdG8gaGVscCB0cmFjayB0aGUgc3RhdGUgb2YgY2FjaGVkIGRhdGFcclxuICAgIG1hbmFnaW5nIHRpbWUsIHByZWZlcmVuY2UgYW5kIGlmIG11c3QgYmUgcmV2YWxpZGF0ZWRcclxuICAgIG9yIG5vdC5cclxuICAgIFxyXG4gICAgSXRzIGp1c3QgbWFuYWdlcyBtZXRhIGRhdGEsIGJ1dCBub3QgdGhlIGRhdGEgdG8gYmUgY2FjaGVkLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuZnVuY3Rpb24gQ2FjaGVDb250cm9sKG9wdGlvbnMpIHtcclxuICAgIFxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLy8gQSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yXHJcbiAgICAvLyBBbiBvYmplY3Qgd2l0aCBkZXNpcmVkIHVuaXRzIGFuZCBhbW91bnQsIGFsbCBvcHRpb25hbCxcclxuICAgIC8vIGFueSBjb21iaW5hdGlvbiB3aXRoIGFsbW9zdCBvbmUgc3BlY2lmaWVkLCBzYW1wbGU6XHJcbiAgICAvLyB7IHllYXJzOiAwLCBtb250aHM6IDAsIHdlZWtzOiAwLCBcclxuICAgIC8vICAgZGF5czogMCwgaG91cnM6IDAsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9XHJcbiAgICB0aGlzLnR0bCA9IG1vbWVudC5kdXJhdGlvbihvcHRpb25zLnR0bCkuYXNNaWxsaXNlY29uZHMoKTtcclxuICAgIHRoaXMubGF0ZXN0ID0gb3B0aW9ucy5sYXRlc3QgfHwgbnVsbDtcclxuXHJcbiAgICB0aGlzLm11c3RSZXZhbGlkYXRlID0gZnVuY3Rpb24gbXVzdFJldmFsaWRhdGUoKSB7XHJcbiAgICAgICAgdmFyIHRkaWZmID0gdGhpcy5sYXRlc3QgJiYgbmV3IERhdGUoKSAtIHRoaXMubGF0ZXN0IHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICByZXR1cm4gdGRpZmYgPiB0aGlzLnR0bDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMudG91Y2ggPSBmdW5jdGlvbiB0b3VjaCgpIHtcclxuICAgICAgICB0aGlzLmxhdGVzdCA9IG5ldyBEYXRlKCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhY2hlQ29udHJvbDtcclxuIiwiLyoqXHJcbiAgICBLZWVwIGFuIGluIG1lbW9yeSBjYWNoZSBvZiBkYXRhIG9yZ2FuaXplZCBieSBkYXRlIGFzIGtleS12YWx1ZS5cclxuICAgIFxyXG4gICAgSU1QT1JUQU5UOiBEYXRlIHdpdGhvdXQgdGltZSwgaW4gSVNPIGZvcm1hdCBZWVlZLU1NLURELCB1c2luZ1xyXG4gICAgbG9jYWwgdGltZXpvbmUuIEEgY2hhbmdlIG9mIHRpbWV6b25lIGRpc3BsYXllZCB0byB0aGUgdXNlciBtdXN0XHJcbiAgICBpbnZhbGlkYXRlIHRoZSBjYWNoZSAodGhyb3VnaCAuY2xlYXIoKSkuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXHJcbiAgICBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuL0NhY2hlQ29udHJvbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEYXRlQ2FjaGUoc2V0dGluZ3MpIHtcclxuICAgIFxyXG4gICAgdGhpcy5Nb2RlbCA9IHNldHRpbmdzICYmIHNldHRpbmdzLk1vZGVsIHx8IG51bGw7XHJcbiAgICB0aGlzLnR0bCA9IHNldHRpbmdzICYmIHNldHRpbmdzLnR0bCB8fCB7IG1pbnV0ZXM6IDEgfTtcclxuICAgIFxyXG4gICAgdGhpcy5ieURhdGUgPSB7fTtcclxuICAgIFxyXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYnlEYXRlID0ge307XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldFNpbmdsZSA9IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgICB2YXIgZGF0ZUtleSA9IGRhdGU7XHJcbiAgICAgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKVxyXG4gICAgICAgICAgICBkYXRlS2V5ID0gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLmJ5RGF0ZS5oYXNPd25Qcm9wZXJ0eShkYXRlS2V5KSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5ieURhdGVbZGF0ZUtleV0uY29udHJvbC5tdXN0UmV2YWxpZGF0ZSgpKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieURhdGVbZGF0ZUtleV0uZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbihkYXRlKSB7XHJcbiAgICAgICAgdmFyIGRhdGVLZXkgPSBkYXRlO1xyXG4gICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgICAgICAgZGF0ZUtleSA9IG1vbWVudChkYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5ieURhdGVbZGF0ZUtleV07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdGFydCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdHNQZXJEYXRlID0ge30sXHJcbiAgICAgICAgICAgIGhvbGVzID0gW10sXHJcbiAgICAgICAgICAgIG1pblJlcXVlc3QgPSBudWxsLFxyXG4gICAgICAgICAgICBtYXhSZXF1ZXN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGRhdGUgPD0gZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRlS2V5ID0gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnlEYXRlLmhhc093blByb3BlcnR5KGRhdGVLZXkpICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5ieURhdGVbZGF0ZUtleV0uY29udHJvbC5tdXN0UmV2YWxpZGF0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzUGVyRGF0ZVtkYXRlS2V5XSA9IHRoaXMuYnlEYXRlW2RhdGVLZXldLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBob2xlcy5wdXNoKG5ldyBEYXRlKGRhdGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBOZXh0IGRhdGU6XHJcbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBTb3J0IGhvbGVzXHJcbiAgICAgICAgaG9sZXMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID09PSBiID8gMCA6IGEgPCBiID8gLTEgOiAxOyB9KTtcclxuICAgICAgICAvLyBtaW4gaG9sZSBpcyB0aGUgZmlyc3Qgb25lXHJcbiAgICAgICAgbWluUmVxdWVzdCA9IGhvbGVzLmxlbmd0aCA/IGhvbGVzWzBdIDogbnVsbDtcclxuICAgICAgICAvLyBtYXggaG9sZSBpcyB0aGUgbGFzdCBvbmVcclxuICAgICAgICBtYXhSZXF1ZXN0ID0gaG9sZXMubGVuZ3RoID8gaG9sZXNbaG9sZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJ5RGF0ZTogcmVzdWx0c1BlckRhdGUsXHJcbiAgICAgICAgICAgIGhvbGVzOiBob2xlcyxcclxuICAgICAgICAgICAgbWluSG9sZTogbWluUmVxdWVzdCxcclxuICAgICAgICAgICAgbWF4SG9sZTogbWF4UmVxdWVzdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uKGRhdGUsIGRhdGEpIHtcclxuICAgICAgICAvLyBEYXRlIGZvcm1hdHRpbmcuIFByb3ZpZGUgYSBmb3JtYXR0ZWQgZGF0ZSBhcyBzdHJpbmcgaXMgdmFsaWQgdG9vXHJcbiAgICAgICAgdmFyIGRhdGVLZXkgPSBkYXRlO1xyXG4gICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgICAgICAgZGF0ZUtleSA9IG1vbWVudChkYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgY2FjaGVcclxuICAgICAgICB2YXIgYyA9IHRoaXMuYnlEYXRlW2RhdGVLZXldO1xyXG4gICAgICAgIGlmIChjICYmIGMuZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5Nb2RlbClcclxuICAgICAgICAgICAgICAgIGMuZGF0YS5tb2RlbC51cGRhdGVXaXRoKGRhdGEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBjLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYyA9IHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuTW9kZWwgPyBuZXcgdGhpcy5Nb2RlbChkYXRhKSA6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBjb250cm9sOiBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiB0aGlzLnR0bCB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmJ5RGF0ZVtkYXRlS2V5XSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGMuY29udHJvbC50b3VjaCgpO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBOZXcgRnVuY3Rpb24gbWV0aG9kOiAnX2RlbGF5ZWQnLlxyXG4gICAgSXQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiwgd3JhcHBpbmcgdGhlIG9yaWdpbmFsIG9uZSxcclxuICAgIHRoYXQgb25jZSBpdHMgY2FsbCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gdGhlIGdpdmVuIG1pbGxpc2Vjb25kcyxcclxuICAgIHVzaW5nIGEgc2V0VGltZW91dC5cclxuICAgIFRoZSBuZXcgZnVuY3Rpb24gcmV0dXJucyAndW5kZWZpbmVkJyBzaW5jZSBpdCBoYXMgbm90IHRoZSByZXN1bHQsXHJcbiAgICBiZWNhdXNlIG9mIHRoYXQgaXMgb25seSBzdWl0YWJsZSB3aXRoIHJldHVybi1mcmVlIGZ1bmN0aW9ucyBcclxuICAgIGxpa2UgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICBcclxuICAgIFdoeTogc29tZXRpbWVzLCB0aGUgaGFuZGxlciBmb3IgYW4gZXZlbnQgbmVlZHMgdG8gYmUgZXhlY3V0ZWRcclxuICAgIGFmdGVyIGEgZGVsYXkgaW5zdGVhZCBvZiBpbnN0YW50bHkuXHJcbioqL1xyXG5GdW5jdGlvbi5wcm90b3R5cGUuX2RlbGF5ZWQgPSBmdW5jdGlvbiBkZWxheWVkKG1pbGxpc2Vjb25kcykge1xyXG4gICAgdmFyIGZuID0gdGhpcztcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH0sIG1pbGxpc2Vjb25kcyk7XHJcbiAgICB9O1xyXG59O1xyXG4iLCIvKipcclxuICAgIEV4dGVuZGluZyB0aGUgRnVuY3Rpb24gY2xhc3Mgd2l0aCBhbiBpbmhlcml0cyBtZXRob2QuXHJcbiAgICBcclxuICAgIFRoZSBpbml0aWFsIGxvdyBkYXNoIGlzIHRvIG1hcmsgaXQgYXMgbm8tc3RhbmRhcmQuXHJcbioqL1xyXG5GdW5jdGlvbi5wcm90b3R5cGUuX2luaGVyaXRzID0gZnVuY3Rpb24gX2luaGVyaXRzKHN1cGVyQ3Rvcikge1xyXG4gICAgdGhpcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcyxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBGaXggRnVuY3Rpb24jbmFtZSBvbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0IChJRTkrKTpcclxuICAgIFxyXG4gICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTcwNTY1MzAvMTYyMjM0NiAgICBcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuLypqc2hpbnQgLVcwNjggKi9cclxuaWYgKCEoZnVuY3Rpb24gZigpIHt9KS5uYW1lKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvblxccyooXFxTKilcXHMqXFwoLylbMV07XHJcbiAgICAgICAgICAgIC8vIEZvciBiZXR0ZXIgcGVyZm9ybWFuY2Ugb25seSBwYXJzZSBvbmNlLCBhbmQgdGhlbiBjYWNoZSB0aGVcclxuICAgICAgICAgICAgLy8gcmVzdWx0IHRocm91Z2ggYSBuZXcgYWNjZXNzb3IgZm9yIHJlcGVhdGVkIGFjY2Vzcy5cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywgeyB2YWx1ZTogbmFtZSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0iLCIvKipcclxuICAgIEdyb3VwTGlzdFJlbW90ZU1vZGVsXHJcbiAgICBVdGlsaXR5IGNsYXNzIGZvciBjb21tb24gY29kZSBmb3IgYSBkYXRhIGxpc3QgZW50aXR5IGZyb20gYSByZW1vdGUgc291cmNlLFxyXG4gICAgd2l0aCBsb2NhbCBjb3B5IGFuZCBjYWNoZSwgd2hlcmUgdGhlIGZ1bGwgbGlzdCBpcyBtYW5hZ2VkIHBlciBncm91cHMsXHJcbiAgICB3aXRob3V0IHBhZ2luZy9jdXJzb3IsIGFsbCB0aGUgZ3JvdXAgZGF0YSBvbiBlYWNoIG9wZXJhdGlvbi5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBJbmRleGVkR3JvdXBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL0luZGV4ZWRHcm91cExpc3RDYWNoZScpO1xyXG5cclxuZnVuY3Rpb24gcmVxdWlyZWQodmFsLCBtc2cpIHtcclxuICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mKHZhbCkgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdSZXF1aXJlZCBwYXJhbWV0ZXInKTtcclxuICAgIGVsc2UgcmV0dXJuIHZhbDtcclxufVxyXG5cclxuZnVuY3Rpb24gR3JvdXBMaXN0UmVtb3RlTW9kZWwoc2V0dGluZ3MpIHtcclxuICAgIC8qanNoaW50IG1heHN0YXRlbWVudHM6MjgqL1xyXG4gICAgXHJcbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG4gICAgc2V0dGluZ3MubGlzdFR0bCA9IHJlcXVpcmVkKHNldHRpbmdzLmxpc3RUdGwsICdsaXN0VHRsIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBzZXR0aW5ncy5ncm91cElkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5ncm91cElkRmllbGQsICdncm91cElkRmllbGQgaXMgcmVxdWlyZWQnKTtcclxuICAgIHNldHRpbmdzLml0ZW1JZEZpZWxkID0gcmVxdWlyZWQoc2V0dGluZ3MuaXRlbUlkRmllbGQsICdpdGVtSWRGaWVsZCBpcyByZXF1aXJlZCcpO1xyXG4gICAgLy8gRm9yIG5vdywgb3B0aW9uYWwgbW9kZWxcclxuICAgIHNldHRpbmdzLk1vZGVsID0gc2V0dGluZ3MuTW9kZWwgfHwgbnVsbDtcclxuICAgIC8vIFJlcXVpcmVkIGZvciBBUEkgYWRkaXRpb25zXHJcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICBpc0xvYWRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG4gICAgICAgIGlzU3luY2luZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcbiAgICAgICAgaXNTYXZpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG4gICAgICAgIGlzRGVsZXRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjYWNoZSA9IG5ldyBJbmRleGVkR3JvdXBMaXN0Q2FjaGUoe1xyXG4gICAgICAgIGxpc3RUdGw6IHNldHRpbmdzLmxpc3RUdGwsXHJcbiAgICAgICAgZ3JvdXBJZEZpZWxkOiBzZXR0aW5ncy5ncm91cElkRmllbGQsXHJcbiAgICAgICAgaXRlbUlkRmllbGQ6IHNldHRpbmdzLml0ZW1JZEZpZWxkXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5jbGVhckNhY2hlID0gY2FjaGUuY2xlYXJDYWNoZTtcclxuXHJcbiAgICB0aGlzLnN0YXRlLmlzTG9ja2VkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzTG9hZGluZygpIHx8IHRoaXMuaXNTYXZpbmcoKSB8fCB0aGlzLmlzRGVsZXRpbmcoKTtcclxuICAgIH0sIHRoaXMuc3RhdGUpO1xyXG5cclxuICAgIC8qKiBEYXRhIFN0b3JlcyBNYW5hZ2VtZW50OiBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIHJlcGxhY2VkLCB3aXRoIGN1c3RvbSBjb2RlIG9yIHVzaW5nXHJcbiAgICAgICAgdGhlIGhlbHBlcnMgYWRkZWQgdG8gdGhlIGNsYXNzIChzZWUgYWRkWHhTdXBwb3J0IHByb3RvdHlwZSBtZXRob2RzKS5cclxuICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7IHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7IH1cclxuICAgIHRoaXMuZmV0Y2hHcm91cEZyb21Mb2NhbCA9IG5vdEltcGxlbWVudGVkO1xyXG4gICAgdGhpcy5mZXRjaEdyb3VwRnJvbVJlbW90ZSA9IG5vdEltcGxlbWVudGVkO1xyXG4gICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsID0gbm90SW1wbGVtZW50ZWQ7XHJcbiAgICB0aGlzLnB1c2hHcm91cFRvUmVtb3RlID0gbm90SW1wbGVtZW50ZWQ7XHJcbiAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tUmVtb3RlID0gbm90SW1wbGVtZW50ZWQ7XHJcblxyXG4gICAgLyoqIEFQSSBkZWZpbml0aW9uICoqL1xyXG4gICAgdmFyIGFwaSA9IHRoaXM7XHJcblxyXG4gICAgYXBpLmdldExpc3QgPSBmdW5jdGlvbiBnZXRMaXN0KGdyb3VwSUQpIHtcclxuICAgICAgICB2YXIgY2FjaGVFbnRyeSA9IGNhY2hlLmdldEdyb3VwQ2FjaGUoZ3JvdXBJRCk7XHJcblxyXG4gICAgICAgIGlmIChjYWNoZUVudHJ5LmNvbnRyb2wubXVzdFJldmFsaWRhdGUoKSkge1xyXG4gICAgICAgICAgICAvLyBObyBjYWNoZSBkYXRhLCBpcyBmaXJzdCBsb2FkLCB0cnkgZnJvbSBsb2NhbFxyXG4gICAgICAgICAgICBpZiAoIWNhY2hlRW50cnkubGlzdCkge1xyXG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIEZyb20gbG9jYWxcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoR3JvdXBGcm9tTG9jYWwoZ3JvdXBJRClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsYXVuY2ggcmVtb3RlIGZvciBzeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlUHJvbWlzZSA9IHRoaXMuZmV0Y2hHcm91cEZyb21SZW1vdGUoZ3JvdXBJRClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEdyb3VwQ2FjaGUoZ3JvdXBJRCwgc2VydmVyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaEdyb3VwVG9Mb2NhbChncm91cElELCBzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3RlIGZhbGxiYWNrOiBJZiBubyBsb2NhbCwgd2FpdCBmb3IgcmVtb3RlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhIDogcmVtb3RlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyIGEgbGlzdCwgZXZlbiBpZiBlbXB0eVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEdyb3VwQ2FjaGUoZ3JvdXBJRCwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsKGdyb3VwSUQsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIEZyb20gcmVtb3RlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEdyb3VwRnJvbVJlbW90ZShncm91cElEKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZXIgYSBsaXN0LCBldmVuIGlmIGVtcHR5XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0R3JvdXBDYWNoZShncm91cElELCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hHcm91cFRvTG9jYWwoZ3JvdXBJRCwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZyb20gY2FjaGVcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZUVudHJ5Lmxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbShncm91cElELCBpdGVtSUQpIHtcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IFRvIHNpbXBsaWZ5LCBsb2FkIGFsbCB0aGUgbGlzdCAoaXMgYSBzaG9ydCBsaXN0KVxyXG4gICAgICAgIC8vIGFuZCBsb29rIGZyb20gaXRzIGNhY2hlZCBpbmRleFxyXG4gICAgICAgIC8vIFRPRE8gSW1wbGVtZW50IGl0ZW0gc2VydmVyIGxvb2stdXAuIEJlIGNhcmVmdWwgd2l0aCBjYWNoZSB1cGRhdGUsXHJcbiAgICAgICAgLy8gbGlzdCBzb3J0aW5nIGFuZCBzdGF0ZSBmbGFncy5cclxuICAgICAgICByZXR1cm4gYXBpLmdldExpc3QoZ3JvdXBJRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGZyb20gY2FjaGVkIGluZGV4XHJcbiAgICAgICAgICAgIHZhciBjYWNoZUl0ZW0gPSBjYWNoZS5nZXRJdGVtQ2FjaGUoZ3JvdXBJRCwgaXRlbUlEKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IEVuaGFuY2Ugb24gZnV0dXJlIHdpdGggYWN0dWFsIGxvb2stdXAgYnkgQVBJIGl0ZW1JRFxyXG4gICAgICAgICAgICAvLyBpZiBub3QgY2FjaGVkLCB0aHJvd2luZyBub3QgZm91bmQgZnJvbSB0aGUgc2VydmVyIChqdXN0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIG1pbm9yIGNhc2VzIHdoZW4gYSBuZXcgaXRlbSBpcyBub3Qgc3RpbGwgaW4gdGhlIGNhY2hlIGlmIGxpbmtlZFxyXG4gICAgICAgICAgICAvLyBmcm9tIG90aGVyIGFwcCBkYXRhKS4gQW5kIGtlZXAgdXBkYXRlZCBsaXN0IGNhY2hlIHdpdGggdGhhdFxyXG4gICAgICAgICAgICAvLyBpdGVtcyBsb29rdXBcclxuICAgICAgICAgICAgaWYgKCFjYWNoZUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignR3JvdXBMaXN0UmVtb3RlTW9kZWwgTm90IGZvdW5kJywgZ3JvdXBJRCwgaXRlbUlELCBzZXR0aW5ncy5Nb2RlbCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBGb3VuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUl0ZW0uaXRlbTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgU2F2ZSBhbiBpdGVtIGluIGNhY2hlLCBsb2NhbCBhbmQgcmVtb3RlLlxyXG4gICAgICAgIENhbiBiZSBuZXcgb3IgdXBkYXRlZC5cclxuICAgICAgICBUaGUgSURzIGdvZXMgd2l0aCBhbGwgdGhlIG90aGVyIGRhdGEsIGJlaW5nXHJcbiAgICAgICAgZ3JvdXBJRCByZXF1aXJlZCwgaXRlbUlEIHJlcXVpcmVkIGZvciB1cGRhdGVzXHJcbiAgICAgICAgYnV0IGZhbHN5IGZvciBpbnNlcnRpb25zLlxyXG4gICAgICAgIEBwYXJhbSBkYXRhOm9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICoqL1xyXG4gICAgYXBpLnNldEl0ZW0gPSBmdW5jdGlvbiBzZXRJdGVtKGRhdGEpIHtcclxuICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcodHJ1ZSk7XHJcbiAgICAgICAgLy8gU2VuZCB0byByZW1vdGUgZmlyc3RcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoR3JvdXBUb1JlbW90ZShkYXRhKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgLy8gU3VjY2VzcyEgdXBkYXRlIGxvY2FsIGNvcHkgd2l0aCByZXR1cm5lZCBkYXRhXHJcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogdG8gdXNlIHNlcnZlciBkYXRhIGhlcmUgc28gd2UgZ2V0IHZhbHVlcyBzZXRcclxuICAgICAgICAgICAgLy8gYnkgdGhlIHNlcnZlciwgYXMgdXBkYXRlcyBkYXRlcyBhbmQgaXRlbUlEIHdoZW4gY3JlYXRpbmdcclxuICAgICAgICAgICAgLy8gYSBuZXcgaXRlbS5cclxuICAgICAgICAgICAgaWYgKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cElEID0gc2VydmVyRGF0YVtzZXR0aW5ncy5ncm91cElkRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbiBjYWNoZVxyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0SXRlbUNhY2hlKGdyb3VwSUQsIHNlcnZlckRhdGFbc2V0dGluZ3MuaXRlbUlkRmllbGRdLCBzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWwgc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgLy8gSW4gbG9jYWwgbmVlZCB0byBiZSBzYXZlZCBhbGwgdGhlIGdyb3VwZWQgZGF0YSwgbm90IGp1c3RcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtOyBzaW5jZSB3ZSBoYXZlIHRoZSBjYWNoZSBsaXN0IHVwZGF0ZWQsIHVzZSB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyBmdWxsIGxpc3QgdG8gc2F2ZSBsb2NhbFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsKGdyb3VwSUQsIGNhY2hlLmdldEdyb3VwQ2FjaGUoZ3JvdXBJRCkubGlzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzU2F2aW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJEYXRhO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1NhdmluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIFJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5kZWxJdGVtID0gZnVuY3Rpb24gZGVsSXRlbShncm91cElELCBpdGVtSUQpIHtcclxuICAgICAgICBcclxuICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyh0cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZW1vdmUgaW4gcmVtb3RlIGZpcnN0XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSXRlbUZyb21SZW1vdGUoZ3JvdXBJRCwgaXRlbUlEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlbW92ZWREYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjYWNoZVxyXG4gICAgICAgICAgICBjYWNoZS5kZWxJdGVtQ2FjaGUoZ3JvdXBJRCwgaXRlbUlEKTtcclxuICAgICAgICAgICAgLy8gU2F2ZSBpbiBsb2NhbCBzdG9yYWdlXHJcbiAgICAgICAgICAgIC8vIEluIGxvY2FsIG5lZWQgdG8gYmUgc2F2ZWQgYWxsIHRoZSBncm91cGVkIGRhdGE7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlIGhhdmUgdGhlIGNhY2hlIGxpc3QgdXBkYXRlZCwgdXNlIHRoYXRcclxuICAgICAgICAgICAgLy8gZnVsbCBsaXN0IHRvIHNhdmUgbG9jYWxcclxuICAgICAgICAgICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsKGdyb3VwSUQsIGNhY2hlLmdldEdyb3VwQ2FjaGUoZ3JvdXBJRCkubGlzdCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZERhdGE7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzRGVsZXRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKiogU29tZSBVdGlscyAqKi9cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgR2VuZXJhdGVzIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgaW5tZWRpYXRlbHksXHJcbiAgICAgICAgd2l0aCB0aGUgY2FjaGVkIHZhbHVlIG9yIHVuZGVmaW5lZCxcclxuICAgICAgICBsYXVuY2hpbmcgYW4gaXRlbSBsb2FkIHRoYXQgd2lsbCB1cGRhdGUgdGhlIG9ic2VydmFibGVcclxuICAgICAgICBvbiByZWFkeSBpZiB0aGVyZSBpcyBubyBjYWNoZWQgdmFsdWUuXHJcbiAgICAgICAgQSBtZXRob2QgJ3N5bmMnIGlzIGFkZGVkIHRvIHRoZSBvYnNlcnZhYmxlIHNvIGNhbiBiZSByZXF1ZXN0ZWRcclxuICAgICAgICBhIGRhdGEgc3luYy9yZWxvYWQgb24gZGVtYW5kLlxyXG4gICAgKiovXHJcbiAgICBhcGkuZ2V0T2JzZXJ2YWJsZUl0ZW0gPSBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlSXRlbShncm91cElELCBpdGVtSUQsIGFzTW9kZWwpIHtcclxuICAgICAgICAvLyBHZXQgZmlyc3QgdmFsdWVcclxuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGNhY2hlLmdldEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQpO1xyXG4gICAgICAgIGZpcnN0VmFsdWUgPSBmaXJzdFZhbHVlICYmIGZpcnN0VmFsdWUuaXRlbSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIG9icyA9IGtvLm9ic2VydmFibGUoYXNNb2RlbCA/IGFwaS5hc01vZGVsKGZpcnN0VmFsdWUpIDogZmlyc3RWYWx1ZSk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIG1ldGhvZCAnc3luYydcclxuICAgICAgICBvYnMuc3luYyA9IGZ1bmN0aW9uIHN5bmNPYnNlcnZhYmxlSXRlbSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwaS5nZXRJdGVtKGdyb3VwSUQsIGl0ZW1JRClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFzTW9kZWwpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JzKCkubW9kZWwudXBkYXRlV2l0aChpdGVtKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYnMoaXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRmlyc3QgbG9hZCBpZiBubyBjYWNoZWQgdmFsdWVcclxuICAgICAgICBpZiAoIWZpcnN0VmFsdWUpXHJcbiAgICAgICAgICAgIG9icy5zeW5jKCk7XHJcbiAgICAgICAgLy8gUmV0dXJuXHJcbiAgICAgICAgcmV0dXJuIG9icztcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5hc01vZGVsID0gZnVuY3Rpb24gYXNNb2RlbChvYmplY3QpIHtcclxuICAgICAgICB2YXIgTW9kZWwgPSB0aGlzLnNldHRpbmdzLk1vZGVsO1xyXG4gICAgICAgIC8vIGlmIGlzIGFuIGFycmF5LCByZXR1cm4gYSBsaXN0IG9mIG1vZGVsc1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlbChpdGVtKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsKG9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmdldEl0ZW1Nb2RlbCA9IGZ1bmN0aW9uIGdldEl0ZW1Nb2RlbChncm91cElELCBpdGVtSUQpIHtcclxuICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW0oZ3JvdXBJRCwgaXRlbUlEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBhcGkuYXNNb2RlbChkYXRhKSA6IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgTW9kZWxWZXJzaW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvTW9kZWxWZXJzaW9uJyk7XHJcbiAgICBhcGkuZ2V0SXRlbVZlcnNpb24gPSBmdW5jdGlvbiBnZXRJdGVtVmVyc2lvbihncm91cElELCBpdGVtSUQpIHtcclxuICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW1Nb2RlbChncm91cElELCBpdGVtSUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsID8gbmV3IE1vZGVsVmVyc2lvbihtb2RlbCkgOiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLm5ld0l0ZW1WZXJzaW9uID0gZnVuY3Rpb24gbmV3SXRlbVZlcnNpb24odmFsdWVzKSB7XHJcbiAgICAgICAgLy8gTmV3IG9yaWdpbmFsIGFuZCB2ZXJzaW9uIGZvciB0aGUgbW9kZWxcclxuICAgICAgICB2YXIgdmVyc2lvbiA9IG5ldyBNb2RlbFZlcnNpb24obmV3IHRoaXMuc2V0dGluZ3MuTW9kZWwodmFsdWVzKSk7XHJcbiAgICAgICAgLy8gVG8gYmUgc3VyZSB0aGF0IHRoZSB2ZXJzaW9uIGFwcGVhciBhcyBzb21ldGhpbmcgJ25ldycsIHVuc2F2ZWQsXHJcbiAgICAgICAgLy8gd2UgdXBkYXRlIGl0cyB0aW1lc3RhbXAgdG8gYmUgZGlmZmVyZW50IHRvIHRoZSBvcmlnaW5hbC5cclxuICAgICAgICB2ZXJzaW9uLnZlcnNpb24ubW9kZWwudG91Y2goKTtcclxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JvdXBMaXN0UmVtb3RlTW9kZWw7XHJcblxyXG5Hcm91cExpc3RSZW1vdGVNb2RlbC5wcm90b3R5cGUuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0ID0gZnVuY3Rpb24gYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KGJhc2VOYW1lKSB7XHJcbiAgICB2YXIgbG9jYWxmb3JhZ2UgPSByZXF1aXJlKCdsb2NhbGZvcmFnZScpO1xyXG5cclxuICAgIHRoaXMuZmV0Y2hHcm91cEZyb21Mb2NhbCA9IGZ1bmN0aW9uIGZldGNoRnJvbUxvY2FsKGdyb3VwSUQpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbShiYXNlTmFtZSArIGdyb3VwSUQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMucHVzaEdyb3VwVG9Mb2NhbCA9IGZ1bmN0aW9uIHB1c2hUb0xvY2FsKGdyb3VwSUQsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2Uuc2V0SXRlbShiYXNlTmFtZSArIGdyb3VwSUQsIGRhdGEpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbkdyb3VwTGlzdFJlbW90ZU1vZGVsLnByb3RvdHlwZS5hZGRSZXN0U3VwcG9ydCA9IGZ1bmN0aW9uIGFkZFJlc3RTdXBwb3J0KHJlc3RDbGllbnQsIGJhc2VVcmwpIHtcclxuICAgIFxyXG4gICAgdGhpcy5mZXRjaEdyb3VwRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIGZldGNoRnJvbVJlbW90ZShncm91cElEKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3RDbGllbnQuZ2V0KGJhc2VVcmwgKyBncm91cElEKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnB1c2hHcm91cFRvUmVtb3RlID0gZnVuY3Rpb24gcHVzaFRvUmVtb3RlKGRhdGEpIHtcclxuXHJcbiAgICAgICAgdmFyIGdyb3VwSUQgPSBkYXRhW3RoaXMuc2V0dGluZ3MuZ3JvdXBJZEZpZWxkXSxcclxuICAgICAgICAgICAgaXRlbUlEID0gZGF0YVt0aGlzLnNldHRpbmdzLml0ZW1JZEZpZWxkXSxcclxuICAgICAgICAgICAgbWV0aG9kID0gZGF0YVt0aGlzLnNldHRpbmdzLml0ZW1JZEZpZWxkXSA/ICdwdXQnIDogJ3Bvc3QnO1xyXG5cclxuICAgICAgICB2YXIgdXJsID0gYmFzZVVybCArIGdyb3VwSUQgKyAoXHJcbiAgICAgICAgICAgIGl0ZW1JRCA/ICcvJyArIGl0ZW1JRCA6ICcnXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcmVzdENsaWVudFttZXRob2RdKHVybCwgZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tUmVtb3RlKGdyb3VwSUQsIGl0ZW1JRCkge1xyXG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50LmRlbGV0ZShiYXNlVXJsICsgZ3JvdXBJRCArICcvJyArIGl0ZW1JRCk7XHJcbiAgICB9O1xyXG59O1xyXG4iLCIvKipcclxuICAgIEluZGV4ZWRHcm91cExpc3RDYWNoZSBtYW5hZ2VzIGEgaW4tbWVtb3J5IGNhY2hlIGZvciBhIGxpc3RcclxuICAgIG9mIG9iamVjdHMsIGdyb3VwZWQgYnkgYSBmaWVsZCBhbmQgd2l0aCBpbmRleGVkIGFjY2VzcyB0byBncm91cHNcclxuICAgIGFuZCBpdGVtcywgd2l0aCBjYWNoZSBjb250cm9sLlxyXG4gICAgXHJcbiAgICBTZXR0aW5ncyBvYmplY3QgYXMgdW5pcXVlIHBhcmFtZXRlcjpcclxuICAgIGxpc3RUdGw6IHR0bCB0eXBlIGNvbnN0cnVjdG9yLiBUaW1lVG9MaWZlIGZvciBlYWNoIGdyb3VwIGxpc3QgY2FjaGUuXHJcbiAgICBGVVRVUkU6IGl0ZW1UdGw6IHR0bCB0eXBlIGNvbnN0cnVjdG9yLiBUaW1lVG9MaWZlIGZvciBlYWNoIGl0ZW0gY2FjaGUuXHJcbiAgICB0dGw6IHR0bCB0eXBlIGNvbnN0cnVjdG9yLiBUaW1lVG9MaWZlIHRvIHVzZSBmb3IgbGlzdCBhbmQgaXRlbSBjYWNoZSBpZiB0aGVyZSBpcyBubyBhIG1vcmUgZXhwbGljaXQgb25lXHJcbiAgICBncm91cElkRmllbGQ6IHN0cmluZyBOYW1lIG9mIHRoZSBmaWVsZCB1c2VkIHRvIGdyb3VwIG9iamVjdHNcclxuICAgIGl0ZW1JZEZpZWxkOiBzdHJpbmcgTmFtZSBvZiB0aGUgZmllbGQgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBlYWNoIGl0ZW1cclxuICAgIEZVVFVSRTogTW9kZWw6IGNvbnN0cnVjdG9yIG9mIHR5cGUgTW9kZWwuXHJcbiAgICBcclxuICAgIE5vdGU6ICd0dGwgdHlwZSBjb25zdHJ1Y3RvcicgY2FuIGJlIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciBhIHZhbHVlIHRvIHBhc3MgdG8gbW9tZW50LmR1cmF0aW9uIGNvbnN0cnVjdG9yIChtb21lbnRqcyBtb2R1bGUpLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENhY2hlQ29udHJvbCA9IHJlcXVpcmUoJy4vQ2FjaGVDb250cm9sJyk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJbmRleChsaXN0LCBieUZpZWxkKSB7XHJcbiAgICB2YXIgaW5kZXggPSB7fTtcclxuICAgIFxyXG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGl0ZW1JbmRleCkge1xyXG4gICAgICAgIGluZGV4W2l0ZW1bYnlGaWVsZF1dID0ge1xyXG4gICAgICAgICAgICBpbmRleDogaXRlbUluZGV4LFxyXG4gICAgICAgICAgICBpdGVtOiBpdGVtXHJcbiAgICAgICAgICAgIC8vIERpcmVjdCByZWZlcmVuYywgY291bGQgYmUgYSBwcm9wZXJ0eSB0b28gYXV0byByZXNvbHZpbmcgYXNcclxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIGxpa2UgZ2V0IGl0ZW0oKSB7IHJldHVybiBsaXN0W2l0ZW1JbmRleFtpdGVtW2J5RmllbGRdXV0gfHwgbnVsbDsgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcXVpcmVkKHZhbCwgbXNnKSB7XHJcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZih2YWwpID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnUmVxdWlyZWQgcGFyYW1ldGVyJyk7XHJcbiAgICBlbHNlIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluZGV4ZWRHcm91cExpc3RDYWNoZShzZXR0aW5ncykge1xyXG4gICAgXHJcbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG4gICAgc2V0dGluZ3MudHRsID0gc2V0dGluZ3MudHRsIHx8IDA7XHJcbiAgICBzZXR0aW5ncy5saXN0VHRsID0gc2V0dGluZ3MubGlzdFR0bCB8fCBzZXR0aW5ncy50dGwgfHwgMDtcclxuICAgIC8vRlVUVVJFOiBzZXR0aW5ncy5pdGVtVHRsID0gc2V0dGluZ3MuaXRlbVR0bCB8fCBzZXR0aW5ncy50dGwgfHwgMDtcclxuICAgIHNldHRpbmdzLmdyb3VwSWRGaWVsZCA9IHJlcXVpcmVkKHNldHRpbmdzLmdyb3VwSWRGaWVsZCwgJ2dyb3VwSWRGaWVsZCBpcyByZXF1aXJlZCcpO1xyXG4gICAgc2V0dGluZ3MuaXRlbUlkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5pdGVtSWRGaWVsZCwgJ2l0ZW1JZEZpZWxkIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAvL0ZVVFVSRTogc2V0dGluZ3MuTW9kZWwgPSBzZXR0aW5ncy5Nb2RlbCB8fCB0aHJvdyBuZXcgRXJyb3IoJ0EgTW9kZWwgaXMgcmVxdWlyZWQnKTtcclxuICAgIFxyXG4gICAgdmFyIGNhY2hlID0gey8qXHJcbiAgICAgICAgZ3JvdXBJZEZpZWxkOiB7XHJcbiAgICAgICAgICAgIGNvbnRyb2w6IENhY2hlQ29udHJvbCxcclxuICAgICAgICAgICAgbGlzdDogQXJyYXksXHJcbiAgICAgICAgICAgIGluZGV4OiB7XHJcbiAgICAgICAgICAgICAgICBpdGVtSWRGaWVsZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBJbnRlZ2VyIChpbmRleCBpbiB0aGUgbGlzdCBhcnJheSksXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogT2JqZWN0IChyZWZlcmVuY2UgdG8gdGhlIGl0ZW0gb2JqZWN0IGluIHRoZSBhcnJheSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSBmdXR1cmU6IGNvbnRyb2w6IENhY2hlQ29udHJvbCBwZXIgaXRlbVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC4uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC4uXHJcbiAgICAqL307XHJcbiAgICBcclxuICAgIHRoaXMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XHJcbiAgICAgICAgY2FjaGUgPSB7fTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbmV3Q2FjaGVFbnRyeShsaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udHJvbDogbmV3IENhY2hlQ29udHJvbCh7IHR0bDogc2V0dGluZ3MubGlzdFR0bCB9KSxcclxuICAgICAgICAgICAgbGlzdDogbGlzdCB8fCBudWxsLFxyXG4gICAgICAgICAgICBpbmRleDogbGlzdCAmJiBjcmVhdGVJbmRleChsaXN0LCBzZXR0aW5ncy5pdGVtSWRGaWVsZCkgfHwge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEdyb3VwQ2FjaGUoZ3JvdXBJRCwgbGlzdCkge1xyXG4gICAgICAgIHZhciBjYWNoZUVudHJ5ID0gY2FjaGVbZ3JvdXBJRF07XHJcbiAgICAgICAgaWYgKGNhY2hlRW50cnkpIHtcclxuICAgICAgICAgICAgY2FjaGVFbnRyeS5saXN0ID0gbGlzdCB8fCBbXTtcclxuICAgICAgICAgICAgY2FjaGVFbnRyeS5pbmRleCA9IGNyZWF0ZUluZGV4KGxpc3QgfHwgW10sIHNldHRpbmdzLml0ZW1JZEZpZWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhY2hlRW50cnkgPSBjYWNoZVtncm91cElEXSA9IG5ld0NhY2hlRW50cnkobGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhY2hlRW50cnkuY29udHJvbC5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnNldEdyb3VwQ2FjaGUgPSBzZXRHcm91cENhY2hlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIEdldCB0aGUgY2FjaGUgZW50cnkgZm9yIHRoZSBHcm91cFxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBnZXRHcm91cENhY2hlKGdyb3VwSUQpIHtcclxuICAgICAgICB2YXIgY2FjaGVFbnRyeSA9IGNhY2hlW2dyb3VwSURdO1xyXG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5IHx8IG5ld0NhY2hlRW50cnkoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5nZXRHcm91cENhY2hlID0gZ2V0R3JvdXBDYWNoZTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgdGhlIGNhY2hlIGVudHJ5IGZyb20gdGhlIEl0ZW1cclxuICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SXRlbUNhY2hlKGdyb3VwSUQsIGl0ZW1JRCkge1xyXG4gICAgICAgIHZhciBjYWNoZUVudHJ5ID0gY2FjaGVbZ3JvdXBJRF07XHJcbiAgICAgICAgaWYgKGNhY2hlRW50cnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5kZXhbaXRlbUlEXSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmdldEl0ZW1DYWNoZSA9IGdldEl0ZW1DYWNoZTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRJdGVtQ2FjaGUoZ3JvdXBJRCwgaXRlbUlELCBpdGVtKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSBjYWNoZVtncm91cElEXSB8fCBuZXdDYWNoZUVudHJ5KFtdKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBMb29mIGZvciB0aGUgZW50cnksIHRvIHVwZGF0ZSBvciBpbnNlcnQgYSBuZXcgb25lXHJcbiAgICAgICAgdmFyIGl0ZW1FbnRyeSA9IGNhY2hlRW50cnkuaW5kZXhbaXRlbUlEXTtcclxuICAgICAgICBpZiAoaXRlbUVudHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBlbnRyeVxyXG4gICAgICAgICAgICBjYWNoZUVudHJ5Lmxpc3RbaXRlbUVudHJ5LmluZGV4XSA9IGl0ZW07XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2UgaW4gdGhlIGluZGV4IHRvbyAoaXMgbm90IGNvbXB1dGVkIHJpZ2h0IG5vdylcclxuICAgICAgICAgICAgaXRlbUVudHJ5Lml0ZW0gPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIHZhciBpdGVtSW5kZXggPSBjYWNoZUVudHJ5Lmxpc3QucHVzaChpdGVtKSAtIDE7XHJcbiAgICAgICAgICAgIGNhY2hlRW50cnkuaW5kZXhbaXRlbUlEXSA9IHtcclxuICAgICAgICAgICAgICAgIGluZGV4OiBpdGVtSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBpdGVtOiBpdGVtXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnNldEl0ZW1DYWNoZSA9IHNldEl0ZW1DYWNoZTtcclxuXHJcbiAgICBmdW5jdGlvbiBkZWxJdGVtQ2FjaGUoZ3JvdXBJRCwgaXRlbUlEKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwRW50cnkgPSBjYWNoZVtncm91cElEXSB8fCBudWxsO1xyXG4gICAgICAgIGlmIChncm91cEVudHJ5KSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtRW50cnkgPSBncm91cEVudHJ5LmluZGV4W2l0ZW1JRF07XHJcbiAgICAgICAgICAgIGlmIChpdGVtRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBsaXN0IHJlbW92aW5nIHRoZSBlbGVtZW50IGluIHBsYWNlLCB3aXRob3V0IGhvbGVzXHJcbiAgICAgICAgICAgICAgICBncm91cEVudHJ5Lmxpc3Quc3BsaWNlKGl0ZW1FbnRyeS5pbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaW5kZXggYnk6XHJcbiAgICAgICAgICAgICAgICAvLyAtIFJlbW92ZSBpdGVtSUQgZW50cnlcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBncm91cEVudHJ5LmluZGV4W2l0ZW1JRF07XHJcbiAgICAgICAgICAgICAgICAvLyAtIFVwZGF0ZSBldmVyeSBlbnRyeSB3aXRoIGFuIElEIGdyZWF0ZXIgdGhhbiB0aGUgdXBkYXRlZCxcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIG5vdyBvbmUgcG9zaXRpb24gbGVzcyBpbiB0aGUgdXBkYXRlZCBsaXN0XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhncm91cEVudHJ5LmluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cEVudHJ5LmluZGV4W2tleV0gPiBpdGVtRW50cnkuaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwRW50cnkuaW5kZXhba2V5XS0tO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuZGVsSXRlbUNhY2hlID0gZGVsSXRlbUNhY2hlO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBkZWxHcm91cENhY2hlKGdyb3VwSUQpIHtcclxuICAgICAgICB2YXIgZ3JvdXBFbnRyeSA9IGNhY2hlW2dyb3VwSURdIHx8IG51bGw7XHJcbiAgICAgICAgaWYgKGdyb3VwRW50cnkpIHtcclxuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBlbnRyeS9wcm9wZXJ0eVxyXG4gICAgICAgICAgICBkZWxldGUgY2FjaGVbZ3JvdXBJRF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmRlbEdyb3VwQ2FjaGUgPSBkZWxHcm91cENhY2hlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWRHcm91cExpc3RDYWNoZTtcclxuIiwiLyoqXHJcbiAgICBJbmRleGVkTGlzdENhY2hlIG1hbmFnZXMgYSBpbi1tZW1vcnkgY2FjaGUgZm9yIGEgbGlzdFxyXG4gICAgb2Ygb2JqZWN0cywgd2l0aCBpbmRleGVkIGFjY2VzcyB0byBpdGVtc1xyXG4gICAgYW5kIGNhY2hlIGNvbnRyb2wuXHJcbiAgICBcclxuICAgIFNldHRpbmdzIG9iamVjdCBhcyB1bmlxdWUgcGFyYW1ldGVyOlxyXG4gICAgbGlzdFR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgZm9yIGVhY2ggZ3JvdXAgbGlzdCBjYWNoZS5cclxuICAgIEZVVFVSRTogaXRlbVR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgZm9yIGVhY2ggaXRlbSBjYWNoZS5cclxuICAgIHR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgdG8gdXNlIGZvciBsaXN0IGFuZCBpdGVtIGNhY2hlIGlmIHRoZXJlIGlzIG5vIGEgbW9yZSBleHBsaWNpdCBvbmVcclxuICAgIGl0ZW1JZEZpZWxkOiBzdHJpbmcgTmFtZSBvZiB0aGUgZmllbGQgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBlYWNoIGl0ZW1cclxuICAgIE1vZGVsOiBjb25zdHJ1Y3RvciBvZiB0eXBlIE1vZGVsLlxyXG4gICAgXHJcbiAgICBOb3RlOiAndHRsIHR5cGUgY29uc3RydWN0b3InIGNhbiBiZSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3IgYSB2YWx1ZSB0byBwYXNzIHRvIG1vbWVudC5kdXJhdGlvbiBjb25zdHJ1Y3RvciAobW9tZW50anMgbW9kdWxlKS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuL0NhY2hlQ29udHJvbCcpLFxyXG4gICAganNQcm9wZXJ0aWVzVG9vbHMgPSByZXF1aXJlKCcuL2pzUHJvcGVydGllc1Rvb2xzJyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJdGVtSW5kZXhFbnRyeShsaXN0LCBpdGVtSW5kZXgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5kZXg6IGl0ZW1JbmRleCxcclxuICAgICAgICBnZXQgaXRlbSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpc3RbdGhpcy5pbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSW5kZXgobGlzdCwgYnlGaWVsZCkge1xyXG4gICAgdmFyIGluZGV4ID0ge307XHJcbiAgICBcclxuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpdGVtSW5kZXgpIHtcclxuICAgICAgICBpbmRleFtrby51bndyYXAoaXRlbVtieUZpZWxkXSldID0gY3JlYXRlSXRlbUluZGV4RW50cnkobGlzdCwgaXRlbUluZGV4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpbmRleDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZWQodmFsLCBtc2cpIHtcclxuICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mKHZhbCkgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdSZXF1aXJlZCBwYXJhbWV0ZXInKTtcclxuICAgIGVsc2UgcmV0dXJuIHZhbDtcclxufVxyXG5cclxuLyoqXHJcbiAgICBBbiBpdGVtIGFkYXB0ZXIgcmVjZWl2ZXMgdGhlIG9sZCBhbmQgdGhlIG5ldyBpdGVtIGRhdGEgYW5kIHJldHVybnNcclxuICAgIHRoZSBpdGVtIHRvIGhvbGQgaW4gdGhlIGxpc3QuIFRoZSByZXR1cm5pbmcgb2JqZWN0IGNhbiBiZSBhIHJlZmVyZW5jZVxyXG4gICAgdG8gdGhlIHNhbWUgZXhpc3RlbnQgb2JqZWN0IChvbGRJdGVtKSB0aGF0IGdldHMgdXBkYXRlZCB3aXRoIHRoZSBcclxuICAgIG5ldyB2YWx1ZXMgKG5ld0l0ZW0pLCBvciBqdXN0IHRoZSBuZXdJdGVtIG9yIGFueSBjb252ZXJzaW9uIG92ZXIgdGhlXHJcbiAgICByYXcgbmV3SXRlbSBkYXRhLlxyXG4gICAgVGhpcyBhbGxvd3MgdG8gcGVyZm9ybSBjaGFuZ2VzLCBhZGQgcHJvcGVydGllcywgb3Iga2VlcCByZWZlcmVuY2VzLFxyXG4gICAgbGlrZSBjcmVhdGluZyBvYnNlcnZhYmxlcywgTW9kZWxzLlxyXG4gICAgXHJcbiAgICBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIHRoZSBuZXdJdGVtLlxyXG4qKi9cclxuZnVuY3Rpb24gZGVmYXVsdEl0ZW1BZGFwdGVyKG9sZEl0ZW0sIG5ld0l0ZW0pIHtcclxuICAgIHJldHVybiBuZXdJdGVtO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbmRleGVkTGlzdENhY2hlKHNldHRpbmdzKSB7XHJcbiAgICBcclxuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcbiAgICBzZXR0aW5ncy50dGwgPSBzZXR0aW5ncy50dGwgfHwgMDtcclxuICAgIHNldHRpbmdzLmxpc3RUdGwgPSBzZXR0aW5ncy5saXN0VHRsIHx8IHNldHRpbmdzLnR0bCB8fCAwO1xyXG4gICAgLy9GVVRVUkU6IHNldHRpbmdzLml0ZW1UdGwgPSBzZXR0aW5ncy5pdGVtVHRsIHx8IHNldHRpbmdzLnR0bCB8fCAwO1xyXG4gICAgc2V0dGluZ3MuaXRlbUlkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5pdGVtSWRGaWVsZCwgJ2l0ZW1JZEZpZWxkIGlzIHJlcXVpcmVkJyk7XHJcbiAgICBzZXR0aW5ncy5pdGVtQWRhcHRlciA9IHR5cGVvZihzZXR0aW5ncy5pdGVtQWRhcHRlcikgPT09ICdmdW5jdGlvbicgPyBzZXR0aW5ncy5pdGVtQWRhcHRlciA6IGRlZmF1bHRJdGVtQWRhcHRlcjtcclxuXHJcbiAgICAvLyBJbnRlcm5hbCBmbGFnIHRvIG5vdGlmeSBpZiB0aGUgY2FjaGUgd2FzIG5vdCB1c2VkIHN0aWxsIChubyBkYXRhIHNldClcclxuICAgIC8vIHNpbmNlIGl0cyBpbnN0YW50aWF0aW9uLiBPbiBmaXJzdCBzZXRMaXN0IHdpbGwgY2hhbmdlIHRvIGZhbHNlIGFuZCBrZWVwIGluIHRoYXQgc3RhdGUuXHJcbiAgICB2YXIgdW51c2VkID0gdHJ1ZTtcclxuICAgIC8vIEludGVybmFsIGNhY2hlIG1hbmFnZW1lbnRcclxuICAgIHZhciBjYWNoZSA9IHtcclxuICAgICAgICBjb250cm9sOiBuZXcgQ2FjaGVDb250cm9sKHsgdHRsOiBzZXR0aW5ncy5saXN0VHRsIH0pLFxyXG4gICAgICAgIGxpc3Q6IGtvLm9ic2VydmFibGVBcnJheShbXSksXHJcbiAgICAgICAgaW5kZXg6IHsvKlxyXG4gICAgICAgICAgICBpdGVtSWRGaWVsZDoge1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IEludGVnZXIgKGluZGV4IGluIHRoZSBsaXN0IGFycmF5KSxcclxuICAgICAgICAgICAgICAgIGl0ZW06IE9iamVjdCAocHJvcGVydHkgcmVmZXJlbmNpbmcgdG8gdGhlIGl0ZW0gb2JqZWN0IGluIHRoZSBhcnJheSBieSBpdHMgaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAvLyBNYXliZSBmdXR1cmU6IGNvbnRyb2w6IENhY2hlQ29udHJvbCBwZXIgaXRlbVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAuLlxyXG4gICAgICAgICovfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICBjYWNoZS5jb250cm9sLmxhdGVzdCA9IG51bGw7XHJcbiAgICAgICAgY2FjaGUubGlzdChbXSk7XHJcbiAgICAgICAgY2FjaGUuaW5kZXggPSB7fTtcclxuICAgICAgICB1bnVzZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBHZXQgdGhlIGNhY2hlIGVudHJ5IGZyb20gdGhlIEl0ZW1cclxuICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SXRlbUNhY2hlKGl0ZW1JRCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZS5pbmRleFtpdGVtSURdIHx8IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nZXRJdGVtQ2FjaGUgPSBnZXRJdGVtQ2FjaGU7XHJcblxyXG4gICAgLy8gQWRhcHQgYSBuZXcgaXRlbSB1c2luZyB0aGUgaXRlbUFkYXB0ZXIgYW5kIGdldHRpbmcgdGhlIG9sZCByZWZlcmVuY2UuXHJcbiAgICBmdW5jdGlvbiBhZGFwdEl0ZW0obmV3SXRlbSkge1xyXG4gICAgICAgIHZhciBvbGRJdGVtID0gZ2V0SXRlbUNhY2hlKGtvLnVud3JhcChuZXdJdGVtW3NldHRpbmdzLml0ZW1JZEZpZWxkXSkpO1xyXG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5pdGVtQWRhcHRlcihvbGRJdGVtLCBuZXdJdGVtKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQWRhcHQgdGhlIGVhY2ggZWxlbWVudCBpbiB0aGUgbGlzdCB3aXRoIHRoZSBpdGVtQWRhcHRlcixcclxuICAgIC8vIHBhc3NpbmcgYW4gb2xkIHJlZmVyZW5jZSBhbmQgdGhlIG5ldyBpdGVtIG9uIGVhY2gsIGFuZCBlbnN1cmluZ1xyXG4gICAgLy8gdG8gcmV0dXJuIGV2ZXIgYW4gYXJyYXksIGV2ZW4gaWYgZW1wdHkuXHJcbiAgICBmdW5jdGlvbiBhZGFwdExpc3QobGlzdCkge1xyXG4gICAgICAgIHJldHVybiAobGlzdCB8fCBbXSkubWFwKGFkYXB0SXRlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0TGlzdChsaXN0KSB7XHJcbiAgICAgICAgY2FjaGUubGlzdChhZGFwdExpc3QobGlzdCkpO1xyXG4gICAgICAgIGNhY2hlLmluZGV4ID0gY3JlYXRlSW5kZXgoY2FjaGUubGlzdCgpLCBzZXR0aW5ncy5pdGVtSWRGaWVsZCk7XHJcbiAgICAgICAgY2FjaGUuY29udHJvbC5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHVudXNlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpYywgcmVhZC1vbmx5LCBhY2Nlc3MgdG8gY2FjaGUgaW5mbyAob2JqZWN0cyBhcmUgbXV0YWJsZSwgYnV0IGFsbW9zdCB0aGUgcmVmZXJlbmNlXHJcbiAgICAvLyBjYW5ub3QgYmUgYnJva2VuOyBhIGNoYW5nZSBpbiB0aGUgbGlzdCBpbnN0YW5jZSB1cGRhdGVzIHRoZSBjYWNoZSBwcm9wZXJseSkuXHJcbiAgICBqc1Byb3BlcnRpZXNUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ2NvbnRyb2wnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhY2hlLmNvbnRyb2w7IH0pO1xyXG4gICAganNQcm9wZXJ0aWVzVG9vbHMuZGVmaW5lR2V0dGVyKHRoaXMsICdsaXN0JywgZnVuY3Rpb24oKSB7IHJldHVybiBjYWNoZS5saXN0OyB9KTtcclxuICAgIGpzUHJvcGVydGllc1Rvb2xzLmRlZmluZVNldHRlcih0aGlzLCAnbGlzdCcsIGZ1bmN0aW9uKGxpc3QpIHsgcmV0dXJuIHNldExpc3QobGlzdCk7IH0pO1xyXG4gICAganNQcm9wZXJ0aWVzVG9vbHMuZGVmaW5lR2V0dGVyKHRoaXMsICdpbmRleCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FjaGUuaW5kZXg7IH0pO1xyXG4gICAganNQcm9wZXJ0aWVzVG9vbHMuZGVmaW5lR2V0dGVyKHRoaXMsICd1bnVzZWQnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVudXNlZDsgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0SXRlbUNhY2hlKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaXRlbUlEID0ga28udW53cmFwKGl0ZW1bc2V0dGluZ3MuaXRlbUlkRmllbGRdKTtcclxuICAgICAgICAvLyBMb29rIGZvciB0aGUgZW50cnksIHRvIHVwZGF0ZSBvciBpbnNlcnQgYSBuZXcgb25lXHJcbiAgICAgICAgdmFyIGl0ZW1FbnRyeSA9IGNhY2hlLmluZGV4W2l0ZW1JRF07XHJcbiAgICAgICAgaWYgKGl0ZW1FbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgZW50cnlcclxuICAgICAgICAgICAgY2FjaGUubGlzdCgpW2l0ZW1FbnRyeS5pbmRleF0gPSBhZGFwdEl0ZW0oaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGxpc3RcclxuICAgICAgICAgICAgdmFyIGl0ZW1JbmRleCA9IGNhY2hlLmxpc3QucHVzaChhZGFwdEl0ZW0oaXRlbSkpIC0gMTtcclxuICAgICAgICAgICAgY2FjaGUuaW5kZXhbaXRlbUlEXSA9IGNyZWF0ZUl0ZW1JbmRleEVudHJ5KGNhY2hlLmxpc3QoKSwgaXRlbUluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRJdGVtQ2FjaGUgPSBzZXRJdGVtQ2FjaGU7XHJcblxyXG4gICAgZnVuY3Rpb24gZGVsSXRlbUNhY2hlKGl0ZW1JRCkge1xyXG4gICAgICAgIHZhciBpdGVtRW50cnkgPSBjYWNoZS5pbmRleFtpdGVtSURdO1xyXG4gICAgICAgIGlmIChpdGVtRW50cnkpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGxpc3QgcmVtb3ZpbmcgdGhlIGVsZW1lbnQgaW4gcGxhY2UsIHdpdGhvdXQgaG9sZXNcclxuICAgICAgICAgICAgY2FjaGUubGlzdC5zcGxpY2UoaXRlbUVudHJ5LmluZGV4LCAxKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGluZGV4IGJ5OlxyXG4gICAgICAgICAgICAvLyAtIFJlbW92ZSBpdGVtSUQgZW50cnlcclxuICAgICAgICAgICAgZGVsZXRlIGNhY2hlLmluZGV4W2l0ZW1JRF07XHJcbiAgICAgICAgICAgIC8vIC0gVXBkYXRlIGV2ZXJ5IGVudHJ5IHdpdGggYW4gSUQgZ3JlYXRlciB0aGFuIHRoZSB1cGRhdGVkLFxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSBub3cgb25lIHBvc2l0aW9uIGxlc3MgaW4gdGhlIHVwZGF0ZWQgbGlzdFxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjYWNoZS5pbmRleCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5pbmRleFtrZXldID4gaXRlbUVudHJ5LmluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmluZGV4W2tleV0tLTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmRlbEl0ZW1DYWNoZSA9IGRlbEl0ZW1DYWNoZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmRleGVkTGlzdENhY2hlO1xyXG4iLCIvKipcclxuICAgIExpc3RSZW1vdGVNb2RlbFxyXG4gICAgVXRpbGl0eSBjbGFzcyBmb3IgY29tbW9uIGNvZGUgZm9yIGEgZGF0YSBsaXN0IGVudGl0eSBmcm9tIGEgcmVtb3RlIHNvdXJjZSxcclxuICAgIHdpdGggbG9jYWwgY29weSBhbmQgY2FjaGUsIHdoZXJlIHRoZSBsaXN0IGlzIG1hbmFnZWQgd2lsbCBhbGwgdGhlIGRhdGEsXHJcbiAgICB3aXRob3V0IHBhZ2luZy9jdXJzb3IsIHdpdGggaW5kZXhlZCBhY2Nlc3MgdG8gZWFjaCBpdGVtIGJ5IGl0cyBJRC5cclxuICAgIElzIGdvb2QgZm9yIGxpc3RzIHRoYXQga2VlcCBzbWFsbCBpbiB0aGUgdGltZS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBJbmRleGVkTGlzdENhY2hlID0gcmVxdWlyZSgnLi9JbmRleGVkTGlzdENhY2hlJyk7XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlZCh2YWwsIG1zZykge1xyXG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YodmFsKSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ1JlcXVpcmVkIHBhcmFtZXRlcicpO1xyXG4gICAgZWxzZSByZXR1cm4gdmFsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBMaXN0UmVtb3RlTW9kZWwoc2V0dGluZ3MpIHtcclxuICAgIC8qanNoaW50IG1heHN0YXRlbWVudHM6NTAqL1xyXG5cclxuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcbiAgICBzZXR0aW5ncy5saXN0VHRsID0gcmVxdWlyZWQoc2V0dGluZ3MubGlzdFR0bCwgJ2xpc3RUdGwgaXMgcmVxdWlyZWQnKTtcclxuICAgIHNldHRpbmdzLml0ZW1JZEZpZWxkID0gcmVxdWlyZWQoc2V0dGluZ3MuaXRlbUlkRmllbGQsICdpdGVtSWRGaWVsZCBpcyByZXF1aXJlZCcpO1xyXG4gICAgLy8gT3B0aW9uYWwgbW9kZWxcclxuICAgIHNldHRpbmdzLk1vZGVsID0gc2V0dGluZ3MuTW9kZWwgfHwgbnVsbDtcclxuICAgIC8vIFJlcXVpcmVkIGZvciBBUEkgYWRkaXRpb25zXHJcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICBpc0xvYWRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG4gICAgICAgIGlzU3luY2luZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcbiAgICAgICAgaXNTYXZpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG4gICAgICAgIGlzRGVsZXRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBJdGVtcyBhcmUgbWFuYWdlZCBhcyBwbGFpbiBvYmplY3QgYnkgZGVmYXVsdCwgYnV0IGFzIHBlcm1hbmVudCwgdXBkYXRlZFxyXG4gICAgLy8gbW9kZWwgaW5zdGFuY2VzIGlmIHRoZSBNb2RlbCBjbGFzcyB3YXMgc3BlY2lmaWVkLlxyXG4gICAgLy8gVGhpcyBhZGFwdGVyIGlzIHBhc3NlZCB0byB0aGUgY2FjaGUgY29uc3RydWN0b3IgdG9vIGtlZXAgdGhlIGluLW1lbW9yeVxyXG4gICAgLy8gb2JqZWN0cyB1cCB0byBkYXRlIHdpdGggdGhlIGNvcnJlY3Qgc3RydWN0dXJlLlxyXG4gICAgZnVuY3Rpb24gaXRlbUFkYXB0ZXIob2xkSXRlbSwgbmV3SXRlbSkge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5Nb2RlbCkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbW9kZWwgaXRlbSBhbHJlYWR5IGV4aXN0cywgdXBkYXRlIHdpdGggbmV3IHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAob2xkSXRlbSAmJiBvbGRJdGVtIGluc3RhbmNlb2Ygc2V0dGluZ3MuTW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIG9sZEl0ZW0ubW9kZWwudXBkYXRlV2l0aChuZXdJdGVtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRJdGVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTmV3IGNyZWF0ZWQgaXRlbS5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByZXZpb3VzLCBuby1tb2RlbCwgdmFsdWUsIHRoZXkgYXJlIGRpc2NhcmRlZFxyXG4gICAgICAgICAgICAgICAgLy8gKHRoYXQgc2l0dWF0aW9uIGNhbiBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgYXJlIGlycmVndWxhciBtb2RpZmljYXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgaW50ZXJuYWwgYmVoYXZpb3IpLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzZXR0aW5ncy5Nb2RlbChuZXdJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0l0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgY2FjaGUgPSBuZXcgSW5kZXhlZExpc3RDYWNoZSh7XHJcbiAgICAgICAgbGlzdFR0bDogc2V0dGluZ3MubGlzdFR0bCxcclxuICAgICAgICBpdGVtSWRGaWVsZDogc2V0dGluZ3MuaXRlbUlkRmllbGQsXHJcbiAgICAgICAgaXRlbUFkYXB0ZXI6IGl0ZW1BZGFwdGVyXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5jbGVhckNhY2hlID0gY2FjaGUuY2xlYXJDYWNoZTtcclxuXHJcbiAgICB0aGlzLnN0YXRlLmlzTG9ja2VkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzTG9hZGluZygpIHx8IHRoaXMuaXNTYXZpbmcoKSB8fCB0aGlzLmlzRGVsZXRpbmcoKTtcclxuICAgIH0sIHRoaXMuc3RhdGUpO1xyXG5cclxuICAgIC8qKiBEYXRhIFN0b3JlcyBNYW5hZ2VtZW50OiBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIHJlcGxhY2VkLCB3aXRoIGN1c3RvbSBjb2RlIG9yIHVzaW5nXHJcbiAgICAgICAgdGhlIGhlbHBlcnMgYWRkZWQgdG8gdGhlIGNsYXNzIChzZWUgYWRkWHhTdXBwb3J0IHByb3RvdHlwZSBtZXRob2RzKS5cclxuICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7IHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7IH1cclxuICAgIHRoaXMuZmV0Y2hMaXN0RnJvbUxvY2FsID0gbm90SW1wbGVtZW50ZWQ7XHJcbiAgICB0aGlzLmZldGNoTGlzdEZyb21SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcclxuICAgIHRoaXMucHVzaExpc3RUb0xvY2FsID0gbm90SW1wbGVtZW50ZWQ7XHJcbiAgICB0aGlzLnB1c2hMaXN0VG9SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcclxuICAgIHRoaXMucmVtb3ZlSXRlbUZyb21SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgUmV0cmlldmVzIGEgcGxhaW4gYXJyYXktb2JqZWN0cyBmcm9tIHRoZSBjYWNoZWQgbGlzdFxyXG4gICAgKiovXHJcbiAgICBmdW5jdGlvbiBnZXRQbGFpbkNhY2hlZExpc3QoKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IGNhY2hlLmxpc3QoKTtcclxuICAgICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtICYmIHNldHRpbmdzLk1vZGVsICYmIGl0ZW0gaW5zdGFuY2VvZiBzZXR0aW5ncy5Nb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubW9kZWwudG9QbGFpbk9iamVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQVBJIGRlZmluaXRpb24gKiovXHJcbiAgICB2YXIgYXBpID0gdGhpcztcclxuICAgIFxyXG4gICAgLy8gRGlyZWN0IGFjY2VzcyB0byB0aGUgb2JzZXJ2YWJsZSBjYWNoZWQgbGlzdC5cclxuICAgIGFwaS5saXN0ID0gY2FjaGUubGlzdDtcclxuXHJcbiAgICAvLyBDdXJyZW50bHksIGp1c3QgYSB3cmFwcGVyIGZvciBnZXRMaXN0LlxyXG4gICAgYXBpLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xyXG4gICAgICAgIHJldHVybiBhcGkuZ2V0TGlzdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBQcm9taXNlIGJhc2VkIHJlcXVlc3QgdG8gZ2V0IHRoZSBsaXN0IChmcm9tIGNhY2hlLCBsb2NhbCBvciByZW1vdGUpLlxyXG4gICAgICAgIEl0IHVwZGF0ZXMgdGhlIG9ic2VydmFibGUgbGlzdCBpZiBuZXcgZGF0YSBpcyBmZXRjaGVkLlxyXG4gICAgICAgIEEgZ2VuZXJhbCBhcHByb2FjaCBpcyB0byB1c2UgdGhlIG9ic2VydmFibGUgbGlzdCBhbmQgY2FsbCB0aGUgJ3N5bmMnIG1ldGhvZFxyXG4gICAgICAgIHJhdGhlciB0aGFuIHdhaXQgdGhpcyBwcm9taXNlIHRvIGZpbmlzaCAoJ3N5bmMnIHBlcmZvcm1zIHRoaXMgbG9hZCByZWFsbHkpLlxyXG4gICAgKiovXHJcbiAgICBhcGkuZ2V0TGlzdCA9IGZ1bmN0aW9uIGdldExpc3QoKSB7XHJcblxyXG4gICAgICAgIGlmIChjYWNoZS5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcclxuICAgICAgICAgICAgLy8gQ2FjaGUgc3RpbGwgbm90IHVzZWQsIHRoZW4gaXMgZmlyc3QgbG9hZCwgdHJ5IGxvYWQgZnJvbSBsb2NhbFxyXG4gICAgICAgICAgICBpZiAoY2FjaGUudW51c2VkKSB7XHJcbiAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gRnJvbSBsb2NhbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hMaXN0RnJvbUxvY2FsKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsYXVuY2ggcmVtb3RlIGZvciBzeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlUHJvbWlzZSA9IHRoaXMuZmV0Y2hMaXN0RnJvbVJlbW90ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5saXN0ID0gc2VydmVyRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTGlzdFRvTG9jYWwoc2VydmVyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbG9jYWwgZGF0YSwgY2F0Y2ggZXJyb3IgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3luYyBzaW5jZSB0aGlzIHByb21pc2Ugd2lsbCBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgYXZhaWxhYmxlIHRvIGFueSBjb25zdW1lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2cgdG8gY29uc29sZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTGlzdFJlbW90ZU1vZGVsOiByZW1vdGUgc3luY2hyb25pemF0aW9uIGZhaWxlZCcsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHByb21pc2UgaXMgcmV0dXJuZWQgc28gd2lsbCBiZSBjb25zdW1lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmV0aHJvdyBhbmQgbGV0IHRoZSBvdGhlciBjYXRjaC1ibG9ja3MgZG8gdGhlIGNvbW1vbiBzdHVmZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW90ZSBmYWxsYmFjazogSWYgbm8gbG9jYWwsIHdhaXQgZm9yIHJlbW90ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhID8gZGF0YSA6IHJlbW90ZVByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlciBhIGxpc3QsIGV2ZW4gaWYgZW1wdHlcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5saXN0ID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMaXN0VG9Mb2NhbChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmxpc3Q7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBGcm9tIHJlbW90ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hMaXN0RnJvbVJlbW90ZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlciBhIGxpc3QsIGV2ZW4gaWYgZW1wdHlcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5saXN0ID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMaXN0VG9Mb2NhbChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmxpc3Q7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRnJvbSBjYWNoZVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLmxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGFwaS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbShpdGVtSUQpIHtcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IFRvIHNpbXBsaWZ5LCBsb2FkIGFsbCB0aGUgbGlzdCAoaXMgYSBzaG9ydCBsaXN0KVxyXG4gICAgICAgIC8vIGFuZCBsb29rIGZyb20gaXRzIGNhY2hlZCBpbmRleFxyXG4gICAgICAgIC8vIFRPRE8gSW1wbGVtZW50IGl0ZW0gc2VydmVyIGxvb2stdXAuIEJlIGNhcmVmdWwgd2l0aCBjYWNoZSB1cGRhdGUsXHJcbiAgICAgICAgLy8gbGlzdCBzb3J0aW5nIGFuZCBzdGF0ZSBmbGFncy5cclxuICAgICAgICByZXR1cm4gYXBpLmdldExpc3QoKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBHZXQgZnJvbSBjYWNoZWQgaW5kZXhcclxuICAgICAgICAgICAgdmFyIGNhY2hlSXRlbSA9IGNhY2hlLmdldEl0ZW1DYWNoZShpdGVtSUQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogRW5oYW5jZSBvbiBmdXR1cmUgd2l0aCBhY3R1YWwgbG9vay11cCBieSBBUEkgaXRlbUlEXHJcbiAgICAgICAgICAgIC8vIGlmIG5vdCBjYWNoZWQsIHRocm93aW5nIG5vdCBmb3VuZCBmcm9tIHRoZSBzZXJ2ZXIgKGp1c3QgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gbWlub3IgY2FzZXMgd2hlbiBhIG5ldyBpdGVtIGlzIG5vdCBzdGlsbCBpbiB0aGUgY2FjaGUgaWYgbGlua2VkXHJcbiAgICAgICAgICAgIC8vIGZyb20gb3RoZXIgYXBwIGRhdGEpLiBBbmQga2VlcCB1cGRhdGVkIGxpc3QgY2FjaGUgd2l0aCB0aGF0XHJcbiAgICAgICAgICAgIC8vIGl0ZW1zIGxvb2t1cFxyXG4gICAgICAgICAgICBpZiAoIWNhY2hlSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMaXN0UmVtb3RlTW9kZWwgTm90IGZvdW5kJywgaXRlbUlELCBzZXR0aW5ncy5Nb2RlbCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBGb3VuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUl0ZW0uaXRlbTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIGlubWVkaWF0ZWx5LFxyXG4gICAgICAgIHdpdGggdGhlIGNhY2hlZCB2YWx1ZSBvciB1bmRlZmluZWQsXHJcbiAgICAgICAgbGF1bmNoaW5nIGFuIGl0ZW0gbG9hZCB0aGF0IHdpbGwgdXBkYXRlIHRoZSBvYnNlcnZhYmxlXHJcbiAgICAgICAgb24gcmVhZHkgaWYgdGhlcmUgaXMgbm8gY2FjaGVkIHZhbHVlLlxyXG4gICAgICAgIEEgbWV0aG9kICdzeW5jJyBpcyBhZGRlZCB0byB0aGUgb2JzZXJ2YWJsZSBzbyBjYW4gYmUgcmVxdWVzdGVkXHJcbiAgICAgICAgYSBkYXRhIHN5bmMvcmVsb2FkIG9uIGRlbWFuZC5cclxuICAgICoqL1xyXG4gICAgYXBpLmdldE9ic2VydmFibGVJdGVtID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZUl0ZW0oaXRlbUlEKSB7XHJcbiAgICAgICAgLy8gR2V0IGZpcnN0IHZhbHVlXHJcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSBjYWNoZS5nZXRJdGVtQ2FjaGUoaXRlbUlEKTtcclxuICAgICAgICBmaXJzdFZhbHVlID0gZmlyc3RWYWx1ZSAmJiBmaXJzdFZhbHVlLml0ZW0gfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBvYnMgPSBrby5vYnNlcnZhYmxlKGZpcnN0VmFsdWUpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBtZXRob2QgJ3N5bmMnXHJcbiAgICAgICAgb2JzLnN5bmMgPSBmdW5jdGlvbiBzeW5jT2JzZXJ2YWJsZUl0ZW0oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcGkuZ2V0SXRlbShpdGVtSUQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGl0ZW1Nb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgb2JzKGl0ZW1Nb2RlbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRmlyc3QgbG9hZCBpZiBubyBjYWNoZWQgdmFsdWVcclxuICAgICAgICBpZiAoIWZpcnN0VmFsdWUpXHJcbiAgICAgICAgICAgIG9icy5zeW5jKCk7XHJcbiAgICAgICAgLy8gUmV0dXJuXHJcbiAgICAgICAgcmV0dXJuIG9icztcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIFNpbWlsYXIgdG8gZ2V0T2JzZXJ2YWJsZUl0ZW0sIGl0IGFsbG93cyB0byBnZXRcclxuICAgICAgICBhbiBvYnNlcnZhYmxlIHRvIGFuIGl0ZW0gbW9kZWwgc3luY2hyb25vdXNseSB0aGF0XHJcbiAgICAgICAgaXQgdHJpZ2dlcnMgYW4gaXRlbSBsb2FkIHdoZW4gaXRzIG1ldGhvZCAnc3luYydcclxuICAgICAgICBpcyBjYWxsZWQuIFRoZSBpdGVtSUQgaXMgcGFzc2VkIHRvIHRoZSBzeW5jIGl0ZW0sXHJcbiAgICAgICAgc2luY2UgdGhlIG9ic2VydmFibGUgaXMgbWVhbnQgdG8gaG9sZCBhbnkgaXRlbS9pdGVtSURcclxuICAgICAgICAoaXRzIGEgd2lsZGNhcmQpLlxyXG4gICAgICAgIFRoaXMgd2F5LCBhIHJlZmVyZW5jZSB0byBhbiBvYnNlcnZhYmxlIGNhbiBiZSBnZXQgb24gaW5pdGlhbGl6YXRpb25cclxuICAgICAgICBldmVuIGlmIHRoZXJlIGlzIG5vIGRhdGEgc3RpbGwsIGV2ZW4gbm8gaXRlbUlELCBhbmQgbG9hZFxyXG4gICAgICAgIGl0IGxhdGVyIGxhemlseSwgb24gZGVtYW5kLCB3aGlsZSBrZWVwaW5nIHRoZSBjb250ZW50IG9mIHRoZVxyXG4gICAgICAgIHByZXZpb3VzIG91dGRhdGVkIG9yIGRpZmZlcmVudCBpdGVtLlxyXG5cclxuICAgICAgICBOT1RFOiBBUEkgYWx0ZXJuYXRpdmUgbmFtZXM6IGdldExhenlJdGVtLCBjcmVhdGVNdXRhYmxlSXRlbVxyXG4gICAgICAgIE5PVEU6IE1heWJlIGNhbiBnZXQgc3RhdGUgb2JzZXJ2YWJsZXMgKGxvYWRpbmcsIHN5bmNpbmcuLik/XHJcbiAgICAgICAgTk9URTogT24gdXBkYXRlIGEgc2FtZSBpdGVtSUQsIG1heWJlIHVwZGF0ZSB0aGUgbW9kZWwgd2l0aCB1cGRhdGVXaXRoXHJcbiAgICAgICAgICAgICAgICByYXRoZXIgdGhhbiBjaGFuZ2UgdGhlIHJlZmVyZW5jZSBtb2RlbD8/IChkb3VibGUgY2hlY2s6XHJcbiAgICAgICAgICAgICAgICBzaW5jZSB0aGUgbW9kZWwgaXMgdGhlIHNhbWUgaW4gY2FjaGUsIGFscmVhZHkgdXBkYXRlZFxyXG4gICAgICAgICAgICAgICAgd2l0aCAndXBkYXRlV2l0aCcsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmUtYXBwbHkgYW5kIG5vXHJcbiAgICAgICAgICAgICAgICBuZWVkIHRvIGNoYW5nZSB0aGUgaXRlbSBvYnNlcnZhYmxlIGJlY2F1c2UgaXMgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQgYWxyZWFkeSwgcmlnaHQ/XHJcbiAgICAqKi9cclxuICAgIGFwaS5jcmVhdGVXaWxkY2FyZEl0ZW0gPSBmdW5jdGlvbiBjcmVhdGVXaWxkY2FyZEl0ZW0oKSB7XHJcbiAgICAgICAgLy8gVXRpbGl0eSBmb3IgcmV1c2UgaW4gJ3N5bmMnXHJcbiAgICAgICAgdmFyIGhhc0lEID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIHR5cGVvZihpZCkgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ3JlYXRlIG9ic2VydmFibGUsIHdpdGggaW5pdGlhbCB1bmRlZmluZWQgdmFsdWVcclxuICAgICAgICB2YXIgb2JzID0ga28ub2JzZXJ2YWJsZSh1bmRlZmluZWQpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbWV0aG9kICdzeW5jJ1xyXG4gICAgICAgIHZhciBsYXN0SUQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgIFN5bmMgbWV0aG9kIHRvIGxvYWQgYW4gaXRlbSwgZnJvbSBjYWNoZSBBU0FQIGFuZFxyXG4gICAgICAgICAgICBmcm9tIGxvY2FsIG9yIHJlbW90ZSBpZiByZXF1aXJlZCBieSB0aGUgY2FjaGUgY29udHJvbC5cclxuICAgICAgICAgICAgSXQgcmV0dXJucyB0aGUgUHJvbWlzZSBmb3IgZmV0Y2hpbmcgdGhlIHZhbHVlIChnZXRJdGVtKVxyXG4gICAgICAgICAgICBzbyBsb2FkL3N5bmMgZW5kaW5nIGFuZCBlcnJvciBjYW4gYmUgY2F0Y2hlZC5cclxuICAgICAgICAqKi9cclxuICAgICAgICBvYnMuc3luYyA9IGZ1bmN0aW9uIHN5bmNPYnNlcnZhYmxlSXRlbShpdGVtSUQpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBpZENoYW5nZWQgPSBoYXNJRChpdGVtSUQpICYmIGl0ZW1JRCAhPT0gbGFzdElEO1xyXG4gICAgICAgICAgICBsYXN0SUQgPSBoYXNJRChpdGVtSUQpID8gaXRlbUlEIDogbGFzdElEO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQVNBUCBHZXQgZnJvbSBjYWNoZSBpZiBhbnkgYW5kIHJlcXVlc3RlZCBpdGVtIGNoYW5nZWRcclxuICAgICAgICAgICAgaWYgKGlkQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZEl0ZW0gPSBjYWNoZS5nZXRJdGVtQ2FjaGUobGFzdElEKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRJdGVtICYmIGNhY2hlZEl0ZW0uaXRlbSlcclxuICAgICAgICAgICAgICAgICAgICBvYnMoY2FjaGVkSXRlbS5pdGVtKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVxdWVzdCB1cGRhdGVkIHZhbHVlXHJcbiAgICAgICAgICAgIHJldHVybiBhcGkuZ2V0SXRlbShsYXN0SUQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGl0ZW1Nb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgb2JzKGl0ZW1Nb2RlbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbU1vZGVsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgICBTZXRzIHRoZSBvYnNlcnZhYmxlIHZhbHVlIHRvIGEgbmV3IGl0ZW0gaW5zdGFuY2VcclxuICAgICAgICAqKi9cclxuICAgICAgICBvYnMubmV3SXRlbSA9IGZ1bmN0aW9uIG5ld0l0ZW0oZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLk1vZGVsKVxyXG4gICAgICAgICAgICAgICAgb2JzKG5ldyBzZXR0aW5ncy5Nb2RlbChkZWZhdWx0cykpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBvYnMoZGVmYXVsdHMgfHwge30pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFJldHVyblxyXG4gICAgICAgIHJldHVybiBvYnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAgIFNhdmUgYW4gaXRlbSBpbiBjYWNoZSwgbG9jYWwgYW5kIHJlbW90ZS5cclxuICAgICAgICBDYW4gYmUgbmV3IG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgVGhlIElEcyBnb2VzIHdpdGggYWxsIHRoZSBvdGhlciBkYXRhLCBiZWluZ1xyXG4gICAgICAgIGdyb3VwSUQgcmVxdWlyZWQsIGl0ZW1JRCByZXF1aXJlZCBmb3IgdXBkYXRlc1xyXG4gICAgICAgIGJ1dCBmYWxzeSBmb3IgaW5zZXJ0aW9ucy5cclxuICAgICAgICBAcGFyYW0gZGF0YTpvYmplY3QgUGxhaW4gb2JqZWN0XHJcbiAgICAqKi9cclxuICAgIGFwaS5zZXRJdGVtID0gZnVuY3Rpb24gc2V0SXRlbShkYXRhKSB7XHJcbiAgICAgICAgYXBpLnN0YXRlLmlzU2F2aW5nKHRydWUpO1xyXG4gICAgICAgIC8vIFNlbmQgdG8gcmVtb3RlIGZpcnN0XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaExpc3RUb1JlbW90ZShkYXRhKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgLy8gU3VjY2VzcyEgdXBkYXRlIGxvY2FsIGNvcHkgd2l0aCByZXR1cm5lZCBkYXRhXHJcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogdG8gdXNlIHNlcnZlciBkYXRhIGhlcmUgc28gd2UgZ2V0IHZhbHVlcyBzZXRcclxuICAgICAgICAgICAgLy8gYnkgdGhlIHNlcnZlciwgYXMgdXBkYXRlcyBkYXRlcyBhbmQgaXRlbUlEIHdoZW4gY3JlYXRpbmdcclxuICAgICAgICAgICAgLy8gYSBuZXcgaXRlbS5cclxuICAgICAgICAgICAgaWYgKHNlcnZlckRhdGEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgaW4gY2FjaGVcclxuICAgICAgICAgICAgICAgIGNhY2hlLnNldEl0ZW1DYWNoZShzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWwgc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgLy8gSW4gbG9jYWwgbmVlZCB0byBiZSBzYXZlZCBhbGwgdGhlIGxpc3QsIG5vdCBqdXN0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaXRlbTsgc2luY2Ugd2UgaGF2ZSB0aGUgY2FjaGUgbGlzdCB1cGRhdGVkLCB1c2UgdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gZnVsbCBsaXN0IHRvIHNhdmUgbG9jYWxcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaExpc3RUb0xvY2FsKGdldFBsYWluQ2FjaGVkTGlzdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckRhdGE7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzU2F2aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXBpLmRlbEl0ZW0gPSBmdW5jdGlvbiBkZWxJdGVtKGl0ZW1JRCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGFwaS5zdGF0ZS5pc0RlbGV0aW5nKHRydWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlbW92ZSBpbiByZW1vdGUgZmlyc3RcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZShpdGVtSUQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVtb3ZlZERhdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNhY2hlXHJcbiAgICAgICAgICAgIGNhY2hlLmRlbEl0ZW1DYWNoZShpdGVtSUQpO1xyXG4gICAgICAgICAgICAvLyBTYXZlIGluIGxvY2FsIHN0b3JhZ2VcclxuICAgICAgICAgICAgLy8gSW4gbG9jYWwgbmVlZCB0byBiZSBzYXZlZCBhbGwgdGhlIGxpc3Q7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlIGhhdmUgdGhlIGNhY2hlIGxpc3QgdXBkYXRlZCwgdXNlIHRoYXRcclxuICAgICAgICAgICAgLy8gZnVsbCBsaXN0IHRvIHNhdmUgbG9jYWxcclxuICAgICAgICAgICAgdGhpcy5wdXNoTGlzdFRvTG9jYWwoZ2V0UGxhaW5DYWNoZWRMaXN0KCkpO1xyXG5cclxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzRGVsZXRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWREYXRhO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0RlbGV0aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqIFNvbWUgVXRpbHMgKiovXHJcblxyXG4gICAgdmFyIE1vZGVsVmVyc2lvbiA9IHJlcXVpcmUoJy4uL3V0aWxzL01vZGVsVmVyc2lvbicpO1xyXG4gICAgLyoqXHJcbiAgICAgICAgSXQgY3JlYXRlcyBhIG5ldyBNb2RlbFZlcnNpb24gZm9yIHRoZSByZXF1ZXN0ZWQgaXRlbSBJRFxyXG4gICAgICAgIGFmdGVyIGxvYWQgdGhlIGl0ZW0uXHJcbiAgICAgICAgVGhlIHByb21pc2UgcmV0dXJucyB0aGUgTW9kZWxWZXJzaW9uIHJlYWR5LCBvciBudWxsXHJcbiAgICAgICAgaWYgdGhlIGl0ZW0gZG9lcyBub3QgZXhpc3RzLlxyXG4gICAgKiovXHJcbiAgICBhcGkuY3JlYXRlSXRlbVZlcnNpb24gPSBmdW5jdGlvbiBjcmVhdGVJdGVtVmVyc2lvbihpdGVtSUQpIHtcclxuICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW0oaXRlbUlEKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlbCA/IG5ldyBNb2RlbFZlcnNpb24obW9kZWwpIDogbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgSXQgY3JlYXRlcyBhIG5ldyBNb2RlbCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBpbml0aWFsIHZhbHVlcyxcclxuICAgICAgICByZXR1cm5pbmcgYSBNb2RlbFZlcnNpb24gb2JqZWN0LlxyXG4gICAgICAgIFRoZSB2ZXJzaW9uaW5nIGFsbG93cyB0byB0cmFjayB0aGUgaW5pdGlhbFxyXG4gICAgICAgIHN0YXRlIChpZiBjb21lcyBmcm9tIGEgc2V0IG9mIGRlZmF1bHRzIG9yIGNsb25lKSB3aXRoXHJcbiAgICAgICAgdGhlIGNoYW5nZXMgZG9uZTsgdGhlIGludGVybmFsIHZlcnNpb24gbm90aWZpZXMgaXRzZWxmXHJcbiAgICAgICAgYXMgJ3Vuc2F2ZWQnIGV2ZXIuXHJcbiAgICAgICAgSXRzIHVzZWZ1bCB0byBrZWVwIHRoZSBzYW1lIE1vZGVsVmVyc2lvbiBhd2FyZSBjb2RlIGZvclxyXG4gICAgICAgIGVkaXRpb25zIGFuZCBhZGRpdGlvbnMuXHJcbiAgICAqKi9cclxuICAgIGFwaS5uZXdJdGVtID0gZnVuY3Rpb24gbmV3SXRlbSh2YWx1ZXMpIHtcclxuICAgICAgICAvLyBOZXcgb3JpZ2luYWwgYW5kIHZlcnNpb24gZm9yIHRoZSBtb2RlbFxyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gbmV3IE1vZGVsVmVyc2lvbihuZXcgc2V0dGluZ3MuTW9kZWwodmFsdWVzKSk7XHJcbiAgICAgICAgLy8gVG8gYmUgc3VyZSB0aGF0IHRoZSB2ZXJzaW9uIGFwcGVhciBhcyBzb21ldGhpbmcgJ25ldycsIHVuc2F2ZWQsXHJcbiAgICAgICAgLy8gd2UgdXBkYXRlIGl0cyB0aW1lc3RhbXAgdG8gYmUgZGlmZmVyZW50IHRvIHRoZSBvcmlnaW5hbC5cclxuICAgICAgICB2ZXJzaW9uLnZlcnNpb24ubW9kZWwudG91Y2goKTtcclxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGlzdFJlbW90ZU1vZGVsO1xyXG5cclxuTGlzdFJlbW90ZU1vZGVsLnByb3RvdHlwZS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQgPSBmdW5jdGlvbiBhZGRMb2NhbGZvcmFnZVN1cHBvcnQoYmFzZU5hbWUpIHtcclxuICAgIHZhciBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyk7XHJcblxyXG4gICAgdGhpcy5mZXRjaExpc3RGcm9tTG9jYWwgPSBmdW5jdGlvbiBmZXRjaExpc3RGcm9tTG9jYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZm9yYWdlLmdldEl0ZW0oYmFzZU5hbWUpO1xyXG4gICAgfTtcclxuICAgIHRoaXMucHVzaExpc3RUb0xvY2FsID0gZnVuY3Rpb24gcHVzaExpc3RUb0xvY2FsKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2Uuc2V0SXRlbShiYXNlTmFtZSwgZGF0YSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuTGlzdFJlbW90ZU1vZGVsLnByb3RvdHlwZS5hZGRSZXN0U3VwcG9ydCA9IGZ1bmN0aW9uIGFkZFJlc3RTdXBwb3J0KHJlc3RDbGllbnQsIGJhc2VVcmwpIHtcclxuICAgIFxyXG4gICAgdGhpcy5mZXRjaExpc3RGcm9tUmVtb3RlID0gZnVuY3Rpb24gZmV0Y2hMaXN0RnJvbVJlbW90ZSgpIHtcclxuICAgICAgICByZXR1cm4gcmVzdENsaWVudC5nZXQoYmFzZVVybCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5wdXNoTGlzdFRvUmVtb3RlID0gZnVuY3Rpb24gcHVzaExpc3RUb1JlbW90ZShkYXRhKSB7XHJcblxyXG4gICAgICAgIHZhciBpdGVtSUQgPSBkYXRhW3RoaXMuc2V0dGluZ3MuaXRlbUlkRmllbGRdLFxyXG4gICAgICAgICAgICBtZXRob2QgPSBpdGVtSUQgPyAncHV0JyA6ICdwb3N0JztcclxuXHJcbiAgICAgICAgdmFyIHVybCA9IGJhc2VVcmwgKyAoXHJcbiAgICAgICAgICAgIGl0ZW1JRCA/ICcvJyArIGl0ZW1JRCA6ICcnXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcmVzdENsaWVudFttZXRob2RdKHVybCwgZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tUmVtb3RlKGl0ZW1JRCkge1xyXG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50LmRlbGV0ZShiYXNlVXJsICsgJy8nICsgaXRlbUlEKTtcclxuICAgIH07XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgVXRpbGl0eSB0aGF0IGFsbG93cyB0byBrZWVwIGFuIG9yaWdpbmFsIG1vZGVsIHVudG91Y2hlZFxyXG4gICAgd2hpbGUgZWRpdGluZyBhIHZlcnNpb24sIGhlbHBpbmcgc3luY2hyb25pemUgYm90aFxyXG4gICAgd2hlbiBkZXNpcmVkIGJ5IHB1c2gvcHVsbC9zeW5jLWluZy5cclxuICAgIFxyXG4gICAgSXRzIHRoZSB1c3VhbCB3YXkgdG8gd29yayBvbiBmb3Jtcywgd2hlcmUgYW4gaW4gbWVtb3J5XHJcbiAgICBtb2RlbCBjYW4gYmUgdXNlZCBidXQgaW4gYSBjb3B5IHNvIGNoYW5nZXMgZG9lc24ndCBhZmZlY3RzXHJcbiAgICBvdGhlciB1c2VzIG9mIHRoZSBpbi1tZW1vcnkgbW9kZWwgKGFuZCBhdm9pZHMgcmVtb3RlIHN5bmNpbmcpXHJcbiAgICB1bnRpbCB0aGUgY29weSB3YW50IHRvIGJlIHBlcnNpc3RlZCBieSBwdXNoaW5nIGl0LCBvciBiZWluZ1xyXG4gICAgZGlzY2FyZGVkIG9yIHJlZnJlc2hlZCB3aXRoIGEgcmVtb3RlbHkgdXBkYXRlZCBvcmlnaW5hbCBtb2RlbC5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXHJcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcblxyXG5mdW5jdGlvbiBNb2RlbFZlcnNpb24ob3JpZ2luYWwpIHtcclxuICAgIFxyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbDtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIHZlcnNpb25cclxuICAgIC8vICh1cGRhdGVXaXRoIHRha2VzIGNhcmUgdG8gc2V0IHRoZSBzYW1lIGRhdGFUaW1lc3RhbXApXHJcbiAgICB0aGlzLnZlcnNpb24gPSBvcmlnaW5hbC5tb2RlbC5jbG9uZShudWxsLCB0cnVlKTtcclxuICAgIFxyXG4gICAgLy8gQ29tcHV0ZWQgdGhhdCB0ZXN0IGVxdWFsaXR5LCBhbGxvd2luZyBiZWluZyBub3RpZmllZCBvZiBjaGFuZ2VzXHJcbiAgICAvLyBBIHJhdGVMaW1pdCBpcyB1c2VkIG9uIGVhY2ggdG8gYXZvaWQgc2V2ZXJhbCBzeW5jcmhvbm91cyBub3RpZmljYXRpb25zLlxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBSZXR1cm5zIHRydWUgd2hlbiBib3RoIHZlcnNpb25zIGhhcyB0aGUgc2FtZSB0aW1lc3RhbXBcclxuICAgICoqL1xyXG4gICAgdGhpcy5hcmVEaWZmZXJlbnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gYXJlRGlmZmVyZW50KCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWwubW9kZWwuZGF0YVRpbWVzdGFtcCgpICE9PSBcclxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uLm1vZGVsLmRhdGFUaW1lc3RhbXAoKVxyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKS5leHRlbmQoeyByYXRlTGltaXQ6IDAgfSk7XHJcbiAgICAvKipcclxuICAgICAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmVyc2lvbiBoYXMgbmV3ZXIgY2hhbmdlcyB0aGFuXHJcbiAgICAgICAgdGhlIG9yaWdpbmFsXHJcbiAgICAqKi9cclxuICAgIHRoaXMuaXNOZXdlciA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiBpc05ld2VyKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWwubW9kZWwuZGF0YVRpbWVzdGFtcCgpIDwgXHJcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5tb2RlbC5kYXRhVGltZXN0YW1wKClcclxuICAgICAgICApO1xyXG4gICAgfSwgdGhpcykuZXh0ZW5kKHsgcmF0ZUxpbWl0OiAwIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZlcnNpb24gaGFzIG9sZGVyIGNoYW5nZXMgdGhhblxyXG4gICAgICAgIHRoZSBvcmlnaW5hbFxyXG4gICAgKiovXHJcbiAgICB0aGlzLmlzT2Jzb2xldGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gaXNDb21wdXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsLm1vZGVsLmRhdGFUaW1lc3RhbXAoKSA+IFxyXG4gICAgICAgICAgICB0aGlzLnZlcnNpb24ubW9kZWwuZGF0YVRpbWVzdGFtcCgpXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpLmV4dGVuZCh7IHJhdGVMaW1pdDogMCB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbFZlcnNpb247XHJcblxyXG5Nb2RlbFZlcnNpb24uX2luaGVyaXRzKEV2ZW50RW1pdHRlcik7XHJcblxyXG5Nb2RlbFZlcnNpb24ucHJvdG90eXBlLmdldFJvbGxiYWNrID0gZnVuY3Rpb24gZ2V0Um9sbGJhY2soZnJvbSkge1xyXG4gICAgaWYgKGZyb20gPT09ICd2ZXJzaW9uJylcclxuICAgICAgICByZXR1cm4gY3JlYXRlUm9sbGJhY2tGdW5jdGlvbih0aGlzLnZlcnNpb24pO1xyXG4gICAgZWxzZSBpZiAoZnJvbSA9PT0gJ29yaWdpbmFsJylcclxuICAgICAgICByZXR1cm4gY3JlYXRlUm9sbGJhY2tGdW5jdGlvbih0aGlzLm9yaWdpbmFsKTtcclxuICAgIHRocm93IG5ldyBFcnJvcignZnJvbSB2YWx1ZSBub3QgdmFsaWQnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgU2VuZHMgdGhlIHZlcnNpb24gY2hhbmdlcyB0byB0aGUgb3JpZ2luYWxcclxuICAgIFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAgIGV2ZW5JZk5ld2VyOiBmYWxzZVxyXG4gICAgfVxyXG4qKi9cclxuTW9kZWxWZXJzaW9uLnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24gcHVsbChvcHRpb25zKSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIC8vIEJ5IGRlZmF1bHQsIG5vdGhpbmcgdG8gZG8sIG9yIGF2b2lkIG92ZXJ3cml0ZSBjaGFuZ2VzLlxyXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlLFxyXG4gICAgICAgIHJvbGxiYWNrID0gbnVsbDtcclxuICAgIFxyXG4gICAgaWYgKG9wdGlvbnMuZXZlbklmTmV3ZXIgfHwgIXRoaXMuaXNOZXdlcigpKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCB0aGUgb3JpZ2luYWwgZGF0YSxcclxuICAgICAgICAvLyBjcmVhdGluZyBmaXJzdCBhIHJvbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICAgIHJvbGxiYWNrID0gY3JlYXRlUm9sbGJhY2tGdW5jdGlvbih0aGlzLnZlcnNpb24pO1xyXG4gICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIG9ubHkgcHJvcGVydGllcyBhbmQgZmllbGRzIGZyb20gbW9kZWxzXHJcbiAgICAgICAgLy8gYXJlIGNvcGllZCBhbmQgdGhhdCBtdXN0IGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBUaGUgbWV0aG9kIHVwZGF0ZVdpdGggdGFrZXMgY2FyZSB0byBzZXQgdGhlIHNhbWUgZGF0YVRpbWVzdGFtcDogICAgICAgIFxyXG4gICAgICAgIHRoaXMudmVyc2lvbi5tb2RlbC51cGRhdGVXaXRoKHRoaXMub3JpZ2luYWwsIHRydWUpO1xyXG4gICAgICAgIC8vIERvbmVcclxuICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZW1pdCgncHVsbCcsIHJlc3VsdCwgcm9sbGJhY2spO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgRGlzY2FyZCB0aGUgdmVyc2lvbiBjaGFuZ2VzIGdldHRpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICBkYXRhLlxyXG4gICAgXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgZXZlbklmT2Jzb2xldGU6IGZhbHNlXHJcbiAgICB9XHJcbioqL1xyXG5Nb2RlbFZlcnNpb24ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKG9wdGlvbnMpIHtcclxuICAgIFxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIC8vIEJ5IGRlZmF1bHQsIG5vdGhpbmcgdG8gZG8sIG9yIGF2b2lkIG92ZXJ3cml0ZSBjaGFuZ2VzLlxyXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlLFxyXG4gICAgICAgIHJvbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5ldmVuSWZPYnNvbGV0ZSB8fCAhdGhpcy5pc09ic29sZXRlKCkpIHtcclxuICAgICAgICAvLyBVcGRhdGUgb3JpZ2luYWwsIGNyZWF0aW5nIGZpcnN0IGEgcm9sbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgcm9sbGJhY2sgPSBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKHRoaXMub3JpZ2luYWwpO1xyXG4gICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIG9ubHkgcHJvcGVydGllcyBhbmQgZmllbGRzIGZyb20gbW9kZWxzXHJcbiAgICAgICAgLy8gYXJlIGNvcGllZCBhbmQgdGhhdCBtdXN0IGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBUaGUgbWV0aG9kIHVwZGF0ZVdpdGggdGFrZXMgY2FyZSB0byBzZXQgdGhlIHNhbWUgZGF0YVRpbWVzdGFtcC5cclxuICAgICAgICB0aGlzLm9yaWdpbmFsLm1vZGVsLnVwZGF0ZVdpdGgodGhpcy52ZXJzaW9uLCB0cnVlKTtcclxuICAgICAgICAvLyBEb25lXHJcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmVtaXQoJ3B1c2gnLCByZXN1bHQsIHJvbGxiYWNrKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFNldHMgb3JpZ2luYWwgYW5kIHZlcnNpb24gb24gdGhlIHNhbWUgdmVyc2lvblxyXG4gICAgYnkgZ2V0dGluZyB0aGUgbmV3ZXN0IG9uZS5cclxuKiovXHJcbk1vZGVsVmVyc2lvbi5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLmlzTmV3ZXIoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKCk7XHJcbiAgICBlbHNlIGlmICh0aGlzLmlzT2Jzb2xldGUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5wdWxsKCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBVdGlsaXR5IHRoYXQgY3JlYXRlIGEgZnVuY3Rpb24gYWJsZSB0byBcclxuICAgIHBlcmZvcm0gYSBkYXRhIHJvbGxiYWNrIG9uIGV4ZWN1dGlvbiwgdXNlZnVsXHJcbiAgICB0byBwYXNzIG9uIHRoZSBldmVudHMgdG8gYWxsb3cgcmVhY3QgdXBvbiBjaGFuZ2VzXHJcbiAgICBvciBleHRlcm5hbCBzeW5jaHJvbml6YXRpb24gZmFpbHVyZXMuXHJcbioqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKG1vZGVsSW5zdGFuY2UpIHtcclxuICAgIC8vIFByZXZpb3VzIGZ1bmN0aW9uIGNyZWF0aW9uLCBnZXQgTk9XIHRoZSBpbmZvcm1hdGlvbiB0b1xyXG4gICAgLy8gYmUgYmFja2VkIGZvciBsYXRlci5cclxuICAgIHZhciBiYWNrZWREYXRhID0gbW9kZWxJbnN0YW5jZS5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpLFxyXG4gICAgICAgIGJhY2tlZFRpbWVzdGFtcCA9IG1vZGVsSW5zdGFuY2UubW9kZWwuZGF0YVRpbWVzdGFtcCgpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgZnVuY3Rpb24gdGhhdCAqbWF5KiBnZXQgZXhlY3V0ZWQgbGF0ZXIsIGFmdGVyXHJcbiAgICAvLyBjaGFuZ2VzIHdlcmUgZG9uZSBpbiB0aGUgbW9kZWxJbnN0YW5jZS5cclxuICAgIHJldHVybiBmdW5jdGlvbiByb2xsYmFjaygpIHtcclxuICAgICAgICAvLyBTZXQgdGhlIGJhY2tlZCBkYXRhXHJcbiAgICAgICAgbW9kZWxJbnN0YW5jZS5tb2RlbC51cGRhdGVXaXRoKGJhY2tlZERhdGEsIHRydWUpO1xyXG4gICAgICAgIC8vIEFuZCB0aGUgdGltZXN0YW1wXHJcbiAgICAgICAgbW9kZWxJbnN0YW5jZS5tb2RlbC5kYXRhVGltZXN0YW1wKGJhY2tlZFRpbWVzdGFtcCk7XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qKlxyXG4gICAgUmVtb3RlTW9kZWwgY2xhc3MuXHJcbiAgICBcclxuICAgIEl0IGhlbHBzIG1hbmFnaW5nIGEgbW9kZWwgaW5zdGFuY2UsIG1vZGVsIHZlcnNpb25zXHJcbiAgICBmb3IgaW4gbWVtb3J5IG1vZGlmaWNhdGlvbiwgYW5kIHRoZSBwcm9jZXNzIHRvIFxyXG4gICAgcmVjZWl2ZSBvciBzZW5kIHRoZSBtb2RlbCBkYXRhXHJcbiAgICB0byBhIHJlbW90ZSBzb3VyY2VzLCB3aXRoIGdsdWUgY29kZSBmb3IgdGhlIHRhc2tzXHJcbiAgICBhbmQgc3RhdGUgcHJvcGVydGllcy5cclxuICAgIFxyXG4gICAgRXZlcnkgaW5zdGFuY2Ugb3Igc3ViY2xhc3MgbXVzdCBpbXBsZW1lbnRcclxuICAgIHRoZSBmZXRjaCBhbmQgcHVsbCBtZXRob2RzIHRoYXQga25vd3MgdGhlIHNwZWNpZmljc1xyXG4gICAgb2YgdGhlIHJlbW90ZXMuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTW9kZWxWZXJzaW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvTW9kZWxWZXJzaW9uJyksXHJcbiAgICBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuLi91dGlscy9DYWNoZUNvbnRyb2wnKSxcclxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxuXHJcbmZ1bmN0aW9uIFJlbW90ZU1vZGVsKG9wdGlvbnMpIHtcclxuXHJcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICAgIFxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIHZhciBmaXJzdFRpbWVMb2FkID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgLy8gTWFya3MgYSBsb2NrIGxvYWRpbmcgaXMgaGFwcGVuaW5nLCBhbnkgdXNlciBjb2RlXHJcbiAgICAvLyBtdXN0IHdhaXQgZm9yIGl0XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgLy8gTWFya3MgYSBsb2NrIHNhdmluZyBpcyBoYXBwZW5pbmcsIGFueSB1c2VyIGNvZGVcclxuICAgIC8vIG11c3Qgd2FpdCBmb3IgaXRcclxuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIC8vIE1hcmtzIGEgYmFja2dyb3VuZCBzeW5jaHJvbml6YXRpb246IGxvYWQgb3Igc2F2ZSxcclxuICAgIC8vIHVzZXIgY29kZSBrbm93cyBpcyBoYXBwZW5pbmcgYnV0IGNhbiBjb250aW51ZVxyXG4gICAgLy8gdXNpbmcgY2FjaGVkIGRhdGFcclxuICAgIHRoaXMuaXNTeW5jaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICAvLyBVdGlsaXR5IHRvIGtub3cgd2hldGhlciBhbnkgbG9ja2luZyBvcGVyYXRpb24gaXNcclxuICAgIC8vIGhhcHBlbmluZy5cclxuICAgIC8vIEp1c3QgbG9hZGluZyBvciBzYXZpbmdcclxuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xvYWRpbmcoKSB8fCB0aGlzLmlzU2F2aW5nKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgaWYgKCFvcHRpb25zLmRhdGEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGVNb2RlbCBkYXRhIG11c3QgYmUgc2V0IG9uIGNvbnN0cnVjdG9yIGFuZCBubyBjaGFuZ2VkIGxhdGVyJyk7XHJcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICBcclxuICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGVDb250cm9sKHtcclxuICAgICAgICB0dGw6IG9wdGlvbnMudHRsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICB0aGlzLmNhY2hlLmxhdGVzdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhLm1vZGVsLnJlc2V0KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBPcHRpb25hbCBuYW1lIHVzZWQgdG8gcGVyc2lzdCBhIGNvcHkgb2YgdGhlIGRhdGEgYXMgcGxhaW4gb2JqZWN0XHJcbiAgICAvLyBpbiB0aGUgbG9jYWwgc3RvcmFnZSBvbiBldmVyeSBzdWNjZXNzZnVsbHkgbG9hZC9zYXZlIG9wZXJhdGlvbi5cclxuICAgIC8vIFdpdGggbm8gbmFtZSwgbm8gc2F2ZWQgKGRlZmF1bHQpLlxyXG4gICAgLy8gSXQgdXNlcyAnbG9jYWxmb3JhZ2UnLCBzbyBtYXkgYmUgbm90IHNhdmVkIHVzaW5nIGxvY2FsU3RvcmFnZSBhY3R1YWxseSxcclxuICAgIC8vIGJ1dCBhbnkgc3VwcG9ydGVkIGFuZCBpbml0aWFsaXplZCBzdG9yYWdlIHN5c3RlbSwgbGlrZSBXZWJTUUwsIEluZGV4ZWREQiBvciBMb2NhbFN0b3JhZ2UuXHJcbiAgICAvLyBsb2NhbGZvcmFnZSBtdXN0IGhhdmUgYSBzZXQtdXAgcHJldmlvdXMgdXNlIG9mIHRoaXMgb3B0aW9uLlxyXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2VOYW1lID0gb3B0aW9ucy5sb2NhbFN0b3JhZ2VOYW1lIHx8IG51bGw7XHJcbiAgICBcclxuICAgIC8vIFJlY29tbWVuZGVkIHdheSB0byBnZXQgdGhlIGluc3RhbmNlIGRhdGFcclxuICAgIC8vIHNpbmNlIGl0IGVuc3VyZXMgdG8gbGF1bmNoIGEgbG9hZCBvZiB0aGVcclxuICAgIC8vIGRhdGEgZWFjaCB0aW1lIGlzIGFjY2Vzc2VkIHRoaXMgd2F5LlxyXG4gICAgdGhpcy5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YSgpIHtcclxuICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm5ld1ZlcnNpb24gPSBmdW5jdGlvbiBuZXdWZXJzaW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gbmV3IE1vZGVsVmVyc2lvbih0aGlzLmRhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmVyc2lvbiBkYXRhIHdpdGggdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgLy8gYWZ0ZXIgYSBsb2NrIGxvYWQgZmluaXNoLCBsaWtlIHRoZSBmaXJzdCB0aW1lLFxyXG4gICAgICAgIC8vIHNpbmNlIHRoZSBVSSB0byBlZGl0IHRoZSB2ZXJzaW9uIHdpbGwgYmUgbG9ja1xyXG4gICAgICAgIC8vIGluIHRoZSBtaWRkbGUuXHJcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcuc3Vic2NyaWJlKGZ1bmN0aW9uIChpc0l0KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNJdCkge1xyXG4gICAgICAgICAgICAgICAgdi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gbmV3IG1ldGhvZCBmb3IgcHVzaCBhbmQgcmVtb3RlIHNhbWUgcmV0dXJuaW5nXHJcbiAgICAgICAgLy8gdGhlIHNhdmUgcHJvbWlzZSB0byB0cmFjayBpbW1lZGlhdGUgc3VjY2VzcyBvciBlcnJvcixcclxuICAgICAgICAvLyB3aXRoIGVycm9yIGF1dG8gcmVjb3ZlcmluZyBvcmlnaW5hbCBkYXRhLlxyXG4gICAgICAgIHYucHVzaFNhdmUgPSBmdW5jdGlvbiBwdXNoU2F2ZSgpIHtcclxuICAgICAgICAgICAgdmFyIHJvbGxiYWNrID0gdi5nZXRSb2xsYmFjaygnb3JpZ2luYWwnKTtcclxuICAgICAgICAgICAgdi5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlKClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZlcnNpb24gZGF0YSB3aXRoIHRoZSBuZXcgb25lXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSByZW1vdGUsIHRoYXQgbWF5IGluY2x1ZGUgcmVtb3RlIGNvbXB1dGVkXHJcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXM6XHJcbiAgICAgICAgICAgICAgICB2LnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtcyBhIHJvbGxiYWNrIG9mIHRoZSBvcmlnaW5hbCBtb2RlbFxyXG4gICAgICAgICAgICAgICAgcm9sbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSB2ZXJzaW9uIGRhdGEga2VlcHMgdW50b3VjaGVkLCB1c2VyIG1heSB3YW50IHRvIHJldHJ5XHJcbiAgICAgICAgICAgICAgICAvLyBvciBtYWRlIGNoYW5nZXMgb24gaXRzIHVuLXNhdmVkIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmZldGNoID0gb3B0aW9ucy5mZXRjaCB8fCBmdW5jdGlvbiBmZXRjaCgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTsgfTtcclxuICAgIHRoaXMucHVzaCA9IG9wdGlvbnMucHVzaCB8fCBmdW5jdGlvbiBwdXNoKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRkJyk7IH07XHJcblxyXG4gICAgdmFyIGxvYWRGcm9tUmVtb3RlID0gZnVuY3Rpb24gbG9hZEZyb21SZW1vdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJ2ZXJEYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFdmVyIGRlZXBDb3B5LCBzaW5jZSBwbGFpbiBkYXRhIGZyb20gdGhlIHNlcnZlciAoYW5kIGFueVxyXG4gICAgICAgICAgICAgICAgLy8gaW4gYmV0d2VlbiBjb252ZXJzaW9uIG9uICdmZWN0aCcpIGNhbm5vdCBoYXZlIGNpcmN1bGFyXHJcbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2VzOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLm1vZGVsLnVwZGF0ZVdpdGgoc2VydmVyRGF0YSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGVyc2lzdGVudCBsb2NhbCBjb3B5P1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxTdG9yYWdlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0odGhpcy5sb2NhbFN0b3JhZ2VOYW1lLCBzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3RlIG1vZGVsIGRpZCBub3QgcmV0dXJuZWQgZGF0YSwgcmVzcG9uc2UgbXVzdCBiZSBhIFwiTm90IEZvdW5kXCInKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRXZlbnRcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgc2VydmVyRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIHNlcnZlckRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5hbGx5OiBjb21tb24gdGFza3Mgb24gc3VjY2VzcyBvciBlcnJvclxyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUubGF0ZXN0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG5cclxuICAgICAgICAgICAgdmFyIHdhc0xvYWQgPSB0aGlzLmlzTG9hZGluZygpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluYWxseTogY29tbW9uIHRhc2tzIG9uIHN1Y2Nlc3Mgb3IgZXJyb3JcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmlzU3luY2luZyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBFdmVudFxyXG4gICAgICAgICAgICB2YXIgZXJyUGtnID0ge1xyXG4gICAgICAgICAgICAgICAgdGFzazogd2FzTG9hZCA/ICdsb2FkJyA6ICdzeW5jJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gQmUgY2FyZWZ1bCB3aXRoICdlcnJvcicgZXZlbnQsIGlzIHNwZWNpYWwgYW5kIHN0b3BzIGV4ZWN1dGlvbiBvbiBlbWl0XHJcbiAgICAgICAgICAgIC8vIGlmIG5vIGxpc3RlbmVycyBhdHRhY2hlZDogb3ZlcndyaXR0aW5nIHRoYXQgYmVoYXZpb3IgYnkganVzdFxyXG4gICAgICAgICAgICAvLyBwcmludCBvbiBjb25zb2xlIHdoZW4gbm90aGluZywgb3IgZW1pdCBpZiBzb21lIGxpc3RlbmVyOlxyXG4gICAgICAgICAgICBpZiAoRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyUGtnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIExvZyBpdCB3aGVuIG5vdCBoYW5kbGVkIChldmVuIGlmIHRoZSBwcm9taXNlIGVycm9yIGlzIGhhbmRsZWQpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSZW1vdGVNb2RlbCBFcnJvcicsIGVyclBrZyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlLm11c3RSZXZhbGlkYXRlKCkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWVMb2FkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nKHRydWUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSWYgbG9jYWwgc3RvcmFnZSBpcyBzZXQgZm9yIHRoaXMsIGxvYWQgZmlyc3RcclxuICAgICAgICAgICAgLy8gZnJvbSBsb2NhbCwgdGhlbiBmb2xsb3cgd2l0aCBzeW5jaW5nIGZyb20gcmVtb3RlXHJcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWVMb2FkICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsU3RvcmFnZU5hbWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbG9jYWxmb3JhZ2UuZ2V0SXRlbSh0aGlzLmxvY2FsU3RvcmFnZU5hbWUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsb2NhbERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5tb2RlbC51cGRhdGVXaXRoKGxvY2FsRGF0YSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIGRvbmU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYWwgbG9hZCBkb25lLCBkbyBhIGJhY2tncm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3RlIGxvYWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRGcm9tUmVtb3RlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2F0Y2ggYW55IHByb21pc2UtZXJyb3Igb24gdGhlIHJlbW90ZSwgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBlcnJvcnMgYmVpbmcgdW5jYXRjaCwgdGhleSBzdGlsbCBjYW4gYmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggdXNpbmcgdGhlICdlcnJvcicgZXZlbnQgb24gdGhlIFJlbW90ZU1vZGVsIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGRvbid0IHdhaXQsIHJldHVybiBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gZGF0YSwgcGVyZm9ybSBhIHJlbW90ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIGFuZCB3YWl0IGZvciBpdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRGcm9tUmVtb3RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIHJlbW90ZSBsb2FkOlxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IGxvYWRGcm9tUmVtb3RlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUsIGJsb2NraW5nIGxvYWQ6XHJcbiAgICAgICAgICAgIC8vIGl0IHJldHVybnMgd2hlbiB0aGUgbG9hZCByZXR1cm5zXHJcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWVMb2FkKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWVMb2FkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIHRoZSBwcm9taXNlIGFuZCB3aWxsIHdhaXQgZm9yIHRoZSBmaXJzdCBsb2FkOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGxvYWQ6IGlzIGxvYWRpbmcgc3RpbGxcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGNhY2hlZCBkYXRhIHNvIHdlIHVzZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBmb3Igbm93LlxyXG4gICAgICAgICAgICAgICAgLy8gQ2F0Y2ggYW55IHByb21pc2UtZXJyb3Igb24gdGhlIHJlbW90ZSwgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgZXJyb3JzIGJlaW5nIHVuY2F0Y2gsIHRoZXkgc3RpbGwgY2FuIGJlXHJcbiAgICAgICAgICAgICAgICAvLyBjYXRjaCB1c2luZyB0aGUgJ2Vycm9yJyBldmVudCBvbiB0aGUgUmVtb3RlTW9kZWwgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uKCkgeyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIElmIGFueXRoaW5nIG5ldyBmcm9tIG91dHNpZGVcclxuICAgICAgICAgICAgICAgIC8vIHZlcnNpb25zIHdpbGwgZ2V0IG5vdGlmaWVkIHdpdGggaXNPYnNvbGV0ZSgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiBjYWNoZWQgZGF0YSwgbm8gbmVlZCB0byBsb2FkIGFnYWluIGZvciBub3cuXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XHJcbiAgICAgICAgdGhpcy5pc1NhdmluZyh0cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgdGltZXN0YW1wIGFmdGVyIGJlaW5nIHNhdmVkXHJcbiAgICAgICAgLy8gdG8gYXZvaWQgZmFsc2UgJ29ic29sZXRlJyB3YXJuaW5ncyB3aXRoXHJcbiAgICAgICAgLy8gdGhlIHZlcnNpb24gdGhhdCBjcmVhdGVkIHRoZSBuZXcgb3JpZ2luYWxcclxuICAgICAgICB2YXIgdHMgPSB0aGlzLmRhdGEubW9kZWwuZGF0YVRpbWVzdGFtcCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKClcclxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VydmVyRGF0YSkge1xyXG4gICAgICAgICAgICAvLyBFdmVyIGRlZXBDb3B5LCBzaW5jZSBwbGFpbiBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICAgICAgICAvLyBjYW5ub3QgaGF2ZSBjaXJjdWxhciByZWZlcmVuY2VzOlxyXG4gICAgICAgICAgICB0aGlzLmRhdGEubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLm1vZGVsLmRhdGFUaW1lc3RhbXAodHMpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gcGVyc2lzdGVudCBsb2NhbCBjb3B5P1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbFN0b3JhZ2VOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGZvcmFnZS5zZXRJdGVtKHRoaXMubG9jYWxTdG9yYWdlTmFtZSwgc2VydmVyRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEV2ZW50XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc2F2ZWQnLCBzZXJ2ZXJEYXRhKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHk6IGNvbW1vbiB0YXNrcyBvbiBzdWNjZXNzIG9yIGVycm9yXHJcbiAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jYWNoZS5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHk6IGNvbW1vbiB0YXNrcyBvbiBzdWNjZXNzIG9yIGVycm9yXHJcbiAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRXZlbnRcclxuICAgICAgICAgICAgdmFyIGVyclBrZyA9IHtcclxuICAgICAgICAgICAgICAgIHRhc2s6ICdzYXZlJyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gQmUgY2FyZWZ1bCB3aXRoICdlcnJvcicgZXZlbnQsIGlzIHNwZWNpYWwgYW5kIHN0b3BzIGV4ZWN1dGlvbiBvbiBlbWl0XHJcbiAgICAgICAgICAgIC8vIGlmIG5vIGxpc3RlbmVycyBhdHRhY2hlZDogb3ZlcndyaXR0aW5nIHRoYXQgYmVoYXZpb3IgYnkganVzdFxyXG4gICAgICAgICAgICAvLyBwcmludCBvbiBjb25zb2xlIHdoZW4gbm90aGluZywgb3IgZW1pdCBpZiBzb21lIGxpc3RlbmVyOlxyXG4gICAgICAgICAgICBpZiAoRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyUGtnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIExvZyBpdCB3aGVuIG5vdCBoYW5kbGVkIChldmVuIGlmIHRoZSBwcm9taXNlIGVycm9yIGlzIGhhbmRsZWQpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSZW1vdGVNb2RlbCBFcnJvcicsIGVyclBrZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgICAgTGF1bmNoIGEgc3luY2luZyByZXF1ZXN0LiBSZXR1cm5zIG5vdGhpbmcsIHRoZVxyXG4gICAgICAgIHdheSB0byB0cmFjayBhbnkgcmVzdWx0IGlzIHdpdGggZXZlbnRzIG9yIFxyXG4gICAgICAgIHRoZSBpbnN0YW5jZSBvYnNlcnZhYmxlcy5cclxuICAgICAgICBJTVBPUlRBTlQ6IHJpZ2h0IG5vdyBpcyBqdXN0IGEgcmVxdWVzdCBmb3IgJ2xvYWQnXHJcbiAgICAgICAgdGhhdCBhdm9pZHMgcHJvbWlzZSBlcnJvcnMgZnJvbSB0aHJvd2luZy5cclxuICAgICoqL1xyXG4gICAgdGhpcy5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcclxuICAgICAgICAvLyBDYWxsIGZvciBhIGxvYWQsIHRoYXQgd2lsbCBiZSB0cmVhdGVkIGFzICdzeW5jaW5nJyBhZnRlciB0aGVcclxuICAgICAgICAvLyBmaXJzdCBsb2FkXHJcbiAgICAgICAgdGhpcy5sb2FkKClcclxuICAgICAgICAvLyBBdm9pZCBlcnJvcnMgZnJvbSB0aHJvd2luZyBpbiB0aGUgY29uc29sZSxcclxuICAgICAgICAvLyB0aGUgJ2Vycm9yJyBldmVudCBpcyB0aGVyZSB0byB0cmFjayBhbnlvbmUuXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xyXG4gICAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVNb2RlbDtcclxuXHJcblJlbW90ZU1vZGVsLl9pbmhlcml0cyhFdmVudEVtaXR0ZXIpO1xyXG4iLCIvKipcclxuICAgIFJFU1QgQVBJIGFjY2Vzc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5yZXF1aXJlKCdqcXVlcnkuYWpheFF1ZXVlJyk7XHJcblxyXG5mdW5jdGlvbiBsb3dlckZpcnN0TGV0dGVyKG4pIHtcclxuICAgIHJldHVybiBuICYmIG5bMF0gJiYgblswXS50b0xvd2VyQ2FzZSAmJiAoblswXS50b0xvd2VyQ2FzZSgpICsgbi5zbGljZSgxKSkgfHwgbjtcclxufVxyXG5cclxuZnVuY3Rpb24gbG93ZXJDYW1lbGl6ZU9iamVjdChvYmopIHtcclxuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6OFxyXG4gICAgXHJcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcpIHJldHVybiBvYmo7XHJcblxyXG4gICAgdmFyIHJldCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XHJcbiAgICBmb3IodmFyIGsgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3ayA9IGxvd2VyRmlyc3RMZXR0ZXIoayk7XHJcbiAgICAgICAgICAgIHJldFtuZXdrXSA9IHR5cGVvZihvYmpba10pID09PSAnb2JqZWN0JyA/XHJcbiAgICAgICAgICAgICAgICBsb3dlckNhbWVsaXplT2JqZWN0KG9ialtrXSkgOlxyXG4gICAgICAgICAgICAgICAgb2JqW2tdXHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZXN0KG9wdGlvbnNPclVybCkge1xyXG4gICAgXHJcbiAgICB2YXIgdXJsID0gdHlwZW9mKG9wdGlvbnNPclVybCkgPT09ICdzdHJpbmcnID9cclxuICAgICAgICBvcHRpb25zT3JVcmwgOlxyXG4gICAgICAgIG9wdGlvbnNPclVybCAmJiBvcHRpb25zT3JVcmwudXJsO1xyXG5cclxuICAgIHRoaXMuYmFzZVVybCA9IHVybDtcclxuICAgIC8vIE9wdGlvbmFsIGV4dHJhSGVhZGVycyBmb3IgYWxsIHJlcXVlc3RzLFxyXG4gICAgLy8gdXN1YWxseSBmb3IgYXV0aGVudGljYXRpb24gdG9rZW5zXHJcbiAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG51bGw7XHJcbn1cclxuXHJcblJlc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChhcGlVcmwsIGRhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXBpVXJsLCAnZ2V0JywgZGF0YSk7XHJcbn07XHJcblxyXG5SZXN0LnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBnZXQoYXBpVXJsLCBkYXRhKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFwaVVybCwgJ3B1dCcsIGRhdGEpO1xyXG59O1xyXG5cclxuUmVzdC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIGdldChhcGlVcmwsIGRhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXBpVXJsLCAncG9zdCcsIGRhdGEpO1xyXG59O1xyXG5cclxuUmVzdC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gZ2V0KGFwaVVybCwgZGF0YSkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcGlVcmwsICdkZWxldGUnLCBkYXRhKTtcclxufTtcclxuXHJcblJlc3QucHJvdG90eXBlLnB1dEZpbGUgPSBmdW5jdGlvbiBwdXRGaWxlKGFwaVVybCwgZGF0YSkge1xyXG4gICAgLy8gTk9URSBiYXNpYyBwdXRGaWxlIGltcGxlbWVudGF0aW9uLCBvbmUgZmlsZSwgdXNlIGZpbGVVcGxvYWQ/XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFwaVVybCwgJ2RlbGV0ZScsIGRhdGEsICdtdWx0aXBhcnQvZm9ybS1kYXRhJyk7XHJcbn07XHJcblxyXG5SZXN0LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChhcGlVcmwsIGh0dHBNZXRob2QsIGRhdGEsIGNvbnRlbnRUeXBlKSB7XHJcbiAgICBcclxuICAgIHZhciB0aGlzUmVzdCA9IHRoaXM7XHJcbiAgICB2YXIgdXJsID0gdGhpcy5iYXNlVXJsICsgYXBpVXJsO1xyXG5cclxuICAgIC8vIFVzaW5nIGEgcHJvbWlzZSB0byBhdm9pZCB0aGUgZGlmZmVyZW5jZXMgYW5kIHByb2JsZW1zIG9mIHRoZSBqUXVlcnkgdGhlbmFibGVcclxuICAgIC8vIG9iamVjdCwgYnV0IGF0dGFjaGluZyBpdHMgb3JpZ2luYWwgdmFsdWUgYXMgYSBuZXcgcHJvcGVydHkgJ3hocicgb2YgdGhlIHByb21pc2VcclxuICAgIC8vIGNyZWF0ZWQgZm9yIGFkdmFuY2VkIHVzZS5cclxuICAgIHZhciB4aHIgPSAkLmFqYXhRdWV1ZSh7XHJcbiAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgLy8gQXZvaWQgY2FjaGUgZm9yIGRhdGEuXHJcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgbWV0aG9kOiBodHRwTWV0aG9kLFxyXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzLFxyXG4gICAgICAgIC8vIFVSTEVOQ09ERUQgaW5wdXQ6XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBKU09OIGFuZCBiYWNrIGp1c3QgdG8gZW5zdXJlIHRoZSB2YWx1ZXMgYXJlIGNvbnZlcnRlZC9lbmNvZGVkXHJcbiAgICAgICAgLy8gcHJvcGVybHkgdG8gYmUgc2VudCwgbGlrZSBEYXRlcyBiZWluZyBjb252ZXJ0ZWQgdG8gSVNPIGZvcm1hdC5cclxuICAgICAgICBkYXRhOiBkYXRhICYmIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpLFxyXG4gICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xyXG4gICAgICAgIC8vIEFsdGVybmF0ZTogSlNPTiBhcyBpbnB1dFxyXG4gICAgICAgIC8vZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXHJcbiAgICAgICAgLy9jb250ZW50VHlwZTogY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgcHJvbWlzZVhociA9IFByb21pc2UucmVzb2x2ZSh4aHIpXHJcbiAgICAudGhlbihsb3dlckNhbWVsaXplT2JqZWN0KVxyXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIC8vIE9uIGF1dGhvcml6YXRpb24gZXJyb3IsIGdpdmUgb3BvcnR1bml0eSB0byByZXRyeSB0aGUgb3BlcmF0aW9uXHJcbiAgICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgICAgICB2YXIgcmV0cnkgPSByZXF1ZXN0LmJpbmQodGhpcywgYXBpVXJsLCBodHRwTWV0aG9kLCBkYXRhLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHZhciByZXRyeVByb21pc2UgPSB0aGlzUmVzdC5vbkF1dGhvcml6YXRpb25SZXF1aXJlZChyZXRyeSk7XHJcbiAgICAgICAgICAgIGlmIChyZXRyeVByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0IHJldHVybmVkIHNvbWV0aGluZywgZXhwZWN0aW5nIGlzIGEgcHJvbWlzZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmV0cnlQcm9taXNlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgZXJyb3Igb24gcmV0cnksIGp1c3QgcmV0dXJuIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIGNhbGwgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYnkgZGVmYXVsdCwgY29udGludWUgcHJvcGFnYXRpbmcgdGhlIGVycm9yXHJcbiAgICAgICAgcmV0dXJuIGVycjtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBwcm9taXNlWGhyLnhociA9IHhocjtcclxuICAgIHJldHVybiBwcm9taXNlWGhyO1xyXG59O1xyXG5cclxuUmVzdC5wcm90b3R5cGUub25BdXRob3JpemF0aW9uUmVxdWlyZWQgPSBmdW5jdGlvbiBvbkF1dGhvcml6YXRpb25SZXF1aXJlZCgvKnJldHJ5Ki8pIHtcclxuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIG91dHNpZGUsIGlmIGNvbnZlbmllbnQgZXhlY3V0aW5nOlxyXG4gICAgLy9yZXRyeSgpO1xyXG4gICAgLy8gYnkgZGVmYXVsdCBkb24ndCB3YWl0IGZvciByZXRyeSwganVzdCByZXR1cm4gbm90aGluZzpcclxuICAgIHJldHVybjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdDtcclxuIiwiLyoqXHJcbiAgICBUaW1lIGNsYXNzIHV0aWxpdHkuXHJcbiAgICBTaG9ydGVyIHdheSB0byBjcmVhdGUgYSBEYXRlIGluc3RhbmNlXHJcbiAgICBzcGVjaWZ5aW5nIG9ubHkgdGhlIFRpbWUgcGFydCxcclxuICAgIGRlZmF1bHRpbmcgdG8gY3VycmVudCBkYXRlIG9yIFxyXG4gICAgYW5vdGhlciByZWFkeSBkYXRlIGluc3RhbmNlLlxyXG4qKi9cclxuZnVuY3Rpb24gVGltZShkYXRlLCBob3VyLCBtaW51dGUsIHNlY29uZCkge1xyXG4gICAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XHJcbiBcclxuICAgICAgICBzZWNvbmQgPSBtaW51dGU7XHJcbiAgICAgICAgbWludXRlID0gaG91cjtcclxuICAgICAgICBob3VyID0gZGF0ZTtcclxuICAgICAgICBcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUoKTsgICBcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBUaW1lO1xyXG4iLCIvKipcclxuICAgIENyZWF0ZSBhbiBBY2Nlc3MgQ29udHJvbCBmb3IgYW4gYXBwIHRoYXQganVzdCBjaGVja3NcclxuICAgIHRoZSBhY3Rpdml0eSBwcm9wZXJ0eSBmb3IgYWxsb3dlZCB1c2VyIGxldmVsLlxyXG4gICAgVG8gYmUgcHJvdmlkZWQgdG8gU2hlbGwuanMgYW5kIHVzZWQgYnkgdGhlIGFwcC5qcyxcclxuICAgIHZlcnkgdGllZCB0byB0aGF0IGJvdGggY2xhc3Nlcy5cclxuICAgIFxyXG4gICAgQWN0aXZpdGllcyBjYW4gZGVmaW5lIG9uIGl0cyBvYmplY3QgYW4gYWNjZXNzTGV2ZWxcclxuICAgIHByb3BlcnR5IGxpa2UgbmV4dCBleGFtcGxlc1xyXG4gICAgXHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gYXBwLlVzZXJ0eXBlLlVzZXI7IC8vIGFueW9uZVxyXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IGFwcC5Vc2VyVHlwZS5Bbm9ueW1vdXM7IC8vIGFub255bW91cyB1c2VycyBvbmx5XHJcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gYXBwLlVzZXJUeXBlLkxvZ2dlZFVzZXI7IC8vIGF1dGhlbnRpY2F0ZWQgdXNlcnMgb25seVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVXNlclR5cGUgZW51bWVyYXRpb24gaXMgYml0IGJhc2VkLCBzbyBzZXZlcmFsXHJcbi8vIHVzZXJzIGNhbiBoYXMgYWNjZXNzIGluIGEgc2luZ2xlIHByb3BlcnR5XHJcbi8vdmFyIFVzZXJUeXBlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1VzZXInKS5Vc2VyVHlwZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlQWNjZXNzQ29udHJvbChhcHApIHtcclxuICAgIFxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFjY2Vzc0NvbnRyb2wocm91dGUpIHtcclxuXHJcbiAgICAgICAgdmFyIGFjdGl2aXR5ID0gYXBwLmdldEFjdGl2aXR5Q29udHJvbGxlckJ5Um91dGUocm91dGUpO1xyXG5cclxuICAgICAgICB2YXIgdXNlciA9IGFwcC5tb2RlbC51c2VyKCk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRUeXBlID0gdXNlciAmJiB1c2VyLnVzZXJUeXBlKCk7XHJcblxyXG4gICAgICAgIGlmIChhY3Rpdml0eSAmJiBhY3Rpdml0eS5hY2Nlc3NMZXZlbCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbiA9IGFjdGl2aXR5LmFjY2Vzc0xldmVsICYgY3VycmVudFR5cGU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIWNhbikge1xyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IGVycm9yLCB3aHkgY2Fubm90IGFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZExldmVsOiBhY3Rpdml0eS5hY2Nlc3NMZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHlwZTogY3VycmVudFR5cGVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFsbG93XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG59O1xyXG4iLCIvKipcclxuICAgIFNldCBvZiBmdW5jdGlvbnMgdG8gbWFrZSBjYWxjdWxhdGlvbnMgb2YgYXZhaWxhYmlsaXR5XHJcbiAgICBwZXIgZGF0ZSBnaXZlbiBhIGxpc3Qgb2YgYXBwb2ludG1lbnRzLlxyXG4gICAgSXQgYWxsb3dzIHRvIHNvcnQgdGhlbSwgY3JlYXRlIGFuZCBpbnNlcnQgZnJlZS91bmF2YWlsYWJsZSBhcHBvaW50bWVudHNcclxuICAgIGZvbGxvd2luZyBhIGdpdmVuIGRheVNjaGVkdWxlIGFuZCBzdW1tYXJpemUgdGhlIGRhdGUgYXZhaWxhYmlsaXR5IHN0YXR1cy5cclxuICAgIFxyXG4gICAgSXQgcmVsaWVzIChkaXJlY3RseSBvciBub3QpIGluIG1vZGVscyBsaWtlIEFwcG9pbnRtZW50LCBcclxuICAgIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5XZWVrRGF5U2NoZWR1bGUuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5cclxuZXhwb3J0cy5zb3J0QXBwb2ludG1lbnRzID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgdmFyIGFzID0gYS5zdGFydFRpbWUoKSxcclxuICAgICAgICBhZSA9IGEuZW5kVGltZSgpLFxyXG4gICAgICAgIGJzID0gYi5zdGFydFRpbWUoKSxcclxuICAgICAgICBiZSA9IGIuZW5kVGltZSgpO1xyXG5cclxuICAgIGlmIChhcyA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBlbHNlIGlmIChicyA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gMTtcclxuXHJcbiAgICB2YXIgZXEgPSBhcy50b0lTT1N0cmluZygpID09PSBicy50b0lTT1N0cmluZygpO1xyXG4gICAgaWYgKGVxKSB7XHJcbiAgICAgICAgaWYgKGFlID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgZWxzZSBpZiAoYmUgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBhZSAtIGJlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGFzIC0gYnM7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICAgIEl0IGFkZHMgYmVmb3JlIGV2ZXJ5IGJvb2tpbmcgYXB0L3Nsb3QgYSAncHJlcGFyYXRpb24gdGltZScgc2xvdCBmb3IgdGhlICdwcmVwYXJhdGlvbkhvdXJzJyAoQUtBICdiZXR3ZWVuVGltZScpLlxyXG4gICAgVGhlIGdpdmVuIHNsb3RzIGFycmF5IE1VU1QgQkUgU09SVEVELlxyXG4gICAgSXQgdGFrZXMgY2FyZSB0bzpcclxuICAgIC0gZG8gbm90IGFkZCBzbG90cyBvdXQgb2YgdGhlIGdpdmVuIGRhdGVcclxuICAgIC0gZG8gbm90IGFkZCBzbG90cyB0aGF0IG92ZXJsYXkgb3RoZXIgYm9va2luZ3MgKGlmIHR3byBib29raW5ncyB0b28gY2xvc2U7IGJlY2F1c2Ugb2YgbWFudWFsIHRpbWluZyBvciBwcmVmZXJlbmNlXHJcbiAgICAgIGNoYW5nZSBvZiB0aGUgcHJlcGFyYXRpb25Ib3VycylcclxuKiovXHJcbmV4cG9ydHMuZmlsbFByZXBhcmF0aW9uVGltZVNsb3RzID0gZnVuY3Rpb24gZmlsbFByZXBhcmF0aW9uVGltZVNsb3RzKGRhdGUsIHNsb3RzLCBwcmVwYXJhdGlvbkhvdXJzKSB7XHJcbiAgICBcclxuICAgIC8vIEluaXRpYWwgY2hlY2sgb2YgcHJldmlvdXMgc2xvdCBzdGFydCBhbmQgZW5kcyBpcyB0aGUgZ2l2ZW4gZGF0ZSAoYXQgbWlkbmlnaHQpXHJcbiAgICAvLyBzbyB3ZSBhdm9pZCB0byBpbnNlcnQgc2xvdHMgb3V0IG9mIHRoZSBkYXRlLlxyXG4gICAgdmFyIHByZXZFbmQgPSBkYXRlO1xyXG5cclxuICAgIHNsb3RzLmZvckVhY2goZnVuY3Rpb24oc2xvdCwgaW5kZXgpIHtcclxuICAgICAgICAvLyBmb3IgZWFjaCBib29raW5nXHJcbiAgICAgICAgaWYgKHNsb3QuaWQoKSA+IDAgJiZcclxuICAgICAgICAgICAgc2xvdC5zb3VyY2VCb29raW5nKCkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBzbG90LnN0YXJ0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtb21lbnQoZW5kKS5zdWJ0cmFjdChwcmVwYXJhdGlvbkhvdXJzLCAnaG91cnMnKS50b0RhdGUoKTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBhdm9pZGluZyB0aGUgcHJlcGFyYXRpb24gc2xvdCBpZiBpdCBlbmRzIGJlZm9yZSBvciBqdXN0IG9uXHJcbiAgICAgICAgICAgIC8vIHRoZSBwcmV2aW91cyBzbG90IGVuZCAob3IgYmVmb3JlIHRoZSBkYXRlKSB0byBhdm9pZCB1bm5lZWRlZCBzbG90c1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBkbyBOT1QgYSAoZW5kIDw9IHByZXZFbmQgcmV0dXJuOykgYmVjYXVzZSB3aWxsIGludHJvZHVjZSBhIGJ1Z1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgcHJldkVuZCB3aWxsIG5vdCBiZSBjb2xsZWN0ZWQsIGZhaWxpbmcgd2hlbiB0aGVyZSBhcmUgXHJcbiAgICAgICAgICAgIC8vIG1vcmUgdGhhbiAyIGNvbnNlY3V0aXZlIGJvb2tpbmdzXHJcbiAgICAgICAgICAgIGlmIChlbmQgPiBwcmV2RW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAuLm9yIGN1dHMgdGhlIGJlZ2dpbmluZyBvZiB0aGUgc2xvdCAoJ3N0YXJ0JykgYnlcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHNsb3QgKHNvIGZpdHMgcGVyZmVjdGx5LCB3aXRob3V0IG92ZXJsYXkpXHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IDwgcHJldkVuZCA/IHByZXZFbmQgOiBzdGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpdHMgYWRkZWQgYmVmb3JlIHRoZSBjdXJyZW50IHNsb3Q6XHJcbiAgICAgICAgICAgICAgICBzbG90cy5zcGxpY2UoaW5kZXgsIDAsIEFwcG9pbnRtZW50Lm5ld1ByZXBhcmF0aW9uVGltZVNsb3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZFbmQgPSBzbG90LmVuZFRpbWUoKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBJbnRyb2R1Y2UgZnJlZSBvciB1bmF2YWlsYWJsZSBzbG90cyB3aGVyZXZlciBuZWVkZWQgaW4gdGhlIGdpdmVuXHJcbiAgICBhcnJheSBvZiBBcHBvaW50bWVudHMsIHRvIGZpbGwgYW55IGdhcCBpbiBhIG5hdHVyYWwgZGF5XHJcbiAgICAoZnJvbSBNaWRuaWdodCB0byBNaWRuaWdodCBuZXh0IGRhdGUpIGFuZCBiYXNlZCBvbiB0aGVcclxuICAgIGdpdmVuIHdlZWsgZGF5IHNjaGVkdWxlLlxyXG4gICAgVGhlIGhvdXJzIGluIHRoZSBzY2hlZHVsZSBhcmUgYXNzdW1lZCBpbiB0aGUgbG9jYWwgdGltZS5cclxuICAgIEEgbmV3IGFycmF5IGlzIHJldHVybmVkLlxyXG4gICAgSXQgaW50cm9kdWNlICdwcmVwYXJhdGlvbiB0aW1lJyBzbG90cyB0b28gYmVmb3JlIG9mIGJvb2tpbmdzIHdoZW4gbmVlZGVkLlxyXG4gICAgXHJcbiAgICBkYXRlIGlzIGEgRGF0ZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGRhdGUgYXMgdXNlZCBpblxyXG4gICAgdGhlIGFwcG9pbnRtZW50c0xpc3Q7IGl0J3MgdXNlZCB3aGVuIG5vIGFwcG9pbnRtZW50cyBleGlzdHMgKHNvXHJcbiAgICBkYXRlIGNhbm5vdCBiZSBleHRyYWN0ZWQgZnJvbSBmaXJzdCBhcHBvaW50ZW50KSB0byByZXR1cm4gYW4gZW1wdHlcclxuICAgIGRhdGUgdW5hdmFpYWxhYmxlL2ZyZWUvdW5hdmFpbGFibGUgc2xvdHM7IGFuZCB3aGVuIGZpbGxpbmcgcHJlcGFyYXRpb24gc2xvdHMsIHRvXHJcbiAgICBhdm9pZCBhZGQgYSBzbG90IHdpdGggdGltZSB0aGF0IHN0YXJ0cyBpbiBhIHByZXZpb3VzIGRhdGVcclxuICAgIFxyXG4gICAgVE9ETzogTWFrZSBpdCBjb21wYXRpYmxlIHdpdGggYW4gaW5pdGlhbCBhcHBvaW50bWVudCB0aGF0IG1heSBzdGFydCBiZWZvcmUgdGhlIFxyXG4gICAgZGF0ZSAoYnV0IGVuZHMgaW5zaWRlIHRoZSBkYXRlKSBhbmQgYSBmaW5hbCBhcHBvaW50bWVudCB0aGF0IG1heSBlbmRcclxuICAgIG9uIHRoZSBuZXh0IGRhdGUgKGJ1dCBzdGFydHMgaW5zaWRlIHRoZSBkYXRlKS5cclxuKiovXHJcbmV4cG9ydHMuZmlsbERheUF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGZpbGxEYXlBdmFpbGFiaWxpdHkoZGF0ZSwgYXBwb2ludG1lbnRzTGlzdCwgd2Vla0RheVNjaGVkdWxlLCBzY2hlZHVsaW5nUHJlZmVyZW5jZXMpIHtcclxuXHJcbiAgICAvLyBTaGFkb3cgY2xvbmVcclxuICAgIHZhciBzbG90cyA9IGFwcG9pbnRtZW50c0xpc3Quc2xpY2UoMCk7XHJcbiAgICAvLyBzb3J0IHRoZSBsaXN0XHJcbiAgICBzbG90cy5zb3J0KGV4cG9ydHMuc29ydEFwcG9pbnRtZW50cyk7XHJcbiAgICAvLyBhZGQgcHJlcGFyYXRpb24gdGltZSBmb3IgZWFjaCBib29raW5nXHJcbiAgICBleHBvcnRzLmZpbGxQcmVwYXJhdGlvblRpbWVTbG90cyhkYXRlLCBzbG90cywgc2NoZWR1bGluZ1ByZWZlcmVuY2VzLmJldHdlZW5UaW1lKCkpO1xyXG5cclxuICAgIHZhciBmaWxsZWRTbG90cyA9IFtdLFxyXG4gICAgICAgIHplcm9UaW1lID0gJzAwOjAwOjAwJyxcclxuICAgICAgICBsYXN0ID0gemVyb1RpbWUsXHJcbiAgICAgICAgbGFzdERhdGVUaW1lID0gbnVsbCxcclxuICAgICAgICB0aW1lRm9ybWF0ID0gJ0hIOm1tOnNzJztcclxuXHJcbiAgICBpZiAoc2xvdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgLy8gTm8gc2xvdHMsIGVtcHR5IGRhdGUgc28gY3JlYXRlIHRoZSByZXF1aXJlZFxyXG4gICAgICAgIC8vIHVuYXZhaWxhYmxlL2ZyZWUvdW5hdmFpbGFibGUgc2xvdHMgZm9yIHRoZSAnZGF0ZSdcclxuICAgICAgICB2YXIgZnVsbFN0YXJ0ID0gbW9tZW50KGRhdGUpLnN0YXJ0T2YoJ2RheScpLFxyXG4gICAgICAgICAgICBmdWxsRW5kID0gZnVsbFN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XHJcblxyXG4gICAgICAgIGZpbGxlZFNsb3RzID0gZXhwb3J0cy5jcmVhdGVTY2hlZHVsZVNsb3RzKHtcclxuICAgICAgICAgICAgc3RhcnQ6IGZ1bGxTdGFydC50b0RhdGUoKSxcclxuICAgICAgICAgICAgZW5kOiBmdWxsRW5kLnRvRGF0ZSgpXHJcbiAgICAgICAgfSwgd2Vla0RheVNjaGVkdWxlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIExvb2sgZm9yIHRpbWUgZ2FwcyBpbiB0aGUgbGlzdFxyXG4gICAgICAgIHNsb3RzLmZvckVhY2goZnVuY3Rpb24oc2xvdCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBzbG90LnN0YXJ0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgcyA9IG1vbWVudChzdGFydCksXHJcbiAgICAgICAgICAgICAgICBlbmQgPSBzbG90LmVuZFRpbWUoKSxcclxuICAgICAgICAgICAgICAgIGUgPSBtb21lbnQoZW5kKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzLmZvcm1hdCh0aW1lRm9ybWF0KSA+IGxhc3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdERhdGVUaW1lID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3Qgc2xvdCBvZiB0aGUgZGF0ZSwgMTJBTT0wMDowMFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3REYXRlVGltZSA9IG5ldyBEYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydC5nZXRGdWxsWWVhcigpLCBzdGFydC5nZXRNb250aCgpLCBzdGFydC5nZXREYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgZ2FwLCBmaWxsIGl0XHJcbiAgICAgICAgICAgICAgICBmaWxsZWRTbG90cy5wdXNoLmFwcGx5KGZpbGxlZFNsb3RzLCBleHBvcnRzLmNyZWF0ZVNjaGVkdWxlU2xvdHMoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsYXN0RGF0ZVRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzdGFydFxyXG4gICAgICAgICAgICAgICAgfSwgd2Vla0RheVNjaGVkdWxlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpbGxlZFNsb3RzLnB1c2goc2xvdCk7XHJcbiAgICAgICAgICAgIGxhc3REYXRlVGltZSA9IGVuZDtcclxuICAgICAgICAgICAgbGFzdCA9IGUuZm9ybWF0KHRpbWVGb3JtYXQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBsYXRlc3QgdG8gc2VlIGEgZ2FwIGF0IHRoZSBlbmQ6XHJcbiAgICAgICAgdmFyIGxhc3RFbmQgPSBsYXN0RGF0ZVRpbWUgJiYgbW9tZW50KGxhc3REYXRlVGltZSkuZm9ybWF0KHRpbWVGb3JtYXQpO1xyXG4gICAgICAgIGlmIChsYXN0RW5kICE9PSB6ZXJvVGltZSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGdhcCwgZmlsbGVkIGl0XHJcbiAgICAgICAgICAgIHZhciBuZXh0TWlkbmlnaHQgPSBuZXcgRGF0ZShcclxuICAgICAgICAgICAgICAgIGxhc3REYXRlVGltZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICAgICAgbGFzdERhdGVUaW1lLmdldE1vbnRoKCksXHJcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGRhdGUhXHJcbiAgICAgICAgICAgICAgICBsYXN0RGF0ZVRpbWUuZ2V0RGF0ZSgpICsgMSxcclxuICAgICAgICAgICAgICAgIC8vIEF0IHplcm8gaG91cnMhXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAwXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBmaWxsZWRTbG90cy5wdXNoLmFwcGx5KGZpbGxlZFNsb3RzLCBleHBvcnRzLmNyZWF0ZVNjaGVkdWxlU2xvdHMoe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3REYXRlVGltZSxcclxuICAgICAgICAgICAgICAgIGVuZDogbmV4dE1pZG5pZ2h0XHJcbiAgICAgICAgICAgIH0sIHdlZWtEYXlTY2hlZHVsZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmlsbGVkU2xvdHM7XHJcbn07XHJcblxyXG4vKipcclxuICAgIEdpdmVuIGEgdGltZSByYW5nZSB3aXRob3V0IGFwcG9pbnRtZW50cywgYW5kIHRoZSBkYXkgc2NoZWR1bGUsXHJcbiAgICBpdCByZXR1cm5zIGFuIGFycmF5IG9mIGFwcG9pbnRtZW50cyBvYmplY3RzIHRvIGZ1bGxmaWxsXHJcbiAgICB0aGF0IGVtcHR5IHJhbmdlIHdpdGggdW5hdmFpbGFibGUvZnJlZSBhcHBvaW50bWVudHMuXHJcbiAgICBcclxuICAgIFRoZSByYW5nZSBtdXN0IGJlIHR3byB0aW1lcyBpbnNpZGUgdGhlIHNhbWUgZGF0ZSAobG9jYWwgdGltZSksIGZvcm1hdFxyXG4gICAgcmFuZ2UgeyBzdGFydDpEYXRlLCBlbmQ6RGF0ZSB9XHJcbiAgICBcclxuICAgIHdlZWtEYXlTY2hlZHVsZSBpcyBhbiBpbnN0YW5jZSBvZiBXZWVrRGF5U2NoZWR1bGUgTW9kZWwsIGJhc2ljYWxseTpcclxuICAgIHsgZnJvbTpvYnNlcnZhYmxlKERhdGUpLCB0bzpvYnNlcnZhYmxlKERhdGUpIH1cclxuKiovXHJcbmV4cG9ydHMuY3JlYXRlU2NoZWR1bGVTbG90cyA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVkdWxlU2xvdHMocmFuZ2UsIHdlZWtEYXlTY2hlZHVsZSkge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxMCovXHJcbiAgICB2YXIgbGlzdCA9IFtdLFxyXG4gICAgICAgIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsXHJcbiAgICAgICAgZW5kID0gcmFuZ2UuZW5kLFxyXG4gICAgICAgIGRhdGUgPSBtb21lbnQoc3RhcnQpLnN0YXJ0T2YoJ2RheScpLFxyXG4gICAgICAgIGZyb20gPSBtb21lbnQoZGF0ZSkuYWRkKHsgbWludXRlczogd2Vla0RheVNjaGVkdWxlLmZyb20oKSB9KS50b0RhdGUoKSxcclxuICAgICAgICB0byA9IG1vbWVudChkYXRlKS5hZGQoeyBtaW51dGVzOiB3ZWVrRGF5U2NoZWR1bGUudG8oKSB9KS50b0RhdGUoKTtcclxuXHJcbiAgICAvLyBJdCBoYXBwZW5zIGJlZm9yZSB0aGUgd2VlayBkYXkgc2NoZWR1bGUgc3RhcnRzXHJcbiAgICB2YXIgYmVmb3JlU2NoZWR1bGUgPSBcclxuICAgICAgICBzdGFydCA8IGZyb20gJiZcclxuICAgICAgICBlbmQgPD0gZnJvbTtcclxuICAgIC8vIEl0IGhhcHBlbnMgYWZ0ZXIgdGhlIHdlZWsgZGF5IHNjaGVkdWxlIGVuZHNcclxuICAgIHZhciBhZnRlclNjaGVkdWxlID0gXHJcbiAgICAgICAgZW5kID4gdG8gJiZcclxuICAgICAgICBzdGFydCA+PSB0bztcclxuICAgIC8vIEl0IGhhcHBlbnMgaW5zaWRlIHRoZSB3ZWVrIGRheSBzY2hlZHVsZVxyXG4gICAgdmFyIGluc2lkZVNjaGVkdWxlID1cclxuICAgICAgICBzdGFydCA+PSBmcm9tICYmXHJcbiAgICAgICAgZW5kIDw9IHRvO1xyXG5cclxuICAgIGlmIChiZWZvcmVTY2hlZHVsZSB8fCBhZnRlclNjaGVkdWxlKSB7XHJcbiAgICAgICAgbGlzdC5wdXNoKFxyXG4gICAgICAgICAgICBBcHBvaW50bWVudC5uZXdVbmF2YWlsYWJsZVNsb3Qoe1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaW5zaWRlU2NoZWR1bGUpIHtcclxuICAgICAgICBsaXN0LnB1c2goXHJcbiAgICAgICAgICAgIEFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90KHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgIGVuZDogZW5kXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIElzIGluIGEgaW50ZXJtZWRpYXRlIHBvc2l0aW9uLCBuZWVkcyB0d29cclxuICAgICAgICAvLyBvciB0aHJlZSBzbG90c1xyXG4gICAgICAgIHZhciBjcm9zc1N0YXJ0ID1cclxuICAgICAgICAgICAgc3RhcnQgPCBmcm9tICYmXHJcbiAgICAgICAgICAgIGVuZCA+IGZyb207XHJcbiAgICAgICAgdmFyIGNyb3NzRW5kID0gXHJcbiAgICAgICAgICAgIHN0YXJ0IDwgdG8gJiZcclxuICAgICAgICAgICAgZW5kID4gdG87XHJcblxyXG4gICAgICAgIGlmIChjcm9zc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIC8vIFVuYXZhaWxhYmxlIHNsb3QgdW50aWwgdGhlICdmcm9tJ1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goXHJcbiAgICAgICAgICAgICAgICBBcHBvaW50bWVudC5uZXdVbmF2YWlsYWJsZVNsb3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGZyb21cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjcm9zc0VuZCkge1xyXG4gICAgICAgICAgICAvLyBVbmF2YWlsYWJsZSBhZnRlciAndG8nXHJcbiAgICAgICAgICAgIGxpc3QucHVzaChcclxuICAgICAgICAgICAgICAgIEFwcG9pbnRtZW50Lm5ld1VuYXZhaWxhYmxlU2xvdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRvLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNyb3NzU3RhcnQgJiYgY3Jvc3NFbmQpIHtcclxuICAgICAgICAgICAgLy8gRnVsbCBkYXkgZnJlZVxyXG4gICAgICAgICAgICBsaXN0LnB1c2goXHJcbiAgICAgICAgICAgICAgICBBcHBvaW50bWVudC5uZXdGcmVlU2xvdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB0b1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3Jvc3NTdGFydCkge1xyXG4gICAgICAgICAgICAvLyBGcmVlIHNsb3QgdW50aWwgbWlkIHBvaW50XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChcclxuICAgICAgICAgICAgICAgIEFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90KHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3Jvc3NFbmQpIHtcclxuICAgICAgICAgICAgLy8gRnJlZSBzbG90IGZyb20gbWlkIHBvaW50XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChcclxuICAgICAgICAgICAgICAgIEFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90KHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB0b1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluIHRoZSBjb21wbGV4IGNhc2VzLCBpcyBlYXN5IHRoYXQgdGhlIFxyXG4gICAgLy8gb3JkZXIgZ2V0cyBpbnZlcnNlZCBiZWNhdXNlIG9mIHRoZSBpZi1lbHNlIG5hdHVyYWwgb3JkZXJcclxuICAgIC8vIHNvIGVuc3VyZSBnb2VzIGNvcnJlY3RcclxuICAgIHJldHVybiBsaXN0LnNvcnQoZXhwb3J0cy5zb3J0QXBwb2ludG1lbnRzKTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBCb290a25vY2s6IFNldCBvZiBLbm9ja291dCBCaW5kaW5nIEhlbHBlcnMgZm9yIEJvb3RzdHJhcCBqcyBjb21wb25lbnRzIChqcXVlcnkgcGx1Z2lucylcclxuICAgIFxyXG4gICAgRGVwZW5kZW5jaWVzOiBqcXVlcnlcclxuICAgIEluamVjdGVkIGRlcGVuZGVuY2llczoga25vY2tvdXRcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIERlcGVuZGVuY2llc1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG4vLyBESSBpMThuIGxpYnJhcnlcclxuZXhwb3J0cy5pMThuID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUhlbHBlcnMoa28pIHtcclxuICAgIHZhciBoZWxwZXJzID0ge307XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgQmluZGluZyAqKi9cclxuICAgIGhlbHBlcnMucG9wb3ZlciA9IHtcclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNyY09wdGlvbnMgPSBrby51bndyYXAodmFsdWVBY2Nlc3NvcigpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIER1cGxpY2F0aW5nIG9wdGlvbnMgb2JqZWN0IHRvIHBhc3MgdG8gcG9wb3ZlciB3aXRob3V0XHJcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0dG5nIHNvdXJjZSBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHNyY09wdGlvbnMpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVW53cmFwcGluZyBjb250ZW50IHRleHRcclxuICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50ID0ga28udW53cmFwKHNyY09wdGlvbnMuY29udGVudCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gTG9jYWxpemU6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRlbnQgPSBcclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmkxOG4gJiYgZXhwb3J0cy5pMThuLnQob3B0aW9ucy5jb250ZW50KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGVudDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gVG8gZ2V0IHRoZSBuZXcgb3B0aW9ucywgd2UgbmVlZCBkZXN0cm95IGl0IGZpcnN0OlxyXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5wb3BvdmVyKCdkZXN0cm95JykucG9wb3ZlcihvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZSBtdWVzdHJhIHNpIGVsIGVsZW1lbnRvIHRpZW5lIGVsIGZvY29cclxuICAgICAgICAgICAgICAgIGlmICgkKGVsZW1lbnQpLmlzKCc6Zm9jdXMnKSlcclxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnBvcG92ZXIoJ3Nob3cnKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLnBvcG92ZXIoJ2Rlc3Ryb3knKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBoZWxwZXJzO1xyXG59XHJcblxyXG4vKipcclxuICAgIFBsdWcgaGVscGVycyBpbiB0aGUgcHJvdmlkZWQgS25vY2tvdXQgaW5zdGFuY2VcclxuKiovXHJcbmZ1bmN0aW9uIHBsdWdJbihrbywgcHJlZml4KSB7XHJcbiAgICB2YXIgbmFtZSxcclxuICAgICAgICBoZWxwZXJzID0gY3JlYXRlSGVscGVycyhrbyk7XHJcbiAgICBcclxuICAgIGZvcih2YXIgaCBpbiBoZWxwZXJzKSB7XHJcbiAgICAgICAgaWYgKGhlbHBlcnMuaGFzT3duUHJvcGVydHkgJiYgIWhlbHBlcnMuaGFzT3duUHJvcGVydHkoaCkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBuYW1lID0gcHJlZml4ID8gcHJlZml4ICsgaFswXS50b1VwcGVyQ2FzZSgpICsgaC5zbGljZSgxKSA6IGg7XHJcbiAgICAgICAga28uYmluZGluZ0hhbmRsZXJzW25hbWVdID0gaGVscGVyc1toXTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0cy5wbHVnSW4gPSBwbHVnSW47XHJcbmV4cG9ydHMuY3JlYXRlQmluZGluZ0hlbHBlcnMgPSBjcmVhdGVIZWxwZXJzO1xyXG4iLCIvKipcclxuICAgIEtub2Nrb3V0IEJpbmRpbmcgSGVscGVyIGZvciB0aGUgQm9vdHN0cmFwIFN3aXRjaCBwbHVnaW4uXHJcbiAgICBcclxuICAgIERlcGVuZGVuY2llczoganF1ZXJ5LCBib290c3RyYXAsIGJvb3RzdHJhcC1zd2l0Y2hcclxuICAgIEluamVjdGVkIGRlcGVuZGVuY2llczoga25vY2tvdXRcclxuICAgIFxyXG4gICAgSU1QT1JUQU5UIE5PVEVTOlxyXG4gICAgLSBBIGNvbnNvbGUgZXJyb3Igb2YgdHlwZSBcIm9iamVjdCBoYXMgbm90IHRoYXQgcHJvcGVydHlcIiB3aWxsIGhhcHBlbiBpZiBzcGVjaWZpZWRcclxuICAgICAgICBhIG5vbiBleGlzdGFudCBvcHRpb24gaW4gdGhlIGJpbmRpbmcuIFRoZSBlcnJvciBsb29rcyBzdHJhbmdlIHdoZW4gdXNpbmcgdGhlIG1pbmlmaWVkIGZpbGUuXHJcbiAgICAtIFRoZSBvcmRlciBvZiBvcHRpb25zIGluIHRoZSBiaW5kaW5nIG1hdHRlcnMgd2hlbiBjb21iaW5pbmcgd2l0aCBkaXNhYmxlZCBhbmQgcmVhZG9ubHlcclxuICAgICAgICBvcHRpb25zOiBpZiB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZDp0cnVlIG9yIHJlYWRvbmx5OnRydWUsIGFueSBhdHRlbXB0IHRvIGNoYW5nZSB0aGVcclxuICAgICAgICB2YWx1ZSB3aWxsIGZhaWwgc2lsZW50bHksIHNvIGlmIHRoZSBzYW1lIGJpbmRpbmcgdXBkYXRlIGNoYW5nZXMgZGlzYWJsZWQgdG8gZmFsc2VcclxuICAgICAgICBhbmQgdGhlIHN0YXRlLCB0aGUgJ2Rpc2FibGVkJyBjaGFuZ2UgbXVzdCBoYXBwZW5zIGJlZm9yZSB0aGUgJ3N0YXRlJyBjaGFuZ2Ugc28gYm90aFxyXG4gICAgICAgIGFyZSBzdWNjZXNzZnVsbHkgdXBkYXRlZC4gRm9yIHRoYXQsIGp1c3Qgc3BlY2lmeSAnZGlzYWJsZWQnIGJlZm9yZSAnc3RhdGUnIGluIHRoZSBiaW5kaW5nc1xyXG4gICAgICAgIGRlZmluaXRpb24uXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBEZXBlbmRlbmNpZXNcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxucmVxdWlyZSgnYm9vdHN0cmFwJyk7XHJcbnJlcXVpcmUoJ2Jvb3RzdHJhcC1zd2l0Y2gnKTtcclxuXHJcbi8qKlxyXG4gICAgQ3JlYXRlIGFuZCBwbHVnLWluIHRoZSBCaW5kaW5nIGluIHRoZSBwcm92aWRlZCBLbm9ja291dCBpbnN0YW5jZVxyXG4qKi9cclxuZXhwb3J0cy5wbHVnSW4gPSBmdW5jdGlvbiBwbHVnSW4oa28sIHByZWZpeCkge1xyXG5cclxuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1twcmVmaXggPyBwcmVmaXggKyAnc3dpdGNoJyA6ICdzd2l0Y2gnXSA9IHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwbHVnaW4gaW5zdGFuY2VcclxuICAgICAgICAgICAgJChlbGVtZW50KS5ib290c3RyYXBTd2l0Y2goKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N3aXRjaCBpbml0Jywga28udG9KUyh2YWx1ZUFjY2Vzc29yKCkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHZhbHVlIG9uIHBsdWdpbiBjaGFuZ2VzXHJcbiAgICAgICAgICAgICQoZWxlbWVudCkub24oJ3N3aXRjaENoYW5nZS5ib290c3RyYXBTd2l0Y2gnLCBmdW5jdGlvbiAoZSwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsdWVBY2Nlc3NvcigpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3dpdGNoQ2hhbmdlJywga28udG9KUyh2KSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZWQ/XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSAhIWtvLnVud3JhcCh2LnN0YXRlKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9ICEhc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBvbiBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZSAhPT0gbmV3U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHYuc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrby5pc1dyaXRlYWJsZU9ic2VydmFibGUodi5zdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuc3RhdGUobmV3U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi5zdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgLy8gR2V0IG9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgcGx1Z2luIGluc3RhbmNlXHJcbiAgICAgICAgICAgIHZhciBzcmNPcHRpb25zID0gdmFsdWVBY2Nlc3NvcigpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBzcmNPcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gVW53cmFwcGluZyBldmVyeSBvcHRpb24gdmFsdWUsIGdldHRpbmcgYSBkdXBsaWNhdGVkXHJcbiAgICAgICAgICAgIC8vIHBsYWluIG9iamVjdFxyXG4gICAgICAgICAgICBvcHRpb25zID0ga28udG9KUyhvcHRpb25zKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3dpdGNoIHVwZGF0ZScsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgdmFyICRlbCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBldmVyeSBvcHRpb24gaW4gdGhlIHBsdWdpblxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgJGVsLmJvb3RzdHJhcFN3aXRjaChrZXksIG9wdGlvbnNba2V5XSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgQWxsb3cgYXR0YWNoIGF2YWlsYWJpbGl0eSBsb2FkaW5nIGFuZCBkaXNwbGF5aW5nIGNhcGFiaWxpdGllc1xyXG4gICAgdG8gYSBkYXRlcGlja2VyIGNvbXBvbmVudCBhcyBwYXJ0IG9mIGFuIGFjdGl2aXR5LlxyXG4gICAgXHJcbiAgICBJdCBhdHRhY2hlcyBoYW5kbGVycyBzbyBpdCBsb2FkcyBhbmQgdXBkYXRlIGF2YWlsYWJpbGl0eSB3aGVuZXZlclxyXG4gICAgdGhlIGRpc3BsYXllZCBtb250aCBjaGFuZ2UsIGJ1dCBpdCByZXR1cm5zIGEgbWV0aG9kIHRvIGRvIGl0XHJcbiAgICBvbiBkZW1hbmQsIGxpa2UgaW4gdGhlIGZpcnN0IGxvYWQgYWZ0ZXIgY2hvb3NlIGEgJ2N1cnJlbnQgZGF0ZSdcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXHJcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlRGF0ZXBpY2tlckF2YWlsYWJpbGl0eShhcHAsICRkYXRlcGlja2VyLCBpc0xvYWRpbmcpIHtcclxuICAgIC8vIENhY2hlIERPTSBlbGVtZW50c1xyXG4gICAgdmFyIGRheXNFbGVtZW50cyA9ICRkYXRlcGlja2VyLmRhdGVwaWNrZXIoJ2dldERheXNFbGVtZW50cycpO1xyXG4gICAgLy8gQ2FjaGUgbGFzdCBtb250aCBzaG93ZWQsIHRvIGRvdWJsZSBjaGVjayBsYXRlciBhbmQgZG9uJ3QgbG9hZCBhbiBhbHJlYWR5XHJcbiAgICAvLyBkaXNwbGF5ZWQgbW9udGhcclxuICAgIHZhciBwcmV2TW9udGggPSBudWxsO1xyXG4gICAgXHJcbiAgICAvLyBMaXN0ZW4gdG8gY2FjaGUgY2hhbmdlcyBpbiBvcmRlciB0byBmb3JjZSBhIGRhdGEgbG9hZCAodG8gYXZvaWQgaW52YWxpZFxyXG4gICAgLy8gYXZhaWxhYmlsaXR5IGJlaW5nIGRpc3BsYXllZCBhZnRlciBhbiBhcHQgd2FzIG1vZGlmaWVkKVxyXG4gICAgYXBwLm1vZGVsLmNhbGVuZGFyLm9uKCdjbGVhckNhY2hlJywgZnVuY3Rpb24oZGF0ZXMpIHtcclxuICAgICAgICBpZiAoIWRhdGVzKSB7XHJcbiAgICAgICAgICAgIHByZXZNb250aCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRlcy5zb21lKGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlLmdldE1vbnRoKCkgPT09IHByZXZNb250aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZNb250aCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAgICBJdCB0YWdzLCBpZiB0aGUgbW9udGggY2hhbmdlZCwgdGhlIGNhbGVuZGFyIHdpdGggdGhlIERhdGUgQXZhaWxhYmlsaXR5LlxyXG4gICAgICAgIFRoZSByZWZyZXNoIHBhcmFtIGZvcmNlcyB0aGUgcHJvY2VzcyBldmVuIGlmIHRoZSBzYW1lIG1vbnRoIHRoYW4gcHJldmlvdXNseSB0YWdnZWQvcmVuZGVyZWRcclxuICAgICoqL1xyXG4gICAgdmFyIHRhZ0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIHRhZ0F2YWlsYWJpbGl0eShkYXRlLCByZWZyZXNoKSB7XHJcbiAgICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xyXG4gICAgICAgIC8vIEF2b2lkIGR1cGVzXHJcbiAgICAgICAgaWYgKG1vbnRoID09PSBwcmV2TW9udGggJiYgIXJlZnJlc2gpIHJldHVybjtcclxuICAgICAgICBwcmV2TW9udGggPSBtb250aDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIGtub3cgdGhlIHJhbmdlIG9mIGRhdGVzIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcclxuICAgICAgICAvLyBtb250aGx5IGNhbGVuZGFyLCBmcm9tIHRoZSBmaXJzdCB3ZWVrIGRheSBvZiBmaXJzdCBtb250aCB3ZWVrXHJcbiAgICAgICAgLy8gdG8gNiBmdWxsIHdlZWtzLlxyXG4gICAgICAgIHZhciBzdGFydCA9IG1vbWVudChkYXRlKS5jbG9uZSgpLnN0YXJ0T2YoJ21vbnRoJykuc3RhcnRPZignd2VlaycpLFxyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCg2LCAnd2Vla3MnKTtcclxuXHJcbiAgICAgICAgLy8gU3dpdGNoIGxvYWRpbmcgZmxhZ1xyXG4gICAgICAgIGlmIChpc0xvYWRpbmcpXHJcbiAgICAgICAgICAgIGlzTG9hZGluZyh0cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZXF1ZXN0IHRoZSBkYXRhXHJcbiAgICAgICAgYXBwLm1vZGVsLmNhbGVuZGFyLmdldERhdGVzQXZhaWxhYmlsaXR5KHN0YXJ0LCBlbmQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0QnlEYXRlcykge1xyXG4gICAgICAgICAgICAvLyBXZSBhcmUgc3RpbGwgaW4gdGhlIHNhbWUgc2hvd2VkIG1vbnRoPyAobG9hZGluZyBpcyBhc3luYywgc28gY291bGQgaGF2ZSBjaGFuZ2VkKVxyXG4gICAgICAgICAgICBpZiAobW9udGggIT09ICRkYXRlcGlja2VyLmRhdGVwaWNrZXIoJ2dldFZpZXdEYXRlJykuZ2V0TW9udGgoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gV2UgcmVjZWl2ZWQgYSBzZXQgb2YgRGF0ZUF2YWlsYWJpbGl0eSBvYmplY3RzIHBlciBkYXRlIChpc28gc3RyaW5nIGtleSlcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBldmVyeSBkYXkgZWxlbWVudCwgYW5kIHVzZSBpdHMgZGF0ZSBhdmFpbCBmcm9tIHRoZSByZXN1bHRcclxuICAgICAgICAgICAgZGF5c0VsZW1lbnRzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBqc2hpbnQgbWF4Y29tcGxleGl0eToxMFxyXG4gICAgICAgICAgICAgICAgdmFyICRkYXRlVGQgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gJGRhdGVUZC5kYXRhKCdkYXRlLXRpbWUnKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlQXZhaWwgPSByZXN1bHRCeURhdGVzW21vbWVudChpZCkuZm9ybWF0KCdZWVlZLU1NLUREJyldOyAgIFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEludGVncml0eSBjaGVjayB0byBhdm9pZCBlZGdlIGNhc2UgZXhjZXB0aW9ucyAobXVzdCBub3QgaGFwcGVucywgYnV0IHN0cm9uZ2VyIGNvZGUpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlkIHx8ICFkYXRlQXZhaWwpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBwcmV2aW91cyAndGFnLScgY2xhc3MgZnJvbSB0aGUgY2VsbCBjbGFzc05hbWVzIGFuZCBrZWVwIGZvciBsYXRlciBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIHZhciBjZWxsQ2xhc3MgPSAkZGF0ZVRkLmF0dHIoJ2NsYXNzJykucmVwbGFjZSgvKF58XFxzKXRhZy1bXlxcc10rLywgJycpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCBhIGRhdGUgY2VsbCBjbGFzcyBiYXNlZCBvbiBpdHMgYXZhaWxhYmlsaXR5XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xzID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2goZGF0ZUF2YWlsLmF2YWlsYWJsZVRhZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGFzdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9ICd0YWctbXV0ZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdWxsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gJ3RhZy1ibGFuayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21lZGl1bSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9ICd0YWctZGFyayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvdyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9ICd0YWctd2FybmluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSAndGFnLWRhbmdlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgJGRhdGVUZC5hdHRyKCdjbGFzcycsIGNlbGxDbGFzcyArICcgJyArIGNscyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgYXZhaWxhYmlsaXR5JyxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBGaW5hbGx5XHJcbiAgICAgICAgICAgIGlmIChpc0xvYWRpbmcpXHJcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGVyIHRvIGF1dG8gbG9hZC91cGRhdGUgYXZhaWxhYmlsaXR5IGZvciBkaXNwbGF5ZWQgZGF5XHJcbiAgICAkZGF0ZXBpY2tlci5vbigndmlld0RhdGVDaGFuZ2VkJywgZnVuY3Rpb24oZSwgZCkge1xyXG4gICAgICAgIGlmIChkLnZpZXdNb2RlID09PSAnZGF5cycpIHtcclxuICAgICAgICAgICAgdGFnQXZhaWxhYmlsaXR5KGQudmlld0RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdGFnQXZhaWxhYmlsaXR5O1xyXG59O1xyXG4iLCIvKipcclxuICAgIEVzcGFjZSBhIHN0cmluZyBmb3IgdXNlIG9uIGEgUmVnRXhwLlxyXG4gICAgVXN1YWxseSwgdG8gbG9vayBmb3IgYSBzdHJpbmcgaW4gYSB0ZXh0IG11bHRpcGxlIHRpbWVzXHJcbiAgICBvciB3aXRoIHNvbWUgZXhwcmVzc2lvbnMsIHNvbWUgY29tbW9uIGFyZSBcclxuICAgIGxvb2sgZm9yIGEgdGV4dCAnaW4gdGhlIGJlZ2lubmluZycgKF4pXHJcbiAgICBvciAnYXQgdGhlIGVuZCcgKCQpLlxyXG4gICAgXHJcbiAgICBBdXRob3I6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xNTEzMTIvY29vbGFqODYgYW5kIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy85NDEwL2FyaXN0b3RsZS1wYWdhbHR6aXNcclxuICAgIExpbms6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY5Njk0ODZcclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFJlZmVycmluZyB0byB0aGUgdGFibGUgaGVyZTpcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvcmVnZXhwXHJcbi8vIHRoZXNlIGNoYXJhY3RlcnMgc2hvdWxkIGJlIGVzY2FwZWRcclxuLy8gXFwgXiAkICogKyA/IC4gKCApIHwgeyB9IFsgXVxyXG4vLyBUaGVzZSBjaGFyYWN0ZXJzIG9ubHkgaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW5zaWRlIG9mIGJyYWNrZXRzXHJcbi8vIHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgZXNjYXBlZCwgYnV0IHRoZXkgTUFZIGJlIGVzY2FwZWRcclxuLy8gd2l0aG91dCBhbnkgYWR2ZXJzZSBlZmZlY3RzICh0byB0aGUgYmVzdCBvZiBteSBrbm93bGVkZ2UgYW5kIGNhc3VhbCB0ZXN0aW5nKVxyXG4vLyA6ICEgLCA9IFxyXG4vLyBteSB0ZXN0IFwifiFAIyQlXiYqKCl7fVtdYC89PytcXHwtXzs6J1xcXCIsPC4+XCIubWF0Y2goL1tcXCNdL2cpXHJcblxyXG52YXIgc3BlY2lhbHMgPSBbXHJcbiAgICAvLyBvcmRlciBtYXR0ZXJzIGZvciB0aGVzZVxyXG4gICAgICBcIi1cIlxyXG4gICAgLCBcIltcIlxyXG4gICAgLCBcIl1cIlxyXG4gICAgLy8gb3JkZXIgZG9lc24ndCBtYXR0ZXIgZm9yIGFueSBvZiB0aGVzZVxyXG4gICAgLCBcIi9cIlxyXG4gICAgLCBcIntcIlxyXG4gICAgLCBcIn1cIlxyXG4gICAgLCBcIihcIlxyXG4gICAgLCBcIilcIlxyXG4gICAgLCBcIipcIlxyXG4gICAgLCBcIitcIlxyXG4gICAgLCBcIj9cIlxyXG4gICAgLCBcIi5cIlxyXG4gICAgLCBcIlxcXFxcIlxyXG4gICAgLCBcIl5cIlxyXG4gICAgLCBcIiRcIlxyXG4gICAgLCBcInxcIlxyXG4gIF1cclxuXHJcbiAgLy8gSSBjaG9vc2UgdG8gZXNjYXBlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoICdcXCdcclxuICAvLyBldmVuIHRob3VnaCBvbmx5IHNvbWUgc3RyaWN0bHkgcmVxdWlyZSBpdCB3aGVuIGluc2lkZSBvZiBbXVxyXG4sIHJlZ2V4ID0gUmVnRXhwKCdbJyArIHNwZWNpYWxzLmpvaW4oJ1xcXFwnKSArICddJywgJ2cnKVxyXG47XHJcblxyXG52YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gKHN0cikge1xyXG5yZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIFwiXFxcXCQmXCIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XHJcblxyXG4vLyB0ZXN0IGVzY2FwZVJlZ0V4cChcIi9wYXRoL3RvL3Jlcz9zZWFyY2g9dGhpcy50aGF0XCIpXHJcbiIsIi8qKlxyXG4qIGVzY2FwZVNlbGVjdG9yXHJcbipcclxuKiBzb3VyY2U6IGh0dHA6Ly9ranZhcmdhLmJsb2dzcG90LmNvbS5lcy8yMDA5LzA2L2pxdWVyeS1wbHVnaW4tdG8tZXNjYXBlLWNzcy1zZWxlY3Rvci5odG1sXHJcbipcclxuKiBFc2NhcGUgYWxsIHNwZWNpYWwgalF1ZXJ5IENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGluICpzZWxlY3RvciouXHJcbiogVXNlZnVsIHdoZW4geW91IGhhdmUgYSBjbGFzcyBvciBpZCB3aGljaCBjb250YWlucyBzcGVjaWFsIGNoYXJhY3RlcnNcclxuKiB3aGljaCB5b3UgbmVlZCB0byBpbmNsdWRlIGluIGEgc2VsZWN0b3IuXHJcbiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBzcGVjaWFscyA9IFtcclxuICAnIycsICcmJywgJ34nLCAnPScsICc+JywgXHJcbiAgXCInXCIsICc6JywgJ1wiJywgJyEnLCAnOycsICcsJ1xyXG5dO1xyXG52YXIgcmVnZXhTcGVjaWFscyA9IFtcclxuICAnLicsICcqJywgJysnLCAnfCcsICdbJywgJ10nLCAnKCcsICcpJywgJy8nLCAnXicsICckJ1xyXG5dO1xyXG52YXIgc1JFID0gbmV3IFJlZ0V4cChcclxuICAnKCcgKyBzcGVjaWFscy5qb2luKCd8JykgKyAnfFxcXFwnICsgcmVnZXhTcGVjaWFscy5qb2luKCd8XFxcXCcpICsgJyknLCAnZydcclxuKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShzUkUsICdcXFxcJDEnKTtcclxufTtcclxuIiwiLyoqIGdldERhdGVXaXRob3V0VGltZSB1dGlsaXR5LlxyXG4gICAgUmV0dXJucyBhIG5ldyBEYXRlIGluc3RhbmNlIHdpdGggdGltZSBhdCB6ZXJvZXNcclxuICAgIGFuZCB0aGUgc2FtZSBkYXRlIGFzIHRoZSBpbnB1dC5cclxuICAgIEl0IHJldHVybnMgY3VycmVudCBkYXRlIGlmIG5vIHZhbGlkIGRhdGUgb3Igc3RyaW5nIHBhc3NlZC5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RGF0ZVdpdGhvdXRUaW1lKGRhdGUpIHtcclxuICAgIGlmICghZGF0ZSkge1xyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcclxuICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKFxyXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICBkYXRlLmdldE1vbnRoKCksXHJcbiAgICAgICAgZGF0ZS5nZXREYXRlKCksXHJcbiAgICAgICAgMCwgMCwgMFxyXG4gICAgKTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBHZXQgYSBnaXZlbiB2YWx1ZSB3cmFwcGVkIGluIGFuIG9ic2VydmFibGUgb3IgcmV0dXJuc1xyXG4gICAgaXQgaWYgaXRzIGFscmVhZHkgYW4gb2JzZXJ2YWJsZSBvciBqdXN0IGEgZnVuY3Rpb24uXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE9ic2VydmFibGUob2JzT3JWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZihvYnNPclZhbHVlKSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICByZXR1cm4gb2JzT3JWYWx1ZTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4ga28ub2JzZXJ2YWJsZShvYnNPclZhbHVlKTtcclxufTtcclxuIiwiLyoqXHJcbiAgICBSZWFkIGEgcGFnZSdzIEdFVCBVUkwgdmFyaWFibGVzIGFuZCByZXR1cm4gdGhlbSBhcyBhbiBhc3NvY2lhdGl2ZSBhcnJheS5cclxuKiovXHJcbid1c2VyIHN0cmljdCc7XHJcbi8vZ2xvYmFsIHdpbmRvd1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRVcmxRdWVyeSh1cmwpIHtcclxuXHJcbiAgICB1cmwgPSB1cmwgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcblxyXG4gICAgdmFyIHZhcnMgPSBbXSwgaGFzaCxcclxuICAgICAgICBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKTtcclxuICAgIGlmIChxdWVyeUluZGV4ID4gLTEpIHtcclxuICAgICAgICB2YXIgaGFzaGVzID0gdXJsLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKS5zcGxpdCgnJicpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBoYXNoZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBoYXNoID0gaGFzaGVzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgIHZhcnMucHVzaChoYXNoWzBdKTtcclxuICAgICAgICAgICAgdmFyc1toYXNoWzBdXSA9IGhhc2hbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhcnM7XHJcbn07XHJcbiIsIi8vIGpRdWVyeSBwbHVnaW4gdG8gc2V0IG11bHRpbGluZSB0ZXh0IGluIGFuIGVsZW1lbnQsXHJcbi8vIGJ5IHJlcGxhY2luZyBcXG4gYnkgPGJyLz4gd2l0aCBjYXJlZnVsIHRvIGF2b2lkIFhTUyBhdHRhY2tzLlxyXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzA4MjAyOFxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5cclxuJC5mbi5tdWx0aWxpbmUgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICB0aGlzLnRleHQodGV4dCk7XHJcbiAgICB0aGlzLmh0bWwodGhpcy5odG1sKCkucmVwbGFjZSgvXFxuL2csJzxici8+JykpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgU2V0IG9mIHV0aWxpdGllcyB0byBkZWZpbmUgSmF2YXNjcmlwdCBQcm9wZXJ0aWVzXHJcbiAgICBpbmRlcGVuZGVudGx5IG9mIHRoZSBicm93c2VyLlxyXG4gICAgXHJcbiAgICBBbGxvd3MgdG8gZGVmaW5lIGdldHRlcnMgYW5kIHNldHRlcnMuXHJcbiAgICBcclxuICAgIEFkYXB0ZWQgY29kZSBmcm9tIHRoZSBvcmlnaW5hbCBjcmVhdGVkIGJ5IEplZmYgV2FsZGVuXHJcbiAgICBodHRwOi8vd2hlcmVzd2FsZGVuLmNvbS8yMDEwLzA0LzE2L21vcmUtc3BpZGVybW9ua2V5LWNoYW5nZXMtYW5jaWVudC1lc290ZXJpYy12ZXJ5LXJhcmVseS11c2VkLXN5bnRheC1mb3ItY3JlYXRpbmctZ2V0dGVycy1hbmQtc2V0dGVycy1pcy1iZWluZy1yZW1vdmVkL1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gYWNjZXNzb3JEZXNjcmlwdG9yKGZpZWxkLCBmdW4pXHJcbntcclxuICAgIHZhciBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfTtcclxuICAgIGRlc2NbZmllbGRdID0gZnVuO1xyXG4gICAgcmV0dXJuIGRlc2M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZUdldHRlcihvYmosIHByb3AsIGdldClcclxue1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgYWNjZXNzb3JEZXNjcmlwdG9yKFwiZ2V0XCIsIGdldCkpO1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXylcclxuICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lR2V0dGVyX18ocHJvcCwgZ2V0KTtcclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZ2V0dGVyc1wiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lU2V0dGVyKG9iaiwgcHJvcCwgc2V0KVxyXG57XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBhY2Nlc3NvckRlc2NyaXB0b3IoXCJzZXRcIiwgc2V0KSk7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKVxyXG4gICAgICAgIHJldHVybiBvYmouX19kZWZpbmVTZXR0ZXJfXyhwcm9wLCBzZXQpO1xyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcihcImJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBzZXR0ZXJzXCIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGRlZmluZUdldHRlcjogZGVmaW5lR2V0dGVyLFxyXG4gICAgZGVmaW5lU2V0dGVyOiBkZWZpbmVTZXR0ZXJcclxufTtcclxuIiwiLyoqXHJcbiAgICBSZW1vdmUgdGhlIGFjY2VudCBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzIGZyb20gYSB0ZXh0XHJcbiAgICByZXBsYWNpbmcgZWFjaCBjaGFyYWN0ZXIgZm9yIGl0cyBiYXNpYyBlcXVpdmFsZW50LlxyXG4gICAgVXNlZnVsIHRvIHBlcmZvcm1zIHB1bmN0dWF0aW9uLWluc2Vuc2l0aXZlIHRleHQgc2VhcmNocy5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBtYXAgPSB7J8OAJzonQScsJ8OBJzonQScsJ8OCJzonQScsJ8ODJzonQScsJ8OEJzonQScsJ8OFJzonQScsJ8OGJzonQUUnLCfDhyc6J0MnLCfDiCc6J0UnLCfDiSc6J0UnLCfDiic6J0UnLCfDiyc6J0UnLCfDjCc6J0knLCfDjSc6J0knLCfDjic6J0knLCfDjyc6J0knLCfDkCc6J0QnLCfDkSc6J04nLCfDkic6J08nLCfDkyc6J08nLCfDlCc6J08nLCfDlSc6J08nLCfDlic6J08nLCfDmCc6J08nLCfDmSc6J1UnLCfDmic6J1UnLCfDmyc6J1UnLCfDnCc6J1UnLCfDnSc6J1knLCfDnyc6J3MnLCfDoCc6J2EnLCfDoSc6J2EnLCfDoic6J2EnLCfDoyc6J2EnLCfDpCc6J2EnLCfDpSc6J2EnLCfDpic6J2FlJywnw6cnOidjJywnw6gnOidlJywnw6knOidlJywnw6onOidlJywnw6snOidlJywnw6wnOidpJywnw60nOidpJywnw64nOidpJywnw68nOidpJywnw7EnOiduJywnw7InOidvJywnw7MnOidvJywnw7QnOidvJywnw7UnOidvJywnw7YnOidvJywnw7gnOidvJywnw7knOid1Jywnw7onOid1Jywnw7snOid1Jywnw7wnOid1Jywnw70nOid5Jywnw78nOid5JywnxIAnOidBJywnxIEnOidhJywnxIInOidBJywnxIMnOidhJywnxIQnOidBJywnxIUnOidhJywnxIYnOidDJywnxIcnOidjJywnxIgnOidDJywnxIknOidjJywnxIonOidDJywnxIsnOidjJywnxIwnOidDJywnxI0nOidjJywnxI4nOidEJywnxI8nOidkJywnxJAnOidEJywnxJEnOidkJywnxJInOidFJywnxJMnOidlJywnxJQnOidFJywnxJUnOidlJywnxJYnOidFJywnxJcnOidlJywnxJgnOidFJywnxJknOidlJywnxJonOidFJywnxJsnOidlJywnxJwnOidHJywnxJ0nOidnJywnxJ4nOidHJywnxJ8nOidnJywnxKAnOidHJywnxKEnOidnJywnxKInOidHJywnxKMnOidnJywnxKQnOidIJywnxKUnOidoJywnxKYnOidIJywnxKcnOidoJywnxKgnOidJJywnxKknOidpJywnxKonOidJJywnxKsnOidpJywnxKwnOidJJywnxK0nOidpJywnxK4nOidJJywnxK8nOidpJywnxLAnOidJJywnxLEnOidpJywnxLInOidJSicsJ8SzJzonaWonLCfEtCc6J0onLCfEtSc6J2onLCfEtic6J0snLCfEtyc6J2snLCfEuSc6J0wnLCfEuic6J2wnLCfEuyc6J0wnLCfEvCc6J2wnLCfEvSc6J0wnLCfEvic6J2wnLCfEvyc6J0wnLCfFgCc6J2wnLCfFgSc6J0wnLCfFgic6J2wnLCfFgyc6J04nLCfFhCc6J24nLCfFhSc6J04nLCfFhic6J24nLCfFhyc6J04nLCfFiCc6J24nLCfFiSc6J24nLCfFjCc6J08nLCfFjSc6J28nLCfFjic6J08nLCfFjyc6J28nLCfFkCc6J08nLCfFkSc6J28nLCfFkic6J09FJywnxZMnOidvZScsJ8WUJzonUicsJ8WVJzoncicsJ8WWJzonUicsJ8WXJzoncicsJ8WYJzonUicsJ8WZJzoncicsJ8WaJzonUycsJ8WbJzoncycsJ8WcJzonUycsJ8WdJzoncycsJ8WeJzonUycsJ8WfJzoncycsJ8WgJzonUycsJ8WhJzoncycsJ8WiJzonVCcsJ8WjJzondCcsJ8WkJzonVCcsJ8WlJzondCcsJ8WmJzonVCcsJ8WnJzondCcsJ8WoJzonVScsJ8WpJzondScsJ8WqJzonVScsJ8WrJzondScsJ8WsJzonVScsJ8WtJzondScsJ8WuJzonVScsJ8WvJzondScsJ8WwJzonVScsJ8WxJzondScsJ8WyJzonVScsJ8WzJzondScsJ8W0JzonVycsJ8W1JzondycsJ8W2JzonWScsJ8W3JzoneScsJ8W4JzonWScsJ8W5JzonWicsJ8W6JzoneicsJ8W7JzonWicsJ8W8JzoneicsJ8W9JzonWicsJ8W+JzoneicsJ8W/JzoncycsJ8aSJzonZicsJ8agJzonTycsJ8ahJzonbycsJ8avJzonVScsJ8awJzondScsJ8eNJzonQScsJ8eOJzonYScsJ8ePJzonSScsJ8eQJzonaScsJ8eRJzonTycsJ8eSJzonbycsJ8eTJzonVScsJ8eUJzondScsJ8eVJzonVScsJ8eWJzondScsJ8eXJzonVScsJ8eYJzondScsJ8eZJzonVScsJ8eaJzondScsJ8ebJzonVScsJ8ecJzondScsJ8e6JzonQScsJ8e7JzonYScsJ8e8JzonQUUnLCfHvSc6J2FlJywnx74nOidPJywnx78nOidvJ307XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbW92ZUFjY2VudChzdHIpIHtcclxuXHJcbiAgICB2YXIgcmVzID0gJycsIGM7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjID0gc3RyLmNoYXJBdChpKTtcclxuICAgICAgICByZXMgKz0gbWFwW2NdIHx8IGM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG4iLCIvKipcclxuICAgIEl0IHNjcm9sbCBhbGwgbmVlZGVkIGVsZW1lbnRzIGluIHRoZSBwYWdlIHRvIG1ha2UgdGhlXHJcbiAgICB0YXJnZXQgZWxlbWVudCB0byBhcHBlYXIgaW4gdGhlIHNjcmVlbiwgaWYgcG9zc2libGUuXHJcbiAgICBcclxuICAgIEl0IHNjcm9sbHMgYWxsIHRoZSBlbGVtZW50IGFuY2VzdG9ycyAodGhhdCBtYXkgaGF2ZVxyXG4gICAgb3Igbm90IGEgc2Nyb2xsaW5nIGNvbnRleHQpLlxyXG4gICAgXHJcbiAgICBPbmx5IHZlcnRpY2FsbHkuXHJcbiAgICBUT0RPOiBtYWtlIGl0IGhvcml6b250YWwgdG9vLlxyXG4qKi9cclxuLy9nbG9iYWwgd2luZG93XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG4vLyBAcGFyYW0gZWw6RE9NRWxlbWVudHxqUXVlcnlcclxuLy8gQHBhcmFtIG9wdGlvbnM6T2JqZWN0IHtcclxuLy8gICAgICB0b3BPZmZzZXQ6aW50ICBPZmZzZXQgc2Nyb2xsIGZyb20gdGhlIHRvcFxyXG4vLyB9XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2Nyb2xsVG9FbGVtZW50KGVsLCBvcHRpb25zKSB7XHJcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjEwXHJcbiAgICB2YXIgcGFyZW50ID0gJChlbCkucGFyZW50KCk7XHJcblxyXG4gICAgdmFyIHRvcE9mZnNldCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50b3BPZmZzZXQgfHwgMDtcclxuICAgIHZhciBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uO1xyXG4gICAgXHJcbiAgICB2YXIgYXRSb290ID0gZmFsc2U7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIC8vIEdvIG91dCBvbiBkZXRhY2hlZCBlbGVtZW50czpcclxuICAgICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHJvb3QgZWxlbWVudCAoZW5kcyBsb29wIGFuZCBoYXMgZGlmZmVyZW50IHJ1bGVzIGZvciBzY3JvbGxpbmcpXHJcbiAgICAgICAgYXRSb290ID0gcGFyZW50LmdldCgwKSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IGlzIGNhbGN1bGF0ZWQgaW4gYSBkaWZmZXJlbnQgd2F5XHJcbiAgICAgICAgLy8gd2hlbiBhdCB0aGUgcm9vdCwgc28gdGFrZSBjYXJlIG9mIHRoYXRcclxuICAgICAgICB2YXIgcmVsYXRpdmVUb3AgPSBhdFJvb3QgPyBlbC5wb3NpdGlvbigpLnRvcCA6IGVsLm9mZnNldCgpLnRvcDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IGVsZW1lbnRUb3Agd2l0aCBvZmZzZXQgaXMgdXNlZCBhcyBpcyB3aGVuIGF0Um9vdFxyXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIG5leHQgc2Nyb2xsaW5nVG9wIGNhbGN1bGF0aW5nIG1ha2UgaXQgZmFpbFxyXG4gICAgICAgIHZhciBlbGVtZW50VG9wID0gcmVsYXRpdmVUb3AgLSB0b3BPZmZzZXQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbGluZ1RvcCA9IGVsZW1lbnRUb3AgKyBwYXJlbnQuc2Nyb2xsVG9wKCkgLSBwYXJlbnQub2Zmc2V0KCkudG9wO1xyXG5cclxuICAgICAgICBpZiAoYXRSb290KSB7XHJcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogc3BlY2lhbCBjYXNlLCBvbiB0aGUgcm9vdFxyXG4gICAgICAgICAgICAvLyB3ZSBjYW4ganVzdCB1c2Ugd2luZG93LnNjcm9sbCBvciBzY3JvbGxUb3AgZm9yIGFuaW1hdGlvblxyXG4gICAgICAgICAgICAvLyBCVVQgd2l0aCBhIGRpZmZlcmVudCBhbW91bnQsIHRoZSBlbGVtZW50VG9wXHJcbiAgICAgICAgICAgIGlmIChhbmltYXRpb24pXHJcbiAgICAgICAgICAgICAgICAkKCdodG1sLGJvZHknKS5zdG9wKCkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogZWxlbWVudFRvcCB9LCBhbmltYXRpb24pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIGVsZW1lbnRUb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbilcclxuICAgICAgICAgICAgICAgIHBhcmVudC5zdG9wKCkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsaW5nVG9wIH0sIGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHBhcmVudC5zY3JvbGxUb3Aoc2Nyb2xsaW5nVG9wKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKTtcclxuICAgIH0gd2hpbGUoIWF0Um9vdCk7XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgRG9tSXRlbXNNYW5hZ2VyIGNsYXNzLCB0aGF0IG1hbmFnZSBhIGNvbGxlY3Rpb24gXHJcbiAgICBvZiBIVE1ML0RPTSBpdGVtcyB1bmRlciBhIHJvb3QvY29udGFpbmVyLCB3aGVyZVxyXG4gICAgb25seSBvbmUgZWxlbWVudCBhdCB0aGUgdGltZSBpcyB2aXNpYmxlLCBwcm92aWRpbmdcclxuICAgIHRvb2xzIHRvIHVuaXF1ZXJseSBpZGVudGlmeSB0aGUgaXRlbXMsXHJcbiAgICB0byBjcmVhdGUgb3IgdXBkYXRlIG5ldyBpdGVtcyAodGhyb3VnaCAnaW5qZWN0JyksXHJcbiAgICBnZXQgdGhlIGN1cnJlbnQsIGZpbmQgYnkgdGhlIElEIGFuZCBtb3JlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxudmFyIGVzY2FwZVNlbGVjdG9yID0gcmVxdWlyZSgnLi4vZXNjYXBlU2VsZWN0b3InKTtcclxuXHJcbmZ1bmN0aW9uIERvbUl0ZW1zTWFuYWdlcihzZXR0aW5ncykge1xyXG5cclxuICAgIHRoaXMuaWRBdHRyaWJ1dGVOYW1lID0gc2V0dGluZ3MuaWRBdHRyaWJ1dGVOYW1lIHx8ICdpZCc7XHJcbiAgICB0aGlzLmFsbG93RHVwbGljYXRlcyA9ICEhc2V0dGluZ3MuYWxsb3dEdXBsaWNhdGVzIHx8IGZhbHNlO1xyXG4gICAgdGhpcy5yb290ID0gc2V0dGluZ3Mucm9vdCB8fCAnYm9keSc7XHJcbiAgICB0aGlzLiRyb290ID0gbnVsbDtcclxuICAgIC8vIERlZmluZSBpbiBtcyB0aGUgZGVsYXkgaW4gYSBzd2l0Y2ggb2YgaXRlbXMgKHByZXBhcmUgbmV4dCAtPmRlbGF5LT4gaGlkZSBjdXJyZW50LCBzaG93IG5leHQpXHJcbiAgICAvLyBOT1RFOiBhcyBvZiB0ZXN0aW5nIGluIGlPUyA4LjMgaVBhZDIgKHNsb3cpLCAxNDBtcyBlbmRlZCBiZWluZyBhIGdvb2QgZGVmYXVsdFxyXG4gICAgLy8gdG8gYXZvaWQgc29tZSBmbGlja2VyaW5nIGVmZmVjdHMsIGVub3VnaCB0byBsZXQgaW5pdGlhbGl6YXRpb24gbG9naWMgdG8gZmluaXNoIGJlZm9yZVxyXG4gICAgLy8gYmVpbmcgc2hvd2VkLCBhbGxvdyBzb21lIGNvbW1vbiBhc3luYyByZWRpcmVjdHMgd2hlbiBleGVjdXRpbmcgYW4gaXRlbSBsb2dpYyBidXRcclxuICAgIC8vIGVub3VnaCBxdWljayB0byBub3QgYmVpbmcgdmlzdWFsbHkgcGVyY2VpdmVkIHRoZSBkZWxheS5cclxuICAgIC8vIE5PVEU6IG9uIHRlc3RzIG9uIE5leHVzIDUgQW5kcm9pZCA1LjEgd2l0aCBDaHJvbWUgZW5naW5lLCA0MG1zIHdhcyBlbm91Z2h0IHRvIGhhdmUgYWxsIHRoZSBwcmV2aW91c1xyXG4gICAgLy8gYmVuZWZpdHMsIGJ1dCB3YXMgdG9vIHF1aWNrIGZvciBpT1MgKGV2ZW4gMTAwbXMgd2FzIHRvbyBxdWljayBmb3IgaU9TIDguMykuXHJcbiAgICB0aGlzLnN3aXRjaERlbGF5ID0gc2V0dGluZ3Muc3dpdGNoRGVsYXkgfHwgMTQwO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERvbUl0ZW1zTWFuYWdlcjtcclxuXHJcbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsSXRlbXMgPSBmdW5jdGlvbiBnZXRBbGxJdGVtcygpIHtcclxuICAgIHJldHVybiB0aGlzLiRyb290LmNoaWxkcmVuKCdbJyArIHRoaXMuaWRBdHRyaWJ1dGVOYW1lICsgJ10nKTtcclxufTtcclxuXHJcbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQoY29udGFpbmVyTmFtZSwgcm9vdCkge1xyXG4gICAgdmFyICRyb290ID0gJChyb290IHx8IHRoaXMuJHJvb3QpO1xyXG4gICAgcmV0dXJuICRyb290LmNoaWxkcmVuKCdbJyArIHRoaXMuaWRBdHRyaWJ1dGVOYW1lICsgJz1cIicgKyBlc2NhcGVTZWxlY3Rvcihjb250YWluZXJOYW1lKSArICdcIl0nKTtcclxufTtcclxuXHJcbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZlID0gZnVuY3Rpb24gZ2V0QWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJHJvb3QuY2hpbGRyZW4oJ1snICsgdGhpcy5pZEF0dHJpYnV0ZU5hbWUgKyAnXTp2aXNpYmxlJyk7XHJcbn07XHJcblxyXG4vKipcclxuICAgIEl0IGFkZHMgdGhlIGl0ZW0gaW4gdGhlIGh0bWwgcHJvdmlkZWQgKGNhbiBiZSBvbmx5IHRoZSBlbGVtZW50IG9yIFxyXG4gICAgY29udGFpbmVkIGluIGFub3RoZXIgb3IgYSBmdWxsIGh0bWwgcGFnZSkuXHJcbiAgICBSZXBsYWNlcyBhbnkgZXhpc3RhbnQgaWYgZHVwbGljYXRlcyBhcmUgbm90IGFsbG93ZWQuXHJcbioqL1xyXG5Eb21JdGVtc01hbmFnZXIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdChuYW1lLCBodG1sKSB7XHJcblxyXG4gICAgLy8gRmlsdGVyaW5nIGlucHV0IGh0bWwgKGNhbiBiZSBwYXJ0aWFsIG9yIGZ1bGwgcGFnZXMpXHJcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjg0ODc5OFxyXG4gICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXltcXHNcXFNdKjxib2R5Lio/Pnw8XFwvYm9keT5bXFxzXFxTXSokL2csICcnKTtcclxuXHJcbiAgICAvLyBDcmVhdGluZyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBodG1sXHJcbiAgICAvLyAoY2FuIGJlIHByb3ZpZGVkIHRoZSBpbm5lckh0bWwgb3Igb3V0ZXJIdG1sLCBkb2Vzbid0IG1hdHRlcnMgd2l0aCBuZXh0IGFwcHJvYWNoKVxyXG4gICAgdmFyICRodG1sID0gJCgnPGRpdi8+JywgeyBodG1sOiBodG1sIH0pLFxyXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIHRoZSBjb250YWluZXIgZWxlbWVudCAod2hlbiB0aGUgb3V0ZXJIdG1sIGlzIHByb3ZpZGVkKVxyXG4gICAgICAgICRjID0gdGhpcy5maW5kKG5hbWUsICRodG1sKTtcclxuXHJcbiAgICBpZiAoJGMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgLy8gSXRzIGlubmVySHRtbCwgc28gdGhlIHdyYXBwZXIgYmVjb21lcyB0aGUgY29udGFpbmVyIGl0c2VsZlxyXG4gICAgICAgICRjID0gJGh0bWwuYXR0cih0aGlzLmlkQXR0cmlidXRlTmFtZSwgbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmFsbG93RHVwbGljYXRlcykge1xyXG4gICAgICAgIC8vIE5vIG1vcmUgdGhhbiBvbmUgY29udGFpbmVyIGluc3RhbmNlIGNhbiBleGlzdHMgYXQgdGhlIHNhbWUgdGltZVxyXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGFueSBleGlzdGVudCBvbmUgYW5kIGl0cyByZXBsYWNlZCB3aXRoIHRoZSBuZXdcclxuICAgICAgICB2YXIgJHByZXYgPSB0aGlzLmZpbmQobmFtZSk7XHJcbiAgICAgICAgaWYgKCRwcmV2Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgJHByZXYucmVwbGFjZVdpdGgoJGMpO1xyXG4gICAgICAgICAgICAkYyA9ICRwcmV2O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdG8gdGhlIGRvY3VtZW50XHJcbiAgICAvLyAob24gdGhlIGNhc2Ugb2YgZHVwbGljYXRlZCBmb3VuZCwgdGhpcyB3aWxsIGRvIG5vdGhpbmcsIG5vIHdvcnJ5KVxyXG4gICAgJGMuYXBwZW5kVG8odGhpcy4kcm9vdCk7XHJcbn07XHJcblxyXG4vKiogXHJcbiAgICBUaGUgc3dpdGNoIG1ldGhvZCByZWNlaXZlIHRoZSBpdGVtcyB0byBpbnRlcmNoYW5nZSBhcyBhY3RpdmUgb3IgY3VycmVudCxcclxuICAgIHRoZSAnZnJvbScgYW5kICd0bycsIGFuZCB0aGUgc2hlbGwgaW5zdGFuY2UgdGhhdCBNVVNUIGJlIHVzZWRcclxuICAgIHRvIG5vdGlmeSBlYWNoIGV2ZW50IHRoYXQgaW52b2x2ZXMgdGhlIGl0ZW06XHJcbiAgICB3aWxsQ2xvc2UsIHdpbGxPcGVuLCByZWFkeSwgb3BlbmVkLCBjbG9zZWQuXHJcbiAgICBJdCByZWNlaXZlcyBhcyBsYXRlc3QgcGFyYW1ldGVyIHRoZSAnbm90aWZpY2F0aW9uJyBvYmplY3QgdGhhdCBtdXN0IGJlXHJcbiAgICBwYXNzZWQgd2l0aCB0aGUgZXZlbnQgc28gaGFuZGxlcnMgaGFzIGNvbnRleHQgc3RhdGUgaW5mb3JtYXRpb24uXHJcbiAgICBcclxuICAgIEl0J3MgZGVzaWduZWQgdG8gYmUgYWJsZSB0byBtYW5hZ2UgdHJhbnNpdGlvbnMsIGJ1dCB0aGlzIGRlZmF1bHRcclxuICAgIGltcGxlbWVudGF0aW9uIGlzIGFzIHNpbXBsZSBhcyAnc2hvdyB0aGUgbmV3IGFuZCBoaWRlIHRoZSBvbGQnLlxyXG4qKi9cclxuRG9tSXRlbXNNYW5hZ2VyLnByb3RvdHlwZS5zd2l0Y2ggPSBmdW5jdGlvbiBzd2l0Y2hBY3RpdmVJdGVtKCRmcm9tLCAkdG8sIHNoZWxsLCBzdGF0ZSkge1xyXG5cclxuICAgIHZhciB0b05hbWUgPSBzdGF0ZS5yb3V0ZS5uYW1lO1xyXG4gICAgLy9jb25zb2xlLmxvZygnc3dpdGNoIHRvJywgdG9OYW1lKTtcclxuICAgIFxyXG4gICAgdGhpcy5kaXNhYmxlQWNjZXNzKCk7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGhpZGVpdCgpIHtcclxuICAgICAgICB2YXIgZnJvbUlzSGlkZGVuID0gJGZyb20uaXMoJ1toaWRkZW5dJyk7XHJcbiAgICAgICAgaWYgKCRmcm9tLmxlbmd0aCA+IDAgJiYgIWZyb21Jc0hpZGRlbikge1xyXG4gICAgICAgICAgICBzaGVsbC5lbWl0KHNoZWxsLmV2ZW50cy53aWxsQ2xvc2UsICRmcm9tLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIERvICd1bmZvY3VzJyBvbiB0aGUgaGlkZGVuIGVsZW1lbnQgYWZ0ZXIgbm90aWZ5ICd3aWxsQ2xvc2UnXHJcbiAgICAgICAgICAgIC8vIGZvciBiZXR0ZXIgVVg6IGhpZGRlbiBlbGVtZW50cyBhcmUgbm90IHJlYWNoYWJsZSBhbmQgaGFzIGdvb2RcclxuICAgICAgICAgICAgLy8gc2lkZSBlZmZlY3RzIGxpa2UgaGlkZGluZyB0aGUgb24tc2NyZWVuIGtleWJvYXJkIGlmIGFuIGlucHV0IHdhc1xyXG4gICAgICAgICAgICAvLyBmb2N1c2VkXHJcbiAgICAgICAgICAgICRmcm9tLmZpbmQoJzpmb2N1cycpLmJsdXIoKTtcclxuICAgICAgICAgICAgLy8gaGlkZSBhbmQgbm90aWZ5IGl0IGVuZGVkXHJcbiAgICAgICAgICAgICRmcm9tXHJcbiAgICAgICAgICAgIC5hdHRyKCdoaWRkZW4nLCAnaGlkZGVuJylcclxuICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXIgdGhhdCBkb24ndCBzdXBwb3J0IGF0dHJcclxuICAgICAgICAgICAgLmNzcygnZGlzcGxheScsICdub25lJylcclxuICAgICAgICAgICAgLy8gUmVzZXQgei1pbmRleCB0byBhdm9pZCBvdmVybGFwcGluZyBlZmZlY3RcclxuICAgICAgICAgICAgLmNzcygnei1pbmRleCcsICcnKTtcclxuXHJcbiAgICAgICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLmNsb3NlZCwgJGZyb20sIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgdW5mb2N1cyB0byBhdm9pZCBrZXlib2FyZCBwcm9ibGVtc1xyXG4gICAgICAgICAgICAkZnJvbS5maW5kKCc6Zm9jdXMnKS5ibHVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0b0lzSGlkZGVuID0gJHRvLmlzKCdbaGlkZGVuXScpOyAvLyAhJHRvLmlzKCc6dmlzaWJsZScpXHJcblxyXG4gICAgaWYgKHRvSXNIaWRkZW4pIHtcclxuICAgICAgICBzaGVsbC5lbWl0KHNoZWxsLmV2ZW50cy53aWxsT3BlbiwgJHRvLCBzdGF0ZSk7XHJcbiAgICAgICAgLy8gUHV0IG91dHNpZGUgc2NyZWVuXHJcbiAgICAgICAgLyogRE9ORSBBTFJFQURZIGluIHRoZSBDU1MgY2xhc3MgYXNzaWduZWQgdG8gaXRlbXNcclxuICAgICAgICAkdG8uY3NzKHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgIHpJbmRleDogLTEsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICByaWdodDogMFxyXG4gICAgICAgIH0pOyovXHJcbiAgICAgICAgJHRvLmNzcygnekluZGV4JywgLTEpO1xyXG5cclxuICAgICAgICAvLyBTaG93IGl0OlxyXG4gICAgICAgICR0b1xyXG4gICAgICAgIC5yZW1vdmVBdHRyKCdoaWRkZW4nKVxyXG4gICAgICAgIC8vIEZvciBicm93c2VyIHRoYXQgZG9uJ3Qgc3VwcG9ydCBhdHRyXHJcbiAgICAgICAgLmNzcygnZGlzcGxheScsICdibG9jaycpO1xyXG5cclxuICAgICAgICAvLyBJdHMgZW5vdWdoIHZpc2libGUgYW5kIGluIERPTSB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHRhc2tzXHJcbiAgICAgICAgLy8gdGhhdCBtYXkgaW52b2x2ZSBsYXlvdXQgaW5mb3JtYXRpb25cclxuICAgICAgICBzaGVsbC5lbWl0KHNoZWxsLmV2ZW50cy5pdGVtUmVhZHksICR0bywgc3RhdGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1NXSVRDSCByZWFkeSBkb25lLCB3YWl0JywgdG9OYW1lKTtcclxuXHJcbiAgICAgICAgLy8gRmluaXNoIGluIGEgc21hbGwgZGVsYXksIGVub3VnaCB0byBhbGxvdyBzb21lIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgLy8gc2V0LXVwIHRoYXQgdGFrZSBzb21lIHRpbWUgdG8gZmluaXNoIGF2b2lkaW5nIGZsaWNrZXJpbmcgZWZmZWN0c1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NXSVRDSCBlbnRlcmluZyBoaWRlLXNob3cgZm9yJywgdG9OYW1lLCBzaGVsbC5jdXJyZW50Um91dGUubmFtZSk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VuZGluZyBzd2l0Y2ggdG8nLCB0b05hbWUsICdhbmQgY3VycmVudCBpcycsIHNoZWxsLmN1cnJlbnRSb3V0ZS5uYW1lKTtcclxuICAgICAgICAgICAgLy8gUmFjZSBjb25kaXRpb24sIHJlZGlyZWN0aW9uIGluIHRoZSBtaWRkbGUsIGFib3J0OlxyXG4gICAgICAgICAgICBpZiAodG9OYW1lICE9PSBzaGVsbC5jdXJyZW50Um91dGUubmFtZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIGZyb21cclxuICAgICAgICAgICAgaGlkZWl0KCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBFbmRzIG9wZW5pbmcsIHJlc2V0IHRyYW5zaXRpb25hbCBzdHlsZXNcclxuICAgICAgICAgICAgLyogU0VUVVAgSVMgQUxSRUFEWSBDT1JSRUNUIGluIHRoZSBDU1MgY2xhc3MgYXNzaWduZWQgdG8gaXRlbXNcclxuICAgICAgICAgICAgJHRvLmNzcyh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJycsXHJcbiAgICAgICAgICAgICAgICB0b3A6ICcnLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnJyxcclxuICAgICAgICAgICAgICAgIGxlZnQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiAyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAkdG8uY3NzKCd6SW5kZXgnLCAyKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQWNjZXNzKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdTV0lUQ0ggZW5kZWQgZm9yJywgdG9OYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gaXRzIGNvbXBsZXRlbHkgb3BlbmVkXHJcbiAgICAgICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLm9wZW5lZCwgJHRvLCBzdGF0ZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLnN3aXRjaERlbGF5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZW5kaW5nIHN3aXRjaCB0bycsIHRvTmFtZSwgJ2FuZCBjdXJyZW50IGlzJywgc2hlbGwuY3VycmVudFJvdXRlLm5hbWUsICdJTlNUQU5UICh0byB3YXMgdmlzaWJsZSknKTtcclxuICAgICAgICAvLyBSYWNlIGNvbmRpdGlvbiwgcmVkaXJlY3Rpb24gaW4gdGhlIG1pZGRsZSwgYWJvcnQ6XHJcbiAgICAgICAgaWYgKHRvTmFtZSAhPT0gc2hlbGwuY3VycmVudFJvdXRlLm5hbWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJdHMgcmVhZHk7IG1heWJlIGl0IHdhcyBidXQgc3ViLWxvY2F0aW9uXHJcbiAgICAgICAgLy8gb3Igc3RhdGUgY2hhbmdlIG5lZWQgdG8gYmUgY29tbXVuaWNhdGVkXHJcbiAgICAgICAgc2hlbGwuZW1pdChzaGVsbC5ldmVudHMuaXRlbVJlYWR5LCAkdG8sIHN0YXRlKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmVuYWJsZUFjY2VzcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGhpZGVpdCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAgICBJbml0aWFsaXplcyB0aGUgbGlzdCBvZiBpdGVtcy4gTm8gbW9yZSB0aGFuIG9uZVxyXG4gICAgbXVzdCBiZSBvcGVuZWQvdmlzaWJsZSBhdCB0aGUgc2FtZSB0aW1lLCBzbyBhdCB0aGUgXHJcbiAgICBpbml0IGFsbCB0aGUgZWxlbWVudHMgYXJlIGNsb3NlZCB3YWl0aW5nIHRvIHNldFxyXG4gICAgb25lIGFzIHRoZSBhY3RpdmUgb3IgdGhlIGN1cnJlbnQgb25lLlxyXG4gICAgXHJcbiAgICBFeGVjdXRlIGFmdGVyIERPTSByZWFkeS5cclxuKiovXHJcbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICAvLyBPbiByZWFkeSwgZ2V0IHRoZSByb290IGVsZW1lbnQ6XHJcbiAgICB0aGlzLiRyb290ID0gJCh0aGlzLnJvb3QgfHwgJ2JvZHknKTtcclxuXHJcbiAgICB0aGlzLmdldEFsbEl0ZW1zKClcclxuICAgIC5hdHRyKCdoaWRkZW4nLCAnaGlkZGVuJylcclxuICAgIC8vIEZvciBicm93c2VyIHRoYXQgZG9uJ3Qgc3VwcG9ydCBhdHRyXHJcbiAgICAuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgIFxyXG4gICAgLy8gQSBsYXllciB0byB2aXN1YWxseSBoaWRlIGFuIG9wZW5pbmcgaXRlbSB3aGlsZSBub3QgY29tcGxldGVkIG9wZW5lZFxyXG4gICAgJCgnPGRpdiBjbGFzcz1cIml0ZW1zLWJhY2tzdGFnZVwiLz4nKS5jc3Moe1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHRoaXMuJHJvb3QuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJykgfHwgJ3doaXRlJyxcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgekluZGV4OiAwXHJcbiAgICB9KS5hcHBlbmRUbyh0aGlzLiRyb290KTtcclxuICAgIFxyXG4gICAgLy8gQSBsYXllciB0byBkaXNhYmxlIGFjY2VzcyB0byBhbiBpdGVtIChkaXNhYmxpbmcgZXZlbnRzKVxyXG4gICAgLy8gTk9URTogVHJpZWQgQ1NTIHBvaW50ZXItZXZlbnRzOm5vbmUgaGFzIHNvbWUgc3RyYW5nZSBzaWRlLWVmZmVjdHM6IGF1dG8gc2Nyb2xsLXVwLlxyXG4gICAgLy8gVE9ETzogQWZ0ZXIgc29tZSB0ZXN0aW5nIHdpdGggdGhpcywgc2Nyb2xsLXVwIGhhcHBlbnMgYWdhaW4gd2l0aCB0aGlzICg/PylcclxuICAgIHZhciAkZGlzYWJsZUxheWVyID0gJCgnPGRpdiBjbGFzcz1cIml0ZW1zLWRpc2FibGUtbGF5ZXJcIi8+JykuY3NzKHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiAnV2hpdGUnLFxyXG4gICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHpJbmRleDogLTFcclxuICAgIH0pLmFwcGVuZFRvKHRoaXMuJHJvb3QpO1xyXG4gICAgdGhpcy5kaXNhYmxlQWNjZXNzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJGRpc2FibGVMYXllci5jc3MoJ3pJbmRleCcsIDkwOTAwKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmVuYWJsZUFjY2VzcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRkaXNhYmxlTGF5ZXIuY3NzKCd6SW5kZXgnLCAtMik7XHJcbiAgICB9O1xyXG59O1xyXG4iLCIvKipcclxuICAgIEphdmFzY3JpdHAgU2hlbGwgZm9yIFNQQXMuXHJcbioqL1xyXG4vKmdsb2JhbCB3aW5kb3csIGRvY3VtZW50ICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKiBESSBlbnRyeSBwb2ludHMgZm9yIGRlZmF1bHQgYnVpbGRzLiBNb3N0IGRlcGVuZGVuY2llcyBjYW4gYmVcclxuICAgIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3Igc2V0dGluZ3MgZm9yIHBlci1pbnN0YW5jZSBzZXR1cC5cclxuKiovXHJcbnZhciBkZXBzID0gcmVxdWlyZSgnLi9kZXBlbmRlbmNpZXMnKTtcclxuXHJcbi8qKiBDb25zdHJ1Y3RvciAqKi9cclxuXHJcbmZ1bmN0aW9uIFNoZWxsKHNldHRpbmdzKSB7XHJcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjE0XHJcbiAgICBcclxuICAgIGRlcHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy4kID0gc2V0dGluZ3MuanF1ZXJ5IHx8IGRlcHMuanF1ZXJ5O1xyXG4gICAgdGhpcy4kcm9vdCA9IHRoaXMuJChzZXR0aW5ncy5yb290KTtcclxuICAgIHRoaXMuYmFzZVVybCA9IHNldHRpbmdzLmJhc2VVcmwgfHwgJyc7XHJcbiAgICAvLyBXaXRoIGZvcmNlSGFzaGJhbmc9dHJ1ZTpcclxuICAgIC8vIC0gZnJhZ21lbnRzIFVSTHMgY2Fubm90IGJlIHVzZWQgdG8gc2Nyb2xsIHRvIGFuIGVsZW1lbnQgKGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciksXHJcbiAgICAvLyAgIHRoZXkgYXJlIGRlZmF1bHRQcmV2ZW50ZWQgdG8gYXZvaWQgY29uZnVzZSB0aGUgcm91dGluZyBtZWNoYW5pc20gYW5kIGN1cnJlbnQgVVJMLlxyXG4gICAgLy8gLSBwcmVzc2VkIGxpbmtzIHRvIGZyYWdtZW50cyBVUkxzIGFyZSBub3Qgcm91dGVkLCB0aGV5IGFyZSBza2lwcGVkIHNpbGVudGx5XHJcbiAgICAvLyAgIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIGEgaGFzaGJhbmcgKCMhKS4gVGhpcyB3YXksIHNwZWNpYWwgbGlua3NcclxuICAgIC8vICAgdGhhdCBwZXJmb3JtbiBqcyBhY3Rpb25zIGRvZXNuJ3QgY29uZmxpdHMuXHJcbiAgICAvLyAtIGFsbCBVUkxzIHJvdXRlZCB0aHJvdWdoIHRoZSBzaGVsbCBpbmNsdWRlcyBhIGhhc2hiYW5nICgjISksIHRoZSBzaGVsbCBlbnN1cmVzXHJcbiAgICAvLyAgIHRoYXQgaGFwcGVucyBieSBhcHBlbmRpbmcgdGhlIGhhc2hiYW5nIHRvIGFueSBVUkwgcGFzc2VkIGluIChleGNlcHQgdGhlIHN0YW5kYXJkIGhhc2hcclxuICAgIC8vICAgdGhhdCBhcmUgc2tpcHQpLlxyXG4gICAgdGhpcy5mb3JjZUhhc2hiYW5nID0gc2V0dGluZ3MuZm9yY2VIYXNoYmFuZyB8fCBmYWxzZTtcclxuICAgIHRoaXMubGlua0V2ZW50ID0gc2V0dGluZ3MubGlua0V2ZW50IHx8ICdjbGljayc7XHJcbiAgICB0aGlzLnBhcnNlVXJsID0gKHNldHRpbmdzLnBhcnNlVXJsIHx8IGRlcHMucGFyc2VVcmwpLmJpbmQodGhpcywgdGhpcy5iYXNlVXJsKTtcclxuICAgIHRoaXMuYWJzb2x1dGl6ZVVybCA9IChzZXR0aW5ncy5hYnNvbHV0aXplVXJsIHx8IGRlcHMuYWJzb2x1dGl6ZVVybCkuYmluZCh0aGlzLCB0aGlzLmJhc2VVcmwpO1xyXG5cclxuICAgIHRoaXMuaGlzdG9yeSA9IHNldHRpbmdzLmhpc3RvcnkgfHwgd2luZG93Lmhpc3Rvcnk7XHJcblxyXG4gICAgdGhpcy5pbmRleE5hbWUgPSBzZXR0aW5ncy5pbmRleE5hbWUgfHwgJ2luZGV4JztcclxuICAgIFxyXG4gICAgdGhpcy5pdGVtcyA9IHNldHRpbmdzLmRvbUl0ZW1zTWFuYWdlcjtcclxuXHJcbiAgICAvLyBsb2FkZXIgY2FuIGJlIGRpc2FibGVkIHBhc3NpbmcgJ251bGwnLCBzbyB3ZSBtdXN0XHJcbiAgICAvLyBlbnN1cmUgdG8gbm90IHVzZSB0aGUgZGVmYXVsdCBvbiB0aGF0IGNhc2VzOlxyXG4gICAgdGhpcy5sb2FkZXIgPSB0eXBlb2Yoc2V0dGluZ3MubG9hZGVyKSA9PT0gJ3VuZGVmaW5lZCcgPyBkZXBzLmxvYWRlciA6IHNldHRpbmdzLmxvYWRlcjtcclxuICAgIC8vIGxvYWRlciBzZXR1cFxyXG4gICAgaWYgKHRoaXMubG9hZGVyKVxyXG4gICAgICAgIHRoaXMubG9hZGVyLmJhc2VVcmwgPSB0aGlzLmJhc2VVcmw7XHJcblxyXG4gICAgLy8gRGVmaW5pdGlvbiBvZiBldmVudHMgdGhhdCB0aGlzIG9iamVjdCBjYW4gdHJpZ2dlcixcclxuICAgIC8vIGl0cyB2YWx1ZSBjYW4gYmUgY3VzdG9taXplZCBidXQgYW55IGxpc3RlbmVyIG5lZWRzXHJcbiAgICAvLyB0byBrZWVwIHVwZGF0ZWQgdG8gdGhlIGNvcnJlY3QgZXZlbnQgc3RyaW5nLW5hbWUgdXNlZC5cclxuICAgIC8vIFRoZSBpdGVtcyBtYW5pcHVsYXRpb24gZXZlbnRzIE1VU1QgYmUgdHJpZ2dlcmVkXHJcbiAgICAvLyBieSB0aGUgJ2l0ZW1zLnN3aXRjaCcgZnVuY3Rpb25cclxuICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICAgIHdpbGxPcGVuOiAnc2hlbGwtd2lsbC1vcGVuJyxcclxuICAgICAgICB3aWxsQ2xvc2U6ICdzaGVsbC13aWxsLWNsb3NlJyxcclxuICAgICAgICBpdGVtUmVhZHk6ICdzaGVsbC1pdGVtLXJlYWR5JyxcclxuICAgICAgICBjbG9zZWQ6ICdzaGVsbC1jbG9zZWQnLFxyXG4gICAgICAgIG9wZW5lZDogJ3NoZWxsLW9wZW5lZCdcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICAgIEEgZnVuY3Rpb24gdG8gZGVjaWRlIGlmIHRoZVxyXG4gICAgICAgIGFjY2VzcyBpcyBhbGxvd2VkIChyZXR1cm5zICdudWxsJylcclxuICAgICAgICBvciBub3QgKHJldHVybiBhIHN0YXRlIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uXHJcbiAgICAgICAgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgJ25vbkFjY2Vzc05hbWUnIGl0ZW07XHJcbiAgICAgICAgdGhlICdyb3V0ZScgcHJvcGVydHkgb24gdGhlIHN0YXRlIGlzIGF1dG9tYXRpY2FsbHkgZmlsbGVkKS5cclxuICAgICAgICBcclxuICAgICAgICBUaGUgZGVmYXVsdCBidWl0LWluIGp1c3QgYWxsb3cgZXZlcnl0aGluZyBcclxuICAgICAgICBieSBqdXN0IHJldHVybmluZyAnbnVsbCcgYWxsIHRoZSB0aW1lLlxyXG4gICAgICAgIFxyXG4gICAgICAgIEl0IHJlY2VpdmVzIGFzIHBhcmFtZXRlciB0aGUgc3RhdGUgb2JqZWN0LFxyXG4gICAgICAgIHRoYXQgYWxtb3N0IGNvbnRhaW5zIHRoZSAncm91dGUnIHByb3BlcnR5IHdpdGhcclxuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgVVJMLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLmFjY2Vzc0NvbnRyb2wgPSBzZXR0aW5ncy5hY2Nlc3NDb250cm9sIHx8IGRlcHMuYWNjZXNzQ29udHJvbDtcclxuICAgIC8vIFdoYXQgaXRlbSBsb2FkIG9uIG5vbiBhY2Nlc3NcclxuICAgIHRoaXMubm9uQWNjZXNzTmFtZSA9IHNldHRpbmdzLm5vbkFjY2Vzc05hbWUgfHwgJ2luZGV4JztcclxuICAgIFxyXG4gICAgLy8gQWNjZXNzIHRvIHRoZSBjdXJyZW50IHJvdXRlXHJcbiAgICB0aGlzLmN1cnJlbnRSb3V0ZSA9IG51bGw7XHJcbiAgICAvLyBBY2Nlc3MgdG8gcmVmZXJyZXIvcHJldmlvdXMgcm91dGVcclxuICAgIHRoaXMucmVmZXJyZXJSb3V0ZSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIFNoZWxsIGluaGVyaXRzIGZyb20gRXZlbnRFbWl0dGVyXHJcblNoZWxsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZGVwcy5FdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XHJcbiAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICAgIHZhbHVlOiBTaGVsbCxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoZWxsO1xyXG5cclxuXHJcbi8qKiBBUEkgZGVmaW5pdGlvbiAqKi9cclxuXHJcblNoZWxsLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvKHVybCwgc3RhdGUpIHtcclxuXHJcbiAgICBpZiAodGhpcy5mb3JjZUhhc2hiYW5nKSB7XHJcbiAgICAgICAgaWYgKCEvXiMhLy50ZXN0KHVybCkpIHtcclxuICAgICAgICAgICAgdXJsID0gJyMhJyArIHVybDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB1cmwgPSB0aGlzLmFic29sdXRpemVVcmwodXJsKTtcclxuICAgIH1cclxuICAgIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHVuZGVmaW5lZCwgdXJsKTtcclxuICAgIC8vIHB1c2hTdGF0ZSBkbyBOT1QgdHJpZ2dlciB0aGUgcG9wc3RhdGUgZXZlbnQsIHNvXHJcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHN0YXRlKTtcclxufTtcclxuXHJcblNoZWxsLnByb3RvdHlwZS5nb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soc3RhdGUsIHN0ZXBzKSB7XHJcbiAgICBzdGVwcyA9IDAgLSAoc3RlcHMgfHwgMSk7XHJcbiAgICAvLyBJZiB0aGVyZSBpcyBub3RoaW5nIHRvIGdvLWJhY2sgb3Igbm90IGVub3VnaHRcclxuICAgIC8vICdiYWNrJyBzdGVwcywgZ28gdG8gdGhlIGluZGV4XHJcbiAgICBpZiAoc3RlcHMgPCAwICYmIE1hdGguYWJzKHN0ZXBzKSA+PSB0aGlzLmhpc3RvcnkubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5nbyh0aGlzLmluZGV4TmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBPbiByZXBsYWNlLCB0aGUgcGFzc2VkIHN0YXRlIGlzIG1lcmdlZCB3aXRoXHJcbiAgICAgICAgLy8gdGhlIG9uZSB0aGF0IGNvbWVzIGZyb20gdGhlIHNhdmVkIGhpc3RvcnlcclxuICAgICAgICAvLyBlbnRyeSAoaXQgJ3BvcHMnIHdoZW4gZG9pbmcgdGhlIGhpc3RvcnkuZ28oKSlcclxuICAgICAgICB0aGlzLl9wZW5kaW5nU3RhdGVVcGRhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLmhpc3RvcnkuZ28oc3RlcHMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAgICBQcm9jZXNzIHRoZSBnaXZlbiBzdGF0ZSBpbiBvcmRlciB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgIGJhc2VkIG9uIHRoYXQgb3IgdGhlIHNhdmVkIGluIGhpc3RvcnksIG1lcmdlIGl0IHdpdGhcclxuICAgIGFueSB1cGRhdGVkIHN0YXRlIHBlbmRpbmcgYW5kIGFkZHMgdGhlIHJvdXRlIGluZm9ybWF0aW9uLFxyXG4gICAgcmV0dXJuaW5nIGFuIHN0YXRlIG9iamVjdCBzdWl0YWJsZSB0byB1c2UuXHJcbioqL1xyXG5TaGVsbC5wcm90b3R5cGUuZ2V0VXBkYXRlZFN0YXRlID0gZnVuY3Rpb24gZ2V0VXBkYXRlZFN0YXRlKHN0YXRlKSB7XHJcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXHJcbiAgICBcclxuICAgIC8vIEZvciBjdXJyZW50IHVzZXMsIGFueSBwZW5kaW5nU3RhdGVVcGRhdGUgaXMgdXNlZCBhc1xyXG4gICAgLy8gdGhlIHN0YXRlLCByYXRoZXIgdGhhbiB0aGUgcHJvdmlkZWQgb25lXHJcbiAgICBzdGF0ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVVwZGF0ZSB8fCBzdGF0ZSB8fCB0aGlzLmhpc3Rvcnkuc3RhdGUgfHwge307XHJcbiAgICBcclxuICAgIC8vIFRPRE86IG1vcmUgYWR2YW5jZWQgdXNlcyBtdXN0IGJlIHRvIHVzZSB0aGUgJ3N0YXRlJyB0b1xyXG4gICAgLy8gcmVjb3ZlciB0aGUgVUkgc3RhdGUsIHdpdGggYW55IG1lc3NhZ2UgZnJvbSBvdGhlciBVSVxyXG4gICAgLy8gcGFzc2luZyBpbiBhIHdheSB0aGF0IGFsbG93IHVwZGF0ZSB0aGUgc3RhdGUsIG5vdFxyXG4gICAgLy8gcmVwbGFjZSBpdCAoZnJvbSBwZW5kaW5nU3RhdGVVcGRhdGUpLlxyXG4gICAgLypcclxuICAgIC8vIFN0YXRlIG9yIGRlZmF1bHQgc3RhdGVcclxuICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xyXG4gICAgLy8gbWVyZ2UgcGVuZGluZyB1cGRhdGVkIHN0YXRlXHJcbiAgICB0aGlzLiQuZXh0ZW5kKHN0YXRlLCB0aGlzLl9wZW5kaW5nU3RhdGVVcGRhdGUpO1xyXG4gICAgLy8gZGlzY2FyZCB0aGUgdXBkYXRlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlVXBkYXRlID0gbnVsbDtcclxuICAgIFxyXG4gICAgLy8gRG9lc24ndCBtYXR0ZXJzIGlmIHN0YXRlIGluY2x1ZGVzIGFscmVhZHkgXHJcbiAgICAvLyAncm91dGUnIGluZm9ybWF0aW9uLCBuZWVkIHRvIGJlIG92ZXJ3cml0dGVuXHJcbiAgICAvLyB0byBtYXRjaCB0aGUgY3VycmVudCBvbmUuXHJcbiAgICAvLyBOT1RFOiBwcmV2aW91c2x5LCBhIGNoZWNrIHByZXZlbnRlZCB0aGlzIGlmXHJcbiAgICAvLyByb3V0ZSBwcm9wZXJ0eSBleGlzdHMsIGNyZWF0aW5nIGluZmluaXRlIGxvb3BzXHJcbiAgICAvLyBvbiByZWRpcmVjdGlvbnMgZnJvbSBhY3Rpdml0eS5zaG93IHNpbmNlICdyb3V0ZScgZG9lc24ndFxyXG4gICAgLy8gbWF0Y2ggdGhlIG5ldyBkZXNpcmVkIGxvY2F0aW9uXHJcbiAgICBcclxuICAgIC8vIERldGVjdCBpZiBpcyBhIGhhc2hiYW5nIFVSTCBvciBhbiBzdGFuZGFyZCBvbmUuXHJcbiAgICAvLyBFeGNlcHQgaWYgdGhlIGFwcCBpcyBmb3JjZWQgdG8gdXNlIGhhc2hiYW5nLlxyXG4gICAgdmFyIGlzSGFzaEJhbmcgPSAvIyEvLnRlc3QobG9jYXRpb24uaHJlZikgfHwgdGhpcy5mb3JjZUhhc2hiYW5nO1xyXG4gICAgXHJcbiAgICB2YXIgbGluayA9IChcclxuICAgICAgICBpc0hhc2hCYW5nID9cclxuICAgICAgICBsb2NhdGlvbi5oYXNoIDpcclxuICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxyXG4gICAgKSArIChsb2NhdGlvbi5zZWFyY2ggfHwgJycpO1xyXG4gICAgXHJcbiAgICAvLyBTZXQgdGhlIHJvdXRlXHJcbiAgICBzdGF0ZS5yb3V0ZSA9IHRoaXMucGFyc2VVcmwobGluayk7XHJcbiAgICBcclxuICAgIHJldHVybiBzdGF0ZTtcclxufTtcclxuXHJcblNoZWxsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xyXG4gICAgXHJcbiAgICBzdGF0ZSA9IHRoaXMuZ2V0VXBkYXRlZFN0YXRlKHN0YXRlKTtcclxuXHJcbiAgICAvLyBVc2UgdGhlIGluZGV4IG9uIHJvb3QgY2FsbHNcclxuICAgIGlmIChzdGF0ZS5yb3V0ZS5yb290ID09PSB0cnVlKSB7XHJcbiAgICAgICAgc3RhdGUucm91dGUgPSB0aGlzLnBhcnNlVXJsKHRoaXMuaW5kZXhOYW1lKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5yZWZlcnJlclJvdXRlID0gdGhpcy5jdXJyZW50Um91dGU7XHJcbiAgICB0aGlzLmN1cnJlbnRSb3V0ZSA9IHN0YXRlLnJvdXRlO1xyXG4gICAgLy9jb25zb2xlLmxvZygnc2hlbGwgcmVwbGFjZScsIHN0YXRlLnJvdXRlKTtcclxuXHJcbiAgICAvLyBBY2Nlc3MgY29udHJvbFxyXG4gICAgdmFyIGFjY2Vzc0Vycm9yID0gdGhpcy5hY2Nlc3NDb250cm9sKHN0YXRlLnJvdXRlKTtcclxuICAgIGlmIChhY2Nlc3NFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdvKHRoaXMubm9uQWNjZXNzTmFtZSwgYWNjZXNzRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvY2F0aW5nIHRoZSBjb250YWluZXJcclxuICAgIHZhciAkY29udCA9IHRoaXMuaXRlbXMuZmluZChzdGF0ZS5yb3V0ZS5uYW1lKTtcclxuICAgIHZhciBzaGVsbCA9IHRoaXM7XHJcbiAgICB2YXIgcHJvbWlzZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKCRjb250ICYmICRjb250Lmxlbmd0aCkge1xyXG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgJG9sZENvbnQgPSBzaGVsbC5pdGVtcy5nZXRBY3RpdmUoKTtcclxuICAgICAgICAgICAgICAgICRvbGRDb250ID0gJG9sZENvbnQubm90KCRjb250KTtcclxuICAgICAgICAgICAgICAgIHNoZWxsLml0ZW1zLnN3aXRjaCgkb2xkQ29udCwgJGNvbnQsIHNoZWxsLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzaGVsbCByZXBsYWNlIGFmdGVyIHN3aXRjaCcsIHN0YXRlLnJvdXRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7IC8vPyByZXNvbHZlKGFjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5sb2FkZXIpIHtcclxuICAgICAgICAgICAgLy8gbG9hZCBhbmQgaW5qZWN0IHRoZSBjb250ZW50IGluIHRoZSBwYWdlXHJcbiAgICAgICAgICAgIC8vIHRoZW4gdHJ5IHRoZSByZXBsYWNlIGFnYWluXHJcbiAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLmxvYWRlci5sb2FkKHN0YXRlLnJvdXRlKS50aGVuKGZ1bmN0aW9uKGh0bWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgaXRlbXMgKHRoZSBtYW5hZ2VyIHRha2VzIGNhcmUgeW91XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgb25seSB0aGUgaXRlbSwgaWYgdGhlcmUgaXMgb25lKVxyXG4gICAgICAgICAgICAgICAgc2hlbGwuaXRlbXMuaW5qZWN0KHN0YXRlLnJvdXRlLm5hbWUsIGh0bWwpO1xyXG4gICAgICAgICAgICAgICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgdGhlIGl0ZW0gd2FzIGFkZGVkIGFuZCBpcyByZWFkeVxyXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIGEgcmVxdWVzdCBub3QgcmV0dXJuaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaXRlbSBhbmQgdGhlICdyZXBsYWNlJyB0cnlpbmcgdG8gbG9hZCBpdCBhZ2FpbiwgYW5kIGFnYWluLCBhbmQuLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoZWxsLml0ZW1zLmZpbmQoc3RhdGUucm91dGUubmFtZSkubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGVsbC5yZXBsYWNlKHN0YXRlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdQYWdlIG5vdCBmb3VuZCAoJyArIHN0YXRlLnJvdXRlLm5hbWUgKyAnKScpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NoZWxsIFBhZ2Ugbm90IGZvdW5kLCBzdGF0ZTonLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVG8gYXZvaWQgYmVpbmcgaW4gYW4gaW5leGlzdGFudCBVUkwgKGdlbmVyYXRpbmcgaW5jb25zaXN0ZW5jeSBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgdmlldyBhbmQgVVJMLCBjcmVhdGluZyBiYWQgaGlzdG9yeSBlbnRyaWVzKSxcclxuICAgICAgICAgICAgLy8gYSBnb0JhY2sgaXMgZXhlY3V0ZWQsIGp1c3QgYWZ0ZXIgdGhlIGN1cnJlbnQgcGlwZSBlbmRzXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCByZWRpcmVjdCB0aGF0IGN1dCBjdXJyZW50IHByb2Nlc3NpbmcgcmF0aGVyIHRoYW4gZXhlY3V0ZSBkZWxheWVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdvQmFjaygpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHRoaXNTaGVsbCA9IHRoaXM7XHJcbiAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSlcclxuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKGVycik7XHJcblxyXG4gICAgICAgIC8vIExvZyBlcnJvciwgXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU2hlbGwsIHVuZXhwZWN0ZWQgZXJyb3IuJywgZXJyKTtcclxuICAgICAgICAvLyBub3RpZnkgYXMgYW4gZXZlbnRcclxuICAgICAgICB0aGlzU2hlbGwuZW1pdCgnZXJyb3InLCBlcnIpO1xyXG4gICAgICAgIC8vIGFuZCBjb250aW51ZSBwcm9wYWdhdGluZyB0aGUgZXJyb3JcclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbn07XHJcblxyXG5TaGVsbC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKCkge1xyXG5cclxuICAgIHZhciBzaGVsbCA9IHRoaXM7XHJcblxyXG4gICAgLy8gQ2F0Y2ggcG9wc3RhdGUgZXZlbnQgdG8gdXBkYXRlIHNoZWxsIHJlcGxhY2luZyB0aGUgYWN0aXZlIGNvbnRhaW5lci5cclxuICAgIC8vIEFsbG93cyBwb2x5ZmlsbHMgdG8gcHJvdmlkZSBhIGRpZmZlcmVudCBidXQgZXF1aXZhbGVudCBldmVudCBuYW1lXHJcbiAgICB0aGlzLiQod2luZG93KS5vbih0aGlzLmhpc3RvcnkucG9wc3RhdGVFdmVudCB8fCAncG9wc3RhdGUnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzdGF0ZSA9IGV2ZW50LnN0YXRlIHx8IFxyXG4gICAgICAgICAgICAoZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnN0YXRlKSB8fCBcclxuICAgICAgICAgICAgc2hlbGwuaGlzdG9yeS5zdGF0ZTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHN0YXRlIGZvciBjdXJyZW50LiBUbyBzdXBwb3J0IHBvbHlmaWxscywgd2UgdXNlIHRoZSBnZW5lcmFsIGdldHRlclxyXG4gICAgICAgIC8vIGhpc3Rvcnkuc3RhdGUgYXMgZmFsbGJhY2sgKHRoZXkgbXVzdCBiZSB0aGUgc2FtZSBvbiBicm93c2VycyBzdXBwb3J0aW5nIEhpc3RvcnkgQVBJKVxyXG4gICAgICAgIHNoZWxsLnJlcGxhY2Uoc3RhdGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVE9ETzogUmV2aWV3IGlmIGFsbCB0aGlzIG5leHQgc3RpbGwgaXMgdXNhYmxlIGFuZCBoYXMgdXNlIGNhc2VzLCBzaW5jZSB0aGUgcHJvamVjdFxyXG4gICAgLy8gbm93IHVzZXMgZmFzdGNsaWNrIGxpYnJhcnkgdG8gYXZvaWQgdGhlIGlPUyBkZWxheSwgdXNpbmcgYWdhaW4gY2xpY2sgYWdhaW5zdCB0YXAgZXZlbnQuXHJcbiAgICAvL1xyXG4gICAgLy8gQ2F0Y2ggYWxsIGxpbmtzIGluIHRoZSBwYWdlIChub3Qgb25seSAkcm9vdCBvbmVzKSBhbmQgbGlrZS1saW5rcy5cclxuICAgIC8vIElNUE9SVEFOVDogdGhlIHRpbWVvdXQgYW5kIGxpbmtXb3JraW5nIGlzIGEga2luZCBvZiBoYWNrL3dvcmthcm91bmQgYmVjYXVzZSBvZjpcclxuICAgIC8vIC0gaU9TIGNsaWNrIGRlbGF5OiBjaGFuZ2luZyBsaW5rRXZlbnQgdG8gYmUgJ3RhcCBjbGljaycgKGpxbSB0YXAgZXZlbnQpIG9yIFxyXG4gICAgLy8gICBtb3JlIHN0YW5kYXJkIGJ1dCBzaW1wbGlzdGljICd0b3VjaGVuZCBjbGljaycsIG9ubHkgb24gaU9TIGlmIHBvc3NpYmxlLCB0aGVcclxuICAgIC8vICAgaU9TIGNsaWNrIGRlbGF5IGNhbiBiZSBhdm9pZGVkLCBsZXR0aW5nIHRoZSB0b3VjaCBldmVudCB0byB0cmlnZ2VyIHRoaXMgU2hlbGwgaGFuZGxlclxyXG4gICAgLy8gICBhbmQgcHJldmVudGluZyB0aGUgY2xpY2sgZnJvbSBoYXBwZW5pbmcgdG8gYXZvaWQgZG91YmxlIGV4ZWN1dGlvblxyXG4gICAgLy8gICAodGhhbmtzIHRvIGxpbmtXb3JraW5nIGFuZCBzZXRUaW1lb3V0KS5cclxuICAgIC8vICAgQSBicm9rZW4gYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8gdXNlIG9ubHkgb25lIGV2ZW50LCBsaWtlICd0YXAnIG9yICd0b3VjaGVuZCcsIGJ1dFxyXG4gICAgLy8gICB0aGV5IGZhbGwgZG93biB3aGVuIGEgdG91Y2ggZ2VzdHVyZSBoYXBwZW5zIGluIHRoZSBsaW1pdCBvZiBhIGxpbmsvZWxlbWVudCBiZWNhdXNlXHJcbiAgICAvLyAgIGEgdG91Y2hzdGFydCBoYXBwZW5zIG91dCBvZiBvdXIgdGFyZ2V0IGxpbmsgLWZhaWxpbmcgdG91Y2hlbmQgYW5kIHRhcCBzaW5jZSBkb24ndCBcclxuICAgIC8vICAgZ2V0IHRyaWdnZXJlZCBpbiBvdXIgbGluay0gYnV0IHRoZSBicm93c2VyL3dlYnZpZXcgc3RpbGwgZXhlY3V0ZXMgKGFuZCBpbm1lZGlhdGx5KVxyXG4gICAgLy8gICB0aGUgJ2NsaWNrJyBldmVudCBvbiB0aGUgbGluay4gSXQgc2VlbXMgYW4gZWRnZSBjYXNlIGJ1dCBpcyBlYXNpZXIgdG8gbWFrZSBpdCBoYXBwZW5zXHJcbiAgICAvLyAgIHRoYW4gaXQgc2VlbXMuIEl0J3MgdGhlIGJ1ZyB0aGF0IGZvcmNlZCB0byBpbXBsZW1lbnQgdGhpcyB3b3JrYW91cm5kIDotL1xyXG4gICAgLy8gLSBBbmQgYWRkaXRpb25hbGx5OiBpdCBwcmV2ZW50cyB0d28gJ2NsaWNrcycgZnJvbSBoYXBwZW5pbmcgZXhjZXNzaXZlIGZhc3QgYmVjYXVzZVxyXG4gICAgLy8gICBzb21lIGtpbmQgb2YgYSBzZWNvbmQgdW53YW50ZWQgdG91Y2ggaGFwcGVuaW5nIHZlcnkgZmFzdCwgbWFraW5nXHJcbiAgICAvLyAgIGEgY2xpY2sgYnkgbWlzdGFrZSBvbiBhIGRpZmZlcmVudCBsaW5rIG9uIHRoZSBsb2FkZWQgbmV3IHBhZ2UuXHJcbiAgICB2YXIgbGlua1dvcmtpbmcgPSBudWxsLFxyXG4gICAgICAgIC8vIE9MRDogaU9TIDMwMG1zIGRlbGF5LCBhIGJpdCBpbmNyZWFzZWQgdG8gYXZvaWQgcHJvYmxlbXMuXHJcbiAgICAgICAgLy8gTk9URTogYXMgb2YgaW5jbHVzaW9uIG9mIGZhc3RjbGljayBpbiB0aGUgbWFpbiBwcm9qZWN0LCByZWR1Y2VkXHJcbiAgICAgICAgLy8gdGhpcyBkZWxheSB0byBhdm9pZCBiZWluZyBub3RpY2VhYmxlIG9uIHNvbWUgZWRnZSBjYXNlcywgYnV0IHN0aWxsXHJcbiAgICAgICAgLy8gcHJlc2VydmluZyBiZWNhdXNlIG90aGVyIG5vdCB2ZXJpZmllZCB1c2UgY2FzZXMgKGxpa2Ugb24gYSB0b3VjaCBvbiBhIGxpbmsgdGhhdCBkeW5hbWljYWxseVxyXG4gICAgICAgIC8vIGNoYW5nZXMgYmVpbmcgcGVyY2VpdmVkIGFzIHR3byBxdWljayBjb25zZWN1dGl2ZSBjbGlja3MsIGV4ZWN1dGluZyB0d28gYWN0aW9ucyBpbiBvbmUgYW5kIHRoYXQgYmVpbmcgdW53YW50ZWQpXHJcbiAgICAgICAgbGlua1dvcmtpbmdEZWxheSA9IDgwOyAvLyAzNDA7IC8vIG1zXHJcbiAgICAvL0RFQlVHIHZhciBsaW5rRXZlbnQgPSB0aGlzLmxpbmtFdmVudDtcclxuICAgIHRoaXMuJChkb2N1bWVudCkub24odGhpcy5saW5rRXZlbnQsICdbaHJlZl0sIFtkYXRhLWhyZWZdJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJ1NoZWxsIG9uIGV2ZW50JywgZS50eXBlLCBsaW5rV29ya2luZyk7XHJcbiAgICAgICAgLy8gSWYgd29ya2luZywgYXZvaWQgZXZlcnl0aGluZzpcclxuICAgICAgICBpZiAobGlua1dvcmtpbmcpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBsaW5rV29ya2luZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGxpbmtXb3JraW5nID0gbnVsbDtcclxuICAgICAgICB9LCBsaW5rV29ya2luZ0RlbGF5KTtcclxuXHJcbiAgICAgICAgdmFyICR0ID0gc2hlbGwuJCh0aGlzKSxcclxuICAgICAgICAgICAgaHJlZiA9ICR0LmF0dHIoJ2hyZWYnKSB8fCAkdC5kYXRhKCdocmVmJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9ERUJVRyBjb25zb2xlLmxvZygnU2hlbGwgb24nLCBsaW5rRXZlbnQsIGUudHlwZSwgJ2hyZWYnLCBocmVmLCAnZWxlbWVudCcsICR0KTtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgVVJMIGNvbnRhaW5zIHRoZSBwcm90b2NvbFxyXG4gICAgICAgIGlmICgvXlthLXpdKzovaS50ZXN0KGhyZWYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hlbGwuZm9yY2VIYXNoYmFuZyAmJiAvXiMoW14hXXwkKS8udGVzdChocmVmKSkge1xyXG4gICAgICAgICAgICAvLyBTdGFuZGFyZCBoYXNoLCBidXQgbm90IGhhc2hiYW5nOiBhdm9pZCByb3V0aW5nIGFuZCBkZWZhdWx0IGJlaGF2aW9yXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciBzcGVjaWFsIGV2ZW50IG9uIHRoZSBzaGVsbCwgc28gZXh0ZXJuYWwgc2NyaXB0cyBjYW4gZG9cclxuICAgICAgICAgICAgLy8gc29tZXRoaW5nLCBsaWtlIHRyeWluZyB0byBpbXBsZW1lbnQgc3RhbmRhcmQgc2Nyb2xsIGJlaGF2aW9yIG9yIGFueVxyXG4gICAgICAgICAgICAvLyBQYXNzIGluOiBzb3VyY2UgZnJhZ21lbnQgbGluaywgZWxlbWVudCB0aGF0IHJlY2VpdmUgdGhlIG9yaWdpbmFsIGV2ZW50IGFuZFxyXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAgICAgICAgICAgIHNoZWxsLmVtaXQoJ2ZyYWdtZW50TmF2aWdhdGlvbicsIGhyZWYsIHRoaXMsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGVkIGRlbGF5ZWQgdG8gYXZvaWQgaGFuZGxlciBjb2xsaXNpb25zLCBiZWNhdXNlXHJcbiAgICAgICAgLy8gb2YgdGhlIG5ldyBwYWdlIG1vZGlmeWluZyB0aGUgZWxlbWVudCBhbmQgb3RoZXIgaGFuZGxlcnNcclxuICAgICAgICAvLyByZWFkaW5nIGl0IGF0dHJpYnV0ZXMgYW5kIGFwcGx5aW5nIGxvZ2ljIG9uIHRoZSB1cGRhdGVkIGxpbmtcclxuICAgICAgICAvLyBhcyBpZiB3YXMgdGhlIG9sZCBvbmUgKGV4YW1wbGU6IHNoYXJlZCBsaW5rcywgbGlrZSBpbiBhXHJcbiAgICAgICAgLy8gZ2xvYmFsIG5hdmJhciwgdGhhdCBtb2RpZmllcyB3aXRoIHRoZSBuZXcgcGFnZSkuXHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc2hlbGwuZ28oaHJlZik7XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJbml0aWFsbGl6ZSBzdGF0ZVxyXG4gICAgdGhpcy5pdGVtcy5pbml0KCk7XHJcbiAgICAvLyBSb3V0ZSB0byB0aGUgY3VycmVudCB1cmwvc3RhdGVcclxuICAgIHRoaXMucmVwbGFjZSgpO1xyXG59O1xyXG4iLCIvKipcclxuICAgIGFic29sdXRpemVVcmwgdXRpbGl0eSBcclxuICAgIHRoYXQgZW5zdXJlcyB0aGUgdXJsIHByb3ZpZGVkXHJcbiAgICBiZWluZyBpbiB0aGUgcGF0aCBvZiB0aGUgZ2l2ZW4gYmFzZVVybFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHNhbml0aXplVXJsID0gcmVxdWlyZSgnLi9zYW5pdGl6ZVVybCcpLFxyXG4gICAgZXNjYXBlUmVnRXhwID0gcmVxdWlyZSgnLi4vZXNjYXBlUmVnRXhwJyk7XHJcblxyXG5mdW5jdGlvbiBhYnNvbHV0aXplVXJsKGJhc2VVcmwsIHVybCkge1xyXG5cclxuICAgIC8vIHNhbml0aXplIGJlZm9yZSBjaGVja1xyXG4gICAgdXJsID0gc2FuaXRpemVVcmwodXJsKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB1c2UgdGhlIGJhc2UgYWxyZWFkeVxyXG4gICAgdmFyIG1hdGNoQmFzZSA9IG5ldyBSZWdFeHAoJ14nICsgZXNjYXBlUmVnRXhwKGJhc2VVcmwpLCAnaScpO1xyXG4gICAgaWYgKG1hdGNoQmFzZS50ZXN0KHVybCkpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJ1aWxkIGFuZCBzYW5pdGl6ZVxyXG4gICAgcmV0dXJuIHNhbml0aXplVXJsKGJhc2VVcmwgKyB1cmwpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFic29sdXRpemVVcmw7XHJcbiIsIi8qKlxyXG4gICAgRXh0ZXJuYWwgZGVwZW5kZW5jaWVzIGZvciBTaGVsbCBpbiBhIHNlcGFyYXRlIG1vZHVsZVxyXG4gICAgdG8gdXNlIGFzIERJLCBuZWVkcyBzZXR1cCBiZWZvcmUgY2FsbCB0aGUgU2hlbGwuanNcclxuICAgIG1vZHVsZSBjbGFzc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBwYXJzZVVybDogbnVsbCxcclxuICAgIGFic29sdXRpemVVcmw6IG51bGwsXHJcbiAgICBqcXVlcnk6IG51bGwsXHJcbiAgICBsb2FkZXI6IG51bGwsXHJcbiAgICBhY2Nlc3NDb250cm9sOiBmdW5jdGlvbiBhbGxvd0FsbCgvKm5hbWUqLykge1xyXG4gICAgICAgIC8vIGFsbG93IGFjY2VzcyBieSBkZWZhdWx0XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG4gICAgRXZlbnRFbWl0dGVyOiBudWxsXHJcbn07XHJcbiIsIi8qKlxyXG4gICAgU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBIaXN0b3J5IEFQSSB1c2luZyBvbmx5IGhhc2hiYW5ncyBVUkxzLFxyXG4gICAgZG9lc24ndCBtYXR0ZXJzIHRoZSBicm93c2VyIHN1cHBvcnQuXHJcbiAgICBVc2VkIHRvIGF2b2lkIGZyb20gc2V0dGluZyBVUkxzIHRoYXQgaGFzIG5vdCBhbiBlbmQtcG9pbnQsXHJcbiAgICBsaWtlIGluIGxvY2FsIGVudmlyb25tZW50cyB3aXRob3V0IGEgc2VydmVyIGRvaW5nIHVybC1yZXdyaXRpbmcsXHJcbiAgICBpbiBwaG9uZWdhcCBhcHBzLCBvciB0byBjb21wbGV0ZWx5IGJ5LXBhc3MgYnJvd3NlciBzdXBwb3J0IGJlY2F1c2VcclxuICAgIGlzIGJ1Z2d5IChsaWtlIEFuZHJvaWQgPD0gNC4xKS5cclxuICAgIFxyXG4gICAgTk9URVM6XHJcbiAgICAtIEJyb3dzZXIgbXVzdCBzdXBwb3J0ICdoYXNoY2hhbmdlJyBldmVudC5cclxuICAgIC0gQnJvd3NlciBtdXN0IGhhcyBzdXBwb3J0IGZvciBzdGFuZGFyZCBKU09OIGNsYXNzLlxyXG4gICAgLSBSZWxpZXMgb24gc2Vzc2lvbnN0b3JhZ2UgZm9yIHBlcnNpc3RhbmNlLCBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIGFuZCB3ZWJ2aWV3cyBcclxuICAgICAgZm9yIGEgZW5vdWdoIGxvbmcgdGltZSBub3cuXHJcbiAgICAtIFNpbWlsYXIgYXBwcm9hY2ggYXMgSGlzdG9yeS5qcyBwb2x5ZmlsbCwgYnV0IHNpbXBsaWZpZWQsIGFwcGVuZGluZyBhIGZha2UgcXVlcnlcclxuICAgICAgcGFyYW1ldGVyICdfc3VpZD0wJyB0byB0aGUgaGFzaCB2YWx1ZSAoYWN0dWFsIHF1ZXJ5IGdvZXMgYmVmb3JlIHRoZSBoYXNoLCBidXRcclxuICAgICAgd2UgbmVlZCBpdCBpbnNpZGUpLlxyXG4gICAgLSBGb3Igc2ltcGxpZmljYXRpb24sIG9ubHkgdGhlIHN0YXRlIGlzIHBlcnNpc3RlZCwgdGhlICd0aXRsZScgcGFyYW1ldGVyIGlzIG5vdFxyXG4gICAgICB1c2VkIGF0IGFsbCAodGhlIHNhbWUgYXMgbWFqb3IgYnJvd3NlcnMgZG8sIHNvIGlzIG5vdCBhIHByb2JsZW0pOyBpbiB0aGlzIGxpbmUsXHJcbiAgICAgIG9ubHkgaGlzdG9yeSBlbnRyaWVzIHdpdGggc3RhdGUgYXJlIHBlcnNpc3RlZC5cclxuICAgICAgXHJcbiAgICBUT0RPIHJlcGxhY2VTdGF0ZSBkb2VzIG5vdCB3b3JrIGFzIGV4cGVjdGVkLCBpdCBjcmVhdGVzIGEgaGlzdG9yeSBlbnRyeSByYXRoZXIgdGhhbiByZXBsYWNlIGl0XHJcbiAgICAgICAgQSBzb2x1dGlvbiBpZGVhIGlzIHRvIHBlcmZvcm0gYSBicm93c2VyIGdvKC0xKSBhbmQgdGhlIHRoZW4gaGFzaCBjaGFuZ2UgKHB1c2gpLCBidXQgdGhlIGdvIGJhY2tcclxuICAgICAgICBtdXN0IGJ5cGFzcyB0aGUgZXZlbnRzIG5vdGlmaWNhdGlvbi5cclxuKiovXHJcbi8vZ2xvYmFsIGxvY2F0aW9uXHJcbid1c2Ugc3RyaWN0JztcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIHNhbml0aXplVXJsID0gcmVxdWlyZSgnLi9zYW5pdGl6ZVVybCcpLFxyXG4gICAgZ2V0VXJsUXVlcnkgPSByZXF1aXJlKCcuLi9nZXRVcmxRdWVyeScpO1xyXG5cclxuLy8gSW5pdDogTG9hZCBzYXZlZCBjb3B5IGZyb20gc2Vzc2lvblN0b3JhZ2VcclxudmFyIHNlc3Npb24gPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdoYXNoYmFuZ0hpc3Rvcnkuc3RvcmUnKTtcclxuLy8gT3IgY3JlYXRlIGEgbmV3IG9uZVxyXG5pZiAoIXNlc3Npb24pIHtcclxuICAgIHNlc3Npb24gPSB7XHJcbiAgICAgICAgLy8gU3RhdGVzIGFycmF5IHdoZXJlIGVhY2ggaW5kZXggaXMgdGhlIFNVSUQgY29kZSBhbmQgdGhlXHJcbiAgICAgICAgLy8gdmFsdWUgaXMganVzdCB0aGUgdmFsdWUgcGFzc2VkIGFzIHN0YXRlIG9uIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGVcclxuICAgICAgICBzdGF0ZXM6IFtdXHJcbiAgICB9O1xyXG59XHJcbmVsc2Uge1xyXG4gICAgc2Vzc2lvbiA9IEpTT04ucGFyc2Uoc2Vzc2lvbik7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICAgIEdldCB0aGUgU1VJRCBudW1iZXJcclxuICAgIGZyb20gYSBoYXNoIHN0cmluZ1xyXG4qKi9cclxuZnVuY3Rpb24gZ2V0U3VpZChoYXNoKSB7XHJcbiAgICBcclxuICAgIHZhciBzdWlkID0gK2dldFVybFF1ZXJ5KGhhc2gpLl9zdWlkO1xyXG4gICAgaWYgKGlzTmFOKHN1aWQpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBzdWlkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRTdWlkKGhhc2gsIHN1aWQpIHtcclxuICAgIFxyXG4gICAgLy8gV2UgbmVlZCB0aGUgcXVlcnksIHNpbmNlIHdlIG5lZWQgXHJcbiAgICAvLyB0byByZXBsYWNlIHRoZSBfc3VpZCAobWF5IGV4aXN0KVxyXG4gICAgLy8gYW5kIHJlY3JlYXRlIHRoZSBxdWVyeSBpbiB0aGVcclxuICAgIC8vIHJldHVybmVkIGhhc2gtdXJsXHJcbiAgICB2YXIgcXMgPSBnZXRVcmxRdWVyeShoYXNoKTtcclxuICAgIHFzLnB1c2goJ19zdWlkJyk7XHJcbiAgICBxcy5fc3VpZCA9IHN1aWQ7XHJcblxyXG4gICAgdmFyIHF1ZXJ5ID0gW107XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBxdWVyeS5wdXNoKHFzW2ldICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHFzW3FzW2ldXSkpO1xyXG4gICAgfVxyXG4gICAgcXVlcnkgPSBxdWVyeS5qb2luKCcmJyk7XHJcbiAgICBcclxuICAgIGlmIChxdWVyeSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGhhc2guaW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMCwgaW5kZXgpO1xyXG4gICAgICAgIGhhc2ggKz0gJz8nICsgcXVlcnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhhc2g7XHJcbn1cclxuXHJcbi8qKlxyXG4gICAgQXNrIHRvIHBlcnNpc3QgdGhlIHNlc3Npb24gZGF0YS5cclxuICAgIEl0IGlzIGRvbmUgd2l0aCBhIHRpbWVvdXQgaW4gb3JkZXIgdG8gYXZvaWRcclxuICAgIGRlbGF5IGluIHRoZSBjdXJyZW50IHRhc2sgbWFpbmx5IGFueSBoYW5kbGVyXHJcbiAgICB0aGF0IGFjdHMgYWZ0ZXIgYSBIaXN0b3J5IGNoYW5nZS5cclxuKiovXHJcbmZ1bmN0aW9uIHBlcnNpc3QoKSB7XHJcbiAgICAvLyBFbm91Z2ggdGltZSB0byBhbGxvdyByb3V0aW5nIHRhc2tzLFxyXG4gICAgLy8gbW9zdCBhbmltYXRpb25zIGZyb20gZmluaXNoIGFuZCB0aGUgVUlcclxuICAgIC8vIGJlaW5nIHJlc3BvbnNpdmUuXHJcbiAgICAvLyBCZWNhdXNlIHNlc3Npb25TdG9yYWdlIGlzIHN5bmNocm9ub3VzLlxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdoYXNoYmFuZ0hpc3Rvcnkuc3RvcmUnLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XHJcbiAgICB9LCAxNTAwKTtcclxufVxyXG5cclxuLyoqXHJcbiAgICBSZXR1cm5zIHRoZSBnaXZlbiBzdGF0ZSBvciBudWxsXHJcbiAgICBpZiBpcyBhbiBlbXB0eSBvYmplY3QuXHJcbioqL1xyXG5mdW5jdGlvbiBjaGVja1N0YXRlKHN0YXRlKSB7XHJcbiAgICBcclxuICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgIC8vIGlzIGVtcHR5P1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBOb1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGl0cyBlbXB0eVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gQW55dGhpbmcgZWxzZVxyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG59XHJcblxyXG4vKipcclxuICAgIEdldCBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvblxyXG4gICAgb2YgdGhlIFVSTCBzbyBjYW4gYmUgY29tcGFyZWRcclxuICAgIHdpdGggc3VjY2Vzcy5cclxuKiovXHJcbmZ1bmN0aW9uIGNhbm5vbmljYWxVcmwodXJsKSB7XHJcbiAgICBcclxuICAgIC8vIEF2b2lkIHNvbWUgYmFkIG9yIHByb2JsZW1hdGljIHN5bnRheFxyXG4gICAgdXJsID0gc2FuaXRpemVVcmwodXJsIHx8ICcnKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHRoZSBoYXNoIHBhcnRcclxuICAgIHZhciBpaGFzaCA9IHVybC5pbmRleE9mKCcjJyk7XHJcbiAgICBpZiAoaWhhc2ggPiAtMSkge1xyXG4gICAgICAgIHVybCA9IHVybC5zdWJzdHIoaWhhc2ggKyAxKTtcclxuICAgIH1cclxuICAgIC8vIE1heWJlIGEgaGFzaGJhbmcgVVJMLCByZW1vdmUgdGhlXHJcbiAgICAvLyAnYmFuZycgKHRoZSBoYXNoIHdhcyByZW1vdmVkIGFscmVhZHkpXHJcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXiEvLCAnJyk7XHJcblxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG5cclxuLyoqXHJcbiAgICBUcmFja3MgdGhlIGxhdGVzdCBVUkxcclxuICAgIGJlaW5nIHB1c2hlZCBvciByZXBsYWNlZCBieVxyXG4gICAgdGhlIEFQSS5cclxuICAgIFRoaXMgYWxsb3dzIGxhdGVyIHRvIGF2b2lkXHJcbiAgICB0cmlnZ2VyIHRoZSBwb3BzdGF0ZSBldmVudCxcclxuICAgIHNpbmNlIG11c3QgTk9UIGJlIHRyaWdnZXJlZFxyXG4gICAgYXMgYSByZXN1bHQgb2YgdGhhdCBBUEkgbWV0aG9kc1xyXG4qKi9cclxudmFyIGxhdGVzdFB1c2hlZFJlcGxhY2VkVXJsID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gICAgSGlzdG9yeSBQb2x5ZmlsbFxyXG4qKi9cclxudmFyIGhhc2hiYW5nSGlzdG9yeSA9IHtcclxuICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKSB7XHJcblxyXG4gICAgICAgIC8vIGNsZWFudXAgdXJsXHJcbiAgICAgICAgdXJsID0gY2Fubm9uaWNhbFVybCh1cmwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHNhdmUgbmV3IHN0YXRlIGZvciB1cmxcclxuICAgICAgICBzdGF0ZSA9IGNoZWNrU3RhdGUoc3RhdGUpIHx8IG51bGw7XHJcbiAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgc3RhdGVcclxuICAgICAgICAgICAgc2Vzc2lvbi5zdGF0ZXMucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciBzdWlkID0gc2Vzc2lvbi5zdGF0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIFVSTCB3aXRoIHRoZSBzdWlkXHJcbiAgICAgICAgICAgIHVybCA9IHNldFN1aWQodXJsLCBzdWlkKTtcclxuICAgICAgICAgICAgLy8gY2FsbCB0byBwZXJzaXN0IHRoZSB1cGRhdGVkIHNlc3Npb25cclxuICAgICAgICAgICAgcGVyc2lzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsYXRlc3RQdXNoZWRSZXBsYWNlZFVybCA9IHVybDtcclxuICAgICAgICBcclxuICAgICAgICAvLyB1cGRhdGUgbG9jYXRpb24gdG8gdHJhY2sgaGlzdG9yeTpcclxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMhJyArIHVybDtcclxuICAgIH0sXHJcbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGNsZWFudXAgdXJsXHJcbiAgICAgICAgdXJsID0gY2Fubm9uaWNhbFVybCh1cmwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGl0IGhhcyBzYXZlZCBzdGF0ZT9cclxuICAgICAgICB2YXIgc3VpZCA9IGdldFN1aWQodXJsKSxcclxuICAgICAgICAgICAgaGFzT2xkU3RhdGUgPSBzdWlkICE9PSBudWxsO1xyXG5cclxuICAgICAgICAvLyBzYXZlIG5ldyBzdGF0ZSBmb3IgdXJsXHJcbiAgICAgICAgc3RhdGUgPSBjaGVja1N0YXRlKHN0YXRlKSB8fCBudWxsO1xyXG4gICAgICAgIC8vIGl0cyBzYXZlZCBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdG8gc2F2ZVxyXG4gICAgICAgIC8vIG9yIHNvbWV0aGluZyB0byBkZXN0cm95XHJcbiAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsIHx8IGhhc09sZFN0YXRlKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgc3RhdGVcclxuICAgICAgICAgICAgaWYgKGhhc09sZFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGV4aXN0aW5nIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnN0YXRlc1tzdWlkXSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVybCByZW1haW5zIHRoZSBzYW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgc3RhdGVcclxuICAgICAgICAgICAgICAgIHNlc3Npb24uc3RhdGVzLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgc3VpZCA9IHNlc3Npb24uc3RhdGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgVVJMIHdpdGggdGhlIHN1aWRcclxuICAgICAgICAgICAgICAgIHVybCA9IHNldFN1aWQodXJsLCBzdWlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxsIHRvIHBlcnNpc3QgdGhlIHVwZGF0ZWQgc2Vzc2lvblxyXG4gICAgICAgICAgICBwZXJzaXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGxhdGVzdFB1c2hlZFJlcGxhY2VkVXJsID0gdXJsO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbG9jYXRpb24gdG8gdHJhY2sgaGlzdG9yeTpcclxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMhJyArIHVybDtcclxuICAgIH0sXHJcbiAgICBnZXQgc3RhdGUoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN1aWQgPSBnZXRTdWlkKGxvY2F0aW9uLmhhc2gpO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHN1aWQgIT09IG51bGwgP1xyXG4gICAgICAgICAgICBzZXNzaW9uLnN0YXRlc1tzdWlkXSA6XHJcbiAgICAgICAgICAgIG51bGxcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5Lmxlbmd0aDtcclxuICAgIH0sXHJcbiAgICBnbzogZnVuY3Rpb24gZ28ob2Zmc2V0KSB7XHJcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuZ28ob2Zmc2V0KTtcclxuICAgIH0sXHJcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcclxuICAgIH0sXHJcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEF0dGFjaCBoYXNoY2FuZ2UgZXZlbnQgdG8gdHJpZ2dlciBIaXN0b3J5IEFQSSBldmVudCAncG9wc3RhdGUnXHJcbnZhciAkdyA9ICQod2luZG93KTtcclxuJHcub24oJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbihlKSB7XHJcbiAgICBcclxuICAgIHZhciB1cmwgPSBlLm9yaWdpbmFsRXZlbnQubmV3VVJMO1xyXG4gICAgdXJsID0gY2Fubm9uaWNhbFVybCh1cmwpO1xyXG4gICAgXHJcbiAgICAvLyBBbiBVUkwgYmVpbmcgcHVzaGVkIG9yIHJlcGxhY2VkXHJcbiAgICAvLyBtdXN0IE5PVCB0cmlnZ2VyIHBvcHN0YXRlXHJcbiAgICBpZiAodXJsID09PSBsYXRlc3RQdXNoZWRSZXBsYWNlZFVybClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBcclxuICAgIC8vIGdldCBzdGF0ZSBmcm9tIGhpc3RvcnkgZW50cnlcclxuICAgIC8vIGZvciB0aGUgdXBkYXRlZCBVUkwsIGlmIGFueVxyXG4gICAgLy8gKGNhbiBoYXZlIHZhbHVlIHdoZW4gdHJhdmVyc2luZ1xyXG4gICAgLy8gaGlzdG9yeSkuXHJcbiAgICB2YXIgc3VpZCA9IGdldFN1aWQodXJsKSxcclxuICAgICAgICBzdGF0ZSA9IG51bGw7XHJcbiAgICBcclxuICAgIGlmIChzdWlkICE9PSBudWxsKVxyXG4gICAgICAgIHN0YXRlID0gc2Vzc2lvbi5zdGF0ZXNbc3VpZF07XHJcblxyXG4gICAgJHcudHJpZ2dlcihuZXcgJC5FdmVudCgncG9wc3RhdGUnLCB7XHJcbiAgICAgICAgc3RhdGU6IHN0YXRlXHJcbiAgICB9KSwgJ2hhc2hiYW5nSGlzdG9yeScpO1xyXG59KTtcclxuXHJcbi8vIEZvciBIaXN0b3J5QVBJIGNhcGFibGUgYnJvd3NlcnMsIHdlIG5lZWRcclxuLy8gdG8gY2FwdHVyZSB0aGUgbmF0aXZlICdwb3BzdGF0ZScgZXZlbnQgdGhhdFxyXG4vLyBnZXRzIHRyaWdnZXJlZCBvbiBvdXIgcHVzaC9yZXBsYWNlU3RhdGUgYmVjYXVzZVxyXG4vLyBvZiB0aGUgbG9jYXRpb24gY2hhbmdlLCBidXQgdG9vIG9uIHRyYXZlcnNpbmdcclxuLy8gdGhlIGhpc3RvcnkgKGJhY2svZm9yd2FyZCkuXHJcbi8vIFdlIHdpbGwgbG9jayB0aGUgZXZlbnQgZXhjZXB0IHdoZW4gaXNcclxuLy8gdGhlIG9uZSB3ZSB0cmlnZ2VyLlxyXG4vL1xyXG4vLyBOT1RFOiB0byB0aGlzIHRyaWNrIHRvIHdvcmssIHRoaXMgbXVzdFxyXG4vLyBiZSB0aGUgZmlyc3QgaGFuZGxlciBhdHRhY2hlZCBmb3IgdGhpc1xyXG4vLyBldmVudCwgc28gY2FuIGJsb2NrIGFsbCBvdGhlcnMuXHJcbi8vIEFMVEVSTkFUSVZFOiBpbnN0ZWFkIG9mIHRoaXMsIG9uIHRoZVxyXG4vLyBwdXNoL3JlcGxhY2VTdGF0ZSBtZXRob2RzIGRldGVjdCBpZlxyXG4vLyBIaXN0b3J5QVBJIGlzIG5hdGl2ZSBzdXBwb3J0ZWQgYW5kXHJcbi8vIHVzZSByZXBsYWNlU3RhdGUgdGhlcmUgcmF0aGVyIHRoYW5cclxuLy8gYSBoYXNoIGNoYW5nZS5cclxuJHcub24oJ3BvcHN0YXRlJywgZnVuY3Rpb24oZSwgc291cmNlKSB7XHJcbiAgICBcclxuICAgIC8vIEVuc3VyaW5nIGlzIHRoZSBvbmUgd2UgdHJpZ2dlclxyXG4gICAgaWYgKHNvdXJjZSA9PT0gJ2hhc2hiYW5nSGlzdG9yeScpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAvLyBJbiBvdGhlciBjYXNlLCBibG9jazpcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbn0pO1xyXG5cclxuLy8gRXhwb3NlIEFQSVxyXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hiYW5nSGlzdG9yeTtcclxuIiwiLyoqXHJcbiAgICBEZWZhdWx0IGJ1aWxkIG9mIHRoZSBTaGVsbCBjb21wb25lbnQuXHJcbiAgICBJdCByZXR1cm5zIHRoZSBTaGVsbCBjbGFzcyBhcyBhIG1vZHVsZSBwcm9wZXJ0eSxcclxuICAgIHNldHRpbmcgdXAgdGhlIGJ1aWx0LWluIG1vZHVsZXMgYXMgaXRzIGRlcGVuZGVuY2llcyxcclxuICAgIGFuZCB0aGUgZXh0ZXJuYWwgJ2pxdWVyeScgYW5kICdldmVudHMnIChmb3IgdGhlIEV2ZW50RW1pdHRlcikuXHJcbiAgICBJdCByZXR1cm5zIHRvbyB0aGUgYnVpbHQtaXQgRG9tSXRlbXNNYW5hZ2VyIGNsYXNzIGFzIGEgcHJvcGVydHkgZm9yIGNvbnZlbmllbmNlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlcHMgPSByZXF1aXJlKCcuL2RlcGVuZGVuY2llcycpLFxyXG4gICAgRG9tSXRlbXNNYW5hZ2VyID0gcmVxdWlyZSgnLi9Eb21JdGVtc01hbmFnZXInKSxcclxuICAgIHBhcnNlVXJsID0gcmVxdWlyZSgnLi9wYXJzZVVybCcpLFxyXG4gICAgYWJzb2x1dGl6ZVVybCA9IHJlcXVpcmUoJy4vYWJzb2x1dGl6ZVVybCcpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgbG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKSxcclxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxuXHJcbiQuZXh0ZW5kKGRlcHMsIHtcclxuICAgIHBhcnNlVXJsOiBwYXJzZVVybCxcclxuICAgIGFic29sdXRpemVVcmw6IGFic29sdXRpemVVcmwsXHJcbiAgICBqcXVlcnk6ICQsXHJcbiAgICBsb2FkZXI6IGxvYWRlcixcclxuICAgIEV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyXHJcbn0pO1xyXG5cclxuLy8gRGVwZW5kZW5jaWVzIGFyZSByZWFkeSwgd2UgY2FuIGxvYWQgdGhlIGNsYXNzOlxyXG52YXIgU2hlbGwgPSByZXF1aXJlKCcuL1NoZWxsJyk7XHJcblxyXG5leHBvcnRzLlNoZWxsID0gU2hlbGw7XHJcbmV4cG9ydHMuRG9tSXRlbXNNYW5hZ2VyID0gRG9tSXRlbXNNYW5hZ2VyO1xyXG4iLCIvKipcclxuICAgIExvYWRlciB1dGlsaXR5IHRvIGxvYWQgU2hlbGwgaXRlbXMgb24gZGVtYW5kIHdpdGggQUpBWFxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBiYXNlVXJsOiAnLycsXHJcbiAgICBcclxuICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQocm91dGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTaGVsbCBsb2FkaW5nIG9uIGRlbWFuZCcsIHJvdXRlLm5hbWUsIHJvdXRlKTtcclxuICAgICAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgICAgICAgIHVybDogbW9kdWxlLmV4cG9ydHMuYmFzZVVybCArIHJvdXRlLm5hbWUgKyAnLmh0bWwnLFxyXG4gICAgICAgICAgICAgICAgY2FjaGU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgbG9hZGluZyB0aGUgcHJvZ3JhbSBhbmQgbm8gbG9hZGVyIHNjcmVlbiBpbiBwbGFjZSxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGFueSBpbiBiZXR3ZWVuIGludGVyYWN0aW9uIHdpbGwgYmUgcHJvYmxlbWF0aWMuXHJcbiAgICAgICAgICAgICAgICAvL2FzeW5jOiBmYWxzZVxyXG4gICAgICAgICAgICB9KS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbiIsIi8qKlxyXG4gICAgcGFyc2VVcmwgZnVuY3Rpb24gZGV0ZWN0aW5nXHJcbiAgICB0aGUgbWFpbiBwYXJ0cyBvZiB0aGUgVVJMIGluIGFcclxuICAgIGNvbnZlbmllbmNlIHdheSBmb3Igcm91dGluZy5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBnZXRVcmxRdWVyeSA9IHJlcXVpcmUoJy4uL2dldFVybFF1ZXJ5JyksXHJcbiAgICBlc2NhcGVSZWdFeHAgPSByZXF1aXJlKCcuLi9lc2NhcGVSZWdFeHAnKTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlVXJsKGJhc2VVcmwsIGxpbmspIHtcclxuXHJcbiAgICBsaW5rID0gbGluayB8fCAnJztcclxuXHJcbiAgICB2YXIgcmF3VXJsID0gbGluaztcclxuXHJcbiAgICAvLyBoYXNoYmFuZyBzdXBwb3J0OiByZW1vdmUgdGhlICMhIG9yIHNpbmdsZSAjIGFuZCB1c2UgdGhlIHJlc3QgYXMgdGhlIGxpbmtcclxuICAgIGxpbmsgPSBsaW5rLnJlcGxhY2UoL14jIS8sICcnKS5yZXBsYWNlKC9eIy8sICcnKTtcclxuICAgIFxyXG4gICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGluaXRpYWwgc2xhc2ggb3IgZG90LXNsYXNoXHJcbiAgICBsaW5rID0gbGluay5yZXBsYWNlKC9eXFwvfF5cXC5cXC8vLCAnJyk7XHJcblxyXG4gICAgLy8gVVJMIFF1ZXJ5IGFzIGFuIG9iamVjdCwgZW1wdHkgb2JqZWN0IGlmIG5vIHF1ZXJ5XHJcbiAgICB2YXIgcXVlcnkgPSBnZXRVcmxRdWVyeShsaW5rIHx8ICc/Jyk7XHJcblxyXG4gICAgLy8gcmVtb3ZlIHF1ZXJ5IGZyb20gdGhlIHJlc3Qgb2YgVVJMIHRvIHBhcnNlXHJcbiAgICBsaW5rID0gbGluay5yZXBsYWNlKC9cXD8uKiQvLCAnJyk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSBiYXNlVXJsIHRvIGdldCB0aGUgYXBwIGJhc2UuXHJcbiAgICB2YXIgcGF0aCA9IGxpbmsucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGVzY2FwZVJlZ0V4cChiYXNlVXJsKSwgJ2knKSwgJycpO1xyXG5cclxuICAgIC8vIEdldCBmaXJzdCBzZWdtZW50IG9yIHBhZ2UgbmFtZSAoYW55dGhpbmcgdW50aWwgYSBzbGFzaCBvciBleHRlbnNpb24gYmVnZ2luaW5nKVxyXG4gICAgdmFyIG1hdGNoID0gL15cXC8/KFteXFwvXFwuXSspW15cXC9dKihcXC8uKikqJC8uZXhlYyhwYXRoKTtcclxuXHJcbiAgICB2YXIgcGFyc2VkID0ge1xyXG4gICAgICAgIHJvb3Q6IHRydWUsXHJcbiAgICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgICBzZWdtZW50czogbnVsbCxcclxuICAgICAgICBwYXRoOiBudWxsLFxyXG4gICAgICAgIHVybDogcmF3VXJsLFxyXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBwYXJzZWQucm9vdCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBwYXJzZWQubmFtZSA9IG1hdGNoWzFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aCA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlZ21lbnRzID0gbWF0Y2hbMl0ucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGggPSAnLyc7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQuc2VnbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyc2VkO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVXJsOyIsIi8qKlxyXG4gICAgc2FuaXRpemVVcmwgdXRpbGl0eSB0aGF0IGVuc3VyZXNcclxuICAgIHRoYXQgcHJvYmxlbWF0aWMgcGFydHMgZ2V0IHJlbW92ZWQuXHJcbiAgICBcclxuICAgIEFzIGZvciBub3cgaXQgZG9lczpcclxuICAgIC0gcmVtb3ZlcyBwYXJlbnQgZGlyZWN0b3J5IHN5bnRheFxyXG4gICAgLSByZW1vdmVzIGR1cGxpY2F0ZWQgc2xhc2hlc1xyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XHJcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLnsyLH0vZywgJycpLnJlcGxhY2UoL1xcL3syLH0vZywgJy8nKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzYW5pdGl6ZVVybDsiLCIvKipcclxuICAgIFNtYWxsIHV0aWxpdHkgdG8gc2VhcmNoIGEgdGV4dCBmcmFnbWVudCB1c2luZ1xyXG4gICAgY2FzZSBpbnNlbnNpdGl2ZSwgYWNjZW50L3N5bWJvbCBpbnNlbnNpdGl2ZS5cclxuKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciByZW1vdmVBY2NlbnQgPSByZXF1aXJlKCcuL3JlbW92ZUFjY2VudCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0U2VhcmNoKHNlYXJjaCwgdGV4dCkge1xyXG5cclxuICAgIHZhciBzID0gcmVtb3ZlQWNjZW50KHNlYXJjaCB8fCAnJykudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICB0ID0gcmVtb3ZlQWNjZW50KHRleHQgfHwgJycpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgcmV0dXJuIHQuaW5kZXhPZihzKSA+IC0xO1xyXG59O1xyXG4iLCIvKiogQXBwb2ludG1lbnRDYXJkIHZpZXcgbW9kZWwuXHJcbiAgICBJdCBwcm92aWRlcyBkYXRhIGFuZCBtZXRob2QgdG8gdmlzdWFsaXplIGFuZCBcclxuICAgIGVkaXQgYW5kIGFwcG9pbnRtZW50IGNhcmQsIHdpdGggYm9va2luZywgZXZlbnRcclxuICAgIG9yIHBsYWNlaG9sZGVyIGluZm9ybWF0aW9uXHJcbioqL1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAgZ2V0T2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldE9ic2VydmFibGUnKSxcclxuICAgIEFwcG9pbnRtZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FwcG9pbnRtZW50JyksXHJcbiAgICBBcHBvaW50bWVudFZpZXcgPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL0FwcG9pbnRtZW50VmlldycpLFxyXG4gICAgTW9kZWxWZXJzaW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvTW9kZWxWZXJzaW9uJyksXHJcbiAgICBnZXREYXRlV2l0aG91dFRpbWUgPSByZXF1aXJlKCcuLi91dGlscy9nZXREYXRlV2l0aG91dFRpbWUnKSxcclxuICAgIFByaWNpbmdFc3RpbWF0ZURldGFpbCA9IHJlcXVpcmUoJy4uL21vZGVscy9QcmljaW5nRXN0aW1hdGVEZXRhaWwnKTtcclxuXHJcbmZ1bmN0aW9uIEFwcG9pbnRtZW50Q2FyZFZpZXdNb2RlbChwYXJhbXMpIHtcclxuICAgIC8qanNoaW50IG1heHN0YXRlbWVudHM6IDQwKi9cclxuXHJcbiAgICB0aGlzLnNvdXJjZUl0ZW0gPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5zb3VyY2VJdGVtKTtcclxuICAgIHZhciBhcHAgPSB0aGlzLmFwcCA9IGtvLnVud3JhcChwYXJhbXMuYXBwKTtcclxuXHJcbiAgICB0aGlzLmVkaXRNb2RlID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuZWRpdE1vZGUpO1xyXG4gICAgdGhpcy5lZGl0ZWRWZXJzaW9uID0ga28ub2JzZXJ2YWJsZShudWxsKTtcclxuICAgIFxyXG4gICAgdGhpcy5pc1NhdmluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5pc0xvYWRpbmcpO1xyXG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzU2F2aW5nKCkgfHwgdGhpcy5pc0xvYWRpbmcoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLml0ZW0gPSBrby5vYnNlcnZhYmxlKEFwcG9pbnRtZW50Vmlldyh0aGlzLnNvdXJjZUl0ZW0oKSwgYXBwKSk7XHJcbiAgICBcclxuICAgIHRoaXMuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICBcclxuICAgIHRoaXMuY3VycmVudElEID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpdCA9IHRoaXMuaXRlbSgpO1xyXG4gICAgICAgIHJldHVybiBpdCAmJiBpdC5pZCgpIHx8IDA7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5jdXJyZW50RGF0ZXRpbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbSgpICYmIHRoaXMuaXRlbSgpLnN0YXJ0VGltZSgpIHx8IG5ldyBEYXRlKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5jdXJyZW50RGF0ZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGF0ZVdpdGhvdXRUaW1lKHRoaXMuaXRlbSgpICYmIHRoaXMuaXRlbSgpLnN0YXJ0VGltZSgpKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzTmV3ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5jdXJyZW50SUQoKTtcclxuICAgICAgICByZXR1cm4gaWQgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubmV3Qm9va2luZyB8fCBpZCA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdFdmVudDtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzQm9va2luZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0oKSAmJiB0aGlzLml0ZW0oKS5zb3VyY2VCb29raW5nKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgLyogUmV0dXJuIHRydWUgaWYgaXMgYW4gZXZlbnQgb2JqZWN0IGJ1dCBub3QgYSBib29raW5nICovXHJcbiAgICB0aGlzLmlzRXZlbnQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtKCkgJiYgdGhpcy5pdGVtKCkuc291cmNlRXZlbnQoKSAmJiAhdGhpcy5pdGVtKCkuc291cmNlQm9va2luZygpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaGVhZGVyQ2xhc3MgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0Jvb2tpbmcoKSA/ICh0aGlzLmVkaXRNb2RlKCkgPyAnQ2FyZC10aXRsZS0td2FybmluZycgOiAnQ2FyZC10aXRsZS0tcHJpbWFyeScpIDpcclxuICAgICAgICAgICAgdGhpcy5pc0V2ZW50KCkgPyAnQ2FyZC10aXRsZS0tZGFuZ2VyJyA6XHJcbiAgICAgICAgICAgICcnXHJcbiAgICAgICAgKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm5ld0FwcG9pbnRtZW50VmlzaWJsZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzLmN1cnJlbnRJRCgpO1xyXG4gICAgICAgIHJldHVybiBpZCA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy5mcmVlIHx8IGlkID09PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLmVtcHR5RGF0ZSB8fCBpZCA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy51bmF2YWlsYWJsZTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmVkaXRTY2hlZHVsZVZpc2libGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudElEKCkgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMudW5hdmFpbGFibGU7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5lZGl0ZWRWZXJzaW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxyXG4gICAgICAgICAgICAgICAgJ0xvYWRpbmcuLi4nIDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcclxuICAgICAgICAgICAgICAgICAgICAnU2F2aW5nIGNoYW5nZXMnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgdiAmJiB2LmFyZURpZmZlcmVudCgpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc05ldygpICYmIHRoaXMuaXNCb29raW5nKCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Jvb2snIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlIGNoYW5nZXMnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ1NhdmVkJ1xyXG4gICAgICAgICk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBJZiB0aGUgc291cmNlSXRlbSBjaGFuZ2VzLCBpcyBzZXQgYXMgdGhlIGl0ZW0gdmFsdWVcclxuICAgICAgICBkaXNjYXJkaW5nIGFueSBtb2RlbCB2ZXJzaW9uIGFuZCByZXZlcnRpbmdcclxuICAgICAgICBlZGl0TW9kZSB0byBmYWxzZVxyXG4gICAgKiovXHJcbiAgICB0aGlzLnNvdXJjZUl0ZW0uc3Vic2NyaWJlKGZ1bmN0aW9uKHNvdXJjZUl0ZW0pIHtcclxuICAgICAgICB0aGlzLml0ZW0oQXBwb2ludG1lbnRWaWV3KHNvdXJjZUl0ZW0sIGFwcCkpO1xyXG4gICAgICAgIHRoaXMuZWRpdGVkVmVyc2lvbihudWxsKTtcclxuICAgICAgICB0aGlzLmVkaXRNb2RlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIG5ldyBpdGVtIGlzIGEgbmV3IG9uZSwgc2V0IGVkaXQgbW9kZVxyXG4gICAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBFbnRlciBhbmQgZmluaXNoIGVkaXQ6XHJcbiAgICAgICAgQ3JlYXRlIHZlcnNpb24gYW5kIHNhdmUgZGF0YVxyXG4gICAgKiovXHJcbiAgICB0aGlzLmVkaXRNb2RlLnN1YnNjcmliZShmdW5jdGlvbihpc0VkaXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50SUQoKSA8PSAwICYmICF0aGlzLmlzTmV3KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNFZGl0KSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgc2V0IGEgdmVyc2lvbiB0byBiZSBlZGl0ZWRcclxuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBuZXcgTW9kZWxWZXJzaW9uKHRoaXMuc291cmNlSXRlbSgpKTtcclxuICAgICAgICAgICAgdmVyc2lvbi52ZXJzaW9uLnNvdXJjZUV2ZW50KHRoaXMuc291cmNlSXRlbSgpLnNvdXJjZUV2ZW50KCkpO1xyXG4gICAgICAgICAgICB2ZXJzaW9uLnZlcnNpb24uc291cmNlQm9va2luZyh0aGlzLnNvdXJjZUl0ZW0oKS5zb3VyY2VCb29raW5nKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRlZFZlcnNpb24odmVyc2lvbik7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbShBcHBvaW50bWVudFZpZXcodmVyc2lvbi52ZXJzaW9uLCBhcHApKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV3KCkgJiYgdGhpcy5pc0V2ZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgZGVmYXVsdHMgZm9yIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtKCkuc291cmNlRXZlbnQoKS5hdmFpbGFiaWxpdHlUeXBlSUQoMCk7IC8vIFVuYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW0oKS5pc0FsbERheShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW0oKS5zb3VyY2VFdmVudCgpLmV2ZW50VHlwZUlEKDMpOyAvLyBBcHBvaW50bWVudC9ibG9jay10aW1lXHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW0oKS5zdW1tYXJ5KCcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVtKEFwcG9pbnRtZW50Vmlldyh0aGlzLnNvdXJjZUl0ZW0oKSwgYXBwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5lZGl0ID0gZnVuY3Rpb24gZWRpdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIEEgc3Vic2NyaWJlZCBoYW5kbGVyIGVuc3VyZSB0byBkbyB0aGUgbmVlZGVkIHRhc2tzXHJcbiAgICAgICAgdGhpcy5lZGl0TW9kZSh0cnVlKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIFRoZXJlIGlzIGEgdmVyc2lvbj8gUHVzaCBjaGFuZ2VzIVxyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy5lZGl0ZWRWZXJzaW9uKCk7XHJcblxyXG4gICAgICAgIGlmICh2ZXJzaW9uICYmIHZlcnNpb24uYXJlRGlmZmVyZW50KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyh0cnVlKTtcclxuICAgICAgICAgICAgYXBwLm1vZGVsLmNhbGVuZGFyLnNldEFwcG9pbnRtZW50KHZlcnNpb24udmVyc2lvbiwgdGhpcy5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUoKSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2F2ZWRBcHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBkbyBhIHZlcnNpb24gcHVzaCwganVzdCB1cGRhdGUgd2l0aCByZW1vdGVcclxuICAgICAgICAgICAgICAgIC8vdmVyc2lvbi5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd2l0aCByZW1vdGUgZGF0YSwgdGhlIG9yaWdpbmFsIGFwcG9pbnRtZW50IGluIHRoZSB2ZXJzaW9uLFxyXG4gICAgICAgICAgICAgICAgLy8gbm90IHRoZSBjdXJyZW50QXBwb2ludG1lbnQgb3IgaW4gdGhlIGluZGV4IGluIHRoZSBsaXN0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyByYWNlLWNvbmRpdGlvbnNcclxuICAgICAgICAgICAgICAgIHZlcnNpb24ub3JpZ2luYWwubW9kZWwudXBkYXRlV2l0aChzYXZlZEFwdCk7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBhIHB1bGwgc28gb3JpZ2luYWwgYW5kIHZlcnNpb24gZ2V0cyB0aGUgZXhhY3Qgc2FtZSBkYXRhXHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHbyBvdXQgZWRpdCBtb2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRNb2RlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Jvb2tpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLml0ZW0oKS5jdXN0b21lcigpLmZpcnN0TmFtZSgpICsgJyB3aWxsIHJlY2VpdmUgYW4gZS1tYWlsIGNvbmZpcm1hdGlvbi4nO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd05vdGlmaWNhdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnQ29uZmlybWVkIScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZlcnNpb24gZGF0YSBrZWVwcyB1bnRvdWNoZWQsIHVzZXIgbWF5IHdhbnQgdG8gcmV0cnlcclxuICAgICAgICAgICAgICAgIC8vIG9yIG1hZGUgY2hhbmdlcyBvbiBpdHMgdW4tc2F2ZWQgZGF0YS5cclxuICAgICAgICAgICAgICAgIC8vIFNob3cgZXJyb3JcclxuICAgICAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciBzYXZpbmcgdGhlIGRhdGEuJyxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IHJlcGxpY2F0ZSBlcnJvciwgYWxsb3cgYWx3YXlzXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQUxXQVlTOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWRpdGVkVmVyc2lvbigpKSB7XHJcbiAgICAgICAgICAgIC8vIERpc2NhcmQgcHJldmlvdXMgdmVyc2lvblxyXG4gICAgICAgICAgICB0aGlzLmVkaXRlZFZlcnNpb24oKS5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE91dCBvZiBlZGl0IG1vZGVcclxuICAgICAgICB0aGlzLmVkaXRNb2RlKGZhbHNlKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBFeHRlcm5hbCBhY3Rpb25zXHJcbiAgICAqKi9cclxuICAgIHZhciBlZGl0RmllbGRPbiA9IGZ1bmN0aW9uIGVkaXRGaWVsZE9uKGFjdGl2aXR5LCBkYXRhKSB7XHJcblxyXG4gICAgICAgIC8vIEluY2x1ZGUgYXBwb2ludG1lbnQgdG8gcmVjb3ZlciBzdGF0ZSBvbiByZXR1cm46XHJcbiAgICAgICAgZGF0YS5hcHBvaW50bWVudCA9IHRoaXMuaXRlbSgpLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZGF0YS5jYW5jZWxMaW5rID0gdGhpcy5jYW5jZWxMaW5rO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLnByb2dyZXNzICYmXHJcbiAgICAgICAgICAgICF0aGlzLnByb2dyZXNzLmVuZGVkKSB7XHJcbiAgICAgICAgICAgIGRhdGEucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xyXG4gICAgICAgICAgICB2YXIgc3RlcCA9IGRhdGEucHJvZ3Jlc3Muc3RlcCB8fCAxLFxyXG4gICAgICAgICAgICAgICAgdG90YWwgPSBkYXRhLnByb2dyZXNzLnRvdGFsIHx8IDE7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gSTE4TlxyXG4gICAgICAgICAgICBkYXRhLnRpdGxlID0gc3RlcCArICcgb2YgJyArIHRvdGFsO1xyXG4gICAgICAgICAgICBkYXRhLm5hdlRpdGxlID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBrZWVwIGRhdGEucHJvZ3Jlc3Mgc28gaXQgZG9lcyBub3QgcmVzdGFydCB0aGUgcHJvY2VzcyBhZnRlclxyXG4gICAgICAgICAgICAvLyBhbiBlZGl0aW9uLiBUaGUgcGFzc0luIGFscmVhZHkgcmVzZXRzIHRoYXQgb24gbmV3IGNhbGxzXHJcbiAgICAgICAgICAgIGRhdGEucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xyXG4gICAgICAgICAgICAvLyBFZGl0aW9uIHRpdGxlOlxyXG4gICAgICAgICAgICBkYXRhLnRpdGxlID0gbnVsbDtcclxuICAgICAgICAgICAgZGF0YS5uYXZUaXRsZSA9IHRoaXMuaXNCb29raW5nKCkgPyAnQm9va2luZycgOiAnRXZlbnQnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXBwLnNoZWxsLmdvKGFjdGl2aXR5LCBkYXRhKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnBpY2tEYXRlVGltZSA9IGZ1bmN0aW9uIHBpY2tEYXRlVGltZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XHJcblxyXG4gICAgICAgIGVkaXRGaWVsZE9uKCdkYXRldGltZVBpY2tlcicsIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWREYXRldGltZTogdGhpcy5pdGVtKCkuc3RhcnRUaW1lKCksXHJcbiAgICAgICAgICAgIGRhdGV0aW1lRmllbGQ6ICdzdGFydFRpbWUnLFxyXG4gICAgICAgICAgICBoZWFkZXJUZXh0OiAnU2VsZWN0IHRoZSBzdGFydCB0aW1lJyxcclxuICAgICAgICAgICAgcmVxdWlyZWREdXJhdGlvbjogdGhpcy5pdGVtKCkuZ2V0U2VydmljZUR1cmF0aW9uTWludXRlcygpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5waWNrRW5kRGF0ZVRpbWUgPSBmdW5jdGlvbiBwaWNrRW5kRGF0ZVRpbWUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBlZGl0RmllbGRPbignZGF0ZXRpbWVQaWNrZXInLCB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXRpbWU6IHRoaXMuaXRlbSgpLmVuZFRpbWUoKSxcclxuICAgICAgICAgICAgZGF0ZXRpbWVGaWVsZDogJ2VuZFRpbWUnLFxyXG4gICAgICAgICAgICBoZWFkZXJUZXh0OiAnU2VsZWN0IHRoZSBlbmQgdGltZSdcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnBpY2tDbGllbnQgPSBmdW5jdGlvbiBwaWNrQ2xpZW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgZWRpdEZpZWxkT24oJ2NsaWVudHMnLCB7XHJcbiAgICAgICAgICAgIHNlbGVjdENsaWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRDbGllbnRJRDogdGhpcy5pdGVtKCkuc291cmNlQm9va2luZygpLmJvb2tpbmdSZXF1ZXN0KCkuY3VzdG9tZXJVc2VySUQoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucGlja1NlcnZpY2UgPSBmdW5jdGlvbiBwaWNrU2VydmljZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XHJcblxyXG4gICAgICAgIGVkaXRGaWVsZE9uKCdmcmVlbGFuY2VyUHJpY2luZy8nICsgdGhpcy5pdGVtKCkuam9iVGl0bGVJRCgpLCB7XHJcbiAgICAgICAgICAgIHNlbGVjdFByaWNpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkUHJpY2luZzogdGhpcy5pdGVtKCkucHJpY2luZygpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocHJpY2luZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmVlbGFuY2VyUHJpY2luZ0lEOiBrby51bndyYXAocHJpY2luZy5mcmVlbGFuY2VyUHJpY2luZ0lEKSxcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbFByaWNlOiBrby51bndyYXAocHJpY2luZy50b3RhbFByaWNlKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmNoYW5nZVByaWNlID0gZnVuY3Rpb24gY2hhbmdlUHJpY2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkgcmV0dXJuO1xyXG4gICAgICAgIC8vIFRPRE9cclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnBpY2tMb2NhdGlvbiA9IGZ1bmN0aW9uIHBpY2tMb2NhdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XHJcblxyXG4gICAgICAgIGVkaXRGaWVsZE9uKCdzZXJ2aWNlQWRkcmVzc2VzLycgKyB0aGlzLml0ZW0oKS5qb2JUaXRsZUlEKCksIHtcclxuICAgICAgICAgICAgc2VsZWN0QWRkcmVzczogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzSUQ6IHRoaXMuaXRlbSgpLmFkZHJlc3NJRCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdmFyIHRleHRGaWVsZHNIZWFkZXJzID0ge1xyXG4gICAgICAgIHByZU5vdGVzVG9DbGllbnQ6ICdOb3RlcyB0byBjbGllbnQnLFxyXG4gICAgICAgIHBvc3ROb3Rlc1RvQ2xpZW50OiAnTm90ZXMgdG8gY2xpZW50IChhZnRlcndhcmRzKScsXHJcbiAgICAgICAgcHJlTm90ZXNUb1NlbGY6ICdOb3RlcyB0byBzZWxmJyxcclxuICAgICAgICBwb3N0Tm90ZXNUb1NlbGY6ICdCb29raW5nIHN1bW1hcnknLFxyXG4gICAgICAgIHN1bW1hcnk6ICdXaGF0PydcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5lZGl0VGV4dEZpZWxkID0gZnVuY3Rpb24gZWRpdFRleHRGaWVsZChmaWVsZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgZWRpdEZpZWxkT24oJ3RleHRFZGl0b3InLCB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Q6ICd0ZXh0RWRpdG9yJyxcclxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxyXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5pc05ldygpID8gJ05ldyBib29raW5nJyA6ICdCb29raW5nJyxcclxuICAgICAgICAgICAgaGVhZGVyOiB0ZXh0RmllbGRzSGVhZGVyc1tmaWVsZF0sXHJcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuaXRlbSgpW2ZpZWxkXSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIC8vIHBhc3MgdGhpcyByZWFkeSBtb2RlbCB2aWV3IGFzIGFuIEFQSSB0byB0aGUgb3V0c2lkZVxyXG4gICAgaWYgKHR5cGVvZihwYXJhbXMuYXBpKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHBhcmFtcy5hcGkodGhpcyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZW5kVGltZSBnaXZlbiBhbiBhcHBvaW50bWVudCBkdXJhdGlvbiwgcmV0cmlldmVkXHJcbiAgICAvLyBmcm9tIHRoZSBzZWxlY3RlZCBzZXJ2aWNlXHJcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbiBjYWxjdWxhdGVFbmRUaW1lKCkge1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuaXRlbSgpLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgc3RhcnQgPSBtb21lbnQodGhpcy5pdGVtKCkuc3RhcnRUaW1lKCkpLFxyXG4gICAgICAgICAgICBlbmQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzQm9va2luZygpICYmXHJcbiAgICAgICAgICAgIHN0YXJ0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5hZGQoZHVyYXRpb24sICdtaW51dGVzJykudG9EYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbSgpLmVuZFRpbWUoZW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aGlzKVxyXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiAyMCB9IH0pO1xyXG59XHJcblxyXG4vKipcclxuICAgIEl0IG1hbmFnZXMgaW5jb21pbmcgZGF0YSBwcm92aWRlZCBieSBleHRlcm5hbCBhY3Rpdml0aWVzIGdpdmVuXHJcbiAgICB0aGUgcmVxdWVzdERhdGEgcmVjZWl2ZWQgYnkgdGhlIGFjdGl2aXR5IGhvc3RpbmcgdGhpcyB2aWV3IGluc3RhbmNlLlxyXG4gICAgVXNlZCB0byBtYW5hZ2UgdGhlIGRhdGEgcmV0dXJuZWQgYnkgY2FsbHMgdG8gZWRpdCBkYXRhIGluXHJcbiAgICBleHRlcm5hbCBhY3Rpdml0aWVzLlxyXG4qKi9cclxuQXBwb2ludG1lbnRDYXJkVmlld01vZGVsLnByb3RvdHlwZS5wYXNzSW4gPSBmdW5jdGlvbiBwYXNzSW4ocmVxdWVzdERhdGEpIHtcclxuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6MjAsbWF4c3RhdGVtZW50czo0MCAqL1xyXG4gICAgXHJcbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBpbmNsdWRlcyBhbiBhcHBvaW50bWVudCBwbGFpbiBvYmplY3QsIHRoYXQncyBhblxyXG4gICAgLy8gaW4tZWRpdGluZyBhcHBvaW50bWVudCBzbyBwdXQgaXQgaW4gcGxhY2UgKHRvIHJlc3RvcmUgYSBwcmV2aW91cyBlZGl0aW9uKVxyXG4gICAgaWYgKHJlcXVlc3REYXRhLmFwcG9pbnRtZW50KSB7XHJcbiAgICAgICAgLy8gU2V0IHRoZSBlZGl0IG1vZGUgKGl0IHBlcmZvcm1zIGFueSByZXF1aXJlZFxyXG4gICAgICAgIC8vIHNldC11cCBpZiB3ZSBhcmUgbm90IHN0aWxsIGluIGVkaXQgbW9kZSkuXHJcbiAgICAgICAgdGhpcy5lZGl0TW9kZSh0cnVlKTtcclxuICAgICAgICAvLyBTZXRzIHRoZSBkYXRhXHJcbiAgICAgICAgdGhpcy5pdGVtKClcclxuICAgICAgICAubW9kZWwudXBkYXRlV2l0aChyZXF1ZXN0RGF0YS5hcHBvaW50bWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghdGhpcy5pc05ldygpKSB7XHJcbiAgICAgICAgLy8gT24gYW55IG90aGVyIGNhc2UsIGFuZCB0byBwcmV2ZW50IGEgYmFkIGVkaXRNb2RlIHN0YXRlLFxyXG4gICAgICAgIC8vIHNldCBvZmYgZWRpdCBtb2RlIGRpc2NhcmRpbmcgdW5zYXZlZCBkYXRhOlxyXG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIE1hbmFnZSBzcGVjaWZpYyBzaW5nbGUgZGF0YSBmcm9tIGV4dGVybmFsbHkgcHJvdmlkZWRcclxuICAgIFxyXG4gICAgLy8gSXQgY29tZXMgYmFjayBmcm9tIHRoZSB0ZXh0RWRpdG9yLlxyXG4gICAgaWYgKHJlcXVlc3REYXRhLnJlcXVlc3QgPT09ICd0ZXh0RWRpdG9yJykge1xyXG4gICAgICAgIHRoaXMuaXRlbSgpW3JlcXVlc3REYXRhLmZpZWxkXShyZXF1ZXN0RGF0YS50ZXh0KTtcclxuICAgIH1cclxuICAgIGlmIChyZXF1ZXN0RGF0YS5zZWxlY3RDbGllbnQgPT09IHRydWUpIHtcclxuICAgICAgICB0aGlzLml0ZW0oKS5jdXN0b21lclVzZXJJRChyZXF1ZXN0RGF0YS5zZWxlY3RlZENsaWVudElEKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YocmVxdWVzdERhdGEuc2VsZWN0ZWREYXRldGltZSkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdmFyIGZpZWxkID0gcmVxdWVzdERhdGEuZGF0ZXRpbWVGaWVsZDtcclxuICAgICAgICB0aGlzLml0ZW0oKVtmaWVsZF0ocmVxdWVzdERhdGEuc2VsZWN0ZWREYXRldGltZSk7XHJcbiAgICAgICAgdGhpcy5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUocmVxdWVzdERhdGEuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKTtcclxuICAgIH1cclxuICAgIGlmIChyZXF1ZXN0RGF0YS5zZWxlY3RlZEpvYlRpdGxlSUQpIHtcclxuICAgICAgICB0aGlzLml0ZW0oKS5qb2JUaXRsZUlEKHJlcXVlc3REYXRhLnNlbGVjdGVkSm9iVGl0bGVJRCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdERhdGEuc2VsZWN0QWRkcmVzcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuaXRlbSgpLmFkZHJlc3NJRChyZXF1ZXN0RGF0YS5zZWxlY3RlZEFkZHJlc3NJRCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdERhdGEuc2VsZWN0UHJpY2luZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuaXRlbSgpLnByaWNpbmcoXHJcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLnNlbGVjdGVkUHJpY2luZy5tYXAoZnVuY3Rpb24ocHJpY2luZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmljaW5nRXN0aW1hdGVEZXRhaWwocHJpY2luZyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuaXNOZXcoKSkge1xyXG4gICAgICAgIGlmIChyZXF1ZXN0RGF0YSAmJiByZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTGluayA9IHJlcXVlc3REYXRhLmNhbmNlbExpbms7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2luZyB0aGUgUmVmZXJyZXIgVVJMIGFzIHRoZSBsaW5rIHdoZW4gY2FuY2VsbGluZyB0aGUgdGFza1xyXG4gICAgICAgICAgICB2YXIgcmVmZXJyZXJVcmwgPSB0aGlzLmFwcC5zaGVsbC5yZWZlcnJlclJvdXRlO1xyXG4gICAgICAgICAgICByZWZlcnJlclVybCA9IHJlZmVycmVyVXJsICYmIHJlZmVycmVyVXJsLnVybCB8fCAnY2FsZW5kYXInO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxMaW5rID0gcmVmZXJyZXJVcmw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNwZWNpYWwgYmVoYXZpb3IgZm9yIGFkZGluZyBhIGJvb2tpbmc6IGl0IHJlcXVpcmVzIGEgZ3VpZGVkIGNyZWF0aW9uXHJcbiAgICAvLyB0aHJvdWdoIGEgcHJvZ3Jlc3MgcGF0aFxyXG4gICAgaWYgKHRoaXMuY3VycmVudElEKCkgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubmV3Qm9va2luZykge1xyXG4gICAgICAgIGlmICghcmVxdWVzdERhdGEucHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgLy8gU3RhcnQhXHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwOiAxLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IDQsXHJcbiAgICAgICAgICAgICAgICBlbmRlZDogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gRmlyc3Qgc3RlcFxyXG4gICAgICAgICAgICB0aGlzLnBpY2tDbGllbnQoKTsgLy8uX2RlbGF5ZWQoNTApKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3REYXRhLnByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSByZXF1ZXN0RGF0YS5wcm9ncmVzcztcclxuICAgICAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnByb2dyZXNzLnN0ZXAgfHwgMTtcclxuICAgICAgICAgICAgaWYgKHN0ZXAgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZWNvbmQgc3RlcFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcy5zdGVwID0gMjtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja1NlcnZpY2UoKTsvLy5fZGVsYXllZCg1MCkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGVwIDwgMykge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhyaWQgc3RlcFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGEucHJvZ3Jlc3Muc3RlcCA9IDM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tEYXRlVGltZSgpOy8vLl9kZWxheWVkKDUwKSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ZXAgPCA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YS5wcm9ncmVzcy5zdGVwID0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja0xvY2F0aW9uKCk7Ly8uX2RlbGF5ZWQoNTApKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGVwcyBmaW5pc2hlZCwgbm90IGl0IGVudGVycyBpbiByZXZpc2lvbiBtb2RlIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgLy8gZmluYWxseSBzYXZlL2NyZWF0ZSB0aGUgYm9va2luZywgYnV0IHJlbW92ZSB0aGUgcHJvZ3Jlc3MgaW5mb1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgcHJvYmxlbXMgZWRpdGluZyBmaWVsZHMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzLmVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gUmVzZXQgcHJvZ3Jlc3NcclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFwcG9pbnRtZW50Q2FyZFZpZXdNb2RlbDtcclxuIiwiLyoqXHJcbiAgICBBcHBvaW50bWVudCBWaWV3IG1vZGVsIHRoYXQgd3JhcHMgYW4gQXBwb2ludG1lbnRcclxuICAgIG1vZGVsIGluc3RhbmNlIGV4dGVuZGVkIHdpdGggZXh0cmEgbWV0aG9kcyBjb25uZWN0ZWRcclxuICAgIHRvIHJlbGF0ZWQgZGF0YVxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQXBwb2ludG1lbnRWaWV3KGFwcG9pbnRtZW50LCBhcHApIHtcclxuICAgIGlmIChhcHBvaW50bWVudC5faXNBcHBvaW50bWVudFZpZXcpIHJldHVybiBhcHBvaW50bWVudDtcclxuICAgIGFwcG9pbnRtZW50Ll9pc0FwcG9pbnRtZW50VmlldyA9IHRydWU7XHJcblxyXG4gICAgYXBwb2ludG1lbnQuY3VzdG9tZXIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYiA9IHRoaXMuc291cmNlQm9va2luZygpO1xyXG4gICAgICAgIGlmICghYikgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNpZCA9IHRoaXMuY3VzdG9tZXJVc2VySUQoKTtcclxuICAgICAgICBpZiAoY2lkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwuY3VzdG9tZXJzLmdldE9ic2VydmFibGVJdGVtKGNpZCwgdHJ1ZSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LCBhcHBvaW50bWVudClcclxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJywgdGltZW91dDogMjAgfSB9KTtcclxuICAgIFxyXG4gICAgYXBwb2ludG1lbnQuYWRkcmVzcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhaWQgPSB0aGlzLmFkZHJlc3NJRCgpLFxyXG4gICAgICAgICAgICBqaWQgPSB0aGlzLmpvYlRpdGxlSUQoKTtcclxuICAgICAgICBpZiAoYWlkICYmIGppZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuZ2V0T2JzZXJ2YWJsZUl0ZW0oamlkLCBhaWQsIHRydWUpKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSwgYXBwb2ludG1lbnQpXHJcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XHJcblxyXG4gICAgYXBwb2ludG1lbnQuYWRkcmVzc1N1bW1hcnkgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZXZlbnREYXRhID0gdGhpcy5zb3VyY2VFdmVudCgpO1xyXG4gICAgICAgIHZhciBhZGQgPSB0aGlzLmFkZHJlc3MoKTtcclxuICAgICAgICByZXR1cm4gYWRkICYmIGFkZC5zaW5nbGVMaW5lKCkgfHwgZXZlbnREYXRhICYmIGV2ZW50RGF0YS5sb2NhdGlvbigpIHx8ICcnO1xyXG4gICAgfSwgYXBwb2ludG1lbnQpXHJcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XHJcbiAgICBcclxuICAgIC8qIFByb3BlcnR5IHdpdGggdGhlIHByaWNpbmcgYXJyYXkgcGx1cyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcclxuICAgICAgICBmcmVlbGFuY2VyUHJpY2luZy5cclxuICAgICovXHJcbiAgICBhcHBvaW50bWVudC5wcmljaW5nV2l0aEluZm8gPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYiA9IHRoaXMuc291cmNlQm9va2luZygpO1xyXG4gICAgICAgIGlmICghYikgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICB2YXIgamlkID0gdGhpcy5qb2JUaXRsZUlEKCksXHJcbiAgICAgICAgICAgIGRldGFpbHMgPSB0aGlzLnByaWNpbmcoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRldGFpbHMubWFwKGZ1bmN0aW9uKGRldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJpY2luZ0VzdGltYXRlRGV0YWlsVmlldyhkZXQsIGppZCwgYXBwKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIGFwcG9pbnRtZW50KVxyXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiA2MCB9IH0pO1xyXG5cclxuICAgIGFwcG9pbnRtZW50LnNlcnZpY2VzU3VtbWFyeSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByaWNpbmdXaXRoSW5mbygpXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbihzZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlLmZyZWVsYW5jZXJQcmljaW5nKCkubmFtZSgpO1xyXG4gICAgICAgIH0pLmpvaW4oJywgJyk7XHJcbiAgICB9LCBhcHBvaW50bWVudClcclxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJywgdGltZW91dDogMjAgfSB9KTtcclxuICAgIFxyXG4gICAgLy8gVE9ETyBSZXZpZXcgZm9yIGFueSBjaGFuZ2Ugb2YgY29tcHV0ZSB0aGUgZnVsbCBzZXJ2aWNlIGR1cmF0aW9uXHJcbiAgICAvLyBTZXJ2aWNlRHVyYXRpb24gYXMgZnVuY3Rpb24sIGJlY2F1c2UgaXMgbmVlZGVkIGZvciBjYXNlcyB3aGVuIGNhbm5vdCB3YWl0IGZvciB0aGUgXHJcbiAgICAvLyByYXRlZCBjb21wdXRlZFxyXG4gICAgYXBwb2ludG1lbnQuZ2V0U2VydmljZUR1cmF0aW9uTWludXRlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwcmljaW5nID0gdGhpcy5wcmljaW5nV2l0aEluZm8oKTtcclxuICAgICAgICB2YXIgc3VtID0gcHJpY2luZy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgc2VydmljZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldiArIHNlcnZpY2UuZnJlZWxhbmNlclByaWNpbmcoKS5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcbiAgICAvLyBTZXJ2aWNlRHVyYXRpb24gYXMgY29tcHV0ZWQgc28gY2FuIGJlIG9ic2VydmVkIGZvciBjaGFuZ2VzXHJcbiAgICBhcHBvaW50bWVudC5zZXJ2aWNlRHVyYXRpb25NaW51dGVzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VydmljZUR1cmF0aW9uTWludXRlcygpO1xyXG4gICAgfSwgYXBwb2ludG1lbnQpXHJcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XHJcbiAgICBcclxuICAgIC8vIFRPRE8gUmV2aWV3IGlmIGNhbGN1bGF0aW9uIG9mIGZlZXMgYW5kIHRoYXQgaXMgbmVlZGVkXHJcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcHJpY2luZyA9IGFwcG9pbnRtZW50LnByaWNpbmcoKTtcclxuICAgICAgICB0aGlzLnByaWNlKHByaWNpbmcucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldiArIGN1ci50b3RhbFByaWNlKCk7XHJcbiAgICAgICAgfSwgMCkpO1xyXG4gICAgfSwgYXBwb2ludG1lbnQpXHJcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XHJcblxyXG4gICAgcmV0dXJuIGFwcG9pbnRtZW50O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gUHJpY2luZ0VzdGltYXRlRGV0YWlsVmlldyhwcmljaW5nRXN0aW1hdGVEZXRhaWwsIGpvYlRpdGxlSUQsIGFwcCkge1xyXG5cclxuICAgIHByaWNpbmdFc3RpbWF0ZURldGFpbC5mcmVlbGFuY2VyUHJpY2luZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwaWQgPSB0aGlzLmZyZWVsYW5jZXJQcmljaW5nSUQoKTtcclxuICAgICAgICByZXR1cm4gYXBwLm1vZGVsLmZyZWVsYW5jZXJQcmljaW5nXHJcbiAgICAgICAgICAgIC5nZXRPYnNlcnZhYmxlSXRlbShqb2JUaXRsZUlELCBwaWQsIHRydWUpKCk7XHJcbiAgICB9LCBwcmljaW5nRXN0aW1hdGVEZXRhaWwpXHJcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XHJcblxyXG4gICAgcmV0dXJuIHByaWNpbmdFc3RpbWF0ZURldGFpbDtcclxufVxyXG4iLCIvKipcclxuICAgIFNpbXBsZSBWaWV3IE1vZGVsIHdpdGggbWFpbiBjcmVkZW50aWFscyBmb3JcclxuICAgIHVzZSBpbiBhIGZvcm0sIHdpdGggdmFsaWRhdGlvbi5cclxuICAgIFVzZWQgYnkgTG9naW4gYW5kIFNpZ251cCBhY3Rpdml0aWVzXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xyXG5cclxuZnVuY3Rpb24gRm9ybUNyZWRlbnRpYWxzKCkge1xyXG5cclxuICAgIHRoaXMudXNlcm5hbWUgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIHRoaXMucGFzc3dvcmQgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIFxyXG4gICAgLy8gdmFsaWRhdGUgdXNlcm5hbWUgYXMgYW4gZW1haWxcclxuICAgIHZhciBlbWFpbFJlZ2V4cCA9IC9eWy0wLTlBLVphLXohIyQlJicqKy89P15fYHt8fX4uXStAWy0wLTlBLVphLXohIyQlJicqKy89P15fYHt8fX4uXSskLztcclxuICAgIHRoaXMudXNlcm5hbWUuZXJyb3IgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuICAgIHRoaXMudXNlcm5hbWUuc3Vic2NyaWJlKGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICBpZiAoZW1haWxSZWdleHAudGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51c2VybmFtZS5lcnJvcignJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJuYW1lLmVycm9yKCdJcyBub3QgYSB2YWxpZCBlbWFpbCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVzZXJuYW1lLmVycm9yKCdSZXF1aXJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICBcclxuICAgIC8vIHJlcXVpcmVkIHBhc3N3b3JkXHJcbiAgICB0aGlzLnBhc3N3b3JkLmVycm9yID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcbiAgICB0aGlzLnBhc3N3b3JkLnN1YnNjcmliZShmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgdmFyIGVyciA9ICcnO1xyXG4gICAgICAgIGlmICghdilcclxuICAgICAgICAgICAgZXJyID0gJ1JlcXVpcmVkJztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnBhc3N3b3JkLmVycm9yKGVycik7XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1DcmVkZW50aWFscztcclxuIiwiLyoqIE5hdkFjdGlvbiB2aWV3IG1vZGVsLlxyXG4gICAgSXQgYWxsb3dzIHNldC11cCBwZXIgYWN0aXZpdHkgZm9yIHRoZSBBcHBOYXYgYWN0aW9uIGJ1dHRvbi5cclxuKiovXHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpO1xyXG5cclxuZnVuY3Rpb24gTmF2QWN0aW9uKHZhbHVlcykge1xyXG4gICAgXHJcbiAgICBNb2RlbCh0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcclxuICAgICAgICBsaW5rOiAnJyxcclxuICAgICAgICBpY29uOiAnJyxcclxuICAgICAgICB0ZXh0OiAnJyxcclxuICAgICAgICAvLyAnVGVzdCcgaXMgdGhlIGhlYWRlciB0aXRsZSBidXQgcGxhY2VkIGluIHRoZSBidXR0b24vYWN0aW9uXHJcbiAgICAgICAgaXNUaXRsZTogZmFsc2UsXHJcbiAgICAgICAgLy8gJ0xpbmsnIGlzIHRoZSBlbGVtZW50IElEIG9mIGEgbW9kYWwgKHN0YXJ0cyB3aXRoIGEgIylcclxuICAgICAgICBpc01vZGFsOiBmYWxzZSxcclxuICAgICAgICAvLyAnTGluaycgaXMgYSBTaGVsbCBjb21tYW5kLCBsaWtlICdnb0JhY2sgMidcclxuICAgICAgICBpc1NoZWxsOiBmYWxzZSxcclxuICAgICAgICAvLyBTZXQgaWYgdGhlIGVsZW1lbnQgaXMgYSBtZW51IGJ1dHRvbiwgaW4gdGhhdCBjYXNlICdsaW5rJ1xyXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIElEIG9mIHRoZSBtZW51IChjb250YWluZWQgaW4gdGhlIHBhZ2U7IHdpdGhvdXQgdGhlIGhhc2gpLCB1c2luZ1xyXG4gICAgICAgIC8vIHRoZSB0ZXh0IGFuZCBpY29uIGJ1dCBzcGVjaWFsIG1lYW5pbmcgZm9yIHRoZSB0ZXh0IHZhbHVlICdtZW51J1xyXG4gICAgICAgIC8vIG9uIGljb24gcHJvcGVydHkgdGhhdCB3aWxsIHVzZSB0aGUgc3RhbmRhcmQgbWVudSBpY29uLlxyXG4gICAgICAgIGlzTWVudTogZmFsc2UsXHJcbiAgICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIGFzIGV2ZW50IGhhbmRsZXIgZm9yIGJ1dHRvbiBjbGljay5cclxuICAgICAgICAvLyBUaGUgc3RhbmRhcmQgbGluayBnZXRzIGRpc2FibGVkIHdpdGggdGhpc1xyXG4gICAgICAgIGhhbmRsZXI6IG51bGxcclxuICAgIH0sIHZhbHVlcyk7XHJcbiAgICBcclxuICAgIHRoaXMucnVuSGFuZGxlciA9IGZ1bmN0aW9uIHJ1bkhhbmRsZXIob2JqLCBldmVudCkge1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyKCk7XHJcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmF2QWN0aW9uO1xyXG5cclxuLy8gU2V0IG9mIHZpZXcgdXRpbGl0aWVzIHRvIGdldCB0aGUgbGluayBmb3IgdGhlIGV4cGVjdGVkIGh0bWwgYXR0cmlidXRlc1xyXG5cclxuTmF2QWN0aW9uLnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gZ2V0SHJlZigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKHRoaXMuaGFuZGxlcigpIHx8IHRoaXMuaXNNZW51KCkgfHwgdGhpcy5pc01vZGFsKCkgfHwgdGhpcy5pc1NoZWxsKCkpID9cclxuICAgICAgICAnIycgOlxyXG4gICAgICAgIHRoaXMubGluaygpXHJcbiAgICApO1xyXG59O1xyXG5cclxuTmF2QWN0aW9uLnByb3RvdHlwZS5nZXRNb2RhbFRhcmdldCA9IGZ1bmN0aW9uIGdldE1vZGFsVGFyZ2V0KCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICAodGhpcy5oYW5kbGVyKCkgfHwgdGhpcy5pc01lbnUoKSB8fCAhdGhpcy5pc01vZGFsKCkgfHwgdGhpcy5pc1NoZWxsKCkpID9cclxuICAgICAgICAnJyA6XHJcbiAgICAgICAgdGhpcy5saW5rKClcclxuICAgICk7XHJcbn07XHJcblxyXG5OYXZBY3Rpb24ucHJvdG90eXBlLmdldFNoZWxsQ29tbWFuZCA9IGZ1bmN0aW9uIGdldFNoZWxsQ29tbWFuZCgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKHRoaXMuaGFuZGxlcigpIHx8IHRoaXMuaXNNZW51KCkgfHwgIXRoaXMuaXNTaGVsbCgpKSA/XHJcbiAgICAgICAgJycgOlxyXG4gICAgICAgIHRoaXMubGluaygpXHJcbiAgICApO1xyXG59O1xyXG5cclxuTmF2QWN0aW9uLnByb3RvdHlwZS5nZXRNZW51SUQgPSBmdW5jdGlvbiBnZXRNZW51SUQoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgICh0aGlzLmhhbmRsZXIoKSB8fCAhdGhpcy5pc01lbnUoKSkgP1xyXG4gICAgICAgICcnIDpcclxuICAgICAgICB0aGlzLmxpbmsoKVxyXG4gICAgKTtcclxufTtcclxuXHJcbk5hdkFjdGlvbi5wcm90b3R5cGUuZ2V0TWVudUxpbmsgPSBmdW5jdGlvbiBnZXRNZW51TGluaygpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgKHRoaXMuaGFuZGxlcigpIHx8ICF0aGlzLmlzTWVudSgpKSA/XHJcbiAgICAgICAgJycgOlxyXG4gICAgICAgICcjJyArIHRoaXMubGluaygpXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqIFN0YXRpYywgc2hhcmVkIGFjdGlvbnMgKiovXHJcbk5hdkFjdGlvbi5nb0hvbWUgPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICcvJyxcclxuICAgIGljb246ICdmYSBpb24gaW9uLXN0YXRzLWJhcnMnXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLmdvQmFjayA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJ2dvQmFjaycsXHJcbiAgICBpY29uOiAnZmEgaW9uIGlvbi1pb3MtYXJyb3ctbGVmdCcsXHJcbiAgICBpc1NoZWxsOiB0cnVlXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLm1lbnVJbiA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJ21lbnVJbicsXHJcbiAgICBpY29uOiAnbWVudScsXHJcbiAgICBpc01lbnU6IHRydWVcclxufSk7XHJcblxyXG5OYXZBY3Rpb24ubWVudU91dCA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJ21lbnVPdXQnLFxyXG4gICAgaWNvbjogJ21lbnUnLFxyXG4gICAgaXNNZW51OiB0cnVlXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLm1lbnVOZXdJdGVtID0gbmV3IE5hdkFjdGlvbih7XHJcbiAgICBsaW5rOiAnbWVudU5ld0l0ZW0nLFxyXG4gICAgaWNvbjogJ2ZhIGlvbiBpb24taW9zLXBsdXMtZW1wdHknLFxyXG4gICAgaXNNZW51OiB0cnVlXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLmdvSGVscEluZGV4ID0gbmV3IE5hdkFjdGlvbih7XHJcbiAgICBsaW5rOiAnI2hlbHBJbmRleCcsXHJcbiAgICB0ZXh0OiAnaGVscCcsXHJcbiAgICBpc01vZGFsOiB0cnVlXHJcbn0pO1xyXG5cclxuTmF2QWN0aW9uLmdvTG9naW4gPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICcvbG9naW4nLFxyXG4gICAgdGV4dDogJ2xvZy1pbidcclxufSk7XHJcblxyXG5OYXZBY3Rpb24uZ29Mb2dvdXQgPSBuZXcgTmF2QWN0aW9uKHtcclxuICAgIGxpbms6ICcvbG9nb3V0JyxcclxuICAgIHRleHQ6ICdsb2ctb3V0J1xyXG59KTtcclxuXHJcbk5hdkFjdGlvbi5nb1NpZ251cCA9IG5ldyBOYXZBY3Rpb24oe1xyXG4gICAgbGluazogJy9zaWdudXAnLFxyXG4gICAgdGV4dDogJ3NpZ24tdXAnXHJcbn0pO1xyXG4iLCIvKiogTmF2QmFyIHZpZXcgbW9kZWwuXHJcbiAgICBJdCBhbGxvd3MgY3VzdG9taXplIHRoZSBOYXZCYXIgcGVyIGFjdGl2aXR5LlxyXG4qKi9cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL01vZGVsJyk7XHJcbiAgICAvL05hdkFjdGlvbiA9IHJlcXVpcmUoJy4vTmF2QWN0aW9uJyk7XHJcblxyXG5mdW5jdGlvbiBOYXZCYXIodmFsdWVzKSB7XHJcbiAgICBcclxuICAgIE1vZGVsKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xyXG4gICAgICAgIC8vIFRpdGxlIHNob3dlZCBpbiB0aGUgY2VudGVyXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgdGl0bGUgaXMgJ251bGwnLCB0aGUgYXBwIGxvZ28gaXMgc2hvd2VkIGluIHBsYWNlLFxyXG4gICAgICAgIC8vIG9uIGVtcHR5IHRleHQsIHRoZSBlbXB0eSB0ZXh0IGlzIHNob3dlZCBhbmQgbm8gbG9nby5cclxuICAgICAgICB0aXRsZTogJycsXHJcbiAgICAgICAgLy8gTmF2QWN0aW9uIGluc3RhbmNlOlxyXG4gICAgICAgIGxlZnRBY3Rpb246IG51bGwsXHJcbiAgICAgICAgLy8gTmF2QWN0aW9uIGluc3RhbmNlOlxyXG4gICAgICAgIHJpZ2h0QWN0aW9uOiBudWxsXHJcbiAgICB9LCB2YWx1ZXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5hdkJhcjtcclxuIiwiLyoqIE9uYm9hcmRpbmdQcm9ncmVzcyB2aWV3IG1vZGVsLlxyXG4gICAgSXQgdHJhY2tzIHRoZSBvbmJvYXJkaW5nIGluZm9ybWF0aW9uIGFuZCBtZXRob2RzXHJcbiAgICB0byB1cGRhdGUgdmlld3MgdG8gdGhhdCBzdGF0ZVxyXG4qKi9cclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL01vZGVsJyksXHJcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XHJcblxyXG5mdW5jdGlvbiBPbmJvYXJkaW5nUHJvZ3Jlc3ModmFsdWVzKSB7XHJcblxyXG4gICAgTW9kZWwodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XHJcbiAgICAgICAgZ3JvdXA6ICcnLFxyXG4gICAgICAgIHN0ZXBOdW1iZXI6IC0xLFxyXG4gICAgICAgIHN0ZXBzOiBbXVxyXG4gICAgfSwgdmFsdWVzKTtcclxuICAgIFxyXG4gICAgdGhpcy50b3RhbFN0ZXBzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vICdaZXJvJyBzdGVwIGlzIGEgd2VsY29tZSwgbm90IGFjY291bnRlZDpcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcygpLmxlbmd0aCAtIDE7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIFxyXG4gICAgdGhpcy5zdGVwTmFtZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbnVtID0gdGhpcy5zdGVwTnVtYmVyKCksXHJcbiAgICAgICAgICAgIHRvdCA9IHRoaXMuc3RlcHMoKS5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICh0b3QgPiAwICYmXHJcbiAgICAgICAgICAgIG51bSA+IC0xICYmXHJcbiAgICAgICAgICAgIG51bSA8IHRvdCkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuc3RlcHMoKVtudW1dIHx8ICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLnN0ZXBVcmwgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuc3RlcE5hbWUoKTtcclxuICAgICAgICBpZiAodXJsICYmICEvXlxcLy8udGVzdCh1cmwpKVxyXG4gICAgICAgICAgICB1cmwgPSAnLycgKyB1cmw7XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc3RlcFJlZmVyZW5jZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cCgpICsgJzonICsgdGhpcy5zdGVwTmFtZSgpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMucHJvZ3Jlc3NUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIFRPRE8gTDE4TlxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBOdW1iZXIoKSArICcgb2YgJyArIHRoaXMudG90YWxTdGVwcygpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnN0ZXBVcmwoKTtcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9uYm9hcmRpbmdQcm9ncmVzcztcclxuXHJcbk9uYm9hcmRpbmdQcm9ncmVzcy5wcm90b3R5cGUuc2V0U3RlcEJ5TmFtZSA9IGZ1bmN0aW9uIHNldFN0ZXBCeU5hbWUobmFtZSkge1xyXG4gICAgdmFyIHN0ZXBJbmRleCA9IHRoaXMuc3RlcHMoKS5pbmRleE9mKG5hbWUpO1xyXG4gICAgaWYgKHN0ZXBJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy5zdGVwTnVtYmVyKHN0ZXBJbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICAgIFN0YXRpYyBsaXN0IG9mIGFsbCB0aGUgc3RlcHMgZ3JvdXBzIGZvciB0aGUgYXBwXHJcbioqL1xyXG5PbmJvYXJkaW5nUHJvZ3Jlc3MucHJlZGVmaW5lZFN0ZXBHcm91cHMgPSB7XHJcbiAgICAvLyBTY2hlZHVsaW5nIG9uYm9hcmRpbmcsIGFrYSB3ZWxjb21lXHJcbiAgICB3ZWxjb21lOiBbXHJcbiAgICAgICAgJ3dlbGNvbWUnLFxyXG4gICAgICAgICdhZGRKb2JUaXRsZXMnLFxyXG4gICAgICAgIC8vIGRpc2FibGVkIG9uIDIwMTUtMDYtMTYgYXMgb2YgIzU3NSBjb21tZW50c1xyXG4gICAgICAgIC8vJ2ZyZWVsYW5jZXJQcmljaW5nJyxcclxuICAgICAgICAvLydzZXJ2aWNlQWRkcmVzc2VzJyxcclxuICAgICAgICAnd2Vla2x5U2NoZWR1bGUnLFxyXG4gICAgICAgICdjb250YWN0SW5mbydcclxuICAgIF0sXHJcbiAgICBtYXJrZXRwbGFjZTogW1xyXG4gICAgXSxcclxuICAgIHBheW1lbnQ6IFtcclxuICAgIF1cclxufTtcclxuIiwiLyoqXHJcbiAgICBUaW1lU2xvdCB2aWV3IG1vZGVsIChha2E6IENhbGVuZGFyU2xvdCkgZm9yIHVzZVxyXG4gICAgYXMgcGFydCBvZiB0aGUgdGVtcGxhdGUvY29tcG9uZW50IHRpbWUtc2xvdC10aWxlIG9yIGFjdGl2aXRpZXNcclxuICAgIHByb3ZpZGluZyBkYXRhIGZvciB0aGUgdGVtcGxhdGUuXHJcbioqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZ2V0T2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldE9ic2VydmFibGUnKTtcclxuXHJcbmZ1bmN0aW9uIFRpbWVTbG90Vmlld01vZGVsKHBhcmFtcykge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo5Ki9cclxuXHJcbiAgICB0aGlzLnN0YXJ0VGltZSA9IGdldE9ic2VydmFibGUocGFyYW1zLnN0YXJ0VGltZSB8fCBudWxsKTtcclxuICAgIHRoaXMuZW5kVGltZSA9IGdldE9ic2VydmFibGUocGFyYW1zLmVuZFRpbWUgfHwgbnVsbCk7XHJcbiAgICB0aGlzLnN1YmplY3QgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5zdWJqZWN0IHx8IG51bGwpO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGdldE9ic2VydmFibGUocGFyYW1zLmRlc2NyaXB0aW9uIHx8IG51bGwpO1xyXG4gICAgdGhpcy5saW5rID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMubGluayB8fCBudWxsKTtcclxuICAgIHRoaXMuYWN0aW9uSWNvbiA9IGdldE9ic2VydmFibGUocGFyYW1zLmFjdGlvbkljb24gfHwgbnVsbCk7XHJcbiAgICB0aGlzLmFjdGlvblRleHQgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5hY3Rpb25UZXh0IHx8IG51bGwpO1xyXG4gICAgdGhpcy5jbGFzc05hbWVzID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuY2xhc3NOYW1lcyB8fCBudWxsKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaW1lU2xvdFZpZXdNb2RlbDtcclxuXHJcbnZhciBudW1lcmFsID0gcmVxdWlyZSgnbnVtZXJhbCcpLFxyXG4gICAgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKTtcclxuXHJcbi8qKlxyXG4gICAgU3RhdGljIGNvbnN0cnVjdG9yIHRvIGNvbnZlcnQgYW4gQXBwb2ludG1lbnQgbW9kZWwgaW50byBcclxuICAgIGEgVGltZVNsb3QgaW5zdGFuY2UgZm9sbG93aW5nIFVJIGNyaXRlcmlhIGZvciBwcmVzZXQgdmFsdWVzL3NldHVwLlxyXG4qKi9cclxuVGltZVNsb3RWaWV3TW9kZWwuZnJvbUFwcG9pbnRtZW50ID0gZnVuY3Rpb24gZnJvbUFwcG9pbnRtZW50KGFwdCkge1xyXG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxMCAqL1xyXG4gICAgXHJcbiAgICAvLyBDb21tZW50ZWQgdGhlIG9wdGlvbiB0byBkZXRlY3QgYW5kIG5vdCBsaW5rIHVuYXZhaWwgc2xvdHM6XHJcbiAgICAvL3ZhciB1bmF2YWlsID0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy51bmF2YWlsYWJsZSA9PT0gYXB0LmlkKCk7XHJcbiAgICAvL3ZhciBsaW5rID0gbnVsbDtcclxuICAgIC8vaWYgKCF1bmF2YWlsKVxyXG4gICAgdmFyIGxpbmsgPSAnIyFhcHBvaW50bWVudC8nICsgYXB0LnN0YXJ0VGltZSgpLnRvSVNPU3RyaW5nKCkgKyAnLycgKyBhcHQuaWQoKTtcclxuICAgIFxyXG4gICAgaWYgKGFwdC5pZCgpID09PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLnByZXBhcmF0aW9uVGltZSkge1xyXG4gICAgICAgIC8vIFNwZWNpYWwgbGluayBjYXNlOiBpdCBnb2VzIHRvIHNjaGVkdWxpbmcgcHJlZmVyZW5jZXMgdG8gYWxsb3cgcXVpY2sgZWRpdFxyXG4gICAgICAgIC8vIHRoZSBwcmVwYXJhdGlvbiB0aW1lIHNsb3RzXHJcbiAgICAgICAgbGluayA9ICcjIXNjaGVkdWxpbmdQcmVmZXJlbmNlcz9tdXN0UmV0dXJuPTEnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjbGFzc05hbWVzID0gbnVsbDtcclxuICAgIGlmIChBcHBvaW50bWVudC5zcGVjaWFsSWRzLmZyZWUgPT09IGFwdC5pZCgpKSB7XHJcbiAgICAgICAgY2xhc3NOYW1lcyA9ICdUaWxlLS10YWctZ3JheS1saWdodGVyICc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcHQuaWQoKSA+IDAgJiYgYXB0LnNvdXJjZUJvb2tpbmcoKSkge1xyXG4gICAgICAgIGlmIChhcHQuc291cmNlQm9va2luZygpLmNvbmZpcm1lZERhdGVJRCgpKVxyXG4gICAgICAgICAgICBjbGFzc05hbWVzID0gJ1RpbGUtLXRhZy1wcmltYXJ5ICcgO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgLy8gaXMgYSByZXF1ZXN0OlxyXG4gICAgICAgICAgICBjbGFzc05hbWVzID0gJ1RpbGUtLXRhZy13YXJuaW5nICc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2xhc3NOYW1lcyArPSAnSXRlbUFkZG9uVGlsZS0tbGFyZ2VyQ29udGVudCAnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gYW55IGJsb2NrIGV2ZW50LCBwcmVwYXJhdGlvbiB0aW1lIHNsb3RzXHJcbiAgICAgICAgY2xhc3NOYW1lcyA9ICdUaWxlLS10YWctZGFuZ2VyICc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUaW1lU2xvdFZpZXdNb2RlbCh7XHJcbiAgICAgICAgc3RhcnRUaW1lOiBhcHQuc3RhcnRUaW1lLFxyXG4gICAgICAgIGVuZFRpbWU6IGFwdC5lbmRUaW1lLFxyXG4gICAgICAgIHN1YmplY3Q6IGFwdC5zdW1tYXJ5LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBhcHQuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgbGluazogbGluayxcclxuICAgICAgICBhY3Rpb25JY29uOiAoYXB0LnNvdXJjZUJvb2tpbmcoKSA/IG51bGwgOiBhcHQuc291cmNlRXZlbnQoKSA/ICdmYSBpb24gaW9uLWlvcy1hcnJvdy1yaWdodCcgOiAhYXB0LmlkKCkgPyAnZmEgaW9uIGlvbi1wbHVzJyA6IG51bGwpLFxyXG4gICAgICAgIGFjdGlvblRleHQ6IChcclxuICAgICAgICAgICAgYXB0LnNvdXJjZUJvb2tpbmcoKSAmJiBcclxuICAgICAgICAgICAgYXB0LnNvdXJjZUJvb2tpbmcoKS5ib29raW5nUmVxdWVzdCgpICYmIFxyXG4gICAgICAgICAgICBhcHQuc291cmNlQm9va2luZygpLmJvb2tpbmdSZXF1ZXN0KCkucHJpY2luZ0VzdGltYXRlKCkgPyBcclxuICAgICAgICAgICAgbnVtZXJhbChhcHQuc291cmNlQm9va2luZygpLmJvb2tpbmdSZXF1ZXN0KCkucHJpY2luZ0VzdGltYXRlKCkudG90YWxQcmljZSgpIHx8IDApLmZvcm1hdCgnJDAuMDAnKSA6XHJcbiAgICAgICAgICAgIG51bGxcclxuICAgICAgICApLFxyXG4gICAgICAgIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXNcclxuICAgIH0pO1xyXG59O1xyXG4iLCIvKipcclxuICAgIFVzZXJKb2JQcm9maWxlVmlld01vZGVsOiBsb2FkcyBkYXRhIGFuZCBrZWVwIHN0YXRlXHJcbiAgICB0byBkaXNwbGF5IHRoZSBsaXN0aW5nIG9mIGpvYiB0aXRsZXMgZnJvbSB0aGUgXHJcbiAgICB1c2VyIGpvYiBwcm9maWxlLlxyXG4qKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcclxuXHJcbmZ1bmN0aW9uIFVzZXJKb2JQcm9maWxlVmlld01vZGVsKGFwcCkge1xyXG4gICAgXHJcbiAgICAvLyBMb2FkIGFuZCBzYXZlIGpvYiB0aXRsZSBpbmZvXHJcbiAgICB2YXIgam9iVGl0bGVzSW5kZXggPSB7fTtcclxuICAgIGZ1bmN0aW9uIHN5bmNKb2JUaXRsZShqb2JUaXRsZUlEKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRClcclxuICAgICAgICAudGhlbihmdW5jdGlvbihqb2JUaXRsZSkge1xyXG4gICAgICAgICAgICBqb2JUaXRsZXNJbmRleFtqb2JUaXRsZUlEXSA9IGpvYlRpdGxlO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogZXJyb3JzPyBub3QtZm91bmQgam9iIHRpdGxlP1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gQ3JlYXRlcyBhICdqb2JUaXRsZScgb2JzZXJ2YWJsZSBvbiB0aGUgdXNlckpvYlRpdGxlXHJcbiAgICAvLyBtb2RlbCB0byBoYXZlIGFjY2VzcyB0byBhIGNhY2hlZCBqb2JUaXRsZSBtb2RlbC5cclxuICAgIGZ1bmN0aW9uIGF0dGFjaEpvYlRpdGxlKHVzZXJKb2JUaXRsZSkge1xyXG4gICAgICAgIHVzZXJKb2JUaXRsZS5qb2JUaXRsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2JUaXRsZXNJbmRleFt0aGlzLmpvYlRpdGxlSUQoKV07XHJcbiAgICAgICAgfSwgdXNlckpvYlRpdGxlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy51c2VySm9iUHJvZmlsZSA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcbiAgICAvLyBVcGRhdGVkIHVzaW5nIHRoZSBsaXZlIGxpc3QsIGZvciBiYWNrZ3JvdW5kIHVwZGF0ZXNcclxuICAgIGFwcC5tb2RlbC51c2VySm9iUHJvZmlsZS5saXN0LnN1YnNjcmliZShmdW5jdGlvbihsaXN0KSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgam9iIHRpdGxlcyBpbmZvIGJlZm9yZSBlbmRcclxuICAgICAgICBQcm9taXNlLmFsbChsaXN0Lm1hcChmdW5jdGlvbih1c2VySm9iVGl0bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bmNKb2JUaXRsZSh1c2VySm9iVGl0bGUuam9iVGl0bGVJRCgpKTtcclxuICAgICAgICB9KSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGpvYlRpdGxlIHByb3BlcnR5IGJlZm9yZSB1cGRhdGVcclxuICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZSB3aXRoIHRoZSBwcm9maWxlXHJcbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaChhdHRhY2hKb2JUaXRsZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVzZXJKb2JQcm9maWxlKGxpc3QpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmlzU3luY2luZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGhlcmVJc0Vycm9yKGZhbHNlKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgLmNhdGNoKHNob3dMb2FkaW5nRXJyb3IpO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5pc0ZpcnN0VGltZSA9IGtvLm9ic2VydmFibGUodHJ1ZSk7XHJcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG4gICAgdGhpcy5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxuICAgIHRoaXMudGhlcmVJc0Vycm9yID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcbiAgICB0aGlzLmJhc2VVcmwgPSBrby5vYnNlcnZhYmxlKCcvam9idGl0bGVzJyk7XHJcbiAgICBcclxuICAgIHRoaXMuc2VsZWN0Sm9iVGl0bGUgPSBmdW5jdGlvbihqb2JUaXRsZSkge1xyXG4gICAgICAgIC8vIEdvbGxvdyB0aGUgbmV4dCBsaW5rOlxyXG4gICAgICAgIGFwcC5zaGVsbC5nbyh0aGlzLmJhc2VVcmwoKSArICcvJyArIGpvYlRpdGxlLmpvYlRpdGxlSUQoKSk7XHJcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgcmVwbGFjZWQgYnkgY3VzdG9tIGhhbmRsaW5nLlxyXG4gICAgICAgIC8vIFN0b3AgZXZlbnRzXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB2YXIgc2hvd0xvYWRpbmdFcnJvciA9IGZ1bmN0aW9uIHNob3dMb2FkaW5nRXJyb3IoZXJyKSB7XHJcbiAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xyXG4gICAgICAgICAgICB0aXRsZTogJ0FuIGVycm9yIGhhcHBlbmluZyB3aGVuIGxvYWRpbmcgeW91ciBqb2IgcHJvZmlsZS4nLFxyXG4gICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci5lcnJvciB8fCBlcnJcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5pc1N5bmNpbmcoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMudGhlcmVJc0Vycm9yKHRydWUpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIExvYWRpbmcgYW5kIHN5bmMgb2YgZGF0YVxyXG4gICAgdGhpcy5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcclxuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdGhpcy5pc0ZpcnN0VGltZSgpO1xyXG4gICAgICAgIHRoaXMuaXNGaXJzdFRpbWUoZmFsc2UpO1xyXG5cclxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcclxuICAgICAgICBhcHAubW9kZWwudXNlckpvYlByb2ZpbGUuc3luY0xpc3QoKVxyXG4gICAgICAgIC5jYXRjaChzaG93TG9hZGluZ0Vycm9yKTtcclxuXHJcbiAgICB9LmJpbmQodGhpcyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVXNlckpvYlByb2ZpbGVWaWV3TW9kZWw7XHJcbiJdfQ==
;