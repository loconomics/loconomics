(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./widget');
require('./position');
require('./menu');

/*!
 * jQuery UI Autocomplete 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/autocomplete/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 *	jquery.ui.menu.js
 */
(function( $, undefined ) {

$.widget( "ui.autocomplete", {
	version: "1.10.4",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	requestIndex: 0,
	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
			nodeName = this.element[0].nodeName.toLowerCase(),
			isTextarea = nodeName === "textarea",
			isInput = nodeName === "input";

		this.isMultiLine =
			// Textareas are always multi-line
			isTextarea ? true :
			// Inputs are always single-line, even if inside a contentEditable element
			// IE also treats inputs as contentEditable
			isInput ? false :
			// All other element types are determined by whether or not they're contentEditable
			this.element.prop( "isContentEditable" );

		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						this._value( this.term );
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
						event.preventDefault();
					}
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete ui-front" )
			.appendTo( this._appendTo() )
			.menu({
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.hide()
			.data( "ui-menu" );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				// support: Firefox
				// Prevent accidental activation of menu items in Firefox (#7024 #9118)
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				var item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				} else {
					// Normally the input is populated with the item's value as the
					// menu is navigated, causing screen readers to notice a change and
					// announce the item. Since the focus event was canceled, this doesn't
					// happen, so we update the live region so that screen readers can
					// still notice the change and announce it.
					this.liveRegion.text( item.value );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[0] !== this.document[0].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "polite"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.insertBefore( this.element );

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[0].body;
		}

		return element;
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {
			// only search if the value has changed
			if ( this.term !== this._value() ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var index = ++this.requestIndex;

		return $.proxy(function( content ) {
			if ( index === this.requestIndex ) {
				this.__response( content );
			}

			this.pending--;
			if ( !this.pending ) {
				this.element.removeClass( "ui-autocomplete-loading" );
			}
		}, this );
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element.empty();
		this._renderMenu( ul, items );
		this.isNewMenu = true;
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<a>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {
			this._value( this.term );
			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.text( message );
	}
});

}( jQuery ));

},{"./core":2,"./menu":3,"./position":4,"./widget":5}],2:[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

},{}],3:[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./widget');
require('./position');

/*!
 * jQuery UI Menu 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function( $, undefined ) {

$.widget( "ui.menu", {
	version: "1.10.4",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;
		// flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			})
			// need to catch all clicks on disabled menu
			// not possible through _on
			.bind( "click" + this.eventNamespace, $.proxy(function( event ) {
				if ( this.options.disabled ) {
					event.preventDefault();
				}
			}, this ));

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-state-disabled > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item:has(a)": function( event ) {
				var target = $( event.target ).closest( ".ui-menu-item" );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {

						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( !$( event.target ).closest( ".ui-menu" ).length ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.children( "a" )
				.removeUniqueId()
				.removeClass( "ui-corner-all ui-state-hover" )
				.removeAttr( "tabIndex" )
				.removeAttr( "role" )
				.removeAttr( "aria-haspopup" )
				.children().each( function() {
					var elem = $( this );
					if ( elem.data( "ui-menu-submenu-carat" ) ) {
						elem.remove();
					}
				});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		var match, prev, character, skip, regex,
			preventDefault = true;

		function escape( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			regex = new RegExp( "^" + escape( character ), "i" );
			match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
				return regex.test( $( this ).children( "a" ).text() );
			});
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
					return regex.test( $( this ).children( "a" ).text() );
				});
			}

			if ( match.length ) {
				this.focus( event, match );
				if ( match.length > 1 ) {
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );

		// Initialize nested menus
		submenus.filter( ":not(.ui-menu)" )
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.hide()
			.attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			})
			.each(function() {
				var menu = $( this ),
					item = menu.prev( "a" ),
					submenuCarat = $( "<span>" )
						.addClass( "ui-menu-icon ui-icon " + icon )
						.data( "ui-menu-submenu-carat", true );

				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCarat );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			});

		menus = submenus.add( this.element );

		// Don't refresh list items that are already adapted
		menus.children( ":not(.ui-menu-item):has(a)" )
			.addClass( "ui-menu-item" )
			.attr( "role", "presentation" )
			.children( "a" )
				.uniqueId()
				.addClass( "ui-corner-all" )
				.attr({
					tabIndex: -1,
					role: this._itemRole()
				});

		// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
		menus.children( ":not(.ui-menu-item)" ).each(function() {
			var item = $( this );
			// hyphen, em dash, en dash
			if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Add aria-disabled attribute to any disabled menu item
		menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.element.find( ".ui-menu-icon" )
				.removeClass( this.options.icons.submenu )
				.addClass( value.submenu );
		}
		this._super( key, value );
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.children( "a" ).addClass( "ui-state-focus" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.children( "a:first" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.height();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.children( "a" ).removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( "a.ui-state-active" )
				.removeClass( "ui-state-active" );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.children( ".ui-menu-item" )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	}
});

}( jQuery ));

},{"./core":2,"./position":4,"./widget":5}],4:[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Position 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );

},{}],5:[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

},{}],6:[function(require,module,exports){
/**
    Account activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function AccountActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = this.app.model.userProfile.data;
    this.navBar = Activity.createSectionNavBar('Account');
});

exports.init = A.init;

},{"../components/Activity":96}],7:[function(require,module,exports){
/**
    AddJobTitles activity
**/
'use strict';

var Activity = require('../components/Activity');
var $ = require('jquery');
//NOTE: IT DEPENDS on this, but jquery-ui touch events support requires special load order
// so thats being done in the entry point file
//require('jquery-ui/autocomplete');

var A = Activity.extends(function AddJobTitlesActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Scheduling');
    
    // Setup autocomplete
    var ac = this.$activity.find('#addJobTitles-search');
    var vw = this.viewModel;
    // Autocomplete positions and add to the list
    ac.autocomplete({
        source: function(request, response) {
            vw.searchBy(request.term)
            .then(function(results) {
                response(results);
            });
        },
        autoFocus: false,
        minLength: 0,
        select: function (event, ui) {
            // No value, no action :(
            if (!ui || !ui.item || !ui.item.value) return;

            vw.addItem(ui.item);

            return false;
        },
        focus: function (event, ui) {
            if (!ui || !ui.item || !ui.item.positionSingular);
            // We want the label in textbox, not the value
            $(this).val(ui.item.positionSingular);
            return false;
        }
    });
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var referrer = this.app.shell.referrerRoute;
    referrer = referrer && referrer.url || '/scheduling';
    var link = this.requestData.cancelLink || referrer;
    
    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {
        this.convertToCancelAction(this.navBar.leftAction(), link);
    }
};

A.prototype.show = function show(options) {

    Activity.prototype.show.call(this, options);
    
    // Reset
    this.viewModel.searchText('');
    this.viewModel.jobTitles.removeAll();
    
    this.updateNavBarState();
};

var ko = require('knockout');
function ViewModel(app) {
    
    this.isSearching = ko.observable(false);
    this.isSaving = ko.observable(false);
    this.isLocked = this.isSaving;
    this.searchText = ko.observable('');
    this.jobTitles = ko.observableArray([]);
    
    this.submitText = ko.pureComputed(function() {
        return (
            app.model.onboarding.inProgress() ?
                'Save and continue' :
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, this);
    
    this.unsavedChanges = ko.pureComputed(function() {
        return !!this.jobTitles().length;
    }, this);

    this.searchBy = function searchBy(text) {
        return app.model.rest.get('job-titles/autocomplete', { search: text })
        .catch(function (err) {
            app.modals.showError({ error: err });
        });
    }.bind(this);
    
    this.search = function search() {
        this.searchBy(this.searchText());
    }.bind(this);
    
    this.addItem = function addItem(item) {
        // Add to the list, if is not already in it
        var foundIndex = this.findItem(item);
        if (foundIndex === -1) {
            this.jobTitles.push(item);
        }
    }.bind(this);
    
    this.add = function add() {
        var s = this.searchText();
        if (s) {
            this.addItem({
                value: 0,
                label: s
            });
            this.searchText('');
        }
    }.bind(this);
    
    /**
        Look for an item in the current list, returning
        its index in the list or -1 if nothing.
    **/
    this.findItem = function findItem(jobTitle) {
        var foundIndex = -1;
        this.jobTitles().some(function(item, index) {
            if (jobTitle.value !== 0 &&
                item.value === jobTitle.value ||
                item.label === jobTitle.label) {
                foundIndex = index;
                return true;
            }
        });
        return foundIndex;
    };
    
    this.remove = function remove(jobTitle) {
        var removeIndex = this.findItem(jobTitle);
        if (removeIndex > -1) {
            this.jobTitles.splice(removeIndex, 1);
        }
    }.bind(this);
    
    this.save = function save() {
        this.isSaving(true);

        Promise.all(this.jobTitles().map(function(jobTitle) {
            return app.model.userJobProfile.createUserJobTitle({
                jobTitleID: jobTitle.value,
                jobTitleName: jobTitle.label
            });
        }))
        .then(function(/*results*/) {
            this.searchText('');
            this.isSaving(false);
            // Reset list
            this.jobTitles.removeAll();
            
            if (app.model.onboarding.inProgress()) {
                app.model.onboarding.goNext();
            }
            else {
                app.successSave();
            }
            
        }.bind(this))
        .catch(function(error) {
            this.searchText('');
            this.isSaving(false);
            app.modals.showError({
                title: 'Impossible to add one or more job titles',
                error: error
            });
        }.bind(this));
    }.bind(this);
}

},{"../components/Activity":96,"knockout":false}],8:[function(require,module,exports){
/**
    AddressEditor activity
    
    TODO: ModelVersion is NOT being used, so no getting updates if server updates
    the data after load (data load is requested but get first from cache). Use
    version and get sync'ed data when ready, and additionally notification to
    override changes if server data is different that any local change.

    TODO: The URL structure and how params are read is ready to allow
    edition of different kind of addresses, but actually only service addresses
    are fully supported, since 'home address' is edited in contactInfo and
    'billing addresses' are not used currently, but when needed, the support for this
    last will need to be completed. All the API calls right now are
    for model.serviceAdddresses for example.
**/
'use strict';
var ko = require('knockout'),
    Address = require('../models/Address'),
    Activity = require('../components/Activity');

var A = Activity.extends(function AddressEditorActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Locations');
    
    // Remote postal code look-up
    // NOTE: copied the code inside the postalCode computed handler in contactInfo.js with slight changes
    var app = this.app,
        viewModel = this.viewModel;
    this.registerHandler({
        target: this.viewModel.address,
        handler: function(address) {
            if (address &&
               !address.postalCode._hasLookup) {
                address.postalCode._hasLookup = true;
                
                // On change to a valid code, do remote look-up
                ko.computed(function() {
                    var postalCode = this.postalCode();
                    
                    if (postalCode && !/^\s*$/.test(postalCode)) {
                        app.model.postalCodes.getItem(postalCode)
                        .then(function(info) {
                            if (info) {
                                address.city(info.city);
                                address.stateProvinceCode(info.stateProvinceCode);
                                address.stateProvinceName(info.stateProvinceName);
                                viewModel.errorMessages.postalCode('');
                            }
                        })
                        .catch(function(err) {
                            address.city('');
                            address.stateProvinceCode('');
                            address.stateProvinceName('');
                            // Expected errors, a single message, set
                            // on the observable
                            var msg = typeof(err) === 'string' ? err : null;
                            if (msg || err && err.responseJSON && err.responseJSON.errorMessage) {
                                viewModel.errorMessages.postalCode(msg || err.responseJSON.errorMessage);
                            }
                            else {
                                // Log to console for debugging purposes, on regular use an error on the
                                // postal code is not critical and can be transparent; if there are 
                                // connectivity or authentification errors will throw on saving the address
                                console.error('Server error validating Zip Code', err);
                            }
                        });
                    }
                }, address)
                // Avoid excessive requests by setting a timeout since the latest change
                .extend({ rateLimit: { timeout: 200, method: 'notifyWhenChangesStop' } });
            }
        }
    });
    
    // Special treatment of the save operation
    this.viewModel.onSave = function(addressID) {
        if (this.requestData.returnNewAsSelected === true) {
            // Go to previous activity that required
            // to select an address
            this.requestData.addressID = addressID;
            this.app.shell.goBack(this.requestData);
        }
        else {
            // Regular save
            this.app.successSave();
        }
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var link = this.requestData.cancelLink || '/serviceAddresses/' + this.viewModel.jobTitleID();
    
    this.convertToCancelAction(this.navBar.leftAction(), link);
};

A.prototype.show = function show(options) {
    //jshint maxcomplexity:10    
    Activity.prototype.show.call(this, options);
    
    // Reset
    this.viewModel.wasRemoved(false);
    
    // Params    
    var params = options && options.route && options.route.segments || [];

    var kind = params[0] || '',
        isService = kind === Address.kind.service,
        jobTitleID = isService ? params[1] |0 : 0,
        addressID = isService ? params[2] |0 : params[1] |0,
        // Only used on service address creation, instead an ID we get
        // a string for 'serviceArea' or 'serviceLocation')
        serviceType = params[2] || '';
    
    this.viewModel.jobTitleID(jobTitleID);
    this.viewModel.addressID(addressID);
    
    this.updateNavBarState();

    if (addressID) {
        // Get the address
        this.app.model.serviceAddresses.getItemVersion(jobTitleID, addressID)
        .then(function (addressVersion) {
            if (addressVersion) {
                this.viewModel.addressVersion(addressVersion);
                this.viewModel.header('Edit Location');
            } else {
                this.viewModel.addressVersion(null);
                this.viewModel.header('Unknow location or was deleted');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            });
        }.bind(this));
    }
    else {
        // New address
        this.viewModel.addressVersion(this.app.model.serviceAddresses.newItemVersion({
            jobTitleID: jobTitleID
        }));

        switch (serviceType) {
            case 'serviceArea':
                this.viewModel.address().isServiceArea(true);
                this.viewModel.address().isServiceLocation(false);
                this.viewModel.header('Add a service area');
                break;
            case 'serviceLocation':
                this.viewModel.address().isServiceArea(false);
                this.viewModel.address().isServiceLocation(true);
                this.viewModel.header('Add a service location');
                break;
            default:
                this.viewModel.address().isServiceArea(true);
                this.viewModel.address().isServiceLocation(true);
                this.viewModel.header('Add a location');
                break;
        }
    }
};

function ViewModel(app) {

    this.header = ko.observable('Edit Location');
    
    // List of possible error messages registered
    // by name
    this.errorMessages = {
        postalCode: ko.observable('')
    };
    
    this.jobTitleID = ko.observable(0);
    this.addressID = ko.observable(0);
    
    this.addressVersion = ko.observable(null);
    this.address = ko.pureComputed(function() {
        var v = this.addressVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    this.isLoading = app.model.serviceAddresses.state.isLoading;
    this.isSaving = app.model.serviceAddresses.state.isSaving;
    this.isDeleting = app.model.serviceAddresses.state.isDeleting;

    this.wasRemoved = ko.observable(false);
    
    this.isLocked = ko.computed(function() {
        return this.isDeleting() || app.model.serviceAddresses.state.isLocked();
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        var add = this.address();
        return !add || !add.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.addressVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        'Save changes' :
                        'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.addressVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {

        app.model.serviceAddresses.setItem(this.address().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.address().model.updateWith(serverData);
            // Push version so it appears as saved
            this.addressVersion().push({ evenIfObsolete: true });
            
            // Special save, function provided by the activity on set-up
            this.onSave(serverData.addressID);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        app.modals.confirm({
            title: 'Delete location',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.serviceAddresses.delItem(this.jobTitleID(), this.addressID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    /**
        Typed value binding rather than html binding allow to avoid
        problems because the data in html are string values while
        the actual data from the model is a number.
        Cause problems on some edge cases matching values and with
        detection of changes in the data (because the binding coming from the
        control assigning a string to the value).
    **/
    this.serviceRadiusOptions = ko.observableArray([
        { value: 0.5, label: '0.5 miles' },
        { value: 1.0, label: '1 mile' },
        { value: 2.0, label: '2 miles' },
        { value: 3.0, label: '3 miles' },
        { value: 4.0, label: '4 miles' },
        { value: 5.0, label: '5 miles' },
        { value: 10, label: '10 miles' },
        { value: 25, label: '25 miles' },
        { value: 50, label: '50 miles' },
    ]);
}

},{"../components/Activity":96,"../models/Address":102,"knockout":false}],9:[function(require,module,exports){
/** Calendar activity **/
'use strict';

var $ = require('jquery'),
    moment = require('moment'),
    Appointment = require('../models/Appointment'),
    ko = require('knockout'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

require('../components/DatePicker');

var Activity = require('../components/Activity');

var A = Activity.extends(function AppointmentActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;    
    this.menuItem = 'calendar';
    
    this.$appointmentView = this.$activity.find('#calendarAppointmentView');
    this.$chooseNew = $('#calendarChooseNew');
    
    this.viewModel = new ViewModel(this.app);
    
    // Create default leftAction/backAction settings
    // later used to instantiate a new NavAction that will
    // dynamically change depending on viewModel data.
    var backActionSettings = {
        link: 'calendar/', // Preserve last slash, for later use
        icon: Activity.NavAction.goBack.icon(),
        isTitle: true,
        text: 'Calendar'
    };
    this.navBar = new Activity.NavBar({
        title: '',
        leftAction: new Activity.NavAction(backActionSettings),
        rightAction: Activity.NavAction.goHelpIndex
    });

    // NavBar must update depending on editMode state (to allow cancel and goBack)
    // and appointment date (on read-only, to go back to calendar on current date)
    ko.computed(function() {
        var editMode = this.viewModel.editMode(),
            isNew = this.viewModel.appointmentCardView() && this.viewModel.appointmentCardView().isNew(),
            date = this.viewModel.currentDate();

        if (editMode) {
            // Is cancel action
            
            if (isNew) {
                // Common way of keep a cancel button on navbar
                var cancelLink = this.viewModel.appointmentCardView();
                cancelLink = cancelLink && cancelLink.progress && cancelLink.progress.cancelLink;

                this.convertToCancelAction(this.navBar.leftAction(), cancelLink || this.requestData.cancelLink);
            }
            else {
                // Use the viewmodel cancelation with confirm, so avoid redirects (and all
                // its problems, as redirects to the sub-edition pages -for example, datetimePicker)
                // and avoid reload, just change current state and keeps in read-only mode
                this.navBar.leftAction().model.updateWith({
                    link: null,
                    text: 'cancel',
                    handler: this.viewModel.appointmentCardView().confirmCancel.bind(this)
                });
            }
        }
        else {
            // Is go to calendar/date action
            var defLink = backActionSettings.link,
                defBackText = backActionSettings.text;
            
            var link = date ? defLink + date.toISOString() : defLink;
            var text = date ? moment(date).format('dddd [(]M/D[)]') : defBackText;
            
            this.navBar.leftAction().model.updateWith($.extend({}, backActionSettings, {
                link: link,
                text: text,
                handler: null
            }));
        }

    }, this);

    
    // On changing the current appointment:
    // - Update URL to match the appointment currently showed
    // - Attach handlers to ID and StartTime so we load data for the new
    //   date when it changes (ID changes on create a booking, StartTime on
    //   edition).
    this.registerHandler({
        target: this.viewModel.currentAppointment,
        handler: function (apt) {
            if (!apt)
                return;

            if ((apt.id() === Appointment.specialIds.newBooking ||
                apt.id() === Appointment.specialIds.newEvent) &&
                !apt.__idDateHandlersAttached) {
                apt.__idDateHandlersAttached = true;
                var prevID = apt.id();
                // With explicit subscribe and not a computed because we
                // must avoid the first time execution (creates an infinite loop)
                apt.id.subscribe(function relocateList() {
                    var id = apt.id();
    
                    if (prevID > 0 || id <= 0) return;
                    prevID = id;
                    this.viewModel.setCurrent(null, id)
                    .then(function() {
                        this.viewModel.updateUrl();
                    }.bind(this));
                }.bind(this));
            }
            
        }.bind(this)._delayed(10)
        // IMPORTANT: delayed REQUIRED to avoid triple loading (activity.show) on first load triggered by a click event.
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    /* jshint maxcomplexity:10 */
    Activity.prototype.show.call(this, options);
    
    // Prepare cancelLink, before any attempt of internal URL rewriting
    if (!this.requestData.cancelLink) {
        var referrer = this.app.shell.referrerRoute;
        referrer = referrer && referrer.url;
        // Avoid links to this same page at 'new booking' or 'new event' state
        // to prevent infinite loops
        //referrer && referrer.replace(/\/?appointment\//i, 'calendar/');
        var reg = /\/?appointment\/([^\/]*)\/((\-3)|(\-4))/i;
        if (referrer && reg.test(referrer)) {
            referrer.replace(reg, '/appointment/$1/');
        }
        
        this.requestData.cancelLink = referrer;
    }
    
    var s1 = options && options.route && options.route.segments[0],
        s2 = options && options.route && options.route.segments[1],
        s3 = options && options.route && options.route.segments[2],
        date,
        datetime,
        id,
        type;

    var isNumber = /^\-?\d+$/;
    if (isNumber.test(s1)) {
        // first parameter is an ID
        id = s1 |0;
        type = s2;
    }
    else {
        date = getDateWithoutTime(s1);
        datetime = s1 && new Date(s1) || date;
        id = s2 |0;
        type = s3;
    }
    
    var setupCard = function() {
        // The card component needs to be updated on load
        // with any option passed to the activity since the component
        // is able to to interact with other activities it has requested
        // (to request information edition)
        var cardApi = this.viewModel.appointmentCardView();
        if (cardApi) {
            // Preset the startTime to the one given by the requestData URL parameters
            // when not in an existent appointment, just because:
            // - On a new booking we can preset the date in the 'select date-time' step
            // - On a new event we can preset the date and time in the card
            // - On the other special cards, its allows to pass the datetime to the links
            //   for creation of a new booking/event.
            if (this.viewModel.appointmentCardView().currentID() <= 0) {
                this.viewModel.appointmentCardView().item().startTime(datetime);
            }

            cardApi.passIn(this.requestData);
        }
        else {
            // The first time may happen that the binding is not ready, no cardApi available
            // but we need it, attempt again in short so card is ready:
            setTimeout(setupCard, 80);
        }
    }.bind(this);

    this.viewModel.setCurrent(date, id, type)
    .then(setupCard);
};

var Appointment = require('../models/Appointment');

function findAppointmentInList(list, id) {
    var found = null,
        index = -1;
    list.some(function(apt, i) {
        if (apt.id() === id) {
            found = apt;
            index = i;
            return true;
        }
    });
    return {
        item: found,
        index: index
    };
}

var CalendarEvent = require('../models/CalendarEvent'),
    Booking = require('../models/Booking');

function ViewModel(app) {
    this.app = app;
    this.currentDate = ko.observable(new Date());
    this.currentID = ko.observable(0);
    this.currentIndex = ko.observable(0);
    this.editMode = ko.observable(false);
    this.isLoading = ko.observable(false);
    
    this.dateAvailability = ko.observable();
    this.appointments = ko.pureComputed(function() {
        var dateAvail = this.dateAvailability();
        return dateAvail && dateAvail.appointmentsList() || [];            
    }, this);
    
    // To access the component API we use next observable,
    // updated by the component with its view
    this.appointmentCardView = ko.observable(null);

    var loadingAppointment = new Appointment({
        id: Appointment.specialIds.loading,
        summary: 'Loading...'
    });
    var newEmptyDateAppointment = function newEmptyDateAppointment() {
        return new Appointment({
            id: Appointment.specialIds.emptyDate,
            summary: 'You have nothing scheduled',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newUnavailableAppointment = function newUnavailableAppointment() {
        return new Appointment({
            id: Appointment.specialIds.unavailable,
            summary: 'You`re unavailable all day',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newFreeAppointment = function newFreeAppointment() {
        return new Appointment({
            id: Appointment.specialIds.free,
            summary: 'Free',
            startTime: this.currentDate(),
            endTime: moment(this.currentDate()).add(1, 'days').toDate()
        });
    }.bind(this);
    var newEventAppointment = function newEventAppointment() {
        return new Appointment({
            id: Appointment.specialIds.newEvent,
            summary: 'New event...',
            sourceEvent: new CalendarEvent()
        });
    };
    var newBookingAppointment = function newBookingAppointment() {
        return new Appointment({
            id: Appointment.specialIds.newBooking,
            summary: 'New booking...',
            sourceEvent: new CalendarEvent(),
            sourceBooking: new Booking()
        });
    };
    
    this.currentAppointment = ko.observable(loadingAppointment);

    this.updateUrl = function updateUrl() {
        // Update URL to match the appointment ID and
        // track it state
        // Get ID from URL, to avoid do anything if the same.
        var apt = this.currentAppointment(),
            aptId = apt.id(),
            found = /appointment\/([^\/]+)\/(\-?\d+)/i.exec(window.location),
            urlId = found && found[2] |0,
            urlDate = found && found[1],
            curDateStr = getDateWithoutTime(apt.startTime()).toISOString();

        if (!found ||
            urlId !== aptId.toString() ||
            urlDate !== curDateStr) {
            
            var url = 'appointment/' + curDateStr + '/' + aptId;

            // If was an incomplete URL, just replace current state
            if (urlId === '')
                this.app.shell.replaceState(null, null, url);
            else
                this.app.shell.pushState(null, null, url);
        }
    };

    this.goPrevious = function goPrevious() {
        if (this.editMode()) return;

        var index = this.currentIndex() - 1;

        if (index < 0) {
            // Go previous date
            var m = moment(this.currentDate());
            if (!m.isValid()) {
                m = moment(new Date());
            }
            var prevDate = m.subtract(1, 'days').toDate();
            this.setCurrent(prevDate)
            .then(function() {
                this.updateUrl();
            }.bind(this));
        }
        else {
            // Go previous item in the list, by changing currentID
            index = index % this.appointments().length;
            var apt = this.appointments()[index];
            this.currentIndex(index);
            this.currentID(apt.id());
            this.currentAppointment(apt);
            this.updateUrl();
            // Complete load-double check: this.setCurrent(apt.startTime(), apt.id());
        }
    };

    this.goNext = function goNext() {
        if (this.editMode()) return;
        var index = this.currentIndex() + 1;

        if (index >= this.appointments().length) {
            // Go next date
            var m = moment(this.currentDate());
            if (!m.isValid()) {
                m = moment(new Date());
            }
            var nextDate = m.add(1, 'days').toDate();
            this.setCurrent(nextDate)
            .then(function() {
                this.updateUrl();
            }.bind(this));
        }
        else {
            // Go next item in the list, by changing currentID
            index = index % this.appointments().length;
            var apt = this.appointments()[index];
            this.currentIndex(index);
            this.currentID(apt.id());
            this.currentAppointment(apt);
            this.updateUrl();
            // Complete load-double check: this.setCurrent(apt.startTime(), apt.id());
        }
    };

    /**
        Changing the current viewed data by date and id
    **/

    this.getSpecialItem = function (id) {
        switch (id) {
            default:
            //case -1:
                return newEmptyDateAppointment();
            case Appointment.specialIds.free:
                return newFreeAppointment();
            case Appointment.specialIds.newEvent:
                return newEventAppointment();
            case Appointment.specialIds.newBooking:
                return newBookingAppointment();
            case Appointment.specialIds.loading:
                return loadingAppointment;
            case Appointment.specialIds.unavailable:
                return newUnavailableAppointment();
        }
    };
    this.setItemFromCurrentList = function (id) {
        /*jshint maxdepth:6,maxcomplexity:8*/
        var list = this.appointments(),
            index,
            item;

        // First, respect special IDs, except the 'no appts':
        if (id < -1) {
            item = this.getSpecialItem(id);
            index = -1;
        }
        else if (list.length === 0) {
            // No item ID, empty list:
            index = -1;
            // Show as empty or full-unavailable:
            if (this.dateAvailability().workDayMinutes() === 0)
                item = newUnavailableAppointment();
            else
                item = newEmptyDateAppointment();
        }
        else {
            // Start getting the first item in the list
            item = list[0];
            index = 0;
            
            // With any ID value
            if (id) {
                // Search the ID
                if (id > 0) {
                    // search item in cached list
                    var found = findAppointmentInList(list, id);

                    if (found.item) {
                        item = found.item;
                        index = found.index;
                    }
                    // Else, the first item will be used
                }
                else {
                    item = this.getSpecialItem(id);
                    index = -1;
                }
            }   
        }

        this.currentID(item.id());
        this.currentIndex(index);
        this.currentAppointment(item);
    };
    
    var _setCurrent = function setCurrent(date, id, type) {
        //jshint maxcomplexity:8
        // IMPORTANT: the date to use must be ever
        // a new object rather than the referenced one to
        // avoid some edge cases where the same object is mutated
        // and comparisions can fail. 
        // getDateWithoutTime ensure to create a new instance ever.
        date = date && getDateWithoutTime(date) || null;
        if (date)
            this.currentDate(date);
        
        if (!date) {
            if (id > 0) {
                // remote search for id
                this.isLoading(true);

                var notFound = function notFound() {
                    this.isLoading(false);
                    return _setCurrent(new Date());
                }.bind(this);

                var ids = {};
                if (type === 'booking')
                    ids.bookingID = id;
                else
                    ids.calendarEventID = id;
                
                return app.model.calendar.getAppointment(ids)
                .then(function (item) {
                    if (item) {
                        // Force a load for the item date.
                        var itDate = getDateWithoutTime(item.startTime());
                        this.isLoading(false);
                        return _setCurrent(itDate, item.id());
                    }
                    else {
                        return notFound();
                    }
                }.bind(this))
                .catch(notFound);
            }
            else if (id < 0) {
                // Special IDs
                return _setCurrent(new Date(), id);
            }
            else {
                // No date, no ID, load today
                return _setCurrent(new Date());
            }
        }
        else {
            this.isLoading(true);
            return app.model.calendar.getDateAvailability(date)
            .then(function (dateAvail) {
                this.isLoading(false);
                this.dateAvailability(dateAvail);
                this.setItemFromCurrentList(id);
            }.bind(this))
            .catch(function(err) {

                this.isLoading(false);

                var msg = 'Error loading calendar events.';
                app.modals.showError({
                    title: msg,
                    error: err && err.error || err
                });

            }.bind(this));
        }
    }.bind(this);

    var promiseSetCurrent = Promise.resolve();
    this.setCurrent = function setCurrent(date, id, type) {
        // NOTE: Do nothing if is already in loading process
        // TODO: review if is better to cancel current and continue or
        // just the current queue for when it's finish.
        // If set as 'allow concurrent'
        // the isLoading may be not enough to control the several loadings
        promiseSetCurrent = promiseSetCurrent.then(function() {
            return _setCurrent(date, id, type);
        });
        return promiseSetCurrent;
    };
}

},{"../components/Activity":96,"../components/DatePicker":97,"../models/Appointment":103,"../models/Booking":104,"../models/CalendarEvent":106,"../utils/getDateWithoutTime":175,"knockout":false,"moment":false}],10:[function(require,module,exports){
/**
    backgroundCheck activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function BackgroundCheckActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Marketplace Profile', {
        backLink: '/marketplaceProfile'
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
};

function ViewModel(/*app*/) {
    
    //this.isSyncing = app.model.backgroundCheck.state.isSyncing;
    this.isSyncing = ko.observable(false);
    this.isLoading = ko.observable(false);
    this.isSaving = ko.observable(false);
    
    this.list = ko.observableArray(testdata());
}


// IMPORTANT Background Check uses verification statuses
var Verification = function() {};
Verification.status = {
    confirmed: 1,
    pending: 2,
    revoked: 3,
    obsolete: 4
};

function testdata() {
    
    var verA = new BackgroundCheck({
            name: 'Database Search'
        }),
        verB = new BackgroundCheck({
            name: 'Basic Criminal'
        }),
        verC = new BackgroundCheck({
            name: 'Risk Adverse'
        }),
        verD = new BackgroundCheck({
            name: 'Healthcare Check'
        });

    return [
        new UserBackgroundCheck({
            statusID: Verification.status.confirmed,
            lastVerifiedDate: new Date(2015, 1, 12, 10, 23, 32),
            backgroundCheck: verA
        }),
        new UserBackgroundCheck({
            statusID: Verification.status.revoked,
            lastVerifiedDate: new Date(2015, 5, 20, 16, 4, 0),
            backgroundCheck: verB
        }),
        new UserBackgroundCheck({
            statusID: Verification.status.pending,
            lastVerifiedDate: new Date(2014, 11, 30, 19, 54, 4),
            backgroundCheck: verC
        }),
        new UserBackgroundCheck({
            statusID: Verification.status.obsolete,
            lastVerifiedDate: new Date(2014, 11, 30, 19, 54, 4),
            backgroundCheck: verD
        })
    ];
}


var Model = require('../models/Model');
// TODO Incomplete Model for UI mockup
function UserBackgroundCheck(values) {
    Model(this);
    
    this.model.defProperties({
        statusID: 0,
        lastVerifiedDate: null,
        backgroundCheck: {
            Model: BackgroundCheck
        }
    }, values);
    
    // Same as in UserVerifications
    this.statusText = ko.pureComputed(function() {
        // L18N
        var statusTextsenUS = {
            'verification.status.confirmed': 'Confirmed',
            'verification.status.pending': 'Pending',
            'verification.status.revoked': 'Revoked',
            'verification.status.obsolete': 'Obsolete'
        };
        var statusCode = enumGetName(this.statusID(), Verification.status);
        return statusTextsenUS['verification.status.' + statusCode];
    }, this);
    
    /**
        Check if verification has a given status by name
    **/
    this.isStatus = function (statusName) {
        var id = this.statusID();
        return Verification.status[statusName] === id;
    }.bind(this);
}
function BackgroundCheck(values) {
    Model(this);
    
    this.model.defProperties({
        name: ''
    }, values);
}

// Become shared util; it is on Verifications too:
function enumGetName(value, enumList) {
    var found = null;
    Object.keys(enumList).some(function(k) {
        if (enumList[k] === value) {
            found = k;
            return true;
        }
    });
    return found;
}
                               
},{"../components/Activity":96,"../models/Model":123,"knockout":false}],11:[function(require,module,exports){
/**
    BookMeButton activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout'),
    $ = require('jquery');

var A = Activity.extends(function BookMeButtonActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.serviceProfessional;

    this.navBar = Activity.createSubsectionNavBar('Scheduling');
    
    // Auto select text on textarea, for better 'copy'
    // NOTE: the 'select' must happen on click, no touch, not focus,
    // only 'click' is reliable and bug-free.
    this.registerHandler({
        target: this.$activity,
        event: 'click',
        selector: 'textarea',
        handler: function() {
            $(this).select();
        }
    });
    
    this.registerHandler({
        target: this.app.model.marketplaceProfile,
        event: 'error',
        handler: function(err) {
            if (err && err.task === 'save') return;
            var msg = 'Error loading data to build the Button.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
    
    var $code = this.$activity.find('textarea');
    this.viewModel.copyCode = function() {
        var errMsg;
        try {
            $code.select();
            if (!document.execCommand('copy')) {
                errMsg = 'Impossible to copy text.';
            }
        } catch(err) {
            errMsg = 'Impossible to copy text.';
        }
        if (errMsg) {
            this.app.modals.showError({ error: errMsg });
        }
    }.bind(this);
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.marketplaceProfile.sync();
    
    // Set the job title
    var jobID = state.route.segments[0] |0;
    this.viewModel.jobTitleID(jobID);
};

function ViewModel(app) {

    var marketplaceProfile = app.model.marketplaceProfile;
    
    // Actual data for the form:
    
    // Read-only bookCode
    this.bookCode = ko.computed(function() {
        return marketplaceProfile.data.bookCode();
    });
    
    this.jobTitleID = ko.observable(0);
    
    // Button type, can be: 'icon', 'link'
    this.type = ko.observable('icon');

    this.isLocked = marketplaceProfile.isLocked;
    
    // Generation of the button code
    
    var buttonTemplate =
        '<!-- begin Loconomics book-me-button -->' +
        '<a style="display:inline-block"><img alt="" style="border:none" width="200" height="50" /></a>' + 
        '<!-- end Loconomics book-me-button -->';
    
    var linkTemplate =
        '<!-- begin Loconomics book-me-button -->' +
        '<a><span></span></a>' +
        '<!-- end Loconomics book-me-button -->';

    this.buttonHtmlCode = ko.pureComputed(function() {
        
        if (marketplaceProfile.isLoading()) {
            return 'loading...';
        }
        else {
            var type = this.type(),
                tpl = buttonTemplate;

            if (type === 'link')
                tpl = linkTemplate;

            var siteUrl = $('html').attr('data-site-url'),
                linkUrl = siteUrl + '/book/' + this.bookCode() + '/' + this.jobTitleID() + '/',
                imgUrl = siteUrl + '/img/extern/book-me-now-button.svg';

            var code = generateButtonCode({
                tpl: tpl,
                label: 'Click here to book me now (on loconomics.com)',
                linkUrl: linkUrl,
                imgUrl: imgUrl
            });

            return code;
        }
    }, this);

    this.sendByEmailURL = ko.pureComputed(function() {
        return 'mailto:&body=' + encodeURIComponent('Loconomics Book Me Now Button HTML code: ' + this.buttonHtmlCode());
    }, this);
}

function generateButtonCode(options) {

    var $btn = $($.parseHTML('<div>' + options.tpl + '</div>'));

    $btn
    .find('a')
    .attr('href', options.linkUrl)
    .find('span')
    .text(options.label);
    $btn
    .find('img')
    .attr('src', options.imgUrl)
    .attr('alt', options.label);

    return $btn.html();
}

},{"../components/Activity":96,"knockout":false}],12:[function(require,module,exports){
/**
    Booking activity
    
    It allows a client to book a serviceProfessional
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout'),
    SignupVM = require('../viewmodels/Signup');

var A = Activity.extends(function BookingActivity() {

    Activity.apply(this, arguments);

    // Any, we provide login and signup options integrated here
    //this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Booking');
    
    // Only on change (not first time), when choosed the option 'custom'
    // from gratuity, focus the textbox to input the custom value
    this.viewModel.presetGratuity.subscribe(function(preset) {
        if (preset === 'custom') {
            // Small delay to allow the binding to display the custom field,
            // the UI to update, and then focus it; trying to do it without
            // timeout will do nothing.
            setTimeout(function() {
                this.$activity.find('[name=custom-gratuity]').focus();
            }.bind(this), 50);
        }
    }.bind(this));
    
    this.registerHandler({
        target: this.viewModel.progress.step,
        handler: function() {
            // Trigger load of the specific step
            var load = this[this.viewModel.progress.currentStep() + 'Load'];
            if (load)
                load.call(this);
        }.bind(this)
    });

});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    var params = state && state.route && state.route.segments;
    var bookCode = state && state.route && state.route.query.bookCode;

    this.viewModel.initBooking(params[0] |0, params[1] |0, bookCode);
};

// L18N
// List of all possible steps by name providing the language for the UI
var stepsLabels = {
    services: 'Services',
    selectLocation: 'Select a location',
    selectTimes: 'Select preferred times',
    selectTime: 'Select the time',
    payment: 'Payment',
    confirm: 'Confirm'
};

///
/// Methods that initialize/load each step, given the name of registered steps
/// and sufix 'Load'

A.prototype.servicesLoad = function() {
    // TODO Depends on jobTitle:
    this.viewModel.supportsGratuity(true);    
};

A.prototype.selectLocationLoad = function() {
    // Load remote addresses for provider and jobtitle, reset first
    this.viewModel.serviceAddresses.sourceAddresses([]);
    this.viewModel.isLoadingServiceAddresses(true);
    this.app.model.users.getServiceAddresses(this.viewModel.booking.serviceProfessionalUserID(), this.viewModel.booking.jobTitleID())
    .then(function(list) {
        list = this.app.model.serviceAddresses.asModel(list);
        this.viewModel.serviceAddresses.sourceAddresses(list);
        this.viewModel.isLoadingServiceAddresses(false);
        // TODO: Load user personal addresses too if the service professional has serviceRadius
    }.bind(this))
    .catch(function(err) {
        this.viewModel.isLoadingServiceAddresses(false);
        this.app.modals.showError({ error: err });
    });
};

A.prototype.selectTimesLoad = function() {
    var picker = this.viewModel.serviceStartDatePickerView();
    this.viewModel.timeFieldToBeSelected('');
    picker.selectedDatetime(null);
    picker.userID(this.viewModel.booking.serviceProfessionalUserID());
    picker.selectedDate(new Date());
};

A.prototype.selectTimeLoad = function() {
    this.viewModel.timeFieldToBeSelected('serviceDate');
    var picker = this.viewModel.serviceStartDatePickerView();
    picker.selectedDatetime(null);
    picker.userID(this.viewModel.booking.serviceProfessionalUserID());
    picker.selectedDate(new Date());
};

A.prototype.paymentLoad = function() {
};

A.prototype.confirmLoad = function() {
};


var Model = require('../models/Model');
var numeral = require('numeral');

var PricingSummaryDetail = require('../models/PricingSummaryDetail'),
    PricingSummary = require('../models/PricingSummary');

var ServiceProfessionalServiceVM = require('../viewmodels/ServiceProfessionalService'),
    BookingProgress = require('../viewmodels/BookingProgress'),
    Booking = require('../models/Booking'),
    ServiceAddresses = require('../viewmodels/ServiceAddresses'),
    InputPaymentMethod = require('../models/InputPaymentMethod'),
    Address = require('../models/Address'),
    EventDates = require('../models/EventDates'),
    PublicUser = require('../models/PublicUser');

function ViewModel(app) {
    //jshint maxstatements:100
    
    ///
    /// Booking Data, request options and related entities
    this.booking = new Booking();
    this.newDataReady = ko.observable(false);
    this.summary = new PricingSummaryVM();
    this.bookCode = ko.observable(null);
    this.serviceProfessionalServices = new ServiceProfessionalServiceVM(app);
    this.serviceProfessionalServices.isSelectionMode(true);
    this.serviceProfessionalServices.preSelectedServices([]);
    this.makeRepeatBooking = ko.observable(false);
    this.promotionalCode = ko.observable('');
    this.paymentMethod = ko.observable(null); // InputPaymentMethod
    this.isAnonymous = ko.pureComputed(function() {
        var u = app.model.user();
        return u && u.isAnonymous();
    });
    
    this.confirmBtnText = ko.pureComputed(function() {
        return this.isAnonymous() ? 'Sign up and confirm' : 'Confirm';
    }, this);
    
    // Displayed text when there is a payment card
    this.paymentMethodDisplay = ko.pureComputed(function() {
        var n = this.booking.paymentLastFourCardNumberDigits();
        return n ? 'Card ending in ' + n : '';
    }, this);
    ko.computed(function() {
        var pm = this.paymentMethod(),
            number = pm && pm.cardNumber();
        if (number) {
            var last = number.slice(-4);
            this.booking.paymentLastFourCardNumberDigits(last);
        }
    }, this);
    
    ///
    /// Signup
    this.signupVM = new SignupVM(app);

    ///
    /// Address
    this.serviceAddresses = new ServiceAddresses();
    this.isLoadingServiceAddresses = ko.observable(false);
    this.serviceAddresses.selectedAddress.subscribe(this.booking.serviceAddress, this);

    ///
    /// Gratuity
    // TODO Complete support for gratuity, server-side
    this.supportsGratuity = ko.observable(false);
    this.customGratuity = ko.observable(0);
    this.presetGratuity = ko.observable(0);
    this.gratuityAmount = ko.observable(0);
    this.gratuityPercentage = ko.pureComputed(function() {
        var preset = this.presetGratuity();
        if (preset === 'custom')
            return 0;
        else
            return preset;
    }, this);
    
    // Sync: Automatic updates between dependent models:
    this.booking.jobTitleID.subscribe(this.serviceProfessionalServices.jobTitleID);
    this.booking.serviceProfessionalUserID.subscribe(this.serviceProfessionalServices.serviceProfessionalID);

    this.gratuityPercentage.subscribe(this.summary.gratuityPercentage);
    this.gratuityAmount.subscribe(this.summary.gratuityAmount);
    ko.computed(function() {
        var services = this.serviceProfessionalServices.selectedServices();
        this.summary.details(services.map(function(service) {
            return PricingSummaryDetail.fromServiceProfessionalService(service);
        }));
    }, this);
    
    // Fill booking services from the selected services view
    ko.computed(function() {
        this.booking.pricingSummary(this.summary.toPricingSummary());
    }, this)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    ///
    /// Service Professional Info
    this.serviceProfessionalInfo = ko.observable(new PublicUser());
    this.isLoadingServiceProfessionalInfo = ko.observable(false);
    this.booking.serviceProfessionalUserID.subscribe(function(userID) {
        if (!userID) {
            this.serviceProfessionalInfo().model.reset();
            return;
        }

        this.isLoadingServiceProfessionalInfo(true);

        app.model.users.getUser(userID)
        .then(function(info) {
            info.selectedJobTitleID = this.booking.jobTitleID();
            this.serviceProfessionalInfo().model.updateWith(info, true);
            this.isLoadingServiceProfessionalInfo(false);
        }.bind(this))
        .catch(function(err) {
            this.isLoadingServiceProfessionalInfo(false);
            app.modals.showError({ error: err });
        }.bind(this));
    }, this);
    
    ///
    /// Date time picker(s)
    this.serviceStartDatePickerView = ko.observable(null);
    this.timeFieldToBeSelected = ko.observable('');
    ko.computed(function triggerSelectedDatetime() {
        var v = this.serviceStartDatePickerView(),
            dt = v && v.selectedDatetime(),
            current = this.booking.serviceDate(),
            field = this.timeFieldToBeSelected.peek();

        if (dt && field &&
            dt.toString() !== (current && current.startTime().toString())) {
            this.booking[field](new EventDates({
                startTime: dt
            }));
            this.booking[field]().duration({
                minutes: this.summary.firstSessionDurationMinutes()
            });

            if (this.booking.instantBooking())
                this.progress.next();
            else
                this.timeFieldToBeSelected('');
        }
    }, this);
    this.summary.firstSessionDurationMinutes.subscribe(function(minutes) {
        if (this.serviceStartDatePickerView()) {
            this.serviceStartDatePickerView().requiredDurationMinutes(minutes);
        }
    }, this);
    
    this.pickServiceDate = function() {
        this.timeFieldToBeSelected('serviceDate');
    }.bind(this);
    this.pickAlternativeDate1 = function() {
        this.timeFieldToBeSelected('alternativeDate1');
    }.bind(this);
    this.pickAlternativeDate2 = function() {
        this.timeFieldToBeSelected('alternativeDate2');
    }.bind(this);
    
    ///
    /// Progress management
    // Se inicializa con un estado previo al primer paso
    // (necesario para el manejo de reset y preparacin del activity)
    this.progress = new BookingProgress({ step: -1 });
    
    this.nextStep = function() {
        this.progress.next();
    };
    
    this.goStep = function(stepName) {
        var i = this.progress.stepsList().indexOf(stepName);
        this.progress.step(i > -1 ? i : 0);
    };

    this.getStepLabel = function(stepName) {
        return stepsLabels[stepName] || stepName;
    };
    
    // Reused step observers
    this.isAtSelectTimes = this.progress.observeStep('selectTimes');
    this.isAtSelectTime = this.progress.observeStep('selectTime');
    
    ///
    /// Reset
    this.reset = function reset() {
        this.newDataReady(false);
        this.booking.model.reset();
        this.serviceProfessionalServices.preSelectedServices([]);
        this.customGratuity(0);
        this.presetGratuity(0);
        this.gratuityAmount(0);
        this.promotionalCode('');
        this.makeRepeatBooking(false);
        this.paymentMethod(null);
    }.bind(this);
    
    this.isPhoneServiceOnly = ko.pureComputed(function() {
        return this.serviceProfessionalServices.selectedServices().every(function(service) {
            return service.isPhone();
        });
    }, this).extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    ///
    /// Keeps the progress stepsList updated depending on the data
    ko.computed(function() {
        // Starting list, with fixed first steps:
        var list = ['services'];
        
        if (this.newDataReady()) {

            if (!this.isPhoneServiceOnly())
                list.push('selectLocation');

            list.push(this.booking.instantBooking() ? 'selectTime' : 'selectTimes');

            if (this.booking.paymentEnabled())
                list.push('payment');

            // The final fixed steps
            list.push('confirm');
        }
        // we need almost the first, for its load process to work, even if newData is not ready still

        this.progress.stepsList(list);
    }, this).extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });

    ///
    /// New Booking data
    this.isLoadingNewBooking = ko.observable(false);
    this.initBooking = function(serviceProfessionalID, jobTitleID, bookCode) {
        this.reset();
        this.bookCode(bookCode);
        
        this.isLoadingNewBooking(true);
        
        app.model.bookings.getNewClientBooking({
            serviceProfessionalUserID: serviceProfessionalID,
            jobTitleID: jobTitleID,
            bookCode: bookCode
        }).then(function(bookingData) {
            this.booking.model.updateWith(bookingData);
            if (this.booking.paymentEnabled()) {
                var ipm = new InputPaymentMethod();
                ipm.billingAddress(new Address());
                this.paymentMethod(ipm);
            }

            this.isLoadingNewBooking(false);
            this.newDataReady(true);
            
            // Reset progress to none and trigger next so Load logic gets executed
            this.progress.step(-1);
            this.nextStep();
        }.bind(this))
        .catch(function(err) {
            this.isLoadingNewBooking(false);
            app.modals.showError({ error: err });
        }.bind(this));
    }.bind(this);
    
    ///
    /// UI
    this.bookingHeader = ko.pureComputed(function() {
        var v = this.booking.instantBooking();
        return v === true ? 'Your instant booking' : v === false ? 'Your booking request' : '';
    }, this);

    ///
    /// States
    this.isLoading = ko.pureComputed(function() {
        return (
            this.isLoadingNewBooking() ||
            this.isLoadingServiceProfessionalInfo() ||
            this.serviceProfessionalServices.isLoading()
        );
    }, this);
    this.isSaving = ko.observable();
    this.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving();
    }, this);

    ///
    /// Save
    this.save = function() {
        // Final step, confirm and save booking
        this.isSaving(true);
        
        // Prepare tasks (callbacks)
        // save promise:
        var saveIt = function() {
            var requestOptions = {
                promotionalCode: this.promotionalCode(),
                bookCode: this.bookCode()
            };
            return app.model.bookings.requestClientBooking(this.booking, requestOptions, this.paymentMethod());    
        }.bind(this);
        // success promise:
        var success = function(serverBooking) {
            this.isSaving(false);
            this.booking.model.updateWith(serverBooking);
            
            app.modals.showNotification({
                title: 'Done!',
                message: 'Your booking was created!'
            })
            .then(function() {
                app.shell.go('/');
            });
        }.bind(this);
        // error handling
        var onerror = function(err) {
            this.isSaving(false);
            app.modals.showError({ error: err });
        }.bind(this);

        // If anonymous, must pass the signup, and only after save booking
        if (this.isAnonymous()) {
            this.signupVM.performSignup()
            .then(saveIt)
            .then(success)
            .catch(onerror);
        }
        else {
            saveIt()
            .then(success)
            .catch(onerror);
        }
    }.bind(this);
    
    ///
    /// Field Special requests (client notes to service professional)
    this.specialRequestsPlaceholder = ko.pureComputed(function() {
        var sp = this.serviceProfessionalInfo();
        sp = sp.profile() && sp.profile().firstName();

        return sp ? 'Add notes to ' + sp : 'Add notes';
    }, this);
    this.pickSpecialRequests = function() {
        app.modals.showTextEditor({
            title: this.specialRequestsPlaceholder(),
            text: this.booking.specialRequests()
        })
        .then(function(text) {
            this.booking.specialRequests(text);
        }.bind(this))
        .catch(function(err) {
            if (err) {
                app.modals.showError({ error: err });
            }
            // No error, do nothing just was dismissed
        });
    }.bind(this);
    
    ///
    /// URLs
    this.urlTos = ko.observable('https://loconomics.com/en-US/About/TermsOfUse/');
    this.urlPp = ko.observable('https://loconomics.com/en-US/About/PrivacyPolicy/');
    this.urlBcp = ko.observable('https://loconomics.com/en-US/About/BackgroundCheckPolicy/');
    this.urlCp = ko.observable('https://loconomics.com/en-US/About/CancellationPolicy/');
    
    
    this.goLogin = function(d, e) {
        app.shell.go('/login', { redirectUrl: app.shell.currentRoute.url });
        if (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }
    };
}

function PricingSummaryVM(values) {

    Model(this);

    this.model.defProperties({
        details: {
            isArray: true,
            Model: PricingSummaryDetail
        },
        gratuityPercentage: 0,
        gratuityAmount: 0,
        feesPercentage: 10
    }, values);

    this.subtotalPrice = ko.pureComputed(function() {
        return this.details().reduce(function(total, item) {
            total += item.price();
            return total;
        }, 0);
    }, this);
    
    this.fees = ko.pureComputed(function() {
        var t = this.subtotalPrice(),
            f = this.feesPercentage();
        return t * (f / 100);
    }, this);
    
    this.gratuity = ko.pureComputed(function() {
        var percentage = this.gratuityPercentage() |0,
            amount = this.gratuityAmount() |0;
        return (
            percentage > 0 ?
                (this.subtotalPrice() * (percentage / 100)) :
                amount < 0 ? 0 : amount
        );
    }, this);

    this.totalPrice = ko.pureComputed(function() {
        return this.subtotalPrice() + this.fees() + this.gratuity();
    }, this);
    
    this.feesMessage = ko.pureComputed(function() {
        var f = numeral(this.fees()).format('$#,##0.00');
        return '*includes a __fees__ first-time booking fee'.replace(/__fees__/g, f);
    }, this);

    this.items = ko.pureComputed(function() {

        var items = this.details().slice();
        var gratuity = this.gratuity();

        if (gratuity > 0) {
            var gratuityLabel = this.gratuityPercentage() ?
                'Gratuity (__gratuity__%)'.replace(/__gratuity__/g, (this.gratuityPercentage() |0)) :
                'Gratuity';

            items.push(new PricingSummaryDetail({
                serviceName: gratuityLabel,
                price: this.gratuity()
            }));
        }

        return items;
    }, this);
    
    this.serviceDurationMinutes = ko.pureComputed(function() {
        return this.details().reduce(function(total, item) {
            total += item.serviceDurationMinutes();
            return total;
        }, 0);
    }, this);
    
    this.firstSessionDurationMinutes = ko.pureComputed(function() {
        return this.details().reduce(function(total, item) {
            total += item.firstSessionDurationMinutes();
            return total;
        }, 0);
    }, this);
    
    var duration2Language = require('../utils/duration2Language');
    
    this.serviceDurationDisplay = ko.pureComputed(function() {
        return duration2Language({ minutes: this.serviceDurationMinutes() });
    }, this);
    
    this.firstSessionDurationDisplay = ko.pureComputed(function() {
        return duration2Language({ minutes: this.firstSessionDurationMinutes() });
    }, this);
    
    this.toPricingSummary = function() {
        var plain = this.model.toPlainObject(true);
        plain.subtotalPrice = this.subtotalPrice();
        plain.feePrice = this.fees();
        plain.totalPrice = this.totalPrice();
        plain.serviceDurationMinutes = this.serviceDurationMinutes();
        plain.firstSessionDurationMinutes = this.firstSessionDurationMinutes();
        return new PricingSummary(plain);
    };
}

},{"../components/Activity":96,"../models/Address":102,"../models/Booking":104,"../models/EventDates":110,"../models/InputPaymentMethod":113,"../models/Model":123,"../models/PricingSummary":125,"../models/PricingSummaryDetail":126,"../models/PublicUser":129,"../utils/duration2Language":171,"../viewmodels/BookingProgress":197,"../viewmodels/ServiceAddresses":203,"../viewmodels/ServiceProfessionalService":204,"../viewmodels/Signup":205,"knockout":false,"numeral":false}],13:[function(require,module,exports){
/** Calendar activity **/
'use strict';

var $ = require('jquery'),
    moment = require('moment'),
    ko = require('knockout'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

require('../components/DatePicker');
var datepickerAvailability = require('../utils/datepickerAvailability');

var Activity = require('../components/Activity');

var A = Activity.extends(function CalendarActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Calendar');

    /* Getting elements */
    this.$datepicker = this.$activity.find('#calendarDatePicker');
    this.$dailyView = this.$activity.find('#calendarDailyView');
    this.$dateTitle = this.$activity.find('.CalendarDateHeader > .btn');
    this.$chooseNew = $('#calendarChooseNew');
    
    /* Init components */
    this.$datepicker.show().datepicker({ extraClasses: 'DatePicker--tagged' });
    
    this.tagAvailability = datepickerAvailability.create(this.app, this.$datepicker, this.viewModel.isLoading);

    /* Event handlers */
    // Changes on currentDate
    this.registerHandler({
        target: this.viewModel.currentDate,
        handler: function(date) {

            if (date) {
                var mdate = moment(date);

                if (mdate.isValid()) {

                    var isoDate = mdate.toISOString();

                    // Update datepicker selected date on date change (from 
                    // a different source than the datepicker itself
                    this.$datepicker.removeClass('is-visible');
                    // Change not from the widget?
                    if (this.$datepicker.datepicker('getValue').toISOString() !== isoDate)
                        this.$datepicker.datepicker('setValue', date, true);

                    // On currentDate changes, update the URL
                    // TODO: save a useful state
                    // DOUBT: push or replace state? (more history entries or the same?)
                    this.app.shell.pushState(null, null, 'calendar/' + isoDate);

                    // DONE
                    return;
                }
            }

            // Something fail, bad date or not date at all
            // Set the current 
            this.viewModel.currentDate(getDateWithoutTime());

        }.bind(this)
    });

    // Swipe date on gesture
    this.registerHandler({
        target: this.$dailyView,
        event: 'swipeleft swiperight',
        handler: function(e) {
            e.preventDefault();

            var dir = e.type === 'swipeleft' ? 'next' : 'prev';

            // Hack to solve the freezy-swipe and tap-after bug on JQM:
            $(document).trigger('touchend');
            // Change date
            this.$datepicker.datepicker('moveValue', dir, 'date');

        }.bind(this)
    });

    // Showing datepicker when pressing the title
    this.registerHandler({
        target: this.$dateTitle,
        event: 'click',
        handler: function(e) {
            this.$datepicker.toggleClass('is-visible');
            e.preventDefault();
            e.stopPropagation();
        }.bind(this)
    });

    // Updating view date when picked another one
    this.registerHandler({
        target: this.$datepicker,
        event: 'dateChanged',
        handler: function(e) {
            if (e.viewMode === 'days') {
                this.viewModel.currentDate(getDateWithoutTime(e.date));
            }
        }.bind(this)
    });

    // Set date to today
    this.viewModel.currentDate(getDateWithoutTime());
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    // Date from the parameter, fallback to today
    var sdate = options.route && options.route.segments && options.route.segments[0],
        date;
    if (sdate) {
        // Parsing date from ISO format
        var mdate = moment(sdate);
        // Check is valid, and ensure is date at 12AM
        date = mdate.isValid() ? getDateWithoutTime(mdate.toDate()) : null;
    }
    
    if (!date)
        // Today:
        date = getDateWithoutTime();
    
    // Reset to force new data load (can happens if schedule was change or anything in the middle)
    this.viewModel.previousDate = null;
    this.viewModel.currentDate(date);
    // Force a refresh of tags
    this.tagAvailability(date, this.app.model.userProfile.data.userID(), true);
};

var Appointment = require('../models/Appointment'),
    TimeSlotViewModel = require('../viewmodels/TimeSlot');

function ViewModel(app) {

    this.currentDate = ko.observable(getDateWithoutTime());
    var fullDayFree = [Appointment.newFreeSlot({ date: this.currentDate() })];
    // The 'free' event must update with any change in currentDate
    this.currentDate.subscribe(function(date) {
        if (date) {
            fullDayFree[0].startTime(date);
            fullDayFree[0].endTime(date);
        }
    }, this);

    // slotsSource save the data as processed by a request of 
    // data because a date change.
    // It's updated by changes on currentDate that performs the remote loading
    this.slotsSource = ko.observable(fullDayFree);
    // slots computed, using slotsSource.
    // As computed in order to allow any other observable change
    // from trigger the creation of a new value
    this.slots = ko.computed(function() {
    
        var slots = this.slotsSource();
        
        // Hide unavailable slots, except if there is only one slot (so there
        // is ever something displayed)
        if (slots.length > 1) {
            slots = slots.filter(function(slot) {
                return slot.id() !== Appointment.specialIds.unavailable;
            });
        }
        
        return slots.map(TimeSlotViewModel.fromAppointment);

    }, this);
    
    this.isLoading = ko.observable(false);

    // Update current slots on date change
    // previousDate is public to allow being reset on a new show (discard old data
    // by forcing a load)
    this.previousDate = this.currentDate().toISOString();
    this.currentDate.subscribe(function (date) {

        // IMPORTANT: The date object may be reused and mutated between calls
        // (mostly because the widget I think), so is better to create
        // a clone and avoid getting race-conditions in the data downloading.
        date = new Date(Date.parse(date.toISOString()));

        // Avoid duplicated notification, un-changed date
        if (date.toISOString() === this.previousDate) {
            return;
        }
        this.previousDate = date.toISOString();

        this.isLoading(true);
        
        app.model.calendar.getDateAvailability(date)
        .then(function(dateAvail) {
            
            // IMPORTANT: First, we need to check that we are
            // in the same date still, because several loadings
            // can happen at a time (changing quickly from date to date
            // without wait for finish), avoiding a race-condition
            // that create flickering effects or replace the date events
            // by the events from other date, because it tooks more an changed.
            // TODO: still this has the minor bug of losing the isLoading
            // if a previous triggered load still didn't finished; its minor
            // because is very rare that happens, moving this stuff
            // to a special appModel for mixed bookings and events with 
            // per date cache that includes a view object with isLoading will
            // fix it and reduce this complexity.
            if (date.toISOString() !== this.currentDate().toISOString()) {
                // Race condition, not the same!! out:
                return;
            }
        
            // Update the source:
            this.slotsSource(dateAvail.list());
            this.isLoading(false);

        }.bind(this))
        .catch(function(err) {
            
            // Show free on error
            this.slotsSource(fullDayFree);
            this.isLoading(false);
            
            var msg = 'Error loading calendar events.';
            app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
            
        }.bind(this));

    }.bind(this));
}

},{"../components/Activity":96,"../components/DatePicker":97,"../models/Appointment":103,"../utils/datepickerAvailability":170,"../utils/getDateWithoutTime":175,"../viewmodels/TimeSlot":206,"knockout":false,"moment":false}],14:[function(require,module,exports){
/**
    CalendarSyncing activity
**/
'use strict';

var Activity = require('../components/Activity'),
    $ = require('jquery'),
    ko = require('knockout');

var A = Activity.extends(function CalendarSyncingActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.serviceProfessional;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    
    // Adding auto-select behavior to the export URL
    this.registerHandler({
        target: this.$activity.find('#calendarSync-icalExportUrl'),
        event: 'click',
        handler: function() {
            $(this).select();
        }
    });
    
    this.registerHandler({
        target: this.app.model.calendarSyncing,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving calendar syncing settings.' : 'Error loading calendar syncing settings.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.calendarSyncing.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var calendarSyncing = app.model.calendarSyncing;

    var syncVersion = calendarSyncing.newVersion();
    syncVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            syncVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.sync = syncVersion.version;

    this.isLocked = ko.pureComputed(function() {
        return this.isLocked() || this.isReseting();
    }, calendarSyncing);

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, calendarSyncing);
    
    this.resetText = ko.pureComputed(function() {
        return (
            this.isReseting() ? 
                'reseting...' : 
                'Reset Private URL'
        );
    }, calendarSyncing);
    
    this.discard = function discard() {
        syncVersion.pull({ evenIfNewer: true });
    };

    this.save = function save() {
        syncVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    };
    
    this.reset = function reset() {
        calendarSyncing.resetExportUrl();
    };
}

},{"../components/Activity":96,"knockout":false}],15:[function(require,module,exports){
/**
    Cancellation Policy activity
**/
'use strict';

var ko = require('knockout'),
    moment = require('moment'),
    Activity = require('../components/Activity');

var A = Activity.extends(function CancellationPolicyActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Job Title');
    
    // On changing jobTitleID:
    // - load addresses
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                this.viewModel.isLoading(true);
                // Get data for the Job title ID
                this.app.model.userJobProfile.getUserJobTitle(jobTitleID)
                .then(function(userJobTitle) {
                    // Save for use in the view
                    this.viewModel.userJobTitle(userJobTitle);
                    this.viewModel.selectedCancellationPolicyID(userJobTitle.cancellationPolicyID());
                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this))
                .then(function() {
                    // Finally
                    this.viewModel.isLoading(false);
                }.bind(this));
            }
            else {
                this.viewModel.userJobTitle(null);
                this.viewModel.selectedCancellationPolicyID(null);
            }
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    // Reset
    this.viewModel.jobTitleID(null);
    this.viewModel.selectedCancellationPolicyID(null);
    
    Activity.prototype.show.call(this, state);

    var params = state && state.route && state.route.segments;
    this.viewModel.jobTitleID(params[0] |0);
};

function ViewModel(app) {

    this.jobTitleID = ko.observable(0);
    this.userJobTitle = ko.observable(null);
    // Local copy of the cancellationPolicyID, rather than use
    // it directly from the userJobTitle to avoid that gets saved
    // in memory without press 'save'
    this.selectedCancellationPolicyID = ko.observable(null);
    
    this.isLoading = ko.observable(false);
    this.isSaving = ko.observable(false);
    this.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving();
    }, this);
    
    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, this);
    
    this.save = function() {
        var ujt = this.userJobTitle();
        if (ujt) {
            this.isSaving(true);
            
            var plain = ujt.model.toPlainObject();
            plain.cancellationPolicyID = this.selectedCancellationPolicyID();

            app.model.userJobProfile.setUserJobTitle(plain)
            .then(function() {
                this.isSaving(false);
                app.successSave();
            }.bind(this))
            .catch(function(err) {
                this.isSaving(false);
                app.modals.showError({ title: 'Error saving Cancellation Policy preference', error: err });
            }.bind(this));
        }
    }.bind(this);

    this.policies = ko.observableArray([
        new CancellationPolicy({
            cancellationPolicyID: 1,
            name: 'Strict',
            description: '50% refund up to 5 days before booking, except fees',
            hoursRequired: 120,
            refundIfCancelledBefore: 0.5
        }),
        new CancellationPolicy({
            cancellationPolicyID: 2,
            name: 'Moderate',
            description: '100% refund up to 24 hours before booking, except fees.  No refund for under 24 hours and no-shows.',
            hoursRequired: 24,
            refundIfCancelledBefore: 1
        }),
        new CancellationPolicy({
            cancellationPolicyID: 3,
            name: 'Flexible',
            description: '100% refund up to 24 hours before booking, except fees.  50% refund for under 24 hours and no-shows.',
            hoursRequired: 24,
            refundIfCancelledBefore: 1
        })
    ]);
}

var Model = require('../models/Model');

var observableTime = ko.observable(new Date());
setInterval(function() {
    observableTime(new Date());
}, 1 * 60 * 1000);

function CancellationPolicy(values) {
    
    Model(this);
    
    this.model.defProperties({
        cancellationPolicyID: 0,
        name: '',
        description: '',
        hoursRequired: 0,
        refundIfCancelledBefore: 0
    }, values);
    
    this.refundIfCancelledBeforeDisplay = ko.pureComputed(function() {
        return Math.floor(this.refundIfCancelledBefore() * 100) + '%';
    }, this);

    this.refundLimitDate = ko.computed(function() {
        var d = moment(observableTime()).clone();
        d
        .add(7, 'days')
        .subtract(this.hoursRequired(), 'hours');
        return d.toDate();
    }, this);
}

},{"../components/Activity":96,"../models/Model":123,"knockout":false,"moment":false}],16:[function(require,module,exports){
/**
    ClientEdition activity
**/
'use strict';

var Activity = require('../components/Activity');
var is = require('is_js');

var A = Activity.extends(function ClientEditionActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('clients', {
        backLink: 'clients'
    });
    
    // If there is a change on the clientID, the updates must match
    // that (if is not already that)
    this.registerHandler({
        target: this.viewModel.clientID,
        handler: function (clientID) {
            if (!clientID)
                return;

            var found = /clientEditor\/(\-?\d+)/i.exec(window.location),
                urlID = found && found[1] |0;

            // If is different URL and current ID
            if (!found ||
                urlID !== clientID) {
                // Replace URL
                this.app.shell.replaceState(null, null, 'clientEditor/' + clientID);
            }
        }.bind(this)
    });
    
    // Special treatment of the save operation
    this.viewModel.onSave = function(clientID) {
        if (this.requestData.returnNewAsSelected === true) {
            // Go to previous activity that required
            // to select a client
            this.requestData.clientID = clientID;
            this.app.shell.goBack(this.requestData);
        }
        else {
            // Regular save
            this.app.successSave();
        }
    }.bind(this);
});

exports.init = A.init;

var ko = require('knockout');

A.prototype.updateNavBarState = function updateNavBarState() {

    var referrer = this.app.shell.referrerRoute;
    referrer = referrer && referrer.url || '/clients';
    var link = this.requestData.cancelLink || referrer;
    
    this.convertToCancelAction(this.navBar.leftAction(), link);
};

A.prototype.show = function show(state) {
    /*jshint maxcomplexity: 8*/
    Activity.prototype.show.call(this, state);
    
    // reset
    this.viewModel.clientID(0);
    
    this.updateNavBarState();

    // params
    var params = state && state.route && state.route.segments || [];
    
    var clientID = params[0] |0;
    
    if (clientID) {
        this.viewModel.clientID(clientID);
        
        /*this.viewModel.client.sync(clientID)
        .catch(function (err) {
            this.app.modals.showError({
                title: 'Error loading client data',
                error: err
            });
        }.bind(this));*/

        this.app.model.clients.createItemVersion(clientID)
        .then(function (clientVersion) {
            if (clientVersion) {
                this.viewModel.clientVersion(clientVersion);
                this.viewModel.header('Edit Client');
            } else {
                this.viewModel.clientVersion(null);
                this.viewModel.header('Unknow client or was deleted');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'Error loading client data',
                error: err
            });
        }.bind(this));
    }
    else {
        
        // Check request parameters that allow preset client information
        // (used when the client is created based on an existent marketplace user)
        var presetData = this.requestData.presetData || {};
        // If there is not set an explicit 'false' value on editable
        // field (as when there is not data given), set to true so can be edited
        // NOTE: This is because a given marketplace user will come with editable:false
        // and need to be preserved, while on regular 'new client' all data is set by 
        // the service professional.
        if (presetData.editable !== false) {
            presetData.editable = true;
        }

        /*this.viewModel.client.newItem(presetData);*/
        // New client
        this.viewModel.clientVersion(this.app.model.clients.newItem(presetData));
        this.viewModel.header('Add a Client');
        
        // Extra preset data
        if (this.requestData.newForSearchText) {
            clientDataFromSearchText(this.requestData.newForSearchText || '', this.viewModel.client());
        }
    }
};

/**
    Small utility that just returns true if the given
    string seems a possible phone number, false otherwise.
    NOTE: Is NOT an exaustive phone validation check, just
    checks is there are several numbers so there is a chance
    to be a phone. There are stricker checks (annotated) but
    can fail on some situations (switchboard numbers) or in
    different locales.
**/
function seemsAPhoneNumber(str) {
    // Possible stricker comparision
    // return is.nanpPhone(str) || is.eppPhone(str);
    
    // Just if there are more than three consecutive numbers,
    // then 'may' be a phone number (may be anything else, but
    // since some special phone numbers can have letters or signs,
    // this is just a very lax and conservative (to avoid false negatives) check.
    return (/\d{3,}/).test(str || '');
}

/**
    Use the provided search text as the initial value
    for: name, email or phone (what fits better)
**/
function clientDataFromSearchText(txt, client) {
    if (is.email(txt)) {
        client.email(txt);
    }
    else if (seemsAPhoneNumber(txt)) {
        client.phone(txt);
    }
    else {
        // Otherwise, think is the fullname, spliting by white space
        var nameParts = txt.split(' ', 2);
        client.firstName(nameParts[0]);
        if (nameParts.length > 1) {
            client.lastName(nameParts[1]);
            // TODO For spanish (or any locale with secondLastName)
            // must try to detect the second last name?
        }
    }
}

function ViewModel(app) {
    /*jshint maxstatements:80 */
    
    this.clientID = ko.observable(0);
    
    this.clientVersion = ko.observable(null);
    this.client = ko.pureComputed(function() {
        var v = this.clientVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    //this.client = app.model.clients.createWildcardItem();

    this.header = ko.observable('');
    
    this.isLoading = app.model.clients.state.isLoading;
    this.isSyncing = app.model.clients.state.isSyncing;
    this.isSaving = app.model.clients.state.isSaving;
    this.isLocked = ko.pureComputed(function() {
        return (
            app.model.clients.state.isLocked() ||
            this.isDeleting()
        );
    }, this);
    this.isReadOnly = ko.pureComputed(function() {
        var c = this.client();
        return c && !c.editable();
    }, this);

    this.isDeleting = app.model.clients.state.isDeleting;

    this.wasRemoved = ko.observable(false);

    this.isNew = ko.pureComputed(function() {
        var c = this.client();
        return !c || !c.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.clientVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    this.isNew() ?
                        'Add client' :
                        v && v.areDifferent() ?
                            'Save changes' :
                            'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.clientVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {

        app.model.clients.setItem(this.client().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.client().model.updateWith(serverData);
            // Push version so it appears as saved
            this.clientVersion().push({ evenIfObsolete: true });
          
            // Special save, function provided by the activity on set-up
            this.onSave(serverData.clientUserID);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        app.modals.confirm({
            title: 'Delete client',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.clients.delItem(this.clientID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    // Birth month day
    // TODO l10n
    this.months = ko.observableArray([
        { id: 1, name: 'January'},
        { id: 2, name: 'February'},
        { id: 3, name: 'March'},
        { id: 4, name: 'April'},
        { id: 5, name: 'May'},
        { id: 6, name: 'June'},
        { id: 7, name: 'July'},
        { id: 8, name: 'August'},
        { id: 9, name: 'September'},
        { id: 10, name: 'October'},
        { id: 11, name: 'November'},
        { id: 12, name: 'December'}
    ]);
    // We need to use a special observable in the form, that will
    // update the back-end profile.birthMonth
    this.selectedBirthMonth = ko.computed({
        read: function() {
            var c = this.client();
            if (c) {
                var birthMonth = c.birthMonth();
                return birthMonth ? this.months()[birthMonth - 1] : null;
            }
            return null;
        },
        write: function(month) {
            var c = this.client();
            if (c)
                c.birthMonth(month && month.id || null);
        },
        owner: this
    });
    
    this.monthDays = ko.observableArray([]);
    for (var iday = 1; iday <= 31; iday++) {
        this.monthDays.push(iday);
    }
    
    // Extra for button addons
    this.validEmail = ko.pureComputed(function() {
        var c = this.client();
        if (c) {
            var e = c.email();
            return is.email(e) ? e : '';
        }
        return '';
    }, this);

    this.validPhone = ko.pureComputed(function() {
        var c = this.client();
        if (c) {
            var e = c.phone();
            return seemsAPhoneNumber(e) ? e : '';
        }
        return '';
    }, this);
    
    // Public Search
    
    var foundPublicUser = function foundPublicUser(user) {
        // Only if still matches current view data
        var c = this.client();
        if (!c) return;
        
        // Don't offer if is already that user!
        if (c.clientUserID() === user.clientUserID) return;
        
        // NOTE: avoiding use fullName because it can make more than one conflicting
        // results, being not enough the name to confirm the user (use the search for that)
        //  c.fullName() === user.fullName ||
        if (c.email() === user.email ||
            c.phone() === user.phone) {

            // Notify user
            var msg = 'We`ve found an existing record for {0}. Would you like to add him to your clients?'.replace(/\{0\}/g, user.firstName);
            app.modals.confirm({
                title: 'client found at loconomics.com',
                message: msg
            })
            .then(function() {
                // Acepted
                // Replace current user data
                // but keep notesAboutClient
                var notes = c.notesAboutClient();
                c.model.updateWith(user);
                c.notesAboutClient(notes);
                this.clientID(user.clientUserID);
            }.bind(this))
            .catch(function() {
                // Discarded, do nothing
            });
        }
        
    }.bind(this);
    
    // When filering has no results:
    ko.computed(function() {
        var c = this.client();
        if (!c) return;
        
        // NOTE: discarded the fullName because several results can be retrieved,
        // better use the search for that and double check entries
        
        var email = c.email(),
            //fullName = c.fullName(),
            phone = c.phone();
        if (!email && !phone /*!fullName && */) return;

        app.model.clients.publicSearch({
            //fullName: fullName,
            email: email,
            phone: phone
        })
        .then(function(r) {
            if (r && r[0]) foundPublicUser(r[0]);
        }.bind(this))
        .catch(function() {
            // Doesn't matters
        });
    }, this)
    // Avoid excessive request by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 400, method: 'notifyWhenChangesStop' } });
}

},{"../components/Activity":96,"is_js":false,"knockout":false}],17:[function(require,module,exports){
/**
    clients activity
**/
'use strict';

var $ = require('jquery'),
    ko = require('knockout'),
    Activity = require('../components/Activity'),
    textSearch = require('../utils/textSearch');

var A = Activity.extends(function ClientsActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Clients', {
        backLink: 'cms'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject();
    
    // Getting elements
    this.$index = this.$activity.find('#clientsIndex');
    this.$listView = this.$activity.find('#clientsListView');

    // Handler to go back with the selected client when 
    // there is one selected and requestData is for
    // 'select mode'
    this.registerHandler({
        target: this.viewModel.selectedClient,
        handler: function (theSelectedClient) {
            // We have a request and
            // it requested to select a client,
            // and a selected client
            if (this.requestData &&
                this.requestData.selectClient === true &&
                theSelectedClient) {

                // Pass the selected client in the info
                this.requestData.selectedClientID = theSelectedClient.clientUserID();
                // And go back
                this.app.shell.goBack(this.requestData);
                // Last, clear requestData
                this.requestData = null;
            }
        }.bind(this)
    });
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    //jshint maxcomplexity:8
    
    var itIs = this.viewModel.isSelectionMode();
    
    this.viewModel.headerText(itIs ? 'Select a client' : '');

    if (this.requestData.title) {
        // Replace title by title if required
        this.navBar.title(this.requestData.title);
    }
    else {
        // Title must be empty
        this.navBar.title('');
    }

    if (this.requestData.cancelLink) {
        this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink);
    }
    else {
        // Reset to defaults, or given title:
        this.navBar.leftAction().model.updateWith(this.defaultLeftAction);
        if (this.requestData.navTitle)
            this.navBar.leftAction().text(this.requestData.navTitle);
    }
    
    if (itIs && !this.requestData.cancelLink) {
        // Uses a custom handler so it returns keeping the given state:
        this.navBar.leftAction().handler(this.returnRequest);
    }
    else if (!itIs) {
        this.navBar.leftAction().handler(null);
    }
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // On every show, search gets reseted
    this.viewModel.searchText('');
    this.viewModel.selectedClient(null);
    this.viewModel.requestData = this.requestData;
    
    // Check if it comes from a clientEditor that
    // received the flag 'returnNewAsSelected' and a 
    // clientID: we were in selection mode->creating client->must
    // return the just created client to the previous page
    if (state.returnNewAsSelected === true &&
        state.clientID) {
        
        // perform an activity change but allow the current
        // to stop first
        setTimeout(function() {
            delete state.returnNewAsSelected;
            this.requestData.selectedClientID = state.clientID;
            // And go back
            this.app.shell.goBack(this.requestData);
        }.bind(this), 1);
        
        // avoid the rest operations
        return;
    }
    
    // Set selection:
    this.viewModel.isSelectionMode(state.selectClient === true);

    this.updateNavBarState();
    
    // Keep data updated:
    this.app.model.clients.sync()
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading the clients list',
            error: err
        });
    }.bind(this));
};

function ViewModel(app) {

    this.headerText = ko.observable('');

    // Especial mode when instead of pick and edit we are just selecting
    // (when editing an appointment)
    this.isSelectionMode = ko.observable(false);

    // Full list of clients
    this.clients = app.model.clients.list;
    this.isLoading = app.model.clients.state.isLoading;
    this.isSyncing = app.model.clients.state.isSyncing;
    
    // Search text, used to filter 'clients'
    this.searchText = ko.observable('');
    
    // Utility to get a filtered list of clients based on clients
    this.getFilteredList = function getFilteredList() {
        var s = (this.searchText() || '').toLowerCase();
        // Search the client by:
        // - full name
        // - (else) email
        // - (else) phone
        return this.clients().filter(function(client) {
            if (!client) return false;
            var found = textSearch(s, client.fullName());
            if (found) return true;
            found = textSearch(s, client.email());
            if (found) return true;
            found = textSearch(s, client.phone());
            return found;
        });
    };

    // Filtered list of clients
    this.filteredClients = ko.computed(function() {
        return this.getFilteredList();
    }, this);
    
    // Grouped list of filtered clients
    this.groupedClients = ko.computed(function(){

        // Sorting list, in a cross browser way (in Firefox, just A > B works, but not on webkit/blink)
        var clients = this.filteredClients().sort(function(clientA, clientB) {
            var a = clientA.firstName().toLowerCase(),
                b = clientB.firstName().toLowerCase();
            if (a === b)
                return 0;
            else if (a > b)
                return 1;
            else
                return -1;
        });
        
        var groups = [],
            latestGroup = null,
            latestLetter = null;

        clients.forEach(function(client) {
            var letter = (client.firstName()[0] || '').toUpperCase();
            if (letter !== latestLetter) {
                latestGroup = {
                    letter: letter,
                    clients: [client]
                };
                groups.push(latestGroup);
                latestLetter = letter;
            }
            else {
                latestGroup.clients.push(client);
            }
        });

        return groups;

    }, this);
    
    
    /// Public search
    this.publicSearchResults = ko.observableArray([]);
    this.publicSearchRunning = ko.observable(null);
    // When filering has no results:
    ko.computed(function() {    
        var filtered = this.filteredClients(),
            searchText = this.searchText(),
            request = null;

        // If there is search text and no results from local filtering
        if (filtered.length === 0 && searchText) {
            
            // Remove previous results
            this.publicSearchResults([]);
            
            request = app.model.clients.publicSearch({
                fullName: searchText,
                email: searchText,
                phone: searchText
            });
            this.publicSearchRunning(request);
            request.then(function(r) {
                this.publicSearchResults(r);
            }.bind(this))
            .catch(function(err) {
                app.modals.showError({
                    title: 'There was an error when on remote clients search',
                    error: err
                });
            })
            .then(function() {
                // Always:
                // if still the same, it ended then remove
                if (this.publicSearchRunning() === request)
                    this.publicSearchRunning(null);
            }.bind(this));
        }
        else {
            this.publicSearchResults([]);
            // Cancelling any pending request, to avoid
            // anwanted results when finish
            request = this.publicSearchRunning();
            if (request &&
                request.xhr &&
                request.xhr.abort) {
                request.xhr.abort();
                this.publicSearchRunning(null);
            }
        }
    }, this)
    // Avoid excessive request by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 400, method: 'notifyWhenChangesStop' } });
    
    /**
        Add a client from the public/remote search results
    **/
    this.addRemoteClient = function(client, event) {
        var data = client.model && client.model.toPlainObject() || client;
        var request = $.extend({}, this.requestData, {
            presetData: data,
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go('clientEditor', request);

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    /**
        Call the activity to add a new client, passing the current
        search text so can be used as initial name/email/phone
    **/
    this.addNew = function(data, event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        
        var request = $.extend({}, this.requestData, {
            newForSearchText: this.searchText(),
            returnNewAsSelected: this.isSelectionMode()
        });
        app.shell.go('clientEditor', request);
    }.bind(this);

    /// Selections
    
    this.selectedClient = ko.observable(null);
    
    this.selectClient = function(selectedClient, event) {
        event.preventDefault();
        event.stopImmediatePropagation();

        this.selectedClient(selectedClient);
    }.bind(this);
}

},{"../components/Activity":96,"../utils/textSearch":193,"knockout":false}],18:[function(require,module,exports){
/**
    CMS activity
    (Client Management System)
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function CmsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSectionNavBar('Client management');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Keep data updated:
    this.app.model.clients.sync()
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading the clients list',
            error: err
        });
    }.bind(this));
};

var numeral = require('numeral');

function ViewModel(app) {
    
    this.clients = app.model.clients.list;

    this.clientsCount = ko.pureComputed(function() {
        var cs = this.clients();
        
        if (cs <= 0)
            return '0 clients';
        else if (cs === 1)
            return '1 client';
        else
            return numeral(cs.length |0).format('0,0') + ' clients';
    }, this);
}

},{"../components/Activity":96,"knockout":false,"numeral":false}],19:[function(require,module,exports){
/**
    ContactForm activity
**/
'use strict';

var Activity = require('../components/Activity'),
    VocElementEnum = require('../models/VocElementEnum');

var A = Activity.extends(function ContactFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
    this.navBar.rightAction(null);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    var params = this.requestData.route.segments || [];
    var elementName = params[0] || '',
        elementID = VocElementEnum[elementName] |0;
    
    if (!elementName) {
        console.log('Feedback Support: Accessing without specify an element, using General (0)');
    }
    else if (!VocElementEnum.hasOwnProperty(elementName)) {
        console.error('Feedback Support: given a bad VOC Element name:', elementName);
    }

    this.viewModel.vocElementID(elementID);
};

var ko = require('knockout');
function ViewModel(app) {
    
    this.message = ko.observable('');
    this.wasSent = ko.observable(false);
    this.isSending = ko.observable(false);
    this.vocElementID = ko.observable(0);

    var updateWasSent = function() {
        this.wasSent(false);
    }.bind(this);
    this.message.subscribe(updateWasSent);
    
    this.submitText = ko.pureComputed(function() {
        return this.isSending() ? 'Sending..' : this.wasSent() ? 'Sent' : 'Send';
    }, this);
    
    this.send = function send() {
        this.isSending(true);
        app.model.feedback.postSupport({
            message: this.message(),
            vocElementID: this.vocElementID()
        })
        .then(function() {
            // Reset after being sent
            this.message('');
            this.wasSent(true);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error sending your feedback',
                error: err
            });
        })
        .then(function() {
            // Always
            this.isSending(false);
        }.bind(this));
    }.bind(this);
}

},{"../components/Activity":96,"../models/VocElementEnum":149,"knockout":false}],20:[function(require,module,exports){
/**
    ContactInfo activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function ContactInfoActivity() {
    
    Activity.apply(this, arguments);

    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.loggedUser;
    
    var serviceProfessionalNavBar = Activity.createSubsectionNavBar('Owner information', {
        backLink: 'ownerInfo'
    });
    this.serviceProfessionalNavBar = serviceProfessionalNavBar.model.toPlainObject(true);
    var clientNavBar = Activity.createSubsectionNavBar('Account', {
        backLink: 'account'
    });
    this.clientNavBar = serviceProfessionalNavBar.model.toPlainObject(true);
    this.navBar = this.viewModel.user.isServiceProfessional() ? serviceProfessionalNavBar : clientNavBar;
    
    this.registerHandler({
        target: this.app.model.userProfile,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving contact data.' : 'Error loading contact data.';
            this.app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
        }.bind(this)
    });
    
    this.registerHandler({
        target: this.app.model.homeAddress,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving address details.' : 'Error loading address details.';
            this.app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
        }.bind(this)
    });
    
    // On change to a valid code, do remote look-up
    // NOTE: using directly a computed rather than the registerHandler to use
    // the rateLimit extender that avoids excesive request being performed on changes.
    // NOTE: the code inside the handler is mostly the same as in addressEditor for the same look-up.
    var app = this.app,
        viewModel = this.viewModel;
    ko.computed(function() {
        var postalCode = this.postalCode(),
            address = this;

        if (postalCode && !/^\s*$/.test(postalCode)) {
            app.model.postalCodes.getItem(postalCode)
            .then(function(info) {
                if (info) {
                    address.city(info.city);
                    address.stateProvinceCode(info.stateProvinceCode);
                    address.stateProvinceName(info.stateProvinceName);
                    viewModel.errorMessages.postalCode('');
                }
            })
            .catch(function(err) {
                address.city('');
                address.stateProvinceCode('');
                address.stateProvinceName('');
                // Expected errors, a single message, set
                // on the observable
                var msg = typeof(err) === 'string' ? err : null;
                if (msg || err && err.responseJSON && err.responseJSON.errorMessage) {
                    viewModel.errorMessages.postalCode(msg || err.responseJSON.errorMessage);
                }
                else {
                    // Log to console for debugging purposes, on regular use an error on the
                    // postal code is not critical and can be transparent; if there are 
                    // connectivity or authentification errors will throw on saving the address
                    console.error('Server error validating Zip Code', err);
                }
            });
        }
    }, this.viewModel.address)
    // Avoid excessive requests by setting a timeout since the latest change
    .extend({ rateLimit: { timeout: 200, method: 'notifyWhenChangesStop' } });
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    
    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {
        // Reset
        var nav = this.viewModel.user.isServiceProfessional() ? this.serviceProfessionalNavBar : this.clientNavBar;
        this.navBar.model.updateWith(nav, true);
    }
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Discard any previous unsaved edit
    this.viewModel.discard();
    
    this.updateNavBarState();
    
    // Keep data updated:
    this.app.model.userProfile.sync();
    this.app.model.homeAddress.sync();
};

function ViewModel(app) {
    
    this.user = app.model.userProfile.data;

    this.headerText = ko.pureComputed(function() {
        return app.model.onboarding.inProgress() ?
            'How can we reach you?' :
            'Contact information';
    });
    
    // List of possible error messages registered
    // by name
    this.errorMessages = {
        postalCode: ko.observable('')
    };
    
    // User Profile
    var userProfile = app.model.userProfile;
    var profileVersion = userProfile.newVersion();
    profileVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            profileVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.profile = profileVersion.version;
    
    // TODO l10n
    this.months = ko.observableArray([
        { id: 1, name: 'January'},
        { id: 2, name: 'February'},
        { id: 3, name: 'March'},
        { id: 4, name: 'April'},
        { id: 5, name: 'May'},
        { id: 6, name: 'June'},
        { id: 7, name: 'July'},
        { id: 8, name: 'August'},
        { id: 9, name: 'September'},
        { id: 10, name: 'October'},
        { id: 11, name: 'November'},
        { id: 12, name: 'December'}
    ]);
    // We need to use a special observable in the form, that will
    // update the back-end profile.birthMonth
    this.selectedBirthMonth = ko.computed({
        read: function() {
            var birthMonth = this.profile.birthMonth();
            return birthMonth ? this.months()[birthMonth - 1] : null;
        },
        write: function(month) {
            this.profile.birthMonth(month && month.id || null);
        },
        owner: this
    });
    
    this.monthDays = ko.observableArray([]);
    for (var iday = 1; iday <= 31; iday++) {
        this.monthDays.push(iday);
    }
    
    // Home Address
    var homeAddress = app.model.homeAddress;
    var homeAddressVersion = homeAddress.newVersion();
    homeAddressVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            homeAddressVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.address = homeAddressVersion.version;

    // Control observables: special because must a mix
    // of the both remote models used in this viewmodel
    this.isLocked = ko.computed(function() {
        return userProfile.isLocked() || homeAddress.isLocked();
    }, this);
    this.isLoading = ko.computed(function() {
        return userProfile.isLoading() || homeAddress.isLoading();
    }, this);
    this.isSaving = ko.computed(function() {
        return userProfile.isSaving() || homeAddress.isSaving();
    }, this);

    this.submitText = ko.pureComputed(function() {
        return (
            app.model.onboarding.inProgress() ?
                'Save and continue' :
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, this);
    
    // Actions

    this.discard = function discard() {
        profileVersion.pull({ evenIfNewer: true });
        homeAddressVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        Promise.all([
            profileVersion.pushSave(),
            homeAddressVersion.pushSave()
        ])
        .then(function() {
            if (app.model.onboarding.inProgress()) {
                app.model.onboarding.goNext();
            }
            else {
                app.successSave();
            }
        })
        .catch(function() {
            // catch error, managed on event
        });
    }.bind(this);
}

},{"../components/Activity":96,"knockout":false}],21:[function(require,module,exports){
/**
    Conversation activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function ConversationActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Inbox', {
        backLink: 'inbox'
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Reset
    this.viewModel.threadID(0);
    this.viewModel.thread(null);

    // Params
    var params = state && state.route && state.route.segments || [],
        threadID = params[0] |0;

    this.viewModel.threadID(threadID);
    
    // Load the data
    if (threadID) {
        this.viewModel.thread.sync(threadID)
        .catch(function(err) {
            this.app.modals.showError({
                title: 'Error loading conversation',
                error: err
            }).then(function() {
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));
    }
    else {
        this.app.modals.showError({
            title: 'Conversation Not Found'
        }).then(function() {
            this.app.shell.goBack();
        }.bind(this));
    }
};

var ko = require('knockout');

function ViewModel(app) {

    this.isLoading = app.model.messaging.state.isLoading;
    this.isSyncing = app.model.messaging.state.isSyncing;
    this.isSaving = app.model.messaging.state.isSaving;

    this.threadID = ko.observable(null);
    this.thread = app.model.messaging.createWildcardItem();

    this.subject = ko.pureComputed(function() {
        var m = this.thread();
        return (
            this.isLoading() ?
                'Loading...' :
                m && (m.subject() || '').replace(/^\s+|\s+$/g, '') || 'Conversation without subject'
        );
    }, this);
    
    // If the last message reference a booking, is
    // accessed with:
    this.bookingID = ko.pureComputed(function() {
        var msg = this.thread() && this.thread().messages()[0];
        if (msg &&
            (msg.auxT() || '').toLowerCase() === 'booking' &&
            msg.auxID()) {
            return msg.auxID();
        }
        else {
            return null;
        }
    }, this);
}

},{"../components/Activity":96,"knockout":false}],22:[function(require,module,exports){
/**
    Dashboard activity
**/
'use strict';

var ko = require('knockout');

var Activity = require('../components/Activity'),
    AppointmentView = require('../viewmodels/AppointmentView'),
    UserJobTitle = require('../models/UserJobTitle');

var A = Activity.extends(function DashboardActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
    
    // Getting elements
    this.$nextBooking = this.$activity.find('#dashboardNextBooking');
    this.$upcomingBookings = this.$activity.find('#dashboardUpcomingBookings');
    this.$inbox = this.$activity.find('#dashboardInbox');
    this.$performance = this.$activity.find('#dashboardPerformance');
    this.$getMore = this.$activity.find('#dashboardGetMore');
    
    // TestingData
    setSomeTestingData(this.viewModel);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    var v = this.viewModel,
        app = this.app,
        appModel = this.app.model;
    
    if (this.requestData.completedOnboarding) {
        switch (this.requestData.completedOnboarding) {
            case 'welcome': // Schedule complete
                this.app.modals.showNotification({
                    title: 'Nice work!',
                    message: 'You\'ll now be taken to your dashboard.' +
                        'Please try the following: ' +
                        '1. Activate your marketplace profile ' +
                        '2. Add a fake client using +' +
                        '3. Add a fake booking using +',
                    buttonText: 'Got it'
                });
                break;
        }
    }
    
    var preapareShowErrorFor = function preapareShowErrorFor(title) {
        return function(err) {
            this.app.modals.showError({
                title: title,
                error: err
            });
        }.bind(this);
    }.bind(this);
    
    // Update data
    if (v.upcomingBookings.items().length) {
        v.upcomingBookings.isSyncing(true);
    }
    else {
        v.upcomingBookings.isLoading(true);
    }
    appModel.bookings.getUpcomingBookings()
    .then(function(upcoming) {

        if (upcoming.nextBookingID) {
            var previousID = v.nextBooking() && v.nextBooking().sourceBooking().bookingID();
            if (upcoming.nextBookingID !== previousID) {
                if (v.nextBooking()) {
                    v.nextBooking.isSyncing(true);
                }
                else {
                    v.nextBooking.isLoading(true);
                }
                appModel.calendar.getAppointment({ bookingID: upcoming.nextBookingID })
                .then(function(apt) {
                    v.nextBooking(new AppointmentView(apt, app));
                })
                .catch(preapareShowErrorFor('Error loading next booking'))
                .then(function() {
                    // Finally
                    v.nextBooking.isLoading(false);
                    v.nextBooking.isSyncing(false);
                });
            }
        }
        else {
            v.nextBooking(null);
        }

        v.upcomingBookings.today.quantity(upcoming.today.quantity);
        v.upcomingBookings.today.time(upcoming.today.time && new Date(upcoming.today.time));
        v.upcomingBookings.tomorrow.quantity(upcoming.tomorrow.quantity);
        v.upcomingBookings.tomorrow.time(upcoming.tomorrow.time && new Date(upcoming.tomorrow.time));
        v.upcomingBookings.nextWeek.quantity(upcoming.nextWeek.quantity);
        v.upcomingBookings.nextWeek.time(upcoming.nextWeek.time && new Date(upcoming.nextWeek.time));
    })
    .catch(preapareShowErrorFor('Error loading upcoming bookings'))
    .then(function() {
        // Finally
        v.upcomingBookings.isLoading(false);
        v.upcomingBookings.isSyncing(false);
    });
    
    // Messages
    var MessageView = require('../models/MessageView');
    if (v.inbox.messages().length)
        v.inbox.isSyncing(true);
    else
        v.inbox.isLoading(true);
    appModel.messaging.getList()
    .then(function(threads) {
        v.inbox.messages(threads().map(MessageView.fromThread.bind(null, app)));
    })
    .catch(preapareShowErrorFor('Error loading latest messages'))
    .then(function() {
        // Finally
        v.inbox.isLoading(false);
        v.inbox.isSyncing(false);
    });
    
    this.syncGetMore();
};

A.prototype.syncGetMore = function syncGetMore() {
    // Check the 'profile' alert
    this.app.model.userJobProfile.syncList()
    .then(function(list) {
        var yep = list.some(function(job) {
            if (job.statusID() !== UserJobTitle.status.on)
                return true;
        });
        this.viewModel.getMore.profile(!!yep);
    }.bind(this));
};


var UpcomingBookingsSummary = require('../models/UpcomingBookingsSummary'),
    MailFolder = require('../models/MailFolder'),
    PerformanceSummary = require('../models/PerformanceSummary'),
    GetMore = require('../models/GetMore');

function ViewModel(app) {

    this.upcomingBookings = new UpcomingBookingsSummary();
    this.upcomingBookings.isLoading = ko.observable(false);
    this.upcomingBookings.isSyncing = ko.observable(false);

    this.nextBooking = ko.observable(null);
    this.nextBooking.isLoading = ko.observable(false);
    this.nextBooking.isSyncing = ko.observable(false);
    
    this.inbox = new MailFolder({
        topNumber: 4
    });
    this.inbox.isLoading = ko.observable(false);
    this.inbox.isSyncing = ko.observable(false);
    
    this.performance = new PerformanceSummary();
    
    this.getMore = new GetMore();
    
    this.user = app.model.userProfile.data;
}

/** TESTING DATA **/
function setSomeTestingData(viewModel) {
    
    //viewModel.performance.earnings.currentAmount(2400);
    //viewModel.performance.earnings.nextAmount(6200.54);
    //viewModel.performance.timeBooked.percent(0.93);
    
    var moreData = {};
    if (viewModel.user.isServiceProfessional()) {
        moreData = {
            availability: false,
            payments: false,
            profile: false,
            coop: false
        };
    }
    else {
        moreData = {
            availability: false,
            payments: false,
            profile: false,
            coop: true
        };
    }
    viewModel.getMore.model.updateWith(moreData);
}

},{"../components/Activity":96,"../models/GetMore":112,"../models/MailFolder":119,"../models/MessageView":122,"../models/PerformanceSummary":124,"../models/UpcomingBookingsSummary":141,"../models/UserJobTitle":144,"../viewmodels/AppointmentView":196,"knockout":false}],23:[function(require,module,exports){
/**
    datetimePicker activity
**/
'use strict';

var ko = require('knockout'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

var Activity = require('../components/Activity');

var A = Activity.extends(function DatetimePickerActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel();    
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('', {
        helpId: 'datetimePickerHelp'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject();

    // Return the selected date-time
    ko.computed(function() {
    
        var datetime = this.viewModel.component() && this.viewModel.component().selectedDatetime();
        
        if (datetime) {
            // Pass the selected datetime in the info
            this.requestData.selectedDatetime = datetime;
            this.requestData.allowBookUnavailableTime = this.viewModel.component().allowBookUnavailableTime();
            // And go back
            this.app.shell.goBack(this.requestData);
        }
    }, this);
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    
    var header = this.requestData.headerText;
    this.viewModel.headerText(header || 'Select date and time');

    if (this.requestData.title) {
        // Replace title
        this.navBar.title(this.requestData.title);
    }
    else {
        // Title must be empty
        this.navBar.title('');
        this.navBar.leftAction().text(this.requestData.navTitle || '');
    }
    
    if (this.requestData.cancelLink) {
        this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink);
    }
    else {
        // Reset to defaults, or given title:
        this.navBar.leftAction().model.updateWith(this.defaultLeftAction);
        if (this.requestData.navTitle)
            this.navBar.leftAction().text(this.requestData.navTitle);
        // Uses a custom handler so it returns keeping the given state:
        this.navBar.leftAction().handler(this.returnRequest);
    }
};

A.prototype.show = function show(state) {
    // Reset
    if (this.viewModel.component())
        this.viewModel.component().reset();
    
    Activity.prototype.show.call(this, state);
    
    // Parameters: pass a required duration
    this.viewModel.component().requiredDurationMinutes(this.requestData.requiredDuration |0);

    // Preselect userID and a date, or current date
    this.viewModel.component().userID(this.app.model.user().userID());
    var selDate = getDateWithoutTime(this.requestData.selectedDatetime);
    this.viewModel.component().selectedDate(selDate);
    
    this.updateNavBarState();
};

function ViewModel() {
    this.headerText = ko.observable('Select a time');
    this.component = ko.observable(null);
}

},{"../components/Activity":96,"../utils/getDateWithoutTime":175,"knockout":false}],24:[function(require,module,exports){
/**
    Education activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function EducationActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Marketplace Profile', {
        backLink: '/marketplaceProfile'
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Request a sync and catch any error
    this.app.model.education.sync()
    .catch(function (err) {
        this.app.modals.showError({
            title: 'Error loading education information',
            error: err
        });
    }.bind(this));
};

function ViewModel(app) {

    this.isLoading = app.model.education.state.isLoading;
    this.isSyncing = app.model.education.state.isSyncing;

    this.list = app.model.education.list;
}

},{"../components/Activity":96}],25:[function(require,module,exports){
/**
    EducationForm activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout');

var A = Activity.extends(function EducationFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.loggedUser;

    this.navBar = Activity.createSubsectionNavBar('Education');
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var link = this.requestData.cancelLink || '/education/';
    
    this.convertToCancelAction(this.navBar.leftAction(), link);
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Reset
    this.viewModel.version(null);

    // Params
    var params = state && state.route && state.route.segments || [];
    
    this.viewModel.educationID(params[0] |0);
    
    this.updateNavBarState();
    
    if (this.viewModel.educationID() === 0) {
        // NEW one
        this.viewModel.version(this.app.model.education.newItem());
    }
    else {
        // LOAD
        this.app.model.education.createItemVersion(this.viewModel.educationID())
        .then(function (educationVersion) {
            if (educationVersion) {
                this.viewModel.version(educationVersion);
            } else {
                throw new Error('No data');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            })
            .then(function() {
                // On close modal, go back
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));
    }
};

function ViewModel(app) {

    this.educationID = ko.observable(0);
    this.isLoading = app.model.education.state.isLoading;
    this.isSaving = app.model.education.state.isSaving;
    this.isSyncing = app.model.education.state.isSyncing;
    this.isDeleting = app.model.education.state.isDeleting;
    this.isLocked = ko.computed(function() {
        return this.isDeleting() || app.model.education.state.isLocked();
    }, this);
    
    this.version = ko.observable(null);
    this.item = ko.pureComputed(function() {
        var v = this.version();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        var p = this.item();
        return p && !p.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.version();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        'Save changes' :
                        'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.version();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {
        app.model.education.setItem(this.item().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.item().model.updateWith(serverData);
            // Push version so it appears as saved
            this.version().push({ evenIfObsolete: true });
            // Go out
            app.successSave();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        // L18N
        app.modals.confirm({
            title: 'Delete',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {
        app.model.education.delItem(this.educationID())
        .then(function() {
            // Go out
            // TODO: custom message??
            app.successSave();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    this.yearsOptions = ko.computed(function() {
        var l = [];
        for (var i = new Date().getFullYear(); i > 1900; i--) {
            l.push(i);
        }
        return l;
    });
}

},{"../components/Activity":96,"knockout":false}],26:[function(require,module,exports){
/**
    Faqs activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function FaqsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel();
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
    
    // TestingData
    //setSomeTestingData(this.viewModel);
    this.currentLabels = '';
    this.loadArticles = function() {
        var url = 'https://loconomics.zendesk.com/api/v2/help_center/articles.json?label_names=' + encodeURIComponent(this.currentLabels);
        this.viewModel.isLoading(true);
        
        var $ = require('jquery');
        Promise.resolve($.get(url)).then(function(res) {
            if (res) {
                this.viewModel.faqs(res.articles.map(function(art) {
                    return new Faq({
                        id: art.id,
                        title: art.title,
                        description: art.body
                    });
                }));
            }
            else {
                this.viewModel.faqs([]);
            }
            this.viewModel.isLoading(false);
        }.bind(this))
        .catch(function(/*err*/) {
            this.viewModel.isLoading(false);
        }.bind(this));
    }.bind(this);
});

exports.init = A.init;

A.prototype.show = function show(state) {
    
    Activity.prototype.show.call(this, state);
    
    this.viewModel.searchText('');
    this.loadArticles();
};

var ko = require('knockout');

function ViewModel() {

    this.faqs = ko.observableArray([]);
    this.searchText = ko.observable('');
    this.isLoading = ko.observable(false);
    
    this.filteredFaqs = ko.pureComputed(function() {
        var s = this.searchText().toLowerCase();
        return this.faqs().filter(function(v) {
            var n = v && v.title() || '';
            n += v && v.description() || '';
            n = n.toLowerCase();
            return n.indexOf(s) > -1;
        });
    }, this);
}

var Model = require('../models/Model');
function Faq(values) {
    
    Model(this);

    this.model.defProperties({
        id: 0,
        title: '',
        description: ''
    }, values);
}

/** TESTING DATA **/
//function setSomeTestingData(viewModel) {
//    
//    var testdata = [
//        new Faq({
//            id: 1,
//            title: 'How do I set up a marketplace profile?',
//            description: 'Description about how I set up a marketplace profile'
//        }),
//        new Faq({
//            id: 2,
//            title: 'Another faq',
//            description: 'Another description'
//        })
//    ];
//    viewModel.faqs(testdata);
//}


},{"../components/Activity":96,"../models/Model":123,"knockout":false}],27:[function(require,module,exports){
/**
    Feedback activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function FeedbackActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSectionNavBar('Talk to us');
});

exports.init = A.init;

},{"../components/Activity":96}],28:[function(require,module,exports){
/**
    FeedbackForm activity
**/
'use strict';

var Activity = require('../components/Activity'),
    VocElementEnum = require('../models/VocElementEnum');

var A = Activity.extends(function FeedbackFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Talk to us');
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    var params = this.requestData.route.segments || [];
    var elementName = params[0] || '',
        elementID = VocElementEnum[elementName] |0;
    
    if (!elementName) {
        console.log('Feedback Ideas: Accessing feedback without specify an element, using General (0)');
    }
    else if (!VocElementEnum.hasOwnProperty(elementName)) {
        console.error('Feedback Ideas: given a bad VOC Element name:', elementName);
    }

    this.viewModel.vocElementID(elementID);
};

var ko = require('knockout');
function ViewModel(app) {
    
    this.message = ko.observable('');
    this.becomeCollaborator = ko.observable(false);
    this.wasSent = ko.observable(false);
    this.isSending = ko.observable(false);
    this.vocElementID = ko.observable(0);

    var updateWasSent = function() {
        this.wasSent(false);
    }.bind(this);
    this.message.subscribe(updateWasSent);
    this.becomeCollaborator.subscribe(updateWasSent);
    
    this.submitText = ko.pureComputed(function() {
        return this.isSending() ? 'Sending..' : this.wasSent() ? 'Sent' : 'Send';
    }, this);
    
    this.send = function send() {
        this.isSending(true);
        app.model.feedback.postIdea({
            message: this.message(),
            becomeCollaborator: this.becomeCollaborator(),
            vocElementID: this.vocElementID()
        })
        .then(function() {
            // Reset after being sent
            this.message('');
            this.becomeCollaborator(false);
            this.wasSent(true);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error sending your feedback',
                error: err
            });
        })
        .then(function() {
            // Always
            this.isSending(false);
        }.bind(this));
    }.bind(this);
}

},{"../components/Activity":96,"../models/VocElementEnum":149,"knockout":false}],29:[function(require,module,exports){
/**
    Home activity (aka Search)
**/
'use strict';

var Activity = require('../components/Activity'),
    snapPoints = require('../utils/snapPoints');

var A = Activity.extends(function HomeActivity() {

    Activity.apply(this, arguments);
    this.navBar = null;
    this.accessLevel = null;
    this.viewModel = {
        isAnonymous: this.app.model.user().isAnonymous
    };
    var $header = this.$header = this.$activity.find('header');

    this.registerHandler({
        target: this.$activity,
        event: 'scroll-fixed-header',
        handler: function(e, what) {
            if (what === 'after') {
                $header.addClass('is-fixed');
            }
            else {
                $header.removeClass('is-fixed');
            }
        }
    });

    this.registerHandler({
        target: this.$activity,
        event: 'scroll-search',
        handler: function(e, what) {
            if (what === 'after') {
                $header.addClass('is-search');
            }
            else {
                $header.removeClass('is-search');
            }
        }
    });
});

exports.init = A.init;

A.prototype._registerSnapPoints = function() {

    var $searchBox = this.$activity.find('#homeSearch'),
        // Calculate the position where search box is completely hidden, and get 1 on the worse case -- bad value coerced to 0,
        // negative result because some lack of data (content hidden)
        searchPoint = Math.max(1, (
            // Top offset with the scrolling area plus current scrollTop to know the actual position inside the positioning context
            // (is an issue if the section is showed with scroll applied on the activity)
            $searchBox.offset().top + this.$activity.scrollTop() +
            // Add the box height but sustract the header height because that is fixed and overlaps
            $searchBox.outerHeight() - this.$header.outerHeight()
        ) |0);
    
    var pointsEvents = {
        // Just after start scrolling
        0: 'scroll-fixed-header'
    };
    pointsEvents[searchPoint] = 'scroll-search';

    snapPoints(this.$activity, pointsEvents);
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    if (!this._notFirstShow) {
        this._registerSnapPoints();
        this._notFirstShow = true;
    }
};

},{"../components/Activity":96,"../utils/snapPoints":192}],30:[function(require,module,exports){
/**
    Inbox activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout'),
    MessageView = require('../models/MessageView'),
    textSearch = require('../utils/textSearch');

var A = Activity.extends(function InboxActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSectionNavBar('Inbox');
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Messages
    this.app.model.messaging.getList()
    .then(function(threads) {
        this.viewModel.sourceThreads(threads());
    }.bind(this))
    .catch(function(err) {
        this.app.modals.showError({
            title: 'Error loading messages',
            error: err
        });
    }.bind(this));
};

function ViewModel(app) {
    
    this.isLoading = app.model.messaging.state.isLoading;
    this.isSyncing = app.model.messaging.state.isSyncing;

    this.sourceThreads = ko.observableArray([]);
    
    this.searchText = ko.observable('');
    
    // NOTE: since current API-connection implementation only gets
    // the latest message with getList, the search is done in the
    // bodyText of the last message (additionally to the thread subject)
    // even if this implementation try to iterate all messages.
    this.threads = ko.pureComputed(function() {
        var t = this.sourceThreads(),
            s = this.searchText();

        if (!t)
            return [];
        else if (!s)
            return t.map(MessageView.fromThread.bind(null, app));
        else        
            return t.filter(function(thread) {
                var found = false;
                
                // Check subject
                found = textSearch(s, thread.subject());
                
                if (!found) {
                    // Try content of messages
                    // It stops on first 'true' result
                    thread.messages().some(function(msg) {
                        found = textSearch(s, msg.bodyText());
                        return found;
                    });
                }
                
                return found;
            }).map(MessageView.fromThread.bind(null, app));
    }, this);
}

},{"../components/Activity":96,"../models/MessageView":122,"../utils/textSearch":193,"knockout":false}],31:[function(require,module,exports){
/**
    Index activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function IndexActivity() {
    
    Activity.apply(this, arguments);

    // Any user can access this
    this.accessLevel = null;
    
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
    this.navBar.rightAction(null);
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // It checks if the user is logged so then 
    // their 'logged index' is the dashboard not this
    // page that is focused on anonymous users
    if (!this.app.model.user().isAnonymous()) {
        this.app.goDashboard();
    }
};

},{"../components/Activity":96}],32:[function(require,module,exports){
/**
    Jobtitles activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout');

var A = Activity.extends(function JobtitlesActivity() {
    
    Activity.apply(this, arguments);
    
    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: '/scheduling'
    });
    
    // On changing jobTitleID:
    // - load addresses
    // - load job title information
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {

            if (jobTitleID) {
                ////////////
                // Addresses
                this.app.model.serviceAddresses.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.serviceAddresses.asModel(list);
                    this.viewModel.addresses(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading addresses.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Pricing/Services
                this.app.model.serviceProfessionalServices.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.serviceProfessionalServices.asModel(list);
                    this.viewModel.pricing(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading services.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Job Title
                // Get data for the Job title ID
                this.app.model.jobTitles.getJobTitle(jobTitleID)
                .then(function(jobTitle) {

                    // Fill in job title name
                    this.viewModel.jobTitleName(jobTitle.singularName());
                }.bind(this))
                .catch(function(err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading the job title.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.addresses([]);
                this.viewModel.pricing([]);
                this.viewModel.jobTitleName('Job Title');
            }
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);

    // Parameters
    var params = state && state.route && state.route.segments || {};
    
    // Set the job title
    var jobID = params[0] |0;
    this.viewModel.jobTitleID(jobID);
};

function ViewModel(app) {
    
    this.jobTitleID = ko.observable(0);
    this.jobTitleName = ko.observable('Job Title');
    
    // Retrieves a computed that will link to the given named activity adding the current
    // jobTitleID and a mustReturn URL to point this page so its remember the back route
    this.getJobUrlTo = function(name) {
        // Sample '/serviceProfessionalServices/' + jobTitleID()
        return ko.pureComputed(function() {
            return (
                '/' + name + '/' + this.jobTitleID() + '?mustReturn=jobtitles/' + this.jobTitleID() +
                '&returnText=' + this.jobTitleName()
            );
        }, this);
    };
    
    this.addresses = ko.observable([]);
    this.pricing = ko.observable([]);

    // Computed since it can check several externa loadings
    this.isLoading = ko.pureComputed(function() {
        return (
            app.model.serviceAddresses.state.isLoading() ||
            app.model.serviceProfessionalServices.state.isLoading()
        );
        
    }, this);
    
    this.addressesCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.addresses().length,
            one = '1 location',
            more = ' locations';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
    this.pricingCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.pricing().length,
            one = '1 service',
            more = ' services';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
}

},{"../components/Activity":96,"knockout":false}],33:[function(require,module,exports){
/**
    LearnMore activity
**/
'use strict';
var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function LearnMoreActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = new ViewModel(this.app);
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
    this.navBar.rightAction(null);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    if (options && options.route &&
        options.route.segments &&
        options.route.segments.length) {
        this.viewModel.profile(options.route.segments[0]);
    }
};

function ViewModel() {
    this.profile = ko.observable('client');
}

},{"../components/Activity":96,"knockout":false}],34:[function(require,module,exports){
/**
    LicensesCertifications activity
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    Activity = require('../components/Activity');

var A = Activity.extends(function LicensesCertificationsActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Job Title');

    // On changing jobTitleID:
    // - load licenses/certifications
    /* TODO Uncomment and update on implementing REST API AppModel
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID
                this.app.model.licensesCertifications.getList(jobTitleID)
                .then(function(list) {
                    // Save for use in the view
                    this.viewModel.list(list);
                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.list([]);
            }
        }.bind(this)
    });*/
    // TODO Remove on implemented REST API
    this.viewModel.list(testdata());
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    var params = options && options.route && options.route.segments;
    this.viewModel.jobTitleID(params[0] |0);
};

function ViewModel(app) {

    this.jobTitleID = ko.observable(0);
    this.list = ko.observableArray([]);
    
    this.isSyncing = app.model.licensesCertifications.state.isSyncing();
    this.isLoading = app.model.licensesCertifications.state.isLoading();

    this.addNew = function() {
        var url = '#!licensesCertificationsForm/' + this.jobTitleID(),
            cancelUrl = app.shell.currentRoute.url;
        var request = $.extend({}, this.requestData, {
            cancelLink: cancelUrl
        });
        app.shell.go(url, request);
    }.bind(this);
    
    this.selectItem = function(item) {
        var url = '/licensesCertificationsForm/' + this.jobTitleID() + '/' +
            item.licenseCertificationID() + '?mustReturn=' + 
            encodeURIComponent(app.shell.currentRoute.url) +
            '&returnText=' + encodeURIComponent('Certifications/Licenses');
        app.shell.go(url, this.requestData);
    }.bind(this);
}


               
// TODO SAME CODE AS IN verifications activity, to refactor and share
var Model = require('../models/Model');
function Verification(values) {
    Model(this);
    
    this.model.defProperties({
        name: ''
    }, values);
}
Verification.status = {
    confirmed: 1,
    pending: 2,
    revoked: 3,
    obsolete: 4
};
function enumGetName(value, enumList) {
    var found = null;
    Object.keys(enumList).some(function(k) {
        if (enumList[k] === value) {
            found = k;
            return true;
        }
    });
    return found;
}


/// TESTDATA
var UserLicenseCertification = require('../models/UserLicenseCertification');
var LicenseCertification = require('../models/LicenseCertification');
function testdata() {
    
    var base = {
        17: new LicenseCertification({
            licenseCertificationID: 17,
            name: 'Certified Massage Therapist (CMT)',
            stateProvinceID: 1,
            countryID: 1,
            description: 'Required to complete at least 500 hours of massage education and training at an approved massage therapy school.  CMTs also must undergo background checks, including fingerprinting and other identification verification procedures.',
            authority: 'The California Massage Therapy Council (CAMTC)',
            verificationWebsiteUrl: 'https://www.camtc.org/VerifyCertification.aspx',
            howToGetLicensedUrl: 'https://www.camtc.org/FormDownloads/CAMTCApplicationChecklist.pdf',
            optionGroup: 'Certified Massage',
            createdDate: new Date(),
            updatedDate: new Date()
        }),
        18: new LicenseCertification({
            licenseCertificationID: 18,
            name: 'Certified Massage Practitioner (CMP)',
            stateProvinceID: 1,
            countryID: 1,
            description: 'Generally must complete at least 250 hours of education and training.  CMPs also must undergo background checks, including fingerprinting and other identification verification procedures.',
            authority: 'The California Massage Therapy Council (CAMTC)',
            verificationWebsiteUrl: 'https://www.camtc.org/VerifyCertification.aspx',
            howToGetLicensedUrl: 'https://www.camtc.org/FormDownloads/CAMTCApplicationChecklist.pdf',
            optionGroup: 'Certified Massage',
            createdDate: new Date(),
            updatedDate: new Date()
        })
    };
    
    // Augment Model with related info
    function augment(m) {
        m.licenseCertification = ko.computed(function() {
            return base[this.licenseCertificationID()] || null;
        }, m);
        
        // TODO statusText and isStatus copied from verifications, dedupe/refactor
        m.statusText = ko.pureComputed(function() {
            // L18N
            var statusTextsenUS = {
                'verification.status.confirmed': 'Confirmed',
                'verification.status.pending': 'Pending',
                'verification.status.revoked': 'Revoked',
                'verification.status.obsolete': 'Obsolete'
            };
            var statusCode = enumGetName(this.statusID(), Verification.status);
            return statusTextsenUS['verification.status.' + statusCode];
        }, m);

        /**
            Check if verification has a given status by name
        **/
        m.isStatus = function (statusName) {
            var id = this.statusID();
            return Verification.status[statusName] === id;
        }.bind(m);
        
        return m;
    }

    return [
        augment(new UserLicenseCertification({
            userID: 141,
            jobTitleID: 106,
            statusID: 2,
            licenseCertificationID: 18,
            licenseCertificationNumber: 21341234,
            stateProvinceID: 1,
            countryID: 1,
            expirationDate: new Date(2016, 1, 20),
            lastVerifiedDate: new Date(2015, 3, 20),
            createdDate: new Date(),
            updatedDate: new Date()
        })),
        augment(new UserLicenseCertification({
            userID: 141,
            jobTitleID: 106,
            statusID: 1,
            licenseCertificationID: 17,
            licenseCertificationNumber: 987654321,
            stateProvinceID: 1,
            countryID: 1,
            expirationDate: new Date(2016, 1, 20),
            lastVerifiedDate: new Date(2015, 3, 20),
            createdDate: new Date(),
            updatedDate: new Date()
        }))
    ];
}

},{"../components/Activity":96,"../models/LicenseCertification":117,"../models/Model":123,"../models/UserLicenseCertification":146,"knockout":false}],35:[function(require,module,exports){
/**
    LicensesCertificationsForm activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout');

var A = Activity.extends(function LicensesCertificationsFormActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.serviceProfessional;

    this.navBar = Activity.createSubsectionNavBar('Certifications/Licenses');
    this.defaultNavBarSettings = this.navBar.model.toPlainObject(true);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var link = this.requestData.cancelLink || '/licensesCertifications/';
    
    if (this.viewModel.isNew())
        this.convertToCancelAction(this.navBar.leftAction(), link);
    else
        this.navBar.model.updateWith(this.defaultNavBarSettings, true);
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Reset
    this.viewModel.version(null);

    // Params
    var params = state && state.route && state.route.segments || [];
    
    this.viewModel.jobTitleID(params[0] |0);
    this.viewModel.licenseCertificationID(params[1] |0);
    
    this.updateNavBarState();
    
    // TODO Remove when AppModel
    var ModelVersion = require('../utils/ModelVersion'),
        UserLicenseCertification = require('../models/UserLicenseCertification');
    
    if (this.viewModel.isNew()) {
        this.viewModel.version(new ModelVersion(new UserLicenseCertification()));
    }
    else {
        this.viewModel.version(new ModelVersion(new UserLicenseCertification({
            userID: 141,
            jobTitleID: 106,
            statusID: 2,
            licenseCertificationID: 18,
            licenseCertificationNumber: 21341234,
            stateProvinceID: 1,
            countryID: 1,
            expirationDate: new Date(2016, 1, 20),
            lastVerifiedDate: new Date(2015, 3, 20),
            createdDate: new Date(),
            updatedDate: new Date()
        })));
    }
    
    
    // TODO IT DOES NOT WORKS THIS WAY: in the website dahsboard, the licenseID is provided
    // to the form, because there is a short list of them available, NOT auto-generated.
    // CHECK if put a dropdown selection or list selection here and then show the form or 
    // put the list of possible on the listing page (at /licensesCertifications)
    
    if (this.viewModel.licenseCertificationID() === 0) {
        // NEW one
        /* TODO Uncomment when AppModel
        this.viewModel.version(this.app.model.licensesCertifications.newItem());
        */
    }
    else {
        // LOAD
        /* TODO Uncomment when AppModel
        this.app.model.education.createItemVersion(this.viewModel.educationID())
        .then(function (educationVersion) {
            if (educationVersion) {
                this.viewModel.version(educationVersion);
            } else {
                throw new Error('No data');
            }
        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            })
            .then(function() {
                // On close modal, go back
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));*/
    }
};

function ViewModel(app) {

    this.licenseCertificationID = ko.observable(0);
    this.jobTitleID = ko.observable(0);
    // TODO Uncomment when appmodel
    this.isLoading = ko.observable(false); // app.model.licensesCertifications.state.isLoading;
    this.isSaving = ko.observable(false); //app.model.licensesCertifications.state.isSaving;
    this.isSyncing = ko.observable(false); //app.model.licensesCertifications.state.isSyncing;
    this.isDeleting = ko.observable(false); //app.model.licensesCertifications.state.isDeleting;
    this.isLocked = ko.observable(false); /*ko.computed(function() {
        return this.isDeleting() || app.model.licensesCertifications.state.isLocked();
    }, this);*/
    
    this.isNew = ko.pureComputed(function() {
        return this.licenseCertificationID() === 0;
    }, this);
    
    this.version = ko.observable(null);
    this.item = ko.pureComputed(function() {
        var v = this.version();
        if (v) {
            return v.version;
        }
        return null;
    }, this);
    
    // Fields for the new-certification-file
    this.stateProvinceID = ko.observable(0);
    this.file = ko.observable('');

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.version();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {
        app.model.licensesCertifications.setItem(this.item().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.item().model.updateWith(serverData);
            // Push version so it appears as saved
            this.version().push({ evenIfObsolete: true });
            // Go out
            app.successSave();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        // L18N
        app.modals.confirm({
            title: 'Delete',
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {
        app.model.licensesCertifications.delItem(this.jobTitleID(), this.licenseCertificationID())
        .then(function() {
            // Go out
            // TODO: custom message??
            app.successSave();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
    
    // TODO COMPLETE; FROM A MODEL, REMOTE?
    this.statesProvinces = ko.computed(function() {
        // BLOB copy:
        return [{"stateProvinceID":"23","name":"Alabama"},{"stateProvinceID":"49","name":"Alaska"},{"stateProvinceID":"52","name":"American Samoa"},{"stateProvinceID":"48","name":"Arizona"},{"stateProvinceID":"26","name":"Arkansas"},{"stateProvinceID":"60","name":"Armed Forces Americas (except Canada)"},{"stateProvinceID":"61","name":"Armed Forces Canada, Europe, Middle East, and Africa"},{"stateProvinceID":"62","name":"Armed Forces Pacific"},{"stateProvinceID":"1","name":"California"},{"stateProvinceID":"38","name":"Colorado"},{"stateProvinceID":"6","name":"Connecticut"},{"stateProvinceID":"2","name":"Delaware"},{"stateProvinceID":"51","name":"District of Columbia"},{"stateProvinceID":"57","name":"Federated States of Micronesia"},{"stateProvinceID":"28","name":"Florida"},{"stateProvinceID":"5","name":"Georgia"},{"stateProvinceID":"53","name":"Guam"},{"stateProvinceID":"50","name":"Hawaii"},{"stateProvinceID":"43","name":"Idaho"},{"stateProvinceID":"22","name":"Illinois"},{"stateProvinceID":"20","name":"Indiana"},{"stateProvinceID":"30","name":"Iowa"},{"stateProvinceID":"34","name":"Kansas"},{"stateProvinceID":"16","name":"Kentucky"},{"stateProvinceID":"19","name":"Louisiana"},{"stateProvinceID":"24","name":"Maine"},{"stateProvinceID":"58","name":"Marshall Islands"},{"stateProvinceID":"8","name":"Maryland"},{"stateProvinceID":"7","name":"Massachusetts"},{"stateProvinceID":"27","name":"Michigan"},{"stateProvinceID":"32","name":"Minnesota"},{"stateProvinceID":"21","name":"Mississippi"},{"stateProvinceID":"25","name":"Missouri"},{"stateProvinceID":"41","name":"Montana"},{"stateProvinceID":"37","name":"Nebraska"},{"stateProvinceID":"36","name":"Nevada"},{"stateProvinceID":"10","name":"New Hampshire"},{"stateProvinceID":"4","name":"New Jersey"},{"stateProvinceID":"47","name":"New Mexico"},{"stateProvinceID":"12","name":"New York"},{"stateProvinceID":"13","name":"North Carolina"},{"stateProvinceID":"39","name":"North Dakota"},{"stateProvinceID":"54","name":"Northern Mariana Islands"},{"stateProvinceID":"18","name":"Ohio"},{"stateProvinceID":"46","name":"Oklahoma"},{"stateProvinceID":"33","name":"Oregon"},{"stateProvinceID":"59","name":"Palau"},{"stateProvinceID":"3","name":"Pennsylvania"},{"stateProvinceID":"55","name":"Puerto Rico"},{"stateProvinceID":"14","name":"Rhode Island"},{"stateProvinceID":"9","name":"South Carolina"},{"stateProvinceID":"40","name":"South Dakota"},{"stateProvinceID":"17","name":"Tennessee"},{"stateProvinceID":"29","name":"Texas"},{"stateProvinceID":"56","name":"U.S. Virgin Islands"},{"stateProvinceID":"45","name":"Utah"},{"stateProvinceID":"15","name":"Vermont"},{"stateProvinceID":"11","name":"Virginia"},{"stateProvinceID":"42","name":"Washington"},{"stateProvinceID":"35","name":"West Virginia"},{"stateProvinceID":"31","name":"Wisconsin"},{"stateProvinceID":"44","name":"Wyoming"}];
    });
}

},{"../components/Activity":96,"../models/UserLicenseCertification":146,"../utils/ModelVersion":161,"knockout":false}],36:[function(require,module,exports){
/**
    Login activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function LoginActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.anonymous;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Log in');
    this.navBar.rightAction(null);
    
    // Perform log-in request when is requested by the form:
    this.registerHandler({
        target: this.viewModel.isLogingIn,
        handler: function(v) {
            if (v === true) {

                // Perform loging

                // Notify state:
                var $btn = this.$activity.find('[type="submit"]');
                $btn.button('loading');

                // Clear previous error so makes clear we
                // are attempting
                this.viewModel.loginError('');

                var ended = function ended() {
                    this.viewModel.isLogingIn(false);
                    $btn.button('reset');
                }.bind(this);

                // After clean-up error (to force some view updates),
                // validate and abort on error
                // Manually checking error on each field
                if (this.viewModel.username.error() ||
                    this.viewModel.password.error()) {
                    this.viewModel.loginError('Review your data');
                    ended();
                    return;
                }

                this.app.model.login(
                    this.viewModel.username(),
                    this.viewModel.password()
                ).then(function(/*loginData*/) {

                    this.viewModel.loginError('');
                    ended();

                    // Remove form data
                    this.viewModel.username('');
                    this.viewModel.password('');
                    
                    if (this.requestData && this.requestData.redirectUrl)
                        this.app.shell.go(this.requestData.redirectUrl);
                    else
                        this.app.goDashboard();

                }.bind(this)).catch(function(err) {

                    var msg = err && err.responseJSON && err.responseJSON.errorMessage ||
                        err && err.statusText ||
                        'Invalid username or password';

                    this.viewModel.loginError(msg);
                    ended();
                }.bind(this));
            }
        }.bind(this)
    });
    
    // Focus first bad field on error
    this.registerHandler({
        target: this.viewModel.loginError,
        handler: function(err) {
            // Login is easy since we mark both unique fields
            // as error on loginError (its a general form error)
            var input = this.$activity.find(':input').get(0);
            if (err)
                input.focus();
            else
                input.blur();
        }.bind(this)
    });
    
    this.viewModel.facebook = function() {
        var fb = require('../utils/facebookUtils');
        
        // Notify state:
        var $btn = this.$activity.find('[type="submit"]');
        $btn.button('loading');

        // Clear previous error so makes clear we
        // are attempting
        this.viewModel.loginError('');

        
        var ended = function ended() {
            this.viewModel.isLogingIn(false);
            $btn.button('reset');
        }.bind(this);

        // email,user_about_me
        fb.login({ scope: 'email' })
        .then(function (result) {
            return this.app.model.facebookLogin(result.auth.accessToken)
            .then(function(/*loginData*/) {
                this.viewModel.loginError('');
                ended();

                // Remove form data
                this.viewModel.username('');
                this.viewModel.password('');

                if (this.requestData && this.requestData.redirectUrl)
                    this.app.shell.go(this.requestData.redirectUrl);
                else
                    this.app.goDashboard();

            }.bind(this));
        })
        .catch(function(err) {

            var msg = err && err.responseJSON && err.responseJSON.errorMessage ||
                err && err.statusText ||
                'Invalid login';

            this.viewModel.loginError(msg);
            ended();
        }.bind(this));
    }.bind(this);
});

exports.init = A.init;

var FormCredentials = require('../viewmodels/FormCredentials');

function ViewModel() {

    var credentials = new FormCredentials();    
    this.username = credentials.username;
    this.password = credentials.password;

    this.loginError = ko.observable('');
    
    this.isLogingIn = ko.observable(false);
    
    this.performLogin = function performLogin() {

        this.isLogingIn(true);        
    }.bind(this);
}

},{"../components/Activity":96,"../utils/facebookUtils":174,"../viewmodels/FormCredentials":199,"knockout":false}],37:[function(require,module,exports){
/**
    Logout activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function LogoutActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    this.app.model.logout().then(function() {
        // Anonymous user again
        var newAnon = this.app.model.user().constructor.newAnonymous();
        this.app.model.user().model.updateWith(newAnon);

        // Go index
        this.app.shell.go('/');
        
    }.bind(this));
};

},{"../components/Activity":96}],38:[function(require,module,exports){
/**
    MarketplaceJobtitles activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout');

var A = Activity.extends(function MarketplaceJobtitlesActivity() {
    
    Activity.apply(this, arguments);
    
    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Marketplace profile', {
        backLink: '/marketplaceProfile'
    });

    // On changing jobTitleID:
    // - load addresses
    // - load job title information
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {

            if (jobTitleID) {
                ////////////
                // Addresses
                this.app.model.serviceAddresses.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.serviceAddresses.asModel(list);
                    this.viewModel.addresses(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading addresses.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Pricing/Services
                this.app.model.serviceProfessionalServices.getList(jobTitleID)
                .then(function(list) {

                    list = this.app.model.serviceProfessionalServices.asModel(list);
                    this.viewModel.pricing(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading services.',
                        error: err
                    });
                }.bind(this));
                
                ////////////
                // Job Title
                // Get data for the Job Title and User Profile
                this.app.model.userJobProfile.getUserJobTitleAndJobTitle(jobTitleID)
                //this.app.model.jobTitles.getJobTitle(jobTitleID)
                .then(function(job) {
                    // Fill the job title record
                    this.viewModel.jobTitle(job.jobTitle);
                    this.viewModel.userJobTitle(job.userJobTitle);
                }.bind(this))
                .catch(function(err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading your job title.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.addresses([]);
                this.viewModel.pricing([]);
            }
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);

    // Parameters
    var params = state && state.route && state.route.segments || {};
    
    // Set the job title
    var jobID = params[0] |0;
    this.viewModel.jobTitleID(jobID);
};

function ViewModel(app) {
    
    this.jobTitleID = ko.observable(0);
    this.jobTitle = ko.observable(null);
    this.userJobTitle = ko.observable(null);
    this.jobTitleName = ko.pureComputed(function() {
        var j = this.jobTitle();
        return j && j.singularName() || 'Job Title';
    }, this);
    
    // Retrieves a computed that will link to the given named activity adding the current
    // jobTitleID and a mustReturn URL to point this page so its remember the back route
    this.getJobUrlTo = function(name) {
        // Sample '/serviceProfessionalServices/' + jobTitleID()
        return ko.pureComputed(function() {
            return (
                '/' + name + '/' + this.jobTitleID() + '?mustReturn=marketplaceJobtitles/' + this.jobTitleID() +
                '&returnText=' + encodeURIComponent(this.jobTitleName())
            );
        }, this);
    };
    
    this.isActiveStatus = ko.pureComputed({
        read: function() {
            var j = this.userJobTitle();
            return j && j.statusID() === 1 || false;
        },
        write: function(v) {
            var status = this.userJobTitle() && this.userJobTitle().statusID();
            if (v === true && status === 3) {
                this.userJobTitle().statusID(1);
                // Push change to back-end
                app.model.userJobProfile.reactivateUserJobTitle(this.jobTitleID())
                .catch(function(err) {
                    app.modals.showError({ title: 'Error enabling a Job Title', error: err });
                });
            }
            else if (v === false && status === 1) {
                this.userJobTitle().statusID(3);
                // Push change to back-end
                app.model.userJobProfile.deactivateUserJobTitle(this.jobTitleID())
                .catch(function(err) {
                    app.modals.showError({ title: 'Error disabling a Job Title', error: err });
                });
            }
        },
        owner: this
    });
    
    this.statusLabel = ko.pureComputed(function() {
        return this.isActiveStatus() ? 'ON' : 'OFF';
    }, this);
    
    this.cancellationPolicyLabel = ko.pureComputed(function() {
        var pid = this.userJobTitle() && this.userJobTitle().cancellationPolicyID();
        // TODO fetch policy ID label
        return pid === 3 ? 'Flexible' : pid === 2 ? 'Moderate' : 'Strict';
    }, this);
    
    this.instantBooking = ko.pureComputed(function() {
        return this.userJobTitle() && this.userJobTitle().instantBooking();
    }, this);
    
    this.instantBookingLabel = ko.pureComputed(function() {
        return this.instantBooking() ? 'ON' : 'OFF';
    }, this);
    
    this.toggleInstantBooking = function() {
        var current = this.instantBooking();
        if (this.userJobTitle()) {
            // Change immediately, while saving in background
            this.userJobTitle().instantBooking(!current);
            // Push change to server
            var plain = this.userJobTitle().model.toPlainObject();
            plain.instantBooking = !current;

            app.model.userJobProfile.setUserJobTitle(plain)
            .catch(function(err) {
                app.modals.showError({ title: 'Error saving Instant Booking preference', error: err });
                // On error, original value must be restored (so can attempt to change it again)
                this.userJobTitle().instantBooking(current);
            }.bind(this));
        }
    };

    /// Related models information
    
    this.addresses = ko.observable([]);
    this.pricing = ko.observable([]);
    this.licenseCertifications = ko.observable([]);
    this.workPhotos = ko.observable([]);

    // Computed since it can check several externa loadings
    this.isLoading = ko.pureComputed(function() {
        return (
            app.model.serviceAddresses.state.isLoading() ||
            app.model.serviceProfessionalServices.state.isLoading()
        );
        
    }, this);
    
    this.addressesCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.addresses().length,
            one = '1 location',
            more = ' locations';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
    this.pricingCount = ko.pureComputed(function() {
        
        // TODO l10n.
        // Use i18next plural localization support rather than this manual.
        var count = this.pricing().length,
            one = '1 service',
            more = ' services';
        
        if (count === 1)
            return one;
        else
            // Small numbers, no need for formatting
            return count + more;

    }, this);
    
    this.licensesCertificationsSummary = ko.pureComputed(function() {
        var lc = this.licenseCertifications();
        if (lc && lc.length) {
            // TODO Detect 
            var verified = 0,
                pending = 0;
            lc.forEach(function(l) {
                if (l && l.statusID() === 1)
                    verified++;
                else if (l && l.statusID() === 2)
                    pending++;
            });
            // L18N
            return verified + ' verified, ' + pending + ' pending';
        }
        else {
            // L18N
            return 'There are not verifications';
        }
    }, this);
    
    this.workPhotosSummary = ko.pureComputed(function() {
        var wp = this.workPhotos();
        // L18N
        if (wp && wp.length > 1)
            return wp.length + ' images';
        else if (wp && wp.length === 1)
            return '1 image';
        else
            return 'No images';
    }, this);
    
}

},{"../components/Activity":96,"knockout":false}],39:[function(require,module,exports){
/**
    MarketplaceProfile activity
**/
'use strict';

var Activity = require('../components/Activity'),
    UserJobProfileViewModel = require('../viewmodels/UserJobProfile'),
    ko = require('knockout'),
    moment = require('moment');

var A = Activity.extends(function MarketplaceProfileActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Marketplace Profile');
    
    this.viewModel.showMarketplaceInfo(true);
    this.viewModel.baseUrl('/marketplaceJobtitles');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    if (this.viewModel.user.isServiceProfessional())
        this.viewModel.sync();
};

function ViewModel(app) {
    // Just use the job profile view model (created for the job title listing
    // at 'scheduling'), instance, extend and return
    var jobVm = new UserJobProfileViewModel(app);
    
    // TODO read verifications count from model; computed
    jobVm.verificationsCount = ko.observable(3);
    
    jobVm.displayedVerificationsNumber = ko.computed(function() {
        var verificationsCount = this.verificationsCount();
        // Format
        // L18N
        return '(' + verificationsCount + ')';
    }, jobVm);

    jobVm.verificationsSecondaryText = ko.computed(function() {
        // TODO read count limit
        var verificationsLimit = 10,
            count = this.verificationsCount(),
            remaining = verificationsLimit - count;
        // Format
        // L18N
        return remaining > 0 ? 'You can add up to ' + remaining + ' more' : 'You cannot add more';
    }, jobVm);
    
    jobVm.displayedLastBackgroundCheck = ko.computed(function() {
        // TODO read last check date
        var lastDate = new Date(2014, 10, 14);
        return moment(lastDate).format('L');
    }, jobVm);
    
    jobVm.user = app.model.userProfile.data;

    return jobVm;
}

},{"../components/Activity":96,"../viewmodels/UserJobProfile":207,"knockout":false,"moment":false}],40:[function(require,module,exports){
/**
    OwnerInfo activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function OwnerInfoActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.navBar = Activity.createSubsectionNavBar('Account', {
        backLink: 'account'
    });
});

exports.init = A.init;

},{"../components/Activity":96}],41:[function(require,module,exports){
/**
    Payments activity
**/
'use strict';

var Activity = require('../components/Activity');
var A = Activity.extends(function PaymentsActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = {};
    this.navBar = Activity.createSectionNavBar('Payments');
});

module.exports = A;

},{"../components/Activity":96}],42:[function(require,module,exports){
/**
    Performance activity
**/
'use strict';

var Activity = require('../components/Activity');
var A = Activity.extends(function PerformanceActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = {};
    this.navBar = Activity.createSectionNavBar('Performance');
});

module.exports = A;

},{"../components/Activity":96}],43:[function(require,module,exports){
/**
    PrivacySettings activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function PrivacySettingsActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.loggedUser;

    this.navBar = Activity.createSubsectionNavBar('Account', {
        backLink: 'account'
    });
    
    this.registerHandler({
        target: this.app.model.privacySettings,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving privacy settings.' : 'Error loading privacy settings.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.privacySettings.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {
    
    this.user = app.model.userProfile.data;

    var privacySettings = app.model.privacySettings;

    var settingsVersion = privacySettings.newVersion();
    settingsVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            settingsVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.settings = settingsVersion.version;

    this.isLocked = privacySettings.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, privacySettings);
    
    this.discard = function discard() {
        settingsVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        settingsVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    }.bind(this);
}

},{"../components/Activity":96,"knockout":false}],44:[function(require,module,exports){
/**
    Provile activity
    
    Visualizes the public profile of a user, or current user
**/
'use strict';

var ko = require('knockout');

var Activity = require('../components/Activity');

var A = Activity.extends(function ProfileActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = new ViewModel(this.app);
    // null for logo
    this.navBar = Activity.createSectionNavBar(null);
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    var params = options.route && options.route.segments;
    this.viewModel.requestedUserID(params[0] |0);
};

function ViewModel(app) {

    this.requestedUserID = ko.observable(0);
    this.isLoading = ko.observable(false);
    this.isSyncing = ko.observable(false);
    
    this.profile = ko.pureComputed(function() {
        if (this.requestedUserID() === 0) {
            // Show current user profile
            return app.model.user();
        }
        else {
            // TODO: load another user profile
        }
    }, this);
}

},{"../components/Activity":96,"knockout":false}],45:[function(require,module,exports){
/**
    ProfilePictureBio activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function ProfilePictureBioActivity() {
    
    Activity.apply(this, arguments);

    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Marketplace profile', {
        backLink: 'marketplaceProfile'
    });
    
    this.registerHandler({
        target: this.app.model.marketplaceProfile,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving your data.' : 'Error loading your data.';
            this.app.modals.showError({
                title: msg,
                error: err && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Discard any previous unsaved edit
    this.viewModel.discard();
    
    // Keep data updated:
    this.app.model.marketplaceProfile.sync();
};

function ViewModel(app) {

    // Marketplace Profile
    var marketplaceProfile = app.model.marketplaceProfile;
    var profileVersion = marketplaceProfile.newVersion();
    profileVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            profileVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.profile = profileVersion.version;
    
    // Control observables: special because must a mix
    // of the both remote models used in this viewmodel
    this.isLocked = marketplaceProfile.isLocked;
    this.isLoading = marketplaceProfile.isLoading;
    this.isSaving = marketplaceProfile.isSaving;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, this);

    // Actions

    this.discard = function discard() {
        profileVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        profileVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    }.bind(this);
}

},{"../components/Activity":96,"knockout":false}],46:[function(require,module,exports){
/**
    Scheduling activity
**/
'use strict';

var Activity = require('../components/Activity'),
    UserJobProfileViewModel = require('../viewmodels/UserJobProfile');

var A = Activity.extends(function SchedulingActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new UserJobProfileViewModel(this.app);
    this.navBar = Activity.createSectionNavBar('Scheduling');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);

    this.viewModel.sync();
};

},{"../components/Activity":96,"../viewmodels/UserJobProfile":207}],47:[function(require,module,exports){
/**
    SchedulingPreferences activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');
var moment = require('moment');

var A = Activity.extends(function SchedulingPreferencesActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.serviceProfessional;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    
    this.registerHandler({
        target: this.app.model.schedulingPreferences,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving scheduling preferences.' : 'Error loading scheduling preferences.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.schedulingPreferences.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var schedulingPreferences = app.model.schedulingPreferences;

    var prefsVersion = schedulingPreferences.newVersion();
    prefsVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            prefsVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.prefs = prefsVersion.version;

    this.isLocked = schedulingPreferences.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, schedulingPreferences);
    
    this.discard = function discard() {
        prefsVersion.pull({ evenIfNewer: true });
    }.bind(this);

    this.save = function save() {
        prefsVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    }.bind(this);
    
    this.incrementsExample = ko.pureComputed(function() {
        
        var str = 'e.g. ',
            incSize = this.incrementsSizeInMinutes(),
            m = moment({ hour: 10, minute: 0 }),
            hours = [m.format('HH:mm')];
        
        for (var i = 1; i < 4; i++) {
            hours.push(
                m.add(incSize, 'minutes')
                .format('HH:mm')
            );
        }
        str += hours.join(', ');
        
        return str;
        
    }, this.prefs);
}

},{"../components/Activity":96,"knockout":false,"moment":false}],48:[function(require,module,exports){
/**
    Service Addresses activity
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    Activity = require('../components/Activity');

var A = Activity.extends(function ServiceAddressesActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Job Title', {
        backLink: '/scheduling'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject(true);

    // On changing jobTitleID:
    // - load addresses
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID
                this.app.model.jobTitles.getJobTitle(jobTitleID)
                .then(function(jobTitle) {
                    // Save for use in the view
                    this.viewModel.jobTitle(jobTitle);
                    // Update navbar (may indicate the jobTitle name)
                    this.updateNavBarState();
                    
                    // Get addresses
                    return this.app.model.serviceAddresses.getList(jobTitleID);
                }.bind(this))
                .then(function(list) {

                    list = this.app.model.serviceAddresses.asModel(list);
                    this.viewModel.serviceAddresses.sourceAddresses(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.serviceAddresses.sourceAddresses([]);
                this.viewModel.jobTitle(null);
                this.updateNavBarState();
            }
        }.bind(this)
    });
    
    // Go back with the selected address when triggered in the form/view
    this.viewModel.returnSelected = function(addressID, jobTitleID) {
        // Pass the selected client in the info
        this.requestData.selectedAddressID = addressID;
        this.requestData.selectedJobTitleID = jobTitleID;
        // And go back
        this.app.shell.goBack(this.requestData);
    }.bind(this);
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.applyOwnNavbarRules = function() {
    //jshint maxcomplexity:10
    
    var itIs = this.viewModel.serviceAddresses.isSelectionMode();

    if (this.requestData.title) {
        // Replace title by title if required
        this.navBar.title(this.requestData.title);
    }
    else {
        // Title must be empty
        this.navBar.title('');
    }

    if (this.requestData.cancelLink) {
        this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink, this.requestData);
    }
    else {
        // Reset to defaults, or given title:
        this.navBar.leftAction().model.updateWith(this.defaultLeftAction, true);
        if (this.requestData.navTitle)
            this.navBar.leftAction().text(this.requestData.navTitle);

        var jid = this.viewModel.jobTitleID(),
            jname = this.viewModel.jobTitle() && this.viewModel.jobTitle().singularName() || 'Scheduling',
            url = this.mustReturnTo || (jid && '/jobtitles/' + jid || '/scheduling');

        this.navBar.leftAction().link(url);
        this.navBar.leftAction().text(jname);
    }

    if (itIs && !this.requestData.cancelLink) {
        // Uses a custom handler so it returns keeping the given state:
        this.navBar.leftAction().handler(this.returnRequest);
    }
    else if (!this.requestData.cancelLink) {
        this.navBar.leftAction().handler(null);
    }
};

A.prototype.updateNavBarState = function updateNavBarState() {
    //jshint maxcomplexity:12

    var itIs = this.viewModel.serviceAddresses.isSelectionMode();
    
    this.viewModel.headerText(itIs ? 'Select or add a service location' : 'Locations');

    // Perform updates that apply this request:
    this.app.model.onboarding.updateNavBar(this.navBar) ||
    //this.app.applyNavbarMustReturn(this.requestData) ||
    this.applyOwnNavbarRules();
};

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Remember route to go back, from a request of 'mustReturn' or last requested
    this.mustReturnTo = this.requestData.route.query.mustReturn || this.mustReturnTo;

    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);
    this.viewModel.requestData = this.requestData;

    this.viewModel.serviceAddresses.isSelectionMode(options.selectAddress === true);
    this.viewModel.clientID(options.clientID || null);

    var params = options && options.route && options.route.segments;
    var jobTitleID = params[0] |0;
    
    // Check if it comes from an addressEditor that
    // received the flag 'returnNewAsSelected' and an
    // addressID: we were in selection mode->creating address->must
    // return the just created address to the previous page
    if (options.returnNewAsSelected === true &&
        options.addressID) {
        
        setTimeout(function() {
            delete options.returnNewAsSelected;
            this.viewModel.returnSelected(options.addressID, jobTitleID);
        }.bind(this), 1);
        // quick return
        return;
    }

    this.viewModel.jobTitleID(jobTitleID);

    this.updateNavBarState();
    
    if (jobTitleID === 0) {
        this.viewModel.jobTitles.sync();
    }
};

var UserJobProfile = require('../viewmodels/UserJobProfile'),
    ServiceAddresses = require('../viewmodels/ServiceAddresses');

function ViewModel(app) {
    
    this.serviceAddresses = new ServiceAddresses();

    this.headerText = ko.observable('Locations');
    
    this.jobTitleID = ko.observable(0);
    this.jobTitle = ko.observable(null);
    // Optionally, some times a clientID can be passed in order to create
    // a location for that client where perform a work.
    this.clientID = ko.observable(null);
    
    this.jobTitles = new UserJobProfile(app);
    this.jobTitles.baseUrl('/serviceAddress');
    this.jobTitles.selectJobTitle = function(jobTitle) {
        
        this.jobTitleID(jobTitle.jobTitleID());
        
        return false;
    }.bind(this);

    this.isSyncing = app.model.serviceAddresses.state.isSyncing();
    this.isLoading = ko.computed(function() {
        var add = app.model.serviceAddresses.state.isLoading(),
            jobs = this.jobTitles.isLoading();
        return add || jobs;
    }, this);
    
    this.goNext = function() {
        if (app.model.onboarding.inProgress()) {
            app.model.onboarding.goNext();
        }
    };

    // Replace default selectAddress
    this.serviceAddresses.selectAddress = function(selectedAddress, event) {
        if (this.serviceAddresses.isSelectionMode() === true) {
            // Run method injected by the activity to return a 
            // selected address:
            this.returnSelected(
                selectedAddress.addressID(),
                selectedAddress.jobTitleID()
            );
        }
        else {
            app.shell.go('addressEditor/service/' +
                this.jobTitleID() +
                '/' + selectedAddress.addressID()
            );
        }
        
        event.preventDefault();
        event.stopImmediatePropagation();

    }.bind(this);
    
    this.addServiceLocation = function() {
        var url = '#!addressEditor/service/' + this.jobTitleID() + '/serviceLocation';
        var request = $.extend({}, this.requestData, {
            returnNewAsSelected: this.serviceAddresses.isSelectionMode()
        });
        app.shell.go(url, request);
    }.bind(this);
    
    this.addServiceArea = function() {
        var url = '#!addressEditor/service/' + this.jobTitleID() + '/serviceArea';
        var request = $.extend({}, this.requestData, {
            returnNewAsSelected: this.serviceAddresses.isSelectionMode()
        });
        app.shell.go(url, request);
    }.bind(this);
    
    this.addClientLocation = function() {
        var url = '#!addressEditor/service/' + this.jobTitleID() + '/clientLocation/' + this.clientID();
        var request = $.extend({}, this.requestData, {
            returnNewAsSelected: this.serviceAddresses.isSelectionMode()
        });
        app.shell.go(url, request);
    }.bind(this);
    
    this.onboardingNextReady = ko.computed(function() {
        var isin = app.model.onboarding.inProgress(),
            hasItems = this.serviceAddresses.sourceAddresses().length > 0;

        return isin && hasItems;
    }, this);
}

},{"../components/Activity":96,"../viewmodels/ServiceAddresses":203,"../viewmodels/UserJobProfile":207,"knockout":false}],49:[function(require,module,exports){
/**
    ServiceProfessional Service activity
    
    TODO: Use ServiceProfessionalService ViewModel and template
**/
'use strict';

var ko = require('knockout'),
    _ = require('lodash'),
    $ = require('jquery'),
    Activity = require('../components/Activity');

var A = Activity.extends(function ServiceProfessionalServiceActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Job Title', {
        backLink: '/scheduling'
    });
    // Save defaults to restore on updateNavBarState when needed:
    this.defaultLeftAction = this.navBar.leftAction().model.toPlainObject(true);
    
    // On changing jobTitleID:
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitle,
        handler: function(/*jobTitle*/) {
            // Update navbar (may indicate the jobTitle name)
            this.updateNavBarState();
        }.bind(this)
    });

    // On changing jobTitleID:
    // - load pricing
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID and pricing types.
                // They are essential data
                Promise.all([
                    this.app.model.jobTitles.getJobTitle(jobTitleID),
                    this.app.model.pricingTypes.getList()
                ])
                .then(function(data) {
                    var jobTitle = data[0];
                    // Save for use in the view
                    this.viewModel.jobTitle(jobTitle);
                    // Get pricing
                    return this.app.model.serviceProfessionalServices.getList(jobTitleID);
                }.bind(this))
                .then(function(list) {

                    list = this.app.model.serviceProfessionalServices.asModel(list);
                    
                    // Read presets selection from requestData
                    var preset = this.requestData.selectedServices || [],
                        selection = this.viewModel.selectedServices;
                    
                    // Add the isSelected property to each item
                    list.forEach(function(item) {
                        var preSelected = preset.some(function(pr) {
                            if (pr.serviceProfessionalServiceID === item.serviceProfessionalServiceID())
                                return true;
                        }) || false;
                        
                        item.isSelected = ko.observable(preSelected);
                        
                        if (preSelected) {
                            selection.push(item);
                        }
                    });
                    this.viewModel.list(list);

                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.list([]);
                this.viewModel.jobTitle(null);
            }
        }.bind(this)
    });
    
    // Go back with the selected pricing when triggered in the form/view
    this.viewModel.returnSelected = function(pricing, jobTitleID) {
        // Pass the selected client in the info
        this.requestData.selectedServices = pricing;
        this.requestData.selectedJobTitleID = jobTitleID;
        // And go back
        this.app.shell.goBack(this.requestData);
    }.bind(this);
    
    this.returnRequest = function returnRequest() {
        this.app.shell.goBack(this.requestData);
    }.bind(this);
});

exports.init = A.init;

A.prototype.applyOwnNavbarRules = function() {
    //jshint maxcomplexity:10
    
    var itIs = this.viewModel.isSelectionMode();

    if (this.requestData.title) {
        // Replace title by title if required
        this.navBar.title(this.requestData.title);
    }
    else {
        // Title must be empty
        this.navBar.title('');
    }

    if (this.requestData.cancelLink) {
        this.convertToCancelAction(this.navBar.leftAction(), this.requestData.cancelLink, this.requestData);
    }
    else {
        // Reset to defaults, or given title:
        this.navBar.leftAction().model.updateWith(this.defaultLeftAction, true);
        if (this.requestData.navTitle)
            this.navBar.leftAction().text(this.requestData.navTitle);

        var jid = this.viewModel.jobTitleID(),
            jname = this.viewModel.jobTitle() && this.viewModel.jobTitle().singularName() || 'Scheduling',
            url = this.mustReturnTo || (jid && '/jobtitles/' + jid || '/scheduling');

        this.navBar.leftAction().link(url);
        this.navBar.leftAction().text(jname);
    }

    if (itIs && !this.requestData.cancelLink) {
        // Uses a custom handler so it returns keeping the given state:
        this.navBar.leftAction().handler(this.returnRequest);
    }
    else if (!this.requestData.cancelLink) {
        this.navBar.leftAction().handler(null);
    }
};

A.prototype.updateNavBarState = function updateNavBarState() {
    var itIs = this.viewModel.isSelectionMode();
    
    this.viewModel.headerText(itIs ? 'Select services' : 'Services');
    
    // Perform updates that apply this request:
    this.app.model.onboarding.updateNavBar(this.navBar) ||
    //this.app.applyNavbarMustReturn(this.requestData) ||
    this.applyOwnNavbarRules();
};

A.prototype.show = function show(options) {
    //jshint maxcomplexity:8
    Activity.prototype.show.call(this, options);
    
    // Remember route to go back, from a request of 'mustReturn' or last requested
    this.mustReturnTo = this.requestData.route.query.mustReturn || this.mustReturnTo;
        
    
    // Reset: avoiding errors because persisted data for different ID on loading
    // or outdated info forcing update
    this.viewModel.jobTitleID(0);
    this.viewModel.selectedServices.removeAll();
    this.viewModel.requestData = this.requestData;

    this.viewModel.isSelectionMode(this.requestData.selectPricing === true);
    
    // Params
    var params = options && options.route && options.route.segments;
    var jobTitleID = params[0] |0;
    if (jobTitleID === 0 && options.selectedJobTitleID > 0)
        jobTitleID = options.selectedJobTitleID |0;

    var isAdditionMode = params[0] === 'new' || params[1] === 'new';
    if (isAdditionMode) {
        // Sets referrer as cancelLink
        var ref = this.app.shell.referrerRoute;
        ref = ref && ref.url || '/';
        this.requestData.cancelLink = ref;
        // Set for editor links in the view
        this.viewModel.cancelLink(ref);
    }
    else {
        // Set this page as cancelLink for editor links in the view
        this.viewModel.cancelLink('/serviceProfessionalService/' + this.viewModel.jobTitleID());
    }

    this.viewModel.isAdditionMode(isAdditionMode);
    
    this.updateNavBarState();

    this.viewModel.jobTitleID(jobTitleID);
    
    if (jobTitleID === 0) {
        this.viewModel.jobTitles.sync();
    }
};

var UserJobProfile = require('../viewmodels/UserJobProfile');

function ViewModel(app) {

    this.headerText = ko.observable('Services');
    
    this.jobTitleID = ko.observable(0);
    this.jobTitle = ko.observable(null);
    this.isAdditionMode = ko.observable(false);
    this.cancelLink = ko.observable(null);
    
    this.jobTitles = new UserJobProfile(app);
    this.jobTitles.baseUrl('/serviceProfessionalService');
    this.jobTitles.selectJobTitle = function(jobTitle) {
        
        this.jobTitleID(jobTitle.jobTitleID());
        var url = 'serviceProfessionalService/' + jobTitle.jobTitleID();
        if (this.isAdditionMode())
            url += '/new';
        // pushState cannot be used because it conflicts with the 
        // selection logic (on new-booking progress)
        // TODO: commented until the bug with replaceState in HashbangHistory is fixed
        //app.shell.replaceState(null, null, url);
        
        return false;
    }.bind(this);

    this.list = ko.observableArray([]);

    this.isLoading = ko.computed(function() {
        return (
            app.model.serviceProfessionalServices.state.isLoading() ||
            app.model.pricingTypes.state.isLoading() ||
            app.model.jobTitles.state.isLoading()
        );
    });
    this.isLocked = this.isLoading;

    // Especial mode when instead of pick and edit we are just selecting
    this.isSelectionMode = ko.observable(false);

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                'Save and continue'
        );
    }, this);
    
    // Grouped list of pricings:
    // Defined groups by pricing type
    this.groupedServices = ko.computed(function(){

        var list = this.list();
        var isSelection = this.isSelectionMode();
        var groupNamePrefix = isSelection ? 'Select ' : '';

        var groups = [],
            groupsList = [];
        if (!this.isAdditionMode()) {
            groups = _.groupBy(list, function(pricingItem) {
                return pricingItem.pricingTypeID();
            });

            // Convert the indexed object into an array with some meta-data
            groupsList = Object.keys(groups).map(function(key) {
                var gr = {
                    pricing: groups[key],
                    // Load the pricing information
                    type: app.model.pricingTypes.getObservableItem(key)
                };
                gr.group = ko.computed(function() {
                    return groupNamePrefix + (
                        this.type() && this.type().pluralName() ||
                        'Services'
                    );
                }, gr);
                return gr;
            });
        }
        
        // Since the groupsList is built from the existent pricing items
        // if there are no records for some pricing type (or nothing when
        // just created the job title), that types/groups are not included,
        // so review and include now.
        // NOTE: as a good side effect of this approach, pricing types with
        // some pricing will appear first in the list (nearest to the top)
        var pricingTypes = this.jobTitle() && this.jobTitle().pricingTypes();
        if (pricingTypes && pricingTypes.length) {
            pricingTypes.forEach(function (jobType) {
                
                var typeID = jobType.pricingTypeID();
                // Not if already in the list
                if (groups.hasOwnProperty(typeID))
                    return;

                var gr = {
                    pricing: [],
                    type: app.model.pricingTypes.getObservableItem(typeID)
                };
                gr.group = ko.computed(function() {
                    return groupNamePrefix + (
                        this.type() && this.type().pluralName() ||
                        'Services'
                    );
                }, gr);

                groupsList.push(gr);
            });
        }

        return groupsList;

    }, this);

    this.selectedServices = ko.observableArray([]);
    /**
        Toggle the selection status of a pricing, adding
        or removing it from the 'selectedServices' array.
    **/
    this.toggleServiceSelection = function(pricing) {

        var inIndex = -1,
            isSelected = this.selectedServices().some(function(selectedServices, index) {
            if (selectedServices === pricing) {
                inIndex = index;
                return true;
            }
        });

        pricing.isSelected(!isSelected);

        if (isSelected)
            this.selectedServices.splice(inIndex, 1);
        else
            this.selectedServices.push(pricing);
    }.bind(this);
    
    this.onboardingNextReady = ko.computed(function() {
        var isin = app.model.onboarding.inProgress(),
            hasPricing = this.list().length > 0;
        
        return isin && hasPricing;
    }, this);
    
    /**
        Ends the selection process, ready to collect selection
        and passing it to the requester activity.
        Works too to pass to the next onboarding step
    **/
    this.endSelection = function(data, event) {
        
        if (app.model.onboarding.inProgress()) {
            app.model.onboarding.goNext();
        }
        else {
            // Run method injected by the activity to return a 
            // selected address:
            this.returnSelected(
                this.selectedServices().map(function(pricing) {
                    return {
                        serviceProfessionalServiceID: ko.unwrap(pricing.serviceProfessionalServiceID),
                        totalPrice: ko.unwrap(pricing.price)
                    };
                }),
                this.jobTitleID()
            );
        }

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    this.editService = function(pricing) {
        app.shell.go('serviceProfessionalServiceEditor/' + this.jobTitleID() + '/' + pricing.serviceProfessionalServiceID());
    }.bind(this);
    
    /**
        Handler for the listview items, managing edition and selection depending on current mode
    **/
    this.tapService = function(pricing, event) {
        if (this.isSelectionMode()) {
            this.toggleServiceSelection(pricing);
        }
        else {
            this.editService(pricing);
        }

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    this.tapNewService = function(group, event) {
        
        var url = '#!serviceProfessionalServiceEditor/' + this.jobTitleID() + '/new/' + (group.type() && group.type().pricingTypeID());

        // Passing original data, for in-progress process (as new-booking)
        // and the selected title since the URL could not be updated properly
        // (see the anotated comment about replaceState bug on this file)
        var request = $.extend({}, this.requestData, {
            selectedJobTitleID: this.jobTitleID()
        });
        if (!request.cancelLink) {
            $.extend(request, {
                cancelLink: this.cancelLink()
            });
        }
        
        // When in selection mode:
        // Add current selection as preselection, so can be recovered later and 
        // the editor can add the new pricing to the list
        if (this.isSelectionMode()) {
            request.selectedServices = this.selectedServices()
            .map(function(pricing) {
                return {
                    serviceProfessionalServiceID: ko.unwrap(pricing.serviceProfessionalServiceID),
                    totalPrice: ko.unwrap(pricing.totalPrice)
                };
            });
        }

        app.shell.go(url, request);

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
}

},{"../components/Activity":96,"../viewmodels/UserJobProfile":207,"knockout":false,"lodash":false}],50:[function(require,module,exports){
/**
    ServiceProfessionalServiceEditor activity
    
    TODO: ModelVersion is NOT being used, so no getting updates if server updates
    the data after load (data load is requested but get first from cache). Use
    version and get sync'ed data when ready, and additionally notification to
    override changes if server data is different that any local change.
**/
'use strict';
var ko = require('knockout'),
    Activity = require('../components/Activity'),
    PricingType = require('../models/PricingType');

var A = Activity.extends(function ServiceProfessionalServiceEditorActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    this.navBar = Activity.createSubsectionNavBar('Services');
    
    /// Go out after save succesfully an item.
    /// Pricing is a plain object
    this.viewModel.onSave = function(pricing) {
        // Go back on save.
        // If we comes with a selection of pricing, we must add the new one
        // there and just go back (serviceProfessionalService is in selection mode) keeping
        // any requestData for in-progress state.
        if (this.requestData.selectedServices) {
            // Is an array of plain objects of just ID and totalPrice
            this.requestData.selectedServices.push({
                serviceProfessionalServiceID: pricing.serviceProfessionalServiceID,
                totalPrice: pricing.totalPrice
            });
            this.app.shell.goBack(this.requestData);
        }
        else {
            // Just execute the standard save process
            this.app.successSave();
        }
    }.bind(this);
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {

    var link = this.requestData.cancelLink || '/serviceProfessionalService/' + this.viewModel.jobTitleID();
    
    this.convertToCancelAction(this.navBar.leftAction(), link);
};

A.prototype.show = function show(options) {
    //jshint maxcomplexity:10    
    Activity.prototype.show.call(this, options);

    // Reset
    this.viewModel.wasRemoved(false);
    this.viewModel.serviceProfessionalServiceVersion(null);
    this.viewModel.pricingType(null);

    // Params
    var params = options && options.route && options.route.segments || [];

    var jobTitleID = params[0] |0,
        // Parameter [1] can be 'new' followed by a pricingTypeID as [2]
        pricingTypeID = params[1] === 'new' ? params[2] |0 : 0,
        // Or a pricingID
        serviceProfessionalServiceID = params[1] |0;

    this.viewModel.jobTitleID(jobTitleID);
    this.viewModel.serviceProfessionalServiceID(serviceProfessionalServiceID);
    
    this.updateNavBarState();
    
    /**
        The pricing record needs some special set-up after creation/loading and before
        being presented to the user, because special value-rules.
    **/
    var pricingSetup = function pricingSetup() {
        // Pricing fields that has a special initial value
        var c = this.viewModel.current();
        if (c) {
            // Name: must be the PricingType.fixedName ever if any, or
            //   the name saved in the pricing or
            //   the suggestedName as last fallback
            c.pricing.name(c.type.fixedName() || c.pricing.name() || c.type.suggestedName());
            // Required call after loading a pricing to reflect data correctly (cannot be automated)
            c.pricing.refreshNoPriceRate();
        }
        this.viewModel.isLoading(false);
    }.bind(this);
    
    var showInvalidRequestError = function() {
        this.viewModel.isLoading(false);
        this.app.modals.showError({
            title: 'Invalid request',
            error: { jobTitleID: jobTitleID, pricingTypeID: pricingTypeID, serviceProfessionalServiceID: serviceProfessionalServiceID }
        })
        .then(function() {
            // On close modal, go back
            this.app.shell.goBack();
        }.bind(this));
    }.bind(this);

    this.viewModel.isLoading(true);
    if (pricingTypeID) {
        // Load the pricing Type
        this.app.model.pricingTypes.getItem(pricingTypeID)
        .then(function(type) {
            if (type) {
                this.viewModel.pricingType(type);
                // New pricing
                this.viewModel.serviceProfessionalServiceVersion(this.app.model.serviceProfessionalServices.newItemVersion({
                    jobTitleID: jobTitleID,
                    pricingTypeID: pricingTypeID
                }));
                pricingSetup();
            }
            else {
                showInvalidRequestError();
            }
        }.bind(this));
    }
    else if (serviceProfessionalServiceID) {
        // Get the pricing
        this.app.model.serviceProfessionalServices.getItemVersion(jobTitleID, serviceProfessionalServiceID)
        .then(function (serviceProfessionalServiceVersion) {
            if (serviceProfessionalServiceVersion) {
                // Load the pricing type before put the version
                // returns to let the 'catch' to get any error
                return this.app.model.pricingTypes.getItem(serviceProfessionalServiceVersion.version.pricingTypeID())
                .then(function(type) {
                    if (type) {
                        this.viewModel.pricingType(type);
                        this.viewModel.serviceProfessionalServiceVersion(serviceProfessionalServiceVersion);
                        pricingSetup();
                    }
                    else {
                        showInvalidRequestError();
                    }
                }.bind(this));
            } else {
                showInvalidRequestError();
            }

        }.bind(this))
        .catch(function (err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            })
            .then(function() {
                // On close modal, go back
                this.app.shell.goBack();
            }.bind(this));
        }.bind(this));
    }
    else {
        showInvalidRequestError();
    }
};

function ViewModel(app) {
    /*jshint maxstatements: 35*/

    this.isLoading = ko.observable(false);
    // managed manually instead of
    //app.model.serviceProfessionalServices.state.isLoading;
    this.isSaving = app.model.serviceProfessionalServices.state.isSaving;
    this.isSyncing = app.model.serviceProfessionalServices.state.isSyncing;
    this.isDeleting = app.model.serviceProfessionalServices.state.isDeleting;
    this.jobTitleID = ko.observable(0);
    this.serviceProfessionalServiceID = ko.observable(0);
    // L10N
    this.moneySymbol = ko.observable('$');
    
    this.pricingType = ko.observable(new PricingType());

    this.serviceProfessionalServiceVersion = ko.observable(null);
    this.serviceProfessionalService = ko.pureComputed(function() {
        var v = this.serviceProfessionalServiceVersion();
        if (v) {
            return v.version;
        }
        return null;
    }, this);

    this.header = ko.pureComputed(function() {
        if (this.isLoading()) {
            return 'Loading...';
        }
        else if (this.serviceProfessionalServiceVersion()) {
            var t = this.pricingType();
            return t && t.singularName() || 'Service';
        }
        else {
            return 'Unknow service or was deleted';
        }

    }, this);
    
    // Quicker access in form, under a 'with'
    this.current = ko.pureComputed(function() {
        var t = this.pricingType(),
            p = this.serviceProfessionalService();
        
        if (t && p) {
            return {
                type: t,
                pricing: p
            };
        }
        return null;
    }, this);

    this.wasRemoved = ko.observable(false);
    
    this.isLocked = ko.computed(function() {
        return this.isDeleting() || app.model.serviceProfessionalServices.state.isLocked();
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        var p = this.serviceProfessionalService();
        return p && !p.updatedDate();
    }, this);

    this.submitText = ko.pureComputed(function() {
        var v = this.serviceProfessionalServiceVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        'Save changes' :
                        'Saved'
        );
    }, this);

    this.unsavedChanges = ko.pureComputed(function() {
        var v = this.serviceProfessionalServiceVersion();
        return v && v.areDifferent();
    }, this);
    
    this.deleteText = ko.pureComputed(function() {
        return (
            this.isDeleting() ? 
                'Deleting...' : 
                'Delete'
        );
    }, this);

    this.save = function() {
        
        app.model.serviceProfessionalServices.setItem(this.serviceProfessionalService().model.toPlainObject())
        .then(function(serverData) {
            // Update version with server data.
            this.serviceProfessionalService().model.updateWith(serverData);
            // Push version so it appears as saved
            this.serviceProfessionalServiceVersion().push({ evenIfObsolete: true });
            
            // After save logic provided by the activity, injected in the view:
            this.onSave(serverData);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while saving.',
                error: err
            });
        });

    }.bind(this);
    
    this.confirmRemoval = function() {
        // TODO Better l10n or replace by a new preset field on pricingType.deleteLabel
        var p = this.pricingType();
        app.modals.confirm({
            title: 'Delete ' + (p && p.singularName()),
            message: 'Are you sure? The operation cannot be undone.',
            yes: 'Delete',
            no: 'Keep'
        })
        .then(function() {
            this.remove();
        }.bind(this));
    }.bind(this);

    this.remove = function() {

        app.model.serviceProfessionalServices.delItem(this.jobTitleID(), this.serviceProfessionalServiceID())
        .then(function() {
            this.wasRemoved(true);
            // Go out the deleted location
            app.shell.goBack();
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'There was an error while deleting.',
                error: err
            });
        });
    }.bind(this);
}

},{"../components/Activity":96,"../models/PricingType":127,"knockout":false}],51:[function(require,module,exports){
/**
    ServiceProfessionalWebsite activity
**/
'use strict';

var Activity = require('../components/Activity'),
    ko = require('knockout');

var A = Activity.extends(function ServiceProfessionalWebsiteActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.serviceProfessional;

    this.navBar = Activity.createSubsectionNavBar('Marketplace Profile', {
        backLink: 'marketplaceProfile'
    });
    
    this.registerHandler({
        target: this.app.model.marketplaceProfile,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving your website.' : 'Error loading your website.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    // Keep data updated:
    this.app.model.marketplaceProfile.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var marketplaceProfile = app.model.marketplaceProfile;

    var profileVersion = marketplaceProfile.newVersion();
    profileVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            profileVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.profile = profileVersion.version;

    this.isLocked = marketplaceProfile.isLocked;

    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ? 
                    'saving...' : 
                    'Save'
        );
    }, marketplaceProfile);
    
    this.discard = function discard() {
        profileVersion.pull({ evenIfNewer: true });
    };

    this.save = function save() {
        profileVersion.pushSave()
        .then(function() {
            app.successSave();
        })
        .catch(function() {
            // catch error, managed on event
        });
    };
}

},{"../components/Activity":96,"knockout":false}],52:[function(require,module,exports){
/**
    ServicesOverview activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function ServicesOverviewActivity() {
    
    Activity.apply(this, arguments);

    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.loggedUser;
    
    this.navBar = Activity.createSubsectionNavBar('Job Title');
});

exports.init = A.init;

A.prototype.show = function show(state) {
    // Reset
    this.viewModel.jobTitleID(null);
    this.viewModel.intro(null);
    this.viewModel.serviceAttributes.proposedServiceAttributes({});
    
    Activity.prototype.show.call(this, state);
    
    var params = state && state.route && state.route.segments;
    var jid = params[0] |0;
    this.viewModel.jobTitleID(jid);

    if (jid) {
        // Load it
        this.viewModel.isLoadingUserJobTitle(true);
        Promise.all([
            this.app.model.userJobProfile.getUserJobTitle(jid),
            this.viewModel.serviceAttributesControl.load(jid),
            this.viewModel.jobTitleServiceAttributesControl.load(jid)
        ])
        .then(function(datas) {
            var userJobTitle = datas && datas[0];
            // we need the full record for the saving
            this.viewModel.userJobTitle(userJobTitle);
            // local copy of intro
            this.viewModel.intro(userJobTitle.intro());
            this.viewModel.isLoadingUserJobTitle(false);
        }.bind(this))
        .catch(function(err) {
            this.app.modals.showError({
                title: 'There was an error while loading.',
                error: err
            });
            this.viewModel.isLoadingUserJobTitle(false);
        }.bind(this));
    }
    else {
        // Just empty
        this.viewModel.serviceAttributesControl.reset();
        this.viewModel.jobTitleServiceAttributesControl.reset();
    }
};

function ViewModel(app) {
    this.jobTitleID = ko.observable(0);
    
    this.isLoadingUserJobTitle = ko.observable(false);
    this.userJobTitle = ko.observable(null);
    // Local copy of the intro, rather than use
    // it directly from the userJobTitle to avoid that gets saved
    // in memory without press 'save'
    this.intro = ko.observable(null);
    
    this.serviceAttributesControl = app.model.serviceAttributes.newItemVersion();
    this.serviceAttributes = this.serviceAttributesControl.version;
    this.jobTitleServiceAttributesControl = app.model.jobTitleServiceAttributes.newItemVersion();
    this.jobTitleServiceAttributes = this.jobTitleServiceAttributesControl.original;
    
    this.isLoading = ko.pureComputed(function() {
        return (
            this.isLoadingUserJobTitle() ||
            this.serviceAttributesControl.state.isLoading() ||
            this.jobTitleServiceAttributesControl.state.isLoading()
        );
    }, this);
    this.isSaving = ko.observable(false);
    this.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving();
    }, this);

    // Combined array of service attribute categories for all the available and
    // information for the selected by the user, with methods modify and query the lists
    this.categoriesView = ko.pureComputed(function() {
        var userAtts = this.serviceAttributes;
        return this.jobTitleServiceAttributes.serviceAttributes().map(function(cat) {
            return new AttributesCategoryVM(cat, userAtts);
        });
    }, this);
    
    this.submitText = ko.pureComputed(function() {
        return (
            this.isLoading() ? 
                'loading...' : 
                this.isSaving() ?
                    'saving...' : 
                    'Save'
        );
    }, this);
    
    this.save = function() {
        var ujt = this.userJobTitle();
        if (ujt) {
            this.isSaving(true);

            var plain = ujt.model.toPlainObject();
            plain.intro = this.intro();

            Promise.all([
                this.serviceAttributesControl.save(),
                app.model.userJobProfile.setUserJobTitle(plain)
            ])
            .then(function() {
                this.isSaving(false);
                
                // Force a background jobTitleAttributes refresh if new ones
                // where submitted for insertion.
                var props = this.serviceAttributes.proposedServiceAttributes();
                var propCats = props && Object.keys(props);
                if (propCats && propCats.length) {
                    var thereAreNews = propCats.reduce(function(sum, k) {
                        var cat = props[k];
                        return sum + (cat && cat.length || 0);
                    }, 0) > 0;
                    if (thereAreNews) {
                        this.jobTitleServiceAttributesControl.load(undefined, true);
                    }
                }

                // Cleanup
                this.serviceAttributes.proposedServiceAttributes({});
                
                app.successSave();
            }.bind(this))
            .catch(function(err) {
                this.isSaving(false);
                app.modals.showError({ title: 'Error saving your Services Overview', error: err });
            }.bind(this));
        }
    }.bind(this);
}

var ServiceAttribute = require('../models/ServiceAttribute');

function AttributesCategoryVM(cat, userAtts) {
    
    var catID = cat.serviceAttributeCategoryID();
    var selectedAttsIds = userAtts.serviceAttributes.getServiceCategoryAttributes(catID);
    this.category = ko.observable(cat);
    
    // An array of models for visualization from the list of proposed names for addition
    this.proposedServiceAttributes = ko.pureComputed(function() {
        var props = userAtts.proposedServiceAttributes();
        if (props && props[catID] && props[catID].length) {
            return props[catID].map(function(name) {
                return new ServiceAttribute({ name: name });
            });
        }
        else {
            return [];
        }
    }, this);

    this.selectedAttributes = ko.pureComputed(function() {
        var atts = cat.serviceAttributes().filter(function(att) {
            return selectedAttsIds().indexOf(att.serviceAttributeID()) > -1;
        });

        return atts.concat.apply(atts, this.proposedServiceAttributes());
    }, this);

    // Available, not selected, list of attributes
    this.availableAttributes = ko.computed(function() {
        var props = this.proposedServiceAttributes(),
            atts = selectedAttsIds();
        return cat.serviceAttributes().filter(function(att) {
            var toInclude = atts.indexOf(att.serviceAttributeID()) === -1;
            if (toInclude === false) return false;

            // Not found in IDs, try with proposed Names:
            return props.every(function(propAtt) {
                return att.name() !== propAtt.name();
            });
        });
    }, this);

    this.attributeSearch = ko.observable('');
    var foundAttItem = function(att, item) {
        return item.name() === att.name;
    };

    this.addAttribute = function() {
        var newOne = this.attributeSearch() || '',
            isEmpty = /^\s*$/.test(newOne),
            wasFound = this.selectedAttributes().some(foundAttItem.bind(null, { name: newOne }));
        if (!isEmpty && !wasFound) {
            userAtts.proposedServiceAttributes.push(catID, newOne);
        }
        
        this.attributeSearch('');
    };
    
    this.selectAttribute = function(att) {
        userAtts.serviceAttributes.push(catID, att.serviceAttributeID());
    };

    this.removeAttribute = function(att) {
        var id = att.serviceAttributeID();
        if (id)
            userAtts.serviceAttributes.remove(catID, id);
        else
            userAtts.proposedServiceAttributes.remove(catID, att.name());
    }.bind(this);
    
    // Available attributes filtered out by the search text
    var textSearch = require('../utils/textSearch');
    this.autocompleteAttributes = ko.computed(function() {
        var s = this.attributeSearch(),
            a = this.availableAttributes();
        
        return a.filter(function(att) {
            return textSearch(s, att.name());
        });
    }, this);
}

},{"../components/Activity":96,"../models/ServiceAttribute":136,"../utils/textSearch":193,"knockout":false}],53:[function(require,module,exports){
/**
    Signup activity
**/
'use strict';

var Activity = require('../components/Activity'),
    SignupVM = require('../viewmodels/Signup');

var A = Activity.extends(function SignupActivity() {
    
    Activity.apply(this, arguments);

    this.viewModel = new SignupVM(this.app);
    // null for Logo
    this.navBar = Activity.createSectionNavBar(null);
    this.navBar.rightAction(null);
    
    // Redircect on success
    this.registerHandler({
        target: this.viewModel,
        event: 'signedup',
        handler: function() {
            if (this.app.goDashboard)
                // In App
                this.app.goDashboard();
            else
                // In Splash
                this.app.shell.go('#!splashThanks/' + this.profile());
        }.bind(this)
    });
    
    // Focus first bad field on error
    this.registerHandler({
        target: this.viewModel,
        event: 'signuperror',
        handler: function(err) {
            if (err) {
                // Focus first field with error
                var $el = this.$activity.find('.form-group.has-error:first').find('input');
                setTimeout(function() {
                    // Because trying synchronously will not work on some cases
                    $el.focus();
                }, 100);
            }
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    this.viewModel.reset();

    Activity.prototype.show.call(this, options);
    
    var p = options && options.route && options.route.segments && options.route.segments[0] || '';
    this.viewModel.profile(p);
};

},{"../components/Activity":96,"../viewmodels/Signup":205}],54:[function(require,module,exports){
/**
    Terms activity
**/
'use strict';

var Activity = require('../components/Activity');

var $ = require('jquery');

var A = Activity.extends(function TermsActivity() {
    
    Activity.apply(this, arguments);

    // Any user can access this
    this.accessLevel = null;
    
    // null for logos
    this.navBar = Activity.createSectionNavBar(null);
    this.navBar.rightAction(null);
    this.$activity.find('#terms-index a').click(function (e) {
        e.preventDefault();
        e.stopImmediatePropagation();
        $(this).tab('show');
        if (window.history && window.history.replaceState) {
            window.history.replaceState(null, null, '#!terms/' + $(this).attr('href').replace(/^#/, ''));
        }
    });
});

exports.init = A.init;

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    var tabName = state && state.route.segments && state.route.segments[0] || 'terms-of-service';
    var tab = this.$activity.find('[href="#terms-' + tabName + '"]');
    if (tab.length) tab.tab('show');
};

},{"../components/Activity":96}],55:[function(require,module,exports){
/**
    textEditor activity
**/
//global window
'use strict';

var ko = require('knockout'),
    EventEmitter = require('events').EventEmitter,
    Activity = require('../components/Activity');

var A = Activity.extends(function TextEditorActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    // Title is empty, since we are in 'go back' mode all the time here
    this.navBar = Activity.createSubsectionNavBar('');
    this.navBar.leftAction().handler(function() {
        this.emit('cancel');
    }.bind(this.viewModel));
    
    // Getting elements
    this.$textarea = this.$activity.find('textarea');
    this.textarea = this.$textarea.get(0);
    
    // Handler for the 'saved' event so the activity
    // returns back to the requester activity giving it
    // the new text
    this.registerHandler({
        target: this.viewModel,
        event: 'saved',
        handler: function() {
            // Update the info with the new text
            this.requestData.text = this.viewModel.text();
            // and pass it back
            this.app.shell.goBack(this.requestData);
        }.bind(this)
    });
    
    // Handler the cancel event
    this.registerHandler({
        target: this.viewModel,
        event: 'cancel',
        handler: function() {
            // return, nothing changed
            this.app.shell.goBack(this.requestData);
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    // Set navigation title or nothing
    this.navBar.leftAction().text(this.requestData.navTitle || '');
    
    // Field header
    this.viewModel.headerText(this.requestData.header);
    this.viewModel.text(this.requestData.text);
        
    // Inmediate focus to the textarea for better usability
    this.textarea.focus();
    this.$textarea.click();
    // IMPORTANT: WORKAROUND: for iOS: on iOS (checked up to 8.3, 2015-05-20), the opening of the virtual keyboard
    // makes a scroll down of the viewport, hiding the text field, header, anything, and only the
    // blank area gets showed. That bad autoscroll can be fixed on this single case with next trick
    // without flickering or bad effects (and alternative, generic approach is do it on the keyboardShow
    // event, but there a flickering happens and may affect cases where there is no need or can be worse
    // if field visibility and actual scroll is not checked):
    window.scrollTo(0, 0);
};

function ViewModel() {

    this.headerText = ko.observable('Text');

    // Text to edit
    this.text = ko.observable('');

    this.cancel = function cancel() {
        this.emit('cancel');
    };
    
    this.save = function save() {
        this.emit('saved');
    };
}

ViewModel._inherits(EventEmitter);

},{"../components/Activity":96,"events":false,"knockout":false}],56:[function(require,module,exports){
/**
    UserFees activity
**/
'use strict';

var Activity = require('../components/Activity');
var A = Activity.extends(function UserFeesActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = {};
    this.navBar = Activity.createSubsectionNavBar('Owner information', {
        backLink: 'ownerInfo'
    });
});

module.exports = A;

},{"../components/Activity":96}],57:[function(require,module,exports){
/**
    Verifications activity
**/
'use strict';

var ko = require('knockout'),
    Activity = require('../components/Activity');

var A = Activity.extends(function VerificationsActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Marketplace Profile', {
        backLink: '/marketplaceProfile'
    });
    
    // Setup special links behavior to add/perform specific verifications
    this.registerHandler({
        target: this.$activity,
        event: 'click',
        selector: '[href="#resendEmailConfirmation"]',
        handler: function() {
            this.app.modals.showNotification({
                message: 'TO-DO: resend email confirmation'
            });
        }.bind(this)
    });
    this.registerHandler({
        target: this.$activity,
        event: 'click',
        selector: '[href="#connectWithFacebook"]',
        handler: function() {
            this.app.modals.showNotification({
                message: 'TO-DO: ask for connect with Facebook API'
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);
    
    this.app.model.userVerifications.getList()
    .then(function(list) {
        this.viewModel.userVerifications(list());
    }.bind(this))
    .catch(function(err) {
        this.app.modals.showError({ title: 'Error loading your verifications', error: err });
    }.bind(this));
};

function ViewModel(app) {
    
    this.isSyncing = app.model.userVerifications.state.isSyncing;
    this.isLoading = app.model.userVerifications.state.isLoading;
    this.isSaving = app.model.userVerifications.state.isSaving;

    this.userVerifications = ko.observableArray();

    this.emailInfo = ko.observable('Please click on "Verify my account" in the e-mail we sent you to verify your address. <a class="btn btn-link btn-block"  href="#resendEmailConfirmation">Click here to resend.</a>');
    this.facebookInfo = ko.pureComputed(function() {
        var tpl = 'Letting potential __kind__ know you have a trusted online presence helps them know you\'re real. <a class="btn btn-link btn-block" href="#connectWithFacebook">Click here to connect your account.</a>';
        return tpl.replace(/__kind__/, app.model.user().isServiceProfessional() ? 'clients' : 'service professionals');
    });
}

/*
var UserVerification = require('../models/UserVerification'),
    Verification = require('../models/Verification');

function testdata() {
    
    var verA = new Verification({
            name: 'Email'
        }),
        verB = new Verification({
            name: 'Facebook'
        }),
        verC = new Verification({
            name: 'Loconomic\'s user-reviewed'
        });

    return [
        new UserVerification({
            statusID: Verification.status.confirmed,
            lastVerifiedDate: new Date(2015, 1, 12, 10, 23, 32),
            verification: verA
        }),
        new UserVerification({
            statusID: Verification.status.revoked,
            lastVerifiedDate: new Date(2015, 5, 20, 16, 4, 0),
            verification: verB
        }),
        new UserVerification({
            statusID: Verification.status.pending,
            lastVerifiedDate: new Date(2014, 11, 30, 19, 54, 4),
            verification: verC
        })
    ];
}
*/

},{"../components/Activity":96,"knockout":false}],58:[function(require,module,exports){
/**
    WeeklySchedule activity
**/
'use strict';

var Activity = require('../components/Activity');
var ko = require('knockout');

var A = Activity.extends(function WeeklyScheduleActivity() {
    
    Activity.apply(this, arguments);
    
    this.viewModel = new ViewModel(this.app);
    this.accessLevel = this.app.UserType.serviceProfessional;

    this.navBar = Activity.createSubsectionNavBar('Scheduling', {
        backLink: 'scheduling'
    });
    this.defaultNavBar = this.navBar.model.toPlainObject(true);
    
    this.registerHandler({
        target: this.app.model.simplifiedWeeklySchedule,
        event: 'error',
        handler: function(err) {
            var msg = err.task === 'save' ? 'Error saving your weekly schedule.' : 'Error loading your weekly schedule.';
            this.app.modals.showError({
                title: msg,
                error: err && err.task && err.error || err
            });
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.updateNavBarState = function updateNavBarState() {
    
    if (!this.app.model.onboarding.updateNavBar(this.navBar)) {
        // Reset
        this.navBar.model.updateWith(this.defaultNavBar, true);
    }
};

A.prototype.show = function show(state) {
    Activity.prototype.show.call(this, state);
    
    this.updateNavBarState();
    
    // Keep data updated:
    this.app.model.simplifiedWeeklySchedule.sync();
    // Discard any previous unsaved edit
    this.viewModel.discard();
};

function ViewModel(app) {

    var simplifiedWeeklySchedule = app.model.simplifiedWeeklySchedule;

    var scheduleVersion = simplifiedWeeklySchedule.newVersion();
    scheduleVersion.isObsolete.subscribe(function(itIs) {
        if (itIs) {
            // new version from server while editing
            // FUTURE: warn about a new remote version asking
            // confirmation to load them or discard and overwrite them;
            // the same is need on save(), and on server response
            // with a 509:Conflict status (its body must contain the
            // server version).
            // Right now, just overwrite current changes with
            // remote ones:
            scheduleVersion.pull({ evenIfNewer: true });
        }
    });
    
    // Actual data for the form:
    this.schedule = scheduleVersion.version;

    this.isLocked = simplifiedWeeklySchedule.isLocked;
    this.isSaving = simplifiedWeeklySchedule.isSaving;

    this.submitText = ko.pureComputed(function() {
        return (
            app.model.onboarding.inProgress() ?
                'Save and continue' :
                this.isLoading() ? 
                    'loading...' : 
                    this.isSaving() ? 
                        'saving...' : 
                        'Save'
        );
    }, simplifiedWeeklySchedule);
    
    this.discard = function discard() {
        scheduleVersion.pull({ evenIfNewer: true });
    };

    this.save = function save() {
        scheduleVersion.pushSave()
        .then(function() {
            if (app.model.onboarding.inProgress()) {
                app.model.onboarding.goNext();
            } else {
                app.successSave();
            }
        })
        .catch(function() {
            // catch error, managed on event
        });
    };
}

},{"../components/Activity":96,"knockout":false}],59:[function(require,module,exports){
/**
    Welcome activity
**/
'use strict';

var Activity = require('../components/Activity');

var A = Activity.extends(function WelcomeActivity() {
    
    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.loggedUser;
    
    var app = this.app;
    
    this.viewModel = {
        startOnboarding: function startOnboarding() {
            app.model.onboarding.goNext();
        }
    };
    
    this.navBar = new Activity.NavBar({
        title: null,
        leftAction: Activity.NavAction.goLogout,
        rightAction: null
    });
});

exports.init = A.init;

},{"../components/Activity":96}],60:[function(require,module,exports){
/**
    WorkPhotos activity
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    Activity = require('../components/Activity');

var A = Activity.extends(function WorkPhotosActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = this.app.UserType.serviceProfessional;
    this.viewModel = new ViewModel(this.app);
    // Defaults settings for navBar.
    this.navBar = Activity.createSubsectionNavBar('Job Title');

    // On changing jobTitleID:
    // - load photos
    /* TODO Uncomment and update on implementing REST API AppModel
    this.registerHandler({
        target: this.viewModel.jobTitleID,
        handler: function(jobTitleID) {
            if (jobTitleID) {
                // Get data for the Job title ID
                this.app.model.workphotos.getList(jobTitleID)
                .then(function(list) {
                    // Save for use in the view
                    this.viewModel.list(list);
                }.bind(this))
                .catch(function (err) {
                    this.app.modals.showError({
                        title: 'There was an error while loading.',
                        error: err
                    });
                }.bind(this));
            }
            else {
                this.viewModel.list([]);
            }
        }.bind(this)
    });*/
    // TODO Remove on implemented REST API
    this.viewModel.list(testdata());
    
    // Event handlers for photo list management
    this.registerHandler({
        target: this.$activity,
        selector: '.WorkPhotos-imgBtn',
        event: 'click',
        handler: function(event) {
            $(event.target).closest('li').toggleClass('is-selected');
        }.bind(this)
    });
});

exports.init = A.init;

A.prototype.show = function show(options) {
    Activity.prototype.show.call(this, options);

    var params = options && options.route && options.route.segments;
    this.viewModel.jobTitleID(params[0] |0);
};

function ViewModel(app) {

    this.jobTitleID = ko.observable(0);
    this.list = ko.observableArray([]);
    
    this.isSyncing = app.model.licensesCertifications.state.isSyncing();
    this.isLoading = app.model.licensesCertifications.state.isLoading();

    this.addNew = function() {
        // Pick a new photo
        this.openPhotoPicker()
        .then(function(img) {
            var newItem = new WorkPhoto({
                url: img,
                title: ''
            });
            this.list.push(newItem);
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({ error: err, title: 'Error getting photo.' });
        });
    }.bind(this);

    this.removeImg = function(item) {
        // Pick another photo to replace on 'item'
        this.list.remove(item);
    }.bind(this);

    this.openPhotoPicker = function() {
        /*global navigator,Camera*/
        return new Promise(function(resolve, reject) {
            if (navigator.camera && navigator.camera.getPicture) {
                navigator.camera.getPicture(function(img) {
                    resolve(img);
                }, function(err) {
                    // bug iOS note: http://plugins.cordova.io/#/package/org.apache.cordova.camera
                    setTimeout(function() {
                        reject(err);
                    }, 0);
                }, {
                    destinationType: Camera.DestinationType.FILE_URI,
                    targetWidth: 446,
                    targetHeight: 332,
                    saveToPhotoAlbum: true,
                    mediaType: Camera.MediaType.PICTURE,
                    correctOrientation: true
                });
            }
            else {
                // bug iOS note: http://plugins.cordova.io/#/package/org.apache.cordova.camera
                setTimeout(function() {
                    reject({ error: 'Unsupported', message: 'Impossible to get photo from device' });
                }, 0);
            }
        });
    };
    
    this.updateSort = function(/*info*/) {
        // TODO
    };
}



/// TESTDATA

var Model = require('../models/Model');
function WorkPhoto(values) {
    Model(this);
    
    this.model.defProperties({
        url: '',
        title: ''
    }, values);
}

function testdata() {
    return [
        new WorkPhoto({ url: 'https://loconomics.com/img/userphotos/u296/0c95dbccafd14953a94bde86eff4d34a-442x332.jpg', title: 'Testing photo 1' }),
        new WorkPhoto({ url: 'https://loconomics.com/img/userphotos/u296/3eb14073cb6a45138b6fd96b459bf3a1-442x332.jpg', title: 'Testing photo 2' }),
        new WorkPhoto({ url: 'https://loconomics.com/img/userphotos/u296/0c95dbccafd14953a94bde86eff4d34a-442x332.jpg', title: 'Testing photo 3' }),
        new WorkPhoto({ url: 'https://loconomics.com/img/userphotos/u296/3eb14073cb6a45138b6fd96b459bf3a1-442x332.jpg', title: 'Testing photo 4' })
    ];
}
},{"../components/Activity":96,"../models/Model":123,"knockout":false}],61:[function(require,module,exports){
/**
    Registration of custom html components used by the App.
    All with 'app-' as prefix.
    
    Some definitions may be included on-line rather than on separated
    files (viewmodels), templates are linked so need to be 
    included in the html file with the same ID that referenced here,
    usually using as DOM ID the same name as the component with sufix '-template'.
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    propTools = require('./utils/jsPropertiesTools'),
    getObservable = require('./utils/getObservable');

exports.registerAll = function(app) {
    
    /// navbar-action
    ko.components.register('app-navbar-action', {
        template: { element: 'navbar-action-template' },
        viewModel: function(params) {

            propTools.defineGetter(this, 'action', function() {
                return (
                    params.action && params.navBar() ?
                    params.navBar()[params.action]() :
                    null
                );
            });
        }
    });
    
    /// unlabeled-input
    ko.components.register('app-unlabeled-input', {
        template: { element: 'unlabeled-input-template' },
        viewModel: function(params) {

            this.value = getObservable(params.value);
            this.placeholder = getObservable(params.placeholder);
            this.disable = getObservable(params.disable);
            
            var userAttr = getObservable(params.attr);
            this.attr = ko.pureComputed(function() {
                var attr = userAttr() || {};
                return $.extend({}, attr, {
                    'aria-label': this.placeholder(),
                    placeholder: this.placeholder(),
                    type: this.type()
                });
            }, this);
            
            var type = getObservable(params.type);            
            this.type = ko.computed(function() {
                return type() || 'text';
            }, this);
        }
    });
    
    /// feedback-entry
    ko.components.register('app-feedback-entry', {
        template: { element: 'feedback-entry-template' },
        viewModel: function(params) {

            this.section = getObservable(params.section || '');
            this.url = ko.pureComputed(function() {
                return '/feedbackForm/' + this.section();
            }, this);
        }
    });
    
    /// feedback-entry
    ko.components.register('app-time-slot-tile', {
        template: { element: 'time-slot-tile-template' },
        viewModel: require('./viewmodels/TimeSlot')
    });
    
    /// loading-spinner
    ko.components.register('app-loading-spinner', {
        template: { element: 'loading-spinner-template' },
        viewModel: function(params) {
            var base = 'loadingSpinner';
            this.mod = getObservable(params.mod || '');
            this.cssClass = ko.pureComputed(function() {
                var c = base,
                    mods = (this.mod() || '').split(' ');
                if (mods.length)
                    c += ' ' + base + '--' + mods.join(' ' + base + '--');
                return c;
            }, this);
        }
    });

    /// appointment-card
    ko.components.register('app-appointment-card', {
        template: { element: 'appointment-card-template' },
        viewModel: require('./viewmodels/AppointmentCard')
    });
    
    /// job titles list
    ko.components.register('app-job-titles-list', {
        template: { element: 'job-titles-list-template' },
        viewModel: function(params) {
            this.jobTitles = getObservable(params.jobTitles || []);
            this.selectJobTitle = params.selectJobTitle || function() {};
            this.showMarketplaceInfo = getObservable(params.showMarketplaceInfo || false);
        }
    });
    
    /// Stars
    ko.components.register('app-stars-rating', {
        template: { element: 'stars-rating-template' },
        viewModel: function(params) {
            this.rating = getObservable(params.rating || 2.5);
            this.total = getObservable(params.total || 0);
            
            this.stars = ko.pureComputed(function() {
                var r = this.rating(),
                    list = [];
                for (var i = 1; i <= 5; i++) {
                    // TODO Support half values
                    list.push(i <= r ? 1 : 0);
                }
                return list;
            }, this);

            this.totalText = ko.pureComputed(function() {
                // TODO Conditional formatting for big numbers cases
                return '(' + this.total() + ')';
            }, this);
        }
    });
    
    /// ServiceProfessionalInfo
    var PublicUser = require('./models/PublicUser');
    ko.components.register('app-service-professional-info', {
        synchronous: true,
        template: { element: 'service-professional-info-template' },
        viewModel: {
            createViewModel: function(params) {
                var view = new PublicUser();
                if (params && params.api)
                    params.api(view);
                
                return view;
            }
        }
    });
    
    /// DatetimePicker
    var DateTimePickerVM = require('./viewmodels/DatetimePicker');
    ko.components.register('app-datetime-picker', {
        synchronous: true,
        template: { element: 'datetime-picker-template' },
        viewModel: {
            createViewModel: function(params, componentInfo) {
                var view = new DateTimePickerVM(app, componentInfo.element);
                if (params && params.api)
                    params.api(view);

                if (params)
                    Object.keys(params).forEach(function(key) {
                        if (ko.isObservable(view[key])) {
                            view[key](ko.unwrap(params[key]));
                            if (ko.isObservable(params[key]))
                                view[key].subscribe(params[key]);
                        }
                    });
                
                return view;
            }
        }
    });
};

},{"./models/PublicUser":129,"./utils/getObservable":176,"./utils/jsPropertiesTools":179,"./viewmodels/AppointmentCard":195,"./viewmodels/DatetimePicker":198,"./viewmodels/TimeSlot":206,"knockout":false}],62:[function(require,module,exports){
/**
    Navbar extension of the App,
    adds the elements to manage a view model
    for the NavBar and automatic changes
    under some model changes like user login/logout
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    NavBar = require('./viewmodels/NavBar'),
    NavAction = require('./viewmodels/NavAction');

exports.extends = function (app) {
    
    // REVIEW: still needed? Maybe the per activity navBar means
    // this is not needed. Some previous logic was already removed
    // because was useless.
    //
    // Adjust the navbar setup depending on current user,
    // since different things are need for logged-in/out.
    function adjustUserBar() {

        var user = app.model.user();

        if (user.isAnonymous()) {
            var prev = app.navBar().leftAction();
            if (prev !== NavAction.menuOut) {
                app.navBar().leftAction(NavAction.menuOut);
                app.navBar().prevLeftAction = prev;
            }
        }
        else if (app.navBar().prevLeftAction) {
            app.navBar().leftAction(app.navBar().prevLeftAction);
            app.navBar().prevLeftAction = null;
        }
    }
    // Commented lines, used previously but unused now, it must be enough with the update
    // per activity change
    //app.model.user().isAnonymous.subscribe(updateStatesOnUserChange);
    //app.model.user().onboardingStep.subscribe(updateStatesOnUserChange);
    
    app.navBar = ko.observable(null);
    
    var refreshNav = function refreshNav() {
        // Trigger event to force a component update
        $('.AppNav').trigger('contentChange');
    };
    var autoRefreshNav = function autoRefreshNav(action) {
        if (action) {
            action.text.subscribe(refreshNav);
            action.isTitle.subscribe(refreshNav);
            action.icon.subscribe(refreshNav);
            action.isMenu.subscribe(refreshNav);
        }
    };

    /**
        Update the nav model using the Activity defaults
        // TODO Look a way to replace all this complex navbar logic, maybe per
        // activity nabvars, more model helpers and global state helpers.
    **/
    app.updateAppNav = function updateAppNav(activity, state) {

        // if the activity has its own
        if ('navBar' in activity) {
            if (activity.navBar === null) {
                // Activity requires no menu, create a hidden NavBar instance
                app.navBar(new NavBar({
                    hidden: true
                }));
            }
            else {
                // Use specializied activity bar data
                app.navBar(activity.navBar);
            }
        }
        else {
            // Use default one
            app.navBar(new NavBar());
        }
        
        if (!app.applyNavbarMustReturn(state)) {
            // Changes depending on non-logged user
            adjustUserBar();
        }
        
        refreshNav();
        autoRefreshNav(app.navBar().leftAction());
        autoRefreshNav(app.navBar().rightAction());
    };
    
    app.applyNavbarMustReturn = function(state) {
        if (state && state.route && state.route.query &&
            state.route.query.mustReturn) {
            var returnLink = decodeURIComponent(state.route.query.mustReturn);
            // A text can be provided
            var returnText = decodeURIComponent(state.route.query.returnText || '');
            if (returnLink === '1' || returnLink === 'true') {
                // Left action forced to be a go-back
                app.navBar().leftAction(NavAction.goBack.model.clone({
                    text: returnText,
                    isShell: true,
                    isTitle: true
                }));
            }
            else {
                // Left action force to return to the given URL
                app.navBar().leftAction(NavAction.goBack.model.clone({
                    link: returnLink,
                    text: returnText,
                    isShell: false,
                    isTitle: true
                }));
            }
            return true;
        }
        return false;
    };
    
    
    /**
        Update the app menu to highlight the
        given link name
    **/
    app.updateMenu = function updateMenu(name) {
        
        var $menu = $('.App-menus .navbar-collapse');
        
        // Remove any active
        $menu
        .find('li')
        .removeClass('active');
        // Add active
        $menu
        .find('.go-' + name)
        .closest('li')
        .addClass('active');
        // Hide menu
        $menu
        .filter(':visible')
        .collapse('hide');
    };
    
    app.setupNavBarBinding = function setupNavBarBinding() {
        // Set model for the AppNav
        app.navBarBinding = {
            navBar: app.navBar,
            // Both: are later filled with a call to the model once loaded and ready
            photoUrl: ko.observable('about:blank'),
            userName: ko.observable('Me'),
            isServiceProfessional: ko.observable(false),
            isClient: ko.observable(false)
        };
        ko.applyBindings(app.navBarBinding, $('.AppNav').get(0));
    };
    
    /**
        Performs the 'back' task from the navbar link, if any.
        That is, trigger the left action.
        Fallback to shell goBack
    **/
    app.performsNavBarBack = function performsNavBarBack(options) {
        var nav = this.navBar(),
            left = nav && nav.leftAction(),
            $btn = $('.SmartNavBar-edge.left > a.SmartNavBar-btn');

        // There is an action, trigger like a click so all the handlers
        // attached on spare places do their work:
        if (left && !left.isMenu()) {
            var event = $.Event('click');
            event.options = options || {};
            $btn.trigger(event);
        }
        else if (this.shell) {
            this.shell.goBack();
        }
    };
    
    /**
        It shows an unobtrusive notification on the navbar place, that
        hides after a short timeout
    **/
    var lastNotificationTimer = null;
    app.showNavBarNotification = function showNavBarNotification(settings) {
        var msg = settings && settings.message || 'Hello World!',
            duration = settings && settings.duration || 2000,
            transitionDuration = settings && settings.transitionDuration || 400,
            $el = $('.AppNav .SmartNavBar-notification');

        $el.text(msg);
        $el.fadeIn(transitionDuration)
        .queue(function() {
            
            // Manual hide on clicking
            $el
            .off('click.manualHide')
            .on('click.manualHide', function() {
                $el.fadeOut(transitionDuration);
            });
            
            // Auto hide after timeout
            clearTimeout(lastNotificationTimer);
            lastNotificationTimer = setTimeout(function() {
                $el.fadeOut(transitionDuration);
            }, duration);
            
            $(this).dequeue();
        });
    };
};

},{"./viewmodels/NavAction":200,"./viewmodels/NavBar":201,"knockout":false}],63:[function(require,module,exports){
/**
    List of activities loaded in the App,
    as an object with the activity name as the key
    and the controller as value.
**/
'use strict';

var Activity = require('./components/Activity');
var EmptyActivity = Activity.extends(function EmptyActivity() {

    Activity.apply(this, arguments);

    this.accessLevel = null;
    this.viewModel = {};
    this.navBar = Activity.createSectionNavBar();
});

module.exports = {
    '_test': EmptyActivity,
    'calendar': require('./activities/calendar'),
    'datetimePicker': require('./activities/datetimePicker'),
    'clients': require('./activities/clients'),
    'serviceProfessionalService': require('./activities/serviceProfessionalService'),
    'serviceAddresses': require('./activities/serviceAddresses'),
    'textEditor': require('./activities/textEditor'),
    'dashboard': require('./activities/dashboard'),
    'appointment': require('./activities/appointment'),
    'index': require('./activities/index'),
    'login': require('./activities/login'),
    'logout': require('./activities/logout'),
    'learnMore': require('./activities/learnMore'),
    'signup': require('./activities/signup'),
    'contactInfo': require('./activities/contactInfo'),
    'welcome': require('./activities/welcome'),
    'addressEditor': require('./activities/addressEditor'),
    'account': require('./activities/account'),
    'inbox': require('./activities/inbox'),
    'conversation': require('./activities/conversation'),
    'scheduling': require('./activities/scheduling'),
    'jobtitles': require('./activities/jobtitles'),
    'feedback': require('./activities/feedback'),
    'faqs': require('./activities/faqs'),
    'feedbackForm': require('./activities/feedbackForm'),
    'contactForm': require('./activities/contactForm'),
    'cms': require('./activities/cms'),
    'clientEditor': require('./activities/clientEditor'),
    'schedulingPreferences': require('./activities/schedulingPreferences'),
    'calendarSyncing': require('./activities/calendarSyncing'),
    'weeklySchedule': require('./activities/weeklySchedule'),
    'bookMeButton': require('./activities/bookMeButton'),
    'ownerInfo': require('./activities/ownerInfo'),
    'privacySettings': require('./activities/privacySettings'),
    'addJobTitles': require('./activities/addJobTitles'),
    'serviceProfessionalServiceEditor': require('./activities/serviceProfessionalServiceEditor'),
    'marketplaceProfile': require('./activities/marketplaceProfile'),
    'marketplaceJobtitles': require('./activities/marketplaceJobtitles'),
    'profilePictureBio': require('./activities/profilePictureBio'),
    'servicesOverview': require('./activities/servicesOverview'),
    'verifications': require('./activities/verifications'),
    'education': require('./activities/education'),
    'serviceProfessionalWebsite': require('./activities/serviceProfessionalWebsite'),
    'backgroundCheck': require('./activities/backgroundCheck'),
    'educationForm': require('./activities/educationForm'),
    'cancellationPolicy': require('./activities/cancellationPolicy'),
    'licensesCertifications': require('./activities/licensesCertifications'),
    'licensesCertificationsForm': require('./activities/licensesCertificationsForm'),
    'workPhotos': require('./activities/workPhotos'),
    'profile': require('./activities/profile'),
    'home': require('./activities/home'),
    'booking': require('./activities/booking'),
    'terms': require('./activities/terms'),
    'payments': require('./activities/payments'),
    'userFees': require('./activities/userFees'),
    'performance': require('./activities/performance')
};

},{"./activities/account":6,"./activities/addJobTitles":7,"./activities/addressEditor":8,"./activities/appointment":9,"./activities/backgroundCheck":10,"./activities/bookMeButton":11,"./activities/booking":12,"./activities/calendar":13,"./activities/calendarSyncing":14,"./activities/cancellationPolicy":15,"./activities/clientEditor":16,"./activities/clients":17,"./activities/cms":18,"./activities/contactForm":19,"./activities/contactInfo":20,"./activities/conversation":21,"./activities/dashboard":22,"./activities/datetimePicker":23,"./activities/education":24,"./activities/educationForm":25,"./activities/faqs":26,"./activities/feedback":27,"./activities/feedbackForm":28,"./activities/home":29,"./activities/inbox":30,"./activities/index":31,"./activities/jobtitles":32,"./activities/learnMore":33,"./activities/licensesCertifications":34,"./activities/licensesCertificationsForm":35,"./activities/login":36,"./activities/logout":37,"./activities/marketplaceJobtitles":38,"./activities/marketplaceProfile":39,"./activities/ownerInfo":40,"./activities/payments":41,"./activities/performance":42,"./activities/privacySettings":43,"./activities/profile":44,"./activities/profilePictureBio":45,"./activities/scheduling":46,"./activities/schedulingPreferences":47,"./activities/serviceAddresses":48,"./activities/serviceProfessionalService":49,"./activities/serviceProfessionalServiceEditor":50,"./activities/serviceProfessionalWebsite":51,"./activities/servicesOverview":52,"./activities/signup":53,"./activities/terms":54,"./activities/textEditor":55,"./activities/userFees":56,"./activities/verifications":57,"./activities/weeklySchedule":58,"./activities/welcome":59,"./activities/workPhotos":60,"./components/Activity":96}],64:[function(require,module,exports){
'use strict';

/** Global dependencies **/
var $ = require('jquery');
require('jquery-mobile');
require('./utils/jquery.multiline');
var ko = require('knockout');
ko.bindingHandlers.format = require('ko/formatBinding').formatBinding;
var bootknock = require('./utils/bootknockBindingHelpers');
require('./utils/Function.prototype._inherits');
require('./utils/Function.prototype._delayed');
// Polyfill for useful non-standard feature Function.name for IE9+
// (feature used to simplify creation of Activities and Models)
require('./utils/Function.prototype.name-polyfill');
// Promise polyfill, so its not 'require'd per module:
require('es6-promise').polyfill();

var layoutUpdateEvent = require('layoutUpdateEvent');
var AppModel = require('./appmodel/AppModel');

// Register the special locale
require('./locales/en-US-LC');

var attachFastClick = require('fastclick').attach;

/**
    A set of fixes/workarounds for Bootstrap behavior/plugins
    to be executed before Bootstrap is included/executed.
    For example, because of data-binding removing/creating elements,
    some old references to removed items may get alive and need update,
    or re-enabling some behaviors.
**/
function preBootstrapWorkarounds() {
    // Internal Bootstrap source utility
    function getTargetFromTrigger($trigger) {
        var href,
            target = $trigger.attr('data-target') ||
            (href = $trigger.attr('href')) && 
            href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

        return $(target);
    }
    
    // Bug: navbar-collapse elements hold a reference to their original
    // $trigger, but that trigger can change on different 'clicks' or
    // get removed the original, so it must reference the new one
    // (the latests clicked, and not the cached one under the 'data' API).    
    // NOTE: handler must execute before the Bootstrap handler for the same
    // event in order to work.
    $(document).on('click.bs.collapse.data-api.workaround', '[data-toggle="collapse"]', function() {
        var $t = $(this),
            $target = getTargetFromTrigger($t),
            data = $target && $target.data('bs.collapse');
        
        // If any
        if (data) {
            // Replace the trigger in the data reference:
            data.$trigger = $t;
        }
        // On else, nothing to do, a new Collapse instance will be created
        // with the correct target, the first time
    });
}

/**
    App static class
**/
var app = {
    shell: require('./app.shell'),
    
    // New app model, that starts with anonymous user
    model: new AppModel(),
    
    /** Load activities controllers (not initialized) **/
    activities: require('./app.activities'),
    
    modals: require('./app.modals'),
    
    /**
        Just redirect the better place for current user and state.
        NOTE: Its a delayed function, since on many contexts need to
        wait for the current 'routing' from end before do the new
        history change.
        TODO: Maybe, rather than delay it, can stop current routing
        (changes on Shell required) and perform the new.
        TODO: Maybe alternative to previous, to provide a 'replace'
        in shell rather than a go, to avoid append redirect entries
        in the history, that create the problem of 'broken back button'
    **/
    goDashboard: function goDashboard() {
        
        // To avoid infinite loops if we already are performing 
        // a goDashboard task, we flag the execution
        // being care of the delay introduced in the execution
        if (goDashboard._going === true) {
            return;
        }
        else {
            // Delayed to avoid collisions with in-the-middle
            // tasks: just allowing current routing to finish
            // before perform the 'redirect'
            // TODO: change by a real redirect that is able to
            // cancel the current app.shell routing process.
            setTimeout(function() {
        
                goDashboard._going = true;

                var onboarding = this.model.onboarding.stepUrl();

                if (onboarding) {
                    this.shell.go(onboarding);
                }
                else {
                    this.shell.go('/dashboard');
                }

                // Just because is delayed, needs
                // to be set off after an inmediate to 
                // ensure is set off after any other attempt
                // to add a delayed goDashboard:
                setTimeout(function() {
                    goDashboard._going = false;
                }, 1);
            }.bind(this), 1);
        }
    }
};

/** Continue app creation with things that need a reference to the app **/

require('./app-navbar').extends(app);

require('./app-components').registerAll(app);

app.getActivity = function getActivity(name) {
    var activity = this.activities[name];
    if (activity) {
        var $act = this.shell.items.find(name);
        if ($act && $act.length)
            return activity.init($act, this);
    }
    return null;
};

app.getActivityControllerByRoute = function getActivityControllerByRoute(route) {
    // From the route object, the important piece is route.name
    // that contains the activity name except if is the root
    var actName = route.name || this.shell.indexName;
    
    return this.getActivity(actName);
};

// accessControl setup: cannot be specified on Shell creation because
// depends on the app instance
app.shell.accessControl = require('./utils/accessControl')(app);

// Shortcut to UserType enumeration used to set permissions
app.UserType = require('./models/User').UserType;

// New method for common forms behavior after a successful save operation,
// the activity goes back (following the navbar back-link or shell.goBack())
// and notifying with a temporary unobtrusive navbar notification
app.successSave = function successSave(settings) {
    // defaults
    settings = $.extend({
        message: 'Your changes have been saved',
        link: null
    }, settings);
    
    // show notification
    this.showNavBarNotification(settings);
    
    // requested link or current activity go back
    if (settings.link)
        this.shell.go(settings.link);
    else
        this.performsNavBarBack({ silentMode: true });
};

/** App Init **/
var appInit = function appInit() {
    /*jshint maxstatements:50,maxcomplexity:16 */
    
    attachFastClick(document.body);
    
    // Jquery-ui components used
    require('jquery-ui/autocomplete');
    // Knockout binding for jquery-ui sortable.
    // It loads jquery-ui sortable and draggable as dependencies:
    require('knockout-sortable');
    // Just AFTER jquery-ui is loaded (or the selected components), load
    // the fix for touch support:
    require('jquery.ui.touch-punch');
    
    // Enabling the 'layoutUpdate' jQuery Window event that happens on resize and transitionend,
    // and can be triggered manually by any script to notify changes on layout that
    // may require adjustments on other scripts that listen to it.
    // The event is throttle, guaranting that the minor handlers are executed rather
    // than a lot of them in short time frames (as happen with 'resize' events).
    layoutUpdateEvent.layoutUpdateEvent += ' orientationchange';
    layoutUpdateEvent.on();
    
    // Keyboard plugin events are not compatible with jQuery events, but needed to
    // trigger a layoutUpdate, so here are connected, mainly fixing bugs on iOS when the keyboard
    // is hidding.
    var trigLayout = function trigLayout() {
        $(window).trigger('layoutUpdate');
    };
    window.addEventListener('native.keyboardshow', trigLayout);
    window.addEventListener('native.keyboardhide', trigLayout);

    // iOS-7+ status bar fix. Apply on plugin loaded (cordova/phonegap environment)
    // and in any system, so any other systems fix its solved too if needed 
    // just updating the plugin (future proof) and ensure homogeneous cross plaftform behavior.
    if (window.StatusBar) {
        // Fix iOS-7+ overlay problem
        // Is in config.xml too, but seems not to work without next call:
        window.StatusBar.overlaysWebView(false);
    }
    
    // Force an update delayed to ensure update after some things did additional work
    setTimeout(function() {
        $(window).trigger('layoutUpdate');
    }, 200);
    
    // Bootstrap
    preBootstrapWorkarounds();
    require('bootstrap');
    
    // Load Knockout binding helpers
    bootknock.plugIn(ko);
    require('./utils/bootstrapSwitchBinding').plugIn(ko);
    
    // Plugins setup
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
        // Explicitely, we WANT auto scroll on keyboard show up.
        // Can be disabled only if there is a javascript solution to autoscroll
        // on input focus, else a bug will happen specially on iOS where input
        // fields gets hidden by the on screen keyboard.
        window.cordova.plugins.Keyboard.disableScroll(false);
    }
    
    // Easy links to shell actions, like goBack, in html elements
    // Example: <button data-shell="goBack 2">Go 2 times back</button>
    // NOTE: Important, registered before the shell.run to be executed
    // before its 'catch all links' handler
    $(document).on('click', '[data-shell]', function(e) {
        // Using attr rather than the 'data' API to get updated
        // DOM values
        var cmdline = $(this).attr('data-shell') || '',
            args = cmdline.split(' '),
            cmd = args[0];

        if (cmd && typeof(app.shell[cmd]) === 'function') {
            app.shell[cmd].apply(app.shell, args.slice(1));
            
            // Cancel any other action on the link, to avoid double linking results
            e.stopImmediatePropagation();
            e.preventDefault();
        }
    });
    
    // On Cordova/Phonegap app, special targets must be called using the window.open
    // API to ensure is correctly opened on the InAppBrowser (_blank) or system default
    // browser (_system).
    if (window.cordova) {
        $(document).on('click', '[target="_blank"], [target="_system"]', function(e) {
            window.open(this.getAttribute('href'), this.getAttribute('target'));
            e.preventDefault();
        });
    }
    
    // When an activity is ready in the Shell:
    app.shell.on(app.shell.events.itemReady, function($act, state) {
        
        // Must be the same:
        var routeName = app.shell.currentRoute.name;
        var actName = $act.data('activity');
        // If not, some race condition, not the same page go out
        if (routeName !== actName)
            return;

        // Connect the 'activities' controllers to their views
        var activity = app.getActivity(actName);
        // Trigger the 'show' logic of the activity controller:
        activity.show(state);
        
        // The show logic may do a redirect, loading other activity, double check
        routeName = app.shell.currentRoute.name;
        if (routeName !== actName)
            return;

        // Update menu
        var menuItem = activity.menuItem || actName;
        app.updateMenu(menuItem);

        // Update app navigation
        app.updateAppNav(activity, state);
    });
    // When an activity is hidden
    app.shell.on(app.shell.events.closed, function($act) {
        
        // Connect the 'activities' controllers to their views
        var actName = $act.data('activity');
        var activity = app.getActivity(actName);
        // Trigger the 'hide' logic of the activity controller:
        if (activity.hide)
            activity.hide();
    });
    // Catch errors on item/page loading, showing..
    app.shell.on('error', function(err) {
        app.modals.showError({ error: err });
    });
    
    // Scroll to element when clicking a usual fragment link (not a page link)
    var scrollToElement = require('./utils/scrollToElement');
    app.shell.on('fragmentNavigation', function(href) {
        // Check link, avoiding empty links
        // (href comes with the initial hash ever, so empty is just '#')
        if (href === '#') {
            // Notify for debugging, because this may be unwanted
            console.warn(
                'Navigation to an empty fragment, this may be not wanted. ' +
                'For root links, use "/"; on script handled links, call event.preventDefault; ' +
                'A touch event was listened on a link, but not the click event.'
            );
        }
        else {
            // Locate target
            var target = $(href);
            if (target.length) {
                // Smooth scrolling with animation
                scrollToElement(target, { animation: { duration: 300 } });
            }
        }
    });
    
    // Navbar binding
    app.setupNavBarBinding();
    
    var SmartNavBar = require('./components/SmartNavBar');
    var navBars = SmartNavBar.getAll();
    // Creates an event by listening to it, so other scripts can trigger
    // a 'contentChange' event to force a refresh of the navbar (to 
    // calculate and apply a new size); expected from dynamic navbars
    // that change it content based on observables.
    navBars.forEach(function(navbar) {
        $(navbar.el).on('contentChange', function() {
            navbar.refresh();
        });
    });
    
    // Listen for menu events (collapse in SmartNavBar)
    // to apply the backdrop; add another class, explicit for know the menu/nav is opened
    var togglingBackdrop = false;
    $(document).on('show.bs.collapse hide.bs.collapse', '.AppNav .navbar-collapse', function(e) {
        if (!togglingBackdrop) {
            togglingBackdrop = true;
            var enabled = e.type === 'show';
            $('body').toggleClass('use-backdrop', enabled);
            $('body').toggleClass('has-appNav-open', enabled);
            // Hide any other opened collapse
            $('.collapsing, .collapse.in').collapse('hide');
            togglingBackdrop = false;
        }
    });

    // Catch uncatch model errors
    app.model.on('error', function(err) {
        app.modals.showError({
            error: err
        });
    });
    
    // Additional form elements attribute and behavior: data-autoselect=true
    // sets to automatically select the text content of an input text control
    // when gets the focus
    $(document).on('focus', '[data-autoselect="true"]', function() {
        $(this).select();
    });
    
    // App init:
    var alertError = function(err) {
        app.modals.showError({
            title: 'There was an error loading',
            error: err
        });
    };
    
    if (window.instabug) {
        window.instabug.init({
            iosToken: '515d9e90bd68a18182a05e2a68689897',
            androidToken: '9856054e92e7ae7a8326f1666703d51d'
        });
    }

    app.model.init()
    .then(app.shell.run.bind(app.shell), alertError)
    .then(function() {
        // Mark the page as ready
        $('html').addClass('is-ready');
        // As app, hides splash screen
        if (window.navigator && window.navigator.splashscreen) {
            window.navigator.splashscreen.hide();
        }
        
        // Connect username in navbar, and type flags
        ko.computed(function() {
            var u = app.model.userProfile.data,
                n = u.firstName();
            app.navBarBinding.userName(n || 'Me');
            app.navBarBinding.isServiceProfessional(u.isServiceProfessional());
            app.navBarBinding.isClient(u.isClient());
        });
        // Connect photoUrl in navbar
        ko.computed(function() {
            var n = app.model.marketplaceProfile.data.photoUrl();
            app.navBarBinding.photoUrl(n || 'about:blank');
        });
        
        // Onboarding model needs initialization
        app.model.onboarding.init(app);

        // Check onboarding step to redirect there on app start
        var step = app.model.user().onboardingStep();
        if (step && 
            app.model.onboarding.setStep(step)) {
            var url = app.model.onboarding.stepUrl();
            app.shell.go(url);
        }

    }, alertError);

    // DEBUG
    window.app = app;
};

// App init on page ready and phonegap ready
if (window.cordova) {
    // On DOM-Ready first
    $(function() {
        // Page is ready, device is too?
        // Note: Cordova ensures to call the handler even if the
        // event was already fired, so is good to do it inside
        // the dom-ready and we are ensuring that everything is
        // ready.
        $(document).on('deviceready', appInit);
    });
} else {
    // Only on DOM-Ready, for in browser development
    $(appInit);
}

},{"./app-components":61,"./app-navbar":62,"./app.activities":63,"./app.modals":65,"./app.shell":66,"./appmodel/AppModel":79,"./components/SmartNavBar":98,"./locales/en-US-LC":99,"./models/User":142,"./utils/Function.prototype._delayed":153,"./utils/Function.prototype._inherits":154,"./utils/Function.prototype.name-polyfill":155,"./utils/accessControl":165,"./utils/bootknockBindingHelpers":167,"./utils/bootstrapSwitchBinding":168,"./utils/jquery.multiline":178,"./utils/scrollToElement":182,"es6-promise":false,"jquery-ui/autocomplete":1,"knockout":false,"knockout-sortable":false}],65:[function(require,module,exports){
/**
    Access to use global App Modals
**/
'use strict';

var $ = require('jquery');

/**
    Generates a text message, with newlines if needed, describing the error
    object passed.
    @param err:any As a string, is returned 'as is'; as falsy, it return a generic
    message for 'unknow error'; as object, it investigate what type of error is to
    provide the more meaninful result, with fallback to JSON.stringify prefixed
    with 'Technical details:'.
    Objects recognized:
    - XHR/jQuery for JSON responses: just objects with responseJSON property, is
      used as the 'err' object and passed to the other object tests.
    - Object with 'errorMessage' (server-side formatted error).
    - Object with 'message' property, like the standard Error class and Exception objects.
    - Object with 'name' property, like the standard Exception objects. The name, if any,
      is set as prefix for the 'message' property value.
    - Object with 'errors' property. Each element in the array or object own keys
      is appended to the errorMessage or message separated by newline.
**/
exports.getErrorMessageFrom = function getErrorMessageFrom(err, defaultText) {
    /*jshint maxcomplexity:14, maxdepth:5*/

    defaultText = defaultText || 'Unknow error';
    
    if (!err) {
        return defaultText;
    }
    else if (typeof(err) === 'string') {
        return err || defaultText;
    }
    else {
        // If is a XHR object, use its response as the error.
        err = err.responseJSON || err;

        var msg = err.name && (err.name + ': ') || '';
        msg += err.errorMessage || err.message || '';

        if (err.errors) {
            msg += '\n' + exports.stringifyErrorsList(err.errors);
        }
        else {
            // Avoiding that en error converting the object (circular references)
            // breaks the error control!
            try {
                var jserr = JSON.stringify(err);
                // Avoiding that empty results (empty string or empty object when there
                // is no details to show) makes us to show an annoying 'technical details'
                var hasMoreInfo = jserr && jserr !== '{}';
                // Too if there is no more information than the one extracted to build the
                // message, since on that cases the 'technical details' will be just a 
                // json formatted of the same displayed message
                if (hasMoreInfo) {
                    // Reset initially, re-enabled only if there are more properties
                    // than the ones from the list
                    hasMoreInfo = false;
                    var messagePropertiesList = ['name', 'errorMessage', 'message', 'errors'];
                    Object.keys(err).forEach(function(key) {
                        if (messagePropertiesList.indexOf(key) === -1)
                            hasMoreInfo = true;
                    });
                }

                if (hasMoreInfo)
                    msg += '\n\nTechnical details: ' + jserr;
            }
            catch (ex) {
                console.log('Impossible to stringify JSON error', err, ex);
            }
        }

        return msg || defaultText;
    }
};

exports.stringifyErrorsList = function (errors) {
    var msg = '';
    if (Array.isArray(errors)) {
        msg = errors.join('\n');
    }
    else {
        msg = Object.keys(errors).map(function(key) {
            return errors[key].join('\n');
        }).join('\n');
    }
    return msg;
};

/**
    Show an error modal to notify the user.
    @param options:Object {
        message:string DEPRECATED. Optional. Informative error message.
        error:string Optional. Error/Exception/XHR object, used to auto
            generate the error message. It takes precedence over 'message'
            option, discarding an error object/string is passed.
            It replaces 'message' since can do the same and more.
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when the modal is dismissed/closed.
    No formal rejection happens.
**/
exports.showError = function showErrorModal(options) {
    
    var modal = $('#errorModal'),
        header = modal.find('#errorModal-label'),
        body = modal.find('#errorModal-body');
    
    options = options || {};
    
    // Fallback error message
    var msg = body.data('default-text');

    // Error message from given error object, with fallback to default one.
    // DEPRECATED temporarly using the 'message' option.
    msg = exports.getErrorMessageFrom(options.error || options.message, msg);

    body.multiline(msg);

    header.text(options.title || header.data('default-text'));
    
    return new Promise(function(resolve) {
        modal.modal('show');
        modal.on('hide.bs.modal', function() {
            resolve();
        });
    });
};

/**
    Show confirmation modal with two buttons.
    @param options:object {
        title:string Header title text
        message:string Message text
        yes:string Yes button label
        no:string No button label
    }
    @returns Promise. It resolves if button 'yes' pressed
    and reject on button 'no' pressed or modal dismissed/closed.
**/
exports.confirm = function confirm(options) {
    
    var modal = $('#confirmModal'),
        header = modal.find('#confirmModal-label'),
        body = modal.find('#confirmModal-body'),
        yesBtn = modal.find('#confirmModal-yesBtn'),
        noBtn = modal.find('#confirmModal-noBtn');

    options = options || {};

    // Fallback error message
    var title = header.data('default-text'),
        msg = body.data('default-text'),
        yes = yesBtn.data('default-text'),
        no = noBtn.data('default-text');

    body.multiline(options.message || msg);
    header.text(options.title || title);
    yesBtn.text(options.yes || yes);
    noBtn.text(options.no || no);

    return new Promise(function(resolve, reject) {
        modal.modal('show');
        yesBtn.on('click', function() {
            resolve();
        });
        noBtn.on('click', function() {
            reject();
        });
        modal.on('hide.bs.modal', function() {
            reject();
        });
    });
};

/**
    Show an information modal to notify the user about something.
    @param options:Object {
        message:string. Informative message.
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when the modal is dismissed/closed.
    No formal rejection happens.
**/
exports.showNotification = function showNotification(options) {
    
    var modal = $('#notificationModal'),
        header = modal.find('#notificationModal-label'),
        button = modal.find('#notificationModal-button'),
        body = modal.find('#notificationModal-body');

    options = options || {};
    
    // Fallback message
    var msg = options.message || body.data('default-text');

    body.multiline(msg);

    header.text(options.title || header.data('default-text'));
    button.text(options.buttonText || button.data('default-text'));
    
    return new Promise(function(resolve) {
        modal.modal('show');
        modal.on('hide.bs.modal', function() {
            resolve();
        });
    });
};

exports.showTimePicker = require('./modals/timePicker').show;

exports.showTextEditor = require('./modals/textEditor').show;

},{"./modals/textEditor":100,"./modals/timePicker":101}],66:[function(require,module,exports){
/**
    Setup of the shell object used by the app
**/
'use strict';

var baseUrl = window.location.pathname;

//var History = require('./app-shell-history').create(baseUrl);
var History = require('./utils/shell/hashbangHistory');

// Shell dependencies
var shell = require('./utils/shell/index'),
    Shell = shell.Shell,
    DomItemsManager = shell.DomItemsManager;

//var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );

// Creating the shell:
var shell = new Shell({

    // Selector, DOM element or jQuery object pointing
    // the root or container for the shell items
    root: 'App-activities', //'body',

    // If is not in the site root, the base URL is required:
    baseUrl: baseUrl,
    
    forceHashbang: true,

    indexName: 'index',

    linkEvent: 'click',

    // No need for loader, everything comes bundled
    loader: null,

    // History Polyfill:
    history: History,

    // A DomItemsManager or equivalent object instance needs to
    // be provided:
    domItemsManager: new DomItemsManager({
        idAttributeName: 'data-activity',
        root: '.App-activities'
    })
});

module.exports = shell;

},{"./utils/shell/hashbangHistory":187,"./utils/shell/index":188}],67:[function(require,module,exports){
/** 
    AppModel extension,
    focused on the Account related APIs:
    - login
    - logout
    - signup
**/
'use strict';

var localforage = require('localforage');

exports.plugIn = function (AppModel) {
    /**
        Try to perform an automatic login if there is a local
        copy of credentials to use on that,
        calling the login method that save the updated
        data and profile.
    **/
    AppModel.prototype.tryLogin = function tryLogin() {
        // Get saved credentials
        return localforage.getItem('credentials')
        .then(function(credentials) {
            // If we have ones, try to log-in
            if (credentials) {
                // Attempt login with that
                return this.login(
                    credentials.username,
                    credentials.password
                );
            } else {
                throw new Error('No saved credentials');
            }
        }.bind(this));
    };

    /**
        Performs a login attempt with the API by using
        the provided credentials.
    **/
    AppModel.prototype.login = function login(username, password) {

        // Reset the extra headers to attempt the login
        this.rest.extraHeaders = null;

        return this.rest.post('login', {
            username: username,
            password: password,
            returnProfile: true
        }).then(performLocalLogin(this, username, password));
    };

    /**
        Performs a login attempt with the API by using
        a Facebook accessToken.
    **/
    AppModel.prototype.facebookLogin = function facebookLogin(accessToken) {

        // Reset the extra headers to attempt the login
        this.rest.extraHeaders = null;

        return this.rest.post('login/facebook', {
            accessToken: accessToken,
            returnProfile: true
        }).then(function(logged) {
            return performLocalLogin(this, logged.email, null);
        }.bind(this));
    };

    /**
        Performs a logout, removing cached credentials
        and profile so the app can be filled up with
        new user information.
        It calls to the API logout call too, to remove
        any server-side session and notification
        (removes the cookie too, for browser environment
        that may use it).
    **/
    // FUTURE: TOREVIEW if the /logout call can be removed.
    AppModel.prototype.logout = function logout() {

        // Local app close session
        this.rest.extraHeaders = null;
        localforage.removeItem('credentials');
        localforage.removeItem('profile');
        
        // Local data clean-up!
        this.clearLocalData();

        // Don't need to wait the result of the REST operation
        this.rest.post('logout');

        return Promise.resolve();
    };

    /**
        Attempts to create a user account, getting logged
        if successfully like when doing a login call.
    **/
    AppModel.prototype.signup = function signup(data) {

        // Reset the extra headers to attempt the signup
        this.rest.extraHeadres = null;
        
        data.returnProfile = true;

        // The result is the same as in a login, and
        // we do the same as there to get the user logged
        // on the app on sign-up success.
        return this.rest.post('signup?utm_source=app', data)
        .then(performLocalLogin(this, data.email, data.password));
    };
};

function performLocalLogin(thisAppModel, username, password) {

    return function(logged) {
        
        // Remove any previous local data if any:
        return thisAppModel.clearLocalData()
        .then(function() {

            // use authorization key for each
            // new Rest request
            thisAppModel.rest.extraHeaders = {
                Authorization: 'LC alu=' + logged.userID + ',alk=' + logged.authKey
            };

            // async local save, don't wait
            localforage.setItem('credentials', {
                userID: logged.userID,
                username: username,
                password: password,
                authKey: logged.authKey
            });
            // IMPORTANT: Local name kept in sync with set-up at AppModel.userProfile
            localforage.setItem('profile', logged.profile);

            // Set user data
            thisAppModel.user().model.updateWith(logged.profile);

            return logged;
        });
    };
}

},{"localforage":false}],68:[function(require,module,exports){
/**
    It uses the server-side availability API.
**/
'use strict';

var CacheControl = require('../utils/CacheControl'),
    moment = require('moment'),
    EventEmitter = require('events').EventEmitter;

exports.create = function create(appModel) {
    
    function Api() {
        EventEmitter.call(this);
        this.setMaxListeners(30);
    }
    Api._inherits(EventEmitter);
    
    var api = new Api();
    
    var cache = {
        times: {/*
            "userID-startTime-endTime": {
                // From server:
                incrementsSizeInMinutes: 15,
                times: [{startTime:isodatetime, endTime:isodatetime, availability:string],
                control: new CacheControl()
            }
        */}
    };
    
    api.clearCache = function clearCache() {
        cache.times = {};
        this.emit('clearCache');
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    var createTimeSlots = require('../utils/createTimeSlots');
    function saveTimesInCache(queryKey, data) {
        var c = cache.times[queryKey];
        if (c) {
            c.times = data.times;
            c.incrementsSizeInMinutes = data.incrementsSizeInMinutes;
            c.control.touch();
        }
        else {
            c = cache.times[queryKey] = {
                times: data.times,
                incrementsSizeInMinutes: data.incrementsSizeInMinutes,
                control: new CacheControl({ ttl: { minutes: 1 } }),
                getFreeTimeSlots: function(duration, slotSizeMinutes) {
                    var size = slotSizeMinutes || this.incrementsSizeInMinutes;
                    return createTimeSlots.forList(this.times, size, duration);
                }
            };
        }
        return c;
    }

    api.times = function times(userID, start, end) {
        if (!end) end = moment(start).add(1, 'day').toDate();
        var queryKey = userID + '-' + start.toISOString() + '-' + end.toISOString();

        if (cache.times.hasOwnProperty(queryKey) &&
            !cache.times[queryKey].control.mustRevalidate()) {
            return Promise.resolve(cache.times[queryKey]);
        }
        else {
            // Remote loading data
            return appModel.rest.get('users/' + userID + '/availability/times', {
                start: start,
                end: end
            }).then(function(data) {
                // IMPORTANT: REST API is not ensuring resultsets ONLY in the start-end
                // dates, but on all complete availabilityRanges that touches that criteria.
                // SO: Ensure only the wanted set of data is saved
                data.times = createTimeSlots.filterListBy(data.times, start, end);
                // Save and return:
                return saveTimesInCache(queryKey, data);
            });
        }
    };

    return api;
};

},{"../utils/CacheControl":151,"../utils/createTimeSlots":169,"events":false,"moment":false}],69:[function(require,module,exports){
/** Bookings

    IMPORTANT!! Some APIs here are intented for use through appModel.calendar (it has cache and more)
    and not directly by the app.
**/
'use strict';

var Booking = require('../models/Booking'),
    moment = require('moment'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
        remote: {
            rest: appModel.rest,
            getBookings: function(filters) {
                return appModel.rest.get('me/bookings', filters)
                .then(function(rawItems) {
                    return rawItems && rawItems.map(function(rawItem) {
                        return new Booking(rawItem);
                    });
                });
            }
        }
    };

    api.getBookingsByDates = function getBookingsByDates(date, end) {
        
        end = end || moment(date).clone().add(1, 'days').toDate();
        
        // Remote loading data
        return api.remote.getBookings({
            start: date,
            end: end
        }).then(function(bookings) {
            // Put in cache (they are already model instances)
            var arr = ko.observableArray(bookings);
            // Return the observable array
            return arr;
        });
    };
    
    /**
        Get upcoming bookings meta-information for dashboard page
    **/
    api.getUpcomingBookings = function getUpcomingBookings() {
        return appModel.rest.get('me/upcoming-bookings');
    };

    /**
        Get a specific booking by ID
    **/
    api.getBooking = function getBooking(id) {
        if (!id) return Promise.reject('The bookingID is required to get a booking');
        return appModel.rest.get('me/bookings/' + id)
        .then(function(booking) {
            return new Booking(booking);
        });
    };
    
    /**
        Converts an Appointment model into a simplified
        booking plain object, suitable to REST API for edition
    **/
    api.appointmentToSimplifiedBooking = function(apt) {
        return {
            bookingID: apt.sourceBooking().bookingID(),
            jobTitleID: apt.jobTitleID(),
            clientUserID: apt.clientUserID(),
            addressID: apt.addressID(),
            startTime: apt.startTime(),
            pricing: apt.pricing().map(function(pricing) {
                // TODO: for now, the REST API allow only a list of IDs,
                // not objects, so next line is replaced:
                //return pricing.model.toPlainObject(true);
                return pricing.serviceProfessionalServiceID();
            }),
            preNotesToClient: apt.preNotesToClient(),
            preNotesToSelf: apt.preNotesToSelf(),
            postNotesToClient: apt.postNotesToClient(),
            postNotesToSelf: apt.postNotesToSelf()
        };
    };
    /**
        Converst a Booking model into a simplified
        booking plain object, suitable to REST API for edition
        
        ONLY FOR SERVICE-PROFESSIONAL-BOOKINGS
    **/
    api.bookingToSimplifiedBooking = function(booking) {
        console.log('DEBUG to simplified booking', booking.pricingSummary());
        return {
            bookingID: booking().bookingID(),
            clientUserID: booking.clientUserID(),
            addressID: booking.addressID(),
            startTime: booking.startTime(),
            pricing: booking.pricingSummary() && booking.pricingSummary().details().pricing
            .map(function(pricing) {
                // TODO: for now, the REST API allow only a list of IDs,
                // not objects, so next line is replaced:
                //return pricing.model.toPlainObject(true);
                return pricing.serviceProfessionalServiceID();
            }),
            preNotesToClient: booking.preNotesToClient(),
            preNotesToSelf: booking.preNotesToSelf(),
            postNotesToClient: booking.postNotesToClient(),
            postNotesToSelf: booking.postNotesToSelf()
        };
    };
    
    /**
        Creates/updates a booking by a service professional, given a simplified booking
        object or an Appointment model or a Booking model
    **/
    api.setServiceProfessionalBooking = function setServiceProfessionalBooking(booking, allowBookUnavailableTime) {    
        booking = booking.bookingID ?
            api.bookingToSimplifiedBooking(booking) :
            booking.sourceBooking ?
                api.appointmentToSimplifiedBooking(booking) :
                booking
        ;

        var id = booking.bookingID || '',
            method = id ? 'put' : 'post';
        
        booking.allowBookUnavailableTime = allowBookUnavailableTime || false;

        return appModel.rest[method]('me/service-professional-booking/' + id, booking)
        .then(function(serverBooking) {
            return new Booking(serverBooking);
        });
    };
    
    /**
        Using data to create a booking from a create client booking form,
        as: booking, billingAddress, paymentMethod, requestOptions (promotionalCode, bookCode, etc.)
        returns an object with the request fields to pass in to the REST API asking
        create the client booking.

        NOTE: Do NOT confuse with previous internal concept 'booking request'. Is called a
        request because the fields and data passed in when creating a booking are different
        from a existent booking.
    **/
    var createClientBookingRequest = function(booking, requestOptions, paymentMethod) {
        
        var billingAddress = paymentMethod && paymentMethod.billingAddress();
        paymentMethod = paymentMethod && paymentMethod.model.toPlainObject();
        if (billingAddress) {
            billingAddress = billingAddress.model.toPlainObject();
            delete paymentMethod.billingAddress;
        }

        return {
            serviceProfessionalUserID: booking.serviceProfessionalUserID(),
            jobTitleID: booking.jobTitleID(),
            serviceStartTime: booking.serviceDate() && booking.serviceDate().startTime(),
            alternative1StartTime: booking.alternativeDate1() && booking.alternativeDate1().startTime(),
            alternative2StartTime: booking.alternativeDate2() && booking.alternativeDate2().startTime(),
            
            serviceAddress: booking.serviceAddress() && booking.serviceAddress().model.toPlainObject(),

            services: booking.pricingSummary() && booking.pricingSummary().details()
            .map(function(pricing) {
                return pricing.serviceProfessionalServiceID();
            }),
            
            bookCode: ko.unwrap(requestOptions.bookCode),
            promotionalCode: ko.unwrap(requestOptions.promotionalCode),
            
            // Only a group of fields from a standard address object are read by the server:
            billingAddress: billingAddress && {
                addressLine1: billingAddress.addressLine1,
                addressLine2: billingAddress.addressLine2,
                postalCode: billingAddress.postalCode
            },
            
            paymentMethod: paymentMethod
        };
    };
    
    /**
        Creates a client booking
        @param booking model/Booking
        @param requestOptions { promotionalCode, bookCode }
    **/
    api.requestClientBooking = function requetsClientBooking(booking, requestOptions, billingAddress, paymentMethod) {
        var data = createClientBookingRequest(booking, requestOptions, billingAddress, paymentMethod);
        return appModel.rest.post('me/client-booking', data);
    };
    
    /**
        Ask for initialization data of a new client booking
        
        @param options {
            serviceProfessionalUserID:int,
            jobTitleID:int,
            bookCode:string [Optional]
        }
    **/
    api.getNewClientBooking = function getNewClientBooking(options) {
        return appModel.rest.get('me/client-booking', options);
    };

    return api;
};

},{"../models/Booking":104,"knockout":false,"moment":false}],70:[function(require,module,exports){
/**
    It offers access to calendar elements (appointments) and availability
    
    Appointments is an abstraction around calendar events
    that behave as bookings or as events (where bookings are built
    on top of an event instance --a booking record must have ever a serviceDateID event).
    
    With this appModel, the APIs to manage events&bookings are combined to offer related
    records easier in Appointments objects.
**/
'use strict';

var Appointment = require('../models/Appointment'),
    DateAvailability = require('../models/DateAvailability'),
    DateCache = require('../utils/DateCache'),
    moment = require('moment'),
    _ = require('lodash'),
    EventEmitter = require('events').EventEmitter;

exports.create = function create(appModel) {

    function Api() {
        EventEmitter.call(this);
        this.setMaxListeners(30);
    }
    Api._inherits(EventEmitter);
    
    var api = new Api();
    
    var cache = new DateCache({
        Model: DateAvailability,
        ttl: { minutes: 10 }
    });
    
    api.clearCache = function clearCache() {
        cache.clear();
        this.emit('clearCache');
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Get a generic calendar appointment object, made of events and/or bookings,
        depending on the given ID in the ids object.
        
        TODO: gets single apt from the DateCache
    **/
    api.getAppointment = function getAppointment(ids) {

        if (ids.calendarEventID) {
            return appModel.calendarEvents.getEvent(ids.calendarEventID)
            .then(Appointment.fromCalendarEvent);
        }
        else if (ids.bookingID) {
            return appModel.bookings.getBooking(ids.bookingID)
            .then(function(booking) {
                // An appointment for booking needs the confirmed event information
                return appModel.calendarEvents.getEvent(booking.serviceDateID())
                .then(function(event) {
                    return Appointment.fromBooking(booking, event);
                });
            });
        }
        else {
            return Promise.reject('Unrecognized ID');
        }
    };
    
    api.setAppointment = function setAppointment(apt, allowBookUnavailableTime) {
        
        // TODO: Saving apt must invalidate the cache and force date
        // availability computation with UI update, when start time or start end changes 
        // (ever when inserting apt), for the previous date and the new one (if date changed)
        // and only date availability computation if date is the same but time changed.
        // And triggers "this.emit('clearCache');" passing as parameter the dates array that needs refresh
        
        // If is a booking
        if (apt.sourceBooking()) {
            return appModel.bookings.setServiceProfessionalBooking(apt, allowBookUnavailableTime)
            .then(function(booking) {
                
                // TODO: clearCache, enhance by discarding only the cache for the previous
                // and new date
                api.clearCache();
                
                // We need the event information too
                return appModel.calendarEvents.getEvent(booking.serviceDateID())
                .then(function(event) {
                    return Appointment.fromBooking(booking, event);
                });
            });
        }
        else if (apt.sourceEvent()) {
            return appModel.calendarEvents.setEvent(apt)
            .then(function(event) {
                return Appointment.fromCalendarEvent(event);
            });
        }
        else {
            return Promise.reject(new Error('Unrecognized appointment object'));
        }
    };
    
    /**
        Get a list of generic calendar appointment objects, made of events and/or bookings
        by Date, from the remote source directly.
        Used internally only, to get appointments with and without free/unavailable
        slots use getDateAvailability
    **/
    var getRemoteAppointmentsByDate = function getRemoteAppointmentsByDate(date) {
        return Promise.all([
            appModel.bookings.getBookingsByDates(date),
            appModel.calendarEvents.getEventsByDates(date)
        ]).then(function(group) {

            var events = group[1],
                bookings = group[0],
                apts = [];

            if (events && events().length) {
                apts = Appointment.listFromCalendarEventsBookings(events(), bookings());
            }

            // Return the array
            return apts;
        });
    };
    
    /**
        Fetch appointments and schedule information for the date from remote
        in a convenient object to use with the DateAvailability model.
    **/
    var getRemoteDateAvailability = function getRemoteDateAvailability(date) {
        return Promise.all([
            getRemoteAppointmentsByDate(date),
            appModel.simplifiedWeeklySchedule.load(),
            appModel.schedulingPreferences.load()
        ])
        .then(function(result) {
            var apts = result[0],
                settings = result[1],
                weekDaySchedule = settings.weekDays[date.getDay()](),
                prefs = result[2];

            var dateInfo = {
                date: date,
                appointmentsList: apts || [],
                weekDaySchedule: weekDaySchedule,
                schedulingPreferences: prefs
            };

            return dateInfo;
        });
    };
    
    /**
        Get the appointments and availability for the given date.
        It has cache control, if there is a valid copy is returned
        at the moment, if is reloaded and exists on cache, that copy is
        updated so all previous instances get the updated data too.
    **/
    api.getDateAvailability = function getDateAvailability(date) {
        
        var cached = cache.getSingle(date);

        if (cached) {
            return Promise.resolve(cached);
        }
        else {
            return getRemoteDateAvailability(date)
            .then(function(dateInfo) {
                // Update cache and retun data as class instance
                return cache.set(date, dateInfo).data;
            });
        }
    };
    
    
    //////
    // NEW MULTI DATES API
    
    /**
        Get a list of generic calendar appointment objects, made of events and/or bookings
        by Date, from the remote source directly.
        Used internally only, to get appointments with and without free/unavailable
        slots use getDateAvailability
    **/
    var getRemoteAppointmentsByDates = function getRemoteAppointmentsByDates(start, end) {
        return Promise.all([
            appModel.bookings.getBookingsByDates(start, end),
            appModel.calendarEvents.getEventsByDates(start, end)
        ]).then(function(group) {

            var events = group[1],
                bookings = group[0],
                apts = [];

            if (events && events().length) {
                apts = Appointment.listFromCalendarEventsBookings(events(), bookings());
            }

            // Group apts by date
            var grouped = _.groupBy(apts, function(apt) {
                return moment(apt.startTime()).format('YYYY-MM-DD');
            });
            
            // Ensure all the dates in the range are filled, with empty arrays in the holes.
            // NOTE: this way of first group apts and then fill gaps makes the resulting object
            // to display properties out of order (if some hole needed being filled out).
            var date = new Date(start);
            while (date <= end) {
                var key = moment(date).format('YYYY-MM-DD');
                
                if (!grouped.hasOwnProperty(key))
                    grouped[key] = [];

                // Next date:
                date.setDate(date.getDate() + 1);
            }

            return grouped;
        });
    };
    
    /**
        Fetch appointments and schedule information for the dates from remote
        in a convenient object to use with the DateAvailability model
        (returns an array of them).
    **/
    var getRemoteDatesAvailability = function getRemoteDatesAvailability(start, end) {
        return Promise.all([
            getRemoteAppointmentsByDates(start, end),
            appModel.simplifiedWeeklySchedule.load(),
            appModel.schedulingPreferences.load()
        ])
        .then(function(result) {
            var aptsDates = result[0],
                settings = result[1],
                results = {},
                prefs = result[2];

            Object.keys(aptsDates).forEach(function(dateKey) {
                var date = moment(dateKey, 'YYYY-MM-DD').toDate();
                var weekDaySchedule = settings.weekDays[date.getDay()]();
            
                var dateInfo = {
                    date: date,
                    appointmentsList: aptsDates[dateKey] || [],
                    weekDaySchedule: weekDaySchedule,
                    schedulingPreferences: prefs
                };

                results[dateKey] = dateInfo;
            });

            return results;
        });
    };
    
    api.getDatesAvailability = function getDatesAvailability(start, end) {

        var cacheResults = cache.get(start, end);
        // We know what dates we need and what data is cached already
        // If all cached, just resolve to cache
        if (cacheResults.minHole === null) {
            return Promise.resolve(cacheResults.byDate);
        }
        
        // Request all dates in the range (even if some cached in between)
        return getRemoteDatesAvailability(cacheResults.minHole, cacheResults.maxHole)
        .then(function(results) {
            // Add results to cache, creating DateAvailability object
            // and add that to the resultset
            Object.keys(results).forEach(function(dateKey) {
                cacheResults.byDate[dateKey] = cache.set(dateKey, results[dateKey]).data;
            });
            return cacheResults.byDate;
        });
    };

    return api;
};


},{"../models/Appointment":103,"../models/DateAvailability":109,"../utils/DateCache":152,"events":false,"lodash":false,"moment":false}],71:[function(require,module,exports){
/** Events

    IMPORTANT!!!! API not to use directly by the app, but through appModel.calendar (it has cache and more)
**/
'use strict';

var CalendarEvent = require('../models/CalendarEvent'),
    moment = require('moment'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
        remote: {
            rest: appModel.rest,
            getCalendarEvents: function(filters) {
                return appModel.rest.get('me/events', filters)
                .then(function(rawItems) {
                    return rawItems && rawItems.map(function(rawItem) {
                        return new CalendarEvent(rawItem);
                    });
                });
            }
        }
    };

    api.getEventsByDates = function getEventsByDates(date, end) {
        
        end = end || moment(date).clone().add(1, 'days').toDate();
        
        // Remote loading data
        return api.remote.getCalendarEvents({
            start: date,
            end: end
        }).then(function(events) {

            // Put in array (they are already model instances)
            var arr = ko.observableArray(events);
            // Return the observable array
            // TODO Review really if has sense to have an observable array, take care of its use (on appointments mainly)
            return arr;
        });
    };
    
    /**
        Get a specific event by ID
    **/
    api.getEvent = function getEvent(id) {
        if (!id) return Promise.reject('The calendarEventID is required to get an event');

        return appModel.rest.get('me/events/' + id)
        .then(function(event) {
            return new CalendarEvent(event);
        });
    };
    
    api.appointmentToSimplifiedEvent = function(apt) {
        
        var rrule = apt.sourceEvent().recurrenceRule();
        if (rrule)
            rrule = apt.sourceEvent().recurrenceRule().model.toPlainObject();

        var occs = apt.sourceEvent().recurrenceOccurrences();
        if (occs)
            occs = occs.map(function(occ) {
                return occ && occ.model.toPlainObject() || null;
            }).filter(function(occ) { return occ !== null; });
        
        return {
            // The same as apt.sourceEvent().calendarEventID()
            calendarEventID: apt.id() < 0 ? 0 : apt.id(),
            eventTypeID: apt.sourceEvent().eventTypeID(),
            summary: apt.summary(),
            description: apt.description(),
            availabilityTypeID: apt.sourceEvent().availabilityTypeID(),
            location: apt.addressSummary(),
            startTime: apt.startTime(),
            endTime: apt.endTime(),
            isAllDay: apt.sourceEvent().isAllDay(),
            recurrenceRule: rrule,
            recurrenceOccurrences: occs
        };
    };

    /**
        Creates/updates a booking, given a simplified booking
        object or an Appointment model or a Booking model
    **/
    api.setEvent = function setEvent(event) {

        event = event.calendarEventID ?
            event.model.toPlainObject() :
            event.sourceEvent ?
                api.appointmentToSimplifiedEvent(event) :
                event
        ;

        var id = event.calendarEventID || '',
            method = id ? 'put' : 'post';

        return appModel.rest[method]('me/events' + (id ? '/' : '') + id, event)
        .then(function(serverEvent) {
            return new CalendarEvent(serverEvent);
        });
    };

    return api;
};

},{"../models/CalendarEvent":106,"knockout":false,"moment":false}],72:[function(require,module,exports){
/** Calendar Syncing app model
**/
'use strict';

var ko = require('knockout'),
    CalendarSyncing = require('../models/CalendarSyncing'),
    RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new CalendarSyncing(),
        ttl: { minutes: 1 },
        localStorageName: 'calendarSyncing',
        fetch: function fetch() {
            return appModel.rest.get('me/calendar-syncing');
        },
        push: function push() {
            return appModel.rest.put('me/calendar-syncing', this.data.model.toPlainObject());
        }
    });
    
    // Extending with the special API method 'resetExportUrl'
    rem.isReseting = ko.observable(false);
    rem.resetExportUrl = function resetExportUrl() {
        
        rem.isReseting(true);

        return appModel.rest.post('me/calendar-syncing/reset-export-url')
        .then(function(updatedSyncSettings) {
            // Updating the cached data
            rem.data.model.updateWith(updatedSyncSettings);
            rem.isReseting(false);

            return updatedSyncSettings;
        });
    };
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });

    return rem;
};

},{"../models/CalendarSyncing":107,"../utils/RemoteModel":162,"knockout":false}],73:[function(require,module,exports){
/** clients
**/
'use strict';

var Client = require('../models/Client');

var ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        listTtl: { minutes: 1 },
        itemIdField: 'clientUserID',
        Model: Client
    });

    api.addLocalforageSupport('clients');
    api.addRestSupport(appModel.rest, 'me/clients');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    /**
        Public search of users, possible clients by well
        know fields, with full value match.
    **/
    var publicSearchRequest = null;
    api.publicSearch = function publicSearch(search) {

        // Only one request at a time
        if (publicSearchRequest &&
            publicSearchRequest.abort) {
            try {
                publicSearchRequest.abort();
            } catch (abortErr) {
                console.error('Error aborting request', abortErr);
            }
        }
        
        var request = appModel.rest.get('me/clients/public-search', search);
        publicSearchRequest = request.xhr;
        
        // Catch 'abort' to avoid communicate a fake error in the promise; the
        // promise will just solve as success with empty array.
        request = request.catch(function(err) {
            if (err && err.statusText === 'abort')
                return [];
            else
                // Rethrow only if is not an 'abort'
                return err;
        });
        // Set again, removed by the catch returned promise
        request.xhr = publicSearchRequest;

        return request;
    };

    return api;
};

},{"../models/Client":108,"../utils/ListRemoteModel":160}],74:[function(require,module,exports){
/** Education (user education)
**/
'use strict';

var UserEducation = require('../models/UserEducation');
var ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        listTtl: { minutes: 1 },
        itemIdField: 'educationID',
        Model: UserEducation
    });

    api.addLocalforageSupport('education');

    api.addRestSupport(appModel.rest, 'me/education');
    //api.addMockedRemote(testdata());
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    return api;
};
/*
function testdata() {
    return [
        {
            educationID: 1,
            institutionName: 'A school',
            degreeCertificate: 'The degree',
            fieldOfStudy: 'Field of study',
            fromYearAttended: 1993,
            toYearAttended: 1996
        },
        {
            educationID: 2,
            institutionName: 'Empire Beauty School - Scottsdale'
        },
        {
            educationID: 3,
            institutionName: 'MIT',
            degreeCertificate: 'Computering',
            fieldOfStudy: 'Systems administration'
        }
    ];
}
*/
},{"../models/UserEducation":143,"../utils/ListRemoteModel":160}],75:[function(require,module,exports){
/** Feedback
**/
//global navigator,window
'use strict';

exports.create = function create(appModel) {
    
    var getUserDeviceInfo = function getUserDeviceInfo() {
        var dev = window.device || {
            platform: 'web',
            model: 'unknow',
            cordova: '',
            version: ''
        };
        return {
            userAgent: navigator.userAgent,
            platform: dev.platform,
            version: dev.version,
            model: dev.model,
            cordova: dev.cordova
        };
    };
    
    return {
        /**
            @param values:Object {
                message:string,
                vocElementID:int,
                becomeCollaborator:boolean,
                userDevice:string (automatic)
            }
        **/
        postIdea: function postIdea(values) {
            values.userDevice = JSON.stringify(getUserDeviceInfo());
            return appModel.rest.post('feedback/ideas', values);
        },
        /**
            @param values:Object {
                message:string,
                vocElementID:int,
                userDevice:string (automatic)
            }
        **/
        postSupport: function postSupport(values) {
            values.userDevice = JSON.stringify(getUserDeviceInfo());
            return appModel.rest.post('feedback/support', values);
        }
    };
};

},{}],76:[function(require,module,exports){
/** Home Address
**/
'use strict';

var Address = require('../models/Address');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new Address(),
        ttl: { minutes: 1 },
        localStorageName: 'homeAddress',
        fetch: function fetch() {
            return appModel.rest.get('me/addresses/home');
        },
        push: function push() {
            return appModel.rest.put('me/addresses/home', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/Address":102,"../utils/RemoteModel":162}],77:[function(require,module,exports){
/** Logged user service attributes
**/
'use strict';

var JobTitleServiceAttributes = require('../models/JobTitleServiceAttributes');

var GroupRemoteModel = require('../utils/GroupRemoteModel');

exports.create = function create(appModel) {
    var api = new GroupRemoteModel({
        ttl: { hours: 1 },
        itemIdField: 'jobTitleID',
        Model: JobTitleServiceAttributes
    });
    
    api.addLocalforageSupport('job-title-service-attributes/');
    api.addRestSupport(appModel.rest, 'job-title-service-attributes/');    
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/JobTitleServiceAttributes":116,"../utils/GroupRemoteModel":157}],78:[function(require,module,exports){
/** Fetch Job Titles and Pricing Types information
**/
'use strict';

var localforage = require('localforage'),
    JobTitle = require('../models/JobTitle'),
    ko = require('knockout');

exports.create = function create(appModel) {

    var api = {
            state:  {
                isLoading: ko.observable(false)
            }
        },
        cache = {
            jobTitles: {}
        };
    
    api.clearCache = function clearCache() {
        cache.jobTitles = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Public API
        Get a Job Title information by ID
    **/
    api.getJobTitle = function getJobTitle(id) {
        if (!id) return Promise.reject('Needs an ID to get a Job Title');

        // First, in-memory cache
        if (cache.jobTitles[id]) {
            return Promise.resolve(cache.jobTitles[id]);
        }
        else {
            api.state.isLoading(true);
            // Second, local storage
            return localforage.getItem('jobTitles/' + id)
            .then(function(jobTitle) {
                if (jobTitle) {
                    // cache in memory as Model instance
                    cache.jobTitles[id] = new JobTitle(jobTitle);
                    api.state.isLoading(false);
                    // return it
                    return cache.jobTitles[id];
                }
                else {
                    // Third and last, remote loading
                    return appModel.rest.get('job-titles/' + id)
                    .then(function (raw) {
                        // Cache in local storage
                        localforage.setItem('jobTitles/' + id, raw);
                        // cache in memory as Model instance
                        cache.jobTitles[id] = new JobTitle(raw);
                        api.state.isLoading(false);
                        // return it
                        return cache.jobTitles[id];
                    });
                }
            })
            .catch(function(err) {
                api.state.isLoading(false);
                // Rethrow error
                return err;
            });
        }
    };

    return api;
};

},{"../models/JobTitle":114,"knockout":false,"localforage":false}],79:[function(require,module,exports){
/** AppModel, centralizes all the data for the app,
    caching and sharing data across activities and performing
    requests
**/
var ko = require('knockout'),
    $ = require('jquery'),
    Rest = require('../utils/Rest'),
    localforage = require('localforage'),
    EventEmitter = require('events').EventEmitter;

function AppModel() {
    EventEmitter.call(this);
    this.setMaxListeners(30);
}

AppModel._inherits(EventEmitter);

module.exports = AppModel;

require('./AppModel-account').plugIn(AppModel);

/**
    Load credentials from the local storage, without error if there is nothing
    saved. If load profile data too, performing an tryLogin if no local data.
**/
AppModel.prototype.loadLocalCredentials = function loadLocalCredentials() {
    return new Promise(function(resolve) { // Never rejects: , reject) {

        // Callback to just resolve without error (passing in the error
        // to the 'resolve' will make the process to fail),
        // since we don't need to create an error for the
        // app init, if there is not enough saved information
        // the app has code to request a login.
        var resolveAnyway = function(doesnMatter){        
            console.warning('App Model Init err', doesnMatter);
            resolve();
        };
        
        // If there are credentials saved
        localforage.getItem('credentials').then(function(credentials) {

            if (credentials &&
                credentials.userID &&
                credentials.username &&
                credentials.authKey) {

                // use authorization key for each
                // new Rest request
                this.rest.extraHeaders = {
                    Authorization: 'LC alu=' + credentials.userID + ',alk=' + credentials.authKey
                };
                
                // It has credentials! Has basic profile data?
                // NOTE: the userProfile will load from local storage on this first
                // attempt, and lazily request updated data from remote so we need
                // to catch remote errors with events
                this.userProfile.once('error', function(err) {
                    this.emit('error', {
                        message: 'Impossible to load your data. Please check your Internet connection',
                        error: err
                    });
                }.bind(this));
                
                this.userProfile.load().then(function(profile) {
                    if (profile) {
                        // There is a profile cached                    
                        // End succesfully
                        resolve();
                    }
                    else {
                        // No profile, we need to request it to be able
                        // to work correctly, so we
                        // attempt a login (the tryLogin process performs
                        // a login with the saved credentials and fetch
                        // the profile to save it in the local copy)
                        this.tryLogin().then(resolve, resolveAnyway);
                    }
                }.bind(this), resolveAnyway)
                // The error event catch any error if happens, so avoid uncaught exceptions
                // in the console by catching the promise error
                .catch(function() { });
            }
            else {
                // End successfully. Not loggin is not an error,
                // is just the first app start-up
                resolve();
            }
        }.bind(this), resolveAnyway);
    }.bind(this));
};

/** Initialize and wait for anything up **/
AppModel.prototype.init = function init() {
    
    // Local data
    // TODO Investigate why automatic selection an IndexedDB are
    // failing and we need to use the worse-performance localstorage back-end
    localforage.config({
        name: 'LoconomicsApp',
        version: 0.1,
        size : 4980736, // Size of database, in bytes. WebSQL-only for now.
        storeName : 'keyvaluepairs',
        description : 'Loconomics App',
        driver: localforage.LOCALSTORAGE
    });
    
    // First, get any saved local config
    // NOTE: for now, this is optional, to get a saved siteUrl rather than the
    // default one, if any.
    return localforage.getItem('config')
    .then(function(config) {
        // Optional config
        config = config || {};
        
        if (config.siteUrl) {
            // Update the html URL
            $('html').attr('data-site-url', config.siteUrl);
        }
        else {
            config.siteUrl = $('html').attr('data-site-url');
        }
        
        this.config = config;
        this.rest = new Rest(config.siteUrl + '/api/v1/en-US/');
        
        // Setup Rest authentication
        this.rest.onAuthorizationRequired = function(retry) {

            this.tryLogin()
            .then(function() {
                // Logged! Just retry
                retry();
            });
        }.bind(this);
        
        // With config loaded and REST ready, load all modules
        this.loadModules();
        
        // Initialize: check the user has login data and needed
        // cached data, return its promise
        return this.loadLocalCredentials();
    }.bind(this));
};

AppModel.prototype.loadModules = function loadModules() {
    //jshint maxstatements: 80
    
    this.userProfile = require('./AppModel.userProfile').create(this);
    // NOTE: Alias for the user data
    // TODO:TOREVIEW if continue to makes sense to keep this 'user()' alias, document
    // where is used and why is preferred to the canonical way.
    this.user = ko.computed(function() {
        return this.userProfile.data;
    }, this);

    this.onboarding = require('./AppModel.onboarding').create(this);

    this.schedulingPreferences = require('./AppModel.schedulingPreferences').create(this);
    this.calendarSyncing = require('./AppModel.calendarSyncing').create(this);
    this.simplifiedWeeklySchedule = require('./AppModel.simplifiedWeeklySchedule').create(this);
    this.marketplaceProfile = require('./AppModel.marketplaceProfile').create(this);
    this.homeAddress = require('./AppModel.homeAddress').create(this);
    this.privacySettings = require('./AppModel.privacySettings').create(this);
    this.bookings = require('./AppModel.bookings').create(this);
    this.calendarEvents = require('./AppModel.calendarEvents').create(this);
    this.jobTitles = require('./AppModel.jobTitles').create(this);
    this.userJobProfile = require('./AppModel.userJobProfile').create(this);
    this.calendar = require('./AppModel.calendar').create(this);
    this.serviceAddresses = require('./AppModel.serviceAddresses').create(this);
    this.serviceProfessionalServices = require('./AppModel.serviceProfessionalServices').create(this);
    this.pricingTypes = require('./AppModel.pricingTypes').create(this);
    this.messaging = require('./AppModel.messaging').create(this);
    this.clients = require('./AppModel.clients').create(this);
    this.postalCodes = require('./AppModel.postalCodes').create(this);
    this.feedback = require('./AppModel.feedback').create(this);
    this.education = require('./AppModel.education').create(this);
    this.licensesCertifications = require('./AppModel.licensesCertifications').create(this);
    this.users = require('./AppModel.users').create(this);
    this.availability = require('./AppModel.availability').create(this);
    this.serviceAttributes = require('./AppModel.serviceAttributes').create(this);
    this.jobTitleServiceAttributes = require('./AppModel.jobTitleServiceAttributes').create(this);
    this.userVerifications = require('./AppModel.userVerifications').create(this);
};

/**
    Clear the local stored data, but with careful for the special
    config data that is kept.
**/
AppModel.prototype.clearLocalData = function clearLocalData() {
    // Get config
    return localforage.getItem('config')
    .then(function(config) {
        // Clear all
        localforage.clear();

        if (config) {
            // Set config again
            localforage.setItem('config', config);
        }
        
        // Trigger notification, so other components
        // can make further clean-up or try synchronizations,
        // for example to clean-up in-memory cache.
        this.emit('clearLocalData');
    }.bind(this));
};

},{"../utils/Rest":163,"./AppModel-account":67,"./AppModel.availability":68,"./AppModel.bookings":69,"./AppModel.calendar":70,"./AppModel.calendarEvents":71,"./AppModel.calendarSyncing":72,"./AppModel.clients":73,"./AppModel.education":74,"./AppModel.feedback":75,"./AppModel.homeAddress":76,"./AppModel.jobTitleServiceAttributes":77,"./AppModel.jobTitles":78,"./AppModel.licensesCertifications":80,"./AppModel.marketplaceProfile":81,"./AppModel.messaging":82,"./AppModel.onboarding":83,"./AppModel.postalCodes":84,"./AppModel.pricingTypes":85,"./AppModel.privacySettings":86,"./AppModel.schedulingPreferences":87,"./AppModel.serviceAddresses":88,"./AppModel.serviceAttributes":89,"./AppModel.serviceProfessionalServices":90,"./AppModel.simplifiedWeeklySchedule":91,"./AppModel.userJobProfile":92,"./AppModel.userProfile":93,"./AppModel.userVerifications":94,"./AppModel.users":95,"events":false,"knockout":false,"localforage":false}],80:[function(require,module,exports){
/** Service LicensesCertifications

// TODO Initial work, complete and test
**/
'use strict';

var UserLicenseCertification = require('../models/UserLicenseCertification'),
    GroupListRemoteModel = require('../utils/GroupListRemoteModel');

exports.create = function create(appModel) {

    var api = new GroupListRemoteModel({
        // Conservative cache, just 1 minute
        listTtl: { minutes: 1 },
        groupIdField: 'jobTitleID',
        itemIdField: 'licenseCertificationID',
        Model: UserLicenseCertification
    });
    
    api.addLocalforageSupport('userLicenseCertifications');
    api.addRestSupport(appModel.rest, 'me/user-license-certifications/');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/UserLicenseCertification":146,"../utils/GroupListRemoteModel":156}],81:[function(require,module,exports){
/** MarketplaceProfile
**/
'use strict';

var MarketplaceProfile = require('../models/MarketplaceProfile');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new MarketplaceProfile(),
        ttl: { minutes: 1 },
        localStorageName: 'marketplaceProfile',
        fetch: function fetch() {
            return appModel.rest.get('me/marketplace-profile');
        },
        push: function push() {
            return appModel.rest.put('me/marketplace-profile', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/MarketplaceProfile":120,"../utils/RemoteModel":162}],82:[function(require,module,exports){
/** AppModel for messaging: threads and messages

    NOTE: Initial basic implementation
    TODO: Require advanced implementation, loading a limited
        amount of records for threads and messages per thread
        using the cursor parameters of the REST API to manage
        paging load.
**/
'use strict';

var Thread = require('../models/Thread'),
    CacheControl = require('../utils/CacheControl'),
    ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        listTtl: { minutes: 1 },
        itemIdField: 'threadID',
        Model: Thread
    });

    api.addLocalforageSupport('messaging');
    api.addRestSupport(appModel.rest, 'me/messaging');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    // Basic support is fetching all threads with the latest message of each one.
    // Replace getItem built-in to do non locally saved, fetch for all messages in
    // a thread (the thread is the item)
    var fullThreadsCache = {/*
        threadID: { control: CacheControl, thread: Thread }
    */};
    var fetchThreadRemote = function(threadID) {
        return appModel.rest.get('me/messaging/' + threadID, {
            limit: 1000 /* max messages in the thread */
        })
        .then(function(thread) {
            if (thread) {
                thread = new Thread(thread);
                var cached = fullThreadsCache[threadID];
                if (cached) {
                    cached.control.latest = new Date();
                    cached.thread = thread;
                } else {
                    fullThreadsCache[threadID] = {
                        control: new CacheControl({ ttl: { minutes: 1 } }),
                        thread: thread
                    };
                    fullThreadsCache[threadID].control.latest = new Date();
                }
                return thread;
            }
            else {
                throw new Error('Not Found');
            }
        });
    };
    var markAsEndedAndFollowUp = function(any) {
        api.state.isSyncing(false);
        api.state.isLoading(false);
        return any;
    };
    api.getItem = function getItem(threadID) {
        var cached = fullThreadsCache[threadID];
        if (cached && cached.thread) {
            if (cached.control.mustRevalidate()) {
                api.state.isSyncing(true);
                return fetchThreadRemote(threadID)
                .then(markAsEndedAndFollowUp, markAsEndedAndFollowUp);
            }
            else
                return Promise.resolve(cached.thread);
        } else {
            api.state.isLoading(true);
            return fetchThreadRemote(threadID)
            .then(markAsEndedAndFollowUp, markAsEndedAndFollowUp);
        }
    };

    return api;
};

},{"../models/Thread":140,"../utils/CacheControl":151,"../utils/ListRemoteModel":160}],83:[function(require,module,exports){
/**
    Onboarding tracking information
**/
'use strict';

var OnboardingProgress = require('../viewmodels/OnboardingProgress'),
    NavAction = require('../viewmodels/NavAction');

exports.create = function create(appModel) {
    
    // Onboarding management and state, initially empty so no progress
    var api = new OnboardingProgress();
    
    // Requires initialization to receive and app instance
    api.init = function init(app) {
        api.app = app;
    };
    
    // Extended with new methods

    // Set the correct onboarding progress and step given a step reference
    // (usually from database)
    api.setStep = function(stepReference) {
        if (stepReference) {
            var stepItems = stepReference.split(':', 2),
                group = stepItems[0],
                // step is the second part, or just the same as
                // the full name (that happens for the first steps that share
                // name with the group and only need to define the group name)
                step = stepItems[1] || group;

            // Try to set current step, follow to look for group if does not success
            if (this.setStepByName(step)) {
                return true;
            }
            // else:
            // Look for a group that matches
            var groupSteps = OnboardingProgress.predefinedStepGroups[group];
            if (groupSteps) {
                this.steps(groupSteps);
                this.group(group);
                if (this.setStepByName(step)) {
                    return true;
                }
            }
        }
        // No progress:
        this.model.reset();
        return false;
    };

    // Update the given navbar with the current onboarding information (only if in progress)
    api.updateNavBar = function(navBar) {
        var yep = this.inProgress();
        if (yep) {
            // On 2015-06-16 #575, changed decission from use a 'go back' action
            // (commented in following lines):
//            navBar.leftAction(NavAction.goBack.model.clone());
//            navBar.leftAction().handler(function() {
//                api.goPrevious();
//                return false;
//            });
            // to use the Log-out action
            navBar.leftAction(NavAction.goLogout);

            navBar.title(this.progressText());            
        }
        return yep;
    };
    
    api.goNext = function goNext() {
        var current = this.stepNumber();

        current++;

        if (current > this.totalSteps()) {
            // It ended!!
            this.stepNumber(-1);
            appModel.userProfile.saveOnboardingStep(null);
            this.app.shell.go('/', { completedOnboarding: api.group() });
        }
        else {
            // Get next step
            this.stepNumber(current);
            appModel.userProfile.saveOnboardingStep(this.stepReference());
            this.app.shell.go(this.stepUrl());
        }
    };
    
    api.goPrevious = function goPrevious() {
        var current = this.stepNumber();

        current--;

        if (current >= 0 && current <= this.totalSteps()) {
            // Get previous step
            this.stepNumber(current);
        }
        else {
            this.stepNumber(0);
        }

        appModel.userProfile.saveOnboardingStep(this.stepReference());
        this.app.shell.go(this.stepUrl());
    };
    
    return api;
};

},{"../viewmodels/NavAction":200,"../viewmodels/OnboardingProgress":202}],84:[function(require,module,exports){
/** Postal Code.

    Access the API to validate and retrieve information for a 
    given postal code.
    
    It just offers a 'get postal code info' method returning
    a plain object from the REST endpoint.
    
    Creates an in-memory cache for frequently used postal codes
**/
'use strict';

exports.create = function create(appModel) {

    var api = {},
        cache = {};
    
    api.getItem = function getItem(postalCode) {
        
        postalCode = postalCode || '';
        if (/^\s*$/.test(postalCode)) {
            return Promise.reject('Postal Code Not Valid');
        }
        
        // Check cache
        if (cache.hasOwnProperty(postalCode)) {
            return Promise.resolve(cache[postalCode]);
        }
        
        return appModel.rest.get('postal-codes/' + postalCode)
        .then(function(info) {
            // Save cache
            if (info) {
                cache[postalCode] = info;
            }
            // return
            return info;
        });
    };

    appModel.on('clearLocalData', function() {
        cache = {};
    });
    
    return api;
};

},{}],85:[function(require,module,exports){
/** Pricing Types
**/
'use strict';

var PricingType = require('../models/PricingType');

var ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {
    
    var api = new ListRemoteModel({
        // Types does not changes usually, so big ttl
        listTtl: { days: 1 },
        itemIdField: 'pricingTypeID',
        Model: PricingType
    });

    api.addLocalforageSupport('pricing-types');
    api.addRestSupport(appModel.rest, 'pricing-types');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    return api;
};

},{"../models/PricingType":127,"../utils/ListRemoteModel":160}],86:[function(require,module,exports){
/** Privacy Settings
**/
'use strict';

var PrivacySettings = require('../models/PrivacySettings');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new PrivacySettings(),
        ttl: { minutes: 1 },
        localStorageName: 'privacySettings',
        fetch: function fetch() {
            return appModel.rest.get('me/privacy-settings');
        },
        push: function push() {
            return appModel.rest.put('me/privacy-settings', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/PrivacySettings":128,"../utils/RemoteModel":162}],87:[function(require,module,exports){
/**
**/
'use strict';

var SchedulingPreferences = require('../models/SchedulingPreferences');

var RemoteModel = require('../utils/RemoteModel');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new SchedulingPreferences(),
        ttl: { minutes: 1 },
        localStorageName: 'schedulingPreferences',
        fetch: function fetch() {
            return appModel.rest.get('me/scheduling-preferences');
        },
        push: function push() {
            return appModel.rest.put('me/scheduling-preferences', this.data.model.toPlainObject())
            .then(function(result) {
                // We need to recompute availability as side effect of scheduling preferences changes
                appModel.calendar.clearCache();
                // Forward the result
                return result;
            });
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

},{"../models/SchedulingPreferences":135,"../utils/RemoteModel":162}],88:[function(require,module,exports){
/** Service Addresses
**/
'use strict';

var Address = require('../models/Address'),
    GroupListRemoteModel = require('../utils/GroupListRemoteModel');

exports.create = function create(appModel) {

    var api = new GroupListRemoteModel({
        // Conservative cache, just 1 minute
        listTtl: { minutes: 1 },
        groupIdField: 'jobTitleID',
        itemIdField: 'addressID',
        Model: Address
    });
    
    api.addLocalforageSupport('addresses/service/');
    api.addRestSupport(appModel.rest, 'me/addresses/service/');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/Address":102,"../utils/GroupListRemoteModel":156}],89:[function(require,module,exports){
/** Logged user service attributes
**/
'use strict';

var UserJobTitleServiceAttributes = require('../models/UserJobTitleServiceAttributes');

var GroupRemoteModel = require('../utils/GroupRemoteModel');

exports.create = function create(appModel) {
    var api = new GroupRemoteModel({
        ttl: { minutes: 1 },
        itemIdField: 'jobTitleID',
        Model: UserJobTitleServiceAttributes
    });
    
    api.addLocalforageSupport('service-attributes/');
    api.addRestSupport(appModel.rest, 'me/service-attributes/');    
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/UserJobTitleServiceAttributes":145,"../utils/GroupRemoteModel":157}],90:[function(require,module,exports){
/** Service professional service
**/
'use strict';

var ServiceProfessionalService = require('../models/ServiceProfessionalService'),
    GroupListRemoteModel = require('../utils/GroupListRemoteModel');

exports.create = function create(appModel) {

    var api = new GroupListRemoteModel({
        // Conservative cache, just 1 minute
        listTtl: { minutes: 1 },
        groupIdField: 'jobTitleID',
        itemIdField: 'serviceProfessionalServiceID',
        Model: ServiceProfessionalService
    });

    api.addLocalforageSupport('service-professional-services/');
    api.addRestSupport(appModel.rest, 'me/service-professional-services/');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });
    
    return api;
};

},{"../models/ServiceProfessionalService":138,"../utils/GroupListRemoteModel":156}],91:[function(require,module,exports){
/**
**/
'use strict';

var SimplifiedWeeklySchedule = require('../models/SimplifiedWeeklySchedule'),
    RemoteModel = require('../utils/RemoteModel'),
    moment = require('moment');

// A list of week day properties names allowed
// to be part of the objects describing weekly schedule
// (simplified or complete/slot based)
// Just lowecased english names
var weekDayProperties = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: new SimplifiedWeeklySchedule(),
        ttl: { minutes: 1 },
        localStorageName: 'weeklySchedule',
        fetch: function fetch() {
            return appModel.rest.get('me/weekly-schedule')
            .then(fromWeeklySchedule);
        },
        push: function push() {
            var plainData = toWeeklySchedule(this.data.model.toPlainObject(true));
            return appModel.rest.put('me/weekly-schedule', plainData)
            .then(fromWeeklySchedule)
            .then(function(result) {
                // We need to recompute availability as side effect of schedule
                appModel.calendar.clearCache();
                // Forward the result
                return result;
            });
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    return rem;
};

/**
    Basically, from a multi date timeRanges structure
    to a similar with only one timeRange per date and
    managed in minutes in a 'from-to' structure.
    
    Source structure (some weekdays removed for brevity): {
        "timeZone": "America/Los_Angeles",
        "sunday": [{
            "start": "00:00:00",
            "end": "23:59:59"
        }],
        "monday": [],
        "tuesday": null,
        "saturday": [{
            "start": "10:00:00",
            "end": "14:00:00"
        }, {
            "start": "16:30:00",
            "end": "20:30:00"
        }],
        "isAllTime": false
    }
**/
function fromWeeklySchedule(weeklySchedule) {
    
    // New simplified object, as a plain object with
    // weekdays properties and from-to properties like:
    // { sunday: { from: 0, to: 60 } }
    // Since this is expected to be consumed by fetch-push
    // operations, and later by an 'model.updateWith' operation,
    // so plain is simple and better on performance; can be
    // converted easily to the SimplifiedWeeklySchedule object.
    var simpleWS = {
        timeZone: weeklySchedule.timeZone || '',
        isAllTime: weeklySchedule.isAllTime
    };

    // Read timeRanges per week-day
    Object.keys(weeklySchedule)
    .forEach(function(weekday) {
        
        // Verify is a weekday property, or exit early
        if (weekDayProperties.indexOf(weekday) === -1) {
            return;
        }

        var timeRanges = weeklySchedule[weekday];

        if (timeRanges && timeRanges[0]) {
            // Times comes in ISO format "00:00:00" that we convert to minutes
            // (enough precision for simplified weekly schedule)
            // using moment.duration
            simpleWS[weekday] = {
                from: moment.duration(timeRanges[0].start).asMinutes() |0,
                to: moment.duration(timeRanges[0].end).asMinutes() |0
            };
        }
    });

    // Done!
    return simpleWS;
}

/**
    Pass in a plain object, not a model,
    getting an object suitable for the API endpoint.
    
    It returns a structure like the input source expected at fromWeeklySchedule
**/
function toWeeklySchedule(simplifiedWeeklySchedule) {
    
    // Resulting structure
    var weeklySchedule = {
        timeZone: simplifiedWeeklySchedule.timeZone,
        isAllTime: simplifiedWeeklySchedule.isAllTime
    };

    // Avoid extra work if is all time, since all other properties
    // will get discarded on that case.
    // Otherwise, create the weekdays properties with the timeRanges
    if (!weeklySchedule.isAllTime) {
        // Per weekday
        Object.keys(simplifiedWeeklySchedule)
        .forEach(function(weekday) {

            // Verify is a weekday property, or exit early
            if (weekDayProperties.indexOf(weekday) === -1) {
                return;
            }

            var simpleDay = simplifiedWeeklySchedule[weekday];

            // Convert the minutes to ISO time format (00:00:00)
            // and add it to a new array with a single timeRange:
            weeklySchedule[weekday] = [{
                start: minutesToTimeString(simpleDay.from |0),
                end: minutesToTimeString(simpleDay.to |0)
            }];
        });
    }

    // Done!
    return weeklySchedule;
}

/**
    internal utility function 'to string with two digits almost'
**/
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Convert a number of minutes
    in a string like: 00:00:00 (hours:minutes:seconds)
**/
function minutesToTimeString(minutes) {
    var d = moment.duration(minutes, 'minutes'),
        h = d.hours(),
        m = d.minutes(),
        s = d.seconds();
    
    return (
        twoDigits(h) + ':' +
        twoDigits(m) + ':' +
        twoDigits(s)
    );
}

},{"../models/SimplifiedWeeklySchedule":139,"../utils/RemoteModel":162,"moment":false}],92:[function(require,module,exports){
/**
    Model API to manage the collection of Job Titles assigned
    to the current user and its working data.
**/
'use strict';

var UserJobTitle = require('../models/UserJobTitle'),
    CacheControl = require('../utils/CacheControl'),
    localforage = require('localforage'),
    ko = require('knockout'),
    $ = require('jquery');

exports.create = function create(appModel) {

    var api = {},
        defaultTtl = { minutes: 1 },
        cache = {
            // Array of user job titles making
            // its profile
            userJobProfile: {
                cache: new CacheControl({ ttl: defaultTtl }),
                list: null
            },
            // Indexed list by jobTitleID to the user job titles models
            // in the list and cache information
            userJobTitles: {/*
                jobTitleID: { model: object, cache: CacheControl }
            */}
        };
    
    // Observable list
    api.list = ko.observableArray([]);
    // NOTE: Basic implementation, to enhance
    api.syncList = function syncList() {
        return api.getUserJobProfile().then(function(list) {
            api.list(list);
            return list;
        });
    };
    
    api.clearCache = function clearCache() {
        cache.userJobProfile.cache.latest = null;
        cache.userJobProfile.list = [];
        cache.userJobTitles = {};
    };
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    /**
        Convert raw array of job titles records into
        an indexed array of models, actually an object
        with ID numbers as properties,
        and cache it in memory.
    **/
    function mapToUserJobProfile(rawItems) {
        cache.userJobProfile.list = [];
        cache.userJobTitles = {};

        if (rawItems) {
            rawItems.forEach(function(rawItem) {
                var m = new UserJobTitle(rawItem);
                cache.userJobProfile.list.push(m);
                // Saving and indexed copy and per item cache info
                setGetUserJobTitleToCache(rawItem);
            });
        }
        // Update observable
        api.list(cache.userJobProfile.list);

        // Update cache state
        cache.userJobProfile.cache.latest = new Date();
        
        return cache.userJobProfile.list;
    }
    
    /**
        Get the full jobProfile from local copy, throwing a Promise reject exception if nothing
    **/
    function getUserJobProfileFromLocal() {
        return localforage.getItem('userJobProfile')
        .then(function(userJobProfile) {
            if (userJobProfile) {
                return mapToUserJobProfile(userJobProfile);
            }
            // Return null since there is no data, the promise can catch
            // there is no data and attempt a remote
            return null;
        });
    }
    
    /**
        Set a raw userJobProfile record (from server) and set it in the
        cache, creating or updating the model (so all the time the same model instance
        is used) and cache control information.
        Returns the model instance.
    **/
    function setGetUserJobTitleToCache(rawItem) {
        var c = cache.userJobTitles[rawItem.jobTitleID] || {};
        // Update the model if exists, so get reflected to anyone consuming it
        if (c.model) {
            c.model.model.updateWith(rawItem);
        }
        else {
            // First time, create model
            c.model = new UserJobTitle(rawItem);
        }
        // Update cache control
        if (c.cache) {
            c.cache.latest = new Date();
        }
        else {
            c.cache = new CacheControl({ ttl: defaultTtl });
        }
        
        // If there is a profile list, add or update:
        var fullList =  cache.userJobProfile.list;
        if (fullList) {
            var found = null;
            fullList.some(function(it) {
                if (it.jobTitleID() === rawItem.jobTitleID) {
                    found = it;
                    return true;
                }
            });
            if (found) {
                found.model.updateWith(rawItem);
            }
            else {
                fullList.push(c.model);
            }
        }
        
        // Return the model, updated or just created
        return c.model;
    }
    
    /**
        Get the content from the cache, for full profile
        and save it in local storage
        NOTE It has no sense in current implementation (problem of fetch
        job title without a full job profile in cache/local)
    **/
    /*function saveCacheInLocal() {
        var plain = cache.userJobProfile.list.map(function(item) {
            // Each item is a model, get it in plain:
            return item.model.toPlainObject();
        });
        localforage.setItem('userJobProfile', plain);
    }*/
    
    // Private, fetch from remote
    var fetchUserJobProfile = function () {
        // Third and last, remote loading
        return appModel.rest.get('me/user-job-profile')
        .then(function (raw) {
            // Cache in local storage
            localforage.setItem('userJobProfile', raw);
            return mapToUserJobProfile(raw);
        });
    };
    
    /**
        Public API
        Get the complete list of UserJobTitle for
        all the JobTitles assigned to the current user
    **/
    api.getUserJobProfile = function () {
        // If no cache or must revalidate, go remote
        // (the first loading is ever 'must revalidate')
        if (cache.userJobProfile.cache.mustRevalidate()) {
            // If no cache, is first load, so try local
            if (!cache.userJobProfile.list) {
                // Local storage
                return getUserJobProfileFromLocal()
                .then(function(data) {
                    // launch remote for sync
                    var remotePromise = fetchUserJobProfile();
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                });
            }
            else {
                // No cache, no local, or obsolete, go remote:
                return fetchUserJobProfile();
            }
        }
        else {
            // There is cache and is still valid:
            return Promise.resolve(cache.userJobProfile.list);
        }
    };
    
    // Private, fetch from remote
    var fetchUserJobTitle = function(jobTitleID) {
        return appModel.rest.get('me/user-job-profile/' + jobTitleID)
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            
            // TODO implement cache saving for single job-titles, currently
            // it needs to save the profile cache, that may not exists if
            // the first request is for a single job title.
            // Next lines are to save full profile, not valid here.
            // Save in local
            //saveCacheInLocal();
            
            // Return model
            return m;
        });
    };
    
    var pushNewUserJobTitle = function(values) {
        // Create job title in remote
        return appModel.rest.post('me/user-job-profile', $.extend({
            jobTitleID: 0,
            jobTitleName: '',
            intro: '',
            cancellationPolicyID: null,
            instantBooking: false
        }, values))
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            
            // TODO implement cache saving for single job-titles, currently
            // it needs to save the profile cache, that may not exists if
            // the first request is for a single job title.
            // Next lines are to save full profile, not valid here.
            // Save in local
            //saveCacheInLocal();
            
            // Return model
            return m;
        });
    };
    
    /**
        Public API
        Get a UserJobTitle record for the given
        JobTitleID and the current user.
    **/
    api.getUserJobTitle = function (jobTitleID) {
        // Quick error
        if (!jobTitleID) return Promise.reject('Job Title ID required');
        
        // If no cache or must revalidate, go remote
        if (!cache.userJobTitles[jobTitleID] ||
            cache.userJobTitles[jobTitleID].cache.mustRevalidate()) {
            return fetchUserJobTitle(jobTitleID);
        }
        else {
            // First, try cache
            if (cache.userJobTitles[jobTitleID] &&
                cache.userJobTitles[jobTitleID].model) {
                return Promise.resolve(cache.userJobTitles[jobTitleID].model);
            }
            else {
                // Second, local storage, where we have the full job profile
                return getUserJobProfileFromLocal()
                .then(function(/*userJobProfile*/) {
                    // Not need for the parameter, the data is
                    // in memory and indexed, look for the job title
                    return cache.userJobTitles[jobTitleID].model;
                })
                // If no local copy (error on promise),
                // or that does not contains the job title (error on 'then'):
                // Third and last, remote loading
                .catch(fetchUserJobTitle.bind(null, jobTitleID));
            }
        }
    };
    
    /**
        Push changes to remote. StatusID can NOT be modified with this API, use specific
        deactivate/reactivate methods
    **/
    api.setUserJobTitle = function (values) {
        return appModel.rest.put('me/user-job-profile/' + values.jobTitleID, values)
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            
            // TODO implement cache saving for single job-titles, currently
            // it needs to save the profile cache, that may not exists if
            // the first request is for a single job title.
            // Next lines are to save full profile, not valid here.
            // Save in local
            //saveCacheInLocal();
            
            // Return model
            return m;
        });
    };
    
    api.createUserJobTitle = function (values) {
        return pushNewUserJobTitle(values);
    };
    
    api.deactivateUserJobTitle = function(jobTitleID) {
        return appModel.rest.post('me/user-job-profile/' + (jobTitleID|0) + '/deactivate')
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            return m;
        });
    };
    
    api.reactivateUserJobTitle = function(jobTitleID) {
        return appModel.rest.post('me/user-job-profile/' + (jobTitleID|0) + '/reactivate')
        .then(function(raw) {
            // Save to cache and get model
            var m = setGetUserJobTitleToCache(raw);
            return m;
        });
    };
    
    /*************************/
    /** ADITIONAL UTILITIES **/
    api.getUserJobTitleAndJobTitle = function getUserJobTitleAndJobTitle(jobTitleID) {
        return api.getUserJobTitle(jobTitleID)
        .then(function(userJobTitle) {
            // Very unlikely error
            if (!userJobTitle) {
                throw {
                    name: 'Not Found',
                    message:
                        // LJDI:
                        'You have not this job title in your profile. ' + 
                        'Maybe was deleted from your profile recently.'
                };
            }

            // Get job title info too
            return Promise.all([
                userJobTitle,
                appModel.jobTitles.getJobTitle(jobTitleID)
            ]);
        })
        .then(function(all) {
            var jobTitle = all[1];
            // Very unlikely error
            if (!jobTitle) {
                throw {
                    name: 'Not Found',
                    // LJDI:
                    message: 'The job title does not exist.'
                };
            }
        
            return {
                jobTitleID: jobTitleID,
                userJobTitle: all[0],
                jobTitle: jobTitle
            };
        });
    };
    
    return api;
};

},{"../models/UserJobTitle":144,"../utils/CacheControl":151,"knockout":false,"localforage":false}],93:[function(require,module,exports){
/** UserProfile
**/
'use strict';

var User = require('../models/User');

var RemoteModel = require('../utils/RemoteModel'),
    localforage = require('localforage');

exports.create = function create(appModel) {
    var rem = new RemoteModel({
        data: User.newAnonymous(),
        ttl: { minutes: 1 },
        // IMPORTANT: Keep the name in sync with set-up at AppModel-account
        localStorageName: 'profile',
        fetch: function fetch() {
            return appModel.rest.get('me/profile');
        },
        push: function push() {
            return appModel.rest.put('me/profile', this.data.model.toPlainObject());
        }
    });
    
    appModel.on('clearLocalData', function() {
        rem.clearCache();
    });
    
    rem.saveOnboardingStep = function saveOnboardingStep(stepReference) {
        if (typeof(stepReference) === 'undefined') {
            stepReference = rem.data.onboardingStep();
        }
        else {
            rem.data.onboardingStep(stepReference);
        }

        return appModel.rest.put('me/profile/tracking', {
            onboardingStep: stepReference
        })
        .then(function() {
            // If success, save persistent local copy of the data to ensure the
            // new onboardingStep is saved
            localforage.setItem(rem.localStorageName, rem.data.model.toPlainObject());
        });
    };
    
    return rem;
};

},{"../models/User":142,"../utils/RemoteModel":162,"localforage":false}],94:[function(require,module,exports){
/** User Verifications

    TODO Maybe the ListRemoteModel is not the most appropiated because it allows 1 ID
    while user-verifications have multi-ID fields and there is no an invidual access,
    but it's really a list not a flat RemoteModel.
    NOTE May require a query per job-title in future? Or just filtering the list?
**/
'use strict';

var UserVerification = require('../models/UserVerification'),
    ListRemoteModel = require('../utils/ListRemoteModel');

exports.create = function create(appModel) {

    var api = new ListRemoteModel({
        listTtl: { minutes: 10 },
        itemIdField: 'verificationID',
        Model: UserVerification
    });

    api.addLocalforageSupport('user-verifications');
    api.addRestSupport(appModel.rest, 'me/verifications');
    
    appModel.on('clearLocalData', function() {
        api.clearCache();
    });

    return api;
};

},{"../models/UserVerification":147,"../utils/ListRemoteModel":160}],95:[function(require,module,exports){
/**
    Query public data from other users in the marketplace,
    usually client fetching service professionals data
    to view profile, book them, etc.
**/
'use strict';

exports.create = function create(appModel) {
    
    var api = {};

    //appModel.on('clearLocalData', function() {
    //    api.clearCache();
    //});
    
    /**
        Get the user index/summary information. That includes
        an object with different properties that matches the results
        from other individual APIs, to get in one call information
        like profile, rating, verificationsSummary, jobProfile.
        Usefull to load faster a user public profile, service professional
        information to start a booking process or the user information
        widgets.
    **/
    api.getUser = function(userID) {
        return appModel.rest.get('users/' + (userID |0));
    };
    
    api.getProfile = function(userID) {
        return appModel.rest.get('users/' + (userID |0) + '/profile');
    };
    
    api.getJobProfile = function(userID) {
        return appModel.rest.get('users/' + (userID |0) + '/job-profile');
    };
    api.getJobTitle = function(userID, jobTitleID) {
        return appModel.rest.get('users/' + (userID |0) + '/job-profile/' + (jobTitleID |0));
    };
    
    // TODO REMOVE THIS OLD?? REPLACED BY SERVER-SIDE AppModel.availability?
    var getAvailability = function getAvailability(userID, format, query) {
        return appModel.rest.get('users/' + (userID |0) + '/availability/' + format, query);
    };
    api.getAvailabilityPerDate = function(userID, startDate, endDate) {
        return getAvailability(userID, 'dates', { start: startDate, end: endDate });
    };
    api.getAvailabilityInsSlots = function(userID, startDate, endDate) {
        return getAvailability(userID, 'slots', { start: startDate, end: endDate });
    };

    var getRatings = function getRatings(modifier, userID) {
        return appModel.rest.get('users/' + (userID |0) + '/ratings' + (modifier ? '/' + modifier : ''));
    };
    api.getUserRatings = getRatings.bind(api, null);
    api.getClientRatings = getRatings.bind(api, 'client');
    api.getServiceProfessionalRatings = getRatings.bind(api, 'service-professional');
    api.getJobTitleRatings = function(userID, jobTitleID) { return getRatings(jobTitleID |0, userID); };
    
    api.getServiceAddresses = function(userID, jobTitleID) {
        return appModel.rest.get('users/' + (userID |0) + '/service-addresses/' + (jobTitleID |0));
    };

    api.getServiceProfessionalServices = function(serviceProfessionalUserID, jobTitleID) {
        return appModel.rest.get('users/' + (serviceProfessionalUserID |0) + '/service-professional-services/' + (jobTitleID |0));
    };
    
    var getVerificationsSummary = function getVerificationsSummary(modifier, userID) {
        return appModel.rest.get('users/' + (userID |0) + '/verifications-summary' + (modifier ? '/' + modifier : ''));
    };
    api.getUserVerificationsSummary = getVerificationsSummary.bind(api, null);
    api.getClientVerificationsSummary = getVerificationsSummary.bind(api, 'client');
    api.getServiceProfessionalVerificationsSummary = getVerificationsSummary.bind(api, 'service-professional');
    api.getJobTitleVerificationsSummary = function(userID, jobTitleID) { return getVerificationsSummary(jobTitleID |0, userID); };

    api.getServiceAttributes = function getServiceAttributes(userID, jobTitleID) {
        return appModel.rest.get('users/' + (userID |0) + '/service-attributes/' + (jobTitleID |0));
    };

    return api;
};
},{}],96:[function(require,module,exports){
/**
    Activity base class
**/
'use strict';

var ko = require('knockout'),
    NavAction = require('../viewmodels/NavAction'),
    NavBar = require('../viewmodels/NavBar');

require('../utils/Function.prototype._inherits');

/**
    Activity class definition
**/
function Activity($activity, app) {

    this.$activity = $activity;
    this.app = app;

    // Default access level: anyone
    // Activities can use the enumeration: this.app.UserType
    this.accessLevel = null; 
    
    // TODO: Future use of a viewState, plain object representation
    // of part of the viewModel to be used as the state passed to the
    // history and between activities calls.
    this.viewState = {};
    
    // Object to hold the options passed on 'show' as a result
    // of a request from another activity
    this.requestData = null;

    // Default navBar object.
    this.navBar = new NavBar({
        title: null, // null for logo
        leftAction: null,
        rightAction: null
    });
    
    // Knockout binding of viewState delayed to first show
    // to avoid problems with subclasses replacing the viewState
}

module.exports = Activity;

/**
    Set-up visualization of the view with the given options/state,
    with a reset of current state.
    Must be executed every time the activity is put in the current view.
**/
Activity.prototype.show = function show(options) {
    // TODO: must keep viewState up to date using options/state.
    //console.log('Activity show', this.constructor.name);
    if (!this.__bindingDone) {
        // A view model and bindings being applied is ever required
        // even on Activities without need for a view model, since
        // the use of components and templates, or any other data-bind
        // syntax, requires to be in a context with binding enabled:
        ko.applyBindings(this.viewModel || {}, this.$activity.get(0));
        this.__bindingDone = true;
    }
    
    options = options || {};
    this.requestData = options;
    
    // Enable registered handlers
    // Validation of each settings object is performed
    // on registered, avoided here.
    if (this._handlers &&
        this._handlersAreConnected !== true) {
        this._handlers.forEach(function(settings) {
            // Check if is an observable subscription
            if (!settings.event && settings.target.subscribe) {
                var subscription = settings.target.subscribe(settings.handler);
                // Observables has not a 'unsubscribe' function,
                // they return an object that must be 'disposed'.
                // Saving that with settings to allow 'unsubscribe' later.
                settings._subscription = subscription;

                // Inmediate execution: if current observable value is different
                // than previous one, execute the handler:
                // (this avoid that a changed state get omitted because happened
                // when subscription was off; it means a first time execution too).
                // NOTE: 'undefined' value on observable may cause this to fall
                if (settings._latestSubscribedValue !== settings.target()) {
                    settings.handler.call(settings.target, settings.target());
                }
            }
            else if (settings.selector) {
                settings.target.on(settings.event, settings.selector, settings.handler);
            }
            else if (settings.target.on) {
                settings.target.on(settings.event, settings.handler);
            }
            else {
                console.error('Activity.show: Bad registered handler', settings);
            }
        });
        // To avoid double connections:
        // NOTE: may happen that 'show' gets called several times without a 'hide'
        // in between, because 'show' acts as a refresher right now even from segment
        // changes from the same activity.
        this._handlersAreConnected = true;
    }
};

/**
    Perform tasks to stop anything running or stop handlers from listening.
    Must be executed every time the activity is hidden/removed 
    from the current view.
**/
Activity.prototype.hide = function hide() {
    
    // Disable registered handlers
    if (this._handlers) {
        this._handlers.forEach(function(settings) {
            // Check if is an observable subscription
            if (settings._subscription) {
                settings._subscription.dispose();
                // Save latest observable value to make a comparision
                // next time is enabled to ensure is executed if there was
                // a change while disabled:
                settings._latestSubscribedValue = settings.target();
            }
            else if (settings.target.off) {
                if (settings.selector)
                    settings.target.off(settings.event, settings.selector, settings.handler);
                else
                    settings.target.off(settings.event, settings.handler);
            }
            else if (settings.target.removeListener) {
                settings.target.removeListener(settings.event, settings.handler);
            }
            else {
                console.error('Activity.hide: Bad registered handler', settings);
            }
        });
        
        this._handlersAreConnected = false;
    }
};

/**
    Register a handler that acts on an event or subscription notification,
    that will be enabled on Activity.show and disabled on Activity.hide.

    @param settings:object {
        target: jQuery, EventEmitter, Knockout.observable. Required
        event: string. Event name (can have namespaces, several events allowed). Its required except when the target is an observable, there must
            be omitted.
        handler: Function. Required,
        selector: string. Optional. For jQuery events only, passed as the
            selector for delegated handlers.
    }
**/
Activity.prototype.registerHandler = function registerHandler(settings) {
    /*jshint maxcomplexity:8 */
    
    if (!settings)
        throw new Error('Register require a settings object');
    
    if (!settings.target || (!settings.target.on && !settings.target.subscribe))
        throw new Error('Target is null or not a jQuery, EventEmmiter or Observable object');
    
    if (typeof(settings.handler) !== 'function') {
        throw new Error('Handler must be a function.');
    }
    
    if (!settings.event && !settings.target.subscribe) {
        throw new Error('Event is null; it\'s required for non observable objects');
    }

    this._handlers = this._handlers || [];

    this._handlers.push(settings);
};

/**
    Static utilities
**/
// For commodity, common classes are exposed as static properties
Activity.NavBar = NavBar;
Activity.NavAction = NavAction;

// Quick creation of common types of NavBar
Activity.createSectionNavBar = function createSectionNavBar(title) {
    return new NavBar({
        title: title,
        leftAction: NavAction.menuIn,
        rightAction: NavAction.menuNewItem
    });
};

Activity.createSubsectionNavBar = function createSubsectionNavBar(title, options) {
    
    options = options || {};
    
    var goBackOptions = {
        text: title,
        isTitle: true
    };

    if (options.backLink) {
        goBackOptions.link = options.backLink;
        goBackOptions.isShell = false;
    }

    return new NavBar({
        title: '', // No title
        leftAction: NavAction.goBack.model.clone(goBackOptions),
        rightAction: options.helpId ?
            NavAction.goHelpIndex.model.clone({
                link: '#' + options.helpId
            }) :
            NavAction.goHelpIndex
    });
};

Activity.prototype.createCancelAction = function createCancelAction(cancelLink, state) {
    
    var app = this.app;
    
    var action = new NavAction({
        link: cancelLink,
        text: 'cancel',
        handler: function(event) {
            var link = this.link(),
                eoptions = event && event.options || {};
            
            var goLink = function() {
                if (link)
                    app.shell.go(link, state);
                else
                    app.shell.goBack(state);
            };
            
            // A silentMode passed to the event requires
            // avoid the modal (used when executing a saving task for example)
            if (eoptions.silentMode) {
                goLink();
            }
            else {
                // TODO L18N
                app.modals.confirm({
                    title: 'Cancel',
                    message: 'Are you sure?',
                    yes: 'Yes',
                    no: 'No'
                })
                .then(function() {
                    // Confirmed cancellation:
                    goLink();
                });
            }
        }
    });

    return action;
};

Activity.prototype.convertToCancelAction = function convertToCancelAction(actionModel, cancelLink) {
    var cancel = this.createCancelAction(cancelLink);
    actionModel.model.updateWith(cancel);
    // DUDE: handler is cpied by updateWith?
    actionModel.handler(cancel.handler());
};

/**
    Singleton helper
**/
var singlentonInstances = {};
var createSingleton = function createSingleton(ActivityClass, $activity, app) {
    
    if (singlentonInstances[ActivityClass.name] instanceof ActivityClass) {
        return singlentonInstances[ActivityClass.name];
    }
    else {
        var s = new ActivityClass($activity, app);
        singlentonInstances[ActivityClass.name] = s;
        return s;
    }
};
// Example of use
//exports.init = createSingleton.bind(null, ActivityClass);

/**
    Static method extends to help inheritance.
    Additionally, it adds a static init method ready for the new class
    that generates/retrieves the singleton.
**/
Activity.extends = function extendsActivity(ClassFn) {
    
    ClassFn._inherits(Activity);
    
    ClassFn.init = createSingleton.bind(null, ClassFn);
    
    return ClassFn;
};

},{"../utils/Function.prototype._inherits":154,"../viewmodels/NavAction":200,"../viewmodels/NavBar":201,"knockout":false}],97:[function(require,module,exports){
/* =========================================================
 * DatePicker JS Component, with several
 * modes and optional inline-permanent visualization.
 *
 * Copyright 2014 Loconomics Coop.
 *
 * Based on:
 * bootstrap-datepicker.js 
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

var $ = require('jquery'); 

var classes = {
    component: 'DatePicker',
    months: 'DatePicker-months',
    days: 'DatePicker-days',
    monthDay: 'day',
    month: 'month',
    year: 'year',
    years: 'DatePicker-years',
    weekDays: 'DatePicker-weekDays',
    active: 'active'
};

var events = {
    dayRendered: 'dayRendered',
    dateChanged: 'dateChanged',
    show: 'show',
    hide: 'hide',
    dateSet: 'dateSet',
    // IMPORTANT: Triggered after a value is set or updated in the viewDate property
    // without check if the same or not (but operations updating it happens on a change)
    // AND after is changed and calendar filled (fill method called, so DOM reflects the new viewDate).
    viewDateChanged: 'viewDateChanged'
};

var DPGlobal = {
    modes: [
        {
            clsName: 'days',
            navFnc: 'Month',
            navStep: 1
        },
        {
            clsName: 'months',
            navFnc: 'FullYear',
            navStep: 1
        },
        {
            clsName: 'years',
            navFnc: 'FullYear',
            navStep: 10
        },
        {
            clsName: 'day',
            navFnc: 'Date',
            navStep: 1
        }
    ],
    dates:{
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
        daysMin: ["Su", "M", "Tu", "W", "Th", "F", "Sa", "Su"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    },
    isLeapYear: function (year) {
        return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
    },
    getDaysInMonth: function (year, month) {
        return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },
    parseFormat: function(format){
        var separator = format.match(/[.\/\-\s].*?/),
            parts = format.split(/\W+/);
        if (!separator || !parts || parts.length === 0){
            throw new Error("Invalid date format.");
        }
        return {separator: separator, parts: parts};
    },
    parseDate: function(date, format) {
        /*jshint maxcomplexity:11*/
        var parts = date.split(format.separator),
            val;
        date = new Date();
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        if (parts.length === format.parts.length) {
            var year = date.getFullYear(), day = date.getDate(), month = date.getMonth();
            for (var i=0, cnt = format.parts.length; i < cnt; i++) {
                val = parseInt(parts[i], 10)||1;
                switch(format.parts[i]) {
                    case 'dd':
                    case 'd':
                        day = val;
                        date.setDate(val);
                        break;
                    case 'mm':
                    case 'm':
                        month = val - 1;
                        date.setMonth(val - 1);
                        break;
                    case 'yy':
                        year = 2000 + val;
                        date.setFullYear(2000 + val);
                        break;
                    case 'yyyy':
                        year = val;
                        date.setFullYear(val);
                        break;
                }
            }
            date = new Date(year, month, day, 0 ,0 ,0);
        }
        return date;
    },
    formatDate: function(date, format){
        var val = {
            d: date.getDate(),
            m: date.getMonth() + 1,
            yy: date.getFullYear().toString().substring(2),
            yyyy: date.getFullYear()
        };
        val.dd = (val.d < 10 ? '0' : '') + val.d;
        val.mm = (val.m < 10 ? '0' : '') + val.m;
        date = [];
        for (var i=0, cnt = format.parts.length; i < cnt; i++) {
            date.push(val[format.parts[i]]);
        }
        return date.join(format.separator);
    },
    headTemplate: '<thead>'+
                        '<tr>'+
                            '<th class="prev">&lsaquo;</th>'+
                            '<th colspan="5" class="switch"></th>'+
                            '<th class="next">&rsaquo;</th>'+
                        '</tr>'+
                    '</thead>',
    contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
};
DPGlobal.template = '<div class="' + classes.component + '">'+
                        '<div class="' + classes.days + '">'+
                            '<table class=" table-condensed">'+
                                DPGlobal.headTemplate+
                                '<tbody></tbody>'+
                            '</table>'+
                        '</div>'+
                        '<div class="' + classes.months + '">'+
                            '<table class="table-condensed">'+
                                DPGlobal.headTemplate+
                                DPGlobal.contTemplate+
                            '</table>'+
                        '</div>'+
                        '<div class="' + classes.years + '">'+
                            '<table class="table-condensed">'+
                                DPGlobal.headTemplate+
                                DPGlobal.contTemplate+
                            '</table>'+
                        '</div>'+
                    '</div>';
DPGlobal.modesSet = {
    'date': DPGlobal.modes[3],
    'month': DPGlobal.modes[0],
    'year': DPGlobal.modes[1],
    'decade': DPGlobal.modes[2]
};

// Picker object
var DatePicker = function(element, options) {
    /*jshint maxstatements:40,maxcomplexity:24*/
    this.element = $(element);
    this.format = DPGlobal.parseFormat(options.format||this.element.data('date-format')||'mm/dd/yyyy');
    
    this.isInput = this.element.is('input');
    this.component = this.element.is('.date') ? this.element.find('.add-on') : false;
    this.isPlaceholder = this.element.is('.calendar-placeholder');
    
    this.picker = $(DPGlobal.template)
                        .appendTo(this.isPlaceholder ? this.element : 'body')
                        .on('click', $.proxy(this.click, this));
    this.picker.addClass(this.isPlaceholder ? '' : 'dropdown-menu');
    if (options.extraClasses)
        this.picker.addClass(options.extraClasses);
    
    if (this.isPlaceholder) {
        this.picker.show();
        if (this.element.data('date') == 'today') {
            this.date = new Date();
            this.set();
        }
        this.element.trigger({
            type: events.show,
            date: this.date
        });
    }
    else if (this.isInput) {
        this.element.on({
            focus: $.proxy(this.show, this),
            //blur: $.proxy(this.hide, this),
            keyup: $.proxy(this.update, this)
        });
    } else {
        if (this.component){
            this.component.on('click', $.proxy(this.show, this));
        } else {
            this.element.on('click', $.proxy(this.show, this));
        }
    }
    
    /* Touch events to swipe dates */
    this.element
    .on('swipeleft', function(e) {
        e.preventDefault();
        this.moveDate('next');
    }.bind(this))
    .on('swiperight', function(e) {
        e.preventDefault();
        this.moveDate('prev');
    }.bind(this));

    /* Set-up view mode */
    this.minViewMode = options.minViewMode||this.element.data('date-minviewmode')||0;
    if (typeof this.minViewMode === 'string') {
        switch (this.minViewMode) {
            case 'months':
                this.minViewMode = 1;
                break;
            case 'years':
                this.minViewMode = 2;
                break;
            default:
                this.minViewMode = 0;
                break;
        }
    }
    this.viewMode = options.viewMode||this.element.data('date-viewmode')||0;
    if (typeof this.viewMode === 'string') {
        switch (this.viewMode) {
            case 'months':
                this.viewMode = 1;
                break;
            case 'years':
                this.viewMode = 2;
                break;
            default:
                this.viewMode = 0;
                break;
        }
    }
    this.startViewMode = this.viewMode;
    this.weekStart = options.weekStart||this.element.data('date-weekstart')||0;
    this.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;
    this.onRender = options.onRender;
    this.fillDow();
    this.fillMonths();
    this.update();
    this.showMode();
};

DatePicker.prototype = {
    constructor: DatePicker,
    
    _triggerViewDateChange: function() {
        var viewModeName = DPGlobal.modes[this.viewMode].clsName;
        this.element.trigger(events.viewDateChanged, [{ viewDate: this.viewDate, viewMode: viewModeName }]);
    },
    
    show: function(e) {
        this.picker.show();
        this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
        this.place();
        $(window)
            .off('resize.datepicker')
            .on('resize.datepicker', $.proxy(this.place, this));
        
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        if (!this.isInput) {
        }
        var that = this;
        $(document)
        .off('mousedown.datepicker')
        .on('mousedown.datepicker', function(ev){
            if ($(ev.target).closest('.' + classes.component).length === 0) {
                that.hide();
            }
        });
        this.element.trigger({
            type: events.show,
            date: this.date
        });
    },
    
    hide: function(){
        this.picker.hide();
        $(window).off('resize.datepicker', this.place);
        this.viewMode = this.startViewMode;
        this.showMode();
        if (!this.isInput) {
            $(document).off('mousedown.datepicker', this.hide);
        }
        //this.set();
        this.element.trigger({
            type: events.hide,
            date: this.date
        });
    },
    
    set: function() {
        var formated = DPGlobal.formatDate(this.date, this.format);
        if (!this.isInput) {
            if (this.component){
                this.element.find('input').prop('value', formated);
            }
            this.element.data('date', formated);
        } else {
            this.element.prop('value', formated);
        }
        this.element.trigger(events.dateSet, [this.date, formated]);
    },
    
    /**
        Sets a date as value and notify with an event.
        Parameter dontNotify is only for cases where the calendar or
        some related component gets already updated but the highlighted
        date needs to be updated without create infinite recursion 
        because of notification. In other case, dont use.
    **/
    setValue: function(newDate, dontNotify) {
        if (typeof newDate === 'string') {
            this.date = DPGlobal.parseDate(newDate, this.format);
        } else {
            this.date = new Date(newDate);
        }
        this.set();
        this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
        this.fill();
        // TODO Must check dontNotify?
        this._triggerViewDateChange();
        
        if (dontNotify !== true) {
            // Notify:
            this.element.trigger({
                type: events.dateChanged,
                date: this.date,
                viewMode: DPGlobal.modes[this.viewMode].clsName
            });
        }
    },
    
    getValue: function() {
        return this.date;
    },
    
    getViewDate: function() {
        return this.viewDate;
    },
    
    moveValue: function(dir, mode) {
        // dir can be: 'prev', 'next'
        if (['prev', 'next'].indexOf(dir && dir.toLowerCase()) == -1)
            // No valid option:
            return;

        // default mode is the current one
        mode = mode ?
            DPGlobal.modesSet[mode] :
            DPGlobal.modes[this.viewMode];

        this.date['set' + mode.navFnc].call(
            this.date,
            this.date['get' + mode.navFnc].call(this.date) + 
            mode.navStep * (dir === 'prev' ? -1 : 1)
        );
        this.setValue(this.date);
        return this.date;
    },
    
    place: function(){
        var offset = this.component ? this.component.offset() : this.element.offset();
        this.picker.css({
            top: offset.top + this.height,
            left: offset.left
        });
    },
    
    update: function(newDate){
        this.date = DPGlobal.parseDate(
            typeof newDate === 'string' ? newDate : (this.isInput ? this.element.prop('value') : this.element.data('date')),
            this.format
        );
        this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
        this.fill();
        this._triggerViewDateChange();
    },
    
    getDaysElements: function() {
        return this.picker.find('.' + classes.days + ' .' + classes.monthDay);
    },
    
    fillDow: function(){
        var dowCnt = this.weekStart;
        var html = '<tr class="' + classes.weekDays + '">';
        while (dowCnt < this.weekStart + 7) {
            html += '<th class="dow">'+DPGlobal.dates.daysMin[(dowCnt++)%7]+'</th>';
        }
        html += '</tr>';
        this.picker.find('.' + classes.days + ' thead').append(html);
    },
    
    fillMonths: function(){
        var html = '';
        var i = 0;
        while (i < 12) {
            html += '<span class="' + classes.month + '">'+DPGlobal.dates.monthsShort[i++]+'</span>';
        }
        this.picker.find('.' + classes.months + ' td').append(html);
    },
    
    fill: function() {
        /*jshint maxstatements:70, maxcomplexity:28*/
        var d = new Date(this.viewDate),
            year = d.getFullYear(),
            month = d.getMonth(),
            currentDate = this.date.valueOf();
        
        // Calculate first date to show, usually on previous month:
        var prevMonth = new Date(year, month-1, 28,0,0,0,0),
            lastDayPrevMonth = DPGlobal.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
        // L18N?
        prevMonth.setDate(lastDayPrevMonth);
        prevMonth.setDate(lastDayPrevMonth - (prevMonth.getDay() - this.weekStart + 7)%7);        

        // IMPORTANT: Avoid duplicated work, by checking we are still showing the same month,
        // so not need to 're-render' everything, only swap the active date
        if (this._prevDate && this._prevDate.getMonth() === this.viewDate.getMonth()) {
            var tbody = this.picker.find('.' + classes.days + ' tbody');
            // Remove previous active date mark
            // (viewDate has effectively the value of previous active date, but doing a class search woks too :-)
            tbody.find('.' + classes.monthDay + '.' + classes.active)
            .removeClass(classes.active);

            // Add date mark to current
            var diff = lastDayPrevMonth - prevMonth.getDate(),
                index = diff + this.date.getDate(),
                irow = (index / 7) |0,
                icol = index % 7;
            tbody.find('tr:eq(' + irow + ') td:eq(' + icol + ')').addClass(classes.active);        
            
            this._prevDate = new Date(this.viewDate);
            // DONE:
            return;
        }
        this._prevDate = new Date(this.viewDate);

        // Header
        this.picker
        .find('.' + classes.days + ' th:eq(1)')
        .html(DPGlobal.dates.months[month] + ' ' + year);

        // Calculate ending
        var nextMonth = new Date(prevMonth);
        nextMonth.setDate(nextMonth.getDate() + 42);
        nextMonth = nextMonth.valueOf();
        var html = [];
        var clsName,
            prevY,
            prevM;
            
        if (this._daysCreated !== true) {
            // Create base html (first time only)
            // TODO: Move to constructor
            for(var r = 0; r < 6; r++) {
                html.push('<tr>');
                for(var c = 0; c < 7; c++) {
                    html.push('<td class="' + classes.monthDay + '"><span>&nbsp;</span></td>');
                }
                html.push('</tr>');
            }

            this.picker.find('.' + classes.days + ' tbody').empty().append(html.join(''));
            this._daysCreated = true;
        }

        // Update days values    
        var weekTr = this.picker.find('.' + classes.days + ' tbody tr:first-child()');
        var dayTd = null;
        while(prevMonth.valueOf() < nextMonth) {
            var currentWeekDayIndex = prevMonth.getDay() - this.weekStart;

            clsName = this.onRender(prevMonth);
            prevY = prevMonth.getFullYear();
            prevM = prevMonth.getMonth();
            if ((prevM < month &&  prevY === year) ||  prevY < year) {
                clsName += ' old';
            } else if ((prevM > month && prevY === year) || prevY > year) {
                clsName += ' new';
            }
            if (prevMonth.valueOf() === currentDate) {
                clsName += ' ' + classes.active;
            }

            dayTd = weekTr.find('td:eq(' + currentWeekDayIndex + ')');
            dayTd
            .attr('class', classes.monthDay + ' ' + clsName)
            .data('date-time', prevMonth.toISOString())
            .children('span').text(prevMonth.getDate());

            this.picker.trigger(events.dayRendered, [dayTd]);

            // Next week?
            if (prevMonth.getDay() === this.weekEnd) {
                weekTr = weekTr.next('tr');
            }
            prevMonth.setDate(prevMonth.getDate()+1);
        }

        var currentYear = this.date.getFullYear();
        
        var months = this.picker.find('.' + classes.months)
                    .find('th:eq(1)')
                        .html(year)
                        .end()
                    .find('span').removeClass(classes.active);
        if (currentYear === year) {
            months.eq(this.date.getMonth()).addClass(classes.active);
        }
        
        html = '';
        year = parseInt(year/10, 10) * 10;
        var yearCont = this.picker.find('.' + classes.years)
                            .find('th:eq(1)')
                                .text(year + '-' + (year + 9))
                                .end()
                            .find('td');
        
        year -= 1;
        var i;
        if (this._yearsCreated !== true) {

            for (i = -1; i < 11; i++) {
                html += '<span class="' + classes.year + (i === -1 || i === 10 ? ' old' : '')+(currentYear === year ? ' ' + classes.active : '')+'">'+year+'</span>';
                year += 1;
            }
            
            yearCont.html(html);
            this._yearsCreated = true;
        }
        else {
            
            var yearSpan = yearCont.find('span:first-child()');
            for (i = -1; i < 11; i++) {
                //html += '<span class="year'+(i === -1 || i === 10 ? ' old' : '')+(currentYear === year ? ' ' + classes.active : '')+'">'+year+'</span>';
                yearSpan
                .text(year)
                .attr('class', 'year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' ' + classes.active : ''));
                year += 1;
                yearSpan = yearSpan.next();
            }
        }
    },
    
    moveDate: function(dir, mode) {
        // dir can be: 'prev', 'next'
        if (['prev', 'next'].indexOf(dir && dir.toLowerCase()) == -1)
            // No valid option:
            return;
            
        // default mode is the current one
        mode = mode || this.viewMode;

        this.viewDate['set'+DPGlobal.modes[mode].navFnc].call(
            this.viewDate,
            this.viewDate['get'+DPGlobal.modes[mode].navFnc].call(this.viewDate) + 
            DPGlobal.modes[mode].navStep * (dir === 'prev' ? -1 : 1)
        );
        this.fill();
        this._triggerViewDateChange();
        this.set();
    },

    click: function(e) {
        /*jshint maxcomplexity:16, maxstatements:30*/
        e.stopPropagation();
        e.preventDefault();
        var target = $(e.target).closest('span.month, span.year, td, th');
        if (target.length === 1) {
            var month, year;
            
            var completeMonthYear = function completeMonthYear() {
                if (this.viewMode !== 0) {
                    this.date = new Date(this.viewDate);
                    this.element.trigger({
                        type: events.dateChanged,
                        date: this.date,
                        viewMode: DPGlobal.modes[this.viewMode].clsName
                    });
                }
                this.showMode(-1);
                this.fill();
                this.set();
            }.bind(this);

            if (target.hasClass('switch')) {
                    this.showMode(1);
            }
            else if (target.hasClass('prev') ||
                target.hasClass('next')) {
                    this.moveDate(target[0].className);
            }
            else if (target.hasClass(classes.month)) {
                month = target.parent().find('span').index(target);
                this.viewDate.setMonth(month);
                completeMonthYear();
                this._triggerViewDateChange();
            }
            else if (target.hasClass(classes.year)) {
                year = parseInt(target.text(), 10)||0;
                this.viewDate.setFullYear(year);
                completeMonthYear();
                this._triggerViewDateChange();
            }
            else if (target.hasClass(classes.monthDay)) {
                if (!target.is('.disabled')){
                    var day = parseInt(target.text(), 10)||1;
                    month = this.viewDate.getMonth();
                    month += target.hasClass('old') ? -1 :
                        target.hasClass('new') ? 1 : 0;

                    year = this.viewDate.getFullYear();
                    this.date = new Date(year, month, day,0,0,0,0);
                    this.viewDate = new Date(year, month, Math.min(28, day),0,0,0,0);
                    this.fill();
                    this._triggerViewDateChange();
                    this.set();
                    this.element.trigger({
                        type: events.dateChanged,
                        date: this.date,
                        viewMode: DPGlobal.modes[this.viewMode].clsName
                    });
                }
            }
        }
    },
    
    mousedown: function(e){
        e.stopPropagation();
        e.preventDefault();
    },
    
    showMode: function(dir) {
        if (dir) {
            this.viewMode = Math.max(this.minViewMode, Math.min(2, this.viewMode + dir));
        }
        this.picker.find('>div').hide().filter('.' + classes.component + '-' + DPGlobal.modes[this.viewMode].clsName).show();
    }
};

$.fn.datepicker = function ( option ) {
    var vals = Array.prototype.slice.call(arguments, 1);
    var returned;
    this.each(function () {
        var $this = $(this),
            data = $this.data('datepicker'),
            options = typeof option === 'object' && option;
        if (!data) {
            $this.data('datepicker', (data = new DatePicker(this, $.extend({}, $.fn.datepicker.defaults,options))));
        }

        if (typeof option === 'string') {
            returned = data[option].apply(data, vals);
            // There is a value returned by the method?
            if (typeof(returned) !== 'undefined') {
                // Go out the loop to return the value from the first
                // element-method execution
                return false;
            }
            // Follow next loop item
        }
    });
    if (typeof(returned) !== 'undefined')
        return returned;
    else
        // chaining:
        return this;
};

$.fn.datepicker.defaults = {
    onRender: function(/*date*/) {
        return '';
    }
};
$.fn.datepicker.Constructor = DatePicker;

/** Public API **/
exports.DatePicker = DatePicker;
exports.defaults = DPGlobal;
exports.utils = DPGlobal;

},{}],98:[function(require,module,exports){
/**
    SmartNavBar component.
    Requires its CSS counterpart.
    
    Created based on the project:
    
    Project-Tyson
    Website: https://github.com/c2prods/Project-Tyson
    Author: c2prods
    License:
    The MIT License (MIT)
    Copyright (c) 2013 c2prods
    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**/
var $ = require('jquery');

/**
    Internal utility.
    Removes all children for a DOM node
**/
var clearNode = function (node) {
    while(node.firstChild){
        node.removeChild(node.firstChild);
    }
};

/**
    Calculates and applies the best sizing and distribution for the title
    depending on content and buttons.
    Pass in the title element, buttons must be found as siblings of it.
**/
var textboxResize = function textboxResize(el) {
    /* jshint maxstatements: 28, maxcomplexity:11 */
    
    var leftbtn = el.parentNode.querySelectorAll('.SmartNavBar-edge.left')[0];
    var rightbtn = el.parentNode.querySelectorAll('.SmartNavBar-edge.right')[0];
    if (typeof leftbtn === 'undefined') {
        leftbtn = {
            offsetWidth: 0,
            className: ''
        };
    }
    if (typeof rightbtn === 'undefined') {
        rightbtn = {
            offsetWidth: 0,
            className: ''
        };
    }
    
    var margin = Math.max(leftbtn.offsetWidth, rightbtn.offsetWidth);
    el.style.marginLeft = margin + 'px';
    el.style.marginRight = margin + 'px';
    var tooLong = (el.offsetWidth < el.scrollWidth) ? true : false;
    if (tooLong) {
        if (leftbtn.offsetWidth < rightbtn.offsetWidth) {
            el.style.marginLeft = leftbtn.offsetWidth + 'px';
            el.style.textAlign = 'right';
        } else {
            el.style.marginRight = rightbtn.offsetWidth + 'px';
            el.style.textAlign = 'left';
        }
        tooLong = (el.offsetWidth<el.scrollWidth) ? true : false;
        if (tooLong) {
            if (new RegExp('arrow').test(leftbtn.className)) {
                clearNode(leftbtn.childNodes[1]);
                el.style.marginLeft = '26px';
            }
            if (new RegExp('arrow').test(rightbtn.className)) {
                clearNode(rightbtn.childNodes[1]);
                el.style.marginRight = '26px';
            }
        }
    }
};

exports.textboxResize = textboxResize;

/**
    SmartNavBar class, instantiate with a DOM element
    representing a navbar.
    API:
    - refresh: updates the control taking care of the needed
        width for title and buttons
**/
var SmartNavBar = function SmartNavBar(el) {
    this.el = el;
    
    this.refresh = function refresh() {
        var h = $(el).children('h1').get(0);
        if (h)
            textboxResize(h);
    };

    this.refresh(); 
};

exports.SmartNavBar = SmartNavBar;

/**
    Get instances for all the SmartNavBar elements in the DOM
**/
exports.getAll = function getAll() {
    var all = $('.SmartNavBar');
    return $.map(all, function(item) { return new SmartNavBar(item); });
};

/**
    Refresh all SmartNavBar found in the document.
**/
exports.refreshAll = function refreshAll() {
    $('.SmartNavBar > h1').each(function() { textboxResize(this); });
};

},{}],99:[function(require,module,exports){
/**
    Custom Loconomics 'locale' styles for date/times.
    Its a bit more 'cool' rendering dates ;-)
**/
'use strict';

var moment = require('moment');
// Since the task of define a locale changes
// the current global locale, we save a reference
// and restore it later so nothing changed.
var current = moment.locale();

moment.locale('en-US-LC', {
    meridiemParse : /[ap]\.?\.?/i,
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'p' : 'P';
        } else {
            return isLower ? 'a' : 'A';
        }
    },
    calendar : {
        lastDay : '[Yesterday]',
        sameDay : '[Today]',
        nextDay : '[Tomorrow]',
        lastWeek : '[last] dddd',
        nextWeek : 'dddd',
        sameElse : 'M/D'
    },
    longDateFormat : {
        LT: 'h:mma',
        LTS: 'h:mm:ssa',
        L: 'MM/DD/YYYY',
        l: 'M/D/YYYY',
        LL: 'MMMM Do YYYY',
        ll: 'MMM D YYYY',
        LLL: 'MMMM Do YYYY LT',
        lll: 'MMM D YYYY LT',
        LLLL: 'dddd, MMMM Do YYYY LT',
        llll: 'ddd, MMM D YYYY LT'
    }
});

// Restore locale
moment.locale(current);

},{"moment":false}],100:[function(require,module,exports){
/**
    Shows a textarea field to introduce or change a text, usefull 
    for interfaces like Cards where an inline textarea is not wanted.
    
    @param options:Object {
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when a button is pressed with the introduced text on 'save'.
    Is rejected when the modal is dismissed/closed, like when pressing 'cancel', 'return' or 'close'.
**/
/*global window*/
'use strict';

var ko = require('knockout'),
    $ = require('jquery');

exports.show = function showTextEditor(options) {
    //jshint maxcomplexity:10

    var modal = $('#textEditorModal'),
        vm = modal.data('viewmodel');
    
    if (!vm) {
        vm = new TextEditorModel();

        ko.applyBindings(vm, modal.get(0));
        modal.data('viewmodel', vm);
    }

    options = options || {};
    
    // Input options and data
    vm.title(options.title || '');
    vm.text(options.text || '');
    
    return new Promise(function(resolve, reject) {
        
        // Handlers
        var save = function() {
            resolve(vm.text());
            modal.modal('hide');
        };

        // Just closed without pick anything, rejects
        modal.off('hide.bs.modal');
        // Reject on hide event, but do not pass the event in the
        // first parameter (the error is null, since there is no error).
        modal.on('hide.bs.modal', reject.bind(null, null));
        modal.off('click', '#textEditorModal-save');
        modal.on('click', '#textEditorModal-save', save);

        // Autofocus
        modal.one('shown.bs.modal', function() { setTimeout(function() {
            var $text = modal.find('textarea');
            // Inmediate focus to the textarea for better usability
            $text.focus();
            $text.click();
            // IMPORTANT: WORKAROUND: for iOS: on iOS (checked up to 8.3, 2015-05-20), the opening of the virtual keyboard
            // makes a scroll down of the viewport, hiding the text field, header, anything, and only the
            // blank area gets showed. That bad autoscroll can be fixed on this single case with next trick
            // without flickering or bad effects (and alternative, generic approach is do it on the keyboardShow
            // event, but there a flickering happens and may affect cases where there is no need or can be worse
            // if field visibility and actual scroll is not checked):
            window.scrollTo(0, 0);
        }, 100); });
        
        modal.modal('show');
    });
};

function TextEditorModel() {
    this.title = ko.observable('');
    this.text = ko.observable('');
}

},{"knockout":false}],101:[function(require,module,exports){
'use strict';

var ko = require('knockout'),
    $ = require('jquery');

// internal utility function 'to string with two digits almost'
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Shows a time picker, based on different dropdowns for each time part.
    Supports hours and minutes (with am/pm for US locale)
    @param options:Object {
        title:string Optional. The text to show in the modal's header,
            with fallback to the Modal's default title.
    }
    @returns Promise. It resolves when a button is pressed, with null on 'unset'
    and an object with { time:object, timeString:string } on 'select'.
    The time object is just a plain object as { hours: 0, minutes: 0, seconds: 0 }
    Is rejected when the modal is dismissed/closed without 'unset' or 'select'.
**/
exports.show = function showTimePicker(options) {
    //jshint maxcomplexity:10

    var modal = $('#timePickerModal'),
        vm = modal.data('viewmodel');
    
    if (!vm) {
        vm = new TimePickerModel();

        ko.applyBindings(vm, modal.get(0));
        modal.data('viewmodel', vm);
    }

    options = options || {};
    
    // Fallback title
    vm.title(options.title || 'Select time');
    vm.stepInMinutes(options.stepInMinutes || 5);
    if (typeof(options.selectedTime) === 'string') {
        vm.selectedTimeString(options.selectedTime);
    }
    else {
        vm.selectedTime(options.selectedTime || {});
    }
    vm.unsetLabel(options.unsetLabel || 'Remove');
    vm.selectLabel(options.selectLabel || 'Select');
    
    return new Promise(function(resolve, reject) {
        
        // Handlers
        var unset = function() {
            resolve(null);
            modal.modal('hide');
        };
        var select = function() {
            resolve({
                time: vm.selectedTime(),
                timeString: vm.selectedTimeString()
            });
            modal.modal('hide');
        };

        // Just closed without pick anything, rejects
        modal.off('hide.bs.modal');
        modal.on('hide.bs.modal', reject);
        modal.off('click', '.timePickerModal-unset');
        modal.on('click', '.timePickerModal-unset', unset);
        modal.off('click', '.timePickerModal-select');
        modal.on('click', '.timePickerModal-select', select);

        modal.modal('show');
    });
};

function TimePickerModel() {
    
    // Set-up viewmodel and binding
    var vm = {
        title: ko.observable(''),
        pickedHour: ko.observable(null),
        pickedMinute: ko.observable(null),
        pickedAmpm: ko.observable(null),
        stepInMinutes: ko.observable(5),
        unsetLabel: ko.observable('Remove'),
        selectLabel: ko.observable('Select')
    };
    // TODO: Make localization changes with any app locale change, with timeinterval,
    // as a computed or changed by events:
    vm.locale = ko.observable({ lang: 'en', region: 'US' });

    vm.hourValues = ko.computed(function() {
        var region = this.locale().region;
        var step = (this.stepInMinutes() / 60) |0;
        // IMPORTANT: avoid infinite loops:
        if (step <= 0) step = 1;
        var values = [],
            i;
        if (region === 'US') {
            values.push({
                value: 0,
                label: 12
            });
            for (i = 1; i < 12; i += step) {
                values.push({
                    value: i,
                    label: i
                });
            }
        } else {
            for (i = 0; i < 24; i += step) {
                values.push({
                    value: i,
                    label: i
                });
            }
        }
        return values;
    }, vm);
    vm.minuteValues = ko.computed(function() {
        //var region = this.locale().region;
        var step = this.stepInMinutes() |0;
        // IMPORTANT: avoid infinite loops:
        if (step <= 0) step = 1;
        // No minutes?
        if (step >= 60) return [];

        var values = [];
        //if (region === 'US') {
        for (var i = 0; i < 60; i += step) {
            values.push({
                value: i,
                label: twoDigits(i)
            });
        }
        return values;
    }, vm);
    vm.ampmValues = ko.computed(function() {
        var region = this.locale().region;

        var values = [];
        if (region === 'US') {
            values.push({
                value: 0, // added to hours
                label: 'AM'
            });
            values.push({
                value: 12, // added to hours
                label: 'PM'
            });
        }
        return values;
    }, vm);

    vm.selectedTime = ko.computed({
        read: function() {
            return {
                hours: this.pickedHour() + this.pickedAmpm(),
                minutes: this.pickedMinute(),
                seconds: 0
            };
        },
        write: function(v) {
            if (typeof(v) !== 'object') throw new Error('Invalid input for the time picker. Value:', v);
            v = v || {};
            var region = this.locale().region;
            if (region === 'US') {
                this.pickedHour((v.hours / 12) |0);
                this.pickedMinute(v.minutes |0);
                this.pickedAmpm((v.hours % 12) |0);
            }
            else {
                this.pickedHour(v.hours |0);
                this.pickedMinute(v.minutes |0);
                this.pickedAmpm(0);
            }
        },
        owner: vm
    });

    vm.selectedTimeString = ko.computed({
        read: function() {
            var t = this.selectedTime();
            return twoDigits(t.hours) + ':' + twoDigits(t.minutes) + ':' + twoDigits(t.seconds);
        },
        write: function(v) {
            v = v || '';
            var parts = v.split(':');
            this.selectedTime({
                hours: parts[0] |0,
                minutes: parts[1] |0,
                seconds: parts[2] |0
            });
        },
        owner: vm
    });
    
    return vm;
}

},{"knockout":false}],102:[function(require,module,exports){
/** Address model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

function Address(values) {

    Model(this);
    
    this.model.defProperties({
        addressID: 0,
        addressName: '',
        jobTitleID: 0,
        userID: 0,
        addressLine1: null,
        addressLine2: null,
        postalCode: null,
        city: null, // Autofilled by server
        stateProvinceCode: null, // Autofilled by server
        stateProvinceName: null, // Autofilled by server
        countryCode: null, // ISO Alpha-2 code, Ex.: 'US'
        latitude: null,
        longitude: null,
        specialInstructions: null,
        isServiceArea: false,
        isServiceLocation: false,
        serviceRadius: 0,
        createdDate: null, // Autofilled by server
        updatedDate: null, // Autofilled by server
        kind: '' // Autofilled by server
    }, values);
    
    this.singleLine = ko.computed(function() {
        
        var list = [
            this.addressLine1(),
            this.city(),
            this.postalCode(),
            this.stateProvinceCode()
        ];
        
        return list.filter(function(v) { return !!v; }).join(', ');
    }, this);
    
    // TODO: needed? l10n? must be provided by server side?
    var countries = {
        'US': 'United States',
        'ES': 'Spain'
    };
    this.countryName = ko.computed(function() {
        return countries[this.countryCode()] || 'unknow';
    }, this);

    // Useful GPS object with the format used by Google Maps
    this.latlng = ko.computed(function() {
        return {
            lat: this.latitude(),
            lng: this.longitude()
        };
    }, this);
}

module.exports = Address;

// Public Enumeration for the 'kind' property:
Address.kind = {
    home: 'home',
    billing: 'billing',
    service: 'service'
};

},{"./Model":123,"knockout":false}],103:[function(require,module,exports){
/** Appointment model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment'),
    PricingSummaryDetail = require('./PricingSummaryDetail'),
    CalendarEvent = require('./CalendarEvent'),
    Booking = require('./Booking');

function Appointment(values) {
    
    Model(this);

    this.model.defProperties({
        // An appointment ever references an event, and its 'id' is a CalendarEventID
        // even if other complementary object are used as 'source'
        id: null,
        
        startTime: null,
        endTime: null,
        
        // CommonEvent fields:
        summary: 'New booking',
        description: null,
        
        // Event specific fields:
        isAllDay: false,

        // Fields specific for bookings
        price: 0,
        // Actual bookings fields to use on post/put
        clientUserID: null,
        pricing: {
            Model: PricingSummaryDetail,
            isArray: true
        },
        addressID: null,
        preNotesToClient: null,
        postNotesToClient: null,
        preNotesToSelf: null,
        postNotesToSelf: null,
        
        jobTitleID: 0,
        
        readOnly: false,
        
        sourceEvent: {
            Model: CalendarEvent,
            defaultValue: null
        },
        sourceBooking: {
            Model: Booking,
            defaultValue: null
        }
    }, values);

    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').calendar();
        
    }, this);
    
    this.displayedStartTime = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedEndTime = ko.pureComputed(function() {
        
        return moment(this.endTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedTimeRange = ko.pureComputed(function() {
        
        return this.displayedStartTime() + '-' + this.displayedEndTime();
        
    }, this);
    
    this.itStarted = ko.pureComputed(function() {
        return (this.startTime() && new Date() >= this.startTime());
    }, this);
    
    this.itEnded = ko.pureComputed(function() {
        return (this.endTime() && new Date() >= this.endTime());
    }, this);
    
    this.isNew = ko.pureComputed(function() {
        return (!this.id());
    }, this);
    
    this.stateHeader = ko.pureComputed(function() {
        
        var text = '';
        if (this.id() > 0 && this.sourceEvent()) {
            if (!this.sourceBooking()) {
                text = 'Calendar block';
            }
            else if (this.itStarted()) {
                if (this.itEnded()) {
                    text = 'Completed';
                }
                else {
                    text = 'Now';
                }
            }
            else {
                text = 'Upcoming';
            }
        }

        return text;
        
    }, this);
}

module.exports = Appointment;

/**
    Creates an appointment instance from a CalendarEvent model instance
**/
Appointment.fromCalendarEvent = function fromCalendarEvent(event) {
    var apt = new Appointment();
    
    // Include event in apt
    apt.id(event.calendarEventID());
    apt.startTime(event.startTime());
    apt.endTime(event.endTime());
    apt.summary(event.summary());
    apt.description(event.description());
    apt.isAllDay(event.isAllDay());
    apt.readOnly(event.readOnly());
    apt.sourceEvent(event);
    
    return apt;
};

/**
    Creates an appointment instance from a Booking and a CalendarEvent model instances
**/
Appointment.fromBooking = function fromBooking(booking, event) {
    // Include event in apt
    var apt = Appointment.fromCalendarEvent(event);
    
    // Include booking in apt
    apt.clientUserID(booking.clientUserID());
    apt.addressID(booking.serviceAddressID());
    apt.jobTitleID(booking.jobTitleID());
    apt.pricing(booking.pricingSummary() && booking.pricingSummary().details());
    apt.preNotesToClient(booking.preNotesToClient());
    apt.postNotesToClient(booking.postNotesToClient());
    apt.preNotesToSelf(booking.preNotesToSelf());
    apt.postNotesToSelf(booking.postNotesToSelf());
    
    // On bookings, readOnly must set to false (is sent as true ever from
    // the server, to prevent direct manipulation of the event that is part of
    // a booking
    apt.readOnly(false);

    var prices = booking.pricingSummary();
    if (prices) {
        // TODO Setting service professional price, for clients must be
        // just totalPrice()
        apt.price(prices.totalPrice() - prices.pFeePrice());
    }

    apt.sourceBooking(booking);

    return apt;
};

/**
    Creates a list of appointment instances from the list of events and bookings.
    The bookings list must contain every booking that belongs to the events of type
    'booking' from the list of events.
**/
Appointment.listFromCalendarEventsBookings = function listFromCalendarEventsBookings(events, bookings) {
    return events.map(function(event) {
        var booking = null;
        bookings.some(function(searchBooking) {
            var found = searchBooking.serviceDateID() === event.calendarEventID();
            if (found) {
                booking = searchBooking;
                return true;
            }
        });

        if (booking)
            return Appointment.fromBooking(booking, event);
        else
            return Appointment.fromCalendarEvent(event);
    });
};

Appointment.specialIds = {
    loading: 0,
    emptyDate: -1,
    free: -2,
    newEvent: -3,
    newBooking: -4,
    unavailable: -5,
    preparationTime: -6
};

var Time = require('../utils/Time');
/**
    Creates an Appointment instance that represents a calendar slot of
    free/spare time, for the given time range, or the full given date.
    @param options:Object {
        date:Date. Optional. Used to create a full date slot or default for start/end
            to date start or date end
        start:Date. Optional. Beggining of the slot
        end:Date. Optional. Ending of the slot
        text:string. Optional ['Free']. To allow external localization of the text.
    }
**/
Appointment.newFreeSlot = function newFreeSlot(options) {
    
    var start = options.start || new Time(options.date, 0, 0, 0),
        end = options.end || new Time(options.date, 0, 0, 0);

    return new Appointment({
        id: Appointment.specialIds.free,

        startTime: start,
        endTime: end,

        summary: options.text || 'Free',
        description: null
    });
};

Appointment.newUnavailableSlot = function newUnavailableSlot(options) {
    
    var start = options.start || new Time(options.date, 0, 0, 0),
        end = options.end || new Time(options.date, 0, 0, 0);

    return new Appointment({
        id: Appointment.specialIds.unavailable,

        startTime: start,
        endTime: end,

        summary: options.text || 'Unavailable',
        description: null
    });
};

Appointment.newPreparationTimeSlot = function newPreparationTimeSlot(options) {

    var start = options.start || new Time(options.date, 0, 0, 0),
        end = options.end || new Time(options.date, 0, 0, 0);

    return new Appointment({
        id: Appointment.specialIds.preparationTime,

        startTime: start,
        endTime: end,

        summary: options.text || 'Preparation time',
        description: null
    });
};
},{"../utils/Time":164,"./Booking":104,"./CalendarEvent":106,"./Model":123,"./PricingSummaryDetail":126,"knockout":false,"moment":false}],104:[function(require,module,exports){
/** Booking model.

    Describes a booking and related data,
    mainly the pricing summary and details, but
    can hold other related data if optionally loaded
    (address, dates, publicUserJobTitle)
 **/
'use strict';

var Model = require('./Model'),
    PricingSummary = require('./PricingSummary'),
    PublicUserJobTitle = require('./PublicUserJobTitle'),
    Address = require('./Address'),
    EventDates = require('./EventDates');

function Booking(values) {
    
    Model(this);

    this.model.defProperties({
        bookingID: 0,
        clientUserID: 0,
        serviceProfessionalUserID: 0,
        jobTitleID: 0,
        languageID: 0,
        countryID: 0,
        bookingStatusID: 0,
        bookingTypeID: 0,
        cancellationPolicyID: 0,
        parentBookingID: null,
        
        serviceAddressID: null,
        serviceDateID: null,
        alternativeDate1ID: null,
        alternativeDate2ID: null,
        
        pricingSummaryID: 0,
        pricingSummaryRevision: 0,
        paymentLastFourCardNumberDigits: null,
        totalPricePaidByClient: null,
        totalServiceFeesPaidByClient: null,
        totalPaidToServiceProfessional: null,
        totalServiceFeesPaidByServiceProfessional: null,

        instantBooking: false,
        firstTimeBooking: false,
        sendReminder: false,
        sendPromotional: false,
        recurrent: false,
        multiSession: false,
        pricingAdjustmentApplied: false,
        paymentEnabled: false,
        paymentCollected: false,
        paymentauthorized: false,
        awaitingResponseFromUserID: null,
        pricingAdjustmentRequested: false,
        
        updatedDate: null,
        
        specialRequests: null,
        preNotesToClient: null,
        postNotesToClient: null,
        preNotesToSelf: null,
        postNotesToSelf: null,
        
        reviewedByServiceProfessional: false,
        reviewedByClient: false,
        
        pricingSummary: new PricingSummary(),
        serviceAddress: {
            Model: Address
        },
        serviceDate: {
            Model: EventDates
        },
        alternativeDate1: {
            Model: EventDates
        },
        alternativeDate2: {
            Model: EventDates
        },
        userJobTitle: {
            Model: PublicUserJobTitle
        }
    }, values);
}

module.exports = Booking;

Booking.from = function from(data) {
    if (Array.isArray(data)) {
        return data.map(Booking.from);
    }
    else {
        return new Booking(data);
    }
};

},{"./Address":102,"./EventDates":110,"./Model":123,"./PricingSummary":125,"./PublicUserJobTitle":130}],105:[function(require,module,exports){
/** BookingSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');
    
function BookingSummary(values) {
    
    Model(this);

    this.model.defProperties({
        quantity: 0,
        concept: '',
        time: null,
        timeFormat: ' [@] h:mma'
    }, values);

    this.phrase = ko.pureComputed(function(){
        var t = this.timeFormat() && 
            this.time() && 
            moment(this.time()).format(this.timeFormat()) ||
            '';        
        return this.concept() + t;
    }, this);

    this.url = ko.pureComputed(function() {
        var url = this.time() &&
            '/calendar/' + this.time().toISOString();
        
        return url;
    }, this);
}

module.exports = BookingSummary;

},{"./Model":123,"knockout":false,"moment":false}],106:[function(require,module,exports){
/**
    Event model
**/
'use strict';

/* Example JSON (returned by the REST API):
{
  "EventID": 353,
  "UserID": 141,
  "EventTypeID": 3,
  "Summary": "Housekeeper services for John D.",
  "AvailabilityTypeID": 3,
  "StartTime": "2014-03-25T08:00:00Z",
  "EndTime": "2014-03-25T18:00:00Z",
  "Kind": 0,
  "IsAllDay": false,
  "TimeZone": "01:00:00",
  "Location": "null",
  "UpdatedDate": "2014-10-30T15:44:49.653",
  "CreatedDate": null,
  "Description": "test description of a REST event",
  "RecurrenceRule": {
    "FrequencyTypeID": 502,
    "Interval": 1,
    "Until": "2014-07-01T00:00:00",
    "Count": null,
    "Ending": "date",
    "SelectedWeekDays": [
      1,
    ],
    "MonthlyWeekDay": false,
    "Incompatible": false,
    "TooMany": false
  },
  "RecurrenceOccurrences": null,
  "ReadOnly": false
}*/

var Model = require('./Model');

function RecurrenceRule(values) {
    Model(this);
    
    this.model.defProperties({
        frequencyTypeID: 0,
        interval: 1, //:Integer
        until: null, //:Date
        count: null, //:Integer
        ending: null, // :string Possible values allowed: 'never', 'date', 'ocurrences'
        selectedWeekDays: [], // :integer[] 0:Sunday
        monthlyWeekDay: false,
        incompatible: false,
        tooMany: false
    }, values);
}

function RecurrenceOccurrence(values) {
    Model(this);
    
    this.model.defProperties({
        startTime: null, //:Date
        endTime: null //:Date
    }, values);
}
   
function CalendarEvent(values) {
    
    Model(this);
    
    // Special values: dates must be converted
    // to a Date object. They come as ISO string
    // TODO: Make this something generic, or even in Model definitions,
    // and use for updated/createdDate around all the project
    if (values) {
        values.startTime = values.startTime && new Date(Date.parse(values.startTime)) || null;
        values.endTime = values.endTime && new Date(Date.parse(values.endTime)) || null;
    }

    this.model.defProperties({
        calendarEventID: 0,
        userID: 0,
        eventTypeID: 3,
        summary: '',
        availabilityTypeID: 0,
        startTime: null,
        endTime: null,
        kind: 0,
        isAllDay: false,
        timeZone: 'Z',
        location: null,
        updatedDate: null,
        createdDate: null,
        description: '',
        readOnly: false,
        recurrenceRule: {
            Model: RecurrenceRule
        },
        recurrenceOccurrences: {
            isArray: true,
            Model: RecurrenceOccurrence
        }
    }, values);
}

module.exports = CalendarEvent;

CalendarEvent.RecurrenceRule = RecurrenceRule;
CalendarEvent.RecurrenceOccurrence = RecurrenceOccurrence;

},{"./Model":123}],107:[function(require,module,exports){
/**
    CalendarSyncing model.
 **/
'use strict';

var Model = require('./Model');

function CalendarSyncing(values) {

    Model(this);

    this.model.defProperties({
        icalExportUrl: '',
        icalImportUrl: ''
    }, values);
}

module.exports = CalendarSyncing;

},{"./Model":123}],108:[function(require,module,exports){
/** client model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

function Client(values) {
    
    Model(this);
    
    this.model.defProperties({
        clientUserID: 0,
        
        firstName: '',
        lastName: '',
        secondLastName: '',
        email: '',
        phone: null,
        canReceiveSms: false,
        birthMonthDay: null,
        birthMonth: null,
        
        notesAboutClient: null,
        
        createdDate: null,
        updatedDate: null,
        editable: false
    }, values);

    this.fullName = ko.pureComputed(function() {
        return ((this.firstName() || '') + ' ' + (this.lastName() || ''));
    }, this);
    
    this.birthDay = ko.pureComputed(function() {
        if (this.birthMonthDay() &&
            this.birthMonth()) {
            
            // TODO i10n
            return this.birthMonth() + '/' + this.birthMonthDay();
        }
        else {
            return null;
        }
    }, this);
}

module.exports = Client;

},{"./Model":123,"knockout":false}],109:[function(require,module,exports){
/**
    Keeps a date availability object that includes a list of appointments
    that fills all the times in the date (following the weekDaySchedule and free/unavailable
    times) and summary of the availability status of the date.
    Updating the main properties: appointmentsList, date, weekDaySchedule, the complete
    list and summaries auto calculate to show the proper listing.
**/
'use strict';

var Model = require('../models/Model');
var Appointment = require('../models/Appointment'),
    WeekDaySchedule = require('../models/WeekDaySchedule'),
    SchedulingPreferences = require('../models/SchedulingPreferences'),
    moment = require('moment'),
    ko = require('knockout'),
    availabilityCalculation = require('../utils/availabilityCalculation'),
    getDateWithoutTime = require('../utils/getDateWithoutTime');

function DateAvailability(values) {

    Model(this);
    
    this.model.defProperties({
        date: null, // Date
        weekDaySchedule: {
            Model: WeekDaySchedule
        },
        appointmentsList: {
            isArray: true,
            Model: Appointment
        },
        schedulingPreferences: {
            Model: SchedulingPreferences
        }
    }, values);
    
    /**
        :array<Appointment> List of appointments for all the times in the date.
        It introduces free and unavailable appointments using appointmentsList as base
        for actual *busy* appointments and the rules of weekDaySchedule
    **/
    this.list = ko.pureComputed(function() {
        return availabilityCalculation.fillDayAvailability(
            this.date(), this.appointmentsList(), this.weekDaySchedule(), this.schedulingPreferences()
        );
    }, this);

    /**
        :int
        Number of minutes scheduled for work in a generic/empty day
        based on the information at weekDaySchedule.
    **/
    this.workDayMinutes = ko.pureComputed(function() {
        var schedule = this.weekDaySchedule();
        // from-to are minutes of the day, so its easy to calculate
        return (schedule.to() - schedule.from()) |0;
    }, this);

    /**
        :int
        Number of minutes available to be scheduled in this date
        inside the work time (weekDaySchedule.
        It's the sum of all 'Free' appointments in the date.
    **/
    this.availableMinutes = ko.pureComputed(function() {
        return this.list().reduce(function(minutes, apt) {
            if (apt.id() === Appointment.specialIds.free) {
                var et = moment(apt.endTime()),
                    st = moment(apt.startTime());
                minutes += et.diff(st, 'minutes');
            }
            return minutes;
        }, 0);
    }, this);

    /**
        :int
        Percentage number from 0 to 100 of time
        available time in the date (availableMinutes / workDayMinutes)
    **/
    this.availablePercent = ko.pureComputed(function() {
        return (Math.round((this.availableMinutes() / this.workDayMinutes()) * 100));
    }, this);

    /**
        :string
        A text value from an enumeration that represents
            ranges of availablePercent, suitable for high level use as CSS classes.
            Special case on past date-time, when it returns 'past' rather than the
            availability, since past times are not availabile for anything new (can't change the past! ;-)
            Can be: 'none', 'low', 'medium', 'full', 'past'
    **/
    this.availableTag = ko.pureComputed(function() {
        var perc = this.availablePercent(),
            date = this.date(),
            today = getDateWithoutTime();

        if (date < today)
            return 'past';
        else if (perc >= 100)
            return 'full';
        else if (perc >= 50)
            return 'medium';
        else if (perc > 0)
            return 'low';
        else // <= 0
            return 'none';
    }, this);
    
    /**
        Retrieve a list of date-times that are free, available to be used,
        in this date with a separation between each of the given slotSize
        in minutes or using the default from the scheduling preferences
        included in the object.

        The parameter 'duration' (in minutes) allows that returned slots
        are free almost for the given duration. This allows to choose times
        that fit the needed service duration.
    **/
    var createTimeSlots = require('../utils/createTimeSlots');
    this.getFreeTimeSlots = function getFreeTimeSlots(duration, slotSizeMinutes) {
        
        slotSizeMinutes = slotSizeMinutes || this.schedulingPreferences().incrementsSizeInMinutes();
        
        if (!duration)
            duration = slotSizeMinutes;
        
        var date = this.date(),
            today = getDateWithoutTime();
    
        // Quick return if with empty list when
        // - past date (no time)
        // - no available time (already computed)
        if (date < today ||
            this.availableMinutes() <= 0) {
            return [];
        }
        else {
            return createTimeSlots.forList(this.getFreeAvailableSlots(), slotSizeMinutes, duration);
        }
    };
    
    /**
        Returns a list of objects of type AvailableSlot
        ( { startTime:Date, endTime:Date, availability:'free' } )
        for every free/available time range in the date
    **/
    this.getFreeAvailableSlots = function getFreeAvailableSlots() {
        
        var date = this.date(),
            today = getDateWithoutTime();
    
        // Quick return with empty list when
        // - past date (no time)
        // - no available time (already computed)
        if (date < today ||
            this.availableMinutes() <= 0) {
            return [];
        }
        else {
            var slots = [];
            // Iterate every free appointment
            this.list().forEach(function (apt) {
                if (apt.id() === Appointment.specialIds.free) {
                    slots.push({
                        availability: 'free',
                        startTime: apt.startTime(),
                        endTime: apt.endTime()
                    });
                }
            });
            return slots;
        }
    };
}

module.exports = DateAvailability;

},{"../models/Appointment":103,"../models/Model":123,"../models/SchedulingPreferences":135,"../models/WeekDaySchedule":150,"../utils/availabilityCalculation":166,"../utils/createTimeSlots":169,"../utils/getDateWithoutTime":175,"knockout":false,"moment":false}],110:[function(require,module,exports){
/**
    A dates range, simplified info usually needed from an CalendarEvent.
**/
'use strict';

var Model = require('./Model'),
    ko = require('knockout'),
    moment = require('moment');

module.exports = function EventDates(values) {
    
    Model(this);

    this.model.defProperties({
        startTime: null,
        endTime: null
    }, values);
    
    this.duration = ko.computed({
        read: function() {
            var s = this.startTime(),
                e = this.endTime();
            if (!s || !e) return null;
            
            return moment.duration(e - s);
        },
        write: function(value) {
            var s = this.startTime();

            if (!(value || value === 0) || !s) {
                this.endTime(null);
                return;
            }

            var newEnd = moment(s).clone().add(value);
            this.endTime(newEnd.toDate());
        },
        owner: this
    });
    
    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').calendar();
        
    }, this);
    
    this.displayedStartTime = ko.pureComputed(function() {
        
        return moment(this.startTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedEndTime = ko.pureComputed(function() {
        
        return moment(this.endTime()).locale('en-US-LC').format('LT');
        
    }, this);
    
    this.displayedTimeRange = ko.pureComputed(function() {
        
        return this.displayedStartTime() + '-' + this.displayedEndTime();
        
    }, this);
};

},{"./Model":123,"knockout":false,"moment":false}],111:[function(require,module,exports){
/** ExperienceLevel model.
 **/
'use strict';

var Model = require('./Model');

function ExperienceLevel(values) {
    
    Model(this);

    this.model.defProperties({
        experienceLevelID: 0,
        name: '',
        description: null,
        //createdDate: null,
        updatedDate: null
    }, values);
}

module.exports = ExperienceLevel;

},{"./Model":123}],112:[function(require,module,exports){
/** GetMore model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    ListViewItem = require('./ListViewItem');

function GetMore(values) {

    Model(this);

    this.model.defProperties({
        availability: false,
        payments: false,
        profile: false,
        coop: true
    }, values);

    var availableItems = {
        availability: new ListViewItem({
            contentLine1: 'Complete your availability to create a cleaner calendar',
            markerIcon: 'fa fa-fw fa-calendar'
        }),
        payments: new ListViewItem({
            contentLine1: 'Start accepting payments through Loconomics',
            markerIcon: 'fa ion ion-card'
        }),
        profile: new ListViewItem({
            contentLine1: 'Activate your profile in the marketplace',
            markerIcon: 'fa ion ion-cash',
            link: '/marketplaceProfile'
        }),
        coop: new ListViewItem({
            contentLine1: 'Learn more about our cooperative',
            markerIcon: 'fa fa-gavel'
        })
    };

    this.items = ko.pureComputed(function() {
        var items = [];
        
        Object.keys(availableItems).forEach(function(key) {
            
            if (this[key]())
                items.push(availableItems[key]);
        }.bind(this));

        return items;
    }, this);
}

module.exports = GetMore;

},{"./ListViewItem":118,"./Model":123,"knockout":false}],113:[function(require,module,exports){
/**
    InputPaymentMethod Model, represents
    the data to be filled in a booking request
    for payment information.
**/
'use strict';

var Address = require('./Address'),
    Model = require('./Model'),
    ko = require('knockout');

function InputPaymentMethod(values) {

    Model(this);
    
    this.model.defProperties({
        paymentMethodID: 0,
        nameOnCard: '',
        cardNumber: null,
        expirationMonth: null,
        expirationYear: null,
        securityCode: null,
        billingAddress: { Model: Address },
        savePayment: false
    }, values);
    
    this.expirationMonthYear = ko.computed({
        read: function() {
            var m = this.expirationMonth(),
                y = this.expirationYear();
            
            if (!m && !y) return '';

            return padLeft(m, 2, '0') + '/' + padLeft(y, 4, '0');
        },
        write: function(value) {
            var parts = value.split('/');
            if (parts.length === 2) {
                this.expirationMonth(padLeft(parts[0] |0, 2, '0'));
                this.expirationYear(padLeft(parts[1] |0, 4, '0'));
            }
        },
        owner: this
    });
}

module.exports = InputPaymentMethod;

function padLeft(v, length, padLetter) {
    if (!v) return '';
    v = v.toString();
    while (v.length < length) {
        v = padLetter + v;
    }
    return v;
}


},{"./Address":102,"./Model":123,"knockout":false}],114:[function(require,module,exports){
/** JobTitle model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    JobTitlePricingType = require('./JobTitlePricingType');

function JobTitle(values) {
    
    Model(this);
    
    this.model.defProperties({
        jobTitleID: 0,
        singularName: '',
        pluralName: '',
        aliases: '',
        description: null,
        searchDescription: null,
        createdDate: null,
        updatedDate: null
    }, values);

    this.model.defID(['jobTitleID']);

    // TODO: review if, not registered as a property, the list is updated
    // on syncs by using model.updateWith

    // Pricing Types relationship,
    // collection of JobTitlePricingType entities
    this.pricingTypes = ko.observableArray([]);
    if (values && values.pricingTypes) {
        values.pricingTypes.forEach(function(jobpricing) {
            this.pricingTypes.push(new JobTitlePricingType(jobpricing));
        }.bind(this));
    }
}

module.exports = JobTitle;

},{"./JobTitlePricingType":115,"./Model":123,"knockout":false}],115:[function(require,module,exports){
/**
    Defines the relationship between a JobTitle and a PricingType.
**/
'use strict';

var Model = require('./Model');

function JobTitlePricingType(values) {

    Model(this);
    
    this.model.defProperties({
        pricingTypeID: 0,
        // NOTE: Client Type is mostly unused today but exists
        // on all database records. It uses the default value
        // of 1 all the time for now.
        clientTypeID: 1,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['pricingTypeID', 'clientTypeID']);
}

module.exports = JobTitlePricingType;

},{"./Model":123}],116:[function(require,module,exports){
/** JobTitleServiceAttributes model.
 **/
'use strict';

var Model = require('./Model'),
    ServiceAttributeCategory = require('./ServiceAttributeCategory'),
    ExperienceLevel = require('./ExperienceLevel');

function JobTitleServiceAttributes(values) {

    Model(this);

    this.model.defProperties({
        jobTitleID: 0,
        serviceAttributes: {
            isArray: true,
            Model: ServiceAttributeCategory
        },
        experienceLevels: {
            isArray: true,
            Model: ExperienceLevel
        },
        languageID: 0,
        countryID: 0
        //createdDate: null,
        //updatedDate: null
    }, values);
}

module.exports = JobTitleServiceAttributes;

},{"./ExperienceLevel":111,"./Model":123,"./ServiceAttributeCategory":137}],117:[function(require,module,exports){
/** LicenseCertification model **/
'use strict';

var Model = require('./Model');

function LicenseCertification(values) {

    Model(this);
    
    this.model.defProperties({
        licenseCertificationID: 0,
        name: '',
        stateProvinceID: 0,
        countryID: 0,
        description: null,
        authority: null,
        verificationWebsiteUrl: null,
        howToGetLicensedUrl: null,
        optionGroup: null,
        createdDate: null, // Autofilled by server
        updatedDate: null, // Autofilled by server
    }, values);
    
    this.model.defID(['licenseCertificationID']);
}

module.exports = LicenseCertification;

},{"./Model":123}],118:[function(require,module,exports){
/** ListViewItem model.

    Describes a generic item of a
    ListView component.
 **/
'use strict';

var Model = require('./Model');

function ListViewItem(values) {
    
    Model(this);

    this.model.defProperties({
        markerLine1: null,
        markerLine2: null,
        markerIcon: null,
        
        contentLine1: '',
        contentLine2: null,
        link: '#',

        actionIcon: null,
        actionText: null,
        
        classNames: ''

    }, values);
}

module.exports = ListViewItem;

},{"./Model":123}],119:[function(require,module,exports){
/** MailFolder model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    _ = require('lodash');

function MailFolder(values) {

    Model(this);

    this.model.defProperties({
        messages: [],
        topNumber: 10
    }, values);
    
    this.top = ko.pureComputed(function top(num) {
        if (num) this.topNumber(num);
        return _.first(this.messages(), this.topNumber());
    }, this);
}

module.exports = MailFolder;

},{"./Model":123,"knockout":false,"lodash":false}],120:[function(require,module,exports){
/** MarketplaceProfile model **/
'use strict';

var Model = require('./Model'),
    ko = require('knockout');

function MarketplaceProfile(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        
        publicBio: '',
        serviceProfessionalProfileUrlSlug: '',
        // This is a server-side computed variable (read-only for the user) for a Loconomics address
        // created using the serviceProfessionalProfileUrlSlug if any or the fallback system URL.
        serviceProfessionalProfileUrl: '',
        // Specify an external website of the serviceProfessional.
        serviceProfessionalWebsiteUrl: '',
        // Server-side generated code that allows to identificate special booking requests
        // from the book-me-now button. The server ensures that there is ever a value on this for serviceProfessionals.
        bookCode: '',

        createdDate: null,
        updatedDate: null
    }, values);
    
    // Special observable: photoUrl, is a well know URL, no saved on database, based on the userID
    // and the channel being in use
    this.photoUrl = ko.pureComputed(function() {
        var $ = require('jquery');
        var siteUrl = $('html').attr('data-site-url') || 'https://loconomics.com';
        return siteUrl + '/en-US/Profile/Photo/' + this.userID();
    }, this);
}

module.exports = MarketplaceProfile;

},{"./Model":123,"knockout":false}],121:[function(require,module,exports){
/** Message model.

    Describes a message that belongs to a Thread.
    A message could be of different types,
    as inquiries, bookings, booking requests.
 **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');

function Message(values) {
    
    Model(this);

    this.model.defProperties({
        messageID: 0,
        threadID: 0,
        sentByUserID: null,
        typeID: null,
        auxT: null,
        auxID: null,
        bodyText: '',
        
        createdDate: null,
        updatedDate: null
    }, values);
    
    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        return moment(this.createdDate()).locale('en-US-LC').calendar();
    }, this);
    
    this.displayedTime = ko.pureComputed(function() {
        return moment(this.createdDate()).locale('en-US-LC').format('LT');
    }, this);
}

module.exports = Message;

},{"./Model":123,"knockout":false,"moment":false}],122:[function(require,module,exports){
/** Message model.

    Describes a message from a MailFolder.
    A message could be of different types,
    as inquiries, bookings, booking requests.
 **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    moment = require('moment');

function MessageView(values, app) {
    
    Model(this);

    this.model.defProperties({
        id: 0,
        createdDate: null,
        updatedDate: null,
        
        subject: '',
        content: null,
        link: '#',
        
        tag: '',
        classNames: '',
        
        sourceThread: null,
        sourceMessage: null

    }, values);
    
    // Smart visualization of date and time
    this.displayedDate = ko.pureComputed(function() {
        
        return moment(this.createdDate()).locale('en-US-LC').calendar();
        
    }, this);
    
    this.displayedTime = ko.pureComputed(function() {
        
        return moment(this.createdDate()).locale('en-US-LC').format('LT');

    }, this);
    
    this.quickDateTime = ko.pureComputed(function() {
        var date = this.createdDate();

        var m = moment(date).locale('en-US-LC'),
            t = moment().startOf('day');

        if (m.isAfter(t)) {
            return m.format('LT');
        }
        else {
            return m.fromNow();
        }
    }, this);
    
    this.client = ko.computed(function() {
        var s = this.sourceMessage();
        if (!s || !app) return null;

        var cid = s.sentByUserID();
        if (cid) {
            if (cid === app.model.userProfile.data.userID())
                return app.model.userProfile.data;
            else
                return app.model.clients.getObservableItem(cid, true)();
        }
        return null;
    }, this)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
}

module.exports = MessageView;

/**
    Creates a MessageView instance from a Thread instance.
    It's better to have almost one message in the thread (the latest
    one first, or the one to highlight) to build a
    more detailed MessageView
**/
MessageView.fromThread = function(app, thread) {
    
    var msg = thread.messages();
    msg = msg && msg[0] || null;
    
    // TODO: more different tag/classes depending on booking state as per design
    // NOTE: That requires to load the booking or request by auxID and wait for it
    var tag, classNames;
    if (msg.auxT() === 'Booking') {
        tag = 'Booking';
        classNames = 'text-success';
    }
    // TODO For state==request must be
    /*{
        tag = 'Booking request';
        classNames = 'text-warning';
    }*/
    
    return new MessageView({
        sourceThread: thread,
        sourceMessage: msg,
        id: thread.threadID(),
        createdDate: thread.createdDate(),
        updatedDate: thread.updatedDate(),
        subject: thread.subject(),
        content: msg && msg.bodyText() || '',
        link: '#!/conversation/' + thread.threadID(),
        tag: tag,
        classNames: classNames
    }, app);
};

},{"./Model":123,"knockout":false,"moment":false}],123:[function(require,module,exports){
/**
    Model class to help build models.

    Is not exactly an 'OOP base' class, but provides
    utilities to models and a model definition object
    when executed in their constructors as:
    
    '''
    function MyModel() {
        Model(this);
        // Now, there is a this.model property with
        // an instance of the Model class, with 
        // utilities and model settings.
    }
    '''
    
    That auto creation of 'model' property can be avoided
    when using the object instantiation syntax ('new' keyword):
    
    '''
    var model = new Model(obj);
    // There is no a 'obj.model' property, can be
    // assigned to whatever property or nothing.
    '''
**/
'use strict';
var ko = require('knockout');
ko.mapping = require('knockout.mapping');
var $ = require('jquery');
var clone = function(obj) { return $.extend(true, {}, obj); };
var cloneValue = function(val, deepCopy) {
    /*jshint maxcomplexity: 10*/
    if (typeof(val) === 'object') {
        // A Date object is a special case: even being
        // an object, treat as a basic type, being copied as
        // a new instance independent of the deepCopy option
        if (val instanceof Date) {
            // A date clone
            return new Date(val);
        }
        else if (deepCopy === true) {
            if (val instanceof Array) {
                return val.map(function(item) {
                    return cloneValue(item, true);
                });
            }
            else if (val === null) {
                return null;
            }
            else if (val && val.model instanceof Model) {
                // A model copy
                return val.model.toPlainObject(deepCopy);
            }
            else {
                // Plain 'standard' object clone
                return clone(val);
            }
        }
        else if (deepCopy === false) {
            // Shallow copy
            return val;
        }
        // On else, left undefined, no references, no clones,
        // discarded value
        return undefined;
    }
    else {
        // A basic type value is already copied/cloned by javascript
        // on every assignment
        return val;
    }
};

function Model(modelObject) {
    
    if (!(this instanceof Model)) {
        // Executed as a function, it must create
        // a Model instance
        var model = new Model(modelObject);
        // and register automatically as part
        // of the modelObject in 'model' property
        modelObject.model = model;
        
        // Returns the instance
        return model;
    }
 
    // It includes a reference to the object
    this.modelObject = modelObject;
    // It maintains a list of properties and fields
    this.propertiesList = [];
    this.fieldsList = [];
    this.propertiesDefs = {};
    this.fieldsDefs = {};
    // It allow setting the 'ko.mapping.fromJS' mapping options
    // to control conversions from plain JS objects when 
    // 'updateWith'.
    this.mappingOptions = {};
    
    // Timestamp with the date of last change
    // in the data (automatically updated when changes
    // happens on properties; fields or any other member
    // added to the model cannot be observed for changes,
    // requiring manual updating with a 'new Date()', but is
    // better to use properties.
    // Its rated to zero just to avoid that consecutive
    // synchronous changes emit lot of notifications, specially
    // with bulk tasks like 'updateWith'.
    this.dataTimestamp = ko.observable(new Date()).extend({ rateLimit: 0 });
}

module.exports = Model;

/**
    Internal utility to map a value given its property/field
    definition
**/
function prepareValueByDef(val, def) {
    if (def.isArray && 
        !Array.isArray(val)) {
        if (typeof(val) !== 'undefined')
            val = [val];
        else
            val = [];
    }
    if (def && def.Model) {
        if (Array.isArray(val)) {
            val = val.map(function(item) {
                if (item instanceof def.Model ||
                    item === null ||
                    typeof(item) === 'undefined') {
                    // 'as is'
                    return item;
                }
                else {
                    return new def.Model(item);
                }
            });
        }
        else {
            if (!(val instanceof def.Model) &&
                val !== null &&
                typeof(val) !== 'undefined') {
                val = new def.Model(val);
            }
        }
    }
    return val;
}

function createDef(givenVal, initialVal) {
    
    var def,
        isModel = givenVal && givenVal.model instanceof Model,
        isArray = Array.isArray(givenVal),
        isObject = typeof(givenVal) === 'object' && !(givenVal instanceof Date);

    if (givenVal !== null && !isModel && isObject && !isArray) {
        def = givenVal;
    }
    else {
        def = {
            defaultValue: givenVal,
            isArray: isArray
        };
        if (isModel)
            def.Model = givenVal.constructor;
    }
    
    initialVal = typeof(initialVal) === 'undefined' ? def.defaultValue : initialVal;
    def.initialValue = prepareValueByDef(initialVal, def);
    
    return def;
}

/**
    Define observable properties using the given
    properties object definition that includes de default values,
    and some optional initialValues (normally that is provided externally
    as a parameter to the model constructor, while default values are
    set in the constructor).
    That properties become members of the modelObject, simplifying 
    model definitions.
    
    It uses Knockout.observable and observableArray, so properties
    are funtions that reads the value when no arguments or sets when
    one argument is passed of.
**/
Model.prototype.defProperties = function defProperties(properties, initialValues) {

    initialValues = initialValues || {};

    var modelObject = this.modelObject,
        propertiesList = this.propertiesList,
        defs = this.propertiesDefs,
        dataTimestamp = this.dataTimestamp;

    Object.keys(properties).forEach(function(key) {
        
        // Create and register definition
        var def = createDef(properties[key], initialValues[key]);
        defs[key] = def;

        // Create the observable property
        modelObject[key] = Array.isArray(def.initialValue) ?
            ko.observableArray(def.initialValue) :
            ko.observable(def.initialValue);

        // Remember default
        modelObject[key]._defaultValue = def.defaultValue;
        // remember initial
        modelObject[key]._initialValue = def.initialValue;    
        
        // Add subscriber to update the timestamp on changes
        modelObject[key].subscribe(function() {
            dataTimestamp(new Date());
        });
        
        // Add to the internal registry
        propertiesList.push(key);
    });
    
    // Update timestamp after the bulk creation.
    dataTimestamp(new Date());
};

/**
    Define fields as plain members of the modelObject using
    the fields object definition that includes default values,
    and some optional initialValues.
    
    Its like defProperties, but for plain js values rather than observables.
**/
Model.prototype.defFields = function defFields(fields, initialValues) {

    initialValues = initialValues || {};

    var modelObject = this.modelObject,
        defs = this.fieldsDefs,
        fieldsList = this.fieldsList;

    Object.keys(fields).each(function(key) {
        
        // Create and register definition
        var def = createDef(fields[key], initialValues[key]);
        defs[key] = def;
        
        // Create field with initial value
        modelObject[key] = def.initialValue;
        
        // Add to the internal registry
        fieldsList.push(key);
    });
};

/**
    Store the list of fields that make the ID/primary key
    and create an alias 'id' property that returns the
    value for the ID field or array of values when multiple
    fields.
**/
Model.prototype.defID = function defID(fieldsNames) {
    
    // Store the list
    this.idFieldsNames = fieldsNames;
    
    // Define ID observable
    if (fieldsNames.length === 1) {
        // Returns single value
        var field = fieldsNames[0];
        this.modelObject.id = ko.pureComputed(function() {
            return this[field]();
        }, this.modelObject);
    }
    else {
        this.modelObject.id = ko.pureComputed(function() {
            return fieldsNames.map(function(fieldName) {
                return this[fieldName]();
            }.bind(this));
        }, this.modelObject);
    }
};

/**
    Allows to register a property (previously defined) as 
    the model timestamp, so gets updated on any data change
    (keep in sync with the internal dataTimestamp).
**/
Model.prototype.regTimestamp = function regTimestampProperty(propertyName) {

    var prop = this.modelObject[propertyName];
    if (typeof(prop) !== 'function') {
        throw new Error('There is no observable property with name [' + 
                        propertyName + 
                        '] to register as timestamp.'
       );
    }
    // Add subscriber on internal timestamp to keep
    // the property updated
    this.dataTimestamp.subscribe(function(timestamp) {
        prop(timestamp);
    });
};

/**
    Returns a plain object with the properties and fields
    of the model object, just values.
    
    @param deepCopy:bool If left undefined, do not copy objects in
    values and not references. If false, do a shallow copy, setting
    up references in the result. If true, to a deep copy of all objects.
**/
Model.prototype.toPlainObject = function toPlainObject(deepCopy) {

    var plain = {},
        modelObj = this.modelObject;

    function setValue(property, val) {
        var clonedValue = cloneValue(val, deepCopy);
        if (typeof(clonedValue) !== 'undefined') {
            plain[property] = clonedValue;
        }
    }

    this.propertiesList.forEach(function(property) {
        // Properties are observables, so functions without params:
        var val = modelObj[property]();

        setValue(property, val);
    });

    this.fieldsList.forEach(function(field) {
        // Fields are just plain object members for values, just copy:
        var val = modelObj[field];

        setValue(field, val);
    });

    return plain;
};

Model.prototype.updateWith = function updateWith(data, deepCopy) {
    
    // We need a plain object for 'fromJS'.
    // If is a model, extract their properties and fields from
    // the observables (fromJS), so we not get computed
    // or functions, just registered properties and fields
    var timestamp = null;
    if (data && data.model instanceof Model) {

        // We need to set the same timestamp, so
        // remember for after the fromJS
        timestamp = data.model.dataTimestamp();
        
        // Replace data with a plain copy of itself
        data = data.model.toPlainObject(deepCopy);
    }

    var target = this.modelObject,
        defs = this.propertiesDefs;
    this.propertiesList.forEach(function(property) {
        var val = data[property],
            def = defs[property];
        if (typeof(val) !== 'undefined') {
            target[property](prepareValueByDef(val, def));
        }
    });

    defs = this.fieldsDefs;
    this.fieldsList.forEach(function(field) {
        var val = data[field],
            def = defs[field];
        if (typeof(val) !== 'undefined') {
            target[field] = prepareValueByDef(val, def);
        }
    });

    // Same timestamp if any
    if (timestamp)
        this.modelObject.model.dataTimestamp(timestamp);
};

/**
    Given a plain object in a accepted import structure
    (never a Model instance), it maps
    the data to the object following a set of mapping options
    of ko.mapping.
    If the data is a representation of the model by 'toPlainObject'
    then use 'updateWith' better.
    
    TODO: Review, not used still, no sure if really useful to depend
    on ko.mapping and this.
**/
Model.prototype.mapData = function mapData(data, optionalMapping) {
    ko.mapping.fromJS(data, optionalMapping || this.mappingOptions, this.modelObject);
};

Model.prototype.clone = function clone(data, deepCopy) {
    // Get a plain object with the object data
    var plain = this.toPlainObject(deepCopy);
    // Create a new model instance, using the source plain object
    // as initial values
    var cloned = new this.modelObject.constructor(plain);
    if (data) {
        // Update the cloned with the provided plain data used
        // to replace values on the cloned one, for quick one-step creation
        // of derived objects.
        cloned.model.updateWith(data);
    }
    else {
        // Since there is no initial differential data, ensure the
        // same timestamp since the clone is still identical to the source
        cloned.model.dataTimestamp(this.modelObject.model.dataTimestamp());
    }
    // Cloned model ready:
    return cloned;
};

/**
    Updates the dataTimestamp to the current unique datetime,
    so the model appear as touched/updated, even if not data change.
    Useful sometimes to make a difference from a cloned instance
    so appear different.
    NOTE: the datetime set is not exactly the current one, is the current
    number of milliseconds plus one,
    to ensure that the timestamp is different on edge cases where this
    method is called just after a creation or clonation, because the way
    javascript works and the limited milliseconds precision of the Date object
    there is a chance that the 'touched' date will be the same as before,
    thats avoided with this simple trick, so remains 'unique' in the current execution.
**/
Model.prototype.touch = function touch() {
    // We use the function way to get milliseconds, add 1 and create instance
    this.dataTimestamp(new Date(Date() + 1));
};

/**
    Replaces all the properties and fields data in the model object
    with the default ones of the constructor, plus optional new preset data.
**/
Model.prototype.reset = function reset(presets) {
    
    var newInstance = new this.modelObject.constructor(presets);

    this.updateWith(newInstance, true);
};

},{"knockout":false,"knockout.mapping":false}],124:[function(require,module,exports){
/** PerformanceSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    ListViewItem = require('./ListViewItem'),
    moment = require('moment'),
    numeral = require('numeral');

function PerformanceSummary(values) {

    Model(this);

    values = values || {};
    
    // TODO: define earnings and timeBooking as properties with def.Model?

    this.earnings = new Earnings(values.earnings);
    
    var earningsLine = new ListViewItem();
    earningsLine.markerLine1 = ko.computed(function() {
        var num = numeral(this.currentAmount()).format('$0,0');
        return num;
    }, this.earnings);
    earningsLine.contentLine1 = ko.computed(function() {
        return this.currentConcept();
    }, this.earnings);
    earningsLine.markerLine2 = ko.computed(function() {
        var num = numeral(this.nextAmount()).format('$0,0');
        return num;
    }, this.earnings);
    earningsLine.contentLine2 = ko.computed(function() {
        return this.nextConcept();
    }, this.earnings);
    

    this.timeBooked = new TimeBooked(values.timeBooked);

    var timeBookedLine = new ListViewItem();
    timeBookedLine.markerLine1 = ko.computed(function() {
        var num = numeral(this.percent()).format('0%');
        return num;
    }, this.timeBooked);
    timeBookedLine.contentLine1 = ko.computed(function() {
        return this.concept();
    }, this.timeBooked);
    
    
    this.items = ko.pureComputed(function() {
        var items = [];
        
        items.push(earningsLine);
        items.push(timeBookedLine);

        return items;
    }, this);
}

module.exports = PerformanceSummary;

function Earnings(values) {

    Model(this);
    
    this.model.defProperties({
    
         currentAmount: 0,
         currentConceptTemplate: 'already paid this month',
         nextAmount: 0,
         nextConceptTemplate: 'projected {month} earnings'

    }, values);
    
    this.currentConcept = ko.pureComputed(function() {

        var month = moment().format('MMMM');
        return this.currentConceptTemplate().replace(/\{month\}/, month);

    }, this);

    this.nextConcept = ko.pureComputed(function() {

        var month = moment().add(1, 'month').format('MMMM');
        return this.nextConceptTemplate().replace(/\{month\}/, month);

    }, this);
}

function TimeBooked(values) {

    Model(this);
    
    this.model.defProperties({
    
        percent: 0,
        conceptTemplate: 'of available time booked in {month}'
    
    }, values);
    
    this.concept = ko.pureComputed(function() {

        var month = moment().add(1, 'month').format('MMMM');
        return this.conceptTemplate().replace(/\{month\}/, month);

    }, this);
}

},{"./ListViewItem":118,"./Model":123,"knockout":false,"moment":false,"numeral":false}],125:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model'),
    ko = require('knockout'),
    PricingSummaryDetail = require('./PricingSummaryDetail');

module.exports = function PricingSummary(values) {
    
    Model(this);

    this.model.defProperties({
        pricingSummaryID: 0,
        pricingSummaryRevision: 0,
        serviceDurationMinutes: null,
        firstSessionDurationMinutes: null,
        
        subtotalPrice: null,
        feePrice: null,
        totalPrice: null,
        pFeePrice: null,
        subtotalRefunded: null,
        feeRefunded: null,
        totalRefunded: null,
        dateRefunded: null,
        
        createdDate: null,
        updatedDate: null,
        
        details: {
            Model: PricingSummaryDetail,
            isArray: true
        }
    }, values);
    
    this.servicesSummary = ko.computed(function() {
        return this.details()
        .map(function(detail) {
            return detail.serviceName();
        }).join(', ');
    }, this)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
};

},{"./Model":123,"./PricingSummaryDetail":126,"knockout":false}],126:[function(require,module,exports){
/**
**/
'use strict';

var Model = require('./Model');

function PricingSummaryDetail(values) {
    
    Model(this);

    this.model.defProperties({
        pricingSummaryID: 0,
        pricingSummaryRevision: 0,
        serviceProfessionalServiceID: 0,
        serviceProfessionalDataInput: null,
        clientDataInput: null,
        hourlyPrice: null,
        price: null,
        serviceDurationMinutes: null,
        firstSessionDurationMinutes: null,
        serviceName: '',
        serviceDescription: null,
        numberOfSessions: 1,
        createdDate: null,
        updatedDate: null
    }, values);
}

module.exports = PricingSummaryDetail;

PricingSummaryDetail.fromServiceProfessionalService = function(service) {
    // TODO Support special hourly pricings, housekeeper, etc.
    var allSessionMinutes = service.numberOfSessions () > 0 ?
        service.serviceDurationMinutes() * service.numberOfSessions() :
        service.serviceDurationMinutes();

    return new PricingSummaryDetail({
        serviceName: service.name(),
        serviceDescription: service.description(),
        numberOfSessions: service.numberOfSessions(),
        serviceDurationMinutes: allSessionMinutes,
        firstSessionDurationMinutes: service.serviceDurationMinutes(),
        price: service.price(),
        serviceProfessionalServiceID: service.serviceProfessionalServiceID(),
        hourlyPrice: (service.priceRateUnit() || '').toUpperCase() === 'HOUR' ? service.priceRate() : null
    });
};

},{"./Model":123}],127:[function(require,module,exports){
/**
    Pricing Type model
**/
'use strict';

var Model = require('./Model');

function PricingType(values) {
    
    Model(this);
    
    this.model.defProperties({
        pricingTypeID: 0,
        singularName: '',
        pluralName: '',
        slugName: '',
        addNewLabel: null,
        serviceProfessionalDescription: null,
        // PriceCalculationType enumeration value:
        priceCalculation: null,
        isAddon: false,
        
        // Form Texts
        namePlaceHolder: null,
        suggestedName: null,
        fixedName: null,
        durationLabel: null,
        priceLabel: null,
        priceNote: null,
        firstTimeClientsOnlyLabel: null,
        descriptionPlaceHolder: null,
        priceRateQuantityLabel: null,
        priceRateUnitLabel: null,
        noPriceRateLabel: null,
        numberOfSessionsLabel: null,
        inPersonPhoneLabel: null,
        
        // Action And Validation Texts
        successOnDelete: null,
        errorOnDelete: null,
        successOnSave: null,
        errorOnSave: null,
        priceRateIsRequiredValidationError: null,
        priceRateUnitIsRequiredValidationError: null,
        
        // Help Texts
        learnMoreLabel: null,
        learnMoreText: null,
        priceRateLearnMoreLabel: null,
        priceRateLearnMoreText: null,
        noPriceRateLearnMoreLabel: null,
        noPriceRateLearnMoreText: null,
        
        // Additional configuration
        requireDuration: false,
        includeServiceAttributes: false,
        includeSpecialPromotion: false,
        
        // List Texts
        /// SummaryFormat is the default format for summaries (required),
        /// other formats are good for better detail, but depends
        /// on other options configured per type.
        /// Wildcards:
        /// {0}: duration
        /// {1}: sessions
        /// {2}: inperson/phone
        summaryFormat: null,
        summaryFormatMultipleSessions: null,
        summaryFormatNoDuration: null,
        summaryFormatMultipleSessionsNoDuration: null,
        withoutServiceAttributesClientMessage: null,
        withoutServiceAttributesServiceProfessionalMessage: null,
        firstTimeClientsOnlyListText: null,
        priceRateQuantityListLabel: null,
        priceRateUnitListLabel: null,
        noPriceRateListMessage: null,
        
        // Booking/PricingSummary Texts
        /// NameAndSummaryFormat is the default format for summaries with package name (required),
        /// other formats are good for better detail, but depends
        /// on other options configured per type.
        /// Wildcards:
        /// {0}: package name
        /// {1}: duration
        /// {2}: sessions
        /// {3}: inperson/phone
        nameAndSummaryFormat: null,
        nameAndSummaryFormatMultipleSessions: null,
        nameAndSummaryFormatNoDuration: null,
        nameAndSummaryFormatMultipleSessionsNoDuration: null,
        
        // Record maintenance
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['pricingTypeID']);
}

module.exports = PricingType;

// Enumeration:
var PriceCalculationType = {
    FixedPrice: 1,
    HourlyPrice: 2
};

PricingType.PriceCalculationType = PriceCalculationType;

},{"./Model":123}],128:[function(require,module,exports){
/**
    PrivacySettings model
**/
'use strict';

var Model = require('./Model');

function PrivacySettings(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        smsBookingCommunication: false,
        phoneBookingCommunication: false,
        loconomicsCommunityCommunication: false,
        loconomicsDbmCampaigns: false,
        profileSeoPermission: false,
        loconomicsMarketingCampaigns: false,
        coBrandedPartnerPermissions: false,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['userID']);
}

module.exports = PrivacySettings;

},{"./Model":123}],129:[function(require,module,exports){
/**
    Collection of public information from a user,
    holded on different models
    
    TODO: Some fields introduced to help the ServiceProfessionalInfo component, but may require refactor
**/
'use strict';

var Model = require('./Model'),
    PublicUserProfile = require('./PublicUserProfile'),
    PublicUserRating = require('./PublicUserRating'),
    PublicUserVerificationsSummary = require('./PublicUserVerificationsSummary'),
    PublicUserJobTitle = require('./PublicUserJobTitle'),
    ko = require('knockout');

function PublicUser(values) {
    
    Model(this);
    
    this.model.defProperties({
        profile: { Model: PublicUserProfile },
        rating: { Model: PublicUserRating },
        verificationsSummary: { Model: PublicUserVerificationsSummary },
        jobProfile: {
            Model: PublicUserJobTitle,
            isArray: true
        },
        // TODO To implement on server, REST API
        backgroundCheckPassed: null, // null, true, false
        // Utility data for ServiceProfessionalInfo
        selectedJobTitleID: null,
        isClientFavorite: false
    }, values);
    
    // Utilities for ServiceProfessionalInfo
    this.selectedJobTitle = ko.pureComputed(function() {
        var jid = this.selectedJobTitleID(),
            jp = this.jobProfile();
        if (!jid || !jp) return null;
        var found = null;
        jp.some(function(jobTitle) {
            if (jobTitle.jobTitleID() === jid) {
                found = jobTitle;
                return true;
            }
        });
        return found;
    }, this);
    
    this.backgroundCheckLabel = ko.pureComputed(function() {
        var v = this.backgroundCheckPassed();
        if (v === true) return 'OK';
        else if (v === false) return 'FAILED';
        else return '';
    }, this);
}

module.exports = PublicUser;

},{"./Model":123,"./PublicUserJobTitle":130,"./PublicUserProfile":131,"./PublicUserRating":132,"./PublicUserVerificationsSummary":134,"knockout":false}],130:[function(require,module,exports){
/**
    PublicUserJobTitle model, relationship between an user and a
    job title and the main data attached to that relation for
    public access (internal fields avoided) and additional
    useful job title info (shortcut to job title names for convenience).
    
    The model has optional properties that link
    to other model information related to a specific jobTitle
    for convenience when querying a wider set of information
    and keep it organized under this model instances.
**/
'use strict';

var Model = require('./Model'),
    PublicUserRating = require('./PublicUserRating'),
    PublicUserVerificationsSummary = require('./PublicUserVerificationsSummary');

function PublicUserJobTitle(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        jobTitleID: 0,
        intro: null,
        cancellationPolicyID: 0,
        instantBooking: false,
        jobTitleSingularName: '',
        jobTitlePluralName: '',
        
        rating: { Model: PublicUserRating },
        verificationsSummary: { Model: PublicUserVerificationsSummary },
    }, values);

    this.model.defID(['userID', 'jobTitleID']);
}

module.exports = PublicUserJobTitle;

},{"./Model":123,"./PublicUserRating":132,"./PublicUserVerificationsSummary":134}],131:[function(require,module,exports){
/**
    Public information from a user.
**/
'use strict';

var Model = require('./Model'),
    ko = require('knockout');

function PublicUserProfile(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        firstName: 0,
        lastName: 0,
        secondLastName: 0,
        businessName: 0,
        publicBio: 0,
        serviceProfessionalProfileUrlSlug: null,
        serviceProfessionalWebsiteUrl: null,
        photoUrl: null,
        email: null,
        phone: null,
        isServiceProfessional: false,
        isClient: false,
        updatedDate: null
    }, values);
    
    this.fullName = ko.pureComputed(function() {
        var nameParts = [this.firstName()];
        if (this.lastName())
            nameParts.push(this.lastName());
        if (this.secondLastName())
            nameParts.push(this.secondLastName);
        
        return nameParts.join(' ');
    }, this);
}

module.exports = PublicUserProfile;

},{"./Model":123,"knockout":false}],132:[function(require,module,exports){
/**
    Rating values for user, as user, client. service professional
    or job title specific.
**/
'use strict';

var Model = require('./Model');

function PublicUserRating(values) {
    
    Model(this);
    
    this.model.defProperties({
        rating1: 0,
        rating2: 0,
        rating3: 0,
        ratingAverage: 0,
        totalRatings: 0,
        serviceHours: 0,
        lastRatingDate: null
    }, values);
}

module.exports = PublicUserRating;

},{"./Model":123}],133:[function(require,module,exports){
/**
    Number of verifications for the user, as user, client, service professional
    or job title specific, per group of verifications
**/
'use strict';

var Model = require('./Model');

function PublicUserVerificationsGroup(values) {
    
    Model(this);
    
    this.model.defProperties({
        verificationsCount: 0,
        groupName: '',
        groupID: ''
    }, values);
}

module.exports = PublicUserVerificationsGroup;

},{"./Model":123}],134:[function(require,module,exports){
/**
    Number of verifications and grouped counts.
**/
'use strict';

var Model = require('./Model'),
    PublicUserVerificationsGroup = require('./PublicUserVerificationsGroup');

function PublicUserVerificationsSummary(values) {
    
    Model(this);
    
    this.model.defProperties({
        total: 0,
        groups: PublicUserVerificationsGroup
    }, values);
}

module.exports = PublicUserVerificationsSummary;

},{"./Model":123,"./PublicUserVerificationsGroup":133}],135:[function(require,module,exports){
/**
    SchedulingPreferences model.
 **/
'use strict';

var Model = require('./Model');

function SchedulingPreferences(values) {
    
    Model(this);

    this.model.defProperties({
        advanceTime: 24, // Hours
        betweenTime: 0, // Hours
        incrementsSizeInMinutes: 15
    }, values);
}

module.exports = SchedulingPreferences;

},{"./Model":123}],136:[function(require,module,exports){
/** ServiceAttribute model.
 **/
'use strict';

var Model = require('./Model');

function ServiceAttribute(values) {
    
    Model(this);

    this.model.defProperties({
        serviceAttributeID: 0,
        name: '',
        description: null
        //createdDate: null,
        //updatedDate: null
    }, values);
}

module.exports = ServiceAttribute;

},{"./Model":123}],137:[function(require,module,exports){
/** ServiceAttributeCategory model.
 **/
'use strict';

var Model = require('./Model'),
    ServiceAttribute = require('./ServiceAttribute');

function ServiceAttributeCategory(values) {
    
    Model(this);

    this.model.defProperties({
        serviceAttributeCategoryID: 0,
        name: '',
        description: null,
        requiredInput: false,
        eligibleForPackages: false,
        serviceAttributes: {
            isArray: true,
            Model: ServiceAttribute
        }
        //createdDate: null,
        //updatedDate: null
    }, values);
}

module.exports = ServiceAttributeCategory;

},{"./Model":123,"./ServiceAttribute":136}],138:[function(require,module,exports){
/**
    ServiceProfessionalService model: manages an individual
    service from the user and a specific job title.
**/
'use strict';

var Model = require('./Model'),
    ko = require('knockout'),
    numeral = require('numeral');

function ServiceProfessionalService(values) {
    
    Model(this);
    
    this.model.defProperties({
        serviceProfessionalServiceID: 0,
        serviceProfessionalUserID: 0,
        jobTitleID: 0,
        pricingTypeID: 0,
        name: '',
        description: null,
        price: null,
        serviceDurationMinutes: null,
        firstTimeClientsOnly: false,
        numberOfSessions: 1,
        priceRate: null,
        priceRateUnit: 'hour',
        // Special property, not in source data just only an explicit
        // way to avoid validation of priceRate if not explicit value set
        noPriceRate: false,
        isPhone: false,
        // Array of integers, IDs of serviceAttributes
        serviceAttributes: [],
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['serviceProfessionalServiceID']);
    
    // One way effect: set priceRate to null when setting on noPriceRate
    // But nothing on off and no other relations to avoid bad side effects.
    this.noPriceRate.subscribe(function(enabled) {
        if (enabled === true) {
            this.priceRate(null);
        }
    }, this);
    
    /**
        Ask for a refresh of the noPriceRate, that must be 'true' if the record exists and
        has no priceRate (to remember the previous value set by the user about noPriceRate).
        It ensure that the internal timestamp keep untouched.
        Cannot be automatic, so need to be called manually after a data load that does not
        want to reflect this change as a data change.
    **/
    this.refreshNoPriceRate = function refreshNoPriceRate() {
        // Not To State Price Rate: if is a saved pricing, mark the noPriceRate if price rate is
        // null or 0; cannot be done with a subscription on priceRate changes because will have
        // the bad side effect of auto mark noPriceRate on setting 0 on priceRate, breaking the
        // explicit purpose of the noPriceRate checkbox:
        if (this.serviceProfessionalServiceID() && (this.priceRate() |0) <= 0) {
            var ts = this.model.dataTimestamp();
            this.noPriceRate(true);
            // Set again timestamp so the model appear as untouched.
            this.model.dataTimestamp(ts);
        }
    };

    // Alternative edition of the serviceDurationMinutes fields:
    // Splited as hours and minutes
    var is = require('is_js');
    this.durationHoursPart = ko.pureComputed({
        read: function() {
            var fullMinutes = this.serviceDurationMinutes();
            
            if (is.not.number(fullMinutes))
                return null;

            return ((fullMinutes|0) / 60) |0;
        },
        write: function(hours) {
            var minutes = this.durationMinutesPart() |0;
            // Value comes from text
            hours = parseInt(hours, 10);
            if (is.not.number(hours))
                this.serviceDurationMinutes(null);
            else
                this.serviceDurationMinutes((hours|0) * 60 + minutes);
        },
        owner: this
    });
    this.durationMinutesPart = ko.pureComputed({
        read: function() {
            var fullMinutes = this.serviceDurationMinutes();

            if (is.not.number(fullMinutes))
                return null;

            return (fullMinutes|0) % 60;
        },
        write: function(minutes) {
            var hours = this.durationHoursPart() |0;
            // Value comes from text
            minutes = parseInt(minutes, 10);
            if (is.not.number(minutes))
                this.serviceDurationMinutes(null);
            else
                this.serviceDurationMinutes(hours * 60 + (minutes|0));
        },
        owner: this
    });
    
    
    /// Visual representation of several fields
    
    this.durationText = ko.pureComputed(function() {
        var minutes = this.serviceDurationMinutes() || 0;
        // TODO: l10n
        return minutes ? numeral(minutes).format('0,0') + ' minutes' : '';
    }, this);
    
    this.sessionsAndDuration = ko.pureComputed(function() {
        var sessions = this.numberOfSessions(),
            dur = this.durationText();
        if (sessions > 1)
            // TODO: l10n
            return sessions + ' sessions, ' + dur;
        else
            return dur;
    }, this);

    this.displayedPrice = ko.pureComputed(function() {
        var price = this.price(),
            rate = this.priceRate(),
            unit = this.priceRateUnit(),
            result = price || rate;
        // Formatting
        result = numeral(result).format('$0,0');
        // If is not price but rate, add unit
        if (!price && rate && unit) {
            result += '/' + unit;
        }
        return result;
    }, this);
}

module.exports = ServiceProfessionalService;

},{"./Model":123,"is_js":false,"knockout":false,"numeral":false}],139:[function(require,module,exports){
/**
    SimplifiedWeeklySchedule model.
    
    Its 'simplified' because it provides an API
    for simple time range per week day,
    a pair of from-to times.
    Good for current simple UI.
    
    The original weekly schedule defines the schedule
    in 15 minutes slots, so multiple time ranges can
    exists per week day, just marking each slot
    as available or unavailable. The AppModel
    will fill this model instances properly making
    any conversion from/to the source data.
 **/
'use strict';

var ko = require('knockout'),
    moment = require('moment-timezone'),
    Model = require('./Model'),
    WeekDaySchedule = require('./WeekDaySchedule');

/**
    It attemps to locate local/system timezone,
    getting the first IANA tzid that matches 
    local setup.
**/
function detectLocalTimezone() {
    var year = new Date().getFullYear(),
        winter = new Date(year, 1, 1),
        winOff = winter.getTimezoneOffset(),
        summer = new Date(year, 6, 1),
        sumOff = summer.getTimezoneOffset(),
        found = null;

    moment.tz.names().some(function(tz) {
        var zone = moment.tz.zone(tz);
        if (zone.offset(winter) === winOff &&
            zone.offset(summer) === sumOff) {
           found = zone;
           return true;
        }
    });

    return found;
}

/**
    Main model defining the week schedule
    per week date, or just set all days times
    as available with a single flag.
**/
function SimplifiedWeeklySchedule(values) {
    
    Model(this);

    this.model.defProperties({
        sunday: new WeekDaySchedule(),
        monday: new WeekDaySchedule(),
        tuesday: new WeekDaySchedule(),
        wednesday: new WeekDaySchedule(),
        thursday: new WeekDaySchedule(),
        friday: new WeekDaySchedule(),
        saturday: new WeekDaySchedule(),
        isAllTime: false,
        timeZone: ''
    }, values);
    
    // Index access
    this.weekDays = [
        this.sunday,
        this.monday,
        this.tuesday,
        this.wednesday,
        this.thursday,
        this.friday,
        this.saturday
    ];
    
    this.timeZoneDisplayName = ko.computed(function() {
        var tzid = this.timeZone(),
            tz = moment.tz(tzid),
            name = tz.tz();
        
        // !moment.tz.zoneExists, just check the name is enough
        if (!name) {
            var localtz = detectLocalTimezone();
            if (localtz)
                tz = moment.tz(localtz.name);
            if (tz)
                name = tz.tz();
            if (name)
                setTimeout(function() {
                    this.timeZone(name);
                }.bind(this), 1);
        }

        if (name)
            return name; // + ' (' + tz.zoneAbbr() + ')';
        else
            return '';
    }, this);
}

module.exports = SimplifiedWeeklySchedule;

},{"./Model":123,"./WeekDaySchedule":150,"knockout":false,"moment-timezone":false}],140:[function(require,module,exports){
/** Thread model.

    Describes a thread of messages.
 **/
'use strict';

var Model = require('./Model'),
    Message = require('./Message');

function Thread(values) {
    
    Model(this);

    this.model.defProperties({
        threadID: 0,
        
        clientUserID: null,
        serviceProfessionalUserID: null,
        jobTitleID: null,
        statusID: null,
        subject: null,
        
        messages: {
            isArray: true,
            Model: Message
        },
        
        createdDate: null,
        updatedDate: null        
    }, values);
}

module.exports = Thread;

},{"./Message":121,"./Model":123}],141:[function(require,module,exports){
/** UpcomingBookingsSummary model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model'),
    BookingSummary = require('./BookingSummary');

function UpcomingBookingsSummary() {

    Model(this);
    
    // TODO: define today, tomorrow and nextWeek as
    // properties with default Model?
    // Review how update happens on home/dashboard, it can helps
    // to simplify that

    this.today = new BookingSummary({
        concept: 'more today',
        timeFormat: ' [ending @] h:mma'
    });
    this.tomorrow = new BookingSummary({
        concept: 'tomorrow',
        timeFormat: ' [starting @] h:mma'
    });
    this.nextWeek = new BookingSummary({
        concept: 'next week',
        timeFormat: null
    });
    
    this.items = ko.pureComputed(function() {
        var items = [];
        
        //if (this.today.quantity())
        items.push(this.today);
        //if (this.tomorrow.quantity())
        items.push(this.tomorrow);
        //if (this.nextWeek.quantity())
        items.push(this.nextWeek);

        return items;
    }, this);
    
}

module.exports = UpcomingBookingsSummary;

},{"./BookingSummary":105,"./Model":123,"knockout":false}],142:[function(require,module,exports){
/** User model **/
'use strict';

var ko = require('knockout'),
    Model = require('./Model');

// Enum UserType
var UserType = {
    none: 0,
    anonymous: 1,
    client: 2,
    serviceProfessional: 4,
    // All Members (member-only:8) are service professionals too: 4+8
    member: 12,
    admin: 16,
    // All users except anonymous and system:
    loggedUser: 30,
    // All users except system,
    user: 31,
    system: 32
};

function User(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        email: '',
        
        firstName: '',
        lastName: '',
        secondLastName: '',
        businessName: '',
        
        alternativeEmail: '',
        phone: '',
        canReceiveSms: '',
        birthMonthDay: null,
        birthMonth: null,
        
        isServiceProfessional: false,
        isClient: false,
        isMember: false,
        isAdmin: false,
        
        photoUrl: null,

        onboardingStep: null,
        accountStatusID: 0,
        createdDate: null,
        updatedDate: null
    }, values);

    this.fullName = ko.pureComputed(function() {
        var nameParts = [this.firstName()];
        if (this.lastName())
            nameParts.push(this.lastName());
        if (this.secondLastName())
            nameParts.push(this.secondLastName);
        
        return nameParts.join(' ');
    }, this);
    
    this.birthDay = ko.pureComputed(function() {
        if (this.birthMonthDay() &&
            this.birthMonth()) {
            
            // TODO i10n
            return this.birthMonth() + '/' + this.birthMonthDay();
        }
        else {
            return null;
        }
    }, this);
    
    this.userType = ko.pureComputed({
        read: function() {
            var c = this.isClient(),
                p = this.isServiceProfessional(),
                a = this.isAdmin();
            
            var userType = 0;
            
            if (this.isAnonymous())
                userType = userType | UserType.anonymous;
            if (c)
                userType = userType | UserType.client;
            if (p)
                userType = userType | UserType.serviceProfessional;
            if (a)
                userType = userType | UserType.admin;
            
            return userType;
        },
        /* NOTE: Not required for now:
        write: function(v) {
        },*/
        owner: this
    });
    
    this.isAnonymous = ko.pureComputed(function(){
        return this.userID() < 1;
    }, this);
    
    /**
        It matches a UserType from the enumeration?
    **/
    this.isUserType = function isUserType(type) {
        return (this.userType() & type);
    }.bind(this);
}

module.exports = User;

User.UserType = UserType;

/* Creatint an anonymous user with some pressets */
User.newAnonymous = function newAnonymous() {
    return new User({
        userID: 0,
        email: '',
        firstName: '',
        onboardingStep: null
    });
};

},{"./Model":123,"knockout":false}],143:[function(require,module,exports){
/**
    Represents an User Education record
**/
'use strict';

var Model = require('./Model');

function UserEducation(values) {
    Model(this);
    
    this.model.defProperties({
        educationID: 0,
        userID: 0,
        institutionName: '',
        degreeCertificate: '',
        fieldOfStudy: '',
        fromYearAttended: null,
        toYearAttended: null
    }, values);
}

module.exports = UserEducation;

},{"./Model":123}],144:[function(require,module,exports){
/**
    UserJobTitle model, relationship between an user and a
    job title and the main data attached to that relation.
**/
'use strict';

var Model = require('./Model');

function UserJobTitle(values) {
    
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        jobTitleID: 0,
        intro: null,
        statusID: 0,
        cancellationPolicyID: 0,
        instantBooking: false,
        createdDate: null,
        updatedDate: null
    }, values);
    
    this.model.defID(['userID', 'jobTitleID']);
}

module.exports = UserJobTitle;

// Public Enumeration for the 'statusID' property:
UserJobTitle.status = {
    // Profile is complete and public
    on: 1,
    // Profile cannot be On/public because is incomplete:
    incomplete: 2,
    // User choose to disable (it's supposed to be complete, but disabled by user and will double check before activation)
    off: 3
};

},{"./Model":123}],145:[function(require,module,exports){
/** UserJobTitleServiceAttributes model.
 **/
'use strict';

var Model = require('./Model'),
    ko = require('knockout');

// Needed utility to extend with methods the observable
// properties that holds a plain object as dictionary
// of attributes per category.
// It's useful for attIDs and attNames.
function extendValuesByCategory(obs) {
    // Alias to notify changes, if change a source plain value is needed, this must
    // be manually called to ensure updates.
    obs.notifyChanges = obs.valueHasMutated;

    obs.serviceAttributeCategoriesIDs = ko.pureComputed(function() {
        return Object.keys(obs() || {}).filter(function(key) {
            return (key |0) === 0;
        });
    });
    
    // Indexed list of observers to detect changes in categories values, allowing
    // the cat-atts observers to recompute only on changes on its categories, being more
    // optimal.
    var catsObs = {};

    // Gets an observable for array that keeps in sync with source changes
    // DO NOT PUSH/REMOVE data to the resulting array, use the obs.push and obs.remove methods for data changes
    obs.getServiceCategoryAttributes = function(catID) {
        var catObs = catsObs[catID] = catsObs[catID] || ko.observable({});
        return ko.computed(function() {
            // Recompute when source value changed for the cateogry
            var base = obs.peek();
            // access notifier observable so this recomputes on changes detected:
            catObs();
            // Get category data:
            return base && base[catID] || [];
        });
    };
    
    // On a real bulk change, trigger al cats observers
    var prevValue = obs();
    obs.subscribe(function(v) {
        // really changed?
        if (v !== prevValue) {
            prevValue = v;
            Object.keys(catsObs).forEach(function(a) {
                // notify changes
                a.valueHasMutated && a.valueHasMutated();
            });
        }
    });

    obs.push = function(catID, attID) {
        var v = obs();
        if (!v) {
            // No value at all! Create object, and first category with this first attribute
            v = {};
            v[catID] = [attID];
            obs(v);
            if (catsObs[catID]) catsObs[catID].valueHasMutated();
        }
        else {
            var cat = v[catID] || (v[catID] = []);
            // Double check it does not exists already
            if (cat.indexOf(attID) === -1) {
                cat.push(attID);
                // changes on all the data
                obs.notifyChanges();
                // changes on this category
                if (catsObs[catID]) catsObs[catID].valueHasMutated();
            }
        }
    };

    obs.remove = function(catID, attID) {
        var v = obs(),
            cat = v && v[catID];
        if (cat) {
            var i = cat.indexOf(attID);
            if (i > -1) {
                cat.splice(i, 1);
                obs.notifyChanges();
                if (catsObs[catID]) catsObs[catID].valueHasMutated();
            }
        }
    };
}

// Public Model
function UserJobTitleServiceAttributes(values) {
    
    Model(this);

    this.model.defProperties({
        userID: 0,
        jobTitleID: 0,
        serviceAttributes: {},
        proposedServiceAttributes: {},
        experienceLevelID: false,
        languageID: 0,
        countryID: 0
        //createdDate: null,
        //updatedDate: null
    }, values);
    
    extendValuesByCategory(this.serviceAttributes);
    extendValuesByCategory(this.proposedServiceAttributes);
}

module.exports = UserJobTitleServiceAttributes;

},{"./Model":123,"knockout":false}],146:[function(require,module,exports){
/** UserLicenseCertification model **/
'use strict';

var Model = require('./Model'),
    ko = require('knockout');

function UserLicenseCertification(values) {

    Model(this);
    
    this.model.defProperties({
        userID: 0,
        jobTitleID: 0,
        statusID: 0,
        licenseCertificationID: 0,
        licenseCertificationUrl: '',
        licenseCertificationNumber: 0,
        licenseCertificationStatus: 0,
        expirationDate: null,
        issueDate: null,
        countryID: 0,
        stateProvinceID: 0,
        countyID: 0,
        city: '',
        firstName: null,
        lastName: null,
        middleInitial: null,
        secondLastName: null,
        businessName: null,
        actions: null,
        comments: null,
        verifiedBy: null,
        lastVerifiedDate: null,
        createdDate: null, // Autofilled by server
        updatedDate: null, // Autofilled by server
    }, values);
    
    this.model.defID(['userID', 'jobTitleID', 'licenseCertificationID']);
    
    this.countyName = ko.pureComputed(function() {
        // TODO Implement look-up of counties, a hardly cached version must exists ever
        return 'Alameda';
    }, this);
    this.stateProvinceName = ko.pureComputed(function() {
        // TODO Implement look-up, a hardly cached version must exists ever
        return 'California';
    }, this);
    this.stateProvinceCode = ko.pureComputed(function() {
        // TODO Implement look-up, a hardly cached version must exists ever
        return 'CA';
    }, this);
}

module.exports = UserLicenseCertification;

},{"./Model":123,"knockout":false}],147:[function(require,module,exports){
/**
    UserVerification model
**/
'use strict';

var Model = require('./Model'),
    ko = require('knockout'),
    Verification = require('./Verification');

function UserVerification(values) {
    Model(this);
    
    this.model.defProperties({
        userID: 0,
        verificationID: 0,
        jobTitleID: 0,
        lastVerifiedDate: null,
        statusID: 0,
        verification: {
            Model: Verification
        }
    }, values);
    
    // L18N
    var statusTextsenUS = {
        'verification.status.confirmed': 'Confirmed',
        'verification.status.pending': 'Pending',
        'verification.status.revoked': 'Revoked',
        'verification.status.obsolete': 'Obsolete'
    };

    this.statusText = ko.pureComputed(function() {
        var statusName = Verification.getStatusName(this.statusID());
        return statusTextsenUS['verification.status.' + statusName];
    }, this);

    /**
        Check if verification has a given status by name
    **/
    this.isStatus = function (statusName) {
        var id = this.statusID();
        return Verification.status[statusName] === id;
    }.bind(this);
}

module.exports = UserVerification;

},{"./Model":123,"./Verification":148,"knockout":false}],148:[function(require,module,exports){
/**
    Verification Model
**/
'use strict';

var Model = require('./Model');

function Verification(values) {
    Model(this);

    this.model.defProperties({
        verificationID: 0,
        name: '',
        description: null,
        icon: null,
        summaryGroup: null
    }, values);
}

Verification.status = {
    confirmed: 1,
    pending: 2,
    revoked: 3,
    obsolete: 4
};

// TODO: Maybe as generic utility?
function enumGetName(value, enumList) {
    var found = null;
    Object.keys(enumList).some(function(k) {
        if (enumList[k] === value) {
            found = k;
            return true;
        }
    });
    return found;
}

Verification.getStatusName = function getStatusName(value) {
    return enumGetName(value, Verification.status);
};

module.exports = Verification;

},{"./Model":123}],149:[function(require,module,exports){
/**
    Enumeration of possible values for VocElementIDs, 
    used to identify sections/components when sending Feedback.
**/
'use strict';

module.exports = {
    general: 0,
    nps: 1,
    signup: 2,
    calendar: 3,
    inbox: 4,
    scheduling: 5,
    cms: 6,
    payments: 7,
    performance: 8,
    marketplaceProfile: 9,
    mobileFriendly: 10, // easy of using mobile/tablet app/web
    desktopFriendly: 11, // easy of using desktop website
    coopBenefits: 12,
    coopFee: 13,
    senseOfCommunity: 14,
    clientServiceAgents: 15,
    helpPages: 16
};

},{}],150:[function(require,module,exports){
/**
    Submodel that is used on the SimplifiedWeeklySchedule
    defining a single week day availability range.
    A full day must have values from:0 to:1440, never
    both as zero because thats considered as not available,
    so is better to use the isAllDay property.
**/
'use strict';

var Model = require('./Model'),
    moment = require('moment'),
    ko = require('knockout');

function WeekDaySchedule(values) {

    Model(this);

    // NOTE: from-to properies as numbers
    // for the minute of the day, from 0 (00:00) to 1439 (23:59)
    this.model.defProperties({
        from: 0,
        to: 0
    }, values);
    
    /**
        It allows to know if this week day is 
        enabled for weekly schedule, just it
        has from-to times.
        It allows to be set as true putting
        a default range (9a-5p) or false 
        setting both as 0p.
        
        Since on write two observables are being modified, and
        both are used in the read, a single change to the 
        value will trigger two notifications; to avoid that,
        the observable is rate limited with an inmediate value,
        son only one notification is received.
    **/
    this.isEnabled = ko.computed({
        read: function() {
            return (
                typeof(this.from()) === 'number' &&
                typeof(this.to()) === 'number' &&
                this.from() < this.to()
            );
        },
        write: function(val) {
            if (val === true) {
                // Default range 9a - 5p
                this.fromHour(9);
                this.toHour(17);
            }
            else {
                this.toHour(0);
                this.from(0);
            }
        },
        owner: this
    }).extend({ rateLimit: 0 });
    
    this.isAllDay = ko.computed({
        read: function() {
            return  (
                this.from() === 0 &&
                this.to() === 1440
            );
        },
        write: function(/*val*/) {
            this.from(0);
            this.to(1440);
        },
        owner: this
    }).extend({ rateLimit: 0 });
    
    // Additional interfaces to get/set the from/to times
    // by using a different data unit or format.
    
    // Integer, rounded-up, number of hours
    this.fromHour = ko.computed({
        read: function() {
            return Math.floor(this.from() / 60);
        },
        write: function(hours) {
            this.from((hours * 60) |0);
        },
        owner: this
    });
    this.toHour = ko.computed({
        read: function() {
            return Math.ceil(this.to() / 60);
        },
        write: function(hours) {
            this.to((hours * 60) |0);
        },
        owner: this
    });
    
    // String, time format ('hh:mm')
    this.fromTime = ko.computed({
        read: function() {
            return minutesToTimeString(this.from() |0);
        },
        write: function(time) {
            this.from(timeStringToMinutes(time));
        },
        owner: this
    });
    this.toTime = ko.computed({
        read: function() {
            return minutesToTimeString(this.to() |0);
        },
        write: function(time) {
            this.to(timeStringToMinutes(time));
        },
        owner: this
    });
}

module.exports = WeekDaySchedule;

//// UTILS,
// TODO Organize or externalize. some copied form appmodel..
/**
    internal utility function 'to string with two digits almost'
**/
function twoDigits(n) {
    return Math.floor(n / 10) + '' + n % 10;
}

/**
    Convert a number of minutes
    in a string like: 00:00:00 (hours:minutes:seconds)
**/
function minutesToTimeString(minutes) {
    var d = moment.duration(minutes, 'minutes'),
        h = d.hours(),
        m = d.minutes(),
        s = d.seconds();
    
    return (
        twoDigits(h) + ':' +
        twoDigits(m) + ':' +
        twoDigits(s)
    );
}

function timeStringToMinutes(time) {
    return moment.duration(time).asMinutes() |0;
}
},{"./Model":123,"knockout":false,"moment":false}],151:[function(require,module,exports){
/**
    Utility to help track the state of cached data
    managing time, preference and if must be revalidated
    or not.
    
    Its just manages meta data, but not the data to be cached.
**/
'use strict';

var moment = require('moment');

function CacheControl(options) {
    
    options = options || {};

    // A number of milliseconds or
    // An object with desired units and amount, all optional,
    // any combination with almost one specified, sample:
    // { years: 0, months: 0, weeks: 0, 
    //   days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }
    this.ttl = moment.duration(options.ttl).asMilliseconds();
    this.latest = options.latest || null;

    this.mustRevalidate = function mustRevalidate() {
        var tdiff = this.latest && new Date() - this.latest || Number.POSITIVE_INFINITY;
        return tdiff > this.ttl;
    };
    
    this.touch = function touch() {
        this.latest = new Date();
    };
}

module.exports = CacheControl;

},{"moment":false}],152:[function(require,module,exports){
/**
    Keep an in memory cache of data organized by date as key-value.
    
    IMPORTANT: Date without time, in ISO format YYYY-MM-DD, using
    local timezone. A change of timezone displayed to the user must
    invalidate the cache (through .clear()).
**/
'use strict';

var moment = require('moment'),
    CacheControl = require('./CacheControl');

module.exports = function DateCache(settings) {
    
    this.Model = settings && settings.Model || null;
    this.ttl = settings && settings.ttl || { minutes: 1 };
    
    this.byDate = {};
    
    this.clear = function() {
        this.byDate = {};
    };
    
    this.getSingle = function(date) {
        var dateKey = date;
        if (date instanceof Date)
            dateKey = moment(date).format('YYYY-MM-DD');
        
        if (this.byDate.hasOwnProperty(dateKey) &&
            !this.byDate[dateKey].control.mustRevalidate()) {

            return this.byDate[dateKey].data;
        }

        return null;
    };
    
    this.remove = function(date) {
        var dateKey = date;
        if (date instanceof Date)
            dateKey = moment(date).format('YYYY-MM-DD');
        delete this.byDate[dateKey];
    };
    
    this.get = function(start, end) {

        var date = new Date(start);
        var resultsPerDate = {},
            holes = [],
            minRequest = null,
            maxRequest = null;

        while (date <= end) {
            var dateKey = moment(date).format('YYYY-MM-DD');
            
            if (this.byDate.hasOwnProperty(dateKey) &&
                !this.byDate[dateKey].control.mustRevalidate()) {
                resultsPerDate[dateKey] = this.byDate[dateKey].data;
            }
            else {
                holes.push(new Date(date));
            }
            // Next date:
            date.setDate(date.getDate() + 1);
        }
        
        // Sort holes
        holes.sort(function(a, b) { return a === b ? 0 : a < b ? -1 : 1; });
        // min hole is the first one
        minRequest = holes.length ? holes[0] : null;
        // max hole is the last one
        maxRequest = holes.length ? holes[holes.length - 1] : null;
        
        return {
            byDate: resultsPerDate,
            holes: holes,
            minHole: minRequest,
            maxHole: maxRequest
        };
    };
    
    this.set = function(date, data) {
        // Date formatting. Provide a formatted date as string is valid too
        var dateKey = date;
        if (date instanceof Date)
            dateKey = moment(date).format('YYYY-MM-DD');
        
        // Update cache
        var c = this.byDate[dateKey];
        if (c && c.data) {
            if (this.Model)
                c.data.model.updateWith(data);
            else
                c.data = data;
        }
        else {
            c = {
                data: this.Model ? new this.Model(data) : data,
                control: new CacheControl({ ttl: this.ttl })
            };
            this.byDate[dateKey] = c;
        }
        c.control.touch();
        return c;
    };
};

},{"./CacheControl":151,"moment":false}],153:[function(require,module,exports){
/**
    New Function method: '_delayed'.
    It returns a new function, wrapping the original one,
    that once its call will delay the execution the given milliseconds,
    using a setTimeout.
    The new function returns 'undefined' since it has not the result,
    because of that is only suitable with return-free functions 
    like event handlers.
    
    Why: sometimes, the handler for an event needs to be executed
    after a delay instead of instantly.
**/
Function.prototype._delayed = function delayed(milliseconds) {
    var fn = this;
    return function() {
        var context = this,
            args = arguments;
        setTimeout(function () {
            fn.apply(context, args);
        }, milliseconds);
    };
};

},{}],154:[function(require,module,exports){
/**
    Extending the Function class with an inherits method.
    
    The initial low dash is to mark it as no-standard.
**/
Function.prototype._inherits = function _inherits(superCtor) {
    this.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: this,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

},{}],155:[function(require,module,exports){
/**
    Fix Function#name on browsers that do not support it (IE9+):
    
    http://stackoverflow.com/a/17056530/1622346    
**/
'use strict';
/*jshint -W068 */
if (!(function f() {}).name) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function() {
            var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
            // For better performance only parse once, and then cache the
            // result through a new accessor for repeated access.
            Object.defineProperty(this, 'name', { value: name });
            return name;
        }
    });
}
},{}],156:[function(require,module,exports){
/**
    GroupListRemoteModel
    Utility class for common code for a data list entity from a remote source,
    with local copy and cache, where the full list is managed per groups,
    without paging/cursor, all the group data on each operation.
**/
'use strict';

var ko = require('knockout'),
    IndexedGroupListCache = require('./IndexedGroupListCache');

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function GroupListRemoteModel(settings) {
    /*jshint maxstatements:28*/
    
    settings = settings || {};
    settings.listTtl = required(settings.listTtl, 'listTtl is required');
    settings.groupIdField = required(settings.groupIdField, 'groupIdField is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    // For now, optional model
    settings.Model = settings.Model || null;
    // Required for API additions
    this.settings = settings;

    this.state = {
        isLoading: ko.observable(false),
        isSyncing: ko.observable(false),
        isSaving: ko.observable(false),
        isDeleting: ko.observable(false)
    };

    var cache = new IndexedGroupListCache({
        listTtl: settings.listTtl,
        groupIdField: settings.groupIdField,
        itemIdField: settings.itemIdField
    });
    
    this.clearCache = cache.clearCache;

    this.state.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving() || this.isDeleting();
    }, this.state);

    /** Data Stores Management: implementation must be replaced, with custom code or using
        the helpers added to the class (see addXxSupport prototype methods).
    **/
    function notImplemented() { throw new Error('Not Implemented'); }
    this.fetchGroupFromLocal = notImplemented;
    this.fetchGroupFromRemote = notImplemented;
    this.pushGroupToLocal = notImplemented;
    this.pushGroupToRemote = notImplemented;
    this.removeItemFromRemote = notImplemented;

    /** API definition **/
    var api = this;

    api.getList = function getList(groupID) {
        var cacheEntry = cache.getGroupCache(groupID);

        if (cacheEntry.control.mustRevalidate()) {
            // No cache data, is first load, try from local
            if (!cacheEntry.list) {
                api.state.isLoading(true);
                // From local
                return this.fetchGroupFromLocal(groupID)
                .then(function(data) {
                    // launch remote for sync
                    api.state.isSyncing(true);
                    var remotePromise = this.fetchGroupFromRemote(groupID)
                    .then(function(serverData) {
                        cache.setGroupCache(groupID, serverData);
                        this.pushGroupToLocal(groupID, serverData);
                        api.state.isSyncing(false);
                        return serverData;
                    }.bind(this));
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                }.bind(this))
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.setGroupCache(groupID, data);
                    this.pushGroupToLocal(groupID, data);
                    api.state.isLoading(false);

                    return data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            } else {
                api.state.isSyncing(true);
                // From remote
                return this.fetchGroupFromRemote(groupID)
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.setGroupCache(groupID, data);
                    this.pushGroupToLocal(groupID, data);
                    api.state.isLoading(false);
                    api.state.isSyncing(false);

                    return data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            }
        }
        else {
            // From cache
            return Promise.resolve(cacheEntry.list);
        }
    };
    
    api.getItem = function getItem(groupID, itemID) {
        // IMPORTANT: To simplify, load all the list (is a short list)
        // and look from its cached index
        // TODO Implement item server look-up. Be careful with cache update,
        // list sorting and state flags.
        return api.getList(groupID)
        .then(function() {
            // Get from cached index
            var cacheItem = cache.getItemCache(groupID, itemID);

            // TODO: Enhance on future with actual look-up by API itemID
            // if not cached, throwing not found from the server (just to avoid
            // minor cases when a new item is not still in the cache if linked
            // from other app data). And keep updated list cache with that
            // items lookup
            if (!cacheItem) {
                console.warn('GroupListRemoteModel Not found', groupID, itemID, settings.Model);
                throw new Error('Not Found');
            }
            return cacheItem.item;
        });
    };

    /**
        Save an item in cache, local and remote.
        Can be new or updated.
        The IDs goes with all the other data, being
        groupID required, itemID required for updates
        but falsy for insertions.
        @param data:object Plain object
    **/
    api.setItem = function setItem(data) {
        api.state.isSaving(true);
        // Send to remote first
        return this.pushGroupToRemote(data)
        .then(function(serverData) {
            // Success! update local copy with returned data
            // IMPORTANT: to use server data here so we get values set
            // by the server, as updates dates and itemID when creating
            // a new item.
            if (serverData) {
                var groupID = serverData[settings.groupIdField];
                // Save in cache
                cache.setItemCache(groupID, serverData[settings.itemIdField], serverData);
                // Save in local storage
                // In local need to be saved all the grouped data, not just
                // the item; since we have the cache list updated, use that
                // full list to save local
                this.pushGroupToLocal(groupID, cache.getGroupCache(groupID).list);
            }
            api.state.isSaving(false);

            return serverData;
        }.bind(this))
        .catch(function(err) {
            api.state.isSaving(false);
            // Rethrow error
            return err;
        });
    };
    
    api.delItem = function delItem(groupID, itemID) {
        
        api.state.isDeleting(true);
        
        // Remove in remote first
        return this.removeItemFromRemote(groupID, itemID)
        .then(function(removedData) {
            // Update cache
            cache.delItemCache(groupID, itemID);
            // Save in local storage
            // In local need to be saved all the grouped data;
            // since we have the cache list updated, use that
            // full list to save local
            this.pushGroupToLocal(groupID, cache.getGroupCache(groupID).list);
            
            api.state.isDeleting(false);
            
            return removedData;
        }.bind(this))
        .catch(function(err) {
            api.state.isDeleting(false);
            // Rethrow error
            return err;
        });
    };
    
    /** Some Utils **/
    
    /**
        Generates and returns an observable inmediately,
        with the cached value or undefined,
        launching an item load that will update the observable
        on ready if there is no cached value.
        A method 'sync' is added to the observable so can be requested
        a data sync/reload on demand.
    **/
    api.getObservableItem = function getObservableItem(groupID, itemID, asModel) {
        // Get first value
        var firstValue = cache.getItemCache(groupID, itemID);
        firstValue = firstValue && firstValue.item || undefined;
        var obs = ko.observable(asModel ? api.asModel(firstValue) : firstValue);
        // Create method 'sync'
        obs.sync = function syncObservableItem() {
            return api.getItem(groupID, itemID)
            .then(function(item) {
                if (asModel)
                    obs().model.updateWith(item);
                else
                    obs(item);
            });
        };
        // First load if no cached value
        if (!firstValue)
            obs.sync();
        // Return
        return obs;
    };
    
    api.asModel = function asModel(object) {
        var Model = this.settings.Model;
        // if is an array, return a list of models
        if (Array.isArray(object)) {
            return object.map(function(item) {
                return new Model(item);
            });
        }
        else {
            return new Model(object);
        }
    };
    
    api.getItemModel = function getItemModel(groupID, itemID) {
        return api.getItem(groupID, itemID)
        .then(function(data) {
            return data ? api.asModel(data) : null;
        });
    };
    
    var ModelVersion = require('../utils/ModelVersion');
    api.getItemVersion = function getItemVersion(groupID, itemID) {
        return api.getItemModel(groupID, itemID)
        .then(function(model) {
            return model ? new ModelVersion(model) : null;
        });
    };
    
    api.newItemVersion = function newItemVersion(values) {
        // New original and version for the model
        var version = new ModelVersion(new this.settings.Model(values));
        // To be sure that the version appear as something 'new', unsaved,
        // we update its timestamp to be different to the original.
        version.version.model.touch();
        return version;
    };
}

module.exports = GroupListRemoteModel;

GroupListRemoteModel.prototype.addLocalforageSupport = function addLocalforageSupport(baseName) {
    var localforage = require('localforage');

    this.fetchGroupFromLocal = function fetchFromLocal(groupID) {
        return localforage.getItem(baseName + groupID);
    };
    this.pushGroupToLocal = function pushToLocal(groupID, data) {
        return localforage.setItem(baseName + groupID, data);
    };
};

GroupListRemoteModel.prototype.addRestSupport = function addRestSupport(restClient, baseUrl) {
    
    this.fetchGroupFromRemote = function fetchFromRemote(groupID) {
        return restClient.get(baseUrl + groupID);
    };
    this.pushGroupToRemote = function pushToRemote(data) {

        var groupID = data[this.settings.groupIdField],
            itemID = data[this.settings.itemIdField],
            method = data[this.settings.itemIdField] ? 'put' : 'post';

        var url = baseUrl + groupID + (
            itemID ? '/' + itemID : ''
        );
        return restClient[method](url, data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(groupID, itemID) {
        return restClient.delete(baseUrl + groupID + '/' + itemID);
    };
};

},{"../utils/ModelVersion":161,"./IndexedGroupListCache":158,"knockout":false,"localforage":false}],157:[function(require,module,exports){
/**
    GroupRemoteModel
    Utility class for common code that has remote entities grouped
    by a value but accesed all the time individually.
    It has local copy and cache.
    Difference with GroupListRemoteModel its that the content is NOT
    a list, but an entity.
**/
'use strict';

var ko = require('knockout');
var CacheControl = require('./CacheControl');

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function GroupRemoteModel(settings) {
    
    settings = settings || {};
    settings.ttl = required(settings.ttl, 'ttl is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    settings.Model = required(settings.Model, 'Model is required');
    // Required for API additions
    this.settings = settings;

    this.state = {
        isLoading: ko.observable(false),
        isSyncing: ko.observable(false),
        isSaving: ko.observable(false),
        isDeleting: ko.observable(false)
    };

    var cache = {
        // 'indexID': { data, control:CacheControl }
    };
    var setItemCache = function(itemID, data) {
        if (cache[itemID]) {
            cache[itemID].data.model.updateWith(data);
            cache[itemID].control.touch();
        }
        else {
            cache[itemID] = {
                data: new settings.Model(data),
                control: new CacheControl({
                    ttl: settings.ttl
                })
            };
        }
        return cache[itemID];
    };

    this.clearCache = function() {
        cache = {};
    };

    this.state.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving() || this.isDeleting();
    }, this.state);

    /** Data Stores Management: implementation must be replaced, with custom code or using
        the helpers added to the class (see addXxSupport prototype methods).
    **/
    function notImplemented() { throw new Error('Not Implemented'); }
    this.fetchItemFromLocal = notImplemented;
    this.fetchItemFromRemote = notImplemented;
    this.pushItemToLocal = notImplemented;
    this.pushItemToRemote = notImplemented;
    this.removeItemFromLocal = notImplemented;
    this.removeItemFromRemote = notImplemented;

    /** API definition **/
    var api = this;

    api.getItem = function getItem(itemID, forceRemoteLoad) {
        var cacheEntry = cache[itemID];

        if (forceRemoteLoad || !cacheEntry || cacheEntry.control.mustRevalidate()) {
            // No cache data, is first load, try from local
            if (!cacheEntry || !cacheEntry.data) {
                api.state.isLoading(true);
                // From local
                return this.fetchItemFromLocal(itemID)
                .then(function(data) {
                    // launch remote for sync
                    api.state.isSyncing(true);
                    var remotePromise = this.fetchItemFromRemote(itemID)
                    .then(function(serverData) {
                        var cached = setItemCache(itemID, serverData);
                        this.pushItemToLocal(itemID, serverData);
                        api.state.isSyncing(false);
                        return cached.data;
                    }.bind(this));
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                }.bind(this))
                .then(function(data) {
                    var cached = setItemCache(itemID, data);
                    api.state.isLoading(false);
                    return cached.data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            } else {
                api.state.isSyncing(true);
                // From remote
                return this.fetchItemFromRemote(itemID)
                .then(function(data) {
                    var cached = setItemCache(itemID, data);
                    this.pushItemToLocal(itemID, data);
                    api.state.isLoading(false);
                    api.state.isSyncing(false);

                    return cached.data;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            }
        }
        else {
            // From cache
            return Promise.resolve(cacheEntry.data);
        }
    };

    /**
        Save an item in cache, local and remote.
        Can be new or updated.
        The IDs goes with all the other data, being
        itemID required for updates
        but falsy for insertions.
        @param data:object Plain object
    **/
    api.setItem = function setItem(data) {
        
        // Get plain data if is model
        data = data && data.model && data.model.toPlainObject(true) || data;
        
        api.state.isSaving(true);
        // Send to remote first
        return this.pushItemToRemote(data[settings.itemIdField], data)
        .then(function(serverData) {
            var cached;
            // Success! update local copy with returned data
            // IMPORTANT: to use server data here so we get values set
            // by the server, as updates dates and itemID when creating
            // a new item.
            if (serverData) {
                var itemID = serverData[settings.itemIdField];
                // Save in cache
                cached = setItemCache(serverData[settings.itemIdField], serverData);
                // Save in local storage
                // In local need to be saved all the grouped data, not just
                // the item; since we have the cache list updated, use that
                // full list to save local
                this.pushItemToLocal(itemID, cached.data.model.toPlainObject(true));
            }
            api.state.isSaving(false);

            return cached && cached.data;
        }.bind(this))
        .catch(function(err) {
            api.state.isSaving(false);
            // Rethrow error
            return err;
        });
    };
    
    api.delItem = function delItem(itemID) {
        
        api.state.isDeleting(true);
        
        // Remove in remote first
        return this.removeItemFromRemote(itemID)
        .then(function(removedData) {
            // Update cache
            delete cache[itemID];
            // Update local storage
            this.removeItemFromLocal(itemID);

            api.state.isDeleting(false);
            
            return removedData;
        }.bind(this))
        .catch(function(err) {
            api.state.isDeleting(false);
            // Rethrow error
            return err;
        });
    };
    
    /** Some Utils **/
    var ModelVersion = require('../utils/ModelVersion');
    /**
        Gets immediately an object based on ModelVersion
        with the original and version being the cached version
        if any or an empty Model (instance without data).
        If there is no data, it triggers a load automatically
        setting its state flag isLoading to true until ends.
        If there are data but is obsolete, it triggers a 
        load automatically settings its state  flag isSyncing
        to true until ends.
        It adds a load method to trigger loading of the original
        from remote, and it triggers ModelVersion.sync on finishing
        (isSyncing is flagged); returns Promise
        It adds a save method to trigger saving the version
        to remote, and it push the changes to the original on success
        (isSaving is flagged); returns Promise.
    **/
    api.getItemVersion = function getItemVersion(itemID) {
        
        var cached = cache[itemID],
            initialModel = cached && cached.data || new settings.Model(),
            version = new ModelVersion(initialModel);
        
        // Extend with state flags
        version.state = {
            isLoading: ko.observable(false),
            isSyncing: ko.observable(false),
            isSaving: ko.observable(false),
            // Not just a flag, it contains any error
            // on loading/saving. It no value/null, no error
            lastError: ko.observable(null)
            //isDeleting: ko.observable(false)
        };

        // First time load, if needed:
        if (itemID && (!cached || cached.mustRevalidate())) {
            version.state.isLoading(true);
            api.getItem(itemID)
            .then(function(model) {
                version.state.lastError(null);
                version.state.isLoading(false);
                version.original.model.updateWith(model, true);
                version.version.model.updateWith(model, true);
            })
            .catch(function(err) {
                version.state.lastError(err);
                version.state.isLoading(false);
            });
        }
        
        version.load = function load(newItemID, forceRemoteLoad) {
            version.state.isSyncing(true);
            // Use the new itemID, OR use the one at the original model.
            // Why not the closure itemID?
            // The ID could get updated in a save process,
            // because autogenerating one for a new item.
            var oItemID = newItemID || version.original[settings.itemIdField]();
            return api.getItem(oItemID, forceRemoteLoad)
            .then(function(model) {
                version.state.lastError(null);
                version.state.isSyncing(false);
                version.original.model.updateWith(model, true);
                //// Try sync, if original is newer will replace version
                //version.sync();
                // pull changes from the new original
                version.pull({ eventIfNewer: true });
                return model;
            })
            .catch(function(err) {
                version.state.lastError(err);
                version.state.isSyncing(false);
                // rethrow error
                throw err;
            });
        };
        
        version.reset = function reset() {
            version.original.model.reset();
            version.version.model.reset();
        };
        
        version.save = function save() {
            version.state.isSaving(true);
            return api.setItem(version.version)
            .then(function(model) {
                version.state.lastError(null);
                version.state.isSaving(false);
                version.version.model.updateWith(model, true);
                // push changes to the original
                version.push({ evenIfObsolete: true });
                return model;
            })
            .catch(function(err) {
                version.state.lastError(err);
                version.state.isSaving(false);
                // rethrow error
                throw err;
            });
        };

        return version;
    };
    
    api.newItemVersion = function newItemVersion(values) {
        var version = api.getItemVersion();
        // Initial data
        if (values)
            version.version.model.updateWith(values, true);
        // To be sure that the version appear as something 'new', unsaved,
        // we update its timestamp to be different to the original.
        version.version.model.touch();
        return version;
    };
}

module.exports = GroupRemoteModel;

GroupRemoteModel.prototype.addLocalforageSupport = function addLocalforageSupport(baseName) {
    var localforage = require('localforage');

    this.fetchItemFromLocal = function fetchFromLocal(itemID) {
        return localforage.getItem(baseName + itemID);
    };
    this.pushItemToLocal = function pushToLocal(itemID, data) {
        return localforage.setItem(baseName + itemID, data);
    };
    this.remoteItemFromLocal = function remoteFromLocal(itemID) {
        return localforage.removeItem(baseName + itemID);
    };
};

GroupRemoteModel.prototype.addRestSupport = function addRestSupport(restClient, baseUrl) {

    this.fetchItemFromRemote = function fetchFromRemote(itemID) {
        return restClient.get(baseUrl + itemID);
    };
    this.pushItemToRemote = function pushToRemote(itemID, data) {

        var method = itemID ? 'put' : 'post';

        var url = baseUrl + (
            itemID ? '/' + itemID : ''
        );
        return restClient[method](url, data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(itemID) {
        return restClient.delete(baseUrl + itemID);
    };
};

},{"../utils/ModelVersion":161,"./CacheControl":151,"knockout":false,"localforage":false}],158:[function(require,module,exports){
/**
    IndexedGroupListCache manages a in-memory cache for a list
    of objects, grouped by a field and with indexed access to groups
    and items, with cache control.
    
    Settings object as unique parameter:
    listTtl: ttl type constructor. TimeToLife for each group list cache.
    FUTURE: itemTtl: ttl type constructor. TimeToLife for each item cache.
    ttl: ttl type constructor. TimeToLife to use for list and item cache if there is no a more explicit one
    groupIdField: string Name of the field used to group objects
    itemIdField: string Name of the field used to uniquely identify each item
    FUTURE: Model: constructor of type Model.
    
    Note: 'ttl type constructor' can be a number of milliseconds or a value to pass to moment.duration constructor (momentjs module).
**/
'use strict';

var CacheControl = require('./CacheControl');

function createIndex(list, byField) {
    var index = {};
    
    list.forEach(function(item, itemIndex) {
        index[item[byField]] = {
            index: itemIndex,
            item: item
            // Direct referenc, could be a property too auto resolving as
            // something like get item() { return list[itemIndex[item[byField]]] || null; }
        };
    });

    return index;
}

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function IndexedGroupListCache(settings) {
    
    settings = settings || {};
    settings.ttl = settings.ttl || 0;
    settings.listTtl = settings.listTtl || settings.ttl || 0;
    //FUTURE: settings.itemTtl = settings.itemTtl || settings.ttl || 0;
    settings.groupIdField = required(settings.groupIdField, 'groupIdField is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    //FUTURE: settings.Model = settings.Model || throw new Error('A Model is required');
    
    var cache = {/*
        groupIdField: {
            control: CacheControl,
            list: Array,
            index: {
                itemIdField: {
                    index: Integer (index in the list array),
                    item: Object (reference to the item object in the array)
                    // Maybe future: control: CacheControl per item
                },
                ..
            }
        },
        ..
    */};
    
    this.clearCache = function clearCache() {
        cache = {};
    };

    function newCacheEntry(list) {
        return {
            control: new CacheControl({ ttl: settings.listTtl }),
            list: list || null,
            index: list && createIndex(list, settings.itemIdField) || {}
        };
    }

    function setGroupCache(groupID, list) {
        var cacheEntry = cache[groupID];
        if (cacheEntry) {
            cacheEntry.list = list || [];
            cacheEntry.index = createIndex(list || [], settings.itemIdField);
        }
        else {
            cacheEntry = cache[groupID] = newCacheEntry(list);
        }
        cacheEntry.control.latest = new Date();
    }
    
    this.setGroupCache = setGroupCache;

    /**
        Get the cache entry for the Group
    **/
    function getGroupCache(groupID) {
        var cacheEntry = cache[groupID];
        return cacheEntry || newCacheEntry();
    }
    
    this.getGroupCache = getGroupCache;

    /**
        Get the cache entry from the Item
    **/
    function getItemCache(groupID, itemID) {
        var cacheEntry = cache[groupID];
        if (cacheEntry) {
            return cacheEntry.index[itemID] || null;
        }
        else {
            return null;
        }
    }
    
    this.getItemCache = getItemCache;

    function setItemCache(groupID, itemID, item) {
        var cacheEntry = cache[groupID] || newCacheEntry([]);
        
        // Loof for the entry, to update or insert a new one
        var itemEntry = cacheEntry.index[itemID];
        if (itemEntry) {
            // Update entry
            cacheEntry.list[itemEntry.index] = item;
            // Update reference in the index too (is not computed right now)
            itemEntry.item = item;
        }
        else {
            // Add to the list
            var itemIndex = cacheEntry.list.push(item) - 1;
            cacheEntry.index[itemID] = {
                index: itemIndex,
                item: item
            };
        }
    }
    
    this.setItemCache = setItemCache;

    function delItemCache(groupID, itemID) {
        var groupEntry = cache[groupID] || null;
        if (groupEntry) {
            var itemEntry = groupEntry.index[itemID];
            if (itemEntry) {
                // Update list removing the element in place, without holes
                groupEntry.list.splice(itemEntry.index, 1);
                // Update index by:
                // - Remove itemID entry
                delete groupEntry.index[itemID];
                // - Update every entry with an ID greater than the updated,
                // since they are now one position less in the updated list
                Object.keys(groupEntry.index).forEach(function(key) {
                    if (groupEntry.index[key].index > itemEntry.index)
                        groupEntry.index[key].index--;
                });
            }
        }
    }
    
    this.delItemCache = delItemCache;
    
    function delGroupCache(groupID) {
        var groupEntry = cache[groupID] || null;
        if (groupEntry) {
            // Delete the entry/property
            delete cache[groupID];
        }
    }
    
    this.delGroupCache = delGroupCache;
}

module.exports = IndexedGroupListCache;

},{"./CacheControl":151}],159:[function(require,module,exports){
/**
    IndexedListCache manages a in-memory cache for a list
    of objects, with indexed access to items
    and cache control.
    
    Settings object as unique parameter:
    listTtl: ttl type constructor. TimeToLife for each group list cache.
    FUTURE: itemTtl: ttl type constructor. TimeToLife for each item cache.
    ttl: ttl type constructor. TimeToLife to use for list and item cache if there is no a more explicit one
    itemIdField: string Name of the field used to uniquely identify each item
    Model: constructor of type Model.
    
    Note: 'ttl type constructor' can be a number of milliseconds or a value to pass to moment.duration constructor (momentjs module).
**/
'use strict';

var CacheControl = require('./CacheControl'),
    jsPropertiesTools = require('./jsPropertiesTools'),
    ko = require('knockout');

function createItemIndexEntry(list, itemIndex) {
    return {
        index: itemIndex,
        get item() {
            return list[this.index];
        }
    };
}

function createIndex(list, byField) {
    var index = {};
    
    list.forEach(function(item, itemIndex) {
        index[ko.unwrap(item[byField])] = createItemIndexEntry(list, itemIndex);
    });

    return index;
}

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

/**
    An item adapter receives the old and the new item data and returns
    the item to hold in the list. The returning object can be a reference
    to the same existent object (oldItem) that gets updated with the 
    new values (newItem), or just the newItem or any conversion over the
    raw newItem data.
    This allows to perform changes, add properties, or keep references,
    like creating observables, Models.
    
    This default implementation just returns the newItem.
**/
function defaultItemAdapter(oldItem, newItem) {
    return newItem;
}

function IndexedListCache(settings) {
    
    settings = settings || {};
    settings.ttl = settings.ttl || 0;
    settings.listTtl = settings.listTtl || settings.ttl || 0;
    //FUTURE: settings.itemTtl = settings.itemTtl || settings.ttl || 0;
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    settings.itemAdapter = typeof(settings.itemAdapter) === 'function' ? settings.itemAdapter : defaultItemAdapter;

    // Internal flag to notify if the cache was not used still (no data set)
    // since its instantiation. On first setList will change to false and keep in that state.
    var unused = true;
    // Internal cache management
    var cache = {
        control: new CacheControl({ ttl: settings.listTtl }),
        list: ko.observableArray([]),
        index: {/*
            itemIdField: {
                index: Integer (index in the list array),
                item: Object (property referencing to the item object in the array by its index)
                // Maybe future: control: CacheControl per item
            },
            ..
        */}
    };
    
    this.clearCache = function clearCache() {
        cache.control.latest = null;
        cache.list([]);
        cache.index = {};
        unused = true;
    };

    /**
        Get the cache entry from the Item
    **/
    function getItemCache(itemID) {
        return cache.index[itemID] || null;
    }

    this.getItemCache = getItemCache;

    // Adapt a new item using the itemAdapter and getting the old reference.
    function adaptItem(newItem) {
        var oldItem = getItemCache(ko.unwrap(newItem[settings.itemIdField]));
        return settings.itemAdapter(oldItem, newItem);
    }
    
    // Adapt the each element in the list with the itemAdapter,
    // passing an old reference and the new item on each, and ensuring
    // to return ever an array, even if empty.
    function adaptList(list) {
        return (list || []).map(adaptItem);
    }

    function setList(list) {
        cache.list(adaptList(list));
        cache.index = createIndex(cache.list(), settings.itemIdField);
        cache.control.latest = new Date();
        unused = false;
    }

    // Public, read-only, access to cache info (objects are mutable, but almost the reference
    // cannot be broken; a change in the list instance updates the cache properly).
    jsPropertiesTools.defineGetter(this, 'control', function() { return cache.control; });
    jsPropertiesTools.defineGetter(this, 'list', function() { return cache.list; });
    jsPropertiesTools.defineSetter(this, 'list', function(list) { return setList(list); });
    jsPropertiesTools.defineGetter(this, 'index', function() { return cache.index; });
    jsPropertiesTools.defineGetter(this, 'unused', function() { return unused; });

    function setItemCache(item) {
        var itemID = ko.unwrap(item[settings.itemIdField]);
        // Look for the entry, to update or insert a new one
        var itemEntry = cache.index[itemID];
        if (itemEntry) {
            // Update entry
            cache.list()[itemEntry.index] = adaptItem(item);
        }
        else {
            // Add to the list
            var itemIndex = cache.list.push(adaptItem(item)) - 1;
            cache.index[itemID] = createItemIndexEntry(cache.list(), itemIndex);
        }
    }

    this.setItemCache = setItemCache;

    function delItemCache(itemID) {
        var itemEntry = cache.index[itemID];
        if (itemEntry) {
            // Update list removing the element in place, without holes
            cache.list.splice(itemEntry.index, 1);
            // Update index by:
            // - Remove itemID entry
            delete cache.index[itemID];
            // - Update every entry with an ID greater than the updated,
            // since they are now one position less in the updated list
            Object.keys(cache.index).forEach(function(key) {
                if (cache.index[key].index > itemEntry.index)
                    cache.index[key].index--;
            });
        }
    }
    
    this.delItemCache = delItemCache;
}

module.exports = IndexedListCache;

},{"./CacheControl":151,"./jsPropertiesTools":179,"knockout":false}],160:[function(require,module,exports){
/**
    ListRemoteModel
    Utility class for common code for a data list entity from a remote source,
    with local copy and cache, where the list is managed will all the data,
    without paging/cursor, with indexed access to each item by its ID.
    Is good for lists that keep small in the time.
    
    TODO IMPORTANT The getList method, reused as sync, is returning an observable rather
    than direct data. There are uses right now, double check if this chas any sense and update
    affected code.
    
    TODO To implement single item update mode, not full list each time, by set-up or method
**/
'use strict';

var ko = require('knockout'),
    IndexedListCache = require('./IndexedListCache');

function required(val, msg) {
    if (val === null || typeof(val) === 'undefined') throw new Error(msg || 'Required parameter');
    else return val;
}

function ListRemoteModel(settings) {
    /*jshint maxstatements:50*/

    settings = settings || {};
    settings.listTtl = required(settings.listTtl, 'listTtl is required');
    settings.itemIdField = required(settings.itemIdField, 'itemIdField is required');
    // Optional model
    settings.Model = settings.Model || null;
    // Required for API additions
    this.settings = settings;

    this.state = {
        isLoading: ko.observable(false),
        isSyncing: ko.observable(false),
        isSaving: ko.observable(false),
        isDeleting: ko.observable(false)
    };
    
    // Items are managed as plain object by default, but as permanent, updated
    // model instances if the Model class was specified.
    // This adapter is passed to the cache constructor too keep the in-memory
    // objects up to date with the correct structure.
    function itemAdapter(oldItem, newItem) {
        if (settings.Model) {
            // If the model item already exists, update with new values
            if (oldItem && oldItem instanceof settings.Model) {
                oldItem.model.updateWith(newItem);
                return oldItem;
            }
            else {
                // New created item.
                // If there was a previous, no-model, value, they are discarded
                // (that situation can only happens if there are irregular modifications
                // of the internal behavior).
                return new settings.Model(newItem);
            }
        }
        else {
            return newItem;
        }
    }
    
    var cache = new IndexedListCache({
        listTtl: settings.listTtl,
        itemIdField: settings.itemIdField,
        itemAdapter: itemAdapter
    });
    
    this.clearCache = cache.clearCache;

    this.state.isLocked = ko.pureComputed(function() {
        return this.isLoading() || this.isSaving() || this.isDeleting();
    }, this.state);

    /** Data Stores Management: implementation must be replaced, with custom code or using
        the helpers added to the class (see addXxSupport prototype methods).
    **/
    function notImplemented() { throw new Error('Not Implemented'); }
    this.fetchListFromLocal = notImplemented;
    this.fetchListFromRemote = notImplemented;
    this.pushListToLocal = notImplemented;
    this.pushListToRemote = notImplemented;
    this.removeItemFromRemote = notImplemented;
    
    /**
        Retrieves a plain array-objects from the cached list
    **/
    function getPlainCachedList() {
        var arr = cache.list();
        return arr.map(function(item) {
            if (item && settings.Model && item instanceof settings.Model) {
                return item.model.toPlainObject();
            }
            else {
                return item;
            }
        });
    }

    /** API definition **/
    var api = this;
    
    // Direct access to the observable cached list.
    api.list = cache.list;

    // Currently, just a wrapper for getList.
    api.sync = function sync() {
        return api.getList();
    };

    /**
        Promise based request to get the list (from cache, local or remote).
        It updates the observable list if new data is fetched.
        A general approach is to use the observable list and call the 'sync' method
        rather than wait this promise to finish ('sync' performs this load really).
    **/
    api.getList = function getList() {

        if (cache.control.mustRevalidate()) {
            // Cache still not used, then is first load, try load from local
            if (cache.unused) {
                api.state.isLoading(true);
                // From local
                return this.fetchListFromLocal()
                .then(function(data) {
                    // launch remote for sync
                    api.state.isSyncing(true);
                    var remotePromise = this.fetchListFromRemote()
                    .then(function(serverData) {
                        cache.list = serverData;
                        this.pushListToLocal(serverData);
                        api.state.isSyncing(false);
                        return serverData;
                    }.bind(this))
                    .catch(function(err) {
                        // If there was local data, catch error and
                        // stop sync since this promise will not
                        // be available to any consumer
                        if (data) {
                            api.state.isSyncing(false);
                            // Log to console
                            console.error('ListRemoteModel: remote synchronization failed', err);
                        }
                        else {
                            // This promise is returned so will be consumed,
                            // just rethrow and let the other catch-blocks do the common stuff
                            return err;
                        }
                    });
                    // Remote fallback: If no local, wait for remote
                    return data ? data : remotePromise;
                }.bind(this))
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.list = data;
                    this.pushListToLocal(data);
                    api.state.isLoading(false);

                    return cache.list;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            } else {
                api.state.isSyncing(true);
                // From remote
                return this.fetchListFromRemote()
                .then(function(data) {
                    // Ever a list, even if empty
                    data = data || [];
                    cache.list = data;
                    this.pushListToLocal(data);
                    api.state.isLoading(false);
                    api.state.isSyncing(false);

                    return cache.list;
                }.bind(this))
                .catch(function(err) {
                    api.state.isLoading(false);
                    api.state.isSyncing(false);
                    // rethrow error
                    return err;
                });
            }
        }
        else {
            // From cache
            return Promise.resolve(cache.list);
        }
    };
    
    api.getItem = function getItem(itemID) {
        // IMPORTANT: To simplify, load all the list (is a short list)
        // and look from its cached index
        // TODO Implement item server look-up. Be careful with cache update,
        // list sorting and state flags.
        return api.getList()
        .then(function() {
            // Get from cached index
            var cacheItem = cache.getItemCache(itemID);

            // TODO: Enhance on future with actual look-up by API itemID
            // if not cached, throwing not found from the server (just to avoid
            // minor cases when a new item is not still in the cache if linked
            // from other app data). And keep updated list cache with that
            // items lookup
            if (!cacheItem) {
                console.warn('ListRemoteModel Not found', itemID, settings.Model);
                throw new Error('Not Found');
            }
            return cacheItem.item;
        });
    };
    
    /**
        Generates and returns an observable inmediately,
        with the cached value or undefined,
        launching an item load that will update the observable
        on ready if there is no cached value.
        A method 'sync' is added to the observable so can be requested
        a data sync/reload on demand.
    **/
    api.getObservableItem = function getObservableItem(itemID) {
        // Get first value
        var firstValue = cache.getItemCache(itemID);
        firstValue = firstValue && firstValue.item || undefined;
        var obs = ko.observable(firstValue);
        // Create method 'sync'
        obs.sync = function syncObservableItem() {
            return api.getItem(itemID)
            .then(function(itemModel) {
                obs(itemModel);
            });
        };
        // First load if no cached value
        if (!firstValue)
            obs.sync();
        // Return
        return obs;
    };
    
    /**
        Similar to getObservableItem, it allows to get
        an observable to an item model synchronously that
        it triggers an item load when its method 'sync'
        is called. The itemID is passed to the sync item,
        since the observable is meant to hold any item/itemID
        (its a wildcard).
        This way, a reference to an observable can be get on initialization
        even if there is no data still, even no itemID, and load
        it later lazily, on demand, while keeping the content of the
        previous outdated or different item.

        NOTE: API alternative names: getLazyItem, createMutableItem
        NOTE: Maybe can get state observables (loading, syncing..)?
        NOTE: On update a same itemID, maybe update the model with updateWith
                rather than change the reference model?? (double check:
                since the model is the same in cache, already updated
                with 'updateWith', there is no need to re-apply and no
                need to change the item observable because is the same
                updated already, right?
    **/
    api.createWildcardItem = function createWildcardItem() {
        // Utility for reuse in 'sync'
        var hasID = function(id) {
            return id !== null && typeof(id) !== 'undefined';
        };
        
        // Create observable, with initial undefined value
        var obs = ko.observable(undefined);

        // Create method 'sync'
        var lastID;
        /**
            Sync method to load an item, from cache ASAP and
            from local or remote if required by the cache control.
            It returns the Promise for fetching the value (getItem)
            so load/sync ending and error can be catched.
        **/
        obs.sync = function syncObservableItem(itemID) {
            
            var idChanged = hasID(itemID) && itemID !== lastID;
            lastID = hasID(itemID) ? itemID : lastID;
            
            // ASAP Get from cache if any and requested item changed
            if (idChanged) {
                var cachedItem = cache.getItemCache(lastID);
                if (cachedItem && cachedItem.item)
                    obs(cachedItem.item);
            }

            // Request updated value
            return api.getItem(lastID)
            .then(function(itemModel) {
                obs(itemModel);
                return itemModel;
            });
        };
        
        /**
            Sets the observable value to a new item instance
        **/
        obs.newItem = function newItem(defaults) {
            if (settings.Model)
                obs(new settings.Model(defaults));
            else
                obs(defaults || {});
        };

        // Return
        return obs;
    };

    /**
        Save an item in cache, local and remote.
        Can be new or updated.
        The IDs goes with all the other data, being
        groupID required, itemID required for updates
        but falsy for insertions.
        @param data:object Plain object
    **/
    api.setItem = function setItem(data) {
        api.state.isSaving(true);
        // Send to remote first
        return this.pushListToRemote(data)
        .then(function(serverData) {
            // Success! update local copy with returned data
            // IMPORTANT: to use server data here so we get values set
            // by the server, as updates dates and itemID when creating
            // a new item.
            if (serverData) {
                // Save in cache
                cache.setItemCache(serverData);
                // Save in local storage
                // In local need to be saved all the list, not just
                // the item; since we have the cache list updated, use that
                // full list to save local
                this.pushListToLocal(getPlainCachedList());
            }
            api.state.isSaving(false);

            return serverData;
        }.bind(this))
        .catch(function(err) {
            api.state.isSaving(false);
            // Rethrow error
            return err;
        });
    };
    
    api.delItem = function delItem(itemID) {
        
        api.state.isDeleting(true);
        
        // Remove in remote first
        return this.removeItemFromRemote(itemID)
        .then(function(removedData) {
            // Update cache
            cache.delItemCache(itemID);
            // Save in local storage
            // In local need to be saved all the list;
            // since we have the cache list updated, use that
            // full list to save local
            this.pushListToLocal(getPlainCachedList());

            api.state.isDeleting(false);
            
            return removedData;
        }.bind(this))
        .catch(function(err) {
            api.state.isDeleting(false);
            // Rethrow error
            return err;
        });
    };
    
    /** Some Utils **/

    var ModelVersion = require('../utils/ModelVersion');
    /**
        It creates a new ModelVersion for the requested item ID
        after load the item.
        The promise returns the ModelVersion ready, or null
        if the item does not exists.
    **/
    api.createItemVersion = function createItemVersion(itemID) {
        return api.getItem(itemID)
        .then(function(model) {
            return model ? new ModelVersion(model) : null;
        });
    };

    /**
        It creates a new Model instance with the given initial values,
        returning a ModelVersion object.
        The versioning allows to track the initial
        state (if comes from a set of defaults or clone) with
        the changes done; the internal version notifies itself
        as 'unsaved' ever.
        Its useful to keep the same ModelVersion aware code for
        editions and additions.
    **/
    api.newItem = function newItem(values) {
        // New original and version for the model
        var version = new ModelVersion(new settings.Model(values));
        // To be sure that the version appear as something 'new', unsaved,
        // we update its timestamp to be different to the original.
        version.version.model.touch();
        return version;
    };
}

module.exports = ListRemoteModel;

ListRemoteModel.prototype.addLocalforageSupport = function addLocalforageSupport(baseName) {
    var localforage = require('localforage');

    this.fetchListFromLocal = function fetchListFromLocal() {
        return localforage.getItem(baseName);
    };
    this.pushListToLocal = function pushListToLocal(data) {
        return localforage.setItem(baseName, data);
    };
};

ListRemoteModel.prototype.addRestSupport = function addRestSupport(restClient, baseUrl) {
    
    this.fetchListFromRemote = function fetchListFromRemote() {
        return restClient.get(baseUrl);
    };
    this.pushListToRemote = function pushListToRemote(data) {

        var itemID = data[this.settings.itemIdField],
            method = itemID ? 'put' : 'post';

        var url = baseUrl + (
            itemID ? '/' + itemID : ''
        );
        return restClient[method](url, data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(itemID) {
        return restClient.delete(baseUrl + '/' + itemID);
    };
};

// For testing purposes, emulate a remote providing a static list for the data:
ListRemoteModel.prototype.addMockedRemote = function addMockedRemote(dataList) {
    this.fetchListFromRemote = function fetchListFromRemote() {
        return Promise.resolve(dataList);
    };
    this.pushListToRemote = function pushListToRemote(data) {
        return Promise.resolve(data);
    };
    this.removeItemFromRemote = function removeItemFromRemote(itemID) {
        return Promise.resolve(itemID);
    };
};
},{"../utils/ModelVersion":161,"./IndexedListCache":159,"knockout":false,"localforage":false}],161:[function(require,module,exports){
/**
    Utility that allows to keep an original model untouched
    while editing a version, helping synchronize both
    when desired by push/pull/sync-ing.
    
    Its the usual way to work on forms, where an in memory
    model can be used but in a copy so changes doesn't affects
    other uses of the in-memory model (and avoids remote syncing)
    until the copy want to be persisted by pushing it, or being
    discarded or refreshed with a remotely updated original model.
**/
'use strict';

var ko = require('knockout'),
    EventEmitter = require('events').EventEmitter;

function ModelVersion(original) {
    
    EventEmitter.call(this);
    
    this.original = original;
    
    // Create version
    // (updateWith takes care to set the same dataTimestamp)
    this.version = original.model.clone(null, true);
    
    // Computed that test equality, allowing being notified of changes
    // A rateLimit is used on each to avoid several syncrhonous notifications.
    
    /**
        Returns true when both versions has the same timestamp
    **/
    this.areDifferent = ko.pureComputed(function areDifferent() {
        return (
            this.original.model.dataTimestamp() !== 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
    /**
        Returns true when the version has newer changes than
        the original
    **/
    this.isNewer = ko.pureComputed(function isNewer() {
        return (
            this.original.model.dataTimestamp() < 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
    /**
        Returns true when the version has older changes than
        the original
    **/
    this.isObsolete = ko.pureComputed(function isComputed() {
        return (
            this.original.model.dataTimestamp() > 
            this.version.model.dataTimestamp()
        );
    }, this).extend({ rateLimit: 0 });
}

module.exports = ModelVersion;

ModelVersion._inherits(EventEmitter);

ModelVersion.prototype.getRollback = function getRollback(from) {
    if (from === 'version')
        return createRollbackFunction(this.version);
    else if (from === 'original')
        return createRollbackFunction(this.original);
    throw new Error('from value not valid');
};

/**
    Discard the version changes getting the original
    data.
    
    options: {
        evenIfNewer: false
    }
**/
ModelVersion.prototype.pull = function pull(options) {

    options = options || {};
    
    // By default, nothing to do, or avoid overwrite changes.
    var result = false,
        rollback = null;
    
    if (options.evenIfNewer || !this.isNewer()) {
        // Update version with the original data,
        // creating first a rollback function.
        rollback = createRollbackFunction(this.version);
        // Ever deepCopy, since only properties and fields from models
        // are copied and that must avoid circular references
        // The method updateWith takes care to set the same dataTimestamp:        
        this.version.model.updateWith(this.original, true);
        // Done
        result = true;
    }

    this.emit('pull', result, rollback);
    return result;
};

/**
    Sends the version changes to the original
    
    options: {
        evenIfObsolete: false
    }
**/
ModelVersion.prototype.push = function push(options) {
    
    options = options || {};
    
    // By default, nothing to do, or avoid overwrite changes.
    var result = false,
        rollback = null;

    if (options.evenIfObsolete || !this.isObsolete()) {
        // Update original, creating first a rollback function.
        rollback = createRollbackFunction(this.original);
        // Ever deepCopy, since only properties and fields from models
        // are copied and that must avoid circular references
        // The method updateWith takes care to set the same dataTimestamp.
        this.original.model.updateWith(this.version, true);
        // Done
        result = true;
    }

    this.emit('push', result, rollback);
    return result;
};

/**
    Sets original and version on the same version
    by getting the newest one.
**/
ModelVersion.prototype.sync = function sync() {
    
    if (this.isNewer())
        return this.push();
    else if (this.isObsolete())
        return this.pull();
    else
        return false;
};

/**
    Utility that create a function able to 
    perform a data rollback on execution, useful
    to pass on the events to allow react upon changes
    or external synchronization failures.
**/
function createRollbackFunction(modelInstance) {
    // Previous function creation, get NOW the information to
    // be backed for later.
    var backedData = modelInstance.model.toPlainObject(true),
        backedTimestamp = modelInstance.model.dataTimestamp();

    // Create the function that *may* get executed later, after
    // changes were done in the modelInstance.
    return function rollback() {
        // Set the backed data
        modelInstance.model.updateWith(backedData, true);
        // And the timestamp
        modelInstance.model.dataTimestamp(backedTimestamp);
    };
}

},{"events":false,"knockout":false}],162:[function(require,module,exports){
/**
    RemoteModel class.
    
    It helps managing a model instance, model versions
    for in memory modification, and the process to 
    receive or send the model data
    to a remote sources, with glue code for the tasks
    and state properties.
    
    Every instance or subclass must implement
    the fetch and pull methods that knows the specifics
    of the remotes.
**/
'use strict';

var ModelVersion = require('../utils/ModelVersion'),
    CacheControl = require('../utils/CacheControl'),
    ko = require('knockout'),
    localforage = require('localforage'),
    EventEmitter = require('events').EventEmitter;

function RemoteModel(options) {

    EventEmitter.call(this);
    
    options = options || {};
    
    var firstTimeLoad = true;
    
    // Marks a lock loading is happening, any user code
    // must wait for it
    this.isLoading = ko.observable(false);
    // Marks a lock saving is happening, any user code
    // must wait for it
    this.isSaving = ko.observable(false);
    // Marks a background synchronization: load or save,
    // user code knows is happening but can continue
    // using cached data
    this.isSyncing = ko.observable(false);
    // Utility to know whether any locking operation is
    // happening.
    // Just loading or saving
    this.isLocked = ko.pureComputed(function(){
        return this.isLoading() || this.isSaving();
    }, this);
    
    if (!options.data)
        throw new Error('RemoteModel data must be set on constructor and no changed later');
    this.data = options.data;
    
    this.cache = new CacheControl({
        ttl: options.ttl
    });
    
    this.clearCache = function clearCache() {
        this.cache.latest = null;
        this.data.model.reset();
    };
    
    // Optional name used to persist a copy of the data as plain object
    // in the local storage on every successfully load/save operation.
    // With no name, no saved (default).
    // It uses 'localforage', so may be not saved using localStorage actually,
    // but any supported and initialized storage system, like WebSQL, IndexedDB or LocalStorage.
    // localforage must have a set-up previous use of this option.
    this.localStorageName = options.localStorageName || null;
    
    // Recommended way to get the instance data
    // since it ensures to launch a load of the
    // data each time is accessed this way.
    this.getData = function getData() {
        this.load();
        return this.data;
    };

    this.newVersion = function newVersion() {
        var v = new ModelVersion(this.data);
        
        // Update the version data with the original
        // after a lock load finish, like the first time,
        // since the UI to edit the version will be lock
        // in the middle.
        this.isLoading.subscribe(function (isIt) {
            if (!isIt) {
                v.pull({ evenIfNewer: true });
            }
        });

        // new method for push and remote same returning
        // the save promise to track immediate success or error,
        // with error auto recovering original data.
        v.pushSave = function pushSave() {
            var rollback = v.getRollback('original');
            v.push({ evenIfObsolete: true });

            return this.save()
            .then(function() {
                // Update the version data with the new one
                // from the remote, that may include remote computed
                // values:
                v.pull({ evenIfNewer: true });
            })
            .catch(function(error) {
                // Performs a rollback of the original model
                rollback();
                // The version data keeps untouched, user may want to retry
                // or made changes on its un-saved data.
                // rethrow error
                return error;
            });
        }.bind(this);

        return v;
    };
    
    this.fetch = options.fetch || function fetch() { throw new Error('Not implemented'); };
    this.push = options.push || function push() { throw new Error('Not implementd'); };

    var loadFromRemote = function loadFromRemote() {
        return this.fetch()
        .then(function (serverData) {
            if (serverData) {
                // Ever deepCopy, since plain data from the server (and any
                // in between conversion on 'fecth') cannot have circular
                // references:
                this.data.model.updateWith(serverData, true);

                // persistent local copy?
                if (this.localStorageName) {
                    localforage.setItem(this.localStorageName, serverData);
                }
            }
            else {
                throw new Error('Remote model did not returned data, response must be a "Not Found"');
            }

            // Event
            if (this.isLoading()) {
                this.emit('loaded', serverData);
            }
            else {
                this.emit('synced', serverData);
            }

            // Finally: common tasks on success or error
            this.isLoading(false);
            this.isSyncing(false);

            this.cache.latest = new Date();
            return this.data;
        }.bind(this))
        .catch(function(err) {

            var wasLoad = this.isLoading();

            // Finally: common tasks on success or error
            this.isLoading(false);
            this.isSyncing(false);

            // Event
            var errPkg = {
                task: wasLoad ? 'load' : 'sync',
                error: err
            };
            // Be careful with 'error' event, is special and stops execution on emit
            // if no listeners attached: overwritting that behavior by just
            // print on console when nothing, or emit if some listener:
            if (EventEmitter.listenerCount(this, 'error') > 0) {
                this.emit('error', errPkg);
            }
            else {
                // Log it when not handled (even if the promise error is handled)
                console.error('RemoteModel Error', errPkg);
            }

            // Rethrow error
            return err;
        }.bind(this));
    }.bind(this);
    
    this.load = function load() {
        if (this.cache.mustRevalidate()) {
            
            if (firstTimeLoad)
                this.isLoading(true);
            else
                this.isSyncing(true);
            
            var promise = null;
            
            // If local storage is set for this, load first
            // from local, then follow with syncing from remote
            if (firstTimeLoad &&
                this.localStorageName) {

                promise = localforage.getItem(this.localStorageName)
                .then(function(localData) {
                    if (localData) {
                        this.data.model.updateWith(localData, true);
                        
                        // Load done:
                        this.isLoading(false);
                        this.isSyncing(false);
                        
                        // Local load done, do a background
                        // remote load.
                        loadFromRemote()
                        // Catch any promise-error on the remote, to avoid
                        // unexpected errors being uncatch, they still can be
                        // catch using the 'error' event on the RemoteModel instance.
                        .catch(function() { });
                        // just don't wait, return current
                        // data
                        return this.data;
                    }
                    else {
                        // When no data, perform a remote
                        // load and wait for it:
                        return loadFromRemote();
                    }
                }.bind(this));
            }
            else {
                // Perform the remote load:
                promise = loadFromRemote();
            }
            
            // First time, blocking load:
            // it returns when the load returns
            if (firstTimeLoad) {
                firstTimeLoad = false;
                // Returns the promise and will wait for the first load:
                return promise;
            }
            else {
                // Background load: is loading still
                // but we have cached data so we use
                // that for now.
                // Catch any promise-error on the remote, to avoid
                // unexpected errors being uncatch, they still can be
                // catch using the 'error' event on the RemoteModel instance.
                promise.catch(function() { });
                // If anything new from outside
                // versions will get notified with isObsolete()
                return Promise.resolve(this.data);
            }
        }
        else {
            // Return cached data, no need to load again for now.
            return Promise.resolve(this.data);
        }
    };

    this.save = function save() {
        this.isSaving(true);
        
        // Preserve the timestamp after being saved
        // to avoid false 'obsolete' warnings with
        // the version that created the new original
        var ts = this.data.model.dataTimestamp();

        return this.push()
        .then(function (serverData) {
            // Ever deepCopy, since plain data from the server
            // cannot have circular references:
            this.data.model.updateWith(serverData, true);
            this.data.model.dataTimestamp(ts);
            
            // persistent local copy?
            if (this.localStorageName) {
                localforage.setItem(this.localStorageName, serverData);
            }
            
            // Event
            this.emit('saved', serverData);
            
            // Finally: common tasks on success or error
            this.isSaving(false);
            
            this.cache.latest = new Date();
            return this.data;
        }.bind(this))
        .catch(function(err) {
            // Finally: common tasks on success or error
            this.isSaving(false);
            
            // Event
            var errPkg = {
                task: 'save',
                error: err
            };
            // Be careful with 'error' event, is special and stops execution on emit
            // if no listeners attached: overwritting that behavior by just
            // print on console when nothing, or emit if some listener:
            if (EventEmitter.listenerCount(this, 'error') > 0) {
                this.emit('error', errPkg);
            }
            else {
                // Log it when not handled (even if the promise error is handled)
                console.error('RemoteModel Error', errPkg);
            }
            
            // Rethrow error
            return err;
        }.bind(this));
    };
    
    /**
        Launch a syncing request. Returns nothing, the
        way to track any result is with events or 
        the instance observables.
        IMPORTANT: right now is just a request for 'load'
        that avoids promise errors from throwing.
    **/
    this.sync = function sync() {
        // Call for a load, that will be treated as 'syncing' after the
        // first load
        this.load()
        // Avoid errors from throwing in the console,
        // the 'error' event is there to track anyone.
        .catch(function() {});
    };
}

module.exports = RemoteModel;

RemoteModel._inherits(EventEmitter);

},{"../utils/CacheControl":151,"../utils/ModelVersion":161,"events":false,"knockout":false,"localforage":false}],163:[function(require,module,exports){
/**
    REST API access
**/
'use strict';
var $ = require('jquery');
require('jquery.ajaxQueue');

function lowerFirstLetter(n) {
    return n && n[0] && n[0].toLowerCase && (n[0].toLowerCase() + n.slice(1)) || n;
}

function lowerCamelizeObject(obj) {
    //jshint maxcomplexity:8
    
    if (!obj || typeof(obj) !== 'object') return obj;

    var ret = Array.isArray(obj) ? [] : {};
    for(var k in obj) {
        if (obj.hasOwnProperty(k)) {
            var newk = lowerFirstLetter(k);
            ret[newk] = typeof(obj[k]) === 'object' ?
                lowerCamelizeObject(obj[k]) :
                obj[k]
            ;
        }
    }
    return ret;
}

function Rest(optionsOrUrl) {
    
    var url = typeof(optionsOrUrl) === 'string' ?
        optionsOrUrl :
        optionsOrUrl && optionsOrUrl.url;

    this.baseUrl = url;
    // Optional extraHeaders for all requests,
    // usually for authentication tokens
    this.extraHeaders = null;
}

Rest.prototype.get = function get(apiUrl, data) {
    return this.request(apiUrl, 'get', data);
};

Rest.prototype.put = function get(apiUrl, data) {
    return this.request(apiUrl, 'put', data);
};

Rest.prototype.post = function get(apiUrl, data) {
    return this.request(apiUrl, 'post', data);
};

Rest.prototype.delete = function get(apiUrl, data) {
    return this.request(apiUrl, 'delete', data);
};

Rest.prototype.putFile = function putFile(apiUrl, data) {
    // NOTE basic putFile implementation, one file, use fileUpload?
    return this.request(apiUrl, 'delete', data, 'multipart/form-data');
};

Rest.prototype.request = function request(apiUrl, httpMethod, data, contentType) {
    
    var thisRest = this;
    var url = this.baseUrl + apiUrl;

    // Using a promise to avoid the differences and problems of the jQuery thenable
    // object, but attaching its original value as a new property 'xhr' of the promise
    // created for advanced use.
    var xhr = $.ajaxQueue({
        url: url,
        // Avoid cache for data.
        cache: false,
        dataType: 'json',
        method: httpMethod,
        headers: this.extraHeaders,
        // URLENCODED input:
        // Convert to JSON and back just to ensure the values are converted/encoded
        // properly to be sent, like Dates being converted to ISO format.
        data: data && JSON.parse(JSON.stringify(data)),
        contentType: contentType || 'application/x-www-form-urlencoded'
        // Alternate: JSON as input
        //data: JSON.stringify(data),
        //contentType: contentType || 'application/json'
    });

    var promiseXhr = Promise.resolve(xhr)
    .then(lowerCamelizeObject)
    .catch(function(err) {
        // On authorization error, give oportunity to retry the operation
        if (err.status === 401) {
            var retry = request.bind(this, apiUrl, httpMethod, data, contentType);
            var retryPromise = thisRest.onAuthorizationRequired(retry);
            if (retryPromise) {
                // It returned something, expecting is a promise:
                return Promise.resolve(retryPromise)
                .catch(function(){
                    // There is error on retry, just return the
                    // original call error
                    return err;
                });
            }
        }
        // by default, continue propagating the error
        return err;
    });
    
    promiseXhr.xhr = xhr;
    return promiseXhr;
};

Rest.prototype.onAuthorizationRequired = function onAuthorizationRequired(/*retry*/) {
    // To be implemented outside, if convenient executing:
    //retry();
    // by default don't wait for retry, just return nothing:
    return;
};

module.exports = Rest;

},{}],164:[function(require,module,exports){
/**
    Time class utility.
    Shorter way to create a Date instance
    specifying only the Time part,
    defaulting to current date or 
    another ready date instance.
**/
function Time(date, hour, minute, second) {
    if (!(date instanceof Date)) {
 
        second = minute;
        minute = hour;
        hour = date;
        
        date = new Date();   
    }

    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hour || 0, minute || 0, second || 0);
}
module.exports = Time;

},{}],165:[function(require,module,exports){
/**
    Create an Access Control for an app that just checks
    the activity property for allowed user level.
    To be provided to Shell.js and used by the app.js,
    very tied to that both classes.
    
    Activities can define on its object an accessLevel
    property like next examples
    
    this.accessLevel = app.Usertype.user; // anyone
    this.accessLevel = app.UserType.anonymous; // anonymous users only
    this.accessLevel = app.UserType.loggedUser; // authenticated users only
**/
'use strict';

// UserType enumeration is bit based, so several
// users can has access in a single property
//var UserType = require('../models/User').UserType;

module.exports = function createAccessControl(app) {
    
    return function accessControl(route) {

        var activity = app.getActivityControllerByRoute(route);

        var user = app.model.user();
        var currentType = user && user.userType();

        if (activity && activity.accessLevel) {

            var can = activity.accessLevel & currentType;
            
            if (!can) {
                // Notify error, why cannot access
                return {
                    requiredLevel: activity.accessLevel,
                    currentType: currentType
                };
            }
        }

        // Allow
        return null;
    };
};

},{}],166:[function(require,module,exports){
/**
    Set of functions to make calculations of availability
    per date given a list of appointments.
    It allows to sort them, create and insert free/unavailable appointments
    following a given daySchedule and summarize the date availability status.
    
    It relies (directly or not) in models like Appointment, 
    SimplifiedWeeklySchedule.WeekDaySchedule.
**/
'use strict';

var Appointment = require('../models/Appointment'),
    moment = require('moment');

exports.sortAppointments = function(a, b) {
    var as = a.startTime(),
        ae = a.endTime(),
        bs = b.startTime(),
        be = b.endTime();

    if (as === null)
        return -1;
    else if (bs === null)
        return 1;

    var eq = as.toISOString() === bs.toISOString();
    if (eq) {
        if (ae === null)
            return -1;
        else if (be === null)
            return 1;
        
        return ae - be;
    }
    else {
        return as - bs;
    }
};

/**
    It adds before every booking apt/slot a 'preparation time' slot for the 'preparationHours' (AKA 'betweenTime').
    The given slots array MUST BE SORTED.
    It takes care to:
    - do not add slots out of the given date
    - do not add slots that overlay other bookings (if two bookings too close; because of manual timing or preference
      change of the preparationHours)
**/
exports.fillPreparationTimeSlots = function fillPreparationTimeSlots(date, slots, preparationHours) {
    
    // Initial check of previous slot start and ends is the given date (at midnight)
    // so we avoid to insert slots out of the date.
    var prevEnd = date;

    slots.forEach(function(slot, index) {
        // for each booking
        if (slot.id() > 0 &&
            slot.sourceBooking()) {
            
            var end = slot.startTime(),
                start = moment(end).subtract(preparationHours, 'hours').toDate();
    
            // avoiding the preparation slot if it ends before or just on
            // the previous slot end (or before the date) to avoid unneeded slots
            // NOTE: do NOT a (end <= prevEnd return;) because will introduce a bug
            // since the prevEnd will not be collected, failing when there are 
            // more than 2 consecutive bookings
            if (end > prevEnd) {
                // ..or cuts the beggining of the slot ('start') by
                // the end of the previous slot (so fits perfectly, without overlay)
                start = start < prevEnd ? prevEnd : start;

                // its added before the current slot:
                slots.splice(index, 0, Appointment.newPreparationTimeSlot({
                    start: start,
                    end: end
                }));
            }
        }
        prevEnd = slot.endTime();
    });
};

/**
    Introduce free or unavailable slots wherever needed in the given
    array of Appointments, to fill any gap in a natural day
    (from Midnight to Midnight next date) and based on the
    given week day schedule.
    The hours in the schedule are assumed in the local time.
    A new array is returned.
    It introduce 'preparation time' slots too before of bookings when needed.
    
    date is a Date object representing the same date as used in
    the appointmentsList; it's used when no appointments exists (so
    date cannot be extracted from first appointent) to return an empty
    date unavaialable/free/unavailable slots; and when filling preparation slots, to
    avoid add a slot with time that starts in a previous date
    
    TODO: Make it compatible with an initial appointment that may start before the 
    date (but ends inside the date) and a final appointment that may end
    on the next date (but starts inside the date).
**/
exports.fillDayAvailability = function fillDayAvailability(date, appointmentsList, weekDaySchedule, schedulingPreferences) {

    // Shadow clone
    var slots = appointmentsList.slice(0);
    // sort the list
    slots.sort(exports.sortAppointments);
    // add preparation time for each booking
    exports.fillPreparationTimeSlots(date, slots, schedulingPreferences.betweenTime());

    var filledSlots = [],
        zeroTime = '00:00:00',
        last = zeroTime,
        lastDateTime = null,
        timeFormat = 'HH:mm:ss';

    if (slots.length === 0) {
        // No slots, empty date so create the required
        // unavailable/free/unavailable slots for the 'date'
        var fullStart = moment(date).startOf('day'),
            fullEnd = fullStart.clone().add(1, 'days');

        filledSlots = exports.createScheduleSlots({
            start: fullStart.toDate(),
            end: fullEnd.toDate()
        }, weekDaySchedule);
    }
    else {
        // Look for time gaps in the list
        slots.forEach(function(slot) {
            var start = slot.startTime(),
                s = moment(start),
                end = slot.endTime(),
                e = moment(end);

            if (s.format(timeFormat) > last) {

                if (lastDateTime === null) {
                    // First slot of the date, 12AM=00:00
                    lastDateTime = new Date(
                        start.getFullYear(), start.getMonth(), start.getDate(),
                        0, 0, 0
                    );
                }

                // There is a gap, fill it
                filledSlots.push.apply(filledSlots, exports.createScheduleSlots({
                    start: lastDateTime,
                    end: start
                }, weekDaySchedule));
            }

            filledSlots.push(slot);
            lastDateTime = end;
            last = e.format(timeFormat);
        });

        // Check latest to see a gap at the end:
        var lastEnd = lastDateTime && moment(lastDateTime).format(timeFormat);
        if (lastEnd !== zeroTime) {
            // There is a gap, filled it
            var nextMidnight = new Date(
                lastDateTime.getFullYear(),
                lastDateTime.getMonth(),
                // Next date!
                lastDateTime.getDate() + 1,
                // At zero hours!
                0, 0, 0
            );

            filledSlots.push.apply(filledSlots, exports.createScheduleSlots({
                start: lastDateTime,
                end: nextMidnight
            }, weekDaySchedule));
        }
    }

    return filledSlots;
};

/**
    Given a time range without appointments, and the day schedule,
    it returns an array of appointments objects to fullfill
    that empty range with unavailable/free appointments.
    
    The range must be two times inside the same date (local time), format
    range { start:Date, end:Date }
    
    weekDaySchedule is an instance of WeekDaySchedule Model, basically:
    { from:observable(Date), to:observable(Date) }
**/
exports.createScheduleSlots = function createScheduleSlots(range, weekDaySchedule) {
    /*jshint maxcomplexity:10*/
    var list = [],
        start = range.start,
        end = range.end,
        date = moment(start).startOf('day'),
        from = moment(date).add({ minutes: weekDaySchedule.from() }).toDate(),
        to = moment(date).add({ minutes: weekDaySchedule.to() }).toDate();

    // It happens before the week day schedule starts
    var beforeSchedule = 
        start < from &&
        end <= from;
    // It happens after the week day schedule ends
    var afterSchedule = 
        end > to &&
        start >= to;
    // It happens inside the week day schedule
    var insideSchedule =
        start >= from &&
        end <= to;

    if (beforeSchedule || afterSchedule) {
        list.push(
            Appointment.newUnavailableSlot({
                start: start,
                end: end
            })
        );
    }
    else if (insideSchedule) {
        list.push(
            Appointment.newFreeSlot({
                start: start,
                end: end
            })
        );
    }
    else {
        // Is in a intermediate position, needs two
        // or three slots
        var crossStart =
            start < from &&
            end > from;
        var crossEnd = 
            start < to &&
            end > to;

        if (crossStart) {
            // Unavailable slot until the 'from'
            list.push(
                Appointment.newUnavailableSlot({
                    start: start,
                    end: from
                })
            );
        }
        if (crossEnd) {
            // Unavailable after 'to'
            list.push(
                Appointment.newUnavailableSlot({
                    start: to,
                    end: end
                })
            );
        }

        if (crossStart && crossEnd) {
            // Full day free
            list.push(
                Appointment.newFreeSlot({
                    start: from,
                    end: to
                })
            );
        }
        else if (crossStart) {
            // Free slot until mid point
            list.push(
                Appointment.newFreeSlot({
                    start: from,
                    end: end
                })
            );
        }
        else if (crossEnd) {
            // Free slot from mid point
            list.push(
                Appointment.newFreeSlot({
                    start: start,
                    end: to
                })
            );
        }
    }
    
    // In the complex cases, is easy that the 
    // order gets inversed because of the if-else natural order
    // so ensure goes correct
    return list.sort(exports.sortAppointments);
};

},{"../models/Appointment":103,"moment":false}],167:[function(require,module,exports){
/**
    Bootknock: Set of Knockout Binding Helpers for Bootstrap js components (jquery plugins)
    
    Dependencies: jquery
    Injected dependencies: knockout
**/
'use strict';

// Dependencies
var $ = require('jquery');
// DI i18n library
exports.i18n = null;

function createHelpers(ko) {
    var helpers = {};

    /** Popover Binding **/
    helpers.popover = {
        update: function(element, valueAccessor) {
            var srcOptions = ko.unwrap(valueAccessor());

            // Duplicating options object to pass to popover without
            // overwrittng source configuration
            var options = $.extend(true, {}, srcOptions);
            
            // Unwrapping content text
            options.content = ko.unwrap(srcOptions.content);
            
            if (options.content) {
            
                // Localize:
                options.content = 
                    exports.i18n && exports.i18n.t(options.content) ||
                    options.content;
                
                // To get the new options, we need destroy it first:
                $(element).popover('destroy').popover(options);

                // Se muestra si el elemento tiene el foco
                if ($(element).is(':focus'))
                    $(element).popover('show');

            } else {
                $(element).popover('destroy');
            }
        }
    };
    
    return helpers;
}

/**
    Plug helpers in the provided Knockout instance
**/
function plugIn(ko, prefix) {
    var name,
        helpers = createHelpers(ko);
    
    for(var h in helpers) {
        if (helpers.hasOwnProperty && !helpers.hasOwnProperty(h))
            continue;

        name = prefix ? prefix + h[0].toUpperCase() + h.slice(1) : h;
        ko.bindingHandlers[name] = helpers[h];
    }
}

exports.plugIn = plugIn;
exports.createBindingHelpers = createHelpers;

},{}],168:[function(require,module,exports){
/**
    Knockout Binding Helper for the Bootstrap Switch plugin.
    
    Dependencies: jquery, bootstrap, bootstrap-switch
    Injected dependencies: knockout
    
    IMPORTANT NOTES:
    - A console error of type "object has not that property" will happen if specified
        a non existant option in the binding. The error looks strange when using the minified file.
    - The order of options in the binding matters when combining with disabled and readonly
        options: if the element is disabled:true or readonly:true, any attempt to change the
        value will fail silently, so if the same binding update changes disabled to false
        and the state, the 'disabled' change must happens before the 'state' change so both
        are successfully updated. For that, just specify 'disabled' before 'state' in the bindings
        definition.
**/
'use strict';

// Dependencies
var $ = require('jquery');
require('bootstrap');
require('bootstrap-switch');

/**
    Create and plug-in the Binding in the provided Knockout instance
**/
exports.plugIn = function plugIn(ko, prefix) {

    ko.bindingHandlers[prefix ? prefix + 'switch' : 'switch'] = {
        init: function(element, valueAccessor) {
            // Create plugin instance
            $(element).bootstrapSwitch();
            
            //console.log('switch init', ko.toJS(valueAccessor()));

            // Updating value on plugin changes
            $(element).on('switchChange.bootstrapSwitch', function (e, state) {
                var v = valueAccessor() || {};
                //console.log('switchChange', ko.toJS(v));
                
                // changed?
                var oldState = !!ko.unwrap(v.state),
                    newState = !!state;
                // Only update on change
                if (oldState !== newState) {
                    if (ko.isObservable(v.state)) {
                        if (ko.isWriteableObservable(v.state)) {
                            v.state(newState);
                        }
                    } else {
                        v.state = newState;
                    }
                }
            });
        },
        update: function(element, valueAccessor) {
            // Get options to be applied to the plugin instance
            var srcOptions = valueAccessor();
            
            var options = srcOptions || {};

            // Unwrapping every option value, getting a duplicated
            // plain object
            options = ko.toJS(options);
            //console.log('switch update', options);

            var $el = $(element);
            // Update every option in the plugin
            Object.keys(options).forEach(function(key) {
                $el.bootstrapSwitch(key, options[key]);
            });
        }
    };
};

},{}],169:[function(require,module,exports){
/**
    It creates slots between the given times and size for each one.
    Past times are avoided, because are not available
**/
'use strict';

var moment = require('moment');

/**
    Returns a list of beggining time slots between the range of given times (from-to)
    with a size and that fit in a given duration.
    @param from Date or ISO datetime string
    @param to Date or ISO datetime string
**/
exports.forRange = function forRange(from, to, size, duration) {
    from = new Date(from);
    to = new Date(to);
    var i = moment(from),
        d,
        slots = [],
        now = new Date(),
        enought;

    // Shortcut if bad 'to' (avoid infinite loop)
    if (to <= from)
        return slots;

    while(i.toDate() < to) {
        d = i.clone().toDate();
        enought = i.clone().add(duration, 'minutes').toDate();
        // Check that:
        // - is not a past date
        // - it has enought time in advance to fill the expected duration
        if (d >= now &&
            enought <= to)
            slots.push(d);
        // Next slot
        i.add(size, 'minutes');
    }
    
    return slots;
};

/**
    Returns a list of beggining time slots with a size and that fits in a given
    duration for all the AvailabilitSlots in the list with availability 'free'
    Source list as a consecutive, sorted, non-overlapping list of availabilitySlots
**/
exports.forList = function forList(list, size, duration) {
    var slots = [];
    // Iterate every free time range/AvailabilitySlot
    list.forEach(function (item) {
        if (item.availability === 'free') {
            slots.push.apply(slots, exports.forRange(item.startTime, item.endTime, size, duration));
        }
    });
    return slots;
};


/// Next Much needed Utilities maybe are better in another module, or a different name
/// for this one.

exports.getTotalFreeMinutes = function getTotalFreeMinutes(list) {
    return list.reduce(function (count, item) {
        if (item.availability === 'free') {
            var s = moment(item.startTime),
                e = moment(item.endTime);
            return count + e.diff(s, 'minutes');
        }
        else return count;
    }, 0);
};

/**
    Get the availability tag for the given list of availabilitySlots
    based on a workday of 8 hours.
**/
exports.getAvailabilityTag = function(list) {
    //jshint maxcomplexity:11
    if (!list || list.length === 0) return 'none';
    
    var minutes = exports.getTotalFreeMinutes(list);
    
    var perc = (minutes / (8*60)) * 100,
        date = moment(list[0].startTime).startOf('day').toDate(),
        today = moment().startOf('day').toDate();

    if (date < today)
        return 'past';
    else if (perc >= 100)
        return 'full';
    else if (perc >= 50)
        return 'medium';
    else if (perc > 0)
        return 'low';
    else // <= 0
        return 'none';
};

/**
    Source list as a consecutive, sorted, non-overlapping list of availabilitySlots
    @param list AvailabilitySlot Array from the /availability/times API, the times
        included (startTime, endTime) comes as strings in ISO datetime
**/
exports.filterListBy = function filterListBy(list, start, end) {
    var nstart = start.toISOString(),
        nend = end.toISOString();
    var result = [];

    list.some(function(timeRange) {
        // It's after the wanted range, stop iterating
        if (timeRange.startTime >= nend)
            return true;
        // It's inside the wanted range and not before it starts
        if (timeRange.endTime > nstart) {
            if (timeRange.startTime < nstart) {
                // Beggining needs to be cut
                result.push({
                    startTime: nstart,
                    // Be carefull with looong timeRanges, that can go from before starting to after ending:
                    endTime: timeRange.endTime > nend ? nend : timeRange.endTime,
                    availability: timeRange.availability
                });
            }
            else if (timeRange.endTime > nend) {
                // Ending needs to be cut
                result.push({
                    startTime: timeRange.startTime,
                    endTime: nend,
                    availability: timeRange.availability
                });
            }
            else {
                result.push(timeRange);
            }
        }
        // else continue iterating until reach something in the wanted range
    });
    
    return result;
};

/**
    Creates and returns an object with local isodate as key and including
    each one a filtered list of availabilitySlots from the source list for
    that date.
    Source list as a consecutive, sorted, non-overlapping list of availabilitySlots
**/
exports.splitListInLocalDates = function filterListBy(list) {
    var isodateFormat = 'YYYY-MM-DD';
    var lastIsodate,
        group;
    var result = {};

    list.forEach(function(timeRange) {
        var start = moment(timeRange.startTime);
        var isostart = start.format(isodateFormat);
        // Register new group
        if (isostart !== lastIsodate) {
            group = result[isostart] = [];
            lastIsodate = isostart;
        }
        
        var end = moment(timeRange.endTime),
            endJustDate = end.startOf('day'),
            isoend = end.format(isodateFormat),
            nextDayStart = start.clone().startOf('day').add(1, 'day');
        
        // Checks if different dates, but discard when ending is just
        // the beggining of next date because that's correct for a range
        // that goes to the end of the date (start of next date, to include last minutes)
        if (isostart !== isoend &&
            end.format() !== nextDayStart.format()) {
            // Belongs to different dates, needs to be splitted
            // First fragment, from start to the start of next date.
            group.push({
                startTime: start.format(),
                endTime: nextDayStart.format(),
                availability: timeRange.availability
            });

            // Next fragments must be aware that the end can be next day or
            // a further date, so we need to create the in-between, full day,
            // time ranges, that creates new groups for the dates.
            // And lately, update the lastIsodate and group to the one of the end date.
            var idate = nextDayStart.clone();
            // By compare this way (next day less than ending) we iterate only
            // full day ranges and never the next date, that is managed after the
            // loop the same way if there was something or not in between.
            while (idate < endJustDate) {
                var idateIso = idate.format(isodateFormat),
                    idatetimeIso = idate.format();
                // Mutate iteration date to next day
                idate.add(1, 'day');
                // New date group with single item list of full-day range:
                result[idateIso] = [{
                    startTime: idatetimeIso,
                    endTime: idate.format(),
                    availability: timeRange.availability
                }];
            }
            // Last fragment, from day beginning to the range ending 
            result[idate.format(isodateFormat)] = [{
                startTime: idate.format(),
                endTime: end.format(),
                availability: timeRange.availability
            }];
        }
        else {
            // The range is inside same date, just add it to the group list:
            group.push(timeRange);
        }
    });
    
    return result;
};
},{"moment":false}],170:[function(require,module,exports){
/**
    Allow attach availability loading and displaying capabilities
    to a datepicker component as part of an activity.
    
    It attaches handlers so it loads and update availability whenever
    the displayed month change, but it returns a method to do it
    on demand, like in the first load after choose a 'current date'
**/
'use strict';

var $ = require('jquery'),
    moment = require('moment'),
    createTimeSlots = require('./createTimeSlots');

exports.create = function createDatepickerAvailability(app, $datepicker, isLoading) {
    // Cache DOM elements
    var daysElements = $datepicker.datepicker('getDaysElements');
    // Cache last month showed, to double check later and don't load an already
    // displayed month
    var prevMonth = null;
    var prevUserID = null;
    
    // Listen to cache changes in order to force a data load (to avoid invalid
    // availability being displayed after an apt was modified)
    app.model.availability.on('clearCache', function() {
        prevMonth = null;
    });
    
    /**
        It tags, if the month changed, the calendar with the Date Availability.
        The refresh param forces the process even if the same month than previously tagged/rendered
    **/
    var tagAvailability = function tagAvailability(date, userID, refresh) {
        var month = date.getMonth();
        // Avoid dupes and non-data
        if (!userID || month === prevMonth && prevUserID === userID && !refresh) return;
        prevMonth = month;
        prevUserID = userID;
        
        // We need to know the range of dates being displayed on the
        // monthly calendar, from the first week day of first month week
        // to 6 full weeks.
        var start = moment(date).clone().startOf('month').startOf('week'),
            end = start.clone().add(6, 'weeks');

        // Switch loading flag
        if (isLoading)
            isLoading(true);
        
        // Request the data
        /*app.model.calendar.getDatesAvailability(start, end)
        .then(function(resultByDates) {
            // We are still in the same showed month? (loading is async, so could have changed)
            if (month !== $datepicker.datepicker('getViewDate').getMonth()) return;

            // We received a set of DateAvailability objects per date (iso string key)
            // Iterate every day element, and use its date avail from the result
            daysElements.each(function() {
                // jshint maxcomplexity:10
                var $dateTd = $(this),
                    id = $dateTd.data('date-time'),
                    dateAvail = resultByDates[moment(id).format('YYYY-MM-DD')];   

                // Integrity check to avoid edge case exceptions (must not happens, but stronger code)
                if (!id || !dateAvail) return;
                
                // Remove any previous 'tag-' class from the cell classNames and keep for later change
                var cellClass = $dateTd.attr('class').replace(/(^|\s)tag-[^\s]+/, '');

                // Set a date cell class based on its availability
                var cls = '';
                switch(dateAvail.availableTag()) {
                    case 'past':
                        cls = 'tag-muted';
                        break;
                    case 'full':
                        cls = 'tag-blank';
                        break;
                    case 'medium':
                        cls = 'tag-dark';
                        break;
                    case 'low':
                        cls = 'tag-warning';
                        break;
                    case 'none':
                        cls = 'tag-danger';
                        break;
                }
                $dateTd.attr('class', cellClass + ' ' + cls);
            });
        })*/
        app.model.availability.times(userID, start, end)
        .then(function(result) {
            // We are still in the same showed month? (loading is async, so could have changed)
            if (month !== $datepicker.datepicker('getViewDate').getMonth()) return;

            var byDate = createTimeSlots.splitListInLocalDates(result.times);
            
            // We have a list or ranges per date (iso string key)
            // Iterate every day element, and use its date avail from the result
            daysElements.each(function() {
                // jshint maxcomplexity:10
                var $dateTd = $(this),
                    id = $dateTd.data('date-time'),
                    timeRangeList = byDate[moment(id).format('YYYY-MM-DD')];

                // Integrity check to avoid edge case exceptions
                // ('must' not happens, but stronger code)
                if (!id || !timeRangeList) return;

                // Remove any previous 'tag-' class from the cell classNames and keep for later change
                var cellClass = $dateTd.attr('class').replace(/(^|\s)tag-[^\s]+/, '');

                // Set a date cell class based on its availability
                var cls = '';
                switch(createTimeSlots.getAvailabilityTag(timeRangeList)) {
                    case 'past':
                        cls = 'tag-muted';
                        break;
                    case 'full':
                        cls = 'tag-blank';
                        break;
                    case 'medium':
                        cls = 'tag-dark';
                        break;
                    case 'low':
                        cls = 'tag-warning';
                        break;
                    case 'none':
                        cls = 'tag-danger';
                        break;
                }
                $dateTd.attr('class', cellClass + ' ' + cls);
            });
        })
        .catch(function(err) {
            app.modals.showError({
                title: 'Error loading availability',
                error: err
            });
        }.bind(this))
        .then(function() {
            // Finally
            if (isLoading)
                isLoading(false);
        }.bind(this));
    };
    
    // Handler to auto load/update availability for displayed day
    $datepicker.on('viewDateChanged', function(e, d) {
        if (d.viewMode === 'days') {
            tagAvailability(d.viewDate, prevUserID);
        }
    });
    
    return tagAvailability;
};

},{"./createTimeSlots":169,"moment":false}],171:[function(require,module,exports){
/**
    Converts a duration into a text using long
    language words.
    Example: 2:45 -> 2 hours, 45 minutes
    
    Can pass in a moment.duration object or a valid constructor
    parameter.
    Difference with moment.duration.humanize: this shows a precise
    representation, returning exact value for any non-zero unit,
    while humanize is an approximation in the higher unit
    (in the example above, humanize displays: '3 hours')
    
    TODO: I18N
**/
'use strict';

var moment = require('moment');

module.exports = function duration2Language(duration) {
    //jshint maxcomplexity:30
    duration = moment.duration(duration);
    var y = duration.years(),
        d = duration.days(),
        h = duration.hours(),
        m = duration.minutes(),
        s = duration.seconds(),
        l = duration.milliseconds(),
        parts = [];
    
    if (y === 1) parts.push('a year');
    else if (y) parts.push(y + ' years');
    if (d === 1) parts.push('a day');
    else if (d) parts.push(d + ' days');
    if (h === 1) parts.push('an hour');
    else if (h) parts.push(h + ' hours');
    if (m === 1) parts.push('a minute');
    else if (m) parts.push(m + ' minutes');
    if (s === 1) parts.push('a second');
    else if (s) parts.push(s + ' seconds');
    if (l === 1) parts.push('a millisecond');
    else if (l) parts.push(l + ' milliseconds');
    
    return parts.join(', ');
};
},{"moment":false}],172:[function(require,module,exports){
/**
    Espace a string for use on a RegExp.
    Usually, to look for a string in a text multiple times
    or with some expressions, some common are 
    look for a text 'in the beginning' (^)
    or 'at the end' ($).
    
    Author: http://stackoverflow.com/users/151312/coolaj86 and http://stackoverflow.com/users/9410/aristotle-pagaltzis
    Link: http://stackoverflow.com/a/6969486
**/
'use strict';

// Referring to the table here:
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
// these characters should be escaped
// \ ^ $ * + ? . ( ) | { } [ ]
// These characters only have special meaning inside of brackets
// they do not need to be escaped, but they MAY be escaped
// without any adverse effects (to the best of my knowledge and casual testing)
// : ! , = 
// my test "~!@#$%^&*(){}[]`/=?+\|-_;:'\",<.>".match(/[\#]/g)

var specials = [
    // order matters for these
      "-"
    , "["
    , "]"
    // order doesn't matter for any of these
    , "/"
    , "{"
    , "}"
    , "("
    , ")"
    , "*"
    , "+"
    , "?"
    , "."
    , "\\"
    , "^"
    , "$"
    , "|"
  ]

  // I choose to escape every character with '\'
  // even though only some strictly require it when inside of []
, regex = RegExp('[' + specials.join('\\') + ']', 'g')
;

var escapeRegExp = function (str) {
return str.replace(regex, "\\$&");
};

module.exports = escapeRegExp;

// test escapeRegExp("/path/to/res?search=this.that")

},{}],173:[function(require,module,exports){
/**
* escapeSelector
*
* source: http://kjvarga.blogspot.com.es/2009/06/jquery-plugin-to-escape-css-selector.html
*
* Escape all special jQuery CSS selector characters in *selector*.
* Useful when you have a class or id which contains special characters
* which you need to include in a selector.
*/
'use strict';

var specials = [
  '#', '&', '~', '=', '>', 
  "'", ':', '"', '!', ';', ','
];
var regexSpecials = [
  '.', '*', '+', '|', '[', ']', '(', ')', '/', '^', '$'
];
var sRE = new RegExp(
  '(' + specials.join('|') + '|\\' + regexSpecials.join('|\\') + ')', 'g'
);

module.exports = function(selector) {
  return selector.replace(sRE, '\\$1');
};

},{}],174:[function(require,module,exports){
/**
    Simplifing some uses of the Facebook API
    and the loading of its API with a 'ready' function.

    Official API: https://developers.facebook.com/docs/facebook-login/login-flow-for-web/v2.1
**/
/*global window*/
'use strict';

var loader = require('./loader'),
    $ = require('jquery');

// Facebook API settings gathered from the current page
// on first use:
var settings = {
    language: 'en-US',
    appId: null
};

// Private API loading/ready status
var apiStatus = {
    ready: false,
    loading: false,
    // Private static collection of callbacks registered
    stack: []
};

/**
    Register a callback to be executed when the
    Facebook API is ready.
    The callback receives as unique parameter
    the Facebook API object ('FB')
**/
exports.ready = function facebookReady(readyCallback) {

    if (apiStatus.ready) {
        // Double-check the callback, because its optional
        // (that's allow to use this function force the API pre-load)
        if (typeof(readyCallback) === 'function')
            readyCallback(window.FB);
        // Quik return
        return;
    }

    apiStatus.stack.push(readyCallback);
    
    if (!facebookReady.isLoading) {
        apiStatus.loading = true;

        // Get settings from page attributes
        settings.language = $('[data-facebook-language]').data('facebook-language');
        settings.appId = $('[data-facebook-appid]').data('facebook-appid');

        loader.load({
            scripts: ['//connect.facebook.net/' + settings.language + '/all.js'],
            completeVerification: function () { return !!window.FB; },
            complete: function () {
                // Initialize (Facebook registers itself as global 'FB')
                window.FB.init({ appId: settings.appId, status: true, cookie: true, xfbml: false });

                // Is ready
                apiStatus.ready = true;
                apiStatus.loading = false;

                // Execute callbacks in the stack:
                for (var i = 0; i < apiStatus.stack.length; i++) {
                    try {
                        apiStatus.stack[i](window.FB);
                    } catch (e) { console && console.error && console.error(e); }
                }
            }
        });
    }
};

/**
    Request a Facebook Login, returns a promise.
    Success gets the 'authResponse' given by Facebook,
    and error the whole response object, and both
    the FB API as second parameter.
**/
exports.login = function facebookLogin(options) {
    return new Promise(function(success, error) {
        // When the API is ready
        exports.ready(function (FB) {
            // When Facebook gives a response to the following
            // Login Request
            FB.login(function (response) {
                // status==connected if there is an authResponse
                if (response.authResponse) {
                    success({ auth: response.authResponse, FB: FB, response: response });
                }
                else {
                    error({ response: response, FB: FB });
                }
            }, options);
        });
    });
};

},{"./loader":180}],175:[function(require,module,exports){
/** getDateWithoutTime utility.
    Returns a new Date instance with time at zeroes
    and the same date as the input.
    It returns current date if no valid date or string passed.
**/
'use strict';

module.exports = function getDateWithoutTime(date) {
    if (!date) {
        date = new Date();
    }
    else if (!(date instanceof Date)) {
        date = new Date(date);
    }

    return new Date(
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        0, 0, 0
    );
};

},{}],176:[function(require,module,exports){
/**
    Get a given value wrapped in an observable or returns
    it if its already an observable or just a function.
**/
'use strict';
var ko = require('knockout');

module.exports = function getObservable(obsOrValue) {
    if (typeof(obsOrValue) === 'function')
        return obsOrValue;
    else
        return ko.observable(obsOrValue);
};

},{"knockout":false}],177:[function(require,module,exports){
/**
    Read a page's GET URL variables and return them as an associative array.
**/
'user strict';
//global window

module.exports = function getUrlQuery(url) {

    url = url || window.location.href;

    var vars = [], hash,
        queryIndex = url.indexOf('?');
    if (queryIndex > -1) {
        var hashes = url.slice(queryIndex + 1).split('&');
        for(var i = 0; i < hashes.length; i++)
        {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }
    }
    return vars;
};

},{}],178:[function(require,module,exports){
// jQuery plugin to set multiline text in an element,
// by replacing \n by <br/> with careful to avoid XSS attacks.
// http://stackoverflow.com/a/13082028
'use strict';

var $ = require('jquery');

$.fn.multiline = function(text) {
    this.text(text);
    this.html(this.html().replace(/\n/g,'<br/>'));
    return this;
};

},{}],179:[function(require,module,exports){
/**
    Set of utilities to define Javascript Properties
    independently of the browser.
    
    Allows to define getters and setters.
    
    Adapted code from the original created by Jeff Walden
    http://whereswalden.com/2010/04/16/more-spidermonkey-changes-ancient-esoteric-very-rarely-used-syntax-for-creating-getters-and-setters-is-being-removed/
**/
'use strict';

function accessorDescriptor(field, fun)
{
    var desc = { enumerable: true, configurable: true };
    desc[field] = fun;
    return desc;
}

function defineGetter(obj, prop, get)
{
    if (Object.defineProperty)
        return Object.defineProperty(obj, prop, accessorDescriptor("get", get));
    if (Object.prototype.__defineGetter__)
        return obj.__defineGetter__(prop, get);

    throw new Error("browser does not support getters");
}

function defineSetter(obj, prop, set)
{
    if (Object.defineProperty)
        return Object.defineProperty(obj, prop, accessorDescriptor("set", set));
    if (Object.prototype.__defineSetter__)
        return obj.__defineSetter__(prop, set);

    throw new Error("browser does not support setters");
}

module.exports = {
    defineGetter: defineGetter,
    defineSetter: defineSetter
};

},{}],180:[function(require,module,exports){
/*  Javascript loader, for lazy loading scripts or bundles.
    // with Modernizr: Assets loader with loading confirmation (mainly for scripts).
    
    It uses jquery getScript API
    // based on Modernizr/yepnope loader.
    // var Modernizr = require('modernizr');
*/
'use strict';
var $ = require('jquery');

// Utility: promise based timeout, run task after the returned promise,
// and that task can return another promise.
function promiseTimeout(milliseconds) {
    return new Promise(function(resolve) {
        setTimeout(function() {
            resolve();
        }, milliseconds);
    });
}

exports.load = function (opts) {
    // Define options defaults and use given values
    opts = $.extend(true, {
        scripts: [],
        complete: null,
        completeVerification: null,
        loadDelay: 0,
        trialsInterval: 500
    }, opts);
    // Quick return, nothing to do
    if (!opts.scripts.length) return Promise.resolve();

    function performComplete() {
        if (typeof (opts.completeVerification) !== 'function' || opts.completeVerification()) {
            opts.complete();
            return Promise.resolve();
        }
        else {
            if (console && console.warn)
                console.warn('LC.load.completeVerification failed for ' + opts.scripts[0] + ' retrying it in ' + opts.trialsInterval + 'ms');
            return promiseTimeout(opts.trialsInterval).then(performComplete);
        }
    }
    function load() {
        /*Modernizr.load({
            load: opts.scripts,
            complete: opts.complete ? performComplete : null
        });*/
        return Promise.all(opts.scripts.map(function(sc) { return $.getScript(sc); }))
        .then(opts.complete ? performComplete : null);
    }

    if (opts.loadDelay)
        return promiseTimeout(opts.loadDelay).then(load);
    else
        return load();
};

},{}],181:[function(require,module,exports){
/**
    Remove the accent and special characters from a text
    replacing each character for its basic equivalent.
    Useful to performs punctuation-insensitive text searchs.
**/
'use strict';

var map = {'':'A','':'A','':'A','':'A','':'A','':'A','':'AE','':'C','':'E','':'E','':'E','':'E','':'I','':'I','':'I','':'I','':'D','':'N','':'O','':'O','':'O','':'O','':'O','':'O','':'U','':'U','':'U','':'U','':'Y','':'s','':'a','':'a','':'a','':'a','':'a','':'a','':'ae','':'c','':'e','':'e','':'e','':'e','':'i','':'i','':'i','':'i','':'n','':'o','':'o','':'o','':'o','':'o','':'o','':'u','':'u','':'u','':'u','':'y','':'y','':'A','':'a','':'A','':'a','':'A','':'a','':'C','':'c','':'C','':'c','':'C','':'c','':'C','':'c','':'D','':'d','':'D','':'d','':'E','':'e','':'E','':'e','':'E','':'e','':'E','':'e','':'E','':'e','':'G','':'g','':'G','':'g','':'G','':'g','':'G','':'g','':'H','':'h','':'H','':'h','':'I','':'i','':'I','':'i','':'I','':'i','':'I','':'i','':'I','':'i','':'IJ','':'ij','':'J','':'j','':'K','':'k','':'L','':'l','':'L','':'l','':'L','':'l','':'L','':'l','':'L','':'l','':'N','':'n','':'N','':'n','':'N','':'n','':'n','':'O','':'o','':'O','':'o','':'O','':'o','':'OE','':'oe','':'R','':'r','':'R','':'r','':'R','':'r','':'S','':'s','':'S','':'s','':'S','':'s','':'S','':'s','':'T','':'t','':'T','':'t','':'T','':'t','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'W','':'w','':'Y','':'y','':'Y','':'Z','':'z','':'Z','':'z','':'Z','':'z','':'s','':'f','':'O','':'o','':'U','':'u','':'A','':'a','':'I','':'i','':'O','':'o','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'U','':'u','':'A','':'a','':'AE','':'ae','':'O','':'o'};

module.exports = function removeAccent(str) {

    var res = '', c;
    for (var i = 0, l = str.length; i < l; i++) {
        c = str.charAt(i);
        res += map[c] || c;
    }
    return res;
};

},{}],182:[function(require,module,exports){
/**
    It scroll all needed elements in the page to make the
    target element to appear in the screen, if possible.
    
    It scrolls all the element ancestors (that may have
    or not a scrolling context).
    
    Only vertically.
    TODO: make it horizontal too.
**/
//global window
'use strict';

var $ = require('jquery');

// @param el:DOMElement|jQuery
// @param options:Object {
//      topOffset:int  Offset scroll from the top
// }
module.exports = function scrollToElement(el, options) {
    //jshint maxcomplexity:10
    var parent = $(el).parent();

    var topOffset = options && options.topOffset || 0;
    var animation = options && options.animation;
    
    var atRoot = false;

    do {
        // Go out on detached elements:
        if (!parent || !parent.length) return;
        // Check if root element (ends loop and has different rules for scrolling)
        atRoot = parent.get(0) === document.documentElement;
        
        // Relative position of the element is calculated in a different way
        // when at the root, so take care of that
        var relativeTop = atRoot ? el.position().top : el.offset().top;
        
        // IMPORTANT: elementTop with offset is used as is when atRoot
        // because the next scrollingTop calculating make it fail
        var elementTop = relativeTop - topOffset;
        var scrollingTop = elementTop + parent.scrollTop() - parent.offset().top;

        if (atRoot) {
            // IMPORTANT: special case, on the root
            // we can just use window.scroll or scrollTop for animation
            // BUT with a different amount, the elementTop
            if (animation)
                $('html,body').stop().animate({ scrollTop: elementTop }, animation);
            else
                window.scroll(0, elementTop);
        }
        else {
            if (animation)
                parent.stop().animate({ scrollTop: scrollingTop }, animation);
            else
                parent.scrollTop(scrollingTop);
        }

        parent = parent.parent();
    } while(!atRoot);
};

},{}],183:[function(require,module,exports){
/**
    DomItemsManager class, that manage a collection 
    of HTML/DOM items under a root/container, where
    only one element at the time is visible, providing
    tools to uniquerly identify the items,
    to create or update new items (through 'inject'),
    get the current, find by the ID and more.
**/
'use strict';

var $ = require('jquery');
var escapeSelector = require('../escapeSelector');
var getFlags = require('../userAgentFlags');

function DomItemsManager(settings) {
    //jshint maxcomplexity:10

    this.idAttributeName = settings.idAttributeName || 'id';
    this.allowDuplicates = !!settings.allowDuplicates || false;
    this.root = settings.root || 'body';
    this.$root = null;
    // Define in ms the delay in a switch of items (prepare next ->delay-> hide current, show next)
    // NOTE: as of testing in iOS 8.3 iPad2 (slow), 140ms ended being a good default
    // to avoid some flickering effects, enough to let initialization logic to finish before
    // being showed, allow some common async redirects when executing an item logic but
    // enough quick to not being visually perceived the delay.
    // NOTE: on tests on Nexus 5 Android 5.1 with Chrome engine, 40ms was enought to have all the previous
    // benefits, but was too quick for iOS (even 100ms was too quick for iOS 8.3).
    var defaultDelay = 140;
    // NOTE:UPDATE: Using WkWebView on iOS (8.x with unofficial plugin with webserver, 9.x will be with official support no-webserver)
    // it's fastest, so trying user-agent sniffing to use the fastest delay on this engine, chrome engine or desktop (non-mobile)
    // and left he conservative delay for other cases (old iOS/webview, old android webkit engine).
    var flags = getFlags();
    // if not is mobile OR is Chrome OR is WKWebview
    if (!flags.isMobile || flags.isChrome || flags.isWkWebview)
        defaultDelay = 40;
    
    this.switchDelay = settings.switchDelay || defaultDelay;
}

module.exports = DomItemsManager;

DomItemsManager.prototype.getAllItems = function getAllItems() {
    return this.$root.children('[' + this.idAttributeName + ']');
};

DomItemsManager.prototype.find = function find(containerName, root) {
    var $root = $(root || this.$root);
    return $root.children('[' + this.idAttributeName + '="' + escapeSelector(containerName) + '"]');
};

DomItemsManager.prototype.getActive = function getActive() {
    return this.$root.children('[' + this.idAttributeName + ']:visible');
};

/**
    It adds the item in the html provided (can be only the element or 
    contained in another or a full html page).
    Replaces any existant if duplicates are not allowed.
**/
DomItemsManager.prototype.inject = function inject(name, html) {

    // Filtering input html (can be partial or full pages)
    // http://stackoverflow.com/a/12848798
    html = html.replace(/^[\s\S]*<body.*?>|<\/body>[\s\S]*$/g, '');

    // Creating a wrapper around the html
    // (can be provided the innerHtml or outerHtml, doesn't matters with next approach)
    var $html = $('<div/>', { html: html }),
        // We look for the container element (when the outerHtml is provided)
        $c = this.find(name, $html);

    if ($c.length === 0) {
        // Its innerHtml, so the wrapper becomes the container itself
        $c = $html.attr(this.idAttributeName, name);
    }

    if (!this.allowDuplicates) {
        // No more than one container instance can exists at the same time
        // We look for any existent one and its replaced with the new
        var $prev = this.find(name);
        if ($prev.length > 0) {
            $prev.replaceWith($c);
            $c = $prev;
        }
    }

    // Add to the document
    // (on the case of duplicated found, this will do nothing, no worry)
    $c.appendTo(this.$root);
};

/** 
    The switch method receive the items to interchange as active or current,
    the 'from' and 'to', and the shell instance that MUST be used
    to notify each event that involves the item:
    willClose, willOpen, ready, opened, closed.
    It receives as latest parameter the 'notification' object that must be
    passed with the event so handlers has context state information.
    
    It's designed to be able to manage transitions, but this default
    implementation is as simple as 'show the new and hide the old'.
**/
DomItemsManager.prototype.switch = function switchActiveItem($from, $to, shell, state) {

    var toName = state.route.name;
    //console.log('switch to', toName);
    
    this.disableAccess();
    
    function hideit() {
        var fromIsHidden = $from.is('[hidden]');
        if ($from.length > 0 && !fromIsHidden) {
            shell.emit(shell.events.willClose, $from, state);
            // Do 'unfocus' on the hidden element after notify 'willClose'
            // for better UX: hidden elements are not reachable and has good
            // side effects like hidding the on-screen keyboard if an input was
            // focused
            $from.find(':focus').blur();
            // hide and notify it ended
            $from
            .attr('hidden', 'hidden')
            // For browser that don't support attr
            .css('display', 'none')
            // Reset z-index to avoid overlapping effect
            .css('z-index', '');

            shell.emit(shell.events.closed, $from, state);
        }
        else {
            // Just unfocus to avoid keyboard problems
            $from.find(':focus').blur();
        }
    }

    var toIsHidden = $to.is('[hidden]'); // !$to.is(':visible')

    if (toIsHidden) {
        shell.emit(shell.events.willOpen, $to, state);
        // Put outside screen
        /* DONE ALREADY in the CSS class assigned to items
        $to.css({
            position: 'absolute',
            zIndex: -1,
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        });*/
        $to.css('zIndex', -1);

        // Show it:
        $to
        .removeAttr('hidden')
        // For browser that don't support attr
        .css('display', 'block');

        // Its enough visible and in DOM to perform initialization tasks
        // that may involve layout information
        shell.emit(shell.events.itemReady, $to, state);
        
        //console.log('SWITCH ready done, wait', toName);

        // Finish in a small delay, enough to allow some initialization
        // set-up that take some time to finish avoiding flickering effects
        setTimeout(function() {
            //console.log('SWITCH entering hide-show for', toName, shell.currentRoute.name);
            //console.log('ending switch to', toName, 'and current is', shell.currentRoute.name);
            // Race condition, redirection in the middle, abort:
            if (toName !== shell.currentRoute.name)
                return;
            
            // Hide the from
            hideit();
            
            // Ends opening, reset transitional styles
            /* SETUP IS ALREADY CORRECT in the CSS class assigned to items
            $to.css({
                position: '',
                top: '',
                bottom: '',
                left: '',
                right: '',
                zIndex: 2
            });
            */
            $to.css('zIndex', 2);
            
            this.enableAccess();
            
            //console.log('SWITCH ended for', toName);

            // When its completely opened
            shell.emit(shell.events.opened, $to, state);
        }.bind(this), this.switchDelay);
    } else {
        //console.log('ending switch to', toName, 'and current is', shell.currentRoute.name, 'INSTANT (to was visible)');
        // Race condition, redirection in the middle, abort:
        if (toName !== shell.currentRoute.name)
            return;
        
        // Its ready; maybe it was but sub-location
        // or state change need to be communicated
        shell.emit(shell.events.itemReady, $to, state);
        
        this.enableAccess();
        
        hideit();
    }
};

/**
    Initializes the list of items. No more than one
    must be opened/visible at the same time, so at the 
    init all the elements are closed waiting to set
    one as the active or the current one.
    
    Execute after DOM ready.
**/
DomItemsManager.prototype.init = function init() {
    // On ready, get the root element:
    this.$root = $(this.root || 'body');

    this.getAllItems()
    .attr('hidden', 'hidden')
    // For browser that don't support attr
    .css('display', 'none');
    
    // A layer to visually hide an opening item while not completed opened
    $('<div class="items-backstage"/>').css({
        background: this.$root.css('background-color') || 'white',
        position: 'fixed',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        zIndex: 0
    }).appendTo(this.$root);
    
    // A layer to disable access to an item (disabling events)
    // NOTE: Tried CSS pointer-events:none has some strange side-effects: auto scroll-up.
    // TODO: After some testing with this, scroll-up happens again with this (??)
    var $disableLayer = $('<div class="items-disable-layer"/>').css({
        background: 'White',
        opacity: 0,
        position: 'fixed',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        zIndex: -1
    }).appendTo(this.$root);
    this.disableAccess = function() {
        $disableLayer.css('zIndex', 90900);
    };
    this.enableAccess = function() {
        $disableLayer.css('zIndex', -2);
    };
};

},{"../escapeSelector":173,"../userAgentFlags":194}],184:[function(require,module,exports){
/**
    Javascritp Shell for SPAs.
**/
/*global window, document */
'use strict';

/** DI entry points for default builds. Most dependencies can be
    specified in the constructor settings for per-instance setup.
**/
var deps = require('./dependencies');

/** Constructor **/

function Shell(settings) {
    //jshint maxcomplexity:14
    
    deps.EventEmitter.call(this);

    this.$ = settings.jquery || deps.jquery;
    this.$root = this.$(settings.root);
    this.baseUrl = settings.baseUrl || '';
    // With forceHashbang=true:
    // - fragments URLs cannot be used to scroll to an element (default browser behavior),
    //   they are defaultPrevented to avoid confuse the routing mechanism and current URL.
    // - pressed links to fragments URLs are not routed, they are skipped silently
    //   except when they are a hashbang (#!). This way, special links
    //   that performn js actions doesn't conflits.
    // - all URLs routed through the shell includes a hashbang (#!), the shell ensures
    //   that happens by appending the hashbang to any URL passed in (except the standard hash
    //   that are skipt).
    this.forceHashbang = settings.forceHashbang || false;
    this.linkEvent = settings.linkEvent || 'click';
    this.parseUrl = (settings.parseUrl || deps.parseUrl).bind(this, this.baseUrl);
    this.absolutizeUrl = (settings.absolutizeUrl || deps.absolutizeUrl).bind(this, this.baseUrl);

    this.history = settings.history || window.history;

    this.indexName = settings.indexName || 'index';
    
    this.items = settings.domItemsManager;

    // loader can be disabled passing 'null', so we must
    // ensure to not use the default on that cases:
    this.loader = typeof(settings.loader) === 'undefined' ? deps.loader : settings.loader;
    // loader setup
    if (this.loader)
        this.loader.baseUrl = this.baseUrl;

    // Definition of events that this object can trigger,
    // its value can be customized but any listener needs
    // to keep updated to the correct event string-name used.
    // The items manipulation events MUST be triggered
    // by the 'items.switch' function
    this.events = {
        willOpen: 'shell-will-open',
        willClose: 'shell-will-close',
        itemReady: 'shell-item-ready',
        closed: 'shell-closed',
        opened: 'shell-opened'
    };
    
    /**
        A function to decide if the
        access is allowed (returns 'null')
        or not (return a state object with information
        that will be passed to the 'nonAccessName' item;
        the 'route' property on the state is automatically filled).
        
        The default buit-in just allow everything 
        by just returning 'null' all the time.
        
        It receives as parameter the state object,
        that almost contains the 'route' property with
        information about the URL.
    **/
    this.accessControl = settings.accessControl || deps.accessControl;
    // What item load on non access
    this.nonAccessName = settings.nonAccessName || 'index';
    
    // Access to the current route
    this.currentRoute = null;
    // Access to referrer/previous route
    this.referrerRoute = null;
}

// Shell inherits from EventEmitter
Shell.prototype = Object.create(deps.EventEmitter.prototype, {
    constructor: {
        value: Shell,
        enumerable: false,
        writable: true,
        configurable: true
    }
});

module.exports = Shell;


/** API definition **/

Shell.prototype.go = function go(url, state) {

    if (this.forceHashbang) {
        if (!/^#!/.test(url)) {
            url = '#!' + url;
        }
    }
    else {
        url = this.absolutizeUrl(url);
    }
    this.history.pushState(state, undefined, url);
    // pushState do NOT trigger the popstate event, so
    return this.replace(state);
};

Shell.prototype.goBack = function goBack(state, steps) {
    steps = 0 - (steps || 1);
    // If there is nothing to go-back or not enought
    // 'back' steps, go to the index
    if (steps < 0 && Math.abs(steps) >= this.history.length) {
        this.go(this.indexName);
    }
    else {
        // On replace, the passed state is merged with
        // the one that comes from the saved history
        // entry (it 'pops' when doing the history.go())
        this._pendingStateUpdate = state;
        this.history.go(steps);
    }
};

/**
    Process the given state in order to get the current state
    based on that or the saved in history, merge it with
    any updated state pending and adds the route information,
    returning an state object suitable to use.
**/
Shell.prototype.getUpdatedState = function getUpdatedState(state) {
    /*jshint maxcomplexity: 8 */
    
    // For current uses, any pendingStateUpdate is used as
    // the state, rather than the provided one
    state = this._pendingStateUpdate || state || this.history.state || {};
    
    // TODO: more advanced uses must be to use the 'state' to
    // recover the UI state, with any message from other UI
    // passing in a way that allow update the state, not
    // replace it (from pendingStateUpdate).
    /*
    // State or default state
    state = state || this.history.state || {};
    // merge pending updated state
    this.$.extend(state, this._pendingStateUpdate);
    // discard the update
    */
    this._pendingStateUpdate = null;
    
    // Doesn't matters if state includes already 
    // 'route' information, need to be overwritten
    // to match the current one.
    // NOTE: previously, a check prevented this if
    // route property exists, creating infinite loops
    // on redirections from activity.show since 'route' doesn't
    // match the new desired location
    
    // Detect if is a hashbang URL or an standard one.
    // Except if the app is forced to use hashbang.
    var isHashBang = /#!/.test(location.href) || this.forceHashbang;
    
    var link = (
        isHashBang ?
        location.hash :
        location.pathname
    );
    // Is better to do this check here, because the hash can contain a query (even if
    // not valid for URL query, is valid for hashbang queries)
    if (location.search) {
        var sep = link.indexOf('?') !== -1 ? '&' : '?';
        link += sep + location.search.substr(1);
    }
    
    // Set the route
    state.route = this.parseUrl(link);
    
    return state;
};

Shell.prototype._getLocationRoutedUrl = function() {
    var reg = /^#!/;
    return reg.test(window.location.hash) ? window.location.hash : window.location.pathname + window.location.search + window.location.hash;
};

/**
    Internal use only.
    Update the URL/route saved as Referrer using the current one from location.
**/
Shell.prototype._refreshReferrer = function() {
    this.referrerRoute = this.parseUrl(this._getLocationRoutedUrl());
};
Shell.prototype._refreshCurrent = function() {
    this.currentRoute = this.parseUrl(this._getLocationRoutedUrl());
};

/**
    Shortcut to history.replaceState API that keeps some internal Shell state correct.
**/
Shell.prototype.replaceState = function replaceState(state, title, url) {
    this._refreshReferrer();
    this.history.replaceState(state, title, url);
    this._refreshCurrent();
};

/**
    Shortcut to history.replaceState API that keeps some internal Shell state correct.
**/
Shell.prototype.pushState = function pushState(state, title, url) {
    this._refreshReferrer();
    this.history.pushState(state, title, url);
    this._refreshCurrent();
};

Shell.prototype.replace = function replace(state) {
    
    state = this.getUpdatedState(state);

    // Use the index on root calls
    if (state.route.root === true) {
        state.route = this.parseUrl(this.indexName);
    }
    this.referrerRoute = this.currentRoute;
    this.currentRoute = state.route;
    //console.log('shell replace', state.route);

    // Access control
    var accessError = this.accessControl(state.route);
    if (accessError) {
        return this.go(this.nonAccessName, accessError);
    }

    // Locating the container
    var $cont = this.items.find(state.route.name);
    var shell = this;
    var promise = null;

    if ($cont && $cont.length) {
        promise = new Promise(function(resolve, reject) {
            try {

                var $oldCont = shell.items.getActive();
                $oldCont = $oldCont.not($cont);
                shell.items.switch($oldCont, $cont, shell, state);
                //console.log('shell replace after switch', state.route);

                resolve(); //? resolve(act);
            }
            catch (ex) {
                reject(ex);
            }
        });
    }
    else {
        if (this.loader) {
            // load and inject the content in the page
            // then try the replace again
            promise = this.loader.load(state.route).then(function(html) {
                // Add to the items (the manager takes care you
                // add only the item, if there is one)
                shell.items.inject(state.route.name, html);
                // Double check that the item was added and is ready
                // to avoid an infinite loop because a request not returning
                // the item and the 'replace' trying to load it again, and again, and..
                if (shell.items.find(state.route.name).length)
                    return shell.replace(state);
            });
        }
        else {
            var err = new Error('Page not found (' + state.route.name + ')');
            console.warn('Shell Page not found, state:', state);
            promise = Promise.reject(err);
            
            // To avoid being in an inexistant URL (generating inconsistency between
            // current view and URL, creating bad history entries),
            // a goBack is executed, just after the current pipe ends
            // TODO: implement redirect that cut current processing rather than execute delayed
            setTimeout(function() {
                this.goBack();
            }.bind(this), 1);
        }
    }
    
    var thisShell = this;
    promise.catch(function(err) {
        if (!(err instanceof Error))
            err = new Error(err);

        // Log error, 
        console.error('Shell, unexpected error.', err);
        // notify as an event
        thisShell.emit('error', err);
        // and continue propagating the error
        return err;
    });

    return promise;
};

Shell.prototype.run = function run() {

    var shell = this;

    // Catch popstate event to update shell replacing the active container.
    // Allows polyfills to provide a different but equivalent event name
    this.$(window).on(this.history.popstateEvent || 'popstate', function(event) {
        
        var state = event.state || 
            (event.originalEvent && event.originalEvent.state) || 
            shell.history.state;

        // get state for current. To support polyfills, we use the general getter
        // history.state as fallback (they must be the same on browsers supporting History API)
        shell.replace(state);
    });

    // TODO: Review if all this next still is usable and has use cases, since the project
    // now uses fastclick library to avoid the iOS delay, using again click against tap event.
    //
    // Catch all links in the page (not only $root ones) and like-links.
    // IMPORTANT: the timeout and linkWorking is a kind of hack/workaround because of:
    // - iOS click delay: changing linkEvent to be 'tap click' (jqm tap event) or 
    //   more standard but simplistic 'touchend click', only on iOS if possible, the
    //   iOS click delay can be avoided, letting the touch event to trigger this Shell handler
    //   and preventing the click from happening to avoid double execution
    //   (thanks to linkWorking and setTimeout).
    //   A broken alternative would be to use only one event, like 'tap' or 'touchend', but
    //   they fall down when a touch gesture happens in the limit of a link/element because
    //   a touchstart happens out of our target link -failing touchend and tap since don't 
    //   get triggered in our link- but the browser/webview still executes (and inmediatly)
    //   the 'click' event on the link. It seems an edge case but is easier to make it happens
    //   than it seems. It's the bug that forced to implement this workaournd :-/
    // - And additionally: it prevents two 'clicks' from happening excessive fast because
    //   some kind of a second unwanted touch happening very fast, making
    //   a click by mistake on a different link on the loaded new page.
    var linkWorking = null,
        // OLD: iOS 300ms delay, a bit increased to avoid problems.
        // NOTE: as of inclusion of fastclick in the main project, reduced
        // this delay to avoid being noticeable on some edge cases, but still
        // preserving because other not verified use cases (like on a touch on a link that dynamically
        // changes being perceived as two quick consecutive clicks, executing two actions in one and that being unwanted)
        linkWorkingDelay = 80; // 340; // ms
    //DEBUG var linkEvent = this.linkEvent;
    this.$(document).on(this.linkEvent, '[href], [data-href]', function(e) {
        //DEBUG console.log('Shell on event', e.type, linkWorking);
        // If working, avoid everything:
        if (linkWorking) return false;
        linkWorking = setTimeout(function() {
            linkWorking = null;
        }, linkWorkingDelay);

        var $t = shell.$(this),
            href = $t.attr('href') || $t.data('href');
        
        //DEBUG console.log('Shell on', linkEvent, e.type, 'href', href, 'element', $t);

        // Do nothing if the URL contains the protocol
        if (/^[a-z]+:/i.test(href)) {
            return;
        }
        else if (shell.forceHashbang && /^#([^!]|$)/.test(href)) {
            // Standard hash, but not hashbang: avoid routing and default behavior
            e.preventDefault();
            // Trigger special event on the shell, so external scripts can do
            // something, like trying to implement standard scroll behavior or any
            // Pass in: source fragment link, element that receive the original event and
            // the original event.
            shell.emit('fragmentNavigation', href, this, e);
            return;
        }

        e.preventDefault();

        // Executed delayed to avoid handler collisions, because
        // of the new page modifying the element and other handlers
        // reading it attributes and applying logic on the updated link
        // as if was the old one (example: shared links, like in a
        // global navbar, that modifies with the new page).
        setTimeout(function() {
            shell.go(href);
        }, 1);
    });

    // Initiallize state
    this.items.init();
    // Route to the current url/state
    this.replace();
};

},{"./dependencies":186}],185:[function(require,module,exports){
/**
    absolutizeUrl utility 
    that ensures the url provided
    being in the path of the given baseUrl
**/
'use strict';

var sanitizeUrl = require('./sanitizeUrl'),
    escapeRegExp = require('../escapeRegExp');

function absolutizeUrl(baseUrl, url) {

    // sanitize before check
    url = sanitizeUrl(url);

    // Check if use the base already
    var matchBase = new RegExp('^' + escapeRegExp(baseUrl), 'i');
    if (matchBase.test(url)) {
        return url;
    }

    // build and sanitize
    return sanitizeUrl(baseUrl + url);
}

module.exports = absolutizeUrl;

},{"../escapeRegExp":172,"./sanitizeUrl":191}],186:[function(require,module,exports){
/**
    External dependencies for Shell in a separate module
    to use as DI, needs setup before call the Shell.js
    module class
**/
'use strict';

module.exports = {
    parseUrl: null,
    absolutizeUrl: null,
    jquery: null,
    loader: null,
    accessControl: function allowAll(/*name*/) {
        // allow access by default
        return null;
    },
    EventEmitter: null
};

},{}],187:[function(require,module,exports){
/**
    Simple implementation of the History API using only hashbangs URLs,
    doesn't matters the browser support.
    Used to avoid from setting URLs that has not an end-point,
    like in local environments without a server doing url-rewriting,
    in phonegap apps, or to completely by-pass browser support because
    is buggy (like Android <= 4.1).
    
    NOTES:
    - Browser must support 'hashchange' event.
    - Browser must has support for standard JSON class.
    - Relies on sessionstorage for persistance, supported by all browsers and webviews 
      for a enough long time now.
    - Similar approach as History.js polyfill, but simplified, appending a fake query
      parameter '_suid=0' to the hash value (actual query goes before the hash, but
      we need it inside).
    - For simplification, only the state is persisted, the 'title' parameter is not
      used at all (the same as major browsers do, so is not a problem); in this line,
      only history entries with state are persisted.
      
    TODO replaceState does not work as expected, it creates a history entry rather than replace it
        A solution idea is to perform a browser go(-1) and the then hash change (push), but the go back
        must bypass the events notification.
**/
//global location
'use strict';
var $ = require('jquery'),
    sanitizeUrl = require('./sanitizeUrl'),
    getUrlQuery = require('../getUrlQuery');

// Init: Load saved copy from sessionStorage
var session = sessionStorage.getItem('hashbangHistory.store');
// Or create a new one
if (!session) {
    session = {
        // States array where each index is the SUID code and the
        // value is just the value passed as state on pushState/replaceState
        states: []
    };
}
else {
    session = JSON.parse(session);
}


/**
    Get the SUID number
    from a hash string
**/
function getSuid(hash) {
    
    var suid = +getUrlQuery(hash)._suid;
    if (isNaN(suid))
        return null;
    else
        return suid;
}

function setSuid(hash, suid) {
    
    // We need the query, since we need 
    // to replace the _suid (may exist)
    // and recreate the query in the
    // returned hash-url
    var qs = getUrlQuery(hash);
    qs.push('_suid');
    qs._suid = suid;

    var query = [];
    for(var i = 0; i < qs.length; i++) {
        query.push(qs[i] + '=' + encodeURIComponent(qs[qs[i]]));
    }
    query = query.join('&');
    
    if (query) {
        var index = hash.indexOf('?');
        if (index > -1)
            hash = hash.substr(0, index);
        hash += '?' + query;
    }

    return hash;
}

/**
    Ask to persist the session data.
    It is done with a timeout in order to avoid
    delay in the current task mainly any handler
    that acts after a History change.
**/
function persist() {
    // Enough time to allow routing tasks,
    // most animations from finish and the UI
    // being responsive.
    // Because sessionStorage is synchronous.
    setTimeout(function() {
        sessionStorage.setItem('hashbangHistory.store', JSON.stringify(session));
    }, 1500);
}

/**
    Returns the given state or null
    if is an empty object.
**/
function checkState(state) {
    
    if (state) {
        // is empty?
        if (Object.keys(state).length > 0) {
            // No
            return state;
        }
        // its empty
        return null;
    }
    // Anything else
    return state;
}

/**
    Get a canonical representation
    of the URL so can be compared
    with success.
**/
function cannonicalUrl(url) {
    
    // Avoid some bad or problematic syntax
    url = sanitizeUrl(url || '');
    
    // Get the hash part
    var ihash = url.indexOf('#');
    if (ihash > -1) {
        url = url.substr(ihash + 1);
    }
    // Maybe a hashbang URL, remove the
    // 'bang' (the hash was removed already)
    url = url.replace(/^!/, '');

    return url;
}

/**
    Tracks the latest URL
    being pushed or replaced by
    the API.
    This allows later to avoid
    trigger the popstate event,
    since must NOT be triggered
    as a result of that API methods
**/
var latestPushedReplacedUrl = null;

/**
    History Polyfill
**/
var hashbangHistory = {
    pushState: function pushState(state, title, url) {

        // cleanup url
        url = cannonicalUrl(url);
        
        // save new state for url
        state = checkState(state) || null;
        if (state !== null) {
            // save state
            session.states.push(state);
            var suid = session.states.length - 1;
            // update URL with the suid
            url = setSuid(url, suid);
            // call to persist the updated session
            persist();
        }
        
        latestPushedReplacedUrl = url;
        
        // update location to track history:
        location.hash = '#!' + url;
    },
    replaceState: function replaceState(state, title, url) {
        
        // cleanup url
        url = cannonicalUrl(url);
        
        // it has saved state?
        var suid = getSuid(url),
            hasOldState = suid !== null;

        // save new state for url
        state = checkState(state) || null;
        // its saved if there is something to save
        // or something to destroy
        if (state !== null || hasOldState) {
            // save state
            if (hasOldState) {
                // replace existing state
                session.states[suid] = state;
                // the url remains the same
            }
            else {
                // create state
                session.states.push(state);
                suid = session.states.length - 1;
                // update URL with the suid
                url = setSuid(url, suid);
            }
            // call to persist the updated session
            persist();
        }
        
        latestPushedReplacedUrl = url;

        // update location to track history:
        location.hash = '#!' + url;
    },
    get state() {
        
        var suid = getSuid(location.hash);
        return (
            suid !== null ?
            session.states[suid] :
            null
        );
    },
    get length() {
        return window.history.length;
    },
    go: function go(offset) {
        window.history.go(offset);
    },
    back: function back() {
        window.history.back();
    },
    forward: function forward() {
        window.history.forward();
    }
};

// Attach hashcange event to trigger History API event 'popstate'
var $w = $(window);
$w.on('hashchange', function(e) {
    
    var url = e.originalEvent.newURL;
    url = cannonicalUrl(url);
    
    // An URL being pushed or replaced
    // must NOT trigger popstate
    if (url === latestPushedReplacedUrl)
        return;
    
    // get state from history entry
    // for the updated URL, if any
    // (can have value when traversing
    // history).
    var suid = getSuid(url),
        state = null;
    
    if (suid !== null)
        state = session.states[suid];

    $w.trigger(new $.Event('popstate', {
        state: state
    }), 'hashbangHistory');
});

// For HistoryAPI capable browsers, we need
// to capture the native 'popstate' event that
// gets triggered on our push/replaceState because
// of the location change, but too on traversing
// the history (back/forward).
// We will lock the event except when is
// the one we trigger.
//
// NOTE: to this trick to work, this must
// be the first handler attached for this
// event, so can block all others.
// ALTERNATIVE: instead of this, on the
// push/replaceState methods detect if
// HistoryAPI is native supported and
// use replaceState there rather than
// a hash change.
$w.on('popstate', function(e, source) {
    
    // Ensuring is the one we trigger
    if (source === 'hashbangHistory')
        return;
    
    // In other case, block:
    e.preventDefault();
    e.stopImmediatePropagation();
});

// Expose API
module.exports = hashbangHistory;

},{"../getUrlQuery":177,"./sanitizeUrl":191}],188:[function(require,module,exports){
/**
    Default build of the Shell component.
    It returns the Shell class as a module property,
    setting up the built-in modules as its dependencies,
    and the external 'jquery' and 'events' (for the EventEmitter).
    It returns too the built-it DomItemsManager class as a property for convenience.
**/
'use strict';

var deps = require('./dependencies'),
    DomItemsManager = require('./DomItemsManager'),
    parseUrl = require('./parseUrl'),
    absolutizeUrl = require('./absolutizeUrl'),
    $ = require('jquery'),
    loader = require('./loader'),
    EventEmitter = require('events').EventEmitter;

$.extend(deps, {
    parseUrl: parseUrl,
    absolutizeUrl: absolutizeUrl,
    jquery: $,
    loader: loader,
    EventEmitter: EventEmitter
});

// Dependencies are ready, we can load the class:
var Shell = require('./Shell');

exports.Shell = Shell;
exports.DomItemsManager = DomItemsManager;

},{"./DomItemsManager":183,"./Shell":184,"./absolutizeUrl":185,"./dependencies":186,"./loader":189,"./parseUrl":190,"events":false}],189:[function(require,module,exports){
/**
    Loader utility to load Shell items on demand with AJAX
**/
'use strict';

var $ = require('jquery');

module.exports = {
    
    baseUrl: '/',
    
    load: function load(route) {
        return new Promise(function(resolve, reject) {
            console.log('Shell loading on demand', route.name, route);
            $.ajax({
                url: module.exports.baseUrl + route.name + '.html',
                cache: false
                // We are loading the program and no loader screen in place,
                // so any in between interaction will be problematic.
                //async: false
            }).then(resolve, reject);
        });
    }
};

},{}],190:[function(require,module,exports){
/**
    parseUrl function detecting
    the main parts of the URL in a
    convenience way for routing.
**/
'use strict';

var getUrlQuery = require('../getUrlQuery'),
    escapeRegExp = require('../escapeRegExp');

function parseUrl(baseUrl, link) {

    link = link || '';

    var rawUrl = link;

    // hashbang support: remove the #! or single # and use the rest as the link
    link = link.replace(/^#!/, '').replace(/^#/, '');
    
    // remove optional initial slash or dot-slash
    link = link.replace(/^\/|^\.\//, '');

    // URL Query as an object, empty object if no query
    var query = getUrlQuery(link || '?');

    // remove query from the rest of URL to parse
    link = link.replace(/\?.*$/, '');

    // Remove the baseUrl to get the app base.
    var path = link.replace(new RegExp('^' + escapeRegExp(baseUrl), 'i'), '');

    // Get first segment or page name (anything until a slash or extension beggining)
    var match = /^\/?([^\/\.]+)[^\/]*(\/.*)*$/.exec(path);

    var parsed = {
        root: true,
        name: null,
        segments: null,
        path: null,
        url: rawUrl,
        query: query
    };

    if (match) {
        parsed.root = false;
        if (match[1]) {
            parsed.name = match[1];

            if (match[2]) {
                parsed.path = match[2];
                parsed.segments = match[2].replace(/^\//, '').split('/');
            }
            else {
                parsed.path = '/';
                parsed.segments = [];
            }
        }
    }

    return parsed;
}

module.exports = parseUrl;
},{"../escapeRegExp":172,"../getUrlQuery":177}],191:[function(require,module,exports){
/**
    sanitizeUrl utility that ensures
    that problematic parts get removed.
    
    As for now it does:
    - removes parent directory syntax
    - removes duplicated slashes
**/
'use strict';

function sanitizeUrl(url) {
    return url.replace(/\.{2,}/g, '').replace(/\/{2,}/g, '/');
}

module.exports = sanitizeUrl;
},{}],192:[function(require,module,exports){
/**
    snapPoints.
    
    Allows to register for a jQuery element a series of
    scroll vertical positions (aka 'snap points') that
    will trigger a custom event (providing a name per snap point)
    that will be triggered then a scroll changes the
    current relative position with that point, being
    the relation 'before', 'after' or 'there'.
    Only triggers when there is a change (it remember previous registered
    state).
    
    The execution of each check on scrolling is throttle to avoid burst,
    being the precision of that throttle configurable throught the third
    parameter (in milliseconds). By default has a value that 'teorically'
    can enable reactions at 60fps.
    Can be completely disabled by passing 0 as precision, and the event
    will be triggered synchronously when scroll happens.
    
    TODO Allow horizontal points
**/

var $ = require('jquery'),
    throttle = require('iagosrl/throttle');

module.exports = function snapPoints($scrollerElement, points, precision) {
    //jshint maxcomplexity:8
    if (!points || !Object.keys(points).length) return;
    $scrollerElement = $scrollerElement || $(window);
    // 60fps precision by default
    precision = precision === 0 ? 0 : Math.abs(precision |0) || 16;
    
    var record = {};

    var checkScroll = function() {
        var top = $scrollerElement.scrollTop();
        Object.keys(points).forEach(function(point) {
            //jshint maxcomplexity:8
            point = point |0;
            var type;
            if (point === top) {
                if (record[point] !== 'there')
                    type = 'there';
            }
            else if (top > point) {
                if (record[point] !== 'after')
                    type = 'after';
            }
            else {
                if (record[point] !== 'before')
                    type = 'before';
            }
            if (type) {
                $scrollerElement.trigger(points[point], [type]);
                record[point] = type;
            }
        });
    };
    if (precision > 0)
        checkScroll = throttle(checkScroll , precision);

    $scrollerElement.scroll(checkScroll);
    // First time check
    checkScroll();
};

},{}],193:[function(require,module,exports){
/**
    Small utility to search a text fragment using
    case insensitive, accent/symbol insensitive.
**/
'use strict';

var removeAccent = require('./removeAccent');

module.exports = function textSearch(search, text) {

    var s = removeAccent(search || '').toLowerCase(),
        t = removeAccent(text || '').toLowerCase();

    return t.indexOf(s) > -1;
};

},{"./removeAccent":181}],194:[function(require,module,exports){
/**
    User agent sniffing. Because sometimes is needed.
**/
//global window
'use strict';

module.exports = function getFlags() {
    if (window.navigator && window.navigator.userAgent) {
        var ua = window.navigator.userAgent;
        var iOsWebview = /iOS|iPad|iPhone|iPod/.test(ua);
        var iOsVersion = /OS ((\d+_?){2,3})\s/.exec(ua);
        if (iOsVersion && iOsVersion.length > 1) {
            iOsVersion = { full: iOsVersion[1] || '' };
            iOsVersion.parts = iOsVersion.full.split('_');
            iOsVersion.major = iOsVersion.parts[0] |0;
            iOsVersion.minor = iOsVersion.parts[1] |0;
            iOsVersion.revision = iOsVersion.parts[2] |0;
        }
        // NO WAY to detect wkwebview versus uiwebview, we just use wkwebview on iOS 9 and later
        // so next assumption works for us:
        var isWkWebview = iOsVersion && iOsVersion.major >= 9;
        var isAndroid = /Android/.test(ua);
        // Chrome, browser or webview https://developer.chrome.com/multidevice/user-agent  Old webkit webviews gets discarded
        var isChrome = /Chrome\//.test(ua);
        var isMobile = iOsWebview || isAndroid;

        return {
            isIos: iOsWebview,
            iOsVersion: iOsVersion,
            isWkWebview: isWkWebview,
            isAndroid: isAndroid,
            isChrome: isChrome,
            isMobile: isMobile
        };
    }
    
    return {};
};

},{}],195:[function(require,module,exports){
/** AppointmentCard view model.
    It provides data and method to visualize and 
    edit and appointment card, with booking, event
    or placeholder information
**/

var ko = require('knockout'),
    moment = require('moment'),
    getObservable = require('../utils/getObservable'),
    Appointment = require('../models/Appointment'),
    AppointmentView = require('../viewmodels/AppointmentView'),
    ModelVersion = require('../utils/ModelVersion'),
    getDateWithoutTime = require('../utils/getDateWithoutTime'),
    PricingSummaryDetail = require('../models/PricingSummaryDetail');

function AppointmentCardViewModel(params) {
    /*jshint maxstatements: 40*/

    this.sourceItem = getObservable(params.sourceItem);
    var app = this.app = ko.unwrap(params.app);

    this.editMode = getObservable(params.editMode);
    this.editedVersion = ko.observable(null);
    
    this.isSaving = ko.observable(false);
    this.isLoading = getObservable(params.isLoading);
    this.isLocked = ko.computed(function() {
        return this.isSaving() || this.isLoading();
    }, this);
    
    this.item = ko.observable(AppointmentView(this.sourceItem(), app));
    
    this.allowBookUnavailableTime = ko.observable(false);
    
    this.currentID = ko.pureComputed(function() {
        var it = this.item();
        return it && it.id() || 0;
    }, this);
    
    this.currentDatetime = ko.pureComputed(function() {
        return this.item() && this.item().startTime() || new Date();
    }, this);
    
    this.currentDate = ko.pureComputed(function() {
        return getDateWithoutTime(this.item() && this.item().startTime());
    }, this);
    
    this.isNew = ko.computed(function() {
        var id = this.currentID();
        return id === Appointment.specialIds.newBooking || id === Appointment.specialIds.newEvent;
    }, this);
    
    this.isBooking = ko.computed(function() {
        return this.item() && this.item().sourceBooking();
    }, this);
    
    /* Return true if is an event object but not a booking */
    this.isEvent = ko.computed(function() {
        return this.item() && this.item().sourceEvent() && !this.item().sourceBooking();
    }, this);
    
    this.headerClass = ko.pureComputed(function() {
        return (
            this.isBooking() ? (this.editMode() ? 'Card-title--warning' : 'Card-title--primary') :
            this.isEvent() ? 'Card-title--danger' :
            ''
        );
    }, this);
    
    this.newAppointmentVisible = ko.pureComputed(function() {
        var id = this.currentID();
        return id === Appointment.specialIds.free || id === Appointment.specialIds.emptyDate || id === Appointment.specialIds.unavailable;
    }, this);
    
    this.editScheduleVisible = ko.pureComputed(function() {
        return this.currentID() === Appointment.specialIds.unavailable;
    }, this);
    
    this.submitText = ko.pureComputed(function() {
        var v = this.editedVersion();
        return (
            this.isLoading() ? 
                'Loading...' : 
                this.isSaving() ? 
                    'Saving changes' : 
                    v && v.areDifferent() ?
                        this.isNew() && this.isBooking() ?
                            'Book' :
                            'Save changes'
                        : 'Saved'
        );
    }, this);

    /**
        If the sourceItem changes, is set as the item value
        discarding any model version and reverting
        editMode to false
    **/
    this.sourceItem.subscribe(function(sourceItem) {
        this.item(AppointmentView(sourceItem, app));
        this.editedVersion(null);
        this.editMode(false);

        // If the new item is a new one, set edit mode
        if (this.isNew()) {
            this.editMode(true);
        }
    }, this);

    /**
        Enter and finish edit:
        Create version and save data
    **/
    this.editMode.subscribe(function(isEdit) {
        if (this.currentID() <= 0 && !this.isNew()) {
            return;
        }
        if (isEdit) {
            // Create and set a version to be edited
            var version = new ModelVersion(this.sourceItem());
            version.version.sourceEvent(this.sourceItem().sourceEvent());
            version.version.sourceBooking(this.sourceItem().sourceBooking());
            this.editedVersion(version);
            this.item(AppointmentView(version.version, app));
            
            if (this.isNew() && this.isEvent()) {
                // Some defaults for events
                this.item().sourceEvent().availabilityTypeID(0); // Unavailable
                this.item().isAllDay(false);
                this.item().sourceEvent().eventTypeID(3); // Appointment/block-time
                this.item().summary('');
            }
        }
        else {
            this.item(AppointmentView(this.sourceItem(), app));
        }
    }, this);

    this.edit = function edit() {
        if (this.isLocked()) return;

        // A subscribed handler ensure to do the needed tasks
        this.editMode(true);
    }.bind(this);
    
    this.save = function save() {
        if (this.isLocked()) return;

        // There is a version? Push changes!
        var version = this.editedVersion();

        if (version && version.areDifferent()) {
            this.isSaving(true);
            app.model.calendar.setAppointment(version.version, this.allowBookUnavailableTime())
            .then(function(savedApt) {
                // Do not do a version push, just update with remote
                //version.push({ evenIfObsolete: true });
                // Update with remote data, the original appointment in the version,
                // not the currentAppointment or in the index in the list to avoid
                // race-conditions
                version.original.model.updateWith(savedApt);
                // Do a pull so original and version gets the exact same data
                version.pull({ evenIfNewer: true });

                // Go out edit mode
                this.editMode(false);
                
                // Notify
                if (this.isBooking()) {
                    
                    var msg = this.item().client().firstName() + ' will receive an e-mail confirmation.';
                    
                    app.modals.showNotification({
                        title: 'Confirmed!',
                        message: msg
                    });
                }
                
            }.bind(this))
            .catch(function(err) {
                // The version data keeps untouched, user may want to retry
                // or made changes on its un-saved data.
                // Show error
                app.modals.showError({
                    title: 'There was an error saving the data.',
                    error: err
                });
                // Don't replicate error, allow always
            })
            .then(function() {
                // ALWAYS:
                this.isSaving(false);
            }.bind(this));
        }
    }.bind(this);

    this.cancel = function cancel() {
        if (this.isLocked()) return;

        if (this.editedVersion()) {
            // Discard previous version
            this.editedVersion().pull({ evenIfNewer: true });
        }
        // Out of edit mode
        this.editMode(false);
    }.bind(this);
    
    this.confirmCancel = function confirmCancel() {
        this.app.modals.confirm({
            title: 'Cancel',
            message: 'Are you sure?',
            yes: 'Yes',
            no: 'No'
        })
        .then(function() {
            // Confirmed cancellation:
            this.cancel();
        }.bind(this));
    }.bind(this);

    /**
        External actions
    **/
    var editFieldOn = function editFieldOn(activity, data) {

        // Include appointment to recover state on return:
        data.appointment = this.item().model.toPlainObject(true);
        
        data.cancelLink = this.cancelLink;
        
        if (this.progress &&
            !this.progress.ended) {
            data.progress = this.progress;
            var step = data.progress.step || 1,
                total = data.progress.total || 1;
            // TODO I18N
            data.title = step + ' of ' + total;
            data.navTitle = null;
        } else {
            // keep data.progress so it does not restart the process after
            // an edition. The passIn already resets that on new calls
            data.progress = this.progress;
            // Edition title:
            data.title = null;
            data.navTitle = this.isBooking() ? 'Booking' : 'Event';
        }

        app.shell.go(activity, data);
    }.bind(this);

    this.pickDateTime = function pickDateTime() {
        if (this.isLocked()) return;

        editFieldOn('datetimePicker', {
            selectedDatetime: this.item().startTime(),
            datetimeField: 'startTime',
            headerText: 'Select the start time',
            requiredDuration: this.item().getServiceDurationMinutes()
        });
    }.bind(this);

    this.pickEndDateTime = function pickEndDateTime() {
        if (this.isLocked()) return;

        editFieldOn('datetimePicker', {
            selectedDatetime: this.item().endTime(),
            datetimeField: 'endTime',
            headerText: 'Select the end time'
        });
    }.bind(this);

    this.pickClient = function pickClient() {
        if (this.isLocked()) return;

        editFieldOn('clients', {
            selectClient: true,
            selectedClientID: this.item().sourceBooking().clientUserID()
        });
    }.bind(this);

    this.pickService = function pickService() {
        if (this.isLocked()) return;

        editFieldOn('serviceProfessionalService/' + this.item().jobTitleID(), {
            selectPricing: true,
            selectedServices: this.item().pricing()
            .map(function(pricing) {
                return {
                    serviceProfessionalServiceID: ko.unwrap(pricing.serviceProfessionalServiceID),
                    totalPrice: ko.unwrap(pricing.totalPrice)
                };
            })
        });
    }.bind(this);

    this.changePrice = function changePrice() {
        if (this.isLocked()) return;
        // TODO
    }.bind(this);

    this.pickLocation = function pickLocation() {
        if (this.isLocked()) return;

        editFieldOn('serviceAddresses/' + this.item().jobTitleID(), {
            selectAddress: true,
            selectedAddressID: this.item().addressID()
        });
    }.bind(this);

    var textFieldsHeaders = {
        preNotesToClient: 'Notes to client',
        postNotesToClient: 'Notes to client (afterwards)',
        preNotesToSelf: 'Notes to self',
        postNotesToSelf: 'Booking summary',
        summary: 'What?'
    };

    this.editTextField = function editTextField(field) {
        if (this.isLocked()) return;

        editFieldOn('textEditor', {
            request: 'textEditor',
            field: field,
            title: this.isNew() ? 'New booking' : 'Booking',
            header: textFieldsHeaders[field],
            text: this.item()[field]()
        });
    }.bind(this);
    
    // pass this ready model view as an API to the outside
    if (typeof(params.api) === 'function') {
        params.api(this);
    }
    
    // Calculate the endTime given an appointment duration, retrieved
    // from the selected service
    ko.computed(function calculateEndTime() {
        var duration = this.item().serviceDurationMinutes(),
            start = moment(this.item().startTime()),
            end;

        if (this.isBooking() &&
            start.isValid()) {
            end = start.add(duration, 'minutes').toDate();
            this.item().endTime(end);
        }
    }, this)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
}

/**
    It manages incoming data provided by external activities given
    the requestData received by the activity hosting this view instance.
    Used to manage the data returned by calls to edit data in
    external activities.
**/
AppointmentCardViewModel.prototype.passIn = function passIn(requestData) {
    /*jshint maxcomplexity:20,maxstatements:40 */
    
    // If the request includes an appointment plain object, that's an
    // in-editing appointment so put it in place (to restore a previous edition)
    if (requestData.appointment) {
        // Set the edit mode (it performs any required
        // set-up if we are not still in edit mode).
        this.editMode(true);
        // Sets the data
        this.item()
        .model.updateWith(requestData.appointment);
    }
    else if (!this.isNew()) {
        // On any other case, and to prevent a bad editMode state,
        // set off edit mode discarding unsaved data:
        this.cancel();
    }

    /// Manage specific single data from externally provided
    
    // It comes back from the textEditor.
    if (requestData.request === 'textEditor') {
        this.item()[requestData.field](requestData.text);
    }
    if (requestData.selectClient === true) {
        this.item().clientUserID(requestData.selectedClientID);
    }
    if (typeof(requestData.selectedDatetime) !== 'undefined') {
        var field = requestData.datetimeField;
        this.item()[field](requestData.selectedDatetime);
        this.allowBookUnavailableTime(requestData.allowBookUnavailableTime);
    }
    if (requestData.selectedJobTitleID) {
        this.item().jobTitleID(requestData.selectedJobTitleID);
    }
    if (requestData.selectAddress === true) {
        this.item().addressID(requestData.selectedAddressID);
    }
    if (requestData.selectPricing === true) {
        this.item().pricing(
            requestData.selectedServices.map(function(pricing) {
                return new PricingSummaryDetail(pricing);
            })
        );
    }
    
    if (this.isNew()) {
        if (requestData && requestData.cancelLink) {
            this.cancelLink = requestData.cancelLink;
        }
        else {
            // Using the Referrer URL as the link when cancelling the task
            var referrerUrl = this.app.shell.referrerRoute;
            referrerUrl = referrerUrl && referrerUrl.url || 'calendar';

            this.cancelLink = referrerUrl;
        }
    }

    // Special behavior for adding a booking: it requires a guided creation
    // through a progress path
    if (this.currentID() === Appointment.specialIds.newBooking) {
        if (!requestData.progress) {
            // Start!
            this.progress = {
                step: 1,
                total: 4,
                ended: false
            };
            // First step
            this.pickClient(); //._delayed(50)();
        }
        else if (requestData.progress) {
            this.progress = requestData.progress;
            var step = this.progress.step || 1;
            if (step < 2) {
                // Second step
                this.progress.step = 2;
                this.pickService();//._delayed(50)();
            }
            else if (step < 3) {
                // Thrid step
                requestData.progress.step = 3;
                this.pickDateTime();//._delayed(50)();
            }
            else if (step < 4) {
                requestData.progress.step = 4;
                this.pickLocation();//._delayed(50)();
            }
            else {
                // Steps finished, not it enters in revision mode before
                // finally save/create the booking, but remove the progress info
                // to avoid problems editing fields.
                this.progress.ended = true;
            }
        }
    } else {
        // Reset progress
        this.progress = null;
    }
};


module.exports = AppointmentCardViewModel;

},{"../models/Appointment":103,"../models/PricingSummaryDetail":126,"../utils/ModelVersion":161,"../utils/getDateWithoutTime":175,"../utils/getObservable":176,"../viewmodels/AppointmentView":196,"knockout":false,"moment":false}],196:[function(require,module,exports){
/**
    Appointment View model that wraps an Appointment
    model instance extended with extra methods connected
    to related data
**/
'use strict';

var ko = require('knockout');

module.exports = function AppointmentView(appointment, app) {
    if (appointment._isAppointmentView) return appointment;
    appointment._isAppointmentView = true;

    appointment.client = ko.computed(function() {
        var b = this.sourceBooking();
        if (!b) return null;
        
        var cid = this.clientUserID();
        if (cid) {
            return app.model.clients.getObservableItem(cid, true)();
        }
        return null;
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    appointment.address = ko.computed(function() {
        var aid = this.addressID(),
            jid = this.jobTitleID();
        if (aid && jid) {
            return app.model.serviceAddresses.getObservableItem(jid, aid, true)();
        }
        return null;
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });

    appointment.addressSummary = ko.computed(function() {
        var eventData = this.sourceEvent();
        var add = this.address();
        return add && add.singleLine() || eventData && eventData.location() || '';
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    /* Property with the pricing array plus information about the
        serviceProfessionalService.
    */
    appointment.pricingWithInfo = ko.computed(function() {
        var b = this.sourceBooking();
        if (!b) return [];

        var jid = this.jobTitleID(),
            details = this.pricing();

        return details.map(function(det) {
            return PricingSummaryDetailView(det, jid, app);
        });
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 60 } });

    appointment.servicesSummary = ko.computed(function() {
        return this.pricingWithInfo()
        .map(function(service) {
            return service.serviceProfessionalService().name();
        }).join(', ');
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    // ServiceDuration as function, because is needed for cases when cannot wait for the 
    // rated computed
    appointment.getServiceDurationMinutes = function() {
        var pricing = this.pricingWithInfo();
        var sum = pricing.reduce(function(prev, service) {
            return prev + service.serviceProfessionalService().serviceDurationMinutes();
        }, 0);
        return sum;
    };
    // ServiceDuration as computed so can be observed for changes
    appointment.serviceDurationMinutes = ko.computed(function() {
        return this.getServiceDurationMinutes();
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
    
    ko.computed(function() {
        var pricing = appointment.pricing();
        this.price(pricing.reduce(function(prev, cur) {
            return prev + cur.price();
        }, 0));
    }, appointment)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });

    return appointment;
};

function PricingSummaryDetailView(pricingSummaryDetail, jobTitleID, app) {

    pricingSummaryDetail.serviceProfessionalService = ko.computed(function() {
        var pid = this.serviceProfessionalServiceID();
        return app.model.serviceProfessionalServices
            .getObservableItem(jobTitleID, pid, true)();
    }, pricingSummaryDetail)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });

    return pricingSummaryDetail;
}

},{"knockout":false}],197:[function(require,module,exports){
/**
    BookingProgress
**/
'use strict';

var Model = require('../models/Model'),
    ko = require('knockout');

function BookingProgress(values) {
    Model(this);

    this.model.defProperties({
        step: 0,
        stepsList: [],
        ended: false
    }, values);
    
    this.totalSteps = ko.pureComputed(function() {
        return this.stepsList().length;
    }, this);
    
    this.currentStep = ko.pureComputed(function() {
        return this.stepsList()[this.step()];
    }, this);
}

module.exports = BookingProgress;

BookingProgress.prototype.next = function() {
    var step = Math.max(0, Math.min(this.step() + 1, this.totalSteps() - 1));
    
    this.step(step);
};

BookingProgress.prototype.observeStep = function(stepName) {
    return ko.pureComputed(function() {
        return this.isStep(stepName);
    }, this);
};

BookingProgress.prototype.isStep = function(stepName) {
    return this.stepsList()[this.step()] === stepName;
};

/*
BookingProgress.prototype.getRequestData = function() {
    
    var data = {
        progress: {}
    };
    
    if (!this.ended()) {

        var step = data.step() || 1,
            total = data.totalSteps() || 1;
        // TODO I18N
        data.title = step + ' of ' + total;
        data.navTitle = null;
    } else {
        // Edition title:
        data.title = null;
        data.navTitle = 'Booking';
    }

    return data;
};
*/
},{"../models/Model":123,"knockout":false}],198:[function(require,module,exports){
/**
    View model for the datetime-picker component/template
**/
'use strict';

var ko = require('knockout'),
    $ = require('jquery'),
    getDateWithoutTime = require('../utils/getDateWithoutTime'),
    moment = require('moment'),
    Time = require('../utils/Time');

require('../components/DatePicker');
var datepickerAvailability = require('../utils/datepickerAvailability');

function DatetimePickerVM(app, element) {
    
    this.selectedDate = ko.observable(getDateWithoutTime());
    this.userID = ko.observable();
    this.isLoading = ko.observable(false);
    this.requiredDurationMinutes = ko.observable(0);
    
    this.durationDisplay = ko.pureComputed(function() {
        var fullMinutes = this.requiredDurationMinutes();
        if (fullMinutes <= 0)
            return '';

        var hours = Math.floor(fullMinutes / 60),
            minutes = fullMinutes % 60,
            text = '';

        if (hours > 0)
            text += moment.duration({ hours: hours }).humanize() + ' ';
        if (minutes > 0)
            text += moment.duration({ minutes: minutes }).humanize();

        return text;
    }, this);

    this.dateAvail = ko.observable();
    this.groupedSlots = ko.computed(function(){
        
        var requiredDurationMinutes = this.requiredDurationMinutes();
        
        /*
          before 12:00pm (noon) = morning
          afternoon: 12:00pm until 5:00pm
          evening: 5:00pm - 11:59pm
        */
        // Since slots must be for the same date,
        // to define the groups ranges use the first date
        var datePart = this.selectedDate() || new Date();
        var groups = [
            {
                group: 'Morning',
                slots: [],
                starts: new Time(datePart, 0, 0),
                ends: new Time(datePart, 12, 0)
            },
            {
                group: 'Afternoon',
                slots: [],
                starts: new Time(datePart, 12, 0),
                ends: new Time(datePart, 17, 0)
            },
            {
                group: 'Evening',
                slots: [],
                starts: new Time(datePart, 17, 0),
                ends: new Time(datePart, 24, 0)
            }
        ];

        // Populate groups with the time slots
        var slots = this.dateAvail() && this.dateAvail().getFreeTimeSlots(requiredDurationMinutes) || [];
        // Iterate to organize by group
        slots.forEach(function(slot) {
            // Check every group
            groups.some(function(group) {
                // If matches the group, push to it
                // and go out of groups iteration quickly
                if (slot >= group.starts &&
                    slot < group.ends) {
                    group.slots.push(slot);
                    return true;
                }
            });
        });

        return groups;

    }, this);
    
    this.selectedDatetime = ko.observable(null);
    
    this.selectDatetime = function(selectedDatetime, event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this.selectedDatetime(selectedDatetime);
    }.bind(this);

    ///
    /// Time Picker

    this.pickedTime = ko.observable();
    this.allowBookUnavailableTime = ko.observable(false);
    this.unavailableTimeBtnEnabled = ko.observable(false);
    
    this.getPickedDatetime = function() {
        var t = this.pickedTime();
        if (!(t instanceof Date)) {
            // Build date-time
            var timespan = moment.duration(t);
            t = moment(this.selectedDate()).startOf('day').add(timespan).toDate();
        }
        return t;
    };
    
    this.setPickedAsSelected = function() {
        this.allowBookUnavailableTime(true);
        this.selectedDatetime(this.getPickedDatetime());
    }.bind(this);
    
    this.showTimePicker = function() {
        app.modals.showTimePicker({
            title: 'Book an unavailable time',
            selectedTime: null,
            unsetLabel: 'Cancel'
        }).then(function(pickedValue) {
            if (pickedValue.time) {
                this.pickedTime(pickedValue.time);
                this.setPickedAsSelected();
            }
        }.bind(this))
        .catch(function() {
            // Just modal was dismissed, so picker was rejected but not an error
        });
    }.bind(this);
    
    this.reset = function() {
        this.selectedDatetime(null);
        this.pickedTime(null);
        this.allowBookUnavailableTime(false);
    }.bind(this);
    
    this.bindDateData = function bindDateData(date) {

        if (!date || !this.userID()) return;
        
        date = getDateWithoutTime(date);
        
        this.isLoading(true);
        //return app.model.calendar.getDateAvailability(date)
        return app.model.availability.times(this.userID(), date)
        .then(function(data) {

            this.dateAvail(data);

            /*var sdate = moment(date).format('YYYY-MM-DD');
            this.slots(data.slots.map(function(slot) {
                // From string to Date
                var dateslot = new Date(sdate + 'T' + slot);
                return dateslot;
            }));*/
        }.bind(this))
        .catch(function(err) {
            app.modals.showError({
                title: 'Error loading availability',
                error: err
            });
        }.bind(this))
        .then(function() {
            // Finally
            this.isLoading(false);
        }.bind(this));
    }.bind(this);

    
    ///
    /// Init component and handlers
    // Getting component element
    var $datePicker = $(element).find('.calendar-placeholder');
    $datePicker.show().datepicker({ extraClasses: 'DatePicker--tagged' });
    this.tagAvailability = datepickerAvailability.create(app, $datePicker, this.isLoading);
    
    $datePicker.on('dateChanged', function(e) {
        if (e.viewMode === 'days') {
            this.selectedDate(e.date);
        }
    }.bind(this));

    // Auto bind date data on selected date change:
    this.selectedDate.subscribe(function(date) {
        this.bindDateData(date);
        var elDate = $datePicker.datepicker('getValue');
        if (elDate !== date)
            $datePicker.datepicker('setValue', date, true);
    }.bind(this));
    
    // On Setting the data, we need to refresh tags,
    // and on change userID. This runs too the first time
    // update.
    ko.computed(function() {
        if (this.dateAvail() && this.userID()) {
            // Once finished, load the whole month
            this.tagAvailability(this.selectedDate(), this.userID());
        }
    }, this)
    .extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 60 } });
    
    // Force first refresh on datepicker to allow
    // event handlers to get notified on first time:
    $datePicker.datepicker('fill');
}

module.exports = DatetimePickerVM;

},{"../components/DatePicker":97,"../utils/Time":164,"../utils/datepickerAvailability":170,"../utils/getDateWithoutTime":175,"knockout":false,"moment":false}],199:[function(require,module,exports){
/**
    Simple View Model with main credentials for
    use in a form, with validation.
    Used by Login and Signup activities
**/
'use strict';

var ko = require('knockout');

function FormCredentials() {

    this.username = ko.observable('');
    this.password = ko.observable('');
    
    // validate username as an email
    var emailRegexp = /^[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+@[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+$/;
    this.username.error = ko.observable('');
    this.username.subscribe(function(v) {
        if (v) {
            if (emailRegexp.test(v)) {
                this.username.error('');
            }
            else {
                this.username.error('Is not a valid email');
            }
        }
        else {
            this.username.error('Required');
        }
    }.bind(this));
    
    // required password
    this.password.error = ko.observable('');
    this.password.subscribe(function(v) {
        var err = '';
        if (!v)
            err = 'Required';
        
        this.password.error(err);
    }.bind(this));
}

module.exports = FormCredentials;

},{"knockout":false}],200:[function(require,module,exports){
/** NavAction view model.
    It allows set-up per activity for the AppNav action button.
**/
var Model = require('../models/Model');

function NavAction(values) {
    
    Model(this);
    
    this.model.defProperties({
        link: '',
        icon: '',
        text: '',
        // 'Test' is the header title but placed in the button/action
        isTitle: false,
        // 'Link' is the element ID of a modal (starts with a #)
        isModal: false,
        // 'Link' is a Shell command, like 'goBack 2'
        isShell: false,
        // Set if the element is a menu button, in that case 'link'
        // will be the ID of the menu (contained in the page; without the hash), using
        // the text and icon but special meaning for the text value 'menu'
        // on icon property that will use the standard menu icon.
        isMenu: false,
        // Custom function as event handler for button click.
        // The standard link gets disabled with this
        handler: null
    }, values);
    
    this.runHandler = function runHandler(obj, event) {
        var handler = this.handler();
        if (handler) {
            event.stopImmediatePropagation();
            event.preventDefault();
            handler.call(this, event, obj);
        }
    }.bind(this);
}

module.exports = NavAction;

// Set of view utilities to get the link for the expected html attributes

NavAction.prototype.getHref = function getHref() {
    return (
        (this.handler() || this.isMenu() || this.isModal() || this.isShell()) ?
        '#' :
        this.link()
    );
};

NavAction.prototype.getModalTarget = function getModalTarget() {
    return (
        (this.handler() || this.isMenu() || !this.isModal() || this.isShell()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getShellCommand = function getShellCommand() {
    return (
        (this.handler() || this.isMenu() || !this.isShell()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getMenuID = function getMenuID() {
    return (
        (this.handler() || !this.isMenu()) ?
        '' :
        this.link()
    );
};

NavAction.prototype.getMenuLink = function getMenuLink() {
    return (
        (this.handler() || !this.isMenu()) ?
        '' :
        '#' + this.link()
    );
};

/** Static, shared actions **/
NavAction.goHome = new NavAction({
    link: '/',
    icon: 'fa ion ion-stats-bars'
});

NavAction.goBack = new NavAction({
    link: 'goBack',
    icon: 'fa ion ion-ios-arrow-left',
    isShell: true
});

NavAction.menuIn = new NavAction({
    link: 'menuIn',
    icon: 'menu',
    isMenu: true
});

NavAction.menuOut = new NavAction({
    link: 'menuOut',
    icon: 'menu',
    isMenu: true
});

NavAction.menuNewItem = new NavAction({
    link: 'menuNewItem',
    icon: 'fa ion ion-ios-plus-empty',
    isMenu: true
});

NavAction.goHelpIndex = new NavAction({
    link: '/contactForm/general?mustReturn=true',
    text: 'help',
    isModal: false
});

NavAction.goLogin = new NavAction({
    link: '/login',
    text: 'log-in'
});

NavAction.goLogout = new NavAction({
    link: '/logout',
    text: 'log-out'
});

NavAction.goSignup = new NavAction({
    link: '/signup',
    text: 'sign-up'
});

},{"../models/Model":123}],201:[function(require,module,exports){
/** NavBar view model.
    It allows customize the NavBar per activity.
**/
var Model = require('../models/Model'),
    NavAction = require('./NavAction');

function NavBar(values) {
    
    Model(this);
    
    this.model.defProperties({
        // Title showed in the center
        // When the title is 'null', the app logo is showed in place,
        // on empty text, the empty text is showed and no logo.
        title: '',
        leftAction: {
            Model: NavAction
        },
        rightAction: {
            Model: NavAction
        },
        hidden: false
    }, values);
}

module.exports = NavBar;

},{"../models/Model":123,"./NavAction":200}],202:[function(require,module,exports){
/** OnboardingProgress view model.
    It tracks the onboarding information and methods
    to update views to that state
**/
var Model = require('../models/Model'),
    ko = require('knockout');

function OnboardingProgress(values) {

    Model(this);
    
    this.model.defProperties({
        group: '',
        stepNumber: -1,
        steps: []
    }, values);
    
    this.totalSteps = ko.pureComputed(function() {
        // 'Zero' step is a welcome, not accounted:
        return this.steps().length - 1;
    }, this);
    
    this.stepName = ko.pureComputed(function() {
        var num = this.stepNumber(),
            tot = this.steps().length;

        if (tot > 0 &&
            num > -1 &&
            num < tot) {
            var name = this.steps()[num] || '';
            return name;
        }
        else {
            return null;
        }
    }, this);
    
    this.stepUrl = ko.pureComputed(function() {
        var url = this.stepName();
        if (url && !/^\//.test(url))
            url = '/' + url;
        return url;
    }, this);

    this.stepReference = ko.pureComputed(function() {
        return this.group() + ':' + this.stepName();
    }, this);
    
    this.progressText = ko.pureComputed(function() {
        // TODO L18N
        return this.stepNumber() + ' of ' + this.totalSteps();
    }, this);
    
    this.inProgress = ko.pureComputed(function() {
        return !!this.stepUrl();
    }, this);
}

module.exports = OnboardingProgress;

OnboardingProgress.prototype.setStepByName = function setStepByName(name) {
    var stepIndex = this.steps().indexOf(name);
    if (stepIndex > -1) {
        this.stepNumber(stepIndex);
        return true;
    }
    return false;
};

/**
    Static list of all the steps groups for the app
**/
OnboardingProgress.predefinedStepGroups = {
    // Scheduling onboarding, aka welcome
    welcome: [
        'welcome',
        'addJobTitles',
        // disabled on 2015-06-16 as of #575 comments
        //'serviceProfessionalService',
        //'serviceAddresses',
        'weeklySchedule',
        'contactInfo'
    ],
    marketplace: [
    ],
    payment: [
    ]
};

},{"../models/Model":123,"knockout":false}],203:[function(require,module,exports){
/**
    ServiceAddressesViewModel
**/
'use strict';

var ko = require('knockout');

function ServiceAddressesViewModel() {
    
    // Especial mode when instead of pick and edit we are just selecting
    // (when editing an appointment)
    this.isSelectionMode = ko.observable(false);

    this.sourceAddresses = ko.observableArray([]);
    this.addresses = ko.computed(function() {
        var list = this.sourceAddresses();
        if (this.isSelectionMode()) {
            // Filter by service addresses (excluding service area)
            list = list.filter(function(add) {
                return add.isServiceLocation();
            });
        }
        return list;
    }, this);
    
    this.selectedAddress = ko.observable(null);

    this.selectAddress = function(selectedAddress, event) {
        this.selectedAddress(selectedAddress);
        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    this.observerSelected = function(item) {
        return ko.pureComputed(function() {
            //return this.selectedAddress() === item;
            var sid = this.selectedAddress() && ko.unwrap(this.selectedAddress().addressID),
                iid = item && ko.unwrap(item.addressID);
            return sid === iid;
        }, this);
    }.bind(this);
}

module.exports = ServiceAddressesViewModel;

},{"knockout":false}],204:[function(require,module,exports){
/**
    ServiceProfessionalServiceViewModel
**/
'use strict';

var ko = require('knockout'),
    _ = require('lodash'),
    $ = require('jquery');

function ServiceProfessionalServiceViewModel(app) {

    this.isLoading = ko.observable(false);
    this.list = ko.observableArray([]);
    this.jobTitleID = ko.observable(0);
    // 0 to load current user pricing and allow edit
    this.serviceProfessionalID = ko.observable(null);
    this.jobTitle = ko.observable(null);
    this.isAdditionMode = ko.observable(false);
    // Especial mode when instead of pick and edit we are just selecting
    this.isSelectionMode = ko.observable(false);
    // Currently selected pricing
    this.selectedServices = ko.observableArray([]);
    // Preset selection, from a previous state (loaded data) or incoming selection:
    this.preSelectedServices = ko.observableArray([]);
    // Add activity requestData to keep progress/navigation on links
    this.requestData = ko.observable();
    this.cancelLink = ko.observable(null);
    
    this.allowAddServices = ko.pureComputed(function() {
        return this.serviceProfessionalID() === null;
    }, this);
    
    // Grouped list of pricings:
    // Defined groups by pricing type
    this.groupedServices = ko.computed(function(){

        var list = this.list();
        var isSelection = this.isSelectionMode();
        var groupNamePrefix = isSelection ? 'Select ' : '';

        var groups = [],
            groupsList = [];
        if (!this.isAdditionMode()) {
            groups = _.groupBy(list, function(service) {
                return service.pricingTypeID();
            });

            // Convert the indexed object into an array with some meta-data
            groupsList = Object.keys(groups).map(function(key) {
                var gr = {
                    services: groups[key],
                    // Load the pricing information
                    type: app.model.pricingTypes.getObservableItem(key)
                };
                gr.group = ko.computed(function() {
                    return groupNamePrefix + (
                        this.type() && this.type().pluralName() ||
                        'Services'
                    );
                }, gr);
                return gr;
            });
        }
        
        if (!this.isSelectionMode()) {
            // Since the groupsList is built from the existent pricing items
            // if there are no records for some pricing type (or nothing when
            // just created the job title), that types/groups are not included,
            // so review and include now.
            // NOTE: as a good side effect of this approach, pricing types with
            // some pricing will appear first in the list (nearest to the top)
            var pricingTypes = this.jobTitle() && this.jobTitle().pricingTypes();
            if (pricingTypes && pricingTypes.length) {
                pricingTypes.forEach(function (jobType) {

                    var typeID = jobType.pricingTypeID();
                    // Not if already in the list
                    if (groups.hasOwnProperty(typeID))
                        return;

                    var gr = {
                        services: [],
                        type: app.model.pricingTypes.getObservableItem(typeID)
                    };
                    gr.group = ko.computed(function() {
                        return groupNamePrefix + (
                            this.type() && this.type().pluralName() ||
                            'Services'
                        );
                    }, gr);

                    groupsList.push(gr);
                });
            }
        }

        return groupsList;

    }, this);

    /**
        Toggle the selection status of a single pricing, adding
        or removing it from the 'selectedServices' array.
    **/
    this.toggleServiceSelection = function(service) {

        var inIndex = -1,
            isSelected = this.selectedServices().some(function(selectedServices, index) {
            if (selectedServices === service) {
                inIndex = index;
                return true;
            }
        });

        service.isSelected(!isSelected);

        if (isSelected)
            this.selectedServices.splice(inIndex, 1);
        else
            this.selectedServices.push(service);
    }.bind(this);
    
    this.editService = function(service) {
        app.shell.go('serviceProfessionalServiceEditor/' + this.jobTitleID() + '/' + service.serviceProfessionalServiceID());
    }.bind(this);
    
    /**
        Handler for the listview items, managing edition and selection depending on current mode
    **/
    this.tapService = function(service, event) {
        if (this.isSelectionMode()) {
            this.toggleServiceSelection(service);
        }
        else {
            this.editService(service);
        }

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    this.tapNewService = function(group, event) {
        
        var url = '#!serviceProfessionalServiceEditor/' + this.jobTitleID() + '/new/' + (group.type() && group.type().pricingTypeID());

        // Passing original data, for in-progress process (as new-booking)
        // and the selected title since the URL could not be updated properly
        // (see the anotated comment about replaceState bug on this file)
        var request = $.extend({}, this.requestData(), {
            selectedJobTitleID: this.jobTitleID()
        });
        if (!request.cancelLink) {
            $.extend(request, {
                cancelLink: this.cancelLink()
            });
        }
        
        // When in selection mode:
        // Add current selection as preselection, so can be recovered later and 
        // the editor can add the new pricing to the list
        if (this.isSelectionMode()) {
            request.selectedServices = this.selectedServices()
            .map(function(pricing) {
                return {
                    serviceProfessionalServiceID: ko.unwrap(pricing.serviceProfessionalServiceID),
                    totalPrice: ko.unwrap(pricing.totalPrice)
                };
            });
        }

        app.shell.go(url, request);

        event.preventDefault();
        event.stopImmediatePropagation();
    }.bind(this);
    
    var loadDataFor = function loadDataFor(serviceProfessionalID, jobTitleID) {
        if (jobTitleID) {
            this.isLoading(true);
            // Get data for the Job title ID and pricing types.
            // They are essential data
            Promise.all([
                app.model.jobTitles.getJobTitle(jobTitleID),
                app.model.pricingTypes.getList()
            ])
            .then(function(data) {
                var jobTitle = data[0];
                // Save for use in the view
                this.jobTitle(jobTitle);
                // Get services
                if (serviceProfessionalID)
                    return app.model.users.getServiceProfessionalServices(serviceProfessionalID, jobTitleID);
                else
                    return app.model.serviceProfessionalServices.getList(jobTitleID);
            }.bind(this))
            .then(function(list) {

                list = app.model.serviceProfessionalServices.asModel(list);

                // Read presets selection from requestData
                var preset = this.preSelectedServices(),
                    selection = this.selectedServices;

                // Add the isSelected property to each item
                list.forEach(function(item) {
                    var preSelected = preset.some(function(pr) {
                        if (pr.serviceProfessionalServiceID === item.serviceProfessionalServiceID())
                            return true;
                    }) || false;

                    item.isSelected = ko.observable(preSelected);

                    if (preSelected) {
                        selection.push(item);
                    }
                });
                this.list(list);
                
                this.isLoading(false);

            }.bind(this))
            .catch(function (err) {
                this.isLoading(false);
                app.modals.showError({
                    title: 'There was an error while loading.',
                    error: err
                });
            }.bind(this));
        }
        else {
            this.list([]);
            this.jobTitle(null);
        }
    }.bind(this);

    // AUTO LOAD on job title change
    ko.computed(function() {
        loadDataFor(this.serviceProfessionalID(), this.jobTitleID());
    }.bind(this)).extend({ rateLimit: { method: 'notifyWhenChangesStop', timeout: 20 } });
}

module.exports = ServiceProfessionalServiceViewModel;

},{"knockout":false,"lodash":false}],205:[function(require,module,exports){
/**
    View model for the signup form/container,
    shared across activity and client booking.
**/
'use strict';
var ko = require('knockout'),
    EventEmitter = require('events').EventEmitter;

//var FormCredentials = require('../viewmodels/FormCredentials');
var newFieldObs = function() {
    var obs = ko.observable('');
    obs.error = ko.observable('');
    // Reset error after a change:
    obs.subscribe(function() {
        obs.error('');
    });
    return obs;
};

function SignupVM(app) {
    
    EventEmitter.call(this);
    
    this.firstName = newFieldObs();
    this.lastName = newFieldObs();
    this.phone = newFieldObs();
    this.postalCode = newFieldObs();
    this.referralCode = newFieldObs();
    this.device = newFieldObs();
    
    this.facebookUserID = ko.observable();
    this.facebookAccessToken = ko.observable();

    //var credentials = new FormCredentials();    
    //this.email = credentials.username;
    //this.password = credentials.password;
    this.email = newFieldObs();
    this.password = newFieldObs();

    this.signupError = ko.observable('');
    
    this.isSigningUp = ko.observable(false);
    this.submitText = ko.pureComputed(function() {
        return (
            this.isSigningUp() ? 'Signing up...' :
            this.facebookUserID() ? 'Sign up with Facebook' :
            'Sign up'
        );
    }, this);
    
    this.performSignup = function performSignup() {

        this.isSigningUp(true);

        // Clear previous error so makes clear we
        // are attempting
        this.signupError('');

        var ended = function ended() {
            this.isSigningUp(false);
        }.bind(this);

        var plainData = {
            email: this.email(),
            password: this.password(),
            firstName: this.firstName(),
            lastName: this.lastName(),
            phone: this.phone(),
            postalCode: this.postalCode(),
            referralCode: this.referralCode(),
            device: this.device(),
            facebookUserID: this.facebookUserID(),
            facebookAccessToken: this.facebookAccessToken(),
            profileType: this.profile(),
        };

        return app.model.signup(plainData)
        .then(function(signupData) {

            this.signupError('');
            ended();

            // Start onboarding
            if (app.model.onboarding)
                app.model.onboarding.setStep(signupData.onboardingStep);

            // Remove form data
            this.reset();
            
            this.emit('signedup', signupData);

        }.bind(this))
        .catch(function(err) {

            err = err && err.responseJSON;

            // Process validation errors, tagging fields or general error
            if (err && err.errorSource === 'validation' && err.errors) {
                Object.keys(err.errors).forEach(function(fieldKey) {
                    if (this[fieldKey] && this[fieldKey].error) {
                        this[fieldKey].error(err.errors[fieldKey]);
                    }
                }.bind(this));
            }
            else {
                var msg = err && err.errorMessage ||
                    err && err.statusText ||
                    'Invalid username or password';

                this.signupError(msg);
                this.email.error(msg);
            }

            ended();
            
            // Use event to catch up the error, since the promise catch it
            // since this will be triggered by a button and never will have change
            // to detect the promise, showing up unknow errors in console
            this.emit('signuperror', err);
        }.bind(this));
        
    }.bind(this);

    this.profile = ko.observable(''); // client, service-professional
    this.forServiceProfessional = ko.pureComputed(function() {
        return this.profile() === 'service-professional';
    }, this);
    
    this.reset = function() {
        this.firstName('');
        this.lastName('');
        this.phone('');
        this.postalCode('');
        this.referralCode('');
        this.device('');
        this.facebookUserID('');
        this.facebookAccessToken('');
    };
    
    this.facebook = function() {
        var fb = require('../utils/facebookUtils');
        var vm = this;

        // email,user_about_me
        fb.login({ scope: 'email' }).then(function (result) {
            var auth = result.auth,
                FB = result.FB;
            // Set FacebookId to link accounts:
            vm.facebookUserID(auth.userID);
            vm.facebookAccessToken(auth.accessToken);
            // Request more user data
            FB.api('/me', function (user) {
                //Fill Data
                vm.email(user.email);
                vm.firstName(user.first_name);
                vm.lastName(user.last_name);
                //(user.gender);
                //(user.about);
            });
        });
    };
}

SignupVM._inherits(EventEmitter);

module.exports = SignupVM;

},{"../utils/facebookUtils":174,"events":false,"knockout":false}],206:[function(require,module,exports){
/**
    TimeSlot view model (aka: CalendarSlot) for use
    as part of the template/component time-slot-tile or activities
    providing data for the template.
**/
'use strict';

var getObservable = require('../utils/getObservable');

function TimeSlotViewModel(params) {
    /*jshint maxcomplexity:9*/

    this.startTime = getObservable(params.startTime || null);
    this.endTime = getObservable(params.endTime || null);
    this.subject = getObservable(params.subject || null);
    this.description = getObservable(params.description || null);
    this.link = getObservable(params.link || null);
    this.actionIcon = getObservable(params.actionIcon || null);
    this.actionText = getObservable(params.actionText || null);
    this.classNames = getObservable(params.classNames || null);
}

module.exports = TimeSlotViewModel;

var numeral = require('numeral'),
    Appointment = require('../models/Appointment');

/**
    Static constructor to convert an Appointment model into 
    a TimeSlot instance following UI criteria for preset values/setup.
**/
TimeSlotViewModel.fromAppointment = function fromAppointment(apt) {
    /*jshint maxcomplexity:10 */
    
    // Commented the option to detect and not link unavail slots:
    //var unavail = Appointment.specialIds.unavailable === apt.id();
    //var link = null;
    //if (!unavail)
    var link = '#!appointment/' + apt.startTime().toISOString() + '/' + apt.id();
    
    if (apt.id() === Appointment.specialIds.preparationTime) {
        // Special link case: it goes to scheduling preferences to allow quick edit
        // the preparation time slots
        link = '#!schedulingPreferences?mustReturn=1';
    }

    var classNames = null;
    if (Appointment.specialIds.free === apt.id()) {
        classNames = 'Tile--tag-gray-lighter ';
    }
    else if (apt.id() > 0 && apt.sourceBooking()) {
        if (apt.sourceBooking().serviceDateID())
            classNames = 'Tile--tag-primary ' ;
        else
            // is a request:
            classNames = 'Tile--tag-warning ';
        
        classNames += 'ItemAddonTile--largerContent ';
    }
    else {
        // any block event, preparation time slots
        classNames = 'Tile--tag-danger ';
    }

    return new TimeSlotViewModel({
        startTime: apt.startTime,
        endTime: apt.endTime,
        subject: apt.summary,
        description: apt.description,
        link: link,
        actionIcon: (apt.sourceBooking() ? null : apt.sourceEvent() ? 'fa ion ion-ios-arrow-right' : !apt.id() ? 'fa ion ion-plus' : null),
        actionText: (
            apt.sourceBooking() && 
            apt.sourceBooking().pricingSummary() ? 
            numeral(apt.sourceBooking().pricingSummary().totalPrice() || 0).format('$0.00') :
            null
        ),
        classNames: classNames
    });
};

},{"../models/Appointment":103,"../utils/getObservable":176,"numeral":false}],207:[function(require,module,exports){
/**
    UserJobProfileViewModel: loads data and keep state
    to display the listing of job titles from the 
    user job profile.
**/
'use strict';

var ko = require('knockout'),
    UserJobTitle = require('../models/UserJobTitle');

function UserJobProfileViewModel(app) {
    
    this.showMarketplaceInfo = ko.observable(false);
    
    // Load and save job title info
    var jobTitlesIndex = {};
    function syncJobTitle(jobTitleID) {
        return app.model.jobTitles.getJobTitle(jobTitleID)
        .then(function(jobTitle) {
            jobTitlesIndex[jobTitleID] = jobTitle;

            // TODO: errors? not-found job title?
        });
    }
    // Creates a 'jobTitle' observable on the userJobTitle
    // model to have access to a cached jobTitle model.
    function attachJobTitle(userJobTitle) {
        userJobTitle.jobTitle = ko.computed(function(){
            return jobTitlesIndex[this.jobTitleID()];
        }, userJobTitle);
        // Shortcut to singular name
        userJobTitle.displayedSingularName = ko.computed(function() {
            return this.jobTitle() && this.jobTitle().singularName() || 'Unknow';
        }, userJobTitle);
    }
    
    function attachMarketplaceStatus(userJobtitle) {
        userJobtitle.marketplaceStatusHtml = ko.pureComputed(function() {
            var status = this.statusID();
            // L18N
            if (status === UserJobTitle.status.on) {
                return 'Marketplace profile: <strong class="text-success">ON</strong>';
            }
            else if (status === UserJobTitle.status.off) {
                return 'Marketplace profile: <strong class="text-danger">OFF</strong>';
            }
            else {
                // TODO: read number of steps left to activate from required alerts for the jobtitle
                // '__count__ steps left to activate'
                return '<span class="text-danger">There are steps left to activate</span>';
            }
        }, userJobtitle);
    }

    function attachExtras(userJobtitle) {
        attachJobTitle(userJobtitle);
        attachMarketplaceStatus(userJobtitle);
    }
    
    this.userJobProfile = ko.observableArray([]);
    // Updated using the live list, for background updates
    app.model.userJobProfile.list.subscribe(function(list) {
        // We need the job titles info before end
        Promise.all(list.map(function(userJobTitle) {
            return syncJobTitle(userJobTitle.jobTitleID());
        }))
        .then(function() {
            // Needs additional properties for the view
            list.forEach(attachExtras);

            this.userJobProfile(list);

            this.isLoading(false);
            this.isSyncing(false);
            this.thereIsError(false);
        }.bind(this))
        .catch(showLoadingError);
    }, this);

    this.isFirstTime = ko.observable(true);
    this.isLoading = ko.observable(false);
    this.isSyncing = ko.observable(false);
    this.thereIsError = ko.observable(false);
    this.baseUrl = ko.observable('/jobtitles');
    
    this.selectJobTitle = function(jobTitle) {
        // Gollow the next link:
        app.shell.go(this.baseUrl() + '/' + jobTitle.jobTitleID());
        // This function can be replaced by custom handling.
        // Stop events
        return false;
    }.bind(this);
    
    var showLoadingError = function showLoadingError(err) {
        app.modals.showError({
            title: 'An error happening when loading your job profile.',
            error: err && err.error || err
        });
        
        this.isLoading(false);
        this.isSyncing(false);
        this.thereIsError(true);
    }.bind(this);

    // Loading and sync of data
    this.sync = function sync() {
        var firstTime = this.isFirstTime();
        this.isFirstTime(false);

        if (firstTime) {
            this.isLoading(true);
        }
        else {
            this.isSyncing(true);
        }

        // Keep data updated:
        app.model.userJobProfile.syncList()
        .catch(showLoadingError);

    }.bind(this);
}

module.exports = UserJobProfileViewModel;

},{"../models/UserJobTitle":144,"knockout":false}]},{},[64])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvbm9kZV9tb2R1bGVzL2pxdWVyeS11aS9hdXRvY29tcGxldGUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvY29yZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvbm9kZV9tb2R1bGVzL2pxdWVyeS11aS9tZW51LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3Bvc2l0aW9uLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3dpZGdldC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYWNjb3VudC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYWRkSm9iVGl0bGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9hZGRyZXNzRWRpdG9yLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9hcHBvaW50bWVudC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvYmFja2dyb3VuZENoZWNrLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9ib29rTWVCdXR0b24uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2Jvb2tpbmcuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2NhbGVuZGFyLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jYWxlbmRhclN5bmNpbmcuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2NhbmNlbGxhdGlvblBvbGljeS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvY2xpZW50RWRpdG9yLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jbGllbnRzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jbXMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2NvbnRhY3RGb3JtLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9jb250YWN0SW5mby5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvY29udmVyc2F0aW9uLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9kYXNoYm9hcmQuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2RhdGV0aW1lUGlja2VyLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9lZHVjYXRpb24uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2VkdWNhdGlvbkZvcm0uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2ZhcXMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2ZlZWRiYWNrLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9mZWVkYmFja0Zvcm0uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2hvbWUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2luYm94LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9pbmRleC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvam9idGl0bGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9sZWFybk1vcmUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2xpY2Vuc2VzQ2VydGlmaWNhdGlvbnMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL2xpY2Vuc2VzQ2VydGlmaWNhdGlvbnNGb3JtLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9sb2dpbi5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvbG9nb3V0LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9tYXJrZXRwbGFjZUpvYnRpdGxlcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvbWFya2V0cGxhY2VQcm9maWxlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9vd25lckluZm8uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3BheW1lbnRzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9wZXJmb3JtYW5jZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvcHJpdmFjeVNldHRpbmdzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9wcm9maWxlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9wcm9maWxlUGljdHVyZUJpby5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvc2NoZWR1bGluZy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvc2NoZWR1bGluZ1ByZWZlcmVuY2VzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zZXJ2aWNlQWRkcmVzc2VzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VFZGl0b3IuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3NlcnZpY2VQcm9mZXNzaW9uYWxXZWJzaXRlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zZXJ2aWNlc092ZXJ2aWV3LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy9zaWdudXAuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3Rlcm1zLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy90ZXh0RWRpdG9yLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYWN0aXZpdGllcy91c2VyRmVlcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvdmVyaWZpY2F0aW9ucy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FjdGl2aXRpZXMvd2Vla2x5U2NoZWR1bGUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3dlbGNvbWUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hY3Rpdml0aWVzL3dvcmtQaG90b3MuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHAtY29tcG9uZW50cy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcC1uYXZiYXIuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHAuYWN0aXZpdGllcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcC5tb2RhbHMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHAuc2hlbGwuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC1hY2NvdW50LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuYXZhaWxhYmlsaXR5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuYm9va2luZ3MuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5jYWxlbmRhci5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuY2FsZW5kYXJTeW5jaW5nLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuY2xpZW50cy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLmVkdWNhdGlvbi5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLmZlZWRiYWNrLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuaG9tZUFkZHJlc3MuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5qb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuam9iVGl0bGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC5saWNlbnNlc0NlcnRpZmljYXRpb25zLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwubWFya2V0cGxhY2VQcm9maWxlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwubWVzc2FnaW5nLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwub25ib2FyZGluZy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLnBvc3RhbENvZGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwucHJpY2luZ1R5cGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwucHJpdmFjeVNldHRpbmdzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuc2VydmljZUFkZHJlc3Nlcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLnNlcnZpY2VBdHRyaWJ1dGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwudXNlckpvYlByb2ZpbGUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9hcHBtb2RlbC9BcHBNb2RlbC51c2VyUHJvZmlsZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2FwcG1vZGVsL0FwcE1vZGVsLnVzZXJWZXJpZmljYXRpb25zLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvYXBwbW9kZWwvQXBwTW9kZWwudXNlcnMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9jb21wb25lbnRzL0FjdGl2aXR5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvY29tcG9uZW50cy9EYXRlUGlja2VyLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvY29tcG9uZW50cy9TbWFydE5hdkJhci5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL2xvY2FsZXMvZW4tVVMtTEMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RhbHMvdGV4dEVkaXRvci5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGFscy90aW1lUGlja2VyLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0FkZHJlc3MuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvQXBwb2ludG1lbnQuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvQm9va2luZy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9Cb29raW5nU3VtbWFyeS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9DYWxlbmRhckV2ZW50LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0NhbGVuZGFyU3luY2luZy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9DbGllbnQuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvRGF0ZUF2YWlsYWJpbGl0eS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9FdmVudERhdGVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0V4cGVyaWVuY2VMZXZlbC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9HZXRNb3JlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0lucHV0UGF5bWVudE1ldGhvZC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9Kb2JUaXRsZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9Kb2JUaXRsZVByaWNpbmdUeXBlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL0pvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTGljZW5zZUNlcnRpZmljYXRpb24uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTGlzdFZpZXdJdGVtLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL01haWxGb2xkZXIuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTWFya2V0cGxhY2VQcm9maWxlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL01lc3NhZ2UuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTWVzc2FnZVZpZXcuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvTW9kZWwuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvUGVyZm9ybWFuY2VTdW1tYXJ5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1ByaWNpbmdTdW1tYXJ5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1ByaWNpbmdTdW1tYXJ5RGV0YWlsLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1ByaWNpbmdUeXBlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1ByaXZhY3lTZXR0aW5ncy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9QdWJsaWNVc2VyLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1B1YmxpY1VzZXJKb2JUaXRsZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9QdWJsaWNVc2VyUHJvZmlsZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9QdWJsaWNVc2VyUmF0aW5nLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1B1YmxpY1VzZXJWZXJpZmljYXRpb25zR3JvdXAuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvUHVibGljVXNlclZlcmlmaWNhdGlvbnNTdW1tYXJ5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1NjaGVkdWxpbmdQcmVmZXJlbmNlcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9TZXJ2aWNlQXR0cmlidXRlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1NlcnZpY2VBdHRyaWJ1dGVDYXRlZ29yeS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9TZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9TaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVGhyZWFkLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1VwY29taW5nQm9va2luZ3NTdW1tYXJ5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1VzZXIuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVXNlckVkdWNhdGlvbi5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL21vZGVscy9Vc2VySm9iVGl0bGUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVXNlckpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVXNlckxpY2Vuc2VDZXJ0aWZpY2F0aW9uLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1VzZXJWZXJpZmljYXRpb24uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy9tb2RlbHMvVmVyaWZpY2F0aW9uLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1ZvY0VsZW1lbnRFbnVtLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvbW9kZWxzL1dlZWtEYXlTY2hlZHVsZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL0NhY2hlQ29udHJvbC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL0RhdGVDYWNoZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL0Z1bmN0aW9uLnByb3RvdHlwZS5fZGVsYXllZC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL0Z1bmN0aW9uLnByb3RvdHlwZS5faW5oZXJpdHMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUubmFtZS1wb2x5ZmlsbC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL0dyb3VwTGlzdFJlbW90ZU1vZGVsLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvR3JvdXBSZW1vdGVNb2RlbC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL0luZGV4ZWRHcm91cExpc3RDYWNoZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL0luZGV4ZWRMaXN0Q2FjaGUuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9MaXN0UmVtb3RlTW9kZWwuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9Nb2RlbFZlcnNpb24uanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9SZW1vdGVNb2RlbC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL1Jlc3QuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9UaW1lLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvYWNjZXNzQ29udHJvbC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL2F2YWlsYWJpbGl0eUNhbGN1bGF0aW9uLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvYm9vdGtub2NrQmluZGluZ0hlbHBlcnMuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9ib290c3RyYXBTd2l0Y2hCaW5kaW5nLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvY3JlYXRlVGltZVNsb3RzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvZGF0ZXBpY2tlckF2YWlsYWJpbGl0eS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL2R1cmF0aW9uMkxhbmd1YWdlLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvZXNjYXBlUmVnRXhwLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvZXNjYXBlU2VsZWN0b3IuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9mYWNlYm9va1V0aWxzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvZ2V0RGF0ZVdpdGhvdXRUaW1lLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvZ2V0T2JzZXJ2YWJsZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL2dldFVybFF1ZXJ5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvanF1ZXJ5Lm11bHRpbGluZS5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL2pzUHJvcGVydGllc1Rvb2xzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvbG9hZGVyLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvcmVtb3ZlQWNjZW50LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2Nyb2xsVG9FbGVtZW50LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvRG9tSXRlbXNNYW5hZ2VyLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvU2hlbGwuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9zaGVsbC9hYnNvbHV0aXplVXJsLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvZGVwZW5kZW5jaWVzLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvaGFzaGJhbmdIaXN0b3J5LmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvc2hlbGwvaW5kZXguanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9zaGVsbC9sb2FkZXIuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy9zaGVsbC9wYXJzZVVybC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL3NoZWxsL3Nhbml0aXplVXJsLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdXRpbHMvc25hcFBvaW50cy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3V0aWxzL3RleHRTZWFyY2guanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy91dGlscy91c2VyQWdlbnRGbGFncy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvQXBwb2ludG1lbnRDYXJkLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9BcHBvaW50bWVudFZpZXcuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0Jvb2tpbmdQcm9ncmVzcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvRGF0ZXRpbWVQaWNrZXIuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL0Zvcm1DcmVkZW50aWFscy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvTmF2QWN0aW9uLmpzIiwiL1VzZXJzL2pvc2h1YWRhbmllbHNvbi9Ecm9wYm94L0dpdGh1Yi9Mb2Nvbm9taWNzL2FwcC9zb3VyY2UvanMvdmlld21vZGVscy9OYXZCYXIuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL09uYm9hcmRpbmdQcm9ncmVzcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvU2VydmljZUFkZHJlc3Nlcy5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL1NpZ251cC5qcyIsIi9Vc2Vycy9qb3NodWFkYW5pZWxzb24vRHJvcGJveC9HaXRodWIvTG9jb25vbWljcy9hcHAvc291cmNlL2pzL3ZpZXdtb2RlbHMvVGltZVNsb3QuanMiLCIvVXNlcnMvam9zaHVhZGFuaWVsc29uL0Ryb3Bib3gvR2l0aHViL0xvY29ub21pY3MvYXBwL3NvdXJjZS9qcy92aWV3bW9kZWxzL1VzZXJKb2JQcm9maWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeG5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3c0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9jQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcbnJlcXVpcmUoJy4vcG9zaXRpb24nKTtcbnJlcXVpcmUoJy4vbWVudScpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBBdXRvY29tcGxldGUgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2F1dG9jb21wbGV0ZS9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS5jb3JlLmpzXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICpcdGpxdWVyeS51aS5wb3NpdGlvbi5qc1xuICpcdGpxdWVyeS51aS5tZW51LmpzXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLndpZGdldCggXCJ1aS5hdXRvY29tcGxldGVcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuNFwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8aW5wdXQ+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhcHBlbmRUbzogbnVsbCxcblx0XHRhdXRvRm9jdXM6IGZhbHNlLFxuXHRcdGRlbGF5OiAzMDAsXG5cdFx0bWluTGVuZ3RoOiAxLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJsZWZ0IHRvcFwiLFxuXHRcdFx0YXQ6IFwibGVmdCBib3R0b21cIixcblx0XHRcdGNvbGxpc2lvbjogXCJub25lXCJcblx0XHR9LFxuXHRcdHNvdXJjZTogbnVsbCxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNoYW5nZTogbnVsbCxcblx0XHRjbG9zZTogbnVsbCxcblx0XHRmb2N1czogbnVsbCxcblx0XHRvcGVuOiBudWxsLFxuXHRcdHJlc3BvbnNlOiBudWxsLFxuXHRcdHNlYXJjaDogbnVsbCxcblx0XHRzZWxlY3Q6IG51bGxcblx0fSxcblxuXHRyZXF1ZXN0SW5kZXg6IDAsXG5cdHBlbmRpbmc6IDAsXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gU29tZSBicm93c2VycyBvbmx5IHJlcGVhdCBrZXlkb3duIGV2ZW50cywgbm90IGtleXByZXNzIGV2ZW50cyxcblx0XHQvLyBzbyB3ZSB1c2UgdGhlIHN1cHByZXNzS2V5UHJlc3MgZmxhZyB0byBkZXRlcm1pbmUgaWYgd2UndmUgYWxyZWFkeVxuXHRcdC8vIGhhbmRsZWQgdGhlIGtleWRvd24gZXZlbnQuICM3MjY5XG5cdFx0Ly8gVW5mb3J0dW5hdGVseSB0aGUgY29kZSBmb3IgJiBpbiBrZXlwcmVzcyBpcyB0aGUgc2FtZSBhcyB0aGUgdXAgYXJyb3csXG5cdFx0Ly8gc28gd2UgdXNlIHRoZSBzdXBwcmVzc0tleVByZXNzUmVwZWF0IGZsYWcgdG8gYXZvaWQgaGFuZGxpbmcga2V5cHJlc3Ncblx0XHQvLyBldmVudHMgd2hlbiB3ZSBrbm93IHRoZSBrZXlkb3duIGV2ZW50IHdhcyB1c2VkIHRvIG1vZGlmeSB0aGVcblx0XHQvLyBzZWFyY2ggdGVybS4gIzc3OTlcblx0XHR2YXIgc3VwcHJlc3NLZXlQcmVzcywgc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCwgc3VwcHJlc3NJbnB1dCxcblx0XHRcdG5vZGVOYW1lID0gdGhpcy5lbGVtZW50WzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRpc1RleHRhcmVhID0gbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIixcblx0XHRcdGlzSW5wdXQgPSBub2RlTmFtZSA9PT0gXCJpbnB1dFwiO1xuXG5cdFx0dGhpcy5pc011bHRpTGluZSA9XG5cdFx0XHQvLyBUZXh0YXJlYXMgYXJlIGFsd2F5cyBtdWx0aS1saW5lXG5cdFx0XHRpc1RleHRhcmVhID8gdHJ1ZSA6XG5cdFx0XHQvLyBJbnB1dHMgYXJlIGFsd2F5cyBzaW5nbGUtbGluZSwgZXZlbiBpZiBpbnNpZGUgYSBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuXHRcdFx0Ly8gSUUgYWxzbyB0cmVhdHMgaW5wdXRzIGFzIGNvbnRlbnRFZGl0YWJsZVxuXHRcdFx0aXNJbnB1dCA/IGZhbHNlIDpcblx0XHRcdC8vIEFsbCBvdGhlciBlbGVtZW50IHR5cGVzIGFyZSBkZXRlcm1pbmVkIGJ5IHdoZXRoZXIgb3Igbm90IHRoZXkncmUgY29udGVudEVkaXRhYmxlXG5cdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJpc0NvbnRlbnRFZGl0YWJsZVwiICk7XG5cblx0XHR0aGlzLnZhbHVlTWV0aG9kID0gdGhpcy5lbGVtZW50WyBpc1RleHRhcmVhIHx8IGlzSW5wdXQgPyBcInZhbFwiIDogXCJ0ZXh0XCIgXTtcblx0XHR0aGlzLmlzTmV3TWVudSA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUtaW5wdXRcIiApXG5cdFx0XHQuYXR0ciggXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIiApO1xuXG5cdFx0dGhpcy5fb24oIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5wcm9wKCBcInJlYWRPbmx5XCIgKSApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gdHJ1ZTtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XG5cdFx0XHRcdHN1cHByZXNzSW5wdXQgPSBmYWxzZTtcblx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzc1JlcGVhdCA9IGZhbHNlO1xuXHRcdFx0XHR2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcblx0XHRcdFx0c3dpdGNoKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkVOVEVSOlxuXHRcdFx0XHRjYXNlIGtleUNvZGUuTlVNUEFEX0VOVEVSOlxuXHRcdFx0XHRcdC8vIHdoZW4gbWVudSBpcyBvcGVuIGFuZCBoYXMgZm9jdXNcblx0XHRcdFx0XHRpZiAoIHRoaXMubWVudS5hY3RpdmUgKSB7XG5cdFx0XHRcdFx0XHQvLyAjNjA1NSAtIE9wZXJhIHN0aWxsIGFsbG93cyB0aGUga2V5cHJlc3MgdG8gb2NjdXJcblx0XHRcdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBmb3JtcyB0byBzdWJtaXRcblx0XHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuVEFCOlxuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmFjdGl2ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuRVNDQVBFOlxuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWUoIHRoaXMudGVybSApO1xuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0XHRcdC8vIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBkZWZhdWx0IGJlaGF2aW9yIGZvciBlc2NhcGVcblx0XHRcdFx0XHRcdC8vIFNpbmdsZSBwcmVzcyBjYW4gbWVhbiB1bmRvIG9yIGNsZWFyXG5cdFx0XHRcdFx0XHQvLyBEb3VibGUgcHJlc3MgaW4gSUUgbWVhbnMgY2xlYXIgdGhlIHdob2xlIGZvcm1cblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xuXHRcdFx0XHRcdC8vIHNlYXJjaCB0aW1lb3V0IHNob3VsZCBiZSB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBpbnB1dCB2YWx1ZSBpcyBjaGFuZ2VkXG5cdFx0XHRcdFx0dGhpcy5fc2VhcmNoVGltZW91dCggZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGtleXByZXNzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggc3VwcHJlc3NLZXlQcmVzcyApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5pc011bHRpTGluZSB8fCB0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzdXBwcmVzc0tleVByZXNzUmVwZWF0ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlcGxpY2F0ZSBzb21lIGtleSBoYW5kbGVycyB0byBhbGxvdyB0aGVtIHRvIHJlcGVhdCBpbiBGaXJlZm94IGFuZCBPcGVyYVxuXHRcdFx0XHR2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcblx0XHRcdFx0c3dpdGNoKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGlucHV0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggc3VwcHJlc3NJbnB1dCApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gZmFsc2U7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2VhcmNoVGltZW91dCggZXZlbnQgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcblx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHRoaXMuX3ZhbHVlKCk7XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2FuY2VsQmx1ciApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5faW5pdFNvdXJjZSgpO1xuXHRcdHRoaXMubWVudSA9ICQoIFwiPHVsPlwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUgdWktZnJvbnRcIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuX2FwcGVuZFRvKCkgKVxuXHRcdFx0Lm1lbnUoe1xuXHRcdFx0XHQvLyBkaXNhYmxlIEFSSUEgc3VwcG9ydCwgdGhlIGxpdmUgcmVnaW9uIHRha2VzIGNhcmUgb2YgdGhhdFxuXHRcdFx0XHRyb2xlOiBudWxsXG5cdFx0XHR9KVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmRhdGEoIFwidWktbWVudVwiICk7XG5cblx0XHR0aGlzLl9vbiggdGhpcy5tZW51LmVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBwcmV2ZW50IG1vdmluZyBmb2N1cyBvdXQgb2YgdGhlIHRleHQgZmllbGRcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHQvLyBJRSBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRcdC8vIHNvIHdlIHNldCBhIGZsYWcgdG8ga25vdyB3aGVuIHdlIHNob3VsZCBpZ25vcmUgdGhlIGJsdXIgZXZlbnRcblx0XHRcdFx0dGhpcy5jYW5jZWxCbHVyID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuY2FuY2VsQmx1cjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gY2xpY2tpbmcgb24gdGhlIHNjcm9sbGJhciBjYXVzZXMgZm9jdXMgdG8gc2hpZnQgdG8gdGhlIGJvZHlcblx0XHRcdFx0Ly8gYnV0IHdlIGNhbid0IGRldGVjdCBhIG1vdXNldXAgb3IgYSBjbGljayBpbW1lZGlhdGVseSBhZnRlcndhcmRcblx0XHRcdFx0Ly8gc28gd2UgaGF2ZSB0byB0cmFjayB0aGUgbmV4dCBtb3VzZWRvd24gYW5kIGNsb3NlIHRoZSBtZW51IGlmXG5cdFx0XHRcdC8vIHRoZSB1c2VyIGNsaWNrcyBzb21ld2hlcmUgb3V0c2lkZSBvZiB0aGUgYXV0b2NvbXBsZXRlXG5cdFx0XHRcdHZhciBtZW51RWxlbWVudCA9IHRoaXMubWVudS5lbGVtZW50WyAwIF07XG5cdFx0XHRcdGlmICggISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0dGhpcy5kb2N1bWVudC5vbmUoIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgIT09IHRoYXQuZWxlbWVudFsgMCBdICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRldmVudC50YXJnZXQgIT09IG1lbnVFbGVtZW50ICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQhJC5jb250YWlucyggbWVudUVsZW1lbnQsIGV2ZW50LnRhcmdldCApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoYXQuY2xvc2UoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtZW51Zm9jdXM6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdC8vIHN1cHBvcnQ6IEZpcmVmb3hcblx0XHRcdFx0Ly8gUHJldmVudCBhY2NpZGVudGFsIGFjdGl2YXRpb24gb2YgbWVudSBpdGVtcyBpbiBGaXJlZm94ICgjNzAyNCAjOTExOClcblx0XHRcdFx0aWYgKCB0aGlzLmlzTmV3TWVudSApIHtcblx0XHRcdFx0XHR0aGlzLmlzTmV3TWVudSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudCAmJiAvXm1vdXNlLy50ZXN0KCBldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5ibHVyKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuZG9jdW1lbnQub25lKCBcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0JCggZXZlbnQudGFyZ2V0ICkudHJpZ2dlciggZXZlbnQub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YSggXCJ1aS1hdXRvY29tcGxldGUtaXRlbVwiICk7XG5cdFx0XHRcdGlmICggZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICkgKSB7XG5cdFx0XHRcdFx0Ly8gdXNlIHZhbHVlIHRvIG1hdGNoIHdoYXQgd2lsbCBlbmQgdXAgaW4gdGhlIGlucHV0LCBpZiBpdCB3YXMgYSBrZXkgZXZlbnRcblx0XHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgL15rZXkvLnRlc3QoIGV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWUoIGl0ZW0udmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gTm9ybWFsbHkgdGhlIGlucHV0IGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBpdGVtJ3MgdmFsdWUgYXMgdGhlXG5cdFx0XHRcdFx0Ly8gbWVudSBpcyBuYXZpZ2F0ZWQsIGNhdXNpbmcgc2NyZWVuIHJlYWRlcnMgdG8gbm90aWNlIGEgY2hhbmdlIGFuZFxuXHRcdFx0XHRcdC8vIGFubm91bmNlIHRoZSBpdGVtLiBTaW5jZSB0aGUgZm9jdXMgZXZlbnQgd2FzIGNhbmNlbGVkLCB0aGlzIGRvZXNuJ3Rcblx0XHRcdFx0XHQvLyBoYXBwZW4sIHNvIHdlIHVwZGF0ZSB0aGUgbGl2ZSByZWdpb24gc28gdGhhdCBzY3JlZW4gcmVhZGVycyBjYW5cblx0XHRcdFx0XHQvLyBzdGlsbCBub3RpY2UgdGhlIGNoYW5nZSBhbmQgYW5ub3VuY2UgaXQuXG5cdFx0XHRcdFx0dGhpcy5saXZlUmVnaW9uLnRleHQoIGl0ZW0udmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1lbnVzZWxlY3Q6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gdWkuaXRlbS5kYXRhKCBcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIgKSxcblx0XHRcdFx0XHRwcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG5cblx0XHRcdFx0Ly8gb25seSB0cmlnZ2VyIHdoZW4gZm9jdXMgd2FzIGxvc3QgKGNsaWNrIG9uIG1lbnUpXG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZvY3VzKCk7XG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdC8vICM2MTA5IC0gSUUgdHJpZ2dlcnMgdHdvIGZvY3VzIGV2ZW50cyBhbmQgdGhlIHNlY29uZFxuXHRcdFx0XHRcdC8vIGlzIGFzeW5jaHJvbm91cywgc28gd2UgbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXNcblx0XHRcdFx0XHQvLyB0ZXJtIHN5bmNocm9ub3VzbHkgYW5kIGFzeW5jaHJvbm91c2x5IDotKFxuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBmYWxzZSAhPT0gdGhpcy5fdHJpZ2dlciggXCJzZWxlY3RcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWUoIGl0ZW0udmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXNldCB0aGUgdGVybSBhZnRlciB0aGUgc2VsZWN0IGV2ZW50XG5cdFx0XHRcdC8vIHRoaXMgYWxsb3dzIGN1c3RvbSBzZWxlY3QgaGFuZGxpbmcgdG8gd29yayBwcm9wZXJseVxuXHRcdFx0XHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMubGl2ZVJlZ2lvbiA9ICQoIFwiPHNwYW4+XCIsIHtcblx0XHRcdFx0cm9sZTogXCJzdGF0dXNcIixcblx0XHRcdFx0XCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIlxuXHRcdFx0fSlcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcIiApXG5cdFx0XHQuaW5zZXJ0QmVmb3JlKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdC8vIHR1cm5pbmcgb2ZmIGF1dG9jb21wbGV0ZSBwcmV2ZW50cyB0aGUgYnJvd3NlciBmcm9tIHJlbWVtYmVyaW5nIHRoZVxuXHRcdC8vIHZhbHVlIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIGhpc3RvcnksIHNvIHdlIHJlLWVuYWJsZSBhdXRvY29tcGxldGVcblx0XHQvLyBpZiB0aGUgcGFnZSBpcyB1bmxvYWRlZCBiZWZvcmUgdGhlIHdpZGdldCBpcyBkZXN0cm95ZWQuICM3NzkwXG5cdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7XG5cdFx0XHRiZWZvcmV1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMuc2VhcmNoaW5nICk7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWlucHV0XCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXV0b2NvbXBsZXRlXCIgKTtcblx0XHR0aGlzLm1lbnUuZWxlbWVudC5yZW1vdmUoKTtcblx0XHR0aGlzLmxpdmVSZWdpb24ucmVtb3ZlKCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0XHRpZiAoIGtleSA9PT0gXCJzb3VyY2VcIiApIHtcblx0XHRcdHRoaXMuX2luaXRTb3VyY2UoKTtcblx0XHR9XG5cdFx0aWYgKCBrZXkgPT09IFwiYXBwZW5kVG9cIiApIHtcblx0XHRcdHRoaXMubWVudS5lbGVtZW50LmFwcGVuZFRvKCB0aGlzLl9hcHBlbmRUbygpICk7XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgJiYgdmFsdWUgJiYgdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblx0fSxcblxuXHRfYXBwZW5kVG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xuXG5cdFx0aWYgKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUgP1xuXHRcdFx0XHQkKCBlbGVtZW50ICkgOlxuXHRcdFx0XHR0aGlzLmRvY3VtZW50LmZpbmQoIGVsZW1lbnQgKS5lcSggMCApO1xuXHRcdH1cblxuXHRcdGlmICggIWVsZW1lbnQgKSB7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmNsb3Nlc3QoIFwiLnVpLWZyb250XCIgKTtcblx0XHR9XG5cblx0XHRpZiAoICFlbGVtZW50Lmxlbmd0aCApIHtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmRvY3VtZW50WzBdLmJvZHk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH0sXG5cblx0X2luaXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcnJheSwgdXJsLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0aWYgKCAkLmlzQXJyYXkodGhpcy5vcHRpb25zLnNvdXJjZSkgKSB7XG5cdFx0XHRhcnJheSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IGZ1bmN0aW9uKCByZXF1ZXN0LCByZXNwb25zZSApIHtcblx0XHRcdFx0cmVzcG9uc2UoICQudWkuYXV0b2NvbXBsZXRlLmZpbHRlciggYXJyYXksIHJlcXVlc3QudGVybSApICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuc291cmNlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dXJsID0gdGhpcy5vcHRpb25zLnNvdXJjZTtcblx0XHRcdHRoaXMuc291cmNlID0gZnVuY3Rpb24oIHJlcXVlc3QsIHJlc3BvbnNlICkge1xuXHRcdFx0XHRpZiAoIHRoYXQueGhyICkge1xuXHRcdFx0XHRcdHRoYXQueGhyLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhhdC54aHIgPSAkLmFqYXgoe1xuXHRcdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHRcdGRhdGE6IHJlcXVlc3QsXG5cdFx0XHRcdFx0ZGF0YVR5cGU6IFwianNvblwiLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UoIGRhdGEgKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlKCBbXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZWFyY2hUaW1lb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnNlYXJjaGluZyApO1xuXHRcdHRoaXMuc2VhcmNoaW5nID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBvbmx5IHNlYXJjaCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcblx0XHRcdGlmICggdGhpcy50ZXJtICE9PSB0aGlzLl92YWx1ZSgpICkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuc2VhcmNoKCBudWxsLCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSApO1xuXHR9LFxuXG5cdHNlYXJjaDogZnVuY3Rpb24oIHZhbHVlLCBldmVudCApIHtcblx0XHR2YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMuX3ZhbHVlKCk7XG5cblx0XHQvLyBhbHdheXMgc2F2ZSB0aGUgYWN0dWFsIHZhbHVlLCBub3QgdGhlIG9uZSBwYXNzZWQgYXMgYW4gYXJndW1lbnRcblx0XHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0aWYgKCB2YWx1ZS5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWluTGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl90cmlnZ2VyKCBcInNlYXJjaFwiLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fc2VhcmNoKCB2YWx1ZSApO1xuXHR9LFxuXG5cdF9zZWFyY2g6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLnBlbmRpbmcrKztcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiApO1xuXHRcdHRoaXMuY2FuY2VsU2VhcmNoID0gZmFsc2U7XG5cblx0XHR0aGlzLnNvdXJjZSggeyB0ZXJtOiB2YWx1ZSB9LCB0aGlzLl9yZXNwb25zZSgpICk7XG5cdH0sXG5cblx0X3Jlc3BvbnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW5kZXggPSArK3RoaXMucmVxdWVzdEluZGV4O1xuXG5cdFx0cmV0dXJuICQucHJveHkoZnVuY3Rpb24oIGNvbnRlbnQgKSB7XG5cdFx0XHRpZiAoIGluZGV4ID09PSB0aGlzLnJlcXVlc3RJbmRleCApIHtcblx0XHRcdFx0dGhpcy5fX3Jlc3BvbnNlKCBjb250ZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucGVuZGluZy0tO1xuXHRcdFx0aWYgKCAhdGhpcy5wZW5kaW5nICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiApO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMgKTtcblx0fSxcblxuXHRfX3Jlc3BvbnNlOiBmdW5jdGlvbiggY29udGVudCApIHtcblx0XHRpZiAoIGNvbnRlbnQgKSB7XG5cdFx0XHRjb250ZW50ID0gdGhpcy5fbm9ybWFsaXplKCBjb250ZW50ICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXIoIFwicmVzcG9uc2VcIiwgbnVsbCwgeyBjb250ZW50OiBjb250ZW50IH0gKTtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCAmJiAhdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHR0aGlzLl9zdWdnZXN0KCBjb250ZW50ICk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcIm9wZW5cIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB1c2UgLl9jbG9zZSgpIGluc3RlYWQgb2YgLmNsb3NlKCkgc28gd2UgZG9uJ3QgY2FuY2VsIGZ1dHVyZSBzZWFyY2hlc1xuXHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y2xvc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLmNhbmNlbFNlYXJjaCA9IHRydWU7XG5cdFx0dGhpcy5fY2xvc2UoIGV2ZW50ICk7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLm1lbnUuZWxlbWVudC5oaWRlKCk7XG5cdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXHRcdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjbG9zZVwiLCBldmVudCApO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLnByZXZpb3VzICE9PSB0aGlzLl92YWx1ZSgpICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQsIHsgaXRlbTogdGhpcy5zZWxlY3RlZEl0ZW0gfSApO1xuXHRcdH1cblx0fSxcblxuXHRfbm9ybWFsaXplOiBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0Ly8gYXNzdW1lIGFsbCBpdGVtcyBoYXZlIHRoZSByaWdodCBmb3JtYXQgd2hlbiB0aGUgZmlyc3QgaXRlbSBpcyBjb21wbGV0ZVxuXHRcdGlmICggaXRlbXMubGVuZ3RoICYmIGl0ZW1zWzBdLmxhYmVsICYmIGl0ZW1zWzBdLnZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0XHRyZXR1cm4gJC5tYXAoIGl0ZW1zLCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bGFiZWw6IGl0ZW0sXG5cdFx0XHRcdFx0dmFsdWU6IGl0ZW1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAkLmV4dGVuZCh7XG5cdFx0XHRcdGxhYmVsOiBpdGVtLmxhYmVsIHx8IGl0ZW0udmFsdWUsXG5cdFx0XHRcdHZhbHVlOiBpdGVtLnZhbHVlIHx8IGl0ZW0ubGFiZWxcblx0XHRcdH0sIGl0ZW0gKTtcblx0XHR9KTtcblx0fSxcblxuXHRfc3VnZ2VzdDogZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdHZhciB1bCA9IHRoaXMubWVudS5lbGVtZW50LmVtcHR5KCk7XG5cdFx0dGhpcy5fcmVuZGVyTWVudSggdWwsIGl0ZW1zICk7XG5cdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXHRcdHRoaXMubWVudS5yZWZyZXNoKCk7XG5cblx0XHQvLyBzaXplIGFuZCBwb3NpdGlvbiBtZW51XG5cdFx0dWwuc2hvdygpO1xuXHRcdHRoaXMuX3Jlc2l6ZU1lbnUoKTtcblx0XHR1bC5wb3NpdGlvbiggJC5leHRlbmQoe1xuXHRcdFx0b2Y6IHRoaXMuZWxlbWVudFxuXHRcdH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbiApKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyApIHtcblx0XHRcdHRoaXMubWVudS5uZXh0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNpemVNZW51OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWwgPSB0aGlzLm1lbnUuZWxlbWVudDtcblx0XHR1bC5vdXRlcldpZHRoKCBNYXRoLm1heChcblx0XHRcdC8vIEZpcmVmb3ggd3JhcHMgbG9uZyB0ZXh0IChwb3NzaWJseSBhIHJvdW5kaW5nIGJ1Zylcblx0XHRcdC8vIHNvIHdlIGFkZCAxcHggdG8gYXZvaWQgdGhlIHdyYXBwaW5nICgjNzUxMylcblx0XHRcdHVsLndpZHRoKCBcIlwiICkub3V0ZXJXaWR0aCgpICsgMSxcblx0XHRcdHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKClcblx0XHQpICk7XG5cdH0sXG5cblx0X3JlbmRlck1lbnU6IGZ1bmN0aW9uKCB1bCwgaXRlbXMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggaXRlbXMsIGZ1bmN0aW9uKCBpbmRleCwgaXRlbSApIHtcblx0XHRcdHRoYXQuX3JlbmRlckl0ZW1EYXRhKCB1bCwgaXRlbSApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9yZW5kZXJJdGVtRGF0YTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJJdGVtKCB1bCwgaXRlbSApLmRhdGEoIFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cIiwgaXRlbSApO1xuXHR9LFxuXG5cdF9yZW5kZXJJdGVtOiBmdW5jdGlvbiggdWwsIGl0ZW0gKSB7XG5cdFx0cmV0dXJuICQoIFwiPGxpPlwiIClcblx0XHRcdC5hcHBlbmQoICQoIFwiPGE+XCIgKS50ZXh0KCBpdGVtLmxhYmVsICkgKVxuXHRcdFx0LmFwcGVuZFRvKCB1bCApO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiggZGlyZWN0aW9uLCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLnNlYXJjaCggbnVsbCwgZXZlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm1lbnUuaXNGaXJzdEl0ZW0oKSAmJiAvXnByZXZpb3VzLy50ZXN0KCBkaXJlY3Rpb24gKSB8fFxuXHRcdFx0XHR0aGlzLm1lbnUuaXNMYXN0SXRlbSgpICYmIC9ebmV4dC8udGVzdCggZGlyZWN0aW9uICkgKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSggdGhpcy50ZXJtICk7XG5cdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm1lbnVbIGRpcmVjdGlvbiBdKCBldmVudCApO1xuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVudS5lbGVtZW50O1xuXHR9LFxuXG5cdF92YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVNZXRob2QuYXBwbHkoIHRoaXMuZWxlbWVudCwgYXJndW1lbnRzICk7XG5cdH0sXG5cblx0X2tleUV2ZW50OiBmdW5jdGlvbigga2V5RXZlbnQsIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuaXNNdWx0aUxpbmUgfHwgdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0dGhpcy5fbW92ZSgga2V5RXZlbnQsIGV2ZW50ICk7XG5cblx0XHRcdC8vIHByZXZlbnRzIG1vdmluZyBjdXJzb3IgdG8gYmVnaW5uaW5nL2VuZCBvZiB0aGUgdGV4dCBmaWVsZCBpbiBzb21lIGJyb3dzZXJzXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbiQuZXh0ZW5kKCAkLnVpLmF1dG9jb21wbGV0ZSwge1xuXHRlc2NhcGVSZWdleDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oYXJyYXksIHRlcm0pIHtcblx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoICQudWkuYXV0b2NvbXBsZXRlLmVzY2FwZVJlZ2V4KHRlcm0pLCBcImlcIiApO1xuXHRcdHJldHVybiAkLmdyZXAoIGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIG1hdGNoZXIudGVzdCggdmFsdWUubGFiZWwgfHwgdmFsdWUudmFsdWUgfHwgdmFsdWUgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxuLy8gbGl2ZSByZWdpb24gZXh0ZW5zaW9uLCBhZGRpbmcgYSBgbWVzc2FnZXNgIG9wdGlvblxuLy8gTk9URTogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgQVBJLiBXZSBhcmUgc3RpbGwgaW52ZXN0aWdhdGluZ1xuLy8gYSBmdWxsIHNvbHV0aW9uIGZvciBzdHJpbmcgbWFuaXB1bGF0aW9uIGFuZCBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiQud2lkZ2V0KCBcInVpLmF1dG9jb21wbGV0ZVwiLCAkLnVpLmF1dG9jb21wbGV0ZSwge1xuXHRvcHRpb25zOiB7XG5cdFx0bWVzc2FnZXM6IHtcblx0XHRcdG5vUmVzdWx0czogXCJObyBzZWFyY2ggcmVzdWx0cy5cIixcblx0XHRcdHJlc3VsdHM6IGZ1bmN0aW9uKCBhbW91bnQgKSB7XG5cdFx0XHRcdHJldHVybiBhbW91bnQgKyAoIGFtb3VudCA+IDEgPyBcIiByZXN1bHRzIGFyZVwiIDogXCIgcmVzdWx0IGlzXCIgKSArXG5cdFx0XHRcdFx0XCIgYXZhaWxhYmxlLCB1c2UgdXAgYW5kIGRvd24gYXJyb3cga2V5cyB0byBuYXZpZ2F0ZS5cIjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X19yZXNwb25zZTogZnVuY3Rpb24oIGNvbnRlbnQgKSB7XG5cdFx0dmFyIG1lc3NhZ2U7XG5cdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCApIHtcblx0XHRcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMucmVzdWx0cyggY29udGVudC5sZW5ndGggKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWVzc2FnZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlcy5ub1Jlc3VsdHM7XG5cdFx0fVxuXHRcdHRoaXMubGl2ZVJlZ2lvbi50ZXh0KCBtZXNzYWdlICk7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIENvcmUgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHJ1bmlxdWVJZCA9IC9edWktaWQtXFxkKyQvO1xuXG4vLyAkLnVpIG1pZ2h0IGV4aXN0IGZyb20gY29tcG9uZW50cyB3aXRoIG5vIGRlcGVuZGVuY2llcywgZS5nLiwgJC51aS5wb3NpdGlvblxuJC51aSA9ICQudWkgfHwge307XG5cbiQuZXh0ZW5kKCAkLnVpLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cblx0a2V5Q29kZToge1xuXHRcdEJBQ0tTUEFDRTogOCxcblx0XHRDT01NQTogMTg4LFxuXHRcdERFTEVURTogNDYsXG5cdFx0RE9XTjogNDAsXG5cdFx0RU5EOiAzNSxcblx0XHRFTlRFUjogMTMsXG5cdFx0RVNDQVBFOiAyNyxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUOiAzNyxcblx0XHROVU1QQURfQUREOiAxMDcsXG5cdFx0TlVNUEFEX0RFQ0lNQUw6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0TlVNUEFEX0VOVEVSOiAxMDgsXG5cdFx0TlVNUEFEX01VTFRJUExZOiAxMDYsXG5cdFx0TlVNUEFEX1NVQlRSQUNUOiAxMDksXG5cdFx0UEFHRV9ET1dOOiAzNCxcblx0XHRQQUdFX1VQOiAzMyxcblx0XHRQRVJJT0Q6IDE5MCxcblx0XHRSSUdIVDogMzksXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFRBQjogOSxcblx0XHRVUDogMzhcblx0fVxufSk7XG5cbi8vIHBsdWdpbnNcbiQuZm4uZXh0ZW5kKHtcblx0Zm9jdXM6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGRlbGF5LCBmbiApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQkKCBlbGVtICkuZm9jdXMoKTtcblx0XHRcdFx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoIGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBkZWxheSApO1xuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0pKCAkLmZuLmZvY3VzICksXG5cblx0c2Nyb2xsUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50O1xuXHRcdGlmICgoJC51aS5pZSAmJiAoLyhzdGF0aWN8cmVsYXRpdmUpLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSkgfHwgKC9hYnNvbHV0ZS8pLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKHJlbGF0aXZlfGFic29sdXRlfGZpeGVkKS8pLnRlc3QoJC5jc3ModGhpcyxcInBvc2l0aW9uXCIpKSAmJiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJvdmVyZmxvd1wiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteVwiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteFwiKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLFwib3ZlcmZsb3dcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXlcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXhcIikpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvZml4ZWQvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XG5cdH0sXG5cblx0ekluZGV4OiBmdW5jdGlvbiggekluZGV4ICkge1xuXHRcdGlmICggekluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jc3MoIFwiekluZGV4XCIsIHpJbmRleCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXNbIDAgXSApLCBwb3NpdGlvbiwgdmFsdWU7XG5cdFx0XHR3aGlsZSAoIGVsZW0ubGVuZ3RoICYmIGVsZW1bIDAgXSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdC8vIElnbm9yZSB6LWluZGV4IGlmIHBvc2l0aW9uIGlzIHNldCB0byBhIHZhbHVlIHdoZXJlIHotaW5kZXggaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlclxuXHRcdFx0XHQvLyBUaGlzIG1ha2VzIGJlaGF2aW9yIG9mIHRoaXMgZnVuY3Rpb24gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnNcblx0XHRcdFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxuXHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHQvLyBJRSByZXR1cm5zIDAgd2hlbiB6SW5kZXggaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0XHRcdC8vIG90aGVyIGJyb3dzZXJzIHJldHVybiBhIHN0cmluZ1xuXHRcdFx0XHRcdC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG5cdFx0XHRcdFx0Ly8gPGRpdiBzdHlsZT1cInotaW5kZXg6IC0xMDtcIj48ZGl2IHN0eWxlPVwiei1pbmRleDogMDtcIj48L2Rpdj48L2Rpdj5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KCBlbGVtLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApO1xuXHRcdFx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZSApICYmIHZhbHVlICE9PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtID0gZWxlbS5wYXJlbnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHR1bmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMuaWQgKSB7XG5cdFx0XHRcdHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKCsrdXVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlVW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bmlxdWVJZC50ZXN0KCB0aGlzLmlkICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVBdHRyKCBcImlkXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIHNlbGVjdG9yc1xuZnVuY3Rpb24gZm9jdXNhYmxlKCBlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOICkge1xuXHR2YXIgbWFwLCBtYXBOYW1lLCBpbWcsXG5cdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmICggXCJhcmVhXCIgPT09IG5vZGVOYW1lICkge1xuXHRcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRtYXBOYW1lID0gbWFwLm5hbWU7XG5cdFx0aWYgKCAhZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1hcFwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpbWcgPSAkKCBcImltZ1t1c2VtYXA9I1wiICsgbWFwTmFtZSArIFwiXVwiIClbMF07XG5cdFx0cmV0dXJuICEhaW1nICYmIHZpc2libGUoIGltZyApO1xuXHR9XG5cdHJldHVybiAoIC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdCggbm9kZU5hbWUgKSA/XG5cdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFwiYVwiID09PSBub2RlTmFtZSA/XG5cdFx0XHRlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdFx0XHRpc1RhYkluZGV4Tm90TmFOKSAmJlxuXHRcdC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcblx0XHR2aXNpYmxlKCBlbGVtZW50ICk7XG59XG5cbmZ1bmN0aW9uIHZpc2libGUoIGVsZW1lbnQgKSB7XG5cdHJldHVybiAkLmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtZW50ICkgJiZcblx0XHQhJCggZWxlbWVudCApLnBhcmVudHMoKS5hZGRCYWNrKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQuY3NzKCB0aGlzLCBcInZpc2liaWxpdHlcIiApID09PSBcImhpZGRlblwiO1xuXHRcdH0pLmxlbmd0aDtcbn1cblxuJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHRkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID9cblx0XHQkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKCBkYXRhTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBkYXRhTmFtZSApO1xuXHRcdFx0fTtcblx0XHR9KSA6XG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIG1hdGNoWyAzIF0gKTtcblx0XHR9LFxuXG5cdGZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzTmFOKCAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApICkgKTtcblx0fSxcblxuXHR0YWJiYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRhYkluZGV4ID0gJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSxcblx0XHRcdGlzVGFiSW5kZXhOYU4gPSBpc05hTiggdGFiSW5kZXggKTtcblx0XHRyZXR1cm4gKCBpc1RhYkluZGV4TmFOIHx8IHRhYkluZGV4ID49IDAgKSAmJiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc1RhYkluZGV4TmFOICk7XG5cdH1cbn0pO1xuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJCggXCI8YT5cIiApLm91dGVyV2lkdGgoIDEgKS5qcXVlcnkgKSB7XG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cblx0XHQkLmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJpbm5lclwiICsgbmFtZSBdLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCBzaXplLCBtYXJnaW4gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJvdXRlclwiICsgbmFtZSBdLmNhbGwoIHRoaXMsIHNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcykuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQuZm4uYWRkQmFjayApIHtcblx0JC5mbi5hZGRCYWNrID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDEuNi4xLCAxLjYuMiAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxMylcbmlmICggJCggXCI8YT5cIiApLmRhdGEoIFwiYS1iXCIsIFwiYVwiICkucmVtb3ZlRGF0YSggXCJhLWJcIiApLmRhdGEoIFwiYS1iXCIgKSApIHtcblx0JC5mbi5yZW1vdmVEYXRhID0gKGZ1bmN0aW9uKCByZW1vdmVEYXRhICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzLCAkLmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVEYXRhICk7XG59XG5cblxuXG5cblxuLy8gZGVwcmVjYXRlZFxuJC51aS5pZSA9ICEhL21zaWUgW1xcdy5dKy8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICk7XG5cbiQuc3VwcG9ydC5zZWxlY3RzdGFydCA9IFwib25zZWxlY3RzdGFydFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcbiQuZm4uZXh0ZW5kKHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmluZCggKCAkLnN1cHBvcnQuc2VsZWN0c3RhcnQgPyBcInNlbGVjdHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiICkgK1xuXHRcdFx0XCIudWktZGlzYWJsZVNlbGVjdGlvblwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHRlbmFibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVuYmluZCggXCIudWktZGlzYWJsZVNlbGVjdGlvblwiICk7XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aSwge1xuXHQvLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiBVc2UgJC53aWRnZXQoKSBleHRlbnNpb25zIGluc3RlYWQuXG5cdHBsdWdpbjoge1xuXHRcdGFkZDogZnVuY3Rpb24oIG1vZHVsZSwgb3B0aW9uLCBzZXQgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0cHJvdG8gPSAkLnVpWyBtb2R1bGUgXS5wcm90b3R5cGU7XG5cdFx0XHRmb3IgKCBpIGluIHNldCApIHtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0XHRwcm90by5wbHVnaW5zWyBpIF0ucHVzaCggWyBvcHRpb24sIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgbmFtZSwgYXJncyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzZXQgPSBpbnN0YW5jZS5wbHVnaW5zWyBuYW1lIF07XG5cdFx0XHRpZiAoICFzZXQgfHwgIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8IGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdFx0c2V0WyBpIF1bIDEgXS5hcHBseSggaW5zdGFuY2UuZWxlbWVudCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIG9ubHkgdXNlZCBieSByZXNpemFibGVcblx0aGFzU2Nyb2xsOiBmdW5jdGlvbiggZWwsIGEgKSB7XG5cblx0XHQvL0lmIG92ZXJmbG93IGlzIGhpZGRlbiwgdGhlIGVsZW1lbnQgbWlnaHQgaGF2ZSBleHRyYSBjb250ZW50LCBidXQgdGhlIHVzZXIgd2FudHMgdG8gaGlkZSBpdFxuXHRcdGlmICggJCggZWwgKS5jc3MoIFwib3ZlcmZsb3dcIiApID09PSBcImhpZGRlblwiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHNjcm9sbCA9ICggYSAmJiBhID09PSBcImxlZnRcIiApID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiLFxuXHRcdFx0aGFzID0gZmFsc2U7XG5cblx0XHRpZiAoIGVsWyBzY3JvbGwgXSA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBkZXRlcm1pbmUgd2hpY2ggY2FzZXMgYWN0dWFsbHkgY2F1c2UgdGhpcyB0byBoYXBwZW5cblx0XHQvLyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgdGhlIHNjcm9sbCBzZXQsIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvXG5cdFx0Ly8gc2V0IHRoZSBzY3JvbGxcblx0XHRlbFsgc2Nyb2xsIF0gPSAxO1xuXHRcdGhhcyA9ICggZWxbIHNjcm9sbCBdID4gMCApO1xuXHRcdGVsWyBzY3JvbGwgXSA9IDA7XG5cdFx0cmV0dXJuIGhhcztcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcbnJlcXVpcmUoJy4vcG9zaXRpb24nKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgTWVudSAxLjEwLjRcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vbWVudS9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS5jb3JlLmpzXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICpcdGpxdWVyeS51aS5wb3NpdGlvbi5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwidWkubWVudVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjx1bD5cIixcblx0ZGVsYXk6IDMwMCxcblx0b3B0aW9uczoge1xuXHRcdGljb25zOiB7XG5cdFx0XHRzdWJtZW51OiBcInVpLWljb24tY2FyYXQtMS1lXCJcblx0XHR9LFxuXHRcdG1lbnVzOiBcInVsXCIsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdG15OiBcImxlZnQgdG9wXCIsXG5cdFx0XHRhdDogXCJyaWdodCB0b3BcIlxuXHRcdH0sXG5cdFx0cm9sZTogXCJtZW51XCIsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRibHVyOiBudWxsLFxuXHRcdGZvY3VzOiBudWxsLFxuXHRcdHNlbGVjdDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYWN0aXZlTWVudSA9IHRoaXMuZWxlbWVudDtcblx0XHQvLyBmbGFnIHVzZWQgdG8gcHJldmVudCBmaXJpbmcgb2YgdGhlIGNsaWNrIGhhbmRsZXJcblx0XHQvLyBhcyB0aGUgZXZlbnQgYnViYmxlcyB1cCB0aHJvdWdoIG5lc3RlZCBtZW51c1xuXHRcdHRoaXMubW91c2VIYW5kbGVkID0gZmFsc2U7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktbWVudS1pY29uc1wiLCAhIXRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1pY29uXCIgKS5sZW5ndGggKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdH0pXG5cdFx0XHQvLyBuZWVkIHRvIGNhdGNoIGFsbCBjbGlja3Mgb24gZGlzYWJsZWQgbWVudVxuXHRcdFx0Ly8gbm90IHBvc3NpYmxlIHRocm91Z2ggX29uXG5cdFx0XHQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgJC5wcm94eShmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMgKSk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbih7XG5cdFx0XHQvLyBQcmV2ZW50IGZvY3VzIGZyb20gc3RpY2tpbmcgdG8gbGlua3MgaW5zaWRlIG1lbnUgYWZ0ZXIgY2xpY2tpbmdcblx0XHRcdC8vIHRoZW0gKGZvY3VzIHNob3VsZCBhbHdheXMgc3RheSBvbiBVTCBkdXJpbmcgbmF2aWdhdGlvbikuXG5cdFx0XHRcIm1vdXNlZG93biAudWktbWVudS1pdGVtID4gYVwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9LFxuXHRcdFx0XCJjbGljayAudWktc3RhdGUtZGlzYWJsZWQgPiBhXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0sXG5cdFx0XHRcImNsaWNrIC51aS1tZW51LWl0ZW06aGFzKGEpXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICk7XG5cdFx0XHRcdGlmICggIXRoaXMubW91c2VIYW5kbGVkICYmIHRhcmdldC5ub3QoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3QoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHQvLyBPbmx5IHNldCB0aGUgbW91c2VIYW5kbGVkIGZsYWcgaWYgdGhlIGV2ZW50IHdpbGwgYnViYmxlLCBzZWUgIzk0NjkuXG5cdFx0XHRcdFx0aWYgKCAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubW91c2VIYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPcGVuIHN1Ym1lbnUgb24gY2xpY2tcblx0XHRcdFx0XHRpZiAoIHRhcmdldC5oYXMoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZXhwYW5kKCBldmVudCApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICF0aGlzLmVsZW1lbnQuaXMoIFwiOmZvY3VzXCIgKSAmJiAkKCB0aGlzLmRvY3VtZW50WyAwIF0uYWN0aXZlRWxlbWVudCApLmNsb3Nlc3QoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVkaXJlY3QgZm9jdXMgdG8gdGhlIG1lbnVcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBcImZvY3VzXCIsIFsgdHJ1ZSBdICk7XG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBhY3RpdmUgaXRlbSBpcyBvbiB0aGUgdG9wIGxldmVsLCBsZXQgaXQgc3RheSBhY3RpdmUuXG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGJsdXIgdGhlIGFjdGl2ZSBpdGVtIHNpbmNlIGl0IGlzIG5vIGxvbmdlciB2aXNpYmxlLlxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmFjdGl2ZSAmJiB0aGlzLmFjdGl2ZS5wYXJlbnRzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdFwibW91c2VlbnRlciAudWktbWVudS1pdGVtXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKTtcblx0XHRcdFx0Ly8gUmVtb3ZlIHVpLXN0YXRlLWFjdGl2ZSBjbGFzcyBmcm9tIHNpYmxpbmdzIG9mIHRoZSBuZXdseSBmb2N1c2VkIG1lbnUgaXRlbVxuXHRcdFx0XHQvLyB0byBhdm9pZCBhIGp1bXAgY2F1c2VkIGJ5IGFkamFjZW50IGVsZW1lbnRzIGJvdGggaGF2aW5nIGEgY2xhc3Mgd2l0aCBhIGJvcmRlclxuXHRcdFx0XHR0YXJnZXQuc2libGluZ3MoKS5jaGlsZHJlbiggXCIudWktc3RhdGUtYWN0aXZlXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGFyZ2V0ICk7XG5cdFx0XHR9LFxuXHRcdFx0bW91c2VsZWF2ZTogXCJjb2xsYXBzZUFsbFwiLFxuXHRcdFx0XCJtb3VzZWxlYXZlIC51aS1tZW51XCI6IFwiY29sbGFwc2VBbGxcIixcblx0XHRcdGZvY3VzOiBmdW5jdGlvbiggZXZlbnQsIGtlZXBBY3RpdmVJdGVtICkge1xuXHRcdFx0XHQvLyBJZiB0aGVyZSdzIGFscmVhZHkgYW4gYWN0aXZlIGl0ZW0sIGtlZXAgaXQgYWN0aXZlXG5cdFx0XHRcdC8vIElmIG5vdCwgYWN0aXZhdGUgdGhlIGZpcnN0IGl0ZW1cblx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZSB8fCB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZXEoIDAgKTtcblxuXHRcdFx0XHRpZiAoICFrZWVwQWN0aXZlSXRlbSApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoICEkLmNvbnRhaW5zKCB0aGlzLmVsZW1lbnRbMF0sIHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb2xsYXBzZUFsbCggZXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGtleWRvd246IFwiX2tleWRvd25cIlxuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cblx0XHQvLyBDbGlja3Mgb3V0c2lkZSBvZiBhIG1lbnUgY29sbGFwc2UgYW55IG9wZW4gbWVudXNcblx0XHR0aGlzLl9vbiggdGhpcy5kb2N1bWVudCwge1xuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCAhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuY29sbGFwc2VBbGwoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCB0aGUgbW91c2VIYW5kbGVkIGZsYWdcblx0XHRcdFx0dGhpcy5tb3VzZUhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gRGVzdHJveSAoc3ViKW1lbnVzXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiApXG5cdFx0XHQuZmluZCggXCIudWktbWVudVwiICkuYWRkQmFjaygpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLW1lbnUtaWNvbnNcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInRhYkluZGV4XCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZXhwYW5kZWRcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtaGlkZGVuXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0XHQucmVtb3ZlVW5pcXVlSWQoKVxuXHRcdFx0XHQuc2hvdygpO1xuXG5cdFx0Ly8gRGVzdHJveSBtZW51IGl0ZW1zXG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1tZW51LWl0ZW1cIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiIClcblx0XHRcdC5jaGlsZHJlbiggXCJhXCIgKVxuXHRcdFx0XHQucmVtb3ZlVW5pcXVlSWQoKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWFsbCB1aS1zdGF0ZS1ob3ZlclwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtaGFzcG9wdXBcIiApXG5cdFx0XHRcdC5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBlbGVtID0gJCggdGhpcyApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5kYXRhKCBcInVpLW1lbnUtc3VibWVudS1jYXJhdFwiICkgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHQvLyBEZXN0cm95IG1lbnUgZGl2aWRlcnNcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudS1kaXZpZGVyXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1tZW51LWRpdmlkZXIgdWktd2lkZ2V0LWNvbnRlbnRcIiApO1xuXHR9LFxuXG5cdF9rZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG1hdGNoLCBwcmV2LCBjaGFyYWN0ZXIsIHNraXAsIHJlZ2V4LFxuXHRcdFx0cHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG5cdFx0ZnVuY3Rpb24gZXNjYXBlKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIgKTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHR0aGlzLnByZXZpb3VzUGFnZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdHRoaXMubmV4dFBhZ2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0dGhpcy5fbW92ZSggXCJmaXJzdFwiLCBcImZpcnN0XCIsIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHR0aGlzLl9tb3ZlKCBcImxhc3RcIiwgXCJsYXN0XCIsIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdHRoaXMucHJldmlvdXMoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0dGhpcy5uZXh0KCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcblx0XHRcdHRoaXMuY29sbGFwc2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcblx0XHRcdGlmICggdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdHRoaXMuZXhwYW5kKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5URVI6XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuU1BBQ0U6XG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVTQ0FQRTpcblx0XHRcdHRoaXMuY29sbGFwc2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHJldmVudERlZmF1bHQgPSBmYWxzZTtcblx0XHRcdHByZXYgPSB0aGlzLnByZXZpb3VzRmlsdGVyIHx8IFwiXCI7XG5cdFx0XHRjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBldmVudC5rZXlDb2RlICk7XG5cdFx0XHRza2lwID0gZmFsc2U7XG5cblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5maWx0ZXJUaW1lciApO1xuXG5cdFx0XHRpZiAoIGNoYXJhY3RlciA9PT0gcHJldiApIHtcblx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGFyYWN0ZXIgPSBwcmV2ICsgY2hhcmFjdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWdleCA9IG5ldyBSZWdFeHAoIFwiXlwiICsgZXNjYXBlKCBjaGFyYWN0ZXIgKSwgXCJpXCIgKTtcblx0XHRcdG1hdGNoID0gdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHJlZ2V4LnRlc3QoICQoIHRoaXMgKS5jaGlsZHJlbiggXCJhXCIgKS50ZXh0KCkgKTtcblx0XHRcdH0pO1xuXHRcdFx0bWF0Y2ggPSBza2lwICYmIG1hdGNoLmluZGV4KCB0aGlzLmFjdGl2ZS5uZXh0KCkgKSAhPT0gLTEgP1xuXHRcdFx0XHR0aGlzLmFjdGl2ZS5uZXh0QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApIDpcblx0XHRcdFx0bWF0Y2g7XG5cblx0XHRcdC8vIElmIG5vIG1hdGNoZXMgb24gdGhlIGN1cnJlbnQgZmlsdGVyLCByZXNldCB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJlc3NlZFxuXHRcdFx0Ly8gdG8gbW92ZSBkb3duIHRoZSBtZW51IHRvIHRoZSBmaXJzdCBpdGVtIHRoYXQgc3RhcnRzIHdpdGggdGhhdCBjaGFyYWN0ZXJcblx0XHRcdGlmICggIW1hdGNoLmxlbmd0aCApIHtcblx0XHRcdFx0Y2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSggZXZlbnQua2V5Q29kZSApO1xuXHRcdFx0XHRyZWdleCA9IG5ldyBSZWdFeHAoIFwiXlwiICsgZXNjYXBlKCBjaGFyYWN0ZXIgKSwgXCJpXCIgKTtcblx0XHRcdFx0bWF0Y2ggPSB0aGlzLmFjdGl2ZU1lbnUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiByZWdleC50ZXN0KCAkKCB0aGlzICkuY2hpbGRyZW4oIFwiYVwiICkudGV4dCgpICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGNoLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIG1hdGNoICk7XG5cdFx0XHRcdGlmICggbWF0Y2gubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHR0aGlzLnByZXZpb3VzRmlsdGVyID0gY2hhcmFjdGVyO1xuXHRcdFx0XHRcdHRoaXMuZmlsdGVyVGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyO1xuXHRcdFx0XHRcdH0sIDEwMDAgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMucHJldmlvdXNGaWx0ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBwcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hY3RpdmF0ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuYWN0aXZlLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRpZiAoIHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcImFbYXJpYS1oYXNwb3B1cD0ndHJ1ZSddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMuZXhwYW5kKCBldmVudCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZW51cyxcblx0XHRcdGljb24gPSB0aGlzLm9wdGlvbnMuaWNvbnMuc3VibWVudSxcblx0XHRcdHN1Ym1lbnVzID0gdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5tZW51cyApO1xuXG5cdFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKCBcInVpLW1lbnUtaWNvbnNcIiwgISF0aGlzLmVsZW1lbnQuZmluZCggXCIudWktaWNvblwiICkubGVuZ3RoICk7XG5cblx0XHQvLyBJbml0aWFsaXplIG5lc3RlZCBtZW51c1xuXHRcdHN1Ym1lbnVzLmZpbHRlciggXCI6bm90KC51aS1tZW51KVwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIlxuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWVudSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRpdGVtID0gbWVudS5wcmV2KCBcImFcIiApLFxuXHRcdFx0XHRcdHN1Ym1lbnVDYXJhdCA9ICQoIFwiPHNwYW4+XCIgKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUtaWNvbiB1aS1pY29uIFwiICsgaWNvbiApXG5cdFx0XHRcdFx0XHQuZGF0YSggXCJ1aS1tZW51LXN1Ym1lbnUtY2FyYXRcIiwgdHJ1ZSApO1xuXG5cdFx0XHRcdGl0ZW1cblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiIClcblx0XHRcdFx0XHQucHJlcGVuZCggc3VibWVudUNhcmF0ICk7XG5cdFx0XHRcdG1lbnUuYXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiwgaXRlbS5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0fSk7XG5cblx0XHRtZW51cyA9IHN1Ym1lbnVzLmFkZCggdGhpcy5lbGVtZW50ICk7XG5cblx0XHQvLyBEb24ndCByZWZyZXNoIGxpc3QgaXRlbXMgdGhhdCBhcmUgYWxyZWFkeSBhZGFwdGVkXG5cdFx0bWVudXMuY2hpbGRyZW4oIFwiOm5vdCgudWktbWVudS1pdGVtKTpoYXMoYSlcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiIClcblx0XHRcdC5jaGlsZHJlbiggXCJhXCIgKVxuXHRcdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiIClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHRhYkluZGV4OiAtMSxcblx0XHRcdFx0XHRyb2xlOiB0aGlzLl9pdGVtUm9sZSgpXG5cdFx0XHRcdH0pO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB1bmxpbmtlZCBtZW51LWl0ZW1zIGNvbnRhaW5pbmcgc3BhY2VzIGFuZC9vciBkYXNoZXMgb25seSBhcyBkaXZpZGVyc1xuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIjpub3QoLnVpLW1lbnUtaXRlbSlcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdC8vIGh5cGhlbiwgZW0gZGFzaCwgZW4gZGFzaFxuXHRcdFx0aWYgKCAhL1teXFwtXFx1MjAxNFxcdTIwMTNcXHNdLy50ZXN0KCBpdGVtLnRleHQoKSApICkge1xuXHRcdFx0XHRpdGVtLmFkZENsYXNzKCBcInVpLXdpZGdldC1jb250ZW50IHVpLW1lbnUtZGl2aWRlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBBZGQgYXJpYS1kaXNhYmxlZCBhdHRyaWJ1dGUgdG8gYW55IGRpc2FibGVkIG1lbnUgaXRlbVxuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHQvLyBJZiB0aGUgYWN0aXZlIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZCwgYmx1ciB0aGUgbWVudVxuXHRcdGlmICggdGhpcy5hY3RpdmUgJiYgISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFsgMCBdLCB0aGlzLmFjdGl2ZVsgMCBdICkgKSB7XG5cdFx0XHR0aGlzLmJsdXIoKTtcblx0XHR9XG5cdH0sXG5cblx0X2l0ZW1Sb2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWVudTogXCJtZW51aXRlbVwiLFxuXHRcdFx0bGlzdGJveDogXCJvcHRpb25cIlxuXHRcdH1bIHRoaXMub3B0aW9ucy5yb2xlIF07XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiaWNvbnNcIiApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51LWljb25cIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5vcHRpb25zLmljb25zLnN1Ym1lbnUgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHZhbHVlLnN1Ym1lbnUgKTtcblx0XHR9XG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0fSxcblxuXHRmb2N1czogZnVuY3Rpb24oIGV2ZW50LCBpdGVtICkge1xuXHRcdHZhciBuZXN0ZWQsIGZvY3VzZWQ7XG5cdFx0dGhpcy5ibHVyKCBldmVudCwgZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJmb2N1c1wiICk7XG5cblx0XHR0aGlzLl9zY3JvbGxJbnRvVmlldyggaXRlbSApO1xuXG5cdFx0dGhpcy5hY3RpdmUgPSBpdGVtLmZpcnN0KCk7XG5cdFx0Zm9jdXNlZCA9IHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcImFcIiApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHQvLyBPbmx5IHVwZGF0ZSBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQgaWYgdGhlcmUncyBhIHJvbGVcblx0XHQvLyBvdGhlcndpc2Ugd2UgYXNzdW1lIGZvY3VzIGlzIG1hbmFnZWQgZWxzZXdoZXJlXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucm9sZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBmb2N1c2VkLmF0dHIoIFwiaWRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gSGlnaGxpZ2h0IGFjdGl2ZSBwYXJlbnQgbWVudSBpdGVtLCBpZiBhbnlcblx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0LnBhcmVudCgpXG5cdFx0XHQuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LmNoaWxkcmVuKCBcImE6Zmlyc3RcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdGlmICggZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIgKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0XHR9LCB0aGlzLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0bmVzdGVkID0gaXRlbS5jaGlsZHJlbiggXCIudWktbWVudVwiICk7XG5cdFx0aWYgKCBuZXN0ZWQubGVuZ3RoICYmIGV2ZW50ICYmICggL15tb3VzZS8udGVzdCggZXZlbnQudHlwZSApICkgKSB7XG5cdFx0XHR0aGlzLl9zdGFydE9wZW5pbmcobmVzdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5hY3RpdmVNZW51ID0gaXRlbS5wYXJlbnQoKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICk7XG5cdH0sXG5cblx0X3Njcm9sbEludG9WaWV3OiBmdW5jdGlvbiggaXRlbSApIHtcblx0XHR2YXIgYm9yZGVyVG9wLCBwYWRkaW5nVG9wLCBvZmZzZXQsIHNjcm9sbCwgZWxlbWVudEhlaWdodCwgaXRlbUhlaWdodDtcblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0Ym9yZGVyVG9wID0gcGFyc2VGbG9hdCggJC5jc3MoIHRoaXMuYWN0aXZlTWVudVswXSwgXCJib3JkZXJUb3BXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0cGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoICQuY3NzKCB0aGlzLmFjdGl2ZU1lbnVbMF0sIFwicGFkZGluZ1RvcFwiICkgKSB8fCAwO1xuXHRcdFx0b2Zmc2V0ID0gaXRlbS5vZmZzZXQoKS50b3AgLSB0aGlzLmFjdGl2ZU1lbnUub2Zmc2V0KCkudG9wIC0gYm9yZGVyVG9wIC0gcGFkZGluZ1RvcDtcblx0XHRcdHNjcm9sbCA9IHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3AoKTtcblx0XHRcdGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFjdGl2ZU1lbnUuaGVpZ2h0KCk7XG5cdFx0XHRpdGVtSGVpZ2h0ID0gaXRlbS5oZWlnaHQoKTtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPCAwICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9mZnNldCArIGl0ZW1IZWlnaHQgPiBlbGVtZW50SGVpZ2h0ICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgLSBlbGVtZW50SGVpZ2h0ICsgaXRlbUhlaWdodCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRibHVyOiBmdW5jdGlvbiggZXZlbnQsIGZyb21Gb2N1cyApIHtcblx0XHRpZiAoICFmcm9tRm9jdXMgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmFjdGl2ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmFjdGl2ZS5jaGlsZHJlbiggXCJhXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0dGhpcy5hY3RpdmUgPSBudWxsO1xuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJibHVyXCIsIGV2ZW50LCB7IGl0ZW06IHRoaXMuYWN0aXZlIH0gKTtcblx0fSxcblxuXHRfc3RhcnRPcGVuaW5nOiBmdW5jdGlvbiggc3VibWVudSApIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblxuXHRcdC8vIERvbid0IG9wZW4gaWYgYWxyZWFkeSBvcGVuIGZpeGVzIGEgRmlyZWZveCBidWcgdGhhdCBjYXVzZWQgYSAuNSBwaXhlbFxuXHRcdC8vIHNoaWZ0IGluIHRoZSBzdWJtZW51IHBvc2l0aW9uIHdoZW4gbW91c2luZyBvdmVyIHRoZSBjYXJhdCBpY29uXG5cdFx0aWYgKCBzdWJtZW51LmF0dHIoIFwiYXJpYS1oaWRkZW5cIiApICE9PSBcInRydWVcIiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0dGhpcy5fb3Blbiggc3VibWVudSApO1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHRfb3BlbjogZnVuY3Rpb24oIHN1Ym1lbnUgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gJC5leHRlbmQoe1xuXHRcdFx0b2Y6IHRoaXMuYWN0aXZlXG5cdFx0fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uICk7XG5cblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudVwiICkubm90KCBzdWJtZW51LnBhcmVudHMoIFwiLnVpLW1lbnVcIiApIClcblx0XHRcdC5oaWRlKClcblx0XHRcdC5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRzdWJtZW51XG5cdFx0XHQuc2hvdygpXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdC5hdHRyKCBcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIgKVxuXHRcdFx0LnBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXHR9LFxuXG5cdGNvbGxhcHNlQWxsOiBmdW5jdGlvbiggZXZlbnQsIGFsbCApIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiB3ZSB3ZXJlIHBhc3NlZCBhbiBldmVudCwgbG9vayBmb3IgdGhlIHN1Ym1lbnUgdGhhdCBjb250YWlucyB0aGUgZXZlbnRcblx0XHRcdHZhciBjdXJyZW50TWVudSA9IGFsbCA/IHRoaXMuZWxlbWVudCA6XG5cdFx0XHRcdCQoIGV2ZW50ICYmIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51XCIgKSApO1xuXG5cdFx0XHQvLyBJZiB3ZSBmb3VuZCBubyB2YWxpZCBzdWJtZW51IGFuY2VzdG9yLCB1c2UgdGhlIG1haW4gbWVudSB0byBjbG9zZSBhbGwgc3ViIG1lbnVzIGFueXdheVxuXHRcdFx0aWYgKCAhY3VycmVudE1lbnUubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJyZW50TWVudSA9IHRoaXMuZWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2xvc2UoIGN1cnJlbnRNZW51ICk7XG5cblx0XHRcdHRoaXMuYmx1ciggZXZlbnQgKTtcblx0XHRcdHRoaXMuYWN0aXZlTWVudSA9IGN1cnJlbnRNZW51O1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHQvLyBXaXRoIG5vIGFyZ3VtZW50cywgY2xvc2VzIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUgLSBpZiBub3RoaW5nIGlzIGFjdGl2ZVxuXHQvLyBpdCBjbG9zZXMgYWxsIG1lbnVzLiAgSWYgcGFzc2VkIGFuIGFyZ3VtZW50LCBpdCB3aWxsIHNlYXJjaCBmb3IgbWVudXMgQkVMT1dcblx0X2Nsb3NlOiBmdW5jdGlvbiggc3RhcnRNZW51ICkge1xuXHRcdGlmICggIXN0YXJ0TWVudSApIHtcblx0XHRcdHN0YXJ0TWVudSA9IHRoaXMuYWN0aXZlID8gdGhpcy5hY3RpdmUucGFyZW50KCkgOiB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0c3RhcnRNZW51XG5cdFx0XHQuZmluZCggXCIudWktbWVudVwiIClcblx0XHRcdFx0LmhpZGUoKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiIClcblx0XHRcdC5lbmQoKVxuXHRcdFx0LmZpbmQoIFwiYS51aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHR9LFxuXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG5ld0l0ZW0gPSB0aGlzLmFjdGl2ZSAmJlxuXHRcdFx0dGhpcy5hY3RpdmUucGFyZW50KCkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIsIHRoaXMuZWxlbWVudCApO1xuXHRcdGlmICggbmV3SXRlbSAmJiBuZXdJdGVtLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgbmV3SXRlbSApO1xuXHRcdH1cblx0fSxcblxuXHRleHBhbmQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgbmV3SXRlbSA9IHRoaXMuYWN0aXZlICYmXG5cdFx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0XHQuY2hpbGRyZW4oIFwiLnVpLW1lbnUgXCIgKVxuXHRcdFx0XHQuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0LmZpcnN0KCk7XG5cblx0XHRpZiAoIG5ld0l0ZW0gJiYgbmV3SXRlbS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9vcGVuKCBuZXdJdGVtLnBhcmVudCgpICk7XG5cblx0XHRcdC8vIERlbGF5IHNvIEZpcmVmb3ggd2lsbCBub3QgaGlkZSBhY3RpdmVkZXNjZW5kYW50IGNoYW5nZSBpbiBleHBhbmRpbmcgc3VibWVudSBmcm9tIEFUXG5cdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIG5ld0l0ZW0gKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5fbW92ZSggXCJuZXh0XCIsIFwiZmlyc3RcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRwcmV2aW91czogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuX21vdmUoIFwicHJldlwiLCBcImxhc3RcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRpc0ZpcnN0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5wcmV2QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApLmxlbmd0aDtcblx0fSxcblxuXHRpc0xhc3RJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLm5leHRBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkubGVuZ3RoO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiggZGlyZWN0aW9uLCBmaWx0ZXIsIGV2ZW50ICkge1xuXHRcdHZhciBuZXh0O1xuXHRcdGlmICggdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHRpZiAoIGRpcmVjdGlvbiA9PT0gXCJmaXJzdFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsYXN0XCIgKSB7XG5cdFx0XHRcdG5leHQgPSB0aGlzLmFjdGl2ZVxuXHRcdFx0XHRcdFsgZGlyZWN0aW9uID09PSBcImZpcnN0XCIgPyBcInByZXZBbGxcIiA6IFwibmV4dEFsbFwiIF0oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0XHQuZXEoIC0xICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVcblx0XHRcdFx0XHRbIGRpcmVjdGlvbiArIFwiQWxsXCIgXSggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHRcdC5lcSggMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoICFuZXh0IHx8ICFuZXh0Lmxlbmd0aCB8fCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApWyBmaWx0ZXIgXSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBuZXh0ICk7XG5cdH0sXG5cblx0bmV4dFBhZ2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaXRlbSwgYmFzZSwgaGVpZ2h0O1xuXG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pc0xhc3RJdGVtKCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5faGFzU2Nyb2xsKCkgKSB7XG5cdFx0XHRiYXNlID0gdGhpcy5hY3RpdmUub2Zmc2V0KCkudG9wO1xuXHRcdFx0aGVpZ2h0ID0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xuXHRcdFx0dGhpcy5hY3RpdmUubmV4dEFsbCggXCIudWktbWVudS1pdGVtXCIgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpdGVtID0gJCggdGhpcyApO1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5vZmZzZXQoKS50b3AgLSBiYXNlIC0gaGVpZ2h0IDwgMDtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdFsgIXRoaXMuYWN0aXZlID8gXCJmaXJzdFwiIDogXCJsYXN0XCIgXSgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZXZpb3VzUGFnZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBpdGVtLCBiYXNlLCBoZWlnaHQ7XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pc0ZpcnN0SXRlbSgpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0YmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcblx0XHRcdGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLnByZXZBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0cmV0dXJuIGl0ZW0ub2Zmc2V0KCkudG9wIC0gYmFzZSArIGhlaWdodCA+IDA7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIGl0ZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKS5maXJzdCgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYXNTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSA8IHRoaXMuZWxlbWVudC5wcm9wKCBcInNjcm9sbEhlaWdodFwiICk7XG5cdH0sXG5cblx0c2VsZWN0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0Ly8gVE9ETzogSXQgc2hvdWxkIG5ldmVyIGJlIHBvc3NpYmxlIHRvIG5vdCBoYXZlIGFuIGFjdGl2ZSBpdGVtIGF0IHRoaXNcblx0XHQvLyBwb2ludCwgYnV0IHRoZSB0ZXN0cyBkb24ndCB0cmlnZ2VyIG1vdXNlZW50ZXIgYmVmb3JlIGNsaWNrLlxuXHRcdHRoaXMuYWN0aXZlID0gdGhpcy5hY3RpdmUgfHwgJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKTtcblx0XHR2YXIgdWkgPSB7IGl0ZW06IHRoaXMuYWN0aXZlIH07XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUuaGFzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmNvbGxhcHNlQWxsKCBldmVudCwgdHJ1ZSApO1xuXHRcdH1cblx0XHR0aGlzLl90cmlnZ2VyKCBcInNlbGVjdFwiLCBldmVudCwgdWkgKTtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC51aSA9ICQudWkgfHwge307XG5cbnZhciBjYWNoZWRTY3JvbGxiYXJXaWR0aCxcblx0bWF4ID0gTWF0aC5tYXgsXG5cdGFicyA9IE1hdGguYWJzLFxuXHRyb3VuZCA9IE1hdGgucm91bmQsXG5cdHJob3Jpem9udGFsID0gL2xlZnR8Y2VudGVyfHJpZ2h0Lyxcblx0cnZlcnRpY2FsID0gL3RvcHxjZW50ZXJ8Ym90dG9tLyxcblx0cm9mZnNldCA9IC9bXFwrXFwtXVxcZCsoXFwuW1xcZF0rKT8lPy8sXG5cdHJwb3NpdGlvbiA9IC9eXFx3Ky8sXG5cdHJwZXJjZW50ID0gLyUkLyxcblx0X3Bvc2l0aW9uID0gJC5mbi5wb3NpdGlvbjtcblxuZnVuY3Rpb24gZ2V0T2Zmc2V0cyggb2Zmc2V0cywgd2lkdGgsIGhlaWdodCApIHtcblx0cmV0dXJuIFtcblx0XHRwYXJzZUZsb2F0KCBvZmZzZXRzWyAwIF0gKSAqICggcnBlcmNlbnQudGVzdCggb2Zmc2V0c1sgMCBdICkgPyB3aWR0aCAvIDEwMCA6IDEgKSxcblx0XHRwYXJzZUZsb2F0KCBvZmZzZXRzWyAxIF0gKSAqICggcnBlcmNlbnQudGVzdCggb2Zmc2V0c1sgMSBdICkgPyBoZWlnaHQgLyAxMDAgOiAxIClcblx0XTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3MoIGVsZW1lbnQsIHByb3BlcnR5ICkge1xuXHRyZXR1cm4gcGFyc2VJbnQoICQuY3NzKCBlbGVtZW50LCBwcm9wZXJ0eSApLCAxMCApIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoIGVsZW0gKSB7XG5cdHZhciByYXcgPSBlbGVtWzBdO1xuXHRpZiAoIHJhdy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IDAsIGxlZnQ6IDAgfVxuXHRcdH07XG5cdH1cblx0aWYgKCAkLmlzV2luZG93KCByYXcgKSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IGVsZW0uc2Nyb2xsVG9wKCksIGxlZnQ6IGVsZW0uc2Nyb2xsTGVmdCgpIH1cblx0XHR9O1xuXHR9XG5cdGlmICggcmF3LnByZXZlbnREZWZhdWx0ICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdG9mZnNldDogeyB0b3A6IHJhdy5wYWdlWSwgbGVmdDogcmF3LnBhZ2VYIH1cblx0XHR9O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0d2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpLFxuXHRcdGhlaWdodDogZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdG9mZnNldDogZWxlbS5vZmZzZXQoKVxuXHR9O1xufVxuXG4kLnBvc2l0aW9uID0ge1xuXHRzY3JvbGxiYXJXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBjYWNoZWRTY3JvbGxiYXJXaWR0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xuXHRcdH1cblx0XHR2YXIgdzEsIHcyLFxuXHRcdFx0ZGl2ID0gJCggXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6aGlkZGVuOyc+PGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cIiApLFxuXHRcdFx0aW5uZXJEaXYgPSBkaXYuY2hpbGRyZW4oKVswXTtcblxuXHRcdCQoIFwiYm9keVwiICkuYXBwZW5kKCBkaXYgKTtcblx0XHR3MSA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xuXHRcdGRpdi5jc3MoIFwib3ZlcmZsb3dcIiwgXCJzY3JvbGxcIiApO1xuXG5cdFx0dzIgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcblxuXHRcdGlmICggdzEgPT09IHcyICkge1xuXHRcdFx0dzIgPSBkaXZbMF0uY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0ZGl2LnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIChjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IHcxIC0gdzIpO1xuXHR9LFxuXHRnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiggd2l0aGluICkge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXhcIiApLFxuXHRcdFx0b3ZlcmZsb3dZID0gd2l0aGluLmlzV2luZG93IHx8IHdpdGhpbi5pc0RvY3VtZW50ID8gXCJcIiA6XG5cdFx0XHRcdHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSxcblx0XHRcdGhhc092ZXJmbG93WCA9IG92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLndpZHRoIDwgd2l0aGluLmVsZW1lbnRbMF0uc2Nyb2xsV2lkdGggKSxcblx0XHRcdGhhc092ZXJmbG93WSA9IG92ZXJmbG93WSA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WSA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLmhlaWdodCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbEhlaWdodCApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogaGFzT3ZlcmZsb3dZID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCxcblx0XHRcdGhlaWdodDogaGFzT3ZlcmZsb3dYID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMFxuXHRcdH07XG5cdH0sXG5cdGdldFdpdGhpbkluZm86IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB3aXRoaW5FbGVtZW50ID0gJCggZWxlbWVudCB8fCB3aW5kb3cgKSxcblx0XHRcdGlzV2luZG93ID0gJC5pc1dpbmRvdyggd2l0aGluRWxlbWVudFswXSApLFxuXHRcdFx0aXNEb2N1bWVudCA9ICEhd2l0aGluRWxlbWVudFsgMCBdICYmIHdpdGhpbkVsZW1lbnRbIDAgXS5ub2RlVHlwZSA9PT0gOTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdGlzRG9jdW1lbnQ6IGlzRG9jdW1lbnQsXG5cdFx0XHRvZmZzZXQ6IHdpdGhpbkVsZW1lbnQub2Zmc2V0KCkgfHwgeyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHRcdHNjcm9sbExlZnQ6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0c2Nyb2xsVG9wOiB3aXRoaW5FbGVtZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0d2lkdGg6IGlzV2luZG93ID8gd2l0aGluRWxlbWVudC53aWR0aCgpIDogd2l0aGluRWxlbWVudC5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGlzV2luZG93ID8gd2l0aGluRWxlbWVudC5oZWlnaHQoKSA6IHdpdGhpbkVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdH1cbn07XG5cbiQuZm4ucG9zaXRpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0aWYgKCAhb3B0aW9ucyB8fCAhb3B0aW9ucy5vZiApIHtcblx0XHRyZXR1cm4gX3Bvc2l0aW9uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdC8vIG1ha2UgYSBjb3B5LCB3ZSBkb24ndCB3YW50IHRvIG1vZGlmeSBhcmd1bWVudHNcblx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciBhdE9mZnNldCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdGFyZ2V0T2Zmc2V0LCBiYXNlUG9zaXRpb24sIGRpbWVuc2lvbnMsXG5cdFx0dGFyZ2V0ID0gJCggb3B0aW9ucy5vZiApLFxuXHRcdHdpdGhpbiA9ICQucG9zaXRpb24uZ2V0V2l0aGluSW5mbyggb3B0aW9ucy53aXRoaW4gKSxcblx0XHRzY3JvbGxJbmZvID0gJC5wb3NpdGlvbi5nZXRTY3JvbGxJbmZvKCB3aXRoaW4gKSxcblx0XHRjb2xsaXNpb24gPSAoIG9wdGlvbnMuY29sbGlzaW9uIHx8IFwiZmxpcFwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0b2Zmc2V0cyA9IHt9O1xuXG5cdGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKCB0YXJnZXQgKTtcblx0aWYgKCB0YXJnZXRbMF0ucHJldmVudERlZmF1bHQgKSB7XG5cdFx0Ly8gZm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRvcHRpb25zLmF0ID0gXCJsZWZ0IHRvcFwiO1xuXHR9XG5cdHRhcmdldFdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0dGFyZ2V0SGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdHRhcmdldE9mZnNldCA9IGRpbWVuc2lvbnMub2Zmc2V0O1xuXHQvLyBjbG9uZSB0byByZXVzZSBvcmlnaW5hbCB0YXJnZXRPZmZzZXQgbGF0ZXJcblx0YmFzZVBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCB0YXJnZXRPZmZzZXQgKTtcblxuXHQvLyBmb3JjZSBteSBhbmQgYXQgdG8gaGF2ZSB2YWxpZCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbnNcblx0Ly8gaWYgYSB2YWx1ZSBpcyBtaXNzaW5nIG9yIGludmFsaWQsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGNlbnRlclxuXHQkLmVhY2goIFsgXCJteVwiLCBcImF0XCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvcyA9ICggb3B0aW9uc1sgdGhpcyBdIHx8IFwiXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRcdGhvcml6b250YWxPZmZzZXQsXG5cdFx0XHR2ZXJ0aWNhbE9mZnNldDtcblxuXHRcdGlmICggcG9zLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0cG9zID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdHBvcy5jb25jYXQoIFsgXCJjZW50ZXJcIiBdICkgOlxuXHRcdFx0XHRydmVydGljYWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiIF0uY29uY2F0KCBwb3MgKSA6XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiLCBcImNlbnRlclwiIF07XG5cdFx0fVxuXHRcdHBvc1sgMCBdID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/IHBvc1sgMCBdIDogXCJjZW50ZXJcIjtcblx0XHRwb3NbIDEgXSA9IHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDEgXSApID8gcG9zWyAxIF0gOiBcImNlbnRlclwiO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIG9mZnNldHNcblx0XHRob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDAgXSApO1xuXHRcdHZlcnRpY2FsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDEgXSApO1xuXHRcdG9mZnNldHNbIHRoaXMgXSA9IFtcblx0XHRcdGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0WyAwIF0gOiAwLFxuXHRcdFx0dmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldFsgMCBdIDogMFxuXHRcdF07XG5cblx0XHQvLyByZWR1Y2UgdG8ganVzdCB0aGUgcG9zaXRpb25zIHdpdGhvdXQgdGhlIG9mZnNldHNcblx0XHRvcHRpb25zWyB0aGlzIF0gPSBbXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAwIF0gKVsgMCBdLFxuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMSBdIClbIDAgXVxuXHRcdF07XG5cdH0pO1xuXG5cdC8vIG5vcm1hbGl6ZSBjb2xsaXNpb24gb3B0aW9uXG5cdGlmICggY29sbGlzaW9uLmxlbmd0aCA9PT0gMSApIHtcblx0XHRjb2xsaXNpb25bIDEgXSA9IGNvbGxpc2lvblsgMCBdO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmF0WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoIC8gMjtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuXHR9IGVsc2UgaWYgKCBvcHRpb25zLmF0WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQgLyAyO1xuXHR9XG5cblx0YXRPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLmF0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0ICk7XG5cdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IGF0T2Zmc2V0WyAwIF07XG5cdGJhc2VQb3NpdGlvbi50b3AgKz0gYXRPZmZzZXRbIDEgXTtcblxuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xsaXNpb25Qb3NpdGlvbiwgdXNpbmcsXG5cdFx0XHRlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0ZWxlbVdpZHRoID0gZWxlbS5vdXRlcldpZHRoKCksXG5cdFx0XHRlbGVtSGVpZ2h0ID0gZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdFx0bWFyZ2luTGVmdCA9IHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpbkxlZnRcIiApLFxuXHRcdFx0bWFyZ2luVG9wID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luVG9wXCIgKSxcblx0XHRcdGNvbGxpc2lvbldpZHRoID0gZWxlbVdpZHRoICsgbWFyZ2luTGVmdCArIHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpblJpZ2h0XCIgKSArIHNjcm9sbEluZm8ud2lkdGgsXG5cdFx0XHRjb2xsaXNpb25IZWlnaHQgPSBlbGVtSGVpZ2h0ICsgbWFyZ2luVG9wICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luQm90dG9tXCIgKSArIHNjcm9sbEluZm8uaGVpZ2h0LFxuXHRcdFx0cG9zaXRpb24gPSAkLmV4dGVuZCgge30sIGJhc2VQb3NpdGlvbiApLFxuXHRcdFx0bXlPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLm15LCBlbGVtLm91dGVyV2lkdGgoKSwgZWxlbS5vdXRlckhlaWdodCgpICk7XG5cblx0XHRpZiAoIG9wdGlvbnMubXlbIDAgXSA9PT0gXCJyaWdodFwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGg7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGggLyAyO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQ7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXRbIDAgXTtcblx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXRbIDEgXTtcblxuXHRcdC8vIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBmcmFjdGlvbnMsIHRoZW4gcm91bmQgZm9yIGNvbnNpc3RlbnQgcmVzdWx0c1xuXHRcdGlmICggISQuc3VwcG9ydC5vZmZzZXRGcmFjdGlvbnMgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0ID0gcm91bmQoIHBvc2l0aW9uLmxlZnQgKTtcblx0XHRcdHBvc2l0aW9uLnRvcCA9IHJvdW5kKCBwb3NpdGlvbi50b3AgKTtcblx0XHR9XG5cblx0XHRjb2xsaXNpb25Qb3NpdGlvbiA9IHtcblx0XHRcdG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG5cdFx0XHRtYXJnaW5Ub3A6IG1hcmdpblRvcFxuXHRcdH07XG5cblx0XHQkLmVhY2goIFsgXCJsZWZ0XCIsIFwidG9wXCIgXSwgZnVuY3Rpb24oIGksIGRpciApIHtcblx0XHRcdGlmICggJC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXSApIHtcblx0XHRcdFx0JC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXVsgZGlyIF0oIHBvc2l0aW9uLCB7XG5cdFx0XHRcdFx0dGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdHRhcmdldEhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGVsZW1XaWR0aDogZWxlbVdpZHRoLFxuXHRcdFx0XHRcdGVsZW1IZWlnaHQ6IGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0Y29sbGlzaW9uUG9zaXRpb246IGNvbGxpc2lvblBvc2l0aW9uLFxuXHRcdFx0XHRcdGNvbGxpc2lvbldpZHRoOiBjb2xsaXNpb25XaWR0aCxcblx0XHRcdFx0XHRjb2xsaXNpb25IZWlnaHQ6IGNvbGxpc2lvbkhlaWdodCxcblx0XHRcdFx0XHRvZmZzZXQ6IFsgYXRPZmZzZXRbIDAgXSArIG15T2Zmc2V0WyAwIF0sIGF0T2Zmc2V0IFsgMSBdICsgbXlPZmZzZXRbIDEgXSBdLFxuXHRcdFx0XHRcdG15OiBvcHRpb25zLm15LFxuXHRcdFx0XHRcdGF0OiBvcHRpb25zLmF0LFxuXHRcdFx0XHRcdHdpdGhpbjogd2l0aGluLFxuXHRcdFx0XHRcdGVsZW0gOiBlbGVtXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCBvcHRpb25zLnVzaW5nICkge1xuXHRcdFx0Ly8gYWRkcyBmZWVkYmFjayBhcyBzZWNvbmQgYXJndW1lbnQgdG8gdXNpbmcgY2FsbGJhY2ssIGlmIHByZXNlbnRcblx0XHRcdHVzaW5nID0gZnVuY3Rpb24oIHByb3BzICkge1xuXHRcdFx0XHR2YXIgbGVmdCA9IHRhcmdldE9mZnNldC5sZWZ0IC0gcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRyaWdodCA9IGxlZnQgKyB0YXJnZXRXaWR0aCAtIGVsZW1XaWR0aCxcblx0XHRcdFx0XHR0b3AgPSB0YXJnZXRPZmZzZXQudG9wIC0gcG9zaXRpb24udG9wLFxuXHRcdFx0XHRcdGJvdHRvbSA9IHRvcCArIHRhcmdldEhlaWdodCAtIGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0ZmVlZGJhY2sgPSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiB0YXJnZXRPZmZzZXQubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiB0YXJnZXRPZmZzZXQudG9wLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogdGFyZ2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogdGFyZ2V0SGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZWxlbWVudDoge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0XHRcdFx0XHR0b3A6IHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBlbGVtSGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aG9yaXpvbnRhbDogcmlnaHQgPCAwID8gXCJsZWZ0XCIgOiBsZWZ0ID4gMCA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCIsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbDogYm90dG9tIDwgMCA/IFwidG9wXCIgOiB0b3AgPiAwID8gXCJib3R0b21cIiA6IFwibWlkZGxlXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIHRhcmdldFdpZHRoIDwgZWxlbVdpZHRoICYmIGFicyggbGVmdCArIHJpZ2h0ICkgPCB0YXJnZXRXaWR0aCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5ob3Jpem9udGFsID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRhcmdldEhlaWdodCA8IGVsZW1IZWlnaHQgJiYgYWJzKCB0b3AgKyBib3R0b20gKSA8IHRhcmdldEhlaWdodCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay52ZXJ0aWNhbCA9IFwibWlkZGxlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXgoIGFicyggbGVmdCApLCBhYnMoIHJpZ2h0ICkgKSA+IG1heCggYWJzKCB0b3AgKSwgYWJzKCBib3R0b20gKSApICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwiaG9yaXpvbnRhbFwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwidmVydGljYWxcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIHRoaXMsIHByb3BzLCBmZWVkYmFjayApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRlbGVtLm9mZnNldCggJC5leHRlbmQoIHBvc2l0aW9uLCB7IHVzaW5nOiB1c2luZyB9ICkgKTtcblx0fSk7XG59O1xuXG4kLnVpLnBvc2l0aW9uID0ge1xuXHRmaXQ6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxMZWZ0IDogd2l0aGluLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHRvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCxcblx0XHRcdFx0b3ZlckxlZnQgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NMZWZ0LFxuXHRcdFx0XHRvdmVyUmlnaHQgPSBjb2xsaXNpb25Qb3NMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQsXG5cdFx0XHRcdG5ld092ZXJSaWdodDtcblxuXHRcdFx0Ly8gZWxlbWVudCBpcyB3aWRlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbldpZHRoID4gb3V0ZXJXaWR0aCApIHtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgbGVmdCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gMCAmJiBvdmVyUmlnaHQgPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgb3ZlckxlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0IC0gbmV3T3ZlclJpZ2h0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHJpZ2h0IHNpZGUgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgJiYgb3ZlckxlZnQgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIHRvbyBmYXIgbGVmdCAtPiBhbGlnbiB3aXRoIGxlZnQgZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckxlZnQgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0O1xuXHRcdFx0Ly8gdG9vIGZhciByaWdodCAtPiBhbGlnbiB3aXRoIHJpZ2h0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gb3ZlclJpZ2h0O1xuXHRcdFx0Ly8gYWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSBtYXgoIHBvc2l0aW9uLmxlZnQgLSBjb2xsaXNpb25Qb3NMZWZ0LCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IGRhdGEud2l0aGluLmhlaWdodCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBlbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbkhlaWdodCA+IG91dGVySGVpZ2h0ICkge1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHRoZSB0b3Agb2Ygd2l0aGluXG5cdFx0XHRcdGlmICggb3ZlclRvcCA+IDAgJiYgb3ZlckJvdHRvbSA8PSAwICkge1xuXHRcdFx0XHRcdG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBvdmVyVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcCAtIG5ld092ZXJCb3R0b207XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90dG9tIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCAmJiBvdmVyVG9wIDw9IDAgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggdG9wIGFuZCBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyVG9wID4gb3ZlckJvdHRvbSApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldCArIG91dGVySGVpZ2h0IC0gZGF0YS5jb2xsaXNpb25IZWlnaHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIHRvbyBmYXIgdXAgLT4gYWxpZ24gd2l0aCB0b3Bcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJUb3AgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcDtcblx0XHRcdC8vIHRvbyBmYXIgZG93biAtPiBhbGlnbiB3aXRoIGJvdHRvbSBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24udG9wIC09IG92ZXJCb3R0b207XG5cdFx0XHQvLyBhZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24udG9wID0gbWF4KCBwb3NpdGlvbi50b3AgLSBjb2xsaXNpb25Qb3NUb3AsIHBvc2l0aW9uLnRvcCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC5sZWZ0ICsgd2l0aGluLnNjcm9sbExlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdG9mZnNldExlZnQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gY29sbGlzaW9uUG9zTGVmdCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG15T2Zmc2V0ID0gZGF0YS5teVsgMCBdID09PSBcImxlZnRcIiA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbVdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLm15WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0V2lkdGggOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDAgXSA9PT0gXCJyaWdodFwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDAgXSxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0LFxuXHRcdFx0XHRuZXdPdmVyTGVmdDtcblxuXHRcdFx0aWYgKCBvdmVyTGVmdCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJSaWdodCA9IHBvc2l0aW9uLmxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlclJpZ2h0IDwgMCB8fCBuZXdPdmVyUmlnaHQgPCBhYnMoIG92ZXJMZWZ0ICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb3ZlclJpZ2h0ID4gMCApIHtcblx0XHRcdFx0bmV3T3ZlckxlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0ICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCAtIG9mZnNldExlZnQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlckxlZnQgPiAwIHx8IGFicyggbmV3T3ZlckxlZnQgKSA8IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4ub2Zmc2V0LnRvcCArIHdpdGhpbi5zY3JvbGxUb3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gd2l0aGluLmhlaWdodCxcblx0XHRcdFx0b2Zmc2V0VG9wID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IGNvbGxpc2lvblBvc1RvcCAtIG9mZnNldFRvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdHRvcCA9IGRhdGEubXlbIDEgXSA9PT0gXCJ0b3BcIixcblx0XHRcdFx0bXlPZmZzZXQgPSB0b3AgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdGRhdGEubXlbIDEgXSA9PT0gXCJib3R0b21cIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAxIF0gPT09IFwidG9wXCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLmF0WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0LWRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDEgXSxcblx0XHRcdFx0bmV3T3ZlclRvcCxcblx0XHRcdFx0bmV3T3ZlckJvdHRvbTtcblx0XHRcdGlmICggb3ZlclRvcCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCAoIHBvc2l0aW9uLnRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQpID4gb3ZlclRvcCAmJiAoIG5ld092ZXJCb3R0b20gPCAwIHx8IG5ld092ZXJCb3R0b20gPCBhYnMoIG92ZXJUb3AgKSApICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggKCBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0KSA+IG92ZXJCb3R0b20gJiYgKCBuZXdPdmVyVG9wID4gMCB8fCBhYnMoIG5ld092ZXJUb3AgKSA8IG92ZXJCb3R0b20gKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLmxlZnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0JC51aS5wb3NpdGlvbi5maXQubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC50b3AuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fVxufTtcblxuLy8gZnJhY3Rpb24gc3VwcG9ydCB0ZXN0XG4oZnVuY3Rpb24gKCkge1xuXHR2YXIgdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LCB0ZXN0RWxlbWVudFN0eWxlLCBvZmZzZXRMZWZ0LCBpLFxuXHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvL0NyZWF0ZSBhIFwiZmFrZSBib2R5XCIgZm9yIHRlc3RpbmcgYmFzZWQgb24gbWV0aG9kIHVzZWQgaW4galF1ZXJ5LnN1cHBvcnRcblx0dGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBib2R5ID8gXCJkaXZcIiA6IFwiYm9keVwiICk7XG5cdHRlc3RFbGVtZW50U3R5bGUgPSB7XG5cdFx0dmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblx0XHR3aWR0aDogMCxcblx0XHRoZWlnaHQ6IDAsXG5cdFx0Ym9yZGVyOiAwLFxuXHRcdG1hcmdpbjogMCxcblx0XHRiYWNrZ3JvdW5kOiBcIm5vbmVcIlxuXHR9O1xuXHRpZiAoIGJvZHkgKSB7XG5cdFx0JC5leHRlbmQoIHRlc3RFbGVtZW50U3R5bGUsIHtcblx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRsZWZ0OiBcIi0xMDAwcHhcIixcblx0XHRcdHRvcDogXCItMTAwMHB4XCJcblx0XHR9KTtcblx0fVxuXHRmb3IgKCBpIGluIHRlc3RFbGVtZW50U3R5bGUgKSB7XG5cdFx0dGVzdEVsZW1lbnQuc3R5bGVbIGkgXSA9IHRlc3RFbGVtZW50U3R5bGVbIGkgXTtcblx0fVxuXHR0ZXN0RWxlbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cdHRlc3RFbGVtZW50UGFyZW50ID0gYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdHRlc3RFbGVtZW50UGFyZW50Lmluc2VydEJlZm9yZSggdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LmZpcnN0Q2hpbGQgKTtcblxuXHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAxMC43NDMyMjIycHg7XCI7XG5cblx0b2Zmc2V0TGVmdCA9ICQoIGRpdiApLm9mZnNldCgpLmxlZnQ7XG5cdCQuc3VwcG9ydC5vZmZzZXRGcmFjdGlvbnMgPSBvZmZzZXRMZWZ0ID4gMTAgJiYgb2Zmc2V0TGVmdCA8IDExO1xuXG5cdHRlc3RFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG5cdHRlc3RFbGVtZW50UGFyZW50LnJlbW92ZUNoaWxkKCB0ZXN0RWxlbWVudCApO1xufSkoKTtcblxufSggalF1ZXJ5ICkgKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHV1aWQgPSAwLFxuXHRzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0X2NsZWFuRGF0YSA9ICQuY2xlYW5EYXRhO1xuJC5jbGVhbkRhdGEgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdHRyeSB7XG5cdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0fSBjYXRjaCggZSApIHt9XG5cdH1cblx0X2NsZWFuRGF0YSggZWxlbXMgKTtcbn07XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGZ1bGxOYW1lLCBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZSxcblx0XHQvLyBwcm94aWVkUHJvdG90eXBlIGFsbG93cyB0aGUgcHJvdmlkZWQgcHJvdG90eXBlIHRvIHJlbWFpbiB1bm1vZGlmaWVkXG5cdFx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0XHRwcm94aWVkUHJvdG90eXBlID0ge30sXG5cdFx0bmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXG5cdG5hbWUgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAxIF07XG5cdGZ1bGxOYW1lID0gbmFtZXNwYWNlICsgXCItXCIgKyBuYW1lO1xuXG5cdGlmICggIXByb3RvdHlwZSApIHtcblx0XHRwcm90b3R5cGUgPSBiYXNlO1xuXHRcdGJhc2UgPSAkLldpZGdldDtcblx0fVxuXG5cdC8vIGNyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwclsgXCI6XCIgXVsgZnVsbE5hbWUudG9Mb3dlckNhc2UoKSBdID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBmdWxsTmFtZSApO1xuXHR9O1xuXG5cdCRbIG5hbWVzcGFjZSBdID0gJFsgbmFtZXNwYWNlIF0gfHwge307XG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xuXHRjb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgXCJuZXdcIiBrZXl3b3JkXG5cdFx0aWYgKCAhdGhpcy5fY3JlYXRlV2lkZ2V0ICkge1xuXHRcdFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3Rvciggb3B0aW9ucywgZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBpbml0aWFsaXppbmcgZm9yIHNpbXBsZSBpbmhlcml0YW5jZVxuXHRcdC8vIG11c3QgdXNlIFwibmV3XCIga2V5d29yZCAodGhlIGNvZGUgYWJvdmUgYWx3YXlzIHBhc3NlcyBhcmdzKVxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX2NyZWF0ZVdpZGdldCggb3B0aW9ucywgZWxlbWVudCApO1xuXHRcdH1cblx0fTtcblx0Ly8gZXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXHRcdC8vIGNvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXG5cdFx0Ly8gdHJhY2sgd2lkZ2V0cyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIHdpZGdldCBpbiBjYXNlIHRoaXMgd2lkZ2V0IGlzXG5cdFx0Ly8gcmVkZWZpbmVkIGFmdGVyIGEgd2lkZ2V0IGluaGVyaXRzIGZyb20gaXRcblx0XHRfY2hpbGRDb25zdHJ1Y3RvcnM6IFtdXG5cdH0pO1xuXG5cdGJhc2VQcm90b3R5cGUgPSBuZXcgYmFzZSgpO1xuXHQvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIG9wdGlvbnMgaGFzaCBhIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBuZXcgaW5zdGFuY2Vcblx0Ly8gb3RoZXJ3aXNlIHdlJ2xsIG1vZGlmeSB0aGUgb3B0aW9ucyBoYXNoIG9uIHRoZSBwcm90b3R5cGUgdGhhdCB3ZSdyZVxuXHQvLyBpbmhlcml0aW5nIGZyb21cblx0YmFzZVByb3RvdHlwZS5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgYmFzZVByb3RvdHlwZS5vcHRpb25zICk7XG5cdCQuZWFjaCggcHJvdG90eXBlLCBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBfc3VwZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9zdXBlckFwcGx5ID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0fTtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIF9fc3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5LFxuXHRcdFx0XHRcdHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSkoKTtcblx0fSk7XG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQud2lkZ2V0LmV4dGVuZCggYmFzZVByb3RvdHlwZSwge1xuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/IChiYXNlUHJvdG90eXBlLndpZGdldEV2ZW50UHJlZml4IHx8IG5hbWUpIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0pO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gcmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLCBjaGlsZC5fcHJvdG8gKTtcblx0XHR9KTtcblx0XHQvLyByZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xufTtcblxuJC53aWRnZXQuZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0dmFyIGlucHV0ID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0aW5wdXRJbmRleCA9IDAsXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0a2V5LFxuXHRcdHZhbHVlO1xuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gQ2xvbmUgb2JqZWN0c1xuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gJC5pc1BsYWluT2JqZWN0KCB0YXJnZXRbIGtleSBdICkgP1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdGFyZ2V0WyBrZXkgXSwgdmFsdWUgKSA6XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIixcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRcdHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdC8vIGFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdG9wdGlvbnMgPSAhaXNNZXRob2RDYWxsICYmIGFyZ3MubGVuZ3RoID9cblx0XHRcdCQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KGFyZ3MpICkgOlxuXHRcdFx0b3B0aW9ucztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWV0aG9kVmFsdWUsXG5cdFx0XHRcdFx0aW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICsgXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2Vbb3B0aW9uc10gKSB8fCBvcHRpb25zLmNoYXJBdCggMCApID09PSBcIl9cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgKyBcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdFx0aWYgKCBtZXRob2RWYWx1ZSAhPT0gaW5zdGFuY2UgJiYgbWV0aG9kVmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0bWV0aG9kVmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKCBvcHRpb25zIHx8IHt9ICkuX2luaXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xufTtcblxuJC5XaWRnZXQgPSBmdW5jdGlvbiggLyogb3B0aW9ucywgZWxlbWVudCAqLyApIHt9O1xuJC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW107XG5cbiQuV2lkZ2V0LnByb3RvdHlwZSA9IHtcblx0d2lkZ2V0TmFtZTogXCJ3aWRnZXRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxkaXY+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gdXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblxuXHRcdGlmICggZWxlbWVudCAhPT0gdGhpcyApIHtcblx0XHRcdCQuZGF0YSggZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyApO1xuXHRcdFx0dGhpcy5fb24oIHRydWUsIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cdFx0XHRcdC8vIGVsZW1lbnQgd2l0aGluIHRoZSBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50Lm93bmVyRG9jdW1lbnQgOlxuXHRcdFx0XHQvLyBlbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdyApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiY3JlYXRlXCIsIG51bGwsIHRoaXMuX2dldENyZWF0ZUV2ZW50RGF0YSgpICk7XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9LFxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogJC5ub29wLFxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cdF9jcmVhdGU6ICQubm9vcCxcblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0Ly8gd2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC8vIDEuOSBCQyBmb3IgIzc4MTBcblx0XHRcdC8vIFRPRE8gcmVtb3ZlIGR1YWwgc3RvcmFnZVxuXHRcdFx0LnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0TmFtZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApXG5cdFx0XHQvLyBzdXBwb3J0OiBqcXVlcnkgPDEuNi4zXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85NDEzXG5cdFx0XHQucmVtb3ZlRGF0YSggJC5jYW1lbENhc2UoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0dGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIFwiICtcblx0XHRcdFx0XCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBjbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3MudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0fSxcblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleSxcblx0XHRcdHBhcnRzLFxuXHRcdFx0Y3VyT3B0aW9uLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdC8vIGRvbid0IHJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgaGFzaFxuXHRcdFx0cmV0dXJuICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdC8vIGhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLndpZGdldCgpXG5cdFx0XHRcdC50b2dnbGVDbGFzcyggdGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIHVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIHZhbHVlICk7XG5cdFx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIGZhbHNlICk7XG5cdH0sXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudCxcblx0XHRcdGluc3RhbmNlID0gdGhpcztcblxuXHRcdC8vIG5vIHN1cHByZXNzRGlzYWJsZWRDaGVjayBmbGFnLCBzaHVmZmxlIGFyZ3VtZW50c1xuXHRcdGlmICggdHlwZW9mIHN1cHByZXNzRGlzYWJsZWRDaGVjayAhPT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gc3VwcHJlc3NEaXNhYmxlZENoZWNrO1xuXHRcdFx0c3VwcHJlc3NEaXNhYmxlZENoZWNrID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gbm8gZWxlbWVudCBhcmd1bWVudCwgc2h1ZmZsZSBhbmQgdXNlIHRoaXMuZWxlbWVudFxuXHRcdGlmICggIWhhbmRsZXJzICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdGRlbGVnYXRlRWxlbWVudCA9IHRoaXMud2lkZ2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFjY2VwdCBzZWxlY3RvcnMsIERPTSBlbGVtZW50c1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdFx0Ly8gYWxsb3cgd2lkZ2V0cyB0byBjdXN0b21pemUgdGhlIGRpc2FibGVkIGhhbmRsaW5nXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgYXMgYW4gYXJyYXkgaW5zdGVhZCBvZiBib29sZWFuXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgY2xhc3MgYXMgbWV0aG9kIGZvciBkaXNhYmxpbmcgaW5kaXZpZHVhbCBwYXJ0c1xuXHRcdFx0XHRpZiAoICFzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgJiZcblx0XHRcdFx0XHRcdCggaW5zdGFuY2Uub3B0aW9ucy5kaXNhYmxlZCA9PT0gdHJ1ZSB8fFxuXHRcdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihcXHcrKVxccyooLiopJC8gKSxcblx0XHRcdFx0ZXZlbnROYW1lID0gbWF0Y2hbMV0gKyBpbnN0YW5jZS5ldmVudE5hbWVzcGFjZSxcblx0XHRcdFx0c2VsZWN0b3IgPSBtYXRjaFsyXTtcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGRlbGVnYXRlRWxlbWVudC5kZWxlZ2F0ZSggc2VsZWN0b3IsIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LmJpbmQoIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IFwiXCIpLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICsgdGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50LnVuYmluZCggZXZlbnROYW1lICkudW5kZWxlZ2F0ZSggZXZlbnROYW1lICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9LFxuXHRcdFx0bW91c2VsZWF2ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1c291dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWcsXG5cdFx0XHRjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0Ly8gdGhlIG9yaWdpbmFsIGV2ZW50IG1heSBjb21lIGZyb20gYW55IGVsZW1lbnRcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB0YXJnZXQgb24gdGhlIG5ldyBldmVudFxuXHRcdGV2ZW50LnRhcmdldCA9IHRoaXMuZWxlbWVudFsgMCBdO1xuXG5cdFx0Ly8gY29weSBvcmlnaW5hbCBldmVudCBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIG5ldyBldmVudFxuXHRcdG9yaWcgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXHRcdGlmICggb3JpZyApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0aWYgKCAhKCBwcm9wIGluIGV2ZW50ICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBldmVudCwgZGF0YSApO1xuXHRcdHJldHVybiAhKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgJiZcblx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLmVsZW1lbnRbMF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXHRcdHZhciBoYXNPcHRpb25zLFxuXHRcdFx0ZWZmZWN0TmFtZSA9ICFvcHRpb25zID9cblx0XHRcdFx0bWV0aG9kIDpcblx0XHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdFx0ZGVmYXVsdEVmZmVjdCA6XG5cdFx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZHVyYXRpb246IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblx0XHRpZiAoIGhhc09wdGlvbnMgJiYgJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3RbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIG1ldGhvZCBdKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIGlmICggZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIGVmZmVjdE5hbWUgXSggb3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQucXVldWUoZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59KTtcblxufSkoIGpRdWVyeSApO1xuIiwiLyoqXG4gICAgQWNjb3VudCBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEFjY291bnRBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLmFwcC5tb2RlbC51c2VyUHJvZmlsZS5kYXRhO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignQWNjb3VudCcpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcbiIsIi8qKlxuICAgIEFkZEpvYlRpdGxlcyBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4vL05PVEU6IElUIERFUEVORFMgb24gdGhpcywgYnV0IGpxdWVyeS11aSB0b3VjaCBldmVudHMgc3VwcG9ydCByZXF1aXJlcyBzcGVjaWFsIGxvYWQgb3JkZXJcbi8vIHNvIHRoYXRzIGJlaW5nIGRvbmUgaW4gdGhlIGVudHJ5IHBvaW50IGZpbGVcbi8vcmVxdWlyZSgnanF1ZXJ5LXVpL2F1dG9jb21wbGV0ZScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQWRkSm9iVGl0bGVzQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5zZXJ2aWNlUHJvZmVzc2lvbmFsO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJyk7XG4gICAgXG4gICAgLy8gU2V0dXAgYXV0b2NvbXBsZXRlXG4gICAgdmFyIGFjID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2FkZEpvYlRpdGxlcy1zZWFyY2gnKTtcbiAgICB2YXIgdncgPSB0aGlzLnZpZXdNb2RlbDtcbiAgICAvLyBBdXRvY29tcGxldGUgcG9zaXRpb25zIGFuZCBhZGQgdG8gdGhlIGxpc3RcbiAgICBhYy5hdXRvY29tcGxldGUoe1xuICAgICAgICBzb3VyY2U6IGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2dy5zZWFyY2hCeShyZXF1ZXN0LnRlcm0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UocmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXV0b0ZvY3VzOiBmYWxzZSxcbiAgICAgICAgbWluTGVuZ3RoOiAwLFxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcbiAgICAgICAgICAgIC8vIE5vIHZhbHVlLCBubyBhY3Rpb24gOihcbiAgICAgICAgICAgIGlmICghdWkgfHwgIXVpLml0ZW0gfHwgIXVpLml0ZW0udmFsdWUpIHJldHVybjtcblxuICAgICAgICAgICAgdncuYWRkSXRlbSh1aS5pdGVtKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1czogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuICAgICAgICAgICAgaWYgKCF1aSB8fCAhdWkuaXRlbSB8fCAhdWkuaXRlbS5wb3NpdGlvblNpbmd1bGFyKTtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIGxhYmVsIGluIHRleHRib3gsIG5vdCB0aGUgdmFsdWVcbiAgICAgICAgICAgICQodGhpcykudmFsKHVpLml0ZW0ucG9zaXRpb25TaW5ndWxhcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnVwZGF0ZU5hdkJhclN0YXRlID0gZnVuY3Rpb24gdXBkYXRlTmF2QmFyU3RhdGUoKSB7XG5cbiAgICB2YXIgcmVmZXJyZXIgPSB0aGlzLmFwcC5zaGVsbC5yZWZlcnJlclJvdXRlO1xuICAgIHJlZmVycmVyID0gcmVmZXJyZXIgJiYgcmVmZXJyZXIudXJsIHx8ICcvc2NoZWR1bGluZyc7XG4gICAgdmFyIGxpbmsgPSB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmsgfHwgcmVmZXJyZXI7XG4gICAgXG4gICAgaWYgKCF0aGlzLmFwcC5tb2RlbC5vbmJvYXJkaW5nLnVwZGF0ZU5hdkJhcih0aGlzLm5hdkJhcikpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0VG9DYW5jZWxBY3Rpb24odGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLCBsaW5rKTtcbiAgICB9XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XG5cbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIFJlc2V0XG4gICAgdGhpcy52aWV3TW9kZWwuc2VhcmNoVGV4dCgnJyk7XG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVzLnJlbW92ZUFsbCgpO1xuICAgIFxuICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcbn07XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgXG4gICAgdGhpcy5pc1NlYXJjaGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmlzTG9ja2VkID0gdGhpcy5pc1NhdmluZztcbiAgICB0aGlzLnNlYXJjaFRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICB0aGlzLmpvYlRpdGxlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuaW5Qcm9ncmVzcygpID9cbiAgICAgICAgICAgICAgICAnU2F2ZSBhbmQgY29udGludWUnIDpcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy51bnNhdmVkQ2hhbmdlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5qb2JUaXRsZXMoKS5sZW5ndGg7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnNlYXJjaEJ5ID0gZnVuY3Rpb24gc2VhcmNoQnkodGV4dCkge1xuICAgICAgICByZXR1cm4gYXBwLm1vZGVsLnJlc3QuZ2V0KCdqb2ItdGl0bGVzL2F1dG9jb21wbGV0ZScsIHsgc2VhcmNoOiB0ZXh0IH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7IGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hCeSh0aGlzLnNlYXJjaFRleHQoKSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuYWRkSXRlbSA9IGZ1bmN0aW9uIGFkZEl0ZW0oaXRlbSkge1xuICAgICAgICAvLyBBZGQgdG8gdGhlIGxpc3QsIGlmIGlzIG5vdCBhbHJlYWR5IGluIGl0XG4gICAgICAgIHZhciBmb3VuZEluZGV4ID0gdGhpcy5maW5kSXRlbShpdGVtKTtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmpvYlRpdGxlcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gYWRkKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoVGV4dCgpO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgdGhpcy5hZGRJdGVtKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICBsYWJlbDogc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaFRleHQoJycpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIC8qKlxuICAgICAgICBMb29rIGZvciBhbiBpdGVtIGluIHRoZSBjdXJyZW50IGxpc3QsIHJldHVybmluZ1xuICAgICAgICBpdHMgaW5kZXggaW4gdGhlIGxpc3Qgb3IgLTEgaWYgbm90aGluZy5cbiAgICAqKi9cbiAgICB0aGlzLmZpbmRJdGVtID0gZnVuY3Rpb24gZmluZEl0ZW0oam9iVGl0bGUpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5qb2JUaXRsZXMoKS5zb21lKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoam9iVGl0bGUudmFsdWUgIT09IDAgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnZhbHVlID09PSBqb2JUaXRsZS52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIGl0ZW0ubGFiZWwgPT09IGpvYlRpdGxlLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgZm91bmRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kSW5kZXg7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShqb2JUaXRsZSkge1xuICAgICAgICB2YXIgcmVtb3ZlSW5kZXggPSB0aGlzLmZpbmRJdGVtKGpvYlRpdGxlKTtcbiAgICAgICAgaWYgKHJlbW92ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuam9iVGl0bGVzLnNwbGljZShyZW1vdmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgICAgdGhpcy5pc1NhdmluZyh0cnVlKTtcblxuICAgICAgICBQcm9taXNlLmFsbCh0aGlzLmpvYlRpdGxlcygpLm1hcChmdW5jdGlvbihqb2JUaXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC51c2VySm9iUHJvZmlsZS5jcmVhdGVVc2VySm9iVGl0bGUoe1xuICAgICAgICAgICAgICAgIGpvYlRpdGxlSUQ6IGpvYlRpdGxlLnZhbHVlLFxuICAgICAgICAgICAgICAgIGpvYlRpdGxlTmFtZTogam9iVGl0bGUubGFiZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oLypyZXN1bHRzKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoVGV4dCgnJyk7XG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIC8vIFJlc2V0IGxpc3RcbiAgICAgICAgICAgIHRoaXMuam9iVGl0bGVzLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYXBwLm1vZGVsLm9uYm9hcmRpbmcuaW5Qcm9ncmVzcygpKSB7XG4gICAgICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuZ29OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHAuc3VjY2Vzc1NhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hUZXh0KCcnKTtcbiAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnSW1wb3NzaWJsZSB0byBhZGQgb25lIG9yIG1vcmUgam9iIHRpdGxlcycsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyk7XG59XG4iLCIvKipcbiAgICBBZGRyZXNzRWRpdG9yIGFjdGl2aXR5XG4gICAgXG4gICAgVE9ETzogTW9kZWxWZXJzaW9uIGlzIE5PVCBiZWluZyB1c2VkLCBzbyBubyBnZXR0aW5nIHVwZGF0ZXMgaWYgc2VydmVyIHVwZGF0ZXNcbiAgICB0aGUgZGF0YSBhZnRlciBsb2FkIChkYXRhIGxvYWQgaXMgcmVxdWVzdGVkIGJ1dCBnZXQgZmlyc3QgZnJvbSBjYWNoZSkuIFVzZVxuICAgIHZlcnNpb24gYW5kIGdldCBzeW5jJ2VkIGRhdGEgd2hlbiByZWFkeSwgYW5kIGFkZGl0aW9uYWxseSBub3RpZmljYXRpb24gdG9cbiAgICBvdmVycmlkZSBjaGFuZ2VzIGlmIHNlcnZlciBkYXRhIGlzIGRpZmZlcmVudCB0aGF0IGFueSBsb2NhbCBjaGFuZ2UuXG5cbiAgICBUT0RPOiBUaGUgVVJMIHN0cnVjdHVyZSBhbmQgaG93IHBhcmFtcyBhcmUgcmVhZCBpcyByZWFkeSB0byBhbGxvd1xuICAgIGVkaXRpb24gb2YgZGlmZmVyZW50IGtpbmQgb2YgYWRkcmVzc2VzLCBidXQgYWN0dWFsbHkgb25seSBzZXJ2aWNlIGFkZHJlc3Nlc1xuICAgIGFyZSBmdWxseSBzdXBwb3J0ZWQsIHNpbmNlICdob21lIGFkZHJlc3MnIGlzIGVkaXRlZCBpbiBjb250YWN0SW5mbyBhbmRcbiAgICAnYmlsbGluZyBhZGRyZXNzZXMnIGFyZSBub3QgdXNlZCBjdXJyZW50bHksIGJ1dCB3aGVuIG5lZWRlZCwgdGhlIHN1cHBvcnQgZm9yIHRoaXNcbiAgICBsYXN0IHdpbGwgbmVlZCB0byBiZSBjb21wbGV0ZWQuIEFsbCB0aGUgQVBJIGNhbGxzIHJpZ2h0IG5vdyBhcmVcbiAgICBmb3IgbW9kZWwuc2VydmljZUFkZGRyZXNzZXMgZm9yIGV4YW1wbGUuXG4qKi9cbid1c2Ugc3RyaWN0JztcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgQWRkcmVzcyA9IHJlcXVpcmUoJy4uL21vZGVscy9BZGRyZXNzJyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBZGRyZXNzRWRpdG9yQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLnNlcnZpY2VQcm9mZXNzaW9uYWw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0xvY2F0aW9ucycpO1xuICAgIFxuICAgIC8vIFJlbW90ZSBwb3N0YWwgY29kZSBsb29rLXVwXG4gICAgLy8gTk9URTogY29waWVkIHRoZSBjb2RlIGluc2lkZSB0aGUgcG9zdGFsQ29kZSBjb21wdXRlZCBoYW5kbGVyIGluIGNvbnRhY3RJbmZvLmpzIHdpdGggc2xpZ2h0IGNoYW5nZXNcbiAgICB2YXIgYXBwID0gdGhpcy5hcHAsXG4gICAgICAgIHZpZXdNb2RlbCA9IHRoaXMudmlld01vZGVsO1xuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihhZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyAmJlxuICAgICAgICAgICAgICAgIWFkZHJlc3MucG9zdGFsQ29kZS5faGFzTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5wb3N0YWxDb2RlLl9oYXNMb29rdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE9uIGNoYW5nZSB0byBhIHZhbGlkIGNvZGUsIGRvIHJlbW90ZSBsb29rLXVwXG4gICAgICAgICAgICAgICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0YWxDb2RlID0gdGhpcy5wb3N0YWxDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdGFsQ29kZSAmJiAhL15cXHMqJC8udGVzdChwb3N0YWxDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLm1vZGVsLnBvc3RhbENvZGVzLmdldEl0ZW0ocG9zdGFsQ29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmNpdHkoaW5mby5jaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5zdGF0ZVByb3ZpbmNlQ29kZShpbmZvLnN0YXRlUHJvdmluY2VDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5zdGF0ZVByb3ZpbmNlTmFtZShpbmZvLnN0YXRlUHJvdmluY2VOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmVycm9yTWVzc2FnZXMucG9zdGFsQ29kZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmNpdHkoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZUNvZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3Muc3RhdGVQcm92aW5jZU5hbWUoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGVjdGVkIGVycm9ycywgYSBzaW5nbGUgbWVzc2FnZSwgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gdHlwZW9mKGVycikgPT09ICdzdHJpbmcnID8gZXJyIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnIHx8IGVyciAmJiBlcnIucmVzcG9uc2VKU09OICYmIGVyci5yZXNwb25zZUpTT04uZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlbC5lcnJvck1lc3NhZ2VzLnBvc3RhbENvZGUobXNnIHx8IGVyci5yZXNwb25zZUpTT04uZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvZyB0byBjb25zb2xlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIG9uIHJlZ3VsYXIgdXNlIGFuIGVycm9yIG9uIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3N0YWwgY29kZSBpcyBub3QgY3JpdGljYWwgYW5kIGNhbiBiZSB0cmFuc3BhcmVudDsgaWYgdGhlcmUgYXJlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0aXZpdHkgb3IgYXV0aGVudGlmaWNhdGlvbiBlcnJvcnMgd2lsbCB0aHJvdyBvbiBzYXZpbmcgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignU2VydmVyIGVycm9yIHZhbGlkYXRpbmcgWmlwIENvZGUnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgYWRkcmVzcylcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBleGNlc3NpdmUgcmVxdWVzdHMgYnkgc2V0dGluZyBhIHRpbWVvdXQgc2luY2UgdGhlIGxhdGVzdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IHRpbWVvdXQ6IDIwMCwgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJyB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU3BlY2lhbCB0cmVhdG1lbnQgb2YgdGhlIHNhdmUgb3BlcmF0aW9uXG4gICAgdGhpcy52aWV3TW9kZWwub25TYXZlID0gZnVuY3Rpb24oYWRkcmVzc0lEKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLnJldHVybk5ld0FzU2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIEdvIHRvIHByZXZpb3VzIGFjdGl2aXR5IHRoYXQgcmVxdWlyZWRcbiAgICAgICAgICAgIC8vIHRvIHNlbGVjdCBhbiBhZGRyZXNzXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REYXRhLmFkZHJlc3NJRCA9IGFkZHJlc3NJRDtcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgc2F2ZVxuICAgICAgICAgICAgdGhpcy5hcHAuc3VjY2Vzc1NhdmUoKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnVwZGF0ZU5hdkJhclN0YXRlID0gZnVuY3Rpb24gdXBkYXRlTmF2QmFyU3RhdGUoKSB7XG5cbiAgICB2YXIgbGluayA9IHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayB8fCAnL3NlcnZpY2VBZGRyZXNzZXMvJyArIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoKTtcbiAgICBcbiAgICB0aGlzLmNvbnZlcnRUb0NhbmNlbEFjdGlvbih0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCksIGxpbmspO1xufTtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6MTAgICAgXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBcbiAgICAvLyBSZXNldFxuICAgIHRoaXMudmlld01vZGVsLndhc1JlbW92ZWQoZmFsc2UpO1xuICAgIFxuICAgIC8vIFBhcmFtcyAgICBcbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHMgfHwgW107XG5cbiAgICB2YXIga2luZCA9IHBhcmFtc1swXSB8fCAnJyxcbiAgICAgICAgaXNTZXJ2aWNlID0ga2luZCA9PT0gQWRkcmVzcy5raW5kLnNlcnZpY2UsXG4gICAgICAgIGpvYlRpdGxlSUQgPSBpc1NlcnZpY2UgPyBwYXJhbXNbMV0gfDAgOiAwLFxuICAgICAgICBhZGRyZXNzSUQgPSBpc1NlcnZpY2UgPyBwYXJhbXNbMl0gfDAgOiBwYXJhbXNbMV0gfDAsXG4gICAgICAgIC8vIE9ubHkgdXNlZCBvbiBzZXJ2aWNlIGFkZHJlc3MgY3JlYXRpb24sIGluc3RlYWQgYW4gSUQgd2UgZ2V0XG4gICAgICAgIC8vIGEgc3RyaW5nIGZvciAnc2VydmljZUFyZWEnIG9yICdzZXJ2aWNlTG9jYXRpb24nKVxuICAgICAgICBzZXJ2aWNlVHlwZSA9IHBhcmFtc1syXSB8fCAnJztcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYlRpdGxlSUQpO1xuICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NJRChhZGRyZXNzSUQpO1xuICAgIFxuICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcblxuICAgIGlmIChhZGRyZXNzSUQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBhZGRyZXNzXG4gICAgICAgIHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuZ2V0SXRlbVZlcnNpb24oam9iVGl0bGVJRCwgYWRkcmVzc0lEKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoYWRkcmVzc1ZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NWZXJzaW9uKGFkZHJlc3NWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXIoJ0VkaXQgTG9jYXRpb24nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc1ZlcnNpb24obnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdVbmtub3cgbG9jYXRpb24gb3Igd2FzIGRlbGV0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZy4nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTmV3IGFkZHJlc3NcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc1ZlcnNpb24odGhpcy5hcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5uZXdJdGVtVmVyc2lvbih7XG4gICAgICAgICAgICBqb2JUaXRsZUlEOiBqb2JUaXRsZUlEXG4gICAgICAgIH0pKTtcblxuICAgICAgICBzd2l0Y2ggKHNlcnZpY2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzZXJ2aWNlQXJlYSc6XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUFyZWEodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUxvY2F0aW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXIoJ0FkZCBhIHNlcnZpY2UgYXJlYScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VydmljZUxvY2F0aW9uJzpcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzKCkuaXNTZXJ2aWNlQXJlYShmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzcygpLmlzU2VydmljZUxvY2F0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlcignQWRkIGEgc2VydmljZSBsb2NhdGlvbicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzKCkuaXNTZXJ2aWNlQXJlYSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzKCkuaXNTZXJ2aWNlTG9jYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyKCdBZGQgYSBsb2NhdGlvbicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuXG4gICAgdGhpcy5oZWFkZXIgPSBrby5vYnNlcnZhYmxlKCdFZGl0IExvY2F0aW9uJyk7XG4gICAgXG4gICAgLy8gTGlzdCBvZiBwb3NzaWJsZSBlcnJvciBtZXNzYWdlcyByZWdpc3RlcmVkXG4gICAgLy8gYnkgbmFtZVxuICAgIHRoaXMuZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgICAgcG9zdGFsQ29kZToga28ub2JzZXJ2YWJsZSgnJylcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5hZGRyZXNzSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIFxuICAgIHRoaXMuYWRkcmVzc1ZlcnNpb24gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIHRoaXMuYWRkcmVzcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmFkZHJlc3NWZXJzaW9uKCk7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdi52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuaXNMb2FkaW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBhcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zdGF0ZS5pc1NhdmluZztcbiAgICB0aGlzLmlzRGVsZXRpbmcgPSBhcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zdGF0ZS5pc0RlbGV0aW5nO1xuXG4gICAgdGhpcy53YXNSZW1vdmVkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgXG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RlbGV0aW5nKCkgfHwgYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNMb2NrZWQoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmlzTmV3ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWRkID0gdGhpcy5hZGRyZXNzKCk7XG4gICAgICAgIHJldHVybiAhYWRkIHx8ICFhZGQudXBkYXRlZERhdGUoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmFkZHJlc3NWZXJzaW9uKCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXG4gICAgICAgICAgICAgICAgJ0xvYWRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXG4gICAgICAgICAgICAgICAgICAgICdTYXZpbmcgY2hhbmdlcycgOiBcbiAgICAgICAgICAgICAgICAgICAgdiAmJiB2LmFyZURpZmZlcmVudCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlIGNoYW5nZXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlZCdcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMudW5zYXZlZENoYW5nZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5hZGRyZXNzVmVyc2lvbigpO1xuICAgICAgICByZXR1cm4gdiAmJiB2LmFyZURpZmZlcmVudCgpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZGVsZXRlVGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNEZWxldGluZygpID8gXG4gICAgICAgICAgICAgICAgJ0RlbGV0aW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgICdEZWxldGUnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBhcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zZXRJdGVtKHRoaXMuYWRkcmVzcygpLm1vZGVsLnRvUGxhaW5PYmplY3QoKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRGF0YSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCBzZXJ2ZXIgZGF0YS5cbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcygpLm1vZGVsLnVwZGF0ZVdpdGgoc2VydmVyRGF0YSk7XG4gICAgICAgICAgICAvLyBQdXNoIHZlcnNpb24gc28gaXQgYXBwZWFycyBhcyBzYXZlZFxuICAgICAgICAgICAgdGhpcy5hZGRyZXNzVmVyc2lvbigpLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3BlY2lhbCBzYXZlLCBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgYWN0aXZpdHkgb24gc2V0LXVwXG4gICAgICAgICAgICB0aGlzLm9uU2F2ZShzZXJ2ZXJEYXRhLmFkZHJlc3NJRCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHNhdmluZy4nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmNvbmZpcm1SZW1vdmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwcC5tb2RhbHMuY29uZmlybSh7XG4gICAgICAgICAgICB0aXRsZTogJ0RlbGV0ZSBsb2NhdGlvbicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXJlIHlvdSBzdXJlPyBUaGUgb3BlcmF0aW9uIGNhbm5vdCBiZSB1bmRvbmUuJyxcbiAgICAgICAgICAgIHllczogJ0RlbGV0ZScsXG4gICAgICAgICAgICBubzogJ0tlZXAnXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmRlbEl0ZW0odGhpcy5qb2JUaXRsZUlEKCksIHRoaXMuYWRkcmVzc0lEKCkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy53YXNSZW1vdmVkKHRydWUpO1xuICAgICAgICAgICAgLy8gR28gb3V0IHRoZSBkZWxldGVkIGxvY2F0aW9uXG4gICAgICAgICAgICBhcHAuc2hlbGwuZ29CYWNrKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGRlbGV0aW5nLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgVHlwZWQgdmFsdWUgYmluZGluZyByYXRoZXIgdGhhbiBodG1sIGJpbmRpbmcgYWxsb3cgdG8gYXZvaWRcbiAgICAgICAgcHJvYmxlbXMgYmVjYXVzZSB0aGUgZGF0YSBpbiBodG1sIGFyZSBzdHJpbmcgdmFsdWVzIHdoaWxlXG4gICAgICAgIHRoZSBhY3R1YWwgZGF0YSBmcm9tIHRoZSBtb2RlbCBpcyBhIG51bWJlci5cbiAgICAgICAgQ2F1c2UgcHJvYmxlbXMgb24gc29tZSBlZGdlIGNhc2VzIG1hdGNoaW5nIHZhbHVlcyBhbmQgd2l0aFxuICAgICAgICBkZXRlY3Rpb24gb2YgY2hhbmdlcyBpbiB0aGUgZGF0YSAoYmVjYXVzZSB0aGUgYmluZGluZyBjb21pbmcgZnJvbSB0aGVcbiAgICAgICAgY29udHJvbCBhc3NpZ25pbmcgYSBzdHJpbmcgdG8gdGhlIHZhbHVlKS5cbiAgICAqKi9cbiAgICB0aGlzLnNlcnZpY2VSYWRpdXNPcHRpb25zID0ga28ub2JzZXJ2YWJsZUFycmF5KFtcbiAgICAgICAgeyB2YWx1ZTogMC41LCBsYWJlbDogJzAuNSBtaWxlcycgfSxcbiAgICAgICAgeyB2YWx1ZTogMS4wLCBsYWJlbDogJzEgbWlsZScgfSxcbiAgICAgICAgeyB2YWx1ZTogMi4wLCBsYWJlbDogJzIgbWlsZXMnIH0sXG4gICAgICAgIHsgdmFsdWU6IDMuMCwgbGFiZWw6ICczIG1pbGVzJyB9LFxuICAgICAgICB7IHZhbHVlOiA0LjAsIGxhYmVsOiAnNCBtaWxlcycgfSxcbiAgICAgICAgeyB2YWx1ZTogNS4wLCBsYWJlbDogJzUgbWlsZXMnIH0sXG4gICAgICAgIHsgdmFsdWU6IDEwLCBsYWJlbDogJzEwIG1pbGVzJyB9LFxuICAgICAgICB7IHZhbHVlOiAyNSwgbGFiZWw6ICcyNSBtaWxlcycgfSxcbiAgICAgICAgeyB2YWx1ZTogNTAsIGxhYmVsOiAnNTAgbWlsZXMnIH0sXG4gICAgXSk7XG59XG4iLCIvKiogQ2FsZW5kYXIgYWN0aXZpdHkgKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKSxcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgZ2V0RGF0ZVdpdGhvdXRUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0RGF0ZVdpdGhvdXRUaW1lJyk7XG5cbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvRGF0ZVBpY2tlcicpO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBBcHBvaW50bWVudEFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDsgICAgXG4gICAgdGhpcy5tZW51SXRlbSA9ICdjYWxlbmRhcic7XG4gICAgXG4gICAgdGhpcy4kYXBwb2ludG1lbnRWaWV3ID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2NhbGVuZGFyQXBwb2ludG1lbnRWaWV3Jyk7XG4gICAgdGhpcy4kY2hvb3NlTmV3ID0gJCgnI2NhbGVuZGFyQ2hvb3NlTmV3Jyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgZGVmYXVsdCBsZWZ0QWN0aW9uL2JhY2tBY3Rpb24gc2V0dGluZ3NcbiAgICAvLyBsYXRlciB1c2VkIHRvIGluc3RhbnRpYXRlIGEgbmV3IE5hdkFjdGlvbiB0aGF0IHdpbGxcbiAgICAvLyBkeW5hbWljYWxseSBjaGFuZ2UgZGVwZW5kaW5nIG9uIHZpZXdNb2RlbCBkYXRhLlxuICAgIHZhciBiYWNrQWN0aW9uU2V0dGluZ3MgPSB7XG4gICAgICAgIGxpbms6ICdjYWxlbmRhci8nLCAvLyBQcmVzZXJ2ZSBsYXN0IHNsYXNoLCBmb3IgbGF0ZXIgdXNlXG4gICAgICAgIGljb246IEFjdGl2aXR5Lk5hdkFjdGlvbi5nb0JhY2suaWNvbigpLFxuICAgICAgICBpc1RpdGxlOiB0cnVlLFxuICAgICAgICB0ZXh0OiAnQ2FsZW5kYXInXG4gICAgfTtcbiAgICB0aGlzLm5hdkJhciA9IG5ldyBBY3Rpdml0eS5OYXZCYXIoe1xuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIGxlZnRBY3Rpb246IG5ldyBBY3Rpdml0eS5OYXZBY3Rpb24oYmFja0FjdGlvblNldHRpbmdzKSxcbiAgICAgICAgcmlnaHRBY3Rpb246IEFjdGl2aXR5Lk5hdkFjdGlvbi5nb0hlbHBJbmRleFxuICAgIH0pO1xuXG4gICAgLy8gTmF2QmFyIG11c3QgdXBkYXRlIGRlcGVuZGluZyBvbiBlZGl0TW9kZSBzdGF0ZSAodG8gYWxsb3cgY2FuY2VsIGFuZCBnb0JhY2spXG4gICAgLy8gYW5kIGFwcG9pbnRtZW50IGRhdGUgKG9uIHJlYWQtb25seSwgdG8gZ28gYmFjayB0byBjYWxlbmRhciBvbiBjdXJyZW50IGRhdGUpXG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlZGl0TW9kZSA9IHRoaXMudmlld01vZGVsLmVkaXRNb2RlKCksXG4gICAgICAgICAgICBpc05ldyA9IHRoaXMudmlld01vZGVsLmFwcG9pbnRtZW50Q2FyZFZpZXcoKSAmJiB0aGlzLnZpZXdNb2RlbC5hcHBvaW50bWVudENhcmRWaWV3KCkuaXNOZXcoKSxcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50RGF0ZSgpO1xuXG4gICAgICAgIGlmIChlZGl0TW9kZSkge1xuICAgICAgICAgICAgLy8gSXMgY2FuY2VsIGFjdGlvblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21tb24gd2F5IG9mIGtlZXAgYSBjYW5jZWwgYnV0dG9uIG9uIG5hdmJhclxuICAgICAgICAgICAgICAgIHZhciBjYW5jZWxMaW5rID0gdGhpcy52aWV3TW9kZWwuYXBwb2ludG1lbnRDYXJkVmlldygpO1xuICAgICAgICAgICAgICAgIGNhbmNlbExpbmsgPSBjYW5jZWxMaW5rICYmIGNhbmNlbExpbmsucHJvZ3Jlc3MgJiYgY2FuY2VsTGluay5wcm9ncmVzcy5jYW5jZWxMaW5rO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0VG9DYW5jZWxBY3Rpb24odGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLCBjYW5jZWxMaW5rIHx8IHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHZpZXdtb2RlbCBjYW5jZWxhdGlvbiB3aXRoIGNvbmZpcm0sIHNvIGF2b2lkIHJlZGlyZWN0cyAoYW5kIGFsbFxuICAgICAgICAgICAgICAgIC8vIGl0cyBwcm9ibGVtcywgYXMgcmVkaXJlY3RzIHRvIHRoZSBzdWItZWRpdGlvbiBwYWdlcyAtZm9yIGV4YW1wbGUsIGRhdGV0aW1lUGlja2VyKVxuICAgICAgICAgICAgICAgIC8vIGFuZCBhdm9pZCByZWxvYWQsIGp1c3QgY2hhbmdlIGN1cnJlbnQgc3RhdGUgYW5kIGtlZXBzIGluIHJlYWQtb25seSBtb2RlXG4gICAgICAgICAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLm1vZGVsLnVwZGF0ZVdpdGgoe1xuICAgICAgICAgICAgICAgICAgICBsaW5rOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogdGhpcy52aWV3TW9kZWwuYXBwb2ludG1lbnRDYXJkVmlldygpLmNvbmZpcm1DYW5jZWwuYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgZ28gdG8gY2FsZW5kYXIvZGF0ZSBhY3Rpb25cbiAgICAgICAgICAgIHZhciBkZWZMaW5rID0gYmFja0FjdGlvblNldHRpbmdzLmxpbmssXG4gICAgICAgICAgICAgICAgZGVmQmFja1RleHQgPSBiYWNrQWN0aW9uU2V0dGluZ3MudGV4dDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxpbmsgPSBkYXRlID8gZGVmTGluayArIGRhdGUudG9JU09TdHJpbmcoKSA6IGRlZkxpbms7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGRhdGUgPyBtb21lbnQoZGF0ZSkuZm9ybWF0KCdkZGRkIFsoXU0vRFspXScpIDogZGVmQmFja1RleHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5tb2RlbC51cGRhdGVXaXRoKCQuZXh0ZW5kKHt9LCBiYWNrQWN0aW9uU2V0dGluZ3MsIHtcbiAgICAgICAgICAgICAgICBsaW5rOiBsaW5rLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbnVsbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICB9LCB0aGlzKTtcblxuICAgIFxuICAgIC8vIE9uIGNoYW5naW5nIHRoZSBjdXJyZW50IGFwcG9pbnRtZW50OlxuICAgIC8vIC0gVXBkYXRlIFVSTCB0byBtYXRjaCB0aGUgYXBwb2ludG1lbnQgY3VycmVudGx5IHNob3dlZFxuICAgIC8vIC0gQXR0YWNoIGhhbmRsZXJzIHRvIElEIGFuZCBTdGFydFRpbWUgc28gd2UgbG9hZCBkYXRhIGZvciB0aGUgbmV3XG4gICAgLy8gICBkYXRlIHdoZW4gaXQgY2hhbmdlcyAoSUQgY2hhbmdlcyBvbiBjcmVhdGUgYSBib29raW5nLCBTdGFydFRpbWUgb25cbiAgICAvLyAgIGVkaXRpb24pLlxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5jdXJyZW50QXBwb2ludG1lbnQsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChhcHQpIHtcbiAgICAgICAgICAgIGlmICghYXB0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKChhcHQuaWQoKSA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdCb29raW5nIHx8XG4gICAgICAgICAgICAgICAgYXB0LmlkKCkgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubmV3RXZlbnQpICYmXG4gICAgICAgICAgICAgICAgIWFwdC5fX2lkRGF0ZUhhbmRsZXJzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBhcHQuX19pZERhdGVIYW5kbGVyc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldklEID0gYXB0LmlkKCk7XG4gICAgICAgICAgICAgICAgLy8gV2l0aCBleHBsaWNpdCBzdWJzY3JpYmUgYW5kIG5vdCBhIGNvbXB1dGVkIGJlY2F1c2Ugd2VcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGF2b2lkIHRoZSBmaXJzdCB0aW1lIGV4ZWN1dGlvbiAoY3JlYXRlcyBhbiBpbmZpbml0ZSBsb29wKVxuICAgICAgICAgICAgICAgIGFwdC5pZC5zdWJzY3JpYmUoZnVuY3Rpb24gcmVsb2NhdGVMaXN0KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBhcHQuaWQoKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZJRCA+IDAgfHwgaWQgPD0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBwcmV2SUQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc2V0Q3VycmVudChudWxsLCBpZClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC51cGRhdGVVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH0uYmluZCh0aGlzKS5fZGVsYXllZCgxMClcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBkZWxheWVkIFJFUVVJUkVEIHRvIGF2b2lkIHRyaXBsZSBsb2FkaW5nIChhY3Rpdml0eS5zaG93KSBvbiBmaXJzdCBsb2FkIHRyaWdnZXJlZCBieSBhIGNsaWNrIGV2ZW50LlxuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OjEwICovXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBcbiAgICAvLyBQcmVwYXJlIGNhbmNlbExpbmssIGJlZm9yZSBhbnkgYXR0ZW1wdCBvZiBpbnRlcm5hbCBVUkwgcmV3cml0aW5nXG4gICAgaWYgKCF0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmspIHtcbiAgICAgICAgdmFyIHJlZmVycmVyID0gdGhpcy5hcHAuc2hlbGwucmVmZXJyZXJSb3V0ZTtcbiAgICAgICAgcmVmZXJyZXIgPSByZWZlcnJlciAmJiByZWZlcnJlci51cmw7XG4gICAgICAgIC8vIEF2b2lkIGxpbmtzIHRvIHRoaXMgc2FtZSBwYWdlIGF0ICduZXcgYm9va2luZycgb3IgJ25ldyBldmVudCcgc3RhdGVcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAvL3JlZmVycmVyICYmIHJlZmVycmVyLnJlcGxhY2UoL1xcLz9hcHBvaW50bWVudFxcLy9pLCAnY2FsZW5kYXIvJyk7XG4gICAgICAgIHZhciByZWcgPSAvXFwvP2FwcG9pbnRtZW50XFwvKFteXFwvXSopXFwvKChcXC0zKXwoXFwtNCkpL2k7XG4gICAgICAgIGlmIChyZWZlcnJlciAmJiByZWcudGVzdChyZWZlcnJlcikpIHtcbiAgICAgICAgICAgIHJlZmVycmVyLnJlcGxhY2UocmVnLCAnL2FwcG9pbnRtZW50LyQxLycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmsgPSByZWZlcnJlcjtcbiAgICB9XG4gICAgXG4gICAgdmFyIHMxID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHNbMF0sXG4gICAgICAgIHMyID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHNbMV0sXG4gICAgICAgIHMzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHNbMl0sXG4gICAgICAgIGRhdGUsXG4gICAgICAgIGRhdGV0aW1lLFxuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTtcblxuICAgIHZhciBpc051bWJlciA9IC9eXFwtP1xcZCskLztcbiAgICBpZiAoaXNOdW1iZXIudGVzdChzMSkpIHtcbiAgICAgICAgLy8gZmlyc3QgcGFyYW1ldGVyIGlzIGFuIElEXG4gICAgICAgIGlkID0gczEgfDA7XG4gICAgICAgIHR5cGUgPSBzMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGUgPSBnZXREYXRlV2l0aG91dFRpbWUoczEpO1xuICAgICAgICBkYXRldGltZSA9IHMxICYmIG5ldyBEYXRlKHMxKSB8fCBkYXRlO1xuICAgICAgICBpZCA9IHMyIHwwO1xuICAgICAgICB0eXBlID0gczM7XG4gICAgfVxuICAgIFxuICAgIHZhciBzZXR1cENhcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVGhlIGNhcmQgY29tcG9uZW50IG5lZWRzIHRvIGJlIHVwZGF0ZWQgb24gbG9hZFxuICAgICAgICAvLyB3aXRoIGFueSBvcHRpb24gcGFzc2VkIHRvIHRoZSBhY3Rpdml0eSBzaW5jZSB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIGlzIGFibGUgdG8gdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBhY3Rpdml0aWVzIGl0IGhhcyByZXF1ZXN0ZWRcbiAgICAgICAgLy8gKHRvIHJlcXVlc3QgaW5mb3JtYXRpb24gZWRpdGlvbilcbiAgICAgICAgdmFyIGNhcmRBcGkgPSB0aGlzLnZpZXdNb2RlbC5hcHBvaW50bWVudENhcmRWaWV3KCk7XG4gICAgICAgIGlmIChjYXJkQXBpKSB7XG4gICAgICAgICAgICAvLyBQcmVzZXQgdGhlIHN0YXJ0VGltZSB0byB0aGUgb25lIGdpdmVuIGJ5IHRoZSByZXF1ZXN0RGF0YSBVUkwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgLy8gd2hlbiBub3QgaW4gYW4gZXhpc3RlbnQgYXBwb2ludG1lbnQsIGp1c3QgYmVjYXVzZTpcbiAgICAgICAgICAgIC8vIC0gT24gYSBuZXcgYm9va2luZyB3ZSBjYW4gcHJlc2V0IHRoZSBkYXRlIGluIHRoZSAnc2VsZWN0IGRhdGUtdGltZScgc3RlcFxuICAgICAgICAgICAgLy8gLSBPbiBhIG5ldyBldmVudCB3ZSBjYW4gcHJlc2V0IHRoZSBkYXRlIGFuZCB0aW1lIGluIHRoZSBjYXJkXG4gICAgICAgICAgICAvLyAtIE9uIHRoZSBvdGhlciBzcGVjaWFsIGNhcmRzLCBpdHMgYWxsb3dzIHRvIHBhc3MgdGhlIGRhdGV0aW1lIHRvIHRoZSBsaW5rc1xuICAgICAgICAgICAgLy8gICBmb3IgY3JlYXRpb24gb2YgYSBuZXcgYm9va2luZy9ldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlbC5hcHBvaW50bWVudENhcmRWaWV3KCkuY3VycmVudElEKCkgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFwcG9pbnRtZW50Q2FyZFZpZXcoKS5pdGVtKCkuc3RhcnRUaW1lKGRhdGV0aW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FyZEFwaS5wYXNzSW4odGhpcy5yZXF1ZXN0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSBtYXkgaGFwcGVuIHRoYXQgdGhlIGJpbmRpbmcgaXMgbm90IHJlYWR5LCBubyBjYXJkQXBpIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gYnV0IHdlIG5lZWQgaXQsIGF0dGVtcHQgYWdhaW4gaW4gc2hvcnQgc28gY2FyZCBpcyByZWFkeTpcbiAgICAgICAgICAgIHNldFRpbWVvdXQoc2V0dXBDYXJkLCA4MCk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5zZXRDdXJyZW50KGRhdGUsIGlkLCB0eXBlKVxuICAgIC50aGVuKHNldHVwQ2FyZCk7XG59O1xuXG52YXIgQXBwb2ludG1lbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQXBwb2ludG1lbnQnKTtcblxuZnVuY3Rpb24gZmluZEFwcG9pbnRtZW50SW5MaXN0KGxpc3QsIGlkKSB7XG4gICAgdmFyIGZvdW5kID0gbnVsbCxcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICBsaXN0LnNvbWUoZnVuY3Rpb24oYXB0LCBpKSB7XG4gICAgICAgIGlmIChhcHQuaWQoKSA9PT0gaWQpIHtcbiAgICAgICAgICAgIGZvdW5kID0gYXB0O1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpdGVtOiBmb3VuZCxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgfTtcbn1cblxudmFyIENhbGVuZGFyRXZlbnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ2FsZW5kYXJFdmVudCcpLFxuICAgIEJvb2tpbmcgPSByZXF1aXJlKCcuLi9tb2RlbHMvQm9va2luZycpO1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5jdXJyZW50RGF0ZSA9IGtvLm9ic2VydmFibGUobmV3IERhdGUoKSk7XG4gICAgdGhpcy5jdXJyZW50SUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMuY3VycmVudEluZGV4ID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICB0aGlzLmVkaXRNb2RlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBcbiAgICB0aGlzLmRhdGVBdmFpbGFiaWxpdHkgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5hcHBvaW50bWVudHMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRlQXZhaWwgPSB0aGlzLmRhdGVBdmFpbGFiaWxpdHkoKTtcbiAgICAgICAgcmV0dXJuIGRhdGVBdmFpbCAmJiBkYXRlQXZhaWwuYXBwb2ludG1lbnRzTGlzdCgpIHx8IFtdOyAgICAgICAgICAgIFxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8vIFRvIGFjY2VzcyB0aGUgY29tcG9uZW50IEFQSSB3ZSB1c2UgbmV4dCBvYnNlcnZhYmxlLFxuICAgIC8vIHVwZGF0ZWQgYnkgdGhlIGNvbXBvbmVudCB3aXRoIGl0cyB2aWV3XG4gICAgdGhpcy5hcHBvaW50bWVudENhcmRWaWV3ID0ga28ub2JzZXJ2YWJsZShudWxsKTtcblxuICAgIHZhciBsb2FkaW5nQXBwb2ludG1lbnQgPSBuZXcgQXBwb2ludG1lbnQoe1xuICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy5sb2FkaW5nLFxuICAgICAgICBzdW1tYXJ5OiAnTG9hZGluZy4uLidcbiAgICB9KTtcbiAgICB2YXIgbmV3RW1wdHlEYXRlQXBwb2ludG1lbnQgPSBmdW5jdGlvbiBuZXdFbXB0eURhdGVBcHBvaW50bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcHBvaW50bWVudCh7XG4gICAgICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy5lbXB0eURhdGUsXG4gICAgICAgICAgICBzdW1tYXJ5OiAnWW91IGhhdmUgbm90aGluZyBzY2hlZHVsZWQnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiB0aGlzLmN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICBlbmRUaW1lOiBtb21lbnQodGhpcy5jdXJyZW50RGF0ZSgpKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKVxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgdmFyIG5ld1VuYXZhaWxhYmxlQXBwb2ludG1lbnQgPSBmdW5jdGlvbiBuZXdVbmF2YWlsYWJsZUFwcG9pbnRtZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IEFwcG9pbnRtZW50KHtcbiAgICAgICAgICAgIGlkOiBBcHBvaW50bWVudC5zcGVjaWFsSWRzLnVuYXZhaWxhYmxlLFxuICAgICAgICAgICAgc3VtbWFyeTogJ1lvdWByZSB1bmF2YWlsYWJsZSBhbGwgZGF5JyxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogdGhpcy5jdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgZW5kVGltZTogbW9tZW50KHRoaXMuY3VycmVudERhdGUoKSkuYWRkKDEsICdkYXlzJykudG9EYXRlKClcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHZhciBuZXdGcmVlQXBwb2ludG1lbnQgPSBmdW5jdGlvbiBuZXdGcmVlQXBwb2ludG1lbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xuICAgICAgICAgICAgaWQ6IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMuZnJlZSxcbiAgICAgICAgICAgIHN1bW1hcnk6ICdGcmVlJyxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogdGhpcy5jdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgZW5kVGltZTogbW9tZW50KHRoaXMuY3VycmVudERhdGUoKSkuYWRkKDEsICdkYXlzJykudG9EYXRlKClcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHZhciBuZXdFdmVudEFwcG9pbnRtZW50ID0gZnVuY3Rpb24gbmV3RXZlbnRBcHBvaW50bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcHBvaW50bWVudCh7XG4gICAgICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdFdmVudCxcbiAgICAgICAgICAgIHN1bW1hcnk6ICdOZXcgZXZlbnQuLi4nLFxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IG5ldyBDYWxlbmRhckV2ZW50KClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgbmV3Qm9va2luZ0FwcG9pbnRtZW50ID0gZnVuY3Rpb24gbmV3Qm9va2luZ0FwcG9pbnRtZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IEFwcG9pbnRtZW50KHtcbiAgICAgICAgICAgIGlkOiBBcHBvaW50bWVudC5zcGVjaWFsSWRzLm5ld0Jvb2tpbmcsXG4gICAgICAgICAgICBzdW1tYXJ5OiAnTmV3IGJvb2tpbmcuLi4nLFxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IG5ldyBDYWxlbmRhckV2ZW50KCksXG4gICAgICAgICAgICBzb3VyY2VCb29raW5nOiBuZXcgQm9va2luZygpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5jdXJyZW50QXBwb2ludG1lbnQgPSBrby5vYnNlcnZhYmxlKGxvYWRpbmdBcHBvaW50bWVudCk7XG5cbiAgICB0aGlzLnVwZGF0ZVVybCA9IGZ1bmN0aW9uIHVwZGF0ZVVybCgpIHtcbiAgICAgICAgLy8gVXBkYXRlIFVSTCB0byBtYXRjaCB0aGUgYXBwb2ludG1lbnQgSUQgYW5kXG4gICAgICAgIC8vIHRyYWNrIGl0IHN0YXRlXG4gICAgICAgIC8vIEdldCBJRCBmcm9tIFVSTCwgdG8gYXZvaWQgZG8gYW55dGhpbmcgaWYgdGhlIHNhbWUuXG4gICAgICAgIHZhciBhcHQgPSB0aGlzLmN1cnJlbnRBcHBvaW50bWVudCgpLFxuICAgICAgICAgICAgYXB0SWQgPSBhcHQuaWQoKSxcbiAgICAgICAgICAgIGZvdW5kID0gL2FwcG9pbnRtZW50XFwvKFteXFwvXSspXFwvKFxcLT9cXGQrKS9pLmV4ZWMod2luZG93LmxvY2F0aW9uKSxcbiAgICAgICAgICAgIHVybElkID0gZm91bmQgJiYgZm91bmRbMl0gfDAsXG4gICAgICAgICAgICB1cmxEYXRlID0gZm91bmQgJiYgZm91bmRbMV0sXG4gICAgICAgICAgICBjdXJEYXRlU3RyID0gZ2V0RGF0ZVdpdGhvdXRUaW1lKGFwdC5zdGFydFRpbWUoKSkudG9JU09TdHJpbmcoKTtcblxuICAgICAgICBpZiAoIWZvdW5kIHx8XG4gICAgICAgICAgICB1cmxJZCAhPT0gYXB0SWQudG9TdHJpbmcoKSB8fFxuICAgICAgICAgICAgdXJsRGF0ZSAhPT0gY3VyRGF0ZVN0cikge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdXJsID0gJ2FwcG9pbnRtZW50LycgKyBjdXJEYXRlU3RyICsgJy8nICsgYXB0SWQ7XG5cbiAgICAgICAgICAgIC8vIElmIHdhcyBhbiBpbmNvbXBsZXRlIFVSTCwganVzdCByZXBsYWNlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgIGlmICh1cmxJZCA9PT0gJycpXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIHVybCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwucHVzaFN0YXRlKG51bGwsIG51bGwsIHVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5nb1ByZXZpb3VzID0gZnVuY3Rpb24gZ29QcmV2aW91cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUoKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY3VycmVudEluZGV4KCkgLSAxO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIC8vIEdvIHByZXZpb3VzIGRhdGVcbiAgICAgICAgICAgIHZhciBtID0gbW9tZW50KHRoaXMuY3VycmVudERhdGUoKSk7XG4gICAgICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgbSA9IG1vbWVudChuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2RGF0ZSA9IG0uc3VidHJhY3QoMSwgJ2RheXMnKS50b0RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudChwcmV2RGF0ZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVXJsKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR28gcHJldmlvdXMgaXRlbSBpbiB0aGUgbGlzdCwgYnkgY2hhbmdpbmcgY3VycmVudElEXG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICUgdGhpcy5hcHBvaW50bWVudHMoKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXB0ID0gdGhpcy5hcHBvaW50bWVudHMoKVtpbmRleF07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJRChhcHQuaWQoKSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBcHBvaW50bWVudChhcHQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVcmwoKTtcbiAgICAgICAgICAgIC8vIENvbXBsZXRlIGxvYWQtZG91YmxlIGNoZWNrOiB0aGlzLnNldEN1cnJlbnQoYXB0LnN0YXJ0VGltZSgpLCBhcHQuaWQoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5nb05leHQgPSBmdW5jdGlvbiBnb05leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlKCkpIHJldHVybjtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jdXJyZW50SW5kZXgoKSArIDE7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuYXBwb2ludG1lbnRzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBHbyBuZXh0IGRhdGVcbiAgICAgICAgICAgIHZhciBtID0gbW9tZW50KHRoaXMuY3VycmVudERhdGUoKSk7XG4gICAgICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgbSA9IG1vbWVudChuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0RGF0ZSA9IG0uYWRkKDEsICdkYXlzJykudG9EYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnQobmV4dERhdGUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVVybCgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdvIG5leHQgaXRlbSBpbiB0aGUgbGlzdCwgYnkgY2hhbmdpbmcgY3VycmVudElEXG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICUgdGhpcy5hcHBvaW50bWVudHMoKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXB0ID0gdGhpcy5hcHBvaW50bWVudHMoKVtpbmRleF07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJRChhcHQuaWQoKSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBcHBvaW50bWVudChhcHQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVcmwoKTtcbiAgICAgICAgICAgIC8vIENvbXBsZXRlIGxvYWQtZG91YmxlIGNoZWNrOiB0aGlzLnNldEN1cnJlbnQoYXB0LnN0YXJ0VGltZSgpLCBhcHQuaWQoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIENoYW5naW5nIHRoZSBjdXJyZW50IHZpZXdlZCBkYXRhIGJ5IGRhdGUgYW5kIGlkXG4gICAgKiovXG5cbiAgICB0aGlzLmdldFNwZWNpYWxJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvL2Nhc2UgLTE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0VtcHR5RGF0ZUFwcG9pbnRtZW50KCk7XG4gICAgICAgICAgICBjYXNlIEFwcG9pbnRtZW50LnNwZWNpYWxJZHMuZnJlZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnJlZUFwcG9pbnRtZW50KCk7XG4gICAgICAgICAgICBjYXNlIEFwcG9pbnRtZW50LnNwZWNpYWxJZHMubmV3RXZlbnQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50QXBwb2ludG1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdCb29raW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdCb29raW5nQXBwb2ludG1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgQXBwb2ludG1lbnQuc3BlY2lhbElkcy5sb2FkaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkaW5nQXBwb2ludG1lbnQ7XG4gICAgICAgICAgICBjYXNlIEFwcG9pbnRtZW50LnNwZWNpYWxJZHMudW5hdmFpbGFibGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1VuYXZhaWxhYmxlQXBwb2ludG1lbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZXRJdGVtRnJvbUN1cnJlbnRMaXN0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIC8qanNoaW50IG1heGRlcHRoOjYsbWF4Y29tcGxleGl0eTo4Ki9cbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmFwcG9pbnRtZW50cygpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIC8vIEZpcnN0LCByZXNwZWN0IHNwZWNpYWwgSURzLCBleGNlcHQgdGhlICdubyBhcHB0cyc6XG4gICAgICAgIGlmIChpZCA8IC0xKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5nZXRTcGVjaWFsSXRlbShpZCk7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBObyBpdGVtIElELCBlbXB0eSBsaXN0OlxuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIC8vIFNob3cgYXMgZW1wdHkgb3IgZnVsbC11bmF2YWlsYWJsZTpcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGVBdmFpbGFiaWxpdHkoKS53b3JrRGF5TWludXRlcygpID09PSAwKVxuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXdVbmF2YWlsYWJsZUFwcG9pbnRtZW50KCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaXRlbSA9IG5ld0VtcHR5RGF0ZUFwcG9pbnRtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGFydCBnZXR0aW5nIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0XG4gICAgICAgICAgICBpdGVtID0gbGlzdFswXTtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2l0aCBhbnkgSUQgdmFsdWVcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgSURcbiAgICAgICAgICAgICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBpdGVtIGluIGNhY2hlZCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZpbmRBcHBvaW50bWVudEluTGlzdChsaXN0LCBpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kLml0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBmb3VuZC5pdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBmb3VuZC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlLCB0aGUgZmlyc3QgaXRlbSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldFNwZWNpYWxJdGVtKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRJRChpdGVtLmlkKCkpO1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIHRoaXMuY3VycmVudEFwcG9pbnRtZW50KGl0ZW0pO1xuICAgIH07XG4gICAgXG4gICAgdmFyIF9zZXRDdXJyZW50ID0gZnVuY3Rpb24gc2V0Q3VycmVudChkYXRlLCBpZCwgdHlwZSkge1xuICAgICAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjhcbiAgICAgICAgLy8gSU1QT1JUQU5UOiB0aGUgZGF0ZSB0byB1c2UgbXVzdCBiZSBldmVyXG4gICAgICAgIC8vIGEgbmV3IG9iamVjdCByYXRoZXIgdGhhbiB0aGUgcmVmZXJlbmNlZCBvbmUgdG9cbiAgICAgICAgLy8gYXZvaWQgc29tZSBlZGdlIGNhc2VzIHdoZXJlIHRoZSBzYW1lIG9iamVjdCBpcyBtdXRhdGVkXG4gICAgICAgIC8vIGFuZCBjb21wYXJpc2lvbnMgY2FuIGZhaWwuIFxuICAgICAgICAvLyBnZXREYXRlV2l0aG91dFRpbWUgZW5zdXJlIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBldmVyLlxuICAgICAgICBkYXRlID0gZGF0ZSAmJiBnZXREYXRlV2l0aG91dFRpbWUoZGF0ZSkgfHwgbnVsbDtcbiAgICAgICAgaWYgKGRhdGUpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlKGRhdGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3RlIHNlYXJjaCBmb3IgaWRcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyh0cnVlKTtcblxuICAgICAgICAgICAgICAgIHZhciBub3RGb3VuZCA9IGZ1bmN0aW9uIG5vdEZvdW5kKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2V0Q3VycmVudChuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWRzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdib29raW5nJylcbiAgICAgICAgICAgICAgICAgICAgaWRzLmJvb2tpbmdJRCA9IGlkO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaWRzLmNhbGVuZGFyRXZlbnRJRCA9IGlkO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwuY2FsZW5kYXIuZ2V0QXBwb2ludG1lbnQoaWRzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBhIGxvYWQgZm9yIHRoZSBpdGVtIGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXREYXRlID0gZ2V0RGF0ZVdpdGhvdXRUaW1lKGl0ZW0uc3RhcnRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZXRDdXJyZW50KGl0RGF0ZSwgaXRlbS5pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3RGb3VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChub3RGb3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpZCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIElEc1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2V0Q3VycmVudChuZXcgRGF0ZSgpLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBkYXRlLCBubyBJRCwgbG9hZCB0b2RheVxuICAgICAgICAgICAgICAgIHJldHVybiBfc2V0Q3VycmVudChuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5jYWxlbmRhci5nZXREYXRlQXZhaWxhYmlsaXR5KGRhdGUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0ZUF2YWlsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZUF2YWlsYWJpbGl0eShkYXRlQXZhaWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SXRlbUZyb21DdXJyZW50TGlzdChpZCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0Vycm9yIGxvYWRpbmcgY2FsZW5kYXIgZXZlbnRzLic7XG4gICAgICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci5lcnJvciB8fCBlcnJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBwcm9taXNlU2V0Q3VycmVudCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuc2V0Q3VycmVudCA9IGZ1bmN0aW9uIHNldEN1cnJlbnQoZGF0ZSwgaWQsIHR5cGUpIHtcbiAgICAgICAgLy8gTk9URTogRG8gbm90aGluZyBpZiBpcyBhbHJlYWR5IGluIGxvYWRpbmcgcHJvY2Vzc1xuICAgICAgICAvLyBUT0RPOiByZXZpZXcgaWYgaXMgYmV0dGVyIHRvIGNhbmNlbCBjdXJyZW50IGFuZCBjb250aW51ZSBvclxuICAgICAgICAvLyBqdXN0IHRoZSBjdXJyZW50IHF1ZXVlIGZvciB3aGVuIGl0J3MgZmluaXNoLlxuICAgICAgICAvLyBJZiBzZXQgYXMgJ2FsbG93IGNvbmN1cnJlbnQnXG4gICAgICAgIC8vIHRoZSBpc0xvYWRpbmcgbWF5IGJlIG5vdCBlbm91Z2ggdG8gY29udHJvbCB0aGUgc2V2ZXJhbCBsb2FkaW5nc1xuICAgICAgICBwcm9taXNlU2V0Q3VycmVudCA9IHByb21pc2VTZXRDdXJyZW50LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NldEN1cnJlbnQoZGF0ZSwgaWQsIHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VTZXRDdXJyZW50O1xuICAgIH07XG59XG4iLCIvKipcbiAgICBiYWNrZ3JvdW5kQ2hlY2sgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQmFja2dyb3VuZENoZWNrQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignTWFya2V0cGxhY2UgUHJvZmlsZScsIHtcbiAgICAgICAgYmFja0xpbms6ICcvbWFya2V0cGxhY2VQcm9maWxlJ1xuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoLyphcHAqLykge1xuICAgIFxuICAgIC8vdGhpcy5pc1N5bmNpbmcgPSBhcHAubW9kZWwuYmFja2dyb3VuZENoZWNrLnN0YXRlLmlzU3luY2luZztcbiAgICB0aGlzLmlzU3luY2luZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5pc1NhdmluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIFxuICAgIHRoaXMubGlzdCA9IGtvLm9ic2VydmFibGVBcnJheSh0ZXN0ZGF0YSgpKTtcbn1cblxuXG4vLyBJTVBPUlRBTlQgQmFja2dyb3VuZCBDaGVjayB1c2VzIHZlcmlmaWNhdGlvbiBzdGF0dXNlc1xudmFyIFZlcmlmaWNhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5WZXJpZmljYXRpb24uc3RhdHVzID0ge1xuICAgIGNvbmZpcm1lZDogMSxcbiAgICBwZW5kaW5nOiAyLFxuICAgIHJldm9rZWQ6IDMsXG4gICAgb2Jzb2xldGU6IDRcbn07XG5cbmZ1bmN0aW9uIHRlc3RkYXRhKCkge1xuICAgIFxuICAgIHZhciB2ZXJBID0gbmV3IEJhY2tncm91bmRDaGVjayh7XG4gICAgICAgICAgICBuYW1lOiAnRGF0YWJhc2UgU2VhcmNoJ1xuICAgICAgICB9KSxcbiAgICAgICAgdmVyQiA9IG5ldyBCYWNrZ3JvdW5kQ2hlY2soe1xuICAgICAgICAgICAgbmFtZTogJ0Jhc2ljIENyaW1pbmFsJ1xuICAgICAgICB9KSxcbiAgICAgICAgdmVyQyA9IG5ldyBCYWNrZ3JvdW5kQ2hlY2soe1xuICAgICAgICAgICAgbmFtZTogJ1Jpc2sgQWR2ZXJzZSdcbiAgICAgICAgfSksXG4gICAgICAgIHZlckQgPSBuZXcgQmFja2dyb3VuZENoZWNrKHtcbiAgICAgICAgICAgIG5hbWU6ICdIZWFsdGhjYXJlIENoZWNrJ1xuICAgICAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBVc2VyQmFja2dyb3VuZENoZWNrKHtcbiAgICAgICAgICAgIHN0YXR1c0lEOiBWZXJpZmljYXRpb24uc3RhdHVzLmNvbmZpcm1lZCxcbiAgICAgICAgICAgIGxhc3RWZXJpZmllZERhdGU6IG5ldyBEYXRlKDIwMTUsIDEsIDEyLCAxMCwgMjMsIDMyKSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDaGVjazogdmVyQVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFVzZXJCYWNrZ3JvdW5kQ2hlY2soe1xuICAgICAgICAgICAgc3RhdHVzSUQ6IFZlcmlmaWNhdGlvbi5zdGF0dXMucmV2b2tlZCxcbiAgICAgICAgICAgIGxhc3RWZXJpZmllZERhdGU6IG5ldyBEYXRlKDIwMTUsIDUsIDIwLCAxNiwgNCwgMCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ2hlY2s6IHZlckJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBVc2VyQmFja2dyb3VuZENoZWNrKHtcbiAgICAgICAgICAgIHN0YXR1c0lEOiBWZXJpZmljYXRpb24uc3RhdHVzLnBlbmRpbmcsXG4gICAgICAgICAgICBsYXN0VmVyaWZpZWREYXRlOiBuZXcgRGF0ZSgyMDE0LCAxMSwgMzAsIDE5LCA1NCwgNCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ2hlY2s6IHZlckNcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBVc2VyQmFja2dyb3VuZENoZWNrKHtcbiAgICAgICAgICAgIHN0YXR1c0lEOiBWZXJpZmljYXRpb24uc3RhdHVzLm9ic29sZXRlLFxuICAgICAgICAgICAgbGFzdFZlcmlmaWVkRGF0ZTogbmV3IERhdGUoMjAxNCwgMTEsIDMwLCAxOSwgNTQsIDQpLFxuICAgICAgICAgICAgYmFja2dyb3VuZENoZWNrOiB2ZXJEXG4gICAgICAgIH0pXG4gICAgXTtcbn1cblxuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvTW9kZWwnKTtcbi8vIFRPRE8gSW5jb21wbGV0ZSBNb2RlbCBmb3IgVUkgbW9ja3VwXG5mdW5jdGlvbiBVc2VyQmFja2dyb3VuZENoZWNrKHZhbHVlcykge1xuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHN0YXR1c0lEOiAwLFxuICAgICAgICBsYXN0VmVyaWZpZWREYXRlOiBudWxsLFxuICAgICAgICBiYWNrZ3JvdW5kQ2hlY2s6IHtcbiAgICAgICAgICAgIE1vZGVsOiBCYWNrZ3JvdW5kQ2hlY2tcbiAgICAgICAgfVxuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgLy8gU2FtZSBhcyBpbiBVc2VyVmVyaWZpY2F0aW9uc1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTDE4TlxuICAgICAgICB2YXIgc3RhdHVzVGV4dHNlblVTID0ge1xuICAgICAgICAgICAgJ3ZlcmlmaWNhdGlvbi5zdGF0dXMuY29uZmlybWVkJzogJ0NvbmZpcm1lZCcsXG4gICAgICAgICAgICAndmVyaWZpY2F0aW9uLnN0YXR1cy5wZW5kaW5nJzogJ1BlbmRpbmcnLFxuICAgICAgICAgICAgJ3ZlcmlmaWNhdGlvbi5zdGF0dXMucmV2b2tlZCc6ICdSZXZva2VkJyxcbiAgICAgICAgICAgICd2ZXJpZmljYXRpb24uc3RhdHVzLm9ic29sZXRlJzogJ09ic29sZXRlJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IGVudW1HZXROYW1lKHRoaXMuc3RhdHVzSUQoKSwgVmVyaWZpY2F0aW9uLnN0YXR1cyk7XG4gICAgICAgIHJldHVybiBzdGF0dXNUZXh0c2VuVVNbJ3ZlcmlmaWNhdGlvbi5zdGF0dXMuJyArIHN0YXR1c0NvZGVdO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8qKlxuICAgICAgICBDaGVjayBpZiB2ZXJpZmljYXRpb24gaGFzIGEgZ2l2ZW4gc3RhdHVzIGJ5IG5hbWVcbiAgICAqKi9cbiAgICB0aGlzLmlzU3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1c05hbWUpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5zdGF0dXNJRCgpO1xuICAgICAgICByZXR1cm4gVmVyaWZpY2F0aW9uLnN0YXR1c1tzdGF0dXNOYW1lXSA9PT0gaWQ7XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuZnVuY3Rpb24gQmFja2dyb3VuZENoZWNrKHZhbHVlcykge1xuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIG5hbWU6ICcnXG4gICAgfSwgdmFsdWVzKTtcbn1cblxuLy8gQmVjb21lIHNoYXJlZCB1dGlsOyBpdCBpcyBvbiBWZXJpZmljYXRpb25zIHRvbzpcbmZ1bmN0aW9uIGVudW1HZXROYW1lKHZhbHVlLCBlbnVtTGlzdCkge1xuICAgIHZhciBmb3VuZCA9IG51bGw7XG4gICAgT2JqZWN0LmtleXMoZW51bUxpc3QpLnNvbWUoZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoZW51bUxpc3Rba10gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGs7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiLCIvKipcbiAgICBCb29rTWVCdXR0b24gYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEJvb2tNZUJ1dHRvbkFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDtcblxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycpO1xuICAgIFxuICAgIC8vIEF1dG8gc2VsZWN0IHRleHQgb24gdGV4dGFyZWEsIGZvciBiZXR0ZXIgJ2NvcHknXG4gICAgLy8gTk9URTogdGhlICdzZWxlY3QnIG11c3QgaGFwcGVuIG9uIGNsaWNrLCBubyB0b3VjaCwgbm90IGZvY3VzLFxuICAgIC8vIG9ubHkgJ2NsaWNrJyBpcyByZWxpYWJsZSBhbmQgYnVnLWZyZWUuXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGFjdGl2aXR5LFxuICAgICAgICBldmVudDogJ2NsaWNrJyxcbiAgICAgICAgc2VsZWN0b3I6ICd0ZXh0YXJlYScsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5tYXJrZXRwbGFjZVByb2ZpbGUsXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLnRhc2sgPT09ICdzYXZlJykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdFcnJvciBsb2FkaW5nIGRhdGEgdG8gYnVpbGQgdGhlIEJ1dHRvbi4nO1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci50YXNrICYmIGVyci5lcnJvciB8fCBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICBcbiAgICB2YXIgJGNvZGUgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCd0ZXh0YXJlYScpO1xuICAgIHRoaXMudmlld01vZGVsLmNvcHlDb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlcnJNc2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAkY29kZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKSkge1xuICAgICAgICAgICAgICAgIGVyck1zZyA9ICdJbXBvc3NpYmxlIHRvIGNvcHkgdGV4dC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgZXJyTXNnID0gJ0ltcG9zc2libGUgdG8gY29weSB0ZXh0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyck1zZykge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7IGVycm9yOiBlcnJNc2cgfSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxuICAgIHRoaXMuYXBwLm1vZGVsLm1hcmtldHBsYWNlUHJvZmlsZS5zeW5jKCk7XG4gICAgXG4gICAgLy8gU2V0IHRoZSBqb2IgdGl0bGVcbiAgICB2YXIgam9iSUQgPSBzdGF0ZS5yb3V0ZS5zZWdtZW50c1swXSB8MDtcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYklEKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcblxuICAgIHZhciBtYXJrZXRwbGFjZVByb2ZpbGUgPSBhcHAubW9kZWwubWFya2V0cGxhY2VQcm9maWxlO1xuICAgIFxuICAgIC8vIEFjdHVhbCBkYXRhIGZvciB0aGUgZm9ybTpcbiAgICBcbiAgICAvLyBSZWFkLW9ubHkgYm9va0NvZGVcbiAgICB0aGlzLmJvb2tDb2RlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXRwbGFjZVByb2ZpbGUuZGF0YS5ib29rQ29kZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgXG4gICAgLy8gQnV0dG9uIHR5cGUsIGNhbiBiZTogJ2ljb24nLCAnbGluaydcbiAgICB0aGlzLnR5cGUgPSBrby5vYnNlcnZhYmxlKCdpY29uJyk7XG5cbiAgICB0aGlzLmlzTG9ja2VkID0gbWFya2V0cGxhY2VQcm9maWxlLmlzTG9ja2VkO1xuICAgIFxuICAgIC8vIEdlbmVyYXRpb24gb2YgdGhlIGJ1dHRvbiBjb2RlXG4gICAgXG4gICAgdmFyIGJ1dHRvblRlbXBsYXRlID1cbiAgICAgICAgJzwhLS0gYmVnaW4gTG9jb25vbWljcyBib29rLW1lLWJ1dHRvbiAtLT4nICtcbiAgICAgICAgJzxhIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2tcIj48aW1nIGFsdD1cIlwiIHN0eWxlPVwiYm9yZGVyOm5vbmVcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjUwXCIgLz48L2E+JyArIFxuICAgICAgICAnPCEtLSBlbmQgTG9jb25vbWljcyBib29rLW1lLWJ1dHRvbiAtLT4nO1xuICAgIFxuICAgIHZhciBsaW5rVGVtcGxhdGUgPVxuICAgICAgICAnPCEtLSBiZWdpbiBMb2Nvbm9taWNzIGJvb2stbWUtYnV0dG9uIC0tPicgK1xuICAgICAgICAnPGE+PHNwYW4+PC9zcGFuPjwvYT4nICtcbiAgICAgICAgJzwhLS0gZW5kIExvY29ub21pY3MgYm9vay1tZS1idXR0b24gLS0+JztcblxuICAgIHRoaXMuYnV0dG9uSHRtbENvZGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICBpZiAobWFya2V0cGxhY2VQcm9maWxlLmlzTG9hZGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xvYWRpbmcuLi4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUoKSxcbiAgICAgICAgICAgICAgICB0cGwgPSBidXR0b25UZW1wbGF0ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsaW5rJylcbiAgICAgICAgICAgICAgICB0cGwgPSBsaW5rVGVtcGxhdGU7XG5cbiAgICAgICAgICAgIHZhciBzaXRlVXJsID0gJCgnaHRtbCcpLmF0dHIoJ2RhdGEtc2l0ZS11cmwnKSxcbiAgICAgICAgICAgICAgICBsaW5rVXJsID0gc2l0ZVVybCArICcvYm9vay8nICsgdGhpcy5ib29rQ29kZSgpICsgJy8nICsgdGhpcy5qb2JUaXRsZUlEKCkgKyAnLycsXG4gICAgICAgICAgICAgICAgaW1nVXJsID0gc2l0ZVVybCArICcvaW1nL2V4dGVybi9ib29rLW1lLW5vdy1idXR0b24uc3ZnJztcblxuICAgICAgICAgICAgdmFyIGNvZGUgPSBnZW5lcmF0ZUJ1dHRvbkNvZGUoe1xuICAgICAgICAgICAgICAgIHRwbDogdHBsLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnQ2xpY2sgaGVyZSB0byBib29rIG1lIG5vdyAob24gbG9jb25vbWljcy5jb20pJyxcbiAgICAgICAgICAgICAgICBsaW5rVXJsOiBsaW5rVXJsLFxuICAgICAgICAgICAgICAgIGltZ1VybDogaW1nVXJsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc2VuZEJ5RW1haWxVUkwgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnbWFpbHRvOiZib2R5PScgKyBlbmNvZGVVUklDb21wb25lbnQoJ0xvY29ub21pY3MgQm9vayBNZSBOb3cgQnV0dG9uIEhUTUwgY29kZTogJyArIHRoaXMuYnV0dG9uSHRtbENvZGUoKSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnV0dG9uQ29kZShvcHRpb25zKSB7XG5cbiAgICB2YXIgJGJ0biA9ICQoJC5wYXJzZUhUTUwoJzxkaXY+JyArIG9wdGlvbnMudHBsICsgJzwvZGl2PicpKTtcblxuICAgICRidG5cbiAgICAuZmluZCgnYScpXG4gICAgLmF0dHIoJ2hyZWYnLCBvcHRpb25zLmxpbmtVcmwpXG4gICAgLmZpbmQoJ3NwYW4nKVxuICAgIC50ZXh0KG9wdGlvbnMubGFiZWwpO1xuICAgICRidG5cbiAgICAuZmluZCgnaW1nJylcbiAgICAuYXR0cignc3JjJywgb3B0aW9ucy5pbWdVcmwpXG4gICAgLmF0dHIoJ2FsdCcsIG9wdGlvbnMubGFiZWwpO1xuXG4gICAgcmV0dXJuICRidG4uaHRtbCgpO1xufVxuIiwiLyoqXG4gICAgQm9va2luZyBhY3Rpdml0eVxuICAgIFxuICAgIEl0IGFsbG93cyBhIGNsaWVudCB0byBib29rIGEgc2VydmljZVByb2Zlc3Npb25hbFxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgU2lnbnVwVk0gPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL1NpZ251cCcpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQm9va2luZ0FjdGl2aXR5KCkge1xuXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIEFueSwgd2UgcHJvdmlkZSBsb2dpbiBhbmQgc2lnbnVwIG9wdGlvbnMgaW50ZWdyYXRlZCBoZXJlXG4gICAgLy90aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignQm9va2luZycpO1xuICAgIFxuICAgIC8vIE9ubHkgb24gY2hhbmdlIChub3QgZmlyc3QgdGltZSksIHdoZW4gY2hvb3NlZCB0aGUgb3B0aW9uICdjdXN0b20nXG4gICAgLy8gZnJvbSBncmF0dWl0eSwgZm9jdXMgdGhlIHRleHRib3ggdG8gaW5wdXQgdGhlIGN1c3RvbSB2YWx1ZVxuICAgIHRoaXMudmlld01vZGVsLnByZXNldEdyYXR1aXR5LnN1YnNjcmliZShmdW5jdGlvbihwcmVzZXQpIHtcbiAgICAgICAgaWYgKHByZXNldCA9PT0gJ2N1c3RvbScpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGFsbG93IHRoZSBiaW5kaW5nIHRvIGRpc3BsYXkgdGhlIGN1c3RvbSBmaWVsZCxcbiAgICAgICAgICAgIC8vIHRoZSBVSSB0byB1cGRhdGUsIGFuZCB0aGVuIGZvY3VzIGl0OyB0cnlpbmcgdG8gZG8gaXQgd2l0aG91dFxuICAgICAgICAgICAgLy8gdGltZW91dCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGFjdGl2aXR5LmZpbmQoJ1tuYW1lPWN1c3RvbS1ncmF0dWl0eV0nKS5mb2N1cygpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCA1MCk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICAgIFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5wcm9ncmVzcy5zdGVwLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgbG9hZCBvZiB0aGUgc3BlY2lmaWMgc3RlcFxuICAgICAgICAgICAgdmFyIGxvYWQgPSB0aGlzW3RoaXMudmlld01vZGVsLnByb2dyZXNzLmN1cnJlbnRTdGVwKCkgKyAnTG9hZCddO1xuICAgICAgICAgICAgaWYgKGxvYWQpXG4gICAgICAgICAgICAgICAgbG9hZC5jYWxsKHRoaXMpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcblxufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcblxuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cztcbiAgICB2YXIgYm9va0NvZGUgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5xdWVyeS5ib29rQ29kZTtcblxuICAgIHRoaXMudmlld01vZGVsLmluaXRCb29raW5nKHBhcmFtc1swXSB8MCwgcGFyYW1zWzFdIHwwLCBib29rQ29kZSk7XG59O1xuXG4vLyBMMThOXG4vLyBMaXN0IG9mIGFsbCBwb3NzaWJsZSBzdGVwcyBieSBuYW1lIHByb3ZpZGluZyB0aGUgbGFuZ3VhZ2UgZm9yIHRoZSBVSVxudmFyIHN0ZXBzTGFiZWxzID0ge1xuICAgIHNlcnZpY2VzOiAnU2VydmljZXMnLFxuICAgIHNlbGVjdExvY2F0aW9uOiAnU2VsZWN0IGEgbG9jYXRpb24nLFxuICAgIHNlbGVjdFRpbWVzOiAnU2VsZWN0IHByZWZlcnJlZCB0aW1lcycsXG4gICAgc2VsZWN0VGltZTogJ1NlbGVjdCB0aGUgdGltZScsXG4gICAgcGF5bWVudDogJ1BheW1lbnQnLFxuICAgIGNvbmZpcm06ICdDb25maXJtJ1xufTtcblxuLy8vXG4vLy8gTWV0aG9kcyB0aGF0IGluaXRpYWxpemUvbG9hZCBlYWNoIHN0ZXAsIGdpdmVuIHRoZSBuYW1lIG9mIHJlZ2lzdGVyZWQgc3RlcHNcbi8vLyBhbmQgc3VmaXggJ0xvYWQnXG5cbkEucHJvdG90eXBlLnNlcnZpY2VzTG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE8gRGVwZW5kcyBvbiBqb2JUaXRsZTpcbiAgICB0aGlzLnZpZXdNb2RlbC5zdXBwb3J0c0dyYXR1aXR5KHRydWUpOyAgICBcbn07XG5cbkEucHJvdG90eXBlLnNlbGVjdExvY2F0aW9uTG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIExvYWQgcmVtb3RlIGFkZHJlc3NlcyBmb3IgcHJvdmlkZXIgYW5kIGpvYnRpdGxlLCByZXNldCBmaXJzdFxuICAgIHRoaXMudmlld01vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc291cmNlQWRkcmVzc2VzKFtdKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmdTZXJ2aWNlQWRkcmVzc2VzKHRydWUpO1xuICAgIHRoaXMuYXBwLm1vZGVsLnVzZXJzLmdldFNlcnZpY2VBZGRyZXNzZXModGhpcy52aWV3TW9kZWwuYm9va2luZy5zZXJ2aWNlUHJvZmVzc2lvbmFsVXNlcklEKCksIHRoaXMudmlld01vZGVsLmJvb2tpbmcuam9iVGl0bGVJRCgpKVxuICAgIC50aGVuKGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuYXNNb2RlbChsaXN0KTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zb3VyY2VBZGRyZXNzZXMobGlzdCk7XG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9hZGluZ1NlcnZpY2VBZGRyZXNzZXMoZmFsc2UpO1xuICAgICAgICAvLyBUT0RPOiBMb2FkIHVzZXIgcGVyc29uYWwgYWRkcmVzc2VzIHRvbyBpZiB0aGUgc2VydmljZSBwcm9mZXNzaW9uYWwgaGFzIHNlcnZpY2VSYWRpdXNcbiAgICB9LmJpbmQodGhpcykpXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmdTZXJ2aWNlQWRkcmVzc2VzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7IGVycm9yOiBlcnIgfSk7XG4gICAgfSk7XG59O1xuXG5BLnByb3RvdHlwZS5zZWxlY3RUaW1lc0xvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGlja2VyID0gdGhpcy52aWV3TW9kZWwuc2VydmljZVN0YXJ0RGF0ZVBpY2tlclZpZXcoKTtcbiAgICB0aGlzLnZpZXdNb2RlbC50aW1lRmllbGRUb0JlU2VsZWN0ZWQoJycpO1xuICAgIHBpY2tlci5zZWxlY3RlZERhdGV0aW1lKG51bGwpO1xuICAgIHBpY2tlci51c2VySUQodGhpcy52aWV3TW9kZWwuYm9va2luZy5zZXJ2aWNlUHJvZmVzc2lvbmFsVXNlcklEKCkpO1xuICAgIHBpY2tlci5zZWxlY3RlZERhdGUobmV3IERhdGUoKSk7XG59O1xuXG5BLnByb3RvdHlwZS5zZWxlY3RUaW1lTG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld01vZGVsLnRpbWVGaWVsZFRvQmVTZWxlY3RlZCgnc2VydmljZURhdGUnKTtcbiAgICB2YXIgcGlja2VyID0gdGhpcy52aWV3TW9kZWwuc2VydmljZVN0YXJ0RGF0ZVBpY2tlclZpZXcoKTtcbiAgICBwaWNrZXIuc2VsZWN0ZWREYXRldGltZShudWxsKTtcbiAgICBwaWNrZXIudXNlcklEKHRoaXMudmlld01vZGVsLmJvb2tpbmcuc2VydmljZVByb2Zlc3Npb25hbFVzZXJJRCgpKTtcbiAgICBwaWNrZXIuc2VsZWN0ZWREYXRlKG5ldyBEYXRlKCkpO1xufTtcblxuQS5wcm90b3R5cGUucGF5bWVudExvYWQgPSBmdW5jdGlvbigpIHtcbn07XG5cbkEucHJvdG90eXBlLmNvbmZpcm1Mb2FkID0gZnVuY3Rpb24oKSB7XG59O1xuXG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpO1xudmFyIG51bWVyYWwgPSByZXF1aXJlKCdudW1lcmFsJyk7XG5cbnZhciBQcmljaW5nU3VtbWFyeURldGFpbCA9IHJlcXVpcmUoJy4uL21vZGVscy9QcmljaW5nU3VtbWFyeURldGFpbCcpLFxuICAgIFByaWNpbmdTdW1tYXJ5ID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ByaWNpbmdTdW1tYXJ5Jyk7XG5cbnZhciBTZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZVZNID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9TZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZScpLFxuICAgIEJvb2tpbmdQcm9ncmVzcyA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvQm9va2luZ1Byb2dyZXNzJyksXG4gICAgQm9va2luZyA9IHJlcXVpcmUoJy4uL21vZGVscy9Cb29raW5nJyksXG4gICAgU2VydmljZUFkZHJlc3NlcyA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvU2VydmljZUFkZHJlc3NlcycpLFxuICAgIElucHV0UGF5bWVudE1ldGhvZCA9IHJlcXVpcmUoJy4uL21vZGVscy9JbnB1dFBheW1lbnRNZXRob2QnKSxcbiAgICBBZGRyZXNzID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FkZHJlc3MnKSxcbiAgICBFdmVudERhdGVzID0gcmVxdWlyZSgnLi4vbW9kZWxzL0V2ZW50RGF0ZXMnKSxcbiAgICBQdWJsaWNVc2VyID0gcmVxdWlyZSgnLi4vbW9kZWxzL1B1YmxpY1VzZXInKTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuICAgIC8vanNoaW50IG1heHN0YXRlbWVudHM6MTAwXG4gICAgXG4gICAgLy8vXG4gICAgLy8vIEJvb2tpbmcgRGF0YSwgcmVxdWVzdCBvcHRpb25zIGFuZCByZWxhdGVkIGVudGl0aWVzXG4gICAgdGhpcy5ib29raW5nID0gbmV3IEJvb2tpbmcoKTtcbiAgICB0aGlzLm5ld0RhdGFSZWFkeSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuc3VtbWFyeSA9IG5ldyBQcmljaW5nU3VtbWFyeVZNKCk7XG4gICAgdGhpcy5ib29rQ29kZSA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMgPSBuZXcgU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VWTShhcHApO1xuICAgIHRoaXMuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLmlzU2VsZWN0aW9uTW9kZSh0cnVlKTtcbiAgICB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5wcmVTZWxlY3RlZFNlcnZpY2VzKFtdKTtcbiAgICB0aGlzLm1ha2VSZXBlYXRCb29raW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5wcm9tb3Rpb25hbENvZGUgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICB0aGlzLnBheW1lbnRNZXRob2QgPSBrby5vYnNlcnZhYmxlKG51bGwpOyAvLyBJbnB1dFBheW1lbnRNZXRob2RcbiAgICB0aGlzLmlzQW5vbnltb3VzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdSA9IGFwcC5tb2RlbC51c2VyKCk7XG4gICAgICAgIHJldHVybiB1ICYmIHUuaXNBbm9ueW1vdXMoKTtcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmNvbmZpcm1CdG5UZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0Fub255bW91cygpID8gJ1NpZ24gdXAgYW5kIGNvbmZpcm0nIDogJ0NvbmZpcm0nO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8vIERpc3BsYXllZCB0ZXh0IHdoZW4gdGhlcmUgaXMgYSBwYXltZW50IGNhcmRcbiAgICB0aGlzLnBheW1lbnRNZXRob2REaXNwbGF5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuYm9va2luZy5wYXltZW50TGFzdEZvdXJDYXJkTnVtYmVyRGlnaXRzKCk7XG4gICAgICAgIHJldHVybiBuID8gJ0NhcmQgZW5kaW5nIGluICcgKyBuIDogJyc7XG4gICAgfSwgdGhpcyk7XG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwbSA9IHRoaXMucGF5bWVudE1ldGhvZCgpLFxuICAgICAgICAgICAgbnVtYmVyID0gcG0gJiYgcG0uY2FyZE51bWJlcigpO1xuICAgICAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG51bWJlci5zbGljZSgtNCk7XG4gICAgICAgICAgICB0aGlzLmJvb2tpbmcucGF5bWVudExhc3RGb3VyQ2FyZE51bWJlckRpZ2l0cyhsYXN0KTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8vL1xuICAgIC8vLyBTaWdudXBcbiAgICB0aGlzLnNpZ251cFZNID0gbmV3IFNpZ251cFZNKGFwcCk7XG5cbiAgICAvLy9cbiAgICAvLy8gQWRkcmVzc1xuICAgIHRoaXMuc2VydmljZUFkZHJlc3NlcyA9IG5ldyBTZXJ2aWNlQWRkcmVzc2VzKCk7XG4gICAgdGhpcy5pc0xvYWRpbmdTZXJ2aWNlQWRkcmVzc2VzID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5zZXJ2aWNlQWRkcmVzc2VzLnNlbGVjdGVkQWRkcmVzcy5zdWJzY3JpYmUodGhpcy5ib29raW5nLnNlcnZpY2VBZGRyZXNzLCB0aGlzKTtcblxuICAgIC8vL1xuICAgIC8vLyBHcmF0dWl0eVxuICAgIC8vIFRPRE8gQ29tcGxldGUgc3VwcG9ydCBmb3IgZ3JhdHVpdHksIHNlcnZlci1zaWRlXG4gICAgdGhpcy5zdXBwb3J0c0dyYXR1aXR5ID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5jdXN0b21HcmF0dWl0eSA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5wcmVzZXRHcmF0dWl0eSA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5ncmF0dWl0eUFtb3VudCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5ncmF0dWl0eVBlcmNlbnRhZ2UgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmVzZXQgPSB0aGlzLnByZXNldEdyYXR1aXR5KCk7XG4gICAgICAgIGlmIChwcmVzZXQgPT09ICdjdXN0b20nKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8gU3luYzogQXV0b21hdGljIHVwZGF0ZXMgYmV0d2VlbiBkZXBlbmRlbnQgbW9kZWxzOlxuICAgIHRoaXMuYm9va2luZy5qb2JUaXRsZUlELnN1YnNjcmliZSh0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5qb2JUaXRsZUlEKTtcbiAgICB0aGlzLmJvb2tpbmcuc2VydmljZVByb2Zlc3Npb25hbFVzZXJJRC5zdWJzY3JpYmUodGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMuc2VydmljZVByb2Zlc3Npb25hbElEKTtcblxuICAgIHRoaXMuZ3JhdHVpdHlQZXJjZW50YWdlLnN1YnNjcmliZSh0aGlzLnN1bW1hcnkuZ3JhdHVpdHlQZXJjZW50YWdlKTtcbiAgICB0aGlzLmdyYXR1aXR5QW1vdW50LnN1YnNjcmliZSh0aGlzLnN1bW1hcnkuZ3JhdHVpdHlBbW91bnQpO1xuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VydmljZXMgPSB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5zZWxlY3RlZFNlcnZpY2VzKCk7XG4gICAgICAgIHRoaXMuc3VtbWFyeS5kZXRhaWxzKHNlcnZpY2VzLm1hcChmdW5jdGlvbihzZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJpY2luZ1N1bW1hcnlEZXRhaWwuZnJvbVNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlKHNlcnZpY2UpO1xuICAgICAgICB9KSk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8gRmlsbCBib29raW5nIHNlcnZpY2VzIGZyb20gdGhlIHNlbGVjdGVkIHNlcnZpY2VzIHZpZXdcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ib29raW5nLnByaWNpbmdTdW1tYXJ5KHRoaXMuc3VtbWFyeS50b1ByaWNpbmdTdW1tYXJ5KCkpO1xuICAgIH0sIHRoaXMpXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiAyMCB9IH0pO1xuICAgIFxuICAgIC8vL1xuICAgIC8vLyBTZXJ2aWNlIFByb2Zlc3Npb25hbCBJbmZvXG4gICAgdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsSW5mbyA9IGtvLm9ic2VydmFibGUobmV3IFB1YmxpY1VzZXIoKSk7XG4gICAgdGhpcy5pc0xvYWRpbmdTZXJ2aWNlUHJvZmVzc2lvbmFsSW5mbyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuYm9va2luZy5zZXJ2aWNlUHJvZmVzc2lvbmFsVXNlcklELnN1YnNjcmliZShmdW5jdGlvbih1c2VySUQpIHtcbiAgICAgICAgaWYgKCF1c2VySUQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZVByb2Zlc3Npb25hbEluZm8oKS5tb2RlbC5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0xvYWRpbmdTZXJ2aWNlUHJvZmVzc2lvbmFsSW5mbyh0cnVlKTtcblxuICAgICAgICBhcHAubW9kZWwudXNlcnMuZ2V0VXNlcih1c2VySUQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgIGluZm8uc2VsZWN0ZWRKb2JUaXRsZUlEID0gdGhpcy5ib29raW5nLmpvYlRpdGxlSUQoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZVByb2Zlc3Npb25hbEluZm8oKS5tb2RlbC51cGRhdGVXaXRoKGluZm8sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmdTZXJ2aWNlUHJvZmVzc2lvbmFsSW5mbyhmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmdTZXJ2aWNlUHJvZmVzc2lvbmFsSW5mbyhmYWxzZSk7XG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7IGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8vXG4gICAgLy8vIERhdGUgdGltZSBwaWNrZXIocylcbiAgICB0aGlzLnNlcnZpY2VTdGFydERhdGVQaWNrZXJWaWV3ID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICB0aGlzLnRpbWVGaWVsZFRvQmVTZWxlY3RlZCA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uIHRyaWdnZXJTZWxlY3RlZERhdGV0aW1lKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuc2VydmljZVN0YXJ0RGF0ZVBpY2tlclZpZXcoKSxcbiAgICAgICAgICAgIGR0ID0gdiAmJiB2LnNlbGVjdGVkRGF0ZXRpbWUoKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmJvb2tpbmcuc2VydmljZURhdGUoKSxcbiAgICAgICAgICAgIGZpZWxkID0gdGhpcy50aW1lRmllbGRUb0JlU2VsZWN0ZWQucGVlaygpO1xuXG4gICAgICAgIGlmIChkdCAmJiBmaWVsZCAmJlxuICAgICAgICAgICAgZHQudG9TdHJpbmcoKSAhPT0gKGN1cnJlbnQgJiYgY3VycmVudC5zdGFydFRpbWUoKS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgdGhpcy5ib29raW5nW2ZpZWxkXShuZXcgRXZlbnREYXRlcyh7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBkdFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5ib29raW5nW2ZpZWxkXSgpLmR1cmF0aW9uKHtcbiAgICAgICAgICAgICAgICBtaW51dGVzOiB0aGlzLnN1bW1hcnkuZmlyc3RTZXNzaW9uRHVyYXRpb25NaW51dGVzKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5ib29raW5nLmluc3RhbnRCb29raW5nKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcy5uZXh0KCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lRmllbGRUb0JlU2VsZWN0ZWQoJycpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5zdW1tYXJ5LmZpcnN0U2Vzc2lvbkR1cmF0aW9uTWludXRlcy5zdWJzY3JpYmUoZnVuY3Rpb24obWludXRlcykge1xuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlU3RhcnREYXRlUGlja2VyVmlldygpKSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2VTdGFydERhdGVQaWNrZXJWaWV3KCkucmVxdWlyZWREdXJhdGlvbk1pbnV0ZXMobWludXRlcyk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLnBpY2tTZXJ2aWNlRGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRpbWVGaWVsZFRvQmVTZWxlY3RlZCgnc2VydmljZURhdGUnKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgdGhpcy5waWNrQWx0ZXJuYXRpdmVEYXRlMSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRpbWVGaWVsZFRvQmVTZWxlY3RlZCgnYWx0ZXJuYXRpdmVEYXRlMScpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICB0aGlzLnBpY2tBbHRlcm5hdGl2ZURhdGUyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGltZUZpZWxkVG9CZVNlbGVjdGVkKCdhbHRlcm5hdGl2ZURhdGUyJyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIC8vL1xuICAgIC8vLyBQcm9ncmVzcyBtYW5hZ2VtZW50XG4gICAgLy8gU2UgaW5pY2lhbGl6YSBjb24gdW4gZXN0YWRvIHByZXZpbyBhbCBwcmltZXIgcGFzb1xuICAgIC8vIChuZWNlc2FyaW8gcGFyYSBlbCBtYW5lam8gZGUgcmVzZXQgeSBwcmVwYXJhY2nDs24gZGVsIGFjdGl2aXR5KVxuICAgIHRoaXMucHJvZ3Jlc3MgPSBuZXcgQm9va2luZ1Byb2dyZXNzKHsgc3RlcDogLTEgfSk7XG4gICAgXG4gICAgdGhpcy5uZXh0U3RlcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb2dyZXNzLm5leHQoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ29TdGVwID0gZnVuY3Rpb24oc3RlcE5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByb2dyZXNzLnN0ZXBzTGlzdCgpLmluZGV4T2Yoc3RlcE5hbWUpO1xuICAgICAgICB0aGlzLnByb2dyZXNzLnN0ZXAoaSA+IC0xID8gaSA6IDApO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFN0ZXBMYWJlbCA9IGZ1bmN0aW9uKHN0ZXBOYW1lKSB7XG4gICAgICAgIHJldHVybiBzdGVwc0xhYmVsc1tzdGVwTmFtZV0gfHwgc3RlcE5hbWU7XG4gICAgfTtcbiAgICBcbiAgICAvLyBSZXVzZWQgc3RlcCBvYnNlcnZlcnNcbiAgICB0aGlzLmlzQXRTZWxlY3RUaW1lcyA9IHRoaXMucHJvZ3Jlc3Mub2JzZXJ2ZVN0ZXAoJ3NlbGVjdFRpbWVzJyk7XG4gICAgdGhpcy5pc0F0U2VsZWN0VGltZSA9IHRoaXMucHJvZ3Jlc3Mub2JzZXJ2ZVN0ZXAoJ3NlbGVjdFRpbWUnKTtcbiAgICBcbiAgICAvLy9cbiAgICAvLy8gUmVzZXRcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmV3RGF0YVJlYWR5KGZhbHNlKTtcbiAgICAgICAgdGhpcy5ib29raW5nLm1vZGVsLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLnByZVNlbGVjdGVkU2VydmljZXMoW10pO1xuICAgICAgICB0aGlzLmN1c3RvbUdyYXR1aXR5KDApO1xuICAgICAgICB0aGlzLnByZXNldEdyYXR1aXR5KDApO1xuICAgICAgICB0aGlzLmdyYXR1aXR5QW1vdW50KDApO1xuICAgICAgICB0aGlzLnByb21vdGlvbmFsQ29kZSgnJyk7XG4gICAgICAgIHRoaXMubWFrZVJlcGVhdEJvb2tpbmcoZmFsc2UpO1xuICAgICAgICB0aGlzLnBheW1lbnRNZXRob2QobnVsbCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuaXNQaG9uZVNlcnZpY2VPbmx5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMuc2VsZWN0ZWRTZXJ2aWNlcygpLmV2ZXJ5KGZ1bmN0aW9uKHNlcnZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlLmlzUGhvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcykuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XG4gICAgXG4gICAgLy8vXG4gICAgLy8vIEtlZXBzIHRoZSBwcm9ncmVzcyBzdGVwc0xpc3QgdXBkYXRlZCBkZXBlbmRpbmcgb24gdGhlIGRhdGFcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU3RhcnRpbmcgbGlzdCwgd2l0aCBmaXhlZCBmaXJzdCBzdGVwczpcbiAgICAgICAgdmFyIGxpc3QgPSBbJ3NlcnZpY2VzJ107XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5uZXdEYXRhUmVhZHkoKSkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQaG9uZVNlcnZpY2VPbmx5KCkpXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKCdzZWxlY3RMb2NhdGlvbicpO1xuXG4gICAgICAgICAgICBsaXN0LnB1c2godGhpcy5ib29raW5nLmluc3RhbnRCb29raW5nKCkgPyAnc2VsZWN0VGltZScgOiAnc2VsZWN0VGltZXMnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYm9va2luZy5wYXltZW50RW5hYmxlZCgpKVxuICAgICAgICAgICAgICAgIGxpc3QucHVzaCgncGF5bWVudCcpO1xuXG4gICAgICAgICAgICAvLyBUaGUgZmluYWwgZml4ZWQgc3RlcHNcbiAgICAgICAgICAgIGxpc3QucHVzaCgnY29uZmlybScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgYWxtb3N0IHRoZSBmaXJzdCwgZm9yIGl0cyBsb2FkIHByb2Nlc3MgdG8gd29yaywgZXZlbiBpZiBuZXdEYXRhIGlzIG5vdCByZWFkeSBzdGlsbFxuXG4gICAgICAgIHRoaXMucHJvZ3Jlc3Muc3RlcHNMaXN0KGxpc3QpO1xuICAgIH0sIHRoaXMpLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiAyMCB9IH0pO1xuXG4gICAgLy8vXG4gICAgLy8vIE5ldyBCb29raW5nIGRhdGFcbiAgICB0aGlzLmlzTG9hZGluZ05ld0Jvb2tpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmluaXRCb29raW5nID0gZnVuY3Rpb24oc2VydmljZVByb2Zlc3Npb25hbElELCBqb2JUaXRsZUlELCBib29rQ29kZSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuYm9va0NvZGUoYm9va0NvZGUpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5pc0xvYWRpbmdOZXdCb29raW5nKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgYXBwLm1vZGVsLmJvb2tpbmdzLmdldE5ld0NsaWVudEJvb2tpbmcoe1xuICAgICAgICAgICAgc2VydmljZVByb2Zlc3Npb25hbFVzZXJJRDogc2VydmljZVByb2Zlc3Npb25hbElELFxuICAgICAgICAgICAgam9iVGl0bGVJRDogam9iVGl0bGVJRCxcbiAgICAgICAgICAgIGJvb2tDb2RlOiBib29rQ29kZVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGJvb2tpbmdEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmJvb2tpbmcubW9kZWwudXBkYXRlV2l0aChib29raW5nRGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5ib29raW5nLnBheW1lbnRFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXBtID0gbmV3IElucHV0UGF5bWVudE1ldGhvZCgpO1xuICAgICAgICAgICAgICAgIGlwbS5iaWxsaW5nQWRkcmVzcyhuZXcgQWRkcmVzcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBheW1lbnRNZXRob2QoaXBtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmdOZXdCb29raW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMubmV3RGF0YVJlYWR5KHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXNldCBwcm9ncmVzcyB0byBub25lIGFuZCB0cmlnZ2VyIG5leHQgc28gTG9hZCBsb2dpYyBnZXRzIGV4ZWN1dGVkXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzLnN0ZXAoLTEpO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RlcCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nTmV3Qm9va2luZyhmYWxzZSk7XG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7IGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIC8vL1xuICAgIC8vLyBVSVxuICAgIHRoaXMuYm9va2luZ0hlYWRlciA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmJvb2tpbmcuaW5zdGFudEJvb2tpbmcoKTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHRydWUgPyAnWW91ciBpbnN0YW50IGJvb2tpbmcnIDogdiA9PT0gZmFsc2UgPyAnWW91ciBib29raW5nIHJlcXVlc3QnIDogJyc7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLy9cbiAgICAvLy8gU3RhdGVzXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZ05ld0Jvb2tpbmcoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmdTZXJ2aWNlUHJvZmVzc2lvbmFsSW5mbygpIHx8XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5pc0xvYWRpbmcoKVxuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2FkaW5nKCkgfHwgdGhpcy5pc1NhdmluZygpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8vXG4gICAgLy8vIFNhdmVcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRmluYWwgc3RlcCwgY29uZmlybSBhbmQgc2F2ZSBib29raW5nXG4gICAgICAgIHRoaXMuaXNTYXZpbmcodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBQcmVwYXJlIHRhc2tzIChjYWxsYmFja3MpXG4gICAgICAgIC8vIHNhdmUgcHJvbWlzZTpcbiAgICAgICAgdmFyIHNhdmVJdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb21vdGlvbmFsQ29kZTogdGhpcy5wcm9tb3Rpb25hbENvZGUoKSxcbiAgICAgICAgICAgICAgICBib29rQ29kZTogdGhpcy5ib29rQ29kZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5ib29raW5ncy5yZXF1ZXN0Q2xpZW50Qm9va2luZyh0aGlzLmJvb2tpbmcsIHJlcXVlc3RPcHRpb25zLCB0aGlzLnBheW1lbnRNZXRob2QoKSk7ICAgIFxuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIC8vIHN1Y2Nlc3MgcHJvbWlzZTpcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbihzZXJ2ZXJCb29raW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYm9va2luZy5tb2RlbC51cGRhdGVXaXRoKHNlcnZlckJvb2tpbmcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnRG9uZSEnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdZb3VyIGJvb2tpbmcgd2FzIGNyZWF0ZWQhJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFwcC5zaGVsbC5nbygnLycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgLy8gZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3IoeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gSWYgYW5vbnltb3VzLCBtdXN0IHBhc3MgdGhlIHNpZ251cCwgYW5kIG9ubHkgYWZ0ZXIgc2F2ZSBib29raW5nXG4gICAgICAgIGlmICh0aGlzLmlzQW5vbnltb3VzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbnVwVk0ucGVyZm9ybVNpZ251cCgpXG4gICAgICAgICAgICAudGhlbihzYXZlSXQpXG4gICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgLmNhdGNoKG9uZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2F2ZUl0KClcbiAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXG4gICAgICAgICAgICAuY2F0Y2gob25lcnJvcik7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIFNwZWNpYWwgcmVxdWVzdHMgKGNsaWVudCBub3RlcyB0byBzZXJ2aWNlIHByb2Zlc3Npb25hbClcbiAgICB0aGlzLnNwZWNpYWxSZXF1ZXN0c1BsYWNlaG9sZGVyID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3AgPSB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxJbmZvKCk7XG4gICAgICAgIHNwID0gc3AucHJvZmlsZSgpICYmIHNwLnByb2ZpbGUoKS5maXJzdE5hbWUoKTtcblxuICAgICAgICByZXR1cm4gc3AgPyAnQWRkIG5vdGVzIHRvICcgKyBzcCA6ICdBZGQgbm90ZXMnO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMucGlja1NwZWNpYWxSZXF1ZXN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAubW9kYWxzLnNob3dUZXh0RWRpdG9yKHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnNwZWNpYWxSZXF1ZXN0c1BsYWNlaG9sZGVyKCksXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLmJvb2tpbmcuc3BlY2lhbFJlcXVlc3RzKClcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgdGhpcy5ib29raW5nLnNwZWNpYWxSZXF1ZXN0cyh0ZXh0KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3IoeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gZXJyb3IsIGRvIG5vdGhpbmcganVzdCB3YXMgZGlzbWlzc2VkXG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICAvLy9cbiAgICAvLy8gVVJMc1xuICAgIHRoaXMudXJsVG9zID0ga28ub2JzZXJ2YWJsZSgnaHR0cHM6Ly9sb2Nvbm9taWNzLmNvbS9lbi1VUy9BYm91dC9UZXJtc09mVXNlLycpO1xuICAgIHRoaXMudXJsUHAgPSBrby5vYnNlcnZhYmxlKCdodHRwczovL2xvY29ub21pY3MuY29tL2VuLVVTL0Fib3V0L1ByaXZhY3lQb2xpY3kvJyk7XG4gICAgdGhpcy51cmxCY3AgPSBrby5vYnNlcnZhYmxlKCdodHRwczovL2xvY29ub21pY3MuY29tL2VuLVVTL0Fib3V0L0JhY2tncm91bmRDaGVja1BvbGljeS8nKTtcbiAgICB0aGlzLnVybENwID0ga28ub2JzZXJ2YWJsZSgnaHR0cHM6Ly9sb2Nvbm9taWNzLmNvbS9lbi1VUy9BYm91dC9DYW5jZWxsYXRpb25Qb2xpY3kvJyk7XG4gICAgXG4gICAgXG4gICAgdGhpcy5nb0xvZ2luID0gZnVuY3Rpb24oZCwgZSkge1xuICAgICAgICBhcHAuc2hlbGwuZ28oJy9sb2dpbicsIHsgcmVkaXJlY3RVcmw6IGFwcC5zaGVsbC5jdXJyZW50Um91dGUudXJsIH0pO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIFByaWNpbmdTdW1tYXJ5Vk0odmFsdWVzKSB7XG5cbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWUsXG4gICAgICAgICAgICBNb2RlbDogUHJpY2luZ1N1bW1hcnlEZXRhaWxcbiAgICAgICAgfSxcbiAgICAgICAgZ3JhdHVpdHlQZXJjZW50YWdlOiAwLFxuICAgICAgICBncmF0dWl0eUFtb3VudDogMCxcbiAgICAgICAgZmVlc1BlcmNlbnRhZ2U6IDEwXG4gICAgfSwgdmFsdWVzKTtcblxuICAgIHRoaXMuc3VidG90YWxQcmljZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlscygpLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgaXRlbSkge1xuICAgICAgICAgICAgdG90YWwgKz0gaXRlbS5wcmljZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9LCAwKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmZlZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5zdWJ0b3RhbFByaWNlKCksXG4gICAgICAgICAgICBmID0gdGhpcy5mZWVzUGVyY2VudGFnZSgpO1xuICAgICAgICByZXR1cm4gdCAqIChmIC8gMTAwKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmdyYXR1aXR5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGVyY2VudGFnZSA9IHRoaXMuZ3JhdHVpdHlQZXJjZW50YWdlKCkgfDAsXG4gICAgICAgICAgICBhbW91bnQgPSB0aGlzLmdyYXR1aXR5QW1vdW50KCkgfDA7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwZXJjZW50YWdlID4gMCA/XG4gICAgICAgICAgICAgICAgKHRoaXMuc3VidG90YWxQcmljZSgpICogKHBlcmNlbnRhZ2UgLyAxMDApKSA6XG4gICAgICAgICAgICAgICAgYW1vdW50IDwgMCA/IDAgOiBhbW91bnRcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMudG90YWxQcmljZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidG90YWxQcmljZSgpICsgdGhpcy5mZWVzKCkgKyB0aGlzLmdyYXR1aXR5KCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5mZWVzTWVzc2FnZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYgPSBudW1lcmFsKHRoaXMuZmVlcygpKS5mb3JtYXQoJyQjLCMjMC4wMCcpO1xuICAgICAgICByZXR1cm4gJyppbmNsdWRlcyBhIF9fZmVlc19fIGZpcnN0LXRpbWUgYm9va2luZyBmZWUnLnJlcGxhY2UoL19fZmVlc19fL2csIGYpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5pdGVtcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmRldGFpbHMoKS5zbGljZSgpO1xuICAgICAgICB2YXIgZ3JhdHVpdHkgPSB0aGlzLmdyYXR1aXR5KCk7XG5cbiAgICAgICAgaWYgKGdyYXR1aXR5ID4gMCkge1xuICAgICAgICAgICAgdmFyIGdyYXR1aXR5TGFiZWwgPSB0aGlzLmdyYXR1aXR5UGVyY2VudGFnZSgpID9cbiAgICAgICAgICAgICAgICAnR3JhdHVpdHkgKF9fZ3JhdHVpdHlfXyUpJy5yZXBsYWNlKC9fX2dyYXR1aXR5X18vZywgKHRoaXMuZ3JhdHVpdHlQZXJjZW50YWdlKCkgfDApKSA6XG4gICAgICAgICAgICAgICAgJ0dyYXR1aXR5JztcblxuICAgICAgICAgICAgaXRlbXMucHVzaChuZXcgUHJpY2luZ1N1bW1hcnlEZXRhaWwoe1xuICAgICAgICAgICAgICAgIHNlcnZpY2VOYW1lOiBncmF0dWl0eUxhYmVsLFxuICAgICAgICAgICAgICAgIHByaWNlOiB0aGlzLmdyYXR1aXR5KClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHMoKS5yZWR1Y2UoZnVuY3Rpb24odG90YWwsIGl0ZW0pIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGl0ZW0uc2VydmljZUR1cmF0aW9uTWludXRlcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9LCAwKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmZpcnN0U2Vzc2lvbkR1cmF0aW9uTWludXRlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlscygpLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgaXRlbSkge1xuICAgICAgICAgICAgdG90YWwgKz0gaXRlbS5maXJzdFNlc3Npb25EdXJhdGlvbk1pbnV0ZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfSwgMCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdmFyIGR1cmF0aW9uMkxhbmd1YWdlID0gcmVxdWlyZSgnLi4vdXRpbHMvZHVyYXRpb24yTGFuZ3VhZ2UnKTtcbiAgICBcbiAgICB0aGlzLnNlcnZpY2VEdXJhdGlvbkRpc3BsYXkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjJMYW5ndWFnZSh7IG1pbnV0ZXM6IHRoaXMuc2VydmljZUR1cmF0aW9uTWludXRlcygpIH0pO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZmlyc3RTZXNzaW9uRHVyYXRpb25EaXNwbGF5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb24yTGFuZ3VhZ2UoeyBtaW51dGVzOiB0aGlzLmZpcnN0U2Vzc2lvbkR1cmF0aW9uTWludXRlcygpIH0pO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMudG9QcmljaW5nU3VtbWFyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGxhaW4gPSB0aGlzLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XG4gICAgICAgIHBsYWluLnN1YnRvdGFsUHJpY2UgPSB0aGlzLnN1YnRvdGFsUHJpY2UoKTtcbiAgICAgICAgcGxhaW4uZmVlUHJpY2UgPSB0aGlzLmZlZXMoKTtcbiAgICAgICAgcGxhaW4udG90YWxQcmljZSA9IHRoaXMudG90YWxQcmljZSgpO1xuICAgICAgICBwbGFpbi5zZXJ2aWNlRHVyYXRpb25NaW51dGVzID0gdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKCk7XG4gICAgICAgIHBsYWluLmZpcnN0U2Vzc2lvbkR1cmF0aW9uTWludXRlcyA9IHRoaXMuZmlyc3RTZXNzaW9uRHVyYXRpb25NaW51dGVzKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJpY2luZ1N1bW1hcnkocGxhaW4pO1xuICAgIH07XG59XG4iLCIvKiogQ2FsZW5kYXIgYWN0aXZpdHkgKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIGdldERhdGVXaXRob3V0VGltZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldERhdGVXaXRob3V0VGltZScpO1xuXG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL0RhdGVQaWNrZXInKTtcbnZhciBkYXRlcGlja2VyQXZhaWxhYmlsaXR5ID0gcmVxdWlyZSgnLi4vdXRpbHMvZGF0ZXBpY2tlckF2YWlsYWJpbGl0eScpO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBDYWxlbmRhckFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignQ2FsZW5kYXInKTtcblxuICAgIC8qIEdldHRpbmcgZWxlbWVudHMgKi9cbiAgICB0aGlzLiRkYXRlcGlja2VyID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2NhbGVuZGFyRGF0ZVBpY2tlcicpO1xuICAgIHRoaXMuJGRhaWx5VmlldyA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjYWxlbmRhckRhaWx5VmlldycpO1xuICAgIHRoaXMuJGRhdGVUaXRsZSA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJy5DYWxlbmRhckRhdGVIZWFkZXIgPiAuYnRuJyk7XG4gICAgdGhpcy4kY2hvb3NlTmV3ID0gJCgnI2NhbGVuZGFyQ2hvb3NlTmV3Jyk7XG4gICAgXG4gICAgLyogSW5pdCBjb21wb25lbnRzICovXG4gICAgdGhpcy4kZGF0ZXBpY2tlci5zaG93KCkuZGF0ZXBpY2tlcih7IGV4dHJhQ2xhc3NlczogJ0RhdGVQaWNrZXItLXRhZ2dlZCcgfSk7XG4gICAgXG4gICAgdGhpcy50YWdBdmFpbGFiaWxpdHkgPSBkYXRlcGlja2VyQXZhaWxhYmlsaXR5LmNyZWF0ZSh0aGlzLmFwcCwgdGhpcy4kZGF0ZXBpY2tlciwgdGhpcy52aWV3TW9kZWwuaXNMb2FkaW5nKTtcblxuICAgIC8qIEV2ZW50IGhhbmRsZXJzICovXG4gICAgLy8gQ2hhbmdlcyBvbiBjdXJyZW50RGF0ZVxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5jdXJyZW50RGF0ZSxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZGF0ZSkge1xuXG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZGF0ZSA9IG1vbWVudChkYXRlKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZGF0ZS5pc1ZhbGlkKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNvRGF0ZSA9IG1kYXRlLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGRhdGVwaWNrZXIgc2VsZWN0ZWQgZGF0ZSBvbiBkYXRlIGNoYW5nZSAoZnJvbSBcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgc291cmNlIHRoYW4gdGhlIGRhdGVwaWNrZXIgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIG5vdCBmcm9tIHRoZSB3aWRnZXQ/XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRkYXRlcGlja2VyLmRhdGVwaWNrZXIoJ2dldFZhbHVlJykudG9JU09TdHJpbmcoKSAhPT0gaXNvRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignc2V0VmFsdWUnLCBkYXRlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbiBjdXJyZW50RGF0ZSBjaGFuZ2VzLCB1cGRhdGUgdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzYXZlIGEgdXNlZnVsIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIERPVUJUOiBwdXNoIG9yIHJlcGxhY2Ugc3RhdGU/IChtb3JlIGhpc3RvcnkgZW50cmllcyBvciB0aGUgc2FtZT8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLnB1c2hTdGF0ZShudWxsLCBudWxsLCAnY2FsZW5kYXIvJyArIGlzb0RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERPTkVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGZhaWwsIGJhZCBkYXRlIG9yIG5vdCBkYXRlIGF0IGFsbFxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IFxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZ2V0RGF0ZVdpdGhvdXRUaW1lKCkpO1xuXG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgLy8gU3dpcGUgZGF0ZSBvbiBnZXN0dXJlXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGRhaWx5VmlldyxcbiAgICAgICAgZXZlbnQ6ICdzd2lwZWxlZnQgc3dpcGVyaWdodCcsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIGRpciA9IGUudHlwZSA9PT0gJ3N3aXBlbGVmdCcgPyAnbmV4dCcgOiAncHJldic7XG5cbiAgICAgICAgICAgIC8vIEhhY2sgdG8gc29sdmUgdGhlIGZyZWV6eS1zd2lwZSBhbmQgdGFwLWFmdGVyIGJ1ZyBvbiBKUU06XG4gICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKCd0b3VjaGVuZCcpO1xuICAgICAgICAgICAgLy8gQ2hhbmdlIGRhdGVcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignbW92ZVZhbHVlJywgZGlyLCAnZGF0ZScpO1xuXG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgLy8gU2hvd2luZyBkYXRlcGlja2VyIHdoZW4gcHJlc3NpbmcgdGhlIHRpdGxlXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGRhdGVUaXRsZSxcbiAgICAgICAgZXZlbnQ6ICdjbGljaycsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIudG9nZ2xlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRpbmcgdmlldyBkYXRlIHdoZW4gcGlja2VkIGFub3RoZXIgb25lXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGRhdGVwaWNrZXIsXG4gICAgICAgIGV2ZW50OiAnZGF0ZUNoYW5nZWQnLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS52aWV3TW9kZSA9PT0gJ2RheXMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZ2V0RGF0ZVdpdGhvdXRUaW1lKGUuZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcblxuICAgIC8vIFNldCBkYXRlIHRvIHRvZGF5XG4gICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZ2V0RGF0ZVdpdGhvdXRUaW1lKCkpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAvLyBEYXRlIGZyb20gdGhlIHBhcmFtZXRlciwgZmFsbGJhY2sgdG8gdG9kYXlcbiAgICB2YXIgc2RhdGUgPSBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHMgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50c1swXSxcbiAgICAgICAgZGF0ZTtcbiAgICBpZiAoc2RhdGUpIHtcbiAgICAgICAgLy8gUGFyc2luZyBkYXRlIGZyb20gSVNPIGZvcm1hdFxuICAgICAgICB2YXIgbWRhdGUgPSBtb21lbnQoc2RhdGUpO1xuICAgICAgICAvLyBDaGVjayBpcyB2YWxpZCwgYW5kIGVuc3VyZSBpcyBkYXRlIGF0IDEyQU1cbiAgICAgICAgZGF0ZSA9IG1kYXRlLmlzVmFsaWQoKSA/IGdldERhdGVXaXRob3V0VGltZShtZGF0ZS50b0RhdGUoKSkgOiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWRhdGUpXG4gICAgICAgIC8vIFRvZGF5OlxuICAgICAgICBkYXRlID0gZ2V0RGF0ZVdpdGhvdXRUaW1lKCk7XG4gICAgXG4gICAgLy8gUmVzZXQgdG8gZm9yY2UgbmV3IGRhdGEgbG9hZCAoY2FuIGhhcHBlbnMgaWYgc2NoZWR1bGUgd2FzIGNoYW5nZSBvciBhbnl0aGluZyBpbiB0aGUgbWlkZGxlKVxuICAgIHRoaXMudmlld01vZGVsLnByZXZpb3VzRGF0ZSA9IG51bGw7XG4gICAgdGhpcy52aWV3TW9kZWwuY3VycmVudERhdGUoZGF0ZSk7XG4gICAgLy8gRm9yY2UgYSByZWZyZXNoIG9mIHRhZ3NcbiAgICB0aGlzLnRhZ0F2YWlsYWJpbGl0eShkYXRlLCB0aGlzLmFwcC5tb2RlbC51c2VyUHJvZmlsZS5kYXRhLnVzZXJJRCgpLCB0cnVlKTtcbn07XG5cbnZhciBBcHBvaW50bWVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9BcHBvaW50bWVudCcpLFxuICAgIFRpbWVTbG90Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9UaW1lU2xvdCcpO1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmN1cnJlbnREYXRlID0ga28ub2JzZXJ2YWJsZShnZXREYXRlV2l0aG91dFRpbWUoKSk7XG4gICAgdmFyIGZ1bGxEYXlGcmVlID0gW0FwcG9pbnRtZW50Lm5ld0ZyZWVTbG90KHsgZGF0ZTogdGhpcy5jdXJyZW50RGF0ZSgpIH0pXTtcbiAgICAvLyBUaGUgJ2ZyZWUnIGV2ZW50IG11c3QgdXBkYXRlIHdpdGggYW55IGNoYW5nZSBpbiBjdXJyZW50RGF0ZVxuICAgIHRoaXMuY3VycmVudERhdGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgIGZ1bGxEYXlGcmVlWzBdLnN0YXJ0VGltZShkYXRlKTtcbiAgICAgICAgICAgIGZ1bGxEYXlGcmVlWzBdLmVuZFRpbWUoZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHNsb3RzU291cmNlIHNhdmUgdGhlIGRhdGEgYXMgcHJvY2Vzc2VkIGJ5IGEgcmVxdWVzdCBvZiBcbiAgICAvLyBkYXRhIGJlY2F1c2UgYSBkYXRlIGNoYW5nZS5cbiAgICAvLyBJdCdzIHVwZGF0ZWQgYnkgY2hhbmdlcyBvbiBjdXJyZW50RGF0ZSB0aGF0IHBlcmZvcm1zIHRoZSByZW1vdGUgbG9hZGluZ1xuICAgIHRoaXMuc2xvdHNTb3VyY2UgPSBrby5vYnNlcnZhYmxlKGZ1bGxEYXlGcmVlKTtcbiAgICAvLyBzbG90cyBjb21wdXRlZCwgdXNpbmcgc2xvdHNTb3VyY2UuXG4gICAgLy8gQXMgY29tcHV0ZWQgaW4gb3JkZXIgdG8gYWxsb3cgYW55IG90aGVyIG9ic2VydmFibGUgY2hhbmdlXG4gICAgLy8gZnJvbSB0cmlnZ2VyIHRoZSBjcmVhdGlvbiBvZiBhIG5ldyB2YWx1ZVxuICAgIHRoaXMuc2xvdHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90c1NvdXJjZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gSGlkZSB1bmF2YWlsYWJsZSBzbG90cywgZXhjZXB0IGlmIHRoZXJlIGlzIG9ubHkgb25lIHNsb3QgKHNvIHRoZXJlXG4gICAgICAgIC8vIGlzIGV2ZXIgc29tZXRoaW5nIGRpc3BsYXllZClcbiAgICAgICAgaWYgKHNsb3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHNsb3RzID0gc2xvdHMuZmlsdGVyKGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xvdC5pZCgpICE9PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLnVuYXZhaWxhYmxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzbG90cy5tYXAoVGltZVNsb3RWaWV3TW9kZWwuZnJvbUFwcG9pbnRtZW50KTtcblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cbiAgICAvLyBVcGRhdGUgY3VycmVudCBzbG90cyBvbiBkYXRlIGNoYW5nZVxuICAgIC8vIHByZXZpb3VzRGF0ZSBpcyBwdWJsaWMgdG8gYWxsb3cgYmVpbmcgcmVzZXQgb24gYSBuZXcgc2hvdyAoZGlzY2FyZCBvbGQgZGF0YVxuICAgIC8vIGJ5IGZvcmNpbmcgYSBsb2FkKVxuICAgIHRoaXMucHJldmlvdXNEYXRlID0gdGhpcy5jdXJyZW50RGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgdGhpcy5jdXJyZW50RGF0ZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGRhdGUpIHtcblxuICAgICAgICAvLyBJTVBPUlRBTlQ6IFRoZSBkYXRlIG9iamVjdCBtYXkgYmUgcmV1c2VkIGFuZCBtdXRhdGVkIGJldHdlZW4gY2FsbHNcbiAgICAgICAgLy8gKG1vc3RseSBiZWNhdXNlIHRoZSB3aWRnZXQgSSB0aGluayksIHNvIGlzIGJldHRlciB0byBjcmVhdGVcbiAgICAgICAgLy8gYSBjbG9uZSBhbmQgYXZvaWQgZ2V0dGluZyByYWNlLWNvbmRpdGlvbnMgaW4gdGhlIGRhdGEgZG93bmxvYWRpbmcuXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKGRhdGUudG9JU09TdHJpbmcoKSkpO1xuXG4gICAgICAgIC8vIEF2b2lkIGR1cGxpY2F0ZWQgbm90aWZpY2F0aW9uLCB1bi1jaGFuZ2VkIGRhdGVcbiAgICAgICAgaWYgKGRhdGUudG9JU09TdHJpbmcoKSA9PT0gdGhpcy5wcmV2aW91c0RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZpb3VzRGF0ZSA9IGRhdGUudG9JU09TdHJpbmcoKTtcblxuICAgICAgICB0aGlzLmlzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGFwcC5tb2RlbC5jYWxlbmRhci5nZXREYXRlQXZhaWxhYmlsaXR5KGRhdGUpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGVBdmFpbCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IEZpcnN0LCB3ZSBuZWVkIHRvIGNoZWNrIHRoYXQgd2UgYXJlXG4gICAgICAgICAgICAvLyBpbiB0aGUgc2FtZSBkYXRlIHN0aWxsLCBiZWNhdXNlIHNldmVyYWwgbG9hZGluZ3NcbiAgICAgICAgICAgIC8vIGNhbiBoYXBwZW4gYXQgYSB0aW1lIChjaGFuZ2luZyBxdWlja2x5IGZyb20gZGF0ZSB0byBkYXRlXG4gICAgICAgICAgICAvLyB3aXRob3V0IHdhaXQgZm9yIGZpbmlzaCksIGF2b2lkaW5nIGEgcmFjZS1jb25kaXRpb25cbiAgICAgICAgICAgIC8vIHRoYXQgY3JlYXRlIGZsaWNrZXJpbmcgZWZmZWN0cyBvciByZXBsYWNlIHRoZSBkYXRlIGV2ZW50c1xuICAgICAgICAgICAgLy8gYnkgdGhlIGV2ZW50cyBmcm9tIG90aGVyIGRhdGUsIGJlY2F1c2UgaXQgdG9va3MgbW9yZSBhbiBjaGFuZ2VkLlxuICAgICAgICAgICAgLy8gVE9ETzogc3RpbGwgdGhpcyBoYXMgdGhlIG1pbm9yIGJ1ZyBvZiBsb3NpbmcgdGhlIGlzTG9hZGluZ1xuICAgICAgICAgICAgLy8gaWYgYSBwcmV2aW91cyB0cmlnZ2VyZWQgbG9hZCBzdGlsbCBkaWRuJ3QgZmluaXNoZWQ7IGl0cyBtaW5vclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpcyB2ZXJ5IHJhcmUgdGhhdCBoYXBwZW5zLCBtb3ZpbmcgdGhpcyBzdHVmZlxuICAgICAgICAgICAgLy8gdG8gYSBzcGVjaWFsIGFwcE1vZGVsIGZvciBtaXhlZCBib29raW5ncyBhbmQgZXZlbnRzIHdpdGggXG4gICAgICAgICAgICAvLyBwZXIgZGF0ZSBjYWNoZSB0aGF0IGluY2x1ZGVzIGEgdmlldyBvYmplY3Qgd2l0aCBpc0xvYWRpbmcgd2lsbFxuICAgICAgICAgICAgLy8gZml4IGl0IGFuZCByZWR1Y2UgdGhpcyBjb21wbGV4aXR5LlxuICAgICAgICAgICAgaWYgKGRhdGUudG9JU09TdHJpbmcoKSAhPT0gdGhpcy5jdXJyZW50RGF0ZSgpLnRvSVNPU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSYWNlIGNvbmRpdGlvbiwgbm90IHRoZSBzYW1lISEgb3V0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNvdXJjZTpcbiAgICAgICAgICAgIHRoaXMuc2xvdHNTb3VyY2UoZGF0ZUF2YWlsLmxpc3QoKSk7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3cgZnJlZSBvbiBlcnJvclxuICAgICAgICAgICAgdGhpcy5zbG90c1NvdXJjZShmdWxsRGF5RnJlZSk7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBtc2cgPSAnRXJyb3IgbG9hZGluZyBjYWxlbmRhciBldmVudHMuJztcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLmVycm9yIHx8IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIH0uYmluZCh0aGlzKSk7XG59XG4iLCIvKipcbiAgICBDYWxlbmRhclN5bmNpbmcgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIENhbGVuZGFyU3luY2luZ0FjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDtcblxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycsIHtcbiAgICAgICAgYmFja0xpbms6ICdzY2hlZHVsaW5nJ1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEFkZGluZyBhdXRvLXNlbGVjdCBiZWhhdmlvciB0byB0aGUgZXhwb3J0IFVSTFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRhY3Rpdml0eS5maW5kKCcjY2FsZW5kYXJTeW5jLWljYWxFeHBvcnRVcmwnKSxcbiAgICAgICAgZXZlbnQ6ICdjbGljaycsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5jYWxlbmRhclN5bmNpbmcsXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBlcnIudGFzayA9PT0gJ3NhdmUnID8gJ0Vycm9yIHNhdmluZyBjYWxlbmRhciBzeW5jaW5nIHNldHRpbmdzLicgOiAnRXJyb3IgbG9hZGluZyBjYWxlbmRhciBzeW5jaW5nIHNldHRpbmdzLic7XG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLnRhc2sgJiYgZXJyLmVycm9yIHx8IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICBcbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcbiAgICB0aGlzLmFwcC5tb2RlbC5jYWxlbmRhclN5bmNpbmcuc3luYygpO1xuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxuICAgIHRoaXMudmlld01vZGVsLmRpc2NhcmQoKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcblxuICAgIHZhciBjYWxlbmRhclN5bmNpbmcgPSBhcHAubW9kZWwuY2FsZW5kYXJTeW5jaW5nO1xuXG4gICAgdmFyIHN5bmNWZXJzaW9uID0gY2FsZW5kYXJTeW5jaW5nLm5ld1ZlcnNpb24oKTtcbiAgICBzeW5jVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XG4gICAgICAgIGlmIChpdElzKSB7XG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXG4gICAgICAgICAgICAvLyBjb25maXJtYXRpb24gdG8gbG9hZCB0aGVtIG9yIGRpc2NhcmQgYW5kIG92ZXJ3cml0ZSB0aGVtO1xuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgdmVyc2lvbikuXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcbiAgICAgICAgICAgIHN5bmNWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEFjdHVhbCBkYXRhIGZvciB0aGUgZm9ybTpcbiAgICB0aGlzLnN5bmMgPSBzeW5jVmVyc2lvbi52ZXJzaW9uO1xuXG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2NrZWQoKSB8fCB0aGlzLmlzUmVzZXRpbmcoKTtcbiAgICB9LCBjYWxlbmRhclN5bmNpbmcpO1xuXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxuICAgICAgICAgICAgICAgICdsb2FkaW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxuICAgICAgICAgICAgICAgICAgICAnc2F2aW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgICAgICAnU2F2ZSdcbiAgICAgICAgKTtcbiAgICB9LCBjYWxlbmRhclN5bmNpbmcpO1xuICAgIFxuICAgIHRoaXMucmVzZXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc1Jlc2V0aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAncmVzZXRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgJ1Jlc2V0IFByaXZhdGUgVVJMJ1xuICAgICAgICApO1xuICAgIH0sIGNhbGVuZGFyU3luY2luZyk7XG4gICAgXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcbiAgICAgICAgc3luY1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgICBzeW5jVmVyc2lvbi5wdXNoU2F2ZSgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXBwLnN1Y2Nlc3NTYXZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yLCBtYW5hZ2VkIG9uIGV2ZW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBjYWxlbmRhclN5bmNpbmcucmVzZXRFeHBvcnRVcmwoKTtcbiAgICB9O1xufVxuIiwiLyoqXG4gICAgQ2FuY2VsbGF0aW9uIFBvbGljeSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBDYW5jZWxsYXRpb25Qb2xpY3lBY3Rpdml0eSgpIHtcblxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignSm9iIFRpdGxlJyk7XG4gICAgXG4gICAgLy8gT24gY2hhbmdpbmcgam9iVGl0bGVJRDpcbiAgICAvLyAtIGxvYWQgYWRkcmVzc2VzXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcbiAgICAgICAgICAgIGlmIChqb2JUaXRsZUlEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwudXNlckpvYlByb2ZpbGUuZ2V0VXNlckpvYlRpdGxlKGpvYlRpdGxlSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odXNlckpvYlRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgZm9yIHVzZSBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC51c2VySm9iVGl0bGUodXNlckpvYlRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRDYW5jZWxsYXRpb25Qb2xpY3lJRCh1c2VySm9iVGl0bGUuY2FuY2VsbGF0aW9uUG9saWN5SUQoKSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwudXNlckpvYlRpdGxlKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnNlbGVjdGVkQ2FuY2VsbGF0aW9uUG9saWN5SUQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcbiAgICAvLyBSZXNldFxuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQobnVsbCk7XG4gICAgdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRDYW5jZWxsYXRpb25Qb2xpY3lJRChudWxsKTtcbiAgICBcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcblxuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cztcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKHBhcmFtc1swXSB8MCk7XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMudXNlckpvYlRpdGxlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICAvLyBMb2NhbCBjb3B5IG9mIHRoZSBjYW5jZWxsYXRpb25Qb2xpY3lJRCwgcmF0aGVyIHRoYW4gdXNlXG4gICAgLy8gaXQgZGlyZWN0bHkgZnJvbSB0aGUgdXNlckpvYlRpdGxlIHRvIGF2b2lkIHRoYXQgZ2V0cyBzYXZlZFxuICAgIC8vIGluIG1lbW9yeSB3aXRob3V0IHByZXNzICdzYXZlJ1xuICAgIHRoaXMuc2VsZWN0ZWRDYW5jZWxsYXRpb25Qb2xpY3lJRCA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmlzU2F2aW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2FkaW5nKCkgfHwgdGhpcy5pc1NhdmluZygpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnbG9hZGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1anQgPSB0aGlzLnVzZXJKb2JUaXRsZSgpO1xuICAgICAgICBpZiAodWp0KSB7XG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcGxhaW4gPSB1anQubW9kZWwudG9QbGFpbk9iamVjdCgpO1xuICAgICAgICAgICAgcGxhaW4uY2FuY2VsbGF0aW9uUG9saWN5SUQgPSB0aGlzLnNlbGVjdGVkQ2FuY2VsbGF0aW9uUG9saWN5SUQoKTtcblxuICAgICAgICAgICAgYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLnNldFVzZXJKb2JUaXRsZShwbGFpbilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHsgdGl0bGU6ICdFcnJvciBzYXZpbmcgQ2FuY2VsbGF0aW9uIFBvbGljeSBwcmVmZXJlbmNlJywgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnBvbGljaWVzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtcbiAgICAgICAgbmV3IENhbmNlbGxhdGlvblBvbGljeSh7XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25Qb2xpY3lJRDogMSxcbiAgICAgICAgICAgIG5hbWU6ICdTdHJpY3QnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICc1MCUgcmVmdW5kIHVwIHRvIDUgZGF5cyBiZWZvcmUgYm9va2luZywgZXhjZXB0IGZlZXMnLFxuICAgICAgICAgICAgaG91cnNSZXF1aXJlZDogMTIwLFxuICAgICAgICAgICAgcmVmdW5kSWZDYW5jZWxsZWRCZWZvcmU6IDAuNVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IENhbmNlbGxhdGlvblBvbGljeSh7XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25Qb2xpY3lJRDogMixcbiAgICAgICAgICAgIG5hbWU6ICdNb2RlcmF0ZScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJzEwMCUgcmVmdW5kIHVwIHRvIDI0IGhvdXJzIGJlZm9yZSBib29raW5nLCBleGNlcHQgZmVlcy4gIE5vIHJlZnVuZCBmb3IgdW5kZXIgMjQgaG91cnMgYW5kIG5vLXNob3dzLicsXG4gICAgICAgICAgICBob3Vyc1JlcXVpcmVkOiAyNCxcbiAgICAgICAgICAgIHJlZnVuZElmQ2FuY2VsbGVkQmVmb3JlOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgQ2FuY2VsbGF0aW9uUG9saWN5KHtcbiAgICAgICAgICAgIGNhbmNlbGxhdGlvblBvbGljeUlEOiAzLFxuICAgICAgICAgICAgbmFtZTogJ0ZsZXhpYmxlJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnMTAwJSByZWZ1bmQgdXAgdG8gMjQgaG91cnMgYmVmb3JlIGJvb2tpbmcsIGV4Y2VwdCBmZWVzLiAgNTAlIHJlZnVuZCBmb3IgdW5kZXIgMjQgaG91cnMgYW5kIG5vLXNob3dzLicsXG4gICAgICAgICAgICBob3Vyc1JlcXVpcmVkOiAyNCxcbiAgICAgICAgICAgIHJlZnVuZElmQ2FuY2VsbGVkQmVmb3JlOiAxXG4gICAgICAgIH0pXG4gICAgXSk7XG59XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpO1xuXG52YXIgb2JzZXJ2YWJsZVRpbWUgPSBrby5vYnNlcnZhYmxlKG5ldyBEYXRlKCkpO1xuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgb2JzZXJ2YWJsZVRpbWUobmV3IERhdGUoKSk7XG59LCAxICogNjAgKiAxMDAwKTtcblxuZnVuY3Rpb24gQ2FuY2VsbGF0aW9uUG9saWN5KHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGNhbmNlbGxhdGlvblBvbGljeUlEOiAwLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICcnLFxuICAgICAgICBob3Vyc1JlcXVpcmVkOiAwLFxuICAgICAgICByZWZ1bmRJZkNhbmNlbGxlZEJlZm9yZTogMFxuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgdGhpcy5yZWZ1bmRJZkNhbmNlbGxlZEJlZm9yZURpc3BsYXkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucmVmdW5kSWZDYW5jZWxsZWRCZWZvcmUoKSAqIDEwMCkgKyAnJSc7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnJlZnVuZExpbWl0RGF0ZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZCA9IG1vbWVudChvYnNlcnZhYmxlVGltZSgpKS5jbG9uZSgpO1xuICAgICAgICBkXG4gICAgICAgIC5hZGQoNywgJ2RheXMnKVxuICAgICAgICAuc3VidHJhY3QodGhpcy5ob3Vyc1JlcXVpcmVkKCksICdob3VycycpO1xuICAgICAgICByZXR1cm4gZC50b0RhdGUoKTtcbiAgICB9LCB0aGlzKTtcbn1cbiIsIi8qKlxuICAgIENsaWVudEVkaXRpb24gYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIgaXMgPSByZXF1aXJlKCdpc19qcycpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ2xpZW50RWRpdGlvbkFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICBcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ2NsaWVudHMnLCB7XG4gICAgICAgIGJhY2tMaW5rOiAnY2xpZW50cydcbiAgICB9KTtcbiAgICBcbiAgICAvLyBJZiB0aGVyZSBpcyBhIGNoYW5nZSBvbiB0aGUgY2xpZW50SUQsIHRoZSB1cGRhdGVzIG11c3QgbWF0Y2hcbiAgICAvLyB0aGF0IChpZiBpcyBub3QgYWxyZWFkeSB0aGF0KVxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5jbGllbnRJRCxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGNsaWVudElEKSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudElEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGZvdW5kID0gL2NsaWVudEVkaXRvclxcLyhcXC0/XFxkKykvaS5leGVjKHdpbmRvdy5sb2NhdGlvbiksXG4gICAgICAgICAgICAgICAgdXJsSUQgPSBmb3VuZCAmJiBmb3VuZFsxXSB8MDtcblxuICAgICAgICAgICAgLy8gSWYgaXMgZGlmZmVyZW50IFVSTCBhbmQgY3VycmVudCBJRFxuICAgICAgICAgICAgaWYgKCFmb3VuZCB8fFxuICAgICAgICAgICAgICAgIHVybElEICE9PSBjbGllbnRJRCkge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgVVJMXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsICdjbGllbnRFZGl0b3IvJyArIGNsaWVudElEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU3BlY2lhbCB0cmVhdG1lbnQgb2YgdGhlIHNhdmUgb3BlcmF0aW9uXG4gICAgdGhpcy52aWV3TW9kZWwub25TYXZlID0gZnVuY3Rpb24oY2xpZW50SUQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEucmV0dXJuTmV3QXNTZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gR28gdG8gcHJldmlvdXMgYWN0aXZpdHkgdGhhdCByZXF1aXJlZFxuICAgICAgICAgICAgLy8gdG8gc2VsZWN0IGEgY2xpZW50XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3REYXRhLmNsaWVudElEID0gY2xpZW50SUQ7XG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWd1bGFyIHNhdmVcbiAgICAgICAgICAgIHRoaXMuYXBwLnN1Y2Nlc3NTYXZlKCk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xuXG4gICAgdmFyIHJlZmVycmVyID0gdGhpcy5hcHAuc2hlbGwucmVmZXJyZXJSb3V0ZTtcbiAgICByZWZlcnJlciA9IHJlZmVycmVyICYmIHJlZmVycmVyLnVybCB8fCAnL2NsaWVudHMnO1xuICAgIHZhciBsaW5rID0gdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rIHx8IHJlZmVycmVyO1xuICAgIFxuICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgbGluayk7XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDgqL1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIHJlc2V0XG4gICAgdGhpcy52aWV3TW9kZWwuY2xpZW50SUQoMCk7XG4gICAgXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xuXG4gICAgLy8gcGFyYW1zXG4gICAgdmFyIHBhcmFtcyA9IHN0YXRlICYmIHN0YXRlLnJvdXRlICYmIHN0YXRlLnJvdXRlLnNlZ21lbnRzIHx8IFtdO1xuICAgIFxuICAgIHZhciBjbGllbnRJRCA9IHBhcmFtc1swXSB8MDtcbiAgICBcbiAgICBpZiAoY2xpZW50SUQpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY2xpZW50SUQoY2xpZW50SUQpO1xuICAgICAgICBcbiAgICAgICAgLyp0aGlzLnZpZXdNb2RlbC5jbGllbnQuc3luYyhjbGllbnRJRClcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgbG9hZGluZyBjbGllbnQgZGF0YScsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7Ki9cblxuICAgICAgICB0aGlzLmFwcC5tb2RlbC5jbGllbnRzLmNyZWF0ZUl0ZW1WZXJzaW9uKGNsaWVudElEKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoY2xpZW50VmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKGNsaWVudFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRWZXJzaW9uKGNsaWVudFZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlcignRWRpdCBDbGllbnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY2xpZW50VmVyc2lvbihudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXIoJ1Vua25vdyBjbGllbnQgb3Igd2FzIGRlbGV0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIGNsaWVudCBkYXRhJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayByZXF1ZXN0IHBhcmFtZXRlcnMgdGhhdCBhbGxvdyBwcmVzZXQgY2xpZW50IGluZm9ybWF0aW9uXG4gICAgICAgIC8vICh1c2VkIHdoZW4gdGhlIGNsaWVudCBpcyBjcmVhdGVkIGJhc2VkIG9uIGFuIGV4aXN0ZW50IG1hcmtldHBsYWNlIHVzZXIpXG4gICAgICAgIHZhciBwcmVzZXREYXRhID0gdGhpcy5yZXF1ZXN0RGF0YS5wcmVzZXREYXRhIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3Qgc2V0IGFuIGV4cGxpY2l0ICdmYWxzZScgdmFsdWUgb24gZWRpdGFibGVcbiAgICAgICAgLy8gZmllbGQgKGFzIHdoZW4gdGhlcmUgaXMgbm90IGRhdGEgZ2l2ZW4pLCBzZXQgdG8gdHJ1ZSBzbyBjYW4gYmUgZWRpdGVkXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYmVjYXVzZSBhIGdpdmVuIG1hcmtldHBsYWNlIHVzZXIgd2lsbCBjb21lIHdpdGggZWRpdGFibGU6ZmFsc2VcbiAgICAgICAgLy8gYW5kIG5lZWQgdG8gYmUgcHJlc2VydmVkLCB3aGlsZSBvbiByZWd1bGFyICduZXcgY2xpZW50JyBhbGwgZGF0YSBpcyBzZXQgYnkgXG4gICAgICAgIC8vIHRoZSBzZXJ2aWNlIHByb2Zlc3Npb25hbC5cbiAgICAgICAgaWYgKHByZXNldERhdGEuZWRpdGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcmVzZXREYXRhLmVkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qdGhpcy52aWV3TW9kZWwuY2xpZW50Lm5ld0l0ZW0ocHJlc2V0RGF0YSk7Ki9cbiAgICAgICAgLy8gTmV3IGNsaWVudFxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5jbGllbnRWZXJzaW9uKHRoaXMuYXBwLm1vZGVsLmNsaWVudHMubmV3SXRlbShwcmVzZXREYXRhKSk7XG4gICAgICAgIHRoaXMudmlld01vZGVsLmhlYWRlcignQWRkIGEgQ2xpZW50Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBFeHRyYSBwcmVzZXQgZGF0YVxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5uZXdGb3JTZWFyY2hUZXh0KSB7XG4gICAgICAgICAgICBjbGllbnREYXRhRnJvbVNlYXJjaFRleHQodGhpcy5yZXF1ZXN0RGF0YS5uZXdGb3JTZWFyY2hUZXh0IHx8ICcnLCB0aGlzLnZpZXdNb2RlbC5jbGllbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAgICBTbWFsbCB1dGlsaXR5IHRoYXQganVzdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gICAgc3RyaW5nIHNlZW1zIGEgcG9zc2libGUgcGhvbmUgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgTk9URTogSXMgTk9UIGFuIGV4YXVzdGl2ZSBwaG9uZSB2YWxpZGF0aW9uIGNoZWNrLCBqdXN0XG4gICAgY2hlY2tzIGlzIHRoZXJlIGFyZSBzZXZlcmFsIG51bWJlcnMgc28gdGhlcmUgaXMgYSBjaGFuY2VcbiAgICB0byBiZSBhIHBob25lLiBUaGVyZSBhcmUgc3RyaWNrZXIgY2hlY2tzIChhbm5vdGF0ZWQpIGJ1dFxuICAgIGNhbiBmYWlsIG9uIHNvbWUgc2l0dWF0aW9ucyAoc3dpdGNoYm9hcmQgbnVtYmVycykgb3IgaW5cbiAgICBkaWZmZXJlbnQgbG9jYWxlcy5cbioqL1xuZnVuY3Rpb24gc2VlbXNBUGhvbmVOdW1iZXIoc3RyKSB7XG4gICAgLy8gUG9zc2libGUgc3RyaWNrZXIgY29tcGFyaXNpb25cbiAgICAvLyByZXR1cm4gaXMubmFucFBob25lKHN0cikgfHwgaXMuZXBwUGhvbmUoc3RyKTtcbiAgICBcbiAgICAvLyBKdXN0IGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdGhyZWUgY29uc2VjdXRpdmUgbnVtYmVycyxcbiAgICAvLyB0aGVuICdtYXknIGJlIGEgcGhvbmUgbnVtYmVyIChtYXkgYmUgYW55dGhpbmcgZWxzZSwgYnV0XG4gICAgLy8gc2luY2Ugc29tZSBzcGVjaWFsIHBob25lIG51bWJlcnMgY2FuIGhhdmUgbGV0dGVycyBvciBzaWducyxcbiAgICAvLyB0aGlzIGlzIGp1c3QgYSB2ZXJ5IGxheCBhbmQgY29uc2VydmF0aXZlICh0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMpIGNoZWNrLlxuICAgIHJldHVybiAoL1xcZHszLH0vKS50ZXN0KHN0ciB8fCAnJyk7XG59XG5cbi8qKlxuICAgIFVzZSB0aGUgcHJvdmlkZWQgc2VhcmNoIHRleHQgYXMgdGhlIGluaXRpYWwgdmFsdWVcbiAgICBmb3I6IG5hbWUsIGVtYWlsIG9yIHBob25lICh3aGF0IGZpdHMgYmV0dGVyKVxuKiovXG5mdW5jdGlvbiBjbGllbnREYXRhRnJvbVNlYXJjaFRleHQodHh0LCBjbGllbnQpIHtcbiAgICBpZiAoaXMuZW1haWwodHh0KSkge1xuICAgICAgICBjbGllbnQuZW1haWwodHh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VlbXNBUGhvbmVOdW1iZXIodHh0KSkge1xuICAgICAgICBjbGllbnQucGhvbmUodHh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpbmsgaXMgdGhlIGZ1bGxuYW1lLCBzcGxpdGluZyBieSB3aGl0ZSBzcGFjZVxuICAgICAgICB2YXIgbmFtZVBhcnRzID0gdHh0LnNwbGl0KCcgJywgMik7XG4gICAgICAgIGNsaWVudC5maXJzdE5hbWUobmFtZVBhcnRzWzBdKTtcbiAgICAgICAgaWYgKG5hbWVQYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjbGllbnQubGFzdE5hbWUobmFtZVBhcnRzWzFdKTtcbiAgICAgICAgICAgIC8vIFRPRE8gRm9yIHNwYW5pc2ggKG9yIGFueSBsb2NhbGUgd2l0aCBzZWNvbmRMYXN0TmFtZSlcbiAgICAgICAgICAgIC8vIG11c3QgdHJ5IHRvIGRldGVjdCB0aGUgc2Vjb25kIGxhc3QgbmFtZT9cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuICAgIC8qanNoaW50IG1heHN0YXRlbWVudHM6ODAgKi9cbiAgICBcbiAgICB0aGlzLmNsaWVudElEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICBcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIHRoaXMuY2xpZW50ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuY2xpZW50VmVyc2lvbigpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgICAvL3RoaXMuY2xpZW50ID0gYXBwLm1vZGVsLmNsaWVudHMuY3JlYXRlV2lsZGNhcmRJdGVtKCk7XG5cbiAgICB0aGlzLmhlYWRlciA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIFxuICAgIHRoaXMuaXNMb2FkaW5nID0gYXBwLm1vZGVsLmNsaWVudHMuc3RhdGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLmNsaWVudHMuc3RhdGUuaXNTeW5jaW5nO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBhcHAubW9kZWwuY2xpZW50cy5zdGF0ZS5pc1NhdmluZztcbiAgICB0aGlzLmlzTG9ja2VkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYXBwLm1vZGVsLmNsaWVudHMuc3RhdGUuaXNMb2NrZWQoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0RlbGV0aW5nKClcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmlzUmVhZE9ubHkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGMgJiYgIWMuZWRpdGFibGUoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaXNEZWxldGluZyA9IGFwcC5tb2RlbC5jbGllbnRzLnN0YXRlLmlzRGVsZXRpbmc7XG5cbiAgICB0aGlzLndhc1JlbW92ZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuICAgIHRoaXMuaXNOZXcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcbiAgICAgICAgcmV0dXJuICFjIHx8ICFjLnVwZGF0ZWREYXRlKCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5jbGllbnRWZXJzaW9uKCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXG4gICAgICAgICAgICAgICAgJ0xvYWRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXG4gICAgICAgICAgICAgICAgICAgICdTYXZpbmcgY2hhbmdlcycgOiBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc05ldygpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdBZGQgY2xpZW50JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2ICYmIHYuYXJlRGlmZmVyZW50KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlIGNoYW5nZXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU2F2ZWQnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnVuc2F2ZWRDaGFuZ2VzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuY2xpZW50VmVyc2lvbigpO1xuICAgICAgICByZXR1cm4gdiAmJiB2LmFyZURpZmZlcmVudCgpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZGVsZXRlVGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNEZWxldGluZygpID8gXG4gICAgICAgICAgICAgICAgJ0RlbGV0aW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgICdEZWxldGUnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBhcHAubW9kZWwuY2xpZW50cy5zZXRJdGVtKHRoaXMuY2xpZW50KCkubW9kZWwudG9QbGFpbk9iamVjdCgpKVxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdmVyc2lvbiB3aXRoIHNlcnZlciBkYXRhLlxuICAgICAgICAgICAgdGhpcy5jbGllbnQoKS5tb2RlbC51cGRhdGVXaXRoKHNlcnZlckRhdGEpO1xuICAgICAgICAgICAgLy8gUHVzaCB2ZXJzaW9uIHNvIGl0IGFwcGVhcnMgYXMgc2F2ZWRcbiAgICAgICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbigpLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgc2F2ZSwgZnVuY3Rpb24gcHJvdmlkZWQgYnkgdGhlIGFjdGl2aXR5IG9uIHNldC11cFxuICAgICAgICAgICAgdGhpcy5vblNhdmUoc2VydmVyRGF0YS5jbGllbnRVc2VySUQpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBzYXZpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5jb25maXJtUmVtb3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAubW9kYWxzLmNvbmZpcm0oe1xuICAgICAgICAgICAgdGl0bGU6ICdEZWxldGUgY2xpZW50JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdBcmUgeW91IHN1cmU/IFRoZSBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nLFxuICAgICAgICAgICAgeWVzOiAnRGVsZXRlJyxcbiAgICAgICAgICAgIG5vOiAnS2VlcCdcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgYXBwLm1vZGVsLmNsaWVudHMuZGVsSXRlbSh0aGlzLmNsaWVudElEKCkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy53YXNSZW1vdmVkKHRydWUpO1xuICAgICAgICAgICAgLy8gR28gb3V0IHRoZSBkZWxldGVkIGxvY2F0aW9uXG4gICAgICAgICAgICBhcHAuc2hlbGwuZ29CYWNrKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGRlbGV0aW5nLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICAvLyBCaXJ0aCBtb250aCBkYXlcbiAgICAvLyBUT0RPIGwxMG5cbiAgICB0aGlzLm1vbnRocyA9IGtvLm9ic2VydmFibGVBcnJheShbXG4gICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdKYW51YXJ5J30sXG4gICAgICAgIHsgaWQ6IDIsIG5hbWU6ICdGZWJydWFyeSd9LFxuICAgICAgICB7IGlkOiAzLCBuYW1lOiAnTWFyY2gnfSxcbiAgICAgICAgeyBpZDogNCwgbmFtZTogJ0FwcmlsJ30sXG4gICAgICAgIHsgaWQ6IDUsIG5hbWU6ICdNYXknfSxcbiAgICAgICAgeyBpZDogNiwgbmFtZTogJ0p1bmUnfSxcbiAgICAgICAgeyBpZDogNywgbmFtZTogJ0p1bHknfSxcbiAgICAgICAgeyBpZDogOCwgbmFtZTogJ0F1Z3VzdCd9LFxuICAgICAgICB7IGlkOiA5LCBuYW1lOiAnU2VwdGVtYmVyJ30sXG4gICAgICAgIHsgaWQ6IDEwLCBuYW1lOiAnT2N0b2Jlcid9LFxuICAgICAgICB7IGlkOiAxMSwgbmFtZTogJ05vdmVtYmVyJ30sXG4gICAgICAgIHsgaWQ6IDEyLCBuYW1lOiAnRGVjZW1iZXInfVxuICAgIF0pO1xuICAgIC8vIFdlIG5lZWQgdG8gdXNlIGEgc3BlY2lhbCBvYnNlcnZhYmxlIGluIHRoZSBmb3JtLCB0aGF0IHdpbGxcbiAgICAvLyB1cGRhdGUgdGhlIGJhY2stZW5kIHByb2ZpbGUuYmlydGhNb250aFxuICAgIHRoaXMuc2VsZWN0ZWRCaXJ0aE1vbnRoID0ga28uY29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpcnRoTW9udGggPSBjLmJpcnRoTW9udGgoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmlydGhNb250aCA/IHRoaXMubW9udGhzKClbYmlydGhNb250aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24obW9udGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jbGllbnQoKTtcbiAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgIGMuYmlydGhNb250aChtb250aCAmJiBtb250aC5pZCB8fCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duZXI6IHRoaXNcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLm1vbnRoRGF5cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgZm9yICh2YXIgaWRheSA9IDE7IGlkYXkgPD0gMzE7IGlkYXkrKykge1xuICAgICAgICB0aGlzLm1vbnRoRGF5cy5wdXNoKGlkYXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBFeHRyYSBmb3IgYnV0dG9uIGFkZG9uc1xuICAgIHRoaXMudmFsaWRFbWFpbCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgdmFyIGUgPSBjLmVtYWlsKCk7XG4gICAgICAgICAgICByZXR1cm4gaXMuZW1haWwoZSkgPyBlIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy52YWxpZFBob25lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2xpZW50KCk7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGMucGhvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWVtc0FQaG9uZU51bWJlcihlKSA/IGUgOiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8gUHVibGljIFNlYXJjaFxuICAgIFxuICAgIHZhciBmb3VuZFB1YmxpY1VzZXIgPSBmdW5jdGlvbiBmb3VuZFB1YmxpY1VzZXIodXNlcikge1xuICAgICAgICAvLyBPbmx5IGlmIHN0aWxsIG1hdGNoZXMgY3VycmVudCB2aWV3IGRhdGFcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNsaWVudCgpO1xuICAgICAgICBpZiAoIWMpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIERvbid0IG9mZmVyIGlmIGlzIGFscmVhZHkgdGhhdCB1c2VyIVxuICAgICAgICBpZiAoYy5jbGllbnRVc2VySUQoKSA9PT0gdXNlci5jbGllbnRVc2VySUQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIE5PVEU6IGF2b2lkaW5nIHVzZSBmdWxsTmFtZSBiZWNhdXNlIGl0IGNhbiBtYWtlIG1vcmUgdGhhbiBvbmUgY29uZmxpY3RpbmdcbiAgICAgICAgLy8gcmVzdWx0cywgYmVpbmcgbm90IGVub3VnaCB0aGUgbmFtZSB0byBjb25maXJtIHRoZSB1c2VyICh1c2UgdGhlIHNlYXJjaCBmb3IgdGhhdClcbiAgICAgICAgLy8gIGMuZnVsbE5hbWUoKSA9PT0gdXNlci5mdWxsTmFtZSB8fFxuICAgICAgICBpZiAoYy5lbWFpbCgpID09PSB1c2VyLmVtYWlsIHx8XG4gICAgICAgICAgICBjLnBob25lKCkgPT09IHVzZXIucGhvbmUpIHtcblxuICAgICAgICAgICAgLy8gTm90aWZ5IHVzZXJcbiAgICAgICAgICAgIHZhciBtc2cgPSAnV2VgdmUgZm91bmQgYW4gZXhpc3RpbmcgcmVjb3JkIGZvciB7MH0uIFdvdWxkIHlvdSBsaWtlIHRvIGFkZCBoaW0gdG8geW91ciBjbGllbnRzPycucmVwbGFjZSgvXFx7MFxcfS9nLCB1c2VyLmZpcnN0TmFtZSk7XG4gICAgICAgICAgICBhcHAubW9kYWxzLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnY2xpZW50IGZvdW5kIGF0IGxvY29ub21pY3MuY29tJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBBY2VwdGVkXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBjdXJyZW50IHVzZXIgZGF0YVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBrZWVwIG5vdGVzQWJvdXRDbGllbnRcbiAgICAgICAgICAgICAgICB2YXIgbm90ZXMgPSBjLm5vdGVzQWJvdXRDbGllbnQoKTtcbiAgICAgICAgICAgICAgICBjLm1vZGVsLnVwZGF0ZVdpdGgodXNlcik7XG4gICAgICAgICAgICAgICAgYy5ub3Rlc0Fib3V0Q2xpZW50KG5vdGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudElEKHVzZXIuY2xpZW50VXNlcklEKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICAvLyBXaGVuIGZpbGVyaW5nIGhhcyBubyByZXN1bHRzOlxuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2xpZW50KCk7XG4gICAgICAgIGlmICghYykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gTk9URTogZGlzY2FyZGVkIHRoZSBmdWxsTmFtZSBiZWNhdXNlIHNldmVyYWwgcmVzdWx0cyBjYW4gYmUgcmV0cmlldmVkLFxuICAgICAgICAvLyBiZXR0ZXIgdXNlIHRoZSBzZWFyY2ggZm9yIHRoYXQgYW5kIGRvdWJsZSBjaGVjayBlbnRyaWVzXG4gICAgICAgIFxuICAgICAgICB2YXIgZW1haWwgPSBjLmVtYWlsKCksXG4gICAgICAgICAgICAvL2Z1bGxOYW1lID0gYy5mdWxsTmFtZSgpLFxuICAgICAgICAgICAgcGhvbmUgPSBjLnBob25lKCk7XG4gICAgICAgIGlmICghZW1haWwgJiYgIXBob25lIC8qIWZ1bGxOYW1lICYmICovKSByZXR1cm47XG5cbiAgICAgICAgYXBwLm1vZGVsLmNsaWVudHMucHVibGljU2VhcmNoKHtcbiAgICAgICAgICAgIC8vZnVsbE5hbWU6IGZ1bGxOYW1lLFxuICAgICAgICAgICAgZW1haWw6IGVtYWlsLFxuICAgICAgICAgICAgcGhvbmU6IHBob25lXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIGlmIChyICYmIHJbMF0pIGZvdW5kUHVibGljVXNlcihyWzBdKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlcnNcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcylcbiAgICAvLyBBdm9pZCBleGNlc3NpdmUgcmVxdWVzdCBieSBzZXR0aW5nIGEgdGltZW91dCBzaW5jZSB0aGUgbGF0ZXN0IGNoYW5nZVxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgdGltZW91dDogNDAwLCBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnIH0gfSk7XG59XG4iLCIvKipcbiAgICBjbGllbnRzIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKSxcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXG4gICAgdGV4dFNlYXJjaCA9IHJlcXVpcmUoJy4uL3V0aWxzL3RleHRTZWFyY2gnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIENsaWVudHNBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLnNlcnZpY2VQcm9mZXNzaW9uYWw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignQ2xpZW50cycsIHtcbiAgICAgICAgYmFja0xpbms6ICdjbXMnXG4gICAgfSk7XG4gICAgLy8gU2F2ZSBkZWZhdWx0cyB0byByZXN0b3JlIG9uIHVwZGF0ZU5hdkJhclN0YXRlIHdoZW4gbmVlZGVkOlxuICAgIHRoaXMuZGVmYXVsdExlZnRBY3Rpb24gPSB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkubW9kZWwudG9QbGFpbk9iamVjdCgpO1xuICAgIFxuICAgIC8vIEdldHRpbmcgZWxlbWVudHNcbiAgICB0aGlzLiRpbmRleCA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjbGllbnRzSW5kZXgnKTtcbiAgICB0aGlzLiRsaXN0VmlldyA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNjbGllbnRzTGlzdFZpZXcnKTtcblxuICAgIC8vIEhhbmRsZXIgdG8gZ28gYmFjayB3aXRoIHRoZSBzZWxlY3RlZCBjbGllbnQgd2hlbiBcbiAgICAvLyB0aGVyZSBpcyBvbmUgc2VsZWN0ZWQgYW5kIHJlcXVlc3REYXRhIGlzIGZvclxuICAgIC8vICdzZWxlY3QgbW9kZSdcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuc2VsZWN0ZWRDbGllbnQsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uICh0aGVTZWxlY3RlZENsaWVudCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHJlcXVlc3QgYW5kXG4gICAgICAgICAgICAvLyBpdCByZXF1ZXN0ZWQgdG8gc2VsZWN0IGEgY2xpZW50LFxuICAgICAgICAgICAgLy8gYW5kIGEgc2VsZWN0ZWQgY2xpZW50XG4gICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YSAmJlxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0Q2xpZW50ID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgdGhlU2VsZWN0ZWRDbGllbnQpIHtcblxuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIHNlbGVjdGVkIGNsaWVudCBpbiB0aGUgaW5mb1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRDbGllbnRJRCA9IHRoZVNlbGVjdGVkQ2xpZW50LmNsaWVudFVzZXJJRCgpO1xuICAgICAgICAgICAgICAgIC8vIEFuZCBnbyBiYWNrXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgIC8vIExhc3QsIGNsZWFyIHJlcXVlc3REYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMucmV0dXJuUmVxdWVzdCA9IGZ1bmN0aW9uIHJldHVyblJlcXVlc3QoKSB7XG4gICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcbiAgICB9LmJpbmQodGhpcyk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6OFxuICAgIFxuICAgIHZhciBpdElzID0gdGhpcy52aWV3TW9kZWwuaXNTZWxlY3Rpb25Nb2RlKCk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwuaGVhZGVyVGV4dChpdElzID8gJ1NlbGVjdCBhIGNsaWVudCcgOiAnJyk7XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS50aXRsZSkge1xuICAgICAgICAvLyBSZXBsYWNlIHRpdGxlIGJ5IHRpdGxlIGlmIHJlcXVpcmVkXG4gICAgICAgIHRoaXMubmF2QmFyLnRpdGxlKHRoaXMucmVxdWVzdERhdGEudGl0bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGl0bGUgbXVzdCBiZSBlbXB0eVxuICAgICAgICB0aGlzLm5hdkJhci50aXRsZSgnJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xuICAgICAgICB0aGlzLmNvbnZlcnRUb0NhbmNlbEFjdGlvbih0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCksIHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSZXNldCB0byBkZWZhdWx0cywgb3IgZ2l2ZW4gdGl0bGU6XG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5tb2RlbC51cGRhdGVXaXRoKHRoaXMuZGVmYXVsdExlZnRBY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5uYXZUaXRsZSlcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KHRoaXMucmVxdWVzdERhdGEubmF2VGl0bGUpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaXRJcyAmJiAhdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKSB7XG4gICAgICAgIC8vIFVzZXMgYSBjdXN0b20gaGFuZGxlciBzbyBpdCByZXR1cm5zIGtlZXBpbmcgdGhlIGdpdmVuIHN0YXRlOlxuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkuaGFuZGxlcih0aGlzLnJldHVyblJlcXVlc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRJcykge1xuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkuaGFuZGxlcihudWxsKTtcbiAgICB9XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIE9uIGV2ZXJ5IHNob3csIHNlYXJjaCBnZXRzIHJlc2V0ZWRcbiAgICB0aGlzLnZpZXdNb2RlbC5zZWFyY2hUZXh0KCcnKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5zZWxlY3RlZENsaWVudChudWxsKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXF1ZXN0RGF0YSA9IHRoaXMucmVxdWVzdERhdGE7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgaXQgY29tZXMgZnJvbSBhIGNsaWVudEVkaXRvciB0aGF0XG4gICAgLy8gcmVjZWl2ZWQgdGhlIGZsYWcgJ3JldHVybk5ld0FzU2VsZWN0ZWQnIGFuZCBhIFxuICAgIC8vIGNsaWVudElEOiB3ZSB3ZXJlIGluIHNlbGVjdGlvbiBtb2RlLT5jcmVhdGluZyBjbGllbnQtPm11c3RcbiAgICAvLyByZXR1cm4gdGhlIGp1c3QgY3JlYXRlZCBjbGllbnQgdG8gdGhlIHByZXZpb3VzIHBhZ2VcbiAgICBpZiAoc3RhdGUucmV0dXJuTmV3QXNTZWxlY3RlZCA9PT0gdHJ1ZSAmJlxuICAgICAgICBzdGF0ZS5jbGllbnRJRCkge1xuICAgICAgICBcbiAgICAgICAgLy8gcGVyZm9ybSBhbiBhY3Rpdml0eSBjaGFuZ2UgYnV0IGFsbG93IHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHRvIHN0b3AgZmlyc3RcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5yZXR1cm5OZXdBc1NlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZENsaWVudElEID0gc3RhdGUuY2xpZW50SUQ7XG4gICAgICAgICAgICAvLyBBbmQgZ28gYmFja1xuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcyksIDEpO1xuICAgICAgICBcbiAgICAgICAgLy8gYXZvaWQgdGhlIHJlc3Qgb3BlcmF0aW9uc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBzZWxlY3Rpb246XG4gICAgdGhpcy52aWV3TW9kZWwuaXNTZWxlY3Rpb25Nb2RlKHN0YXRlLnNlbGVjdENsaWVudCA9PT0gdHJ1ZSk7XG5cbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XG4gICAgXG4gICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XG4gICAgdGhpcy5hcHAubW9kZWwuY2xpZW50cy5zeW5jKClcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIHRoZSBjbGllbnRzIGxpc3QnLFxuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuXG4gICAgdGhpcy5oZWFkZXJUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XG5cbiAgICAvLyBFc3BlY2lhbCBtb2RlIHdoZW4gaW5zdGVhZCBvZiBwaWNrIGFuZCBlZGl0IHdlIGFyZSBqdXN0IHNlbGVjdGluZ1xuICAgIC8vICh3aGVuIGVkaXRpbmcgYW4gYXBwb2ludG1lbnQpXG4gICAgdGhpcy5pc1NlbGVjdGlvbk1vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuICAgIC8vIEZ1bGwgbGlzdCBvZiBjbGllbnRzXG4gICAgdGhpcy5jbGllbnRzID0gYXBwLm1vZGVsLmNsaWVudHMubGlzdDtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5jbGllbnRzLnN0YXRlLmlzTG9hZGluZztcbiAgICB0aGlzLmlzU3luY2luZyA9IGFwcC5tb2RlbC5jbGllbnRzLnN0YXRlLmlzU3luY2luZztcbiAgICBcbiAgICAvLyBTZWFyY2ggdGV4dCwgdXNlZCB0byBmaWx0ZXIgJ2NsaWVudHMnXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgXG4gICAgLy8gVXRpbGl0eSB0byBnZXQgYSBmaWx0ZXJlZCBsaXN0IG9mIGNsaWVudHMgYmFzZWQgb24gY2xpZW50c1xuICAgIHRoaXMuZ2V0RmlsdGVyZWRMaXN0ID0gZnVuY3Rpb24gZ2V0RmlsdGVyZWRMaXN0KCkge1xuICAgICAgICB2YXIgcyA9ICh0aGlzLnNlYXJjaFRleHQoKSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gU2VhcmNoIHRoZSBjbGllbnQgYnk6XG4gICAgICAgIC8vIC0gZnVsbCBuYW1lXG4gICAgICAgIC8vIC0gKGVsc2UpIGVtYWlsXG4gICAgICAgIC8vIC0gKGVsc2UpIHBob25lXG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudHMoKS5maWx0ZXIoZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gdGV4dFNlYXJjaChzLCBjbGllbnQuZnVsbE5hbWUoKSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZm91bmQgPSB0ZXh0U2VhcmNoKHMsIGNsaWVudC5lbWFpbCgpKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBmb3VuZCA9IHRleHRTZWFyY2gocywgY2xpZW50LnBob25lKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRmlsdGVyZWQgbGlzdCBvZiBjbGllbnRzXG4gICAgdGhpcy5maWx0ZXJlZENsaWVudHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVyZWRMaXN0KCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8gR3JvdXBlZCBsaXN0IG9mIGZpbHRlcmVkIGNsaWVudHNcbiAgICB0aGlzLmdyb3VwZWRDbGllbnRzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKXtcblxuICAgICAgICAvLyBTb3J0aW5nIGxpc3QsIGluIGEgY3Jvc3MgYnJvd3NlciB3YXkgKGluIEZpcmVmb3gsIGp1c3QgQSA+IEIgd29ya3MsIGJ1dCBub3Qgb24gd2Via2l0L2JsaW5rKVxuICAgICAgICB2YXIgY2xpZW50cyA9IHRoaXMuZmlsdGVyZWRDbGllbnRzKCkuc29ydChmdW5jdGlvbihjbGllbnRBLCBjbGllbnRCKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGNsaWVudEEuZmlyc3ROYW1lKCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBiID0gY2xpZW50Qi5maXJzdE5hbWUoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBlbHNlIGlmIChhID4gYilcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdLFxuICAgICAgICAgICAgbGF0ZXN0R3JvdXAgPSBudWxsLFxuICAgICAgICAgICAgbGF0ZXN0TGV0dGVyID0gbnVsbDtcblxuICAgICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gKGNsaWVudC5maXJzdE5hbWUoKVswXSB8fCAnJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChsZXR0ZXIgIT09IGxhdGVzdExldHRlcikge1xuICAgICAgICAgICAgICAgIGxhdGVzdEdyb3VwID0ge1xuICAgICAgICAgICAgICAgICAgICBsZXR0ZXI6IGxldHRlcixcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50czogW2NsaWVudF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGxhdGVzdEdyb3VwKTtcbiAgICAgICAgICAgICAgICBsYXRlc3RMZXR0ZXIgPSBsZXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RHcm91cC5jbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwcztcblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIFxuICAgIC8vLyBQdWJsaWMgc2VhcmNoXG4gICAgdGhpcy5wdWJsaWNTZWFyY2hSZXN1bHRzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbiAgICB0aGlzLnB1YmxpY1NlYXJjaFJ1bm5pbmcgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIC8vIFdoZW4gZmlsZXJpbmcgaGFzIG5vIHJlc3VsdHM6XG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7ICAgIFxuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLmZpbHRlcmVkQ2xpZW50cygpLFxuICAgICAgICAgICAgc2VhcmNoVGV4dCA9IHRoaXMuc2VhcmNoVGV4dCgpLFxuICAgICAgICAgICAgcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgc2VhcmNoIHRleHQgYW5kIG5vIHJlc3VsdHMgZnJvbSBsb2NhbCBmaWx0ZXJpbmdcbiAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gMCAmJiBzZWFyY2hUZXh0KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyByZXN1bHRzXG4gICAgICAgICAgICB0aGlzLnB1YmxpY1NlYXJjaFJlc3VsdHMoW10pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXF1ZXN0ID0gYXBwLm1vZGVsLmNsaWVudHMucHVibGljU2VhcmNoKHtcbiAgICAgICAgICAgICAgICBmdWxsTmFtZTogc2VhcmNoVGV4dCxcbiAgICAgICAgICAgICAgICBlbWFpbDogc2VhcmNoVGV4dCxcbiAgICAgICAgICAgICAgICBwaG9uZTogc2VhcmNoVGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1NlYXJjaFJ1bm5pbmcocmVxdWVzdCk7XG4gICAgICAgICAgICByZXF1ZXN0LnRoZW4oZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUmVzdWx0cyhyKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoZW4gb24gcmVtb3RlIGNsaWVudHMgc2VhcmNoJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIEFsd2F5czpcbiAgICAgICAgICAgICAgICAvLyBpZiBzdGlsbCB0aGUgc2FtZSwgaXQgZW5kZWQgdGhlbiByZW1vdmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNTZWFyY2hSdW5uaW5nKCkgPT09IHJlcXVlc3QpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljU2VhcmNoUnVubmluZyhudWxsKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1NlYXJjaFJlc3VsdHMoW10pO1xuICAgICAgICAgICAgLy8gQ2FuY2VsbGluZyBhbnkgcGVuZGluZyByZXF1ZXN0LCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gYW53YW50ZWQgcmVzdWx0cyB3aGVuIGZpbmlzaFxuICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMucHVibGljU2VhcmNoUnVubmluZygpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QgJiZcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnhociAmJlxuICAgICAgICAgICAgICAgIHJlcXVlc3QueGhyLmFib3J0KSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC54aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY1NlYXJjaFJ1bm5pbmcobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKVxuICAgIC8vIEF2b2lkIGV4Y2Vzc2l2ZSByZXF1ZXN0IGJ5IHNldHRpbmcgYSB0aW1lb3V0IHNpbmNlIHRoZSBsYXRlc3QgY2hhbmdlXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyB0aW1lb3V0OiA0MDAsIG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcgfSB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgQWRkIGEgY2xpZW50IGZyb20gdGhlIHB1YmxpYy9yZW1vdGUgc2VhcmNoIHJlc3VsdHNcbiAgICAqKi9cbiAgICB0aGlzLmFkZFJlbW90ZUNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBjbGllbnQubW9kZWwgJiYgY2xpZW50Lm1vZGVsLnRvUGxhaW5PYmplY3QoKSB8fCBjbGllbnQ7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gJC5leHRlbmQoe30sIHRoaXMucmVxdWVzdERhdGEsIHtcbiAgICAgICAgICAgIHByZXNldERhdGE6IGRhdGEsXG4gICAgICAgICAgICByZXR1cm5OZXdBc1NlbGVjdGVkOiB0aGlzLmlzU2VsZWN0aW9uTW9kZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBhcHAuc2hlbGwuZ28oJ2NsaWVudEVkaXRvcicsIHJlcXVlc3QpO1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgQ2FsbCB0aGUgYWN0aXZpdHkgdG8gYWRkIGEgbmV3IGNsaWVudCwgcGFzc2luZyB0aGUgY3VycmVudFxuICAgICAgICBzZWFyY2ggdGV4dCBzbyBjYW4gYmUgdXNlZCBhcyBpbml0aWFsIG5hbWUvZW1haWwvcGhvbmVcbiAgICAqKi9cbiAgICB0aGlzLmFkZE5ldyA9IGZ1bmN0aW9uKGRhdGEsIGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAkLmV4dGVuZCh7fSwgdGhpcy5yZXF1ZXN0RGF0YSwge1xuICAgICAgICAgICAgbmV3Rm9yU2VhcmNoVGV4dDogdGhpcy5zZWFyY2hUZXh0KCksXG4gICAgICAgICAgICByZXR1cm5OZXdBc1NlbGVjdGVkOiB0aGlzLmlzU2VsZWN0aW9uTW9kZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBhcHAuc2hlbGwuZ28oJ2NsaWVudEVkaXRvcicsIHJlcXVlc3QpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIC8vLyBTZWxlY3Rpb25zXG4gICAgXG4gICAgdGhpcy5zZWxlY3RlZENsaWVudCA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgXG4gICAgdGhpcy5zZWxlY3RDbGllbnQgPSBmdW5jdGlvbihzZWxlY3RlZENsaWVudCwgZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZENsaWVudChzZWxlY3RlZENsaWVudCk7XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuIiwiLyoqXG4gICAgQ01TIGFjdGl2aXR5XG4gICAgKENsaWVudCBNYW5hZ2VtZW50IFN5c3RlbSlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ21zQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIFxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5sb2dnZWRVc2VyO1xuICAgIFxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignQ2xpZW50IG1hbmFnZW1lbnQnKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG5cbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcbiAgICB0aGlzLmFwcC5tb2RlbC5jbGllbnRzLnN5bmMoKVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgdGhlIGNsaWVudHMgbGlzdCcsXG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG52YXIgbnVtZXJhbCA9IHJlcXVpcmUoJ251bWVyYWwnKTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuICAgIFxuICAgIHRoaXMuY2xpZW50cyA9IGFwcC5tb2RlbC5jbGllbnRzLmxpc3Q7XG5cbiAgICB0aGlzLmNsaWVudHNDb3VudCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jbGllbnRzKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3MgPD0gMClcbiAgICAgICAgICAgIHJldHVybiAnMCBjbGllbnRzJztcbiAgICAgICAgZWxzZSBpZiAoY3MgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gJzEgY2xpZW50JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwoY3MubGVuZ3RoIHwwKS5mb3JtYXQoJzAsMCcpICsgJyBjbGllbnRzJztcbiAgICB9LCB0aGlzKTtcbn1cbiIsIi8qKlxuICAgIENvbnRhY3RGb3JtIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIFZvY0VsZW1lbnRFbnVtID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ZvY0VsZW1lbnRFbnVtJyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBDb250YWN0Rm9ybUFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICBcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1RhbGsgdG8gdXMnKTtcbiAgICB0aGlzLm5hdkJhci5yaWdodEFjdGlvbihudWxsKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucmVxdWVzdERhdGEucm91dGUuc2VnbWVudHMgfHwgW107XG4gICAgdmFyIGVsZW1lbnROYW1lID0gcGFyYW1zWzBdIHx8ICcnLFxuICAgICAgICBlbGVtZW50SUQgPSBWb2NFbGVtZW50RW51bVtlbGVtZW50TmFtZV0gfDA7XG4gICAgXG4gICAgaWYgKCFlbGVtZW50TmFtZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRmVlZGJhY2sgU3VwcG9ydDogQWNjZXNzaW5nIHdpdGhvdXQgc3BlY2lmeSBhbiBlbGVtZW50LCB1c2luZyBHZW5lcmFsICgwKScpO1xuICAgIH1cbiAgICBlbHNlIGlmICghVm9jRWxlbWVudEVudW0uaGFzT3duUHJvcGVydHkoZWxlbWVudE5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZlZWRiYWNrIFN1cHBvcnQ6IGdpdmVuIGEgYmFkIFZPQyBFbGVtZW50IG5hbWU6JywgZWxlbWVudE5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMudmlld01vZGVsLnZvY0VsZW1lbnRJRChlbGVtZW50SUQpO1xufTtcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLm1lc3NhZ2UgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICB0aGlzLndhc1NlbnQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmlzU2VuZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMudm9jRWxlbWVudElEID0ga28ub2JzZXJ2YWJsZSgwKTtcblxuICAgIHZhciB1cGRhdGVXYXNTZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud2FzU2VudChmYWxzZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZS5zdWJzY3JpYmUodXBkYXRlV2FzU2VudCk7XG4gICAgXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbmRpbmcoKSA/ICdTZW5kaW5nLi4nIDogdGhpcy53YXNTZW50KCkgPyAnU2VudCcgOiAnU2VuZCc7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgICAgdGhpcy5pc1NlbmRpbmcodHJ1ZSk7XG4gICAgICAgIGFwcC5tb2RlbC5mZWVkYmFjay5wb3N0U3VwcG9ydCh7XG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UoKSxcbiAgICAgICAgICAgIHZvY0VsZW1lbnRJRDogdGhpcy52b2NFbGVtZW50SUQoKVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGFmdGVyIGJlaW5nIHNlbnRcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSgnJyk7XG4gICAgICAgICAgICB0aGlzLndhc1NlbnQodHJ1ZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHNlbmRpbmcgeW91ciBmZWVkYmFjaycsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQWx3YXlzXG4gICAgICAgICAgICB0aGlzLmlzU2VuZGluZyhmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuIiwiLyoqXG4gICAgQ29udGFjdEluZm8gYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gQ29udGFjdEluZm9BY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICBcbiAgICB2YXIgc2VydmljZVByb2Zlc3Npb25hbE5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ093bmVyIGluZm9ybWF0aW9uJywge1xuICAgICAgICBiYWNrTGluazogJ293bmVySW5mbydcbiAgICB9KTtcbiAgICB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxOYXZCYXIgPSBzZXJ2aWNlUHJvZmVzc2lvbmFsTmF2QmFyLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XG4gICAgdmFyIGNsaWVudE5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0FjY291bnQnLCB7XG4gICAgICAgIGJhY2tMaW5rOiAnYWNjb3VudCdcbiAgICB9KTtcbiAgICB0aGlzLmNsaWVudE5hdkJhciA9IHNlcnZpY2VQcm9mZXNzaW9uYWxOYXZCYXIubW9kZWwudG9QbGFpbk9iamVjdCh0cnVlKTtcbiAgICB0aGlzLm5hdkJhciA9IHRoaXMudmlld01vZGVsLnVzZXIuaXNTZXJ2aWNlUHJvZmVzc2lvbmFsKCkgPyBzZXJ2aWNlUHJvZmVzc2lvbmFsTmF2QmFyIDogY2xpZW50TmF2QmFyO1xuICAgIFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC51c2VyUHJvZmlsZSxcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdmFyIG1zZyA9IGVyci50YXNrID09PSAnc2F2ZScgPyAnRXJyb3Igc2F2aW5nIGNvbnRhY3QgZGF0YS4nIDogJ0Vycm9yIGxvYWRpbmcgY29udGFjdCBkYXRhLic7XG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLmVycm9yIHx8IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5ob21lQWRkcmVzcyxcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdmFyIG1zZyA9IGVyci50YXNrID09PSAnc2F2ZScgPyAnRXJyb3Igc2F2aW5nIGFkZHJlc3MgZGV0YWlscy4nIDogJ0Vycm9yIGxvYWRpbmcgYWRkcmVzcyBkZXRhaWxzLic7XG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogbXNnLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgJiYgZXJyLmVycm9yIHx8IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIFxuICAgIC8vIE9uIGNoYW5nZSB0byBhIHZhbGlkIGNvZGUsIGRvIHJlbW90ZSBsb29rLXVwXG4gICAgLy8gTk9URTogdXNpbmcgZGlyZWN0bHkgYSBjb21wdXRlZCByYXRoZXIgdGhhbiB0aGUgcmVnaXN0ZXJIYW5kbGVyIHRvIHVzZVxuICAgIC8vIHRoZSByYXRlTGltaXQgZXh0ZW5kZXIgdGhhdCBhdm9pZHMgZXhjZXNpdmUgcmVxdWVzdCBiZWluZyBwZXJmb3JtZWQgb24gY2hhbmdlcy5cbiAgICAvLyBOT1RFOiB0aGUgY29kZSBpbnNpZGUgdGhlIGhhbmRsZXIgaXMgbW9zdGx5IHRoZSBzYW1lIGFzIGluIGFkZHJlc3NFZGl0b3IgZm9yIHRoZSBzYW1lIGxvb2stdXAuXG4gICAgdmFyIGFwcCA9IHRoaXMuYXBwLFxuICAgICAgICB2aWV3TW9kZWwgPSB0aGlzLnZpZXdNb2RlbDtcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvc3RhbENvZGUgPSB0aGlzLnBvc3RhbENvZGUoKSxcbiAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzO1xuXG4gICAgICAgIGlmIChwb3N0YWxDb2RlICYmICEvXlxccyokLy50ZXN0KHBvc3RhbENvZGUpKSB7XG4gICAgICAgICAgICBhcHAubW9kZWwucG9zdGFsQ29kZXMuZ2V0SXRlbShwb3N0YWxDb2RlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MuY2l0eShpbmZvLmNpdHkpO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VDb2RlKGluZm8uc3RhdGVQcm92aW5jZUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnN0YXRlUHJvdmluY2VOYW1lKGluZm8uc3RhdGVQcm92aW5jZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwuZXJyb3JNZXNzYWdlcy5wb3N0YWxDb2RlKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MuY2l0eSgnJyk7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5zdGF0ZVByb3ZpbmNlQ29kZSgnJyk7XG4gICAgICAgICAgICAgICAgYWRkcmVzcy5zdGF0ZVByb3ZpbmNlTmFtZSgnJyk7XG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0ZWQgZXJyb3JzLCBhIHNpbmdsZSBtZXNzYWdlLCBzZXRcbiAgICAgICAgICAgICAgICAvLyBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgIHZhciBtc2cgPSB0eXBlb2YoZXJyKSA9PT0gJ3N0cmluZycgPyBlcnIgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtc2cgfHwgZXJyICYmIGVyci5yZXNwb25zZUpTT04gJiYgZXJyLnJlc3BvbnNlSlNPTi5lcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsLmVycm9yTWVzc2FnZXMucG9zdGFsQ29kZShtc2cgfHwgZXJyLnJlc3BvbnNlSlNPTi5lcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIHRvIGNvbnNvbGUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcywgb24gcmVndWxhciB1c2UgYW4gZXJyb3Igb24gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3RhbCBjb2RlIGlzIG5vdCBjcml0aWNhbCBhbmQgY2FuIGJlIHRyYW5zcGFyZW50OyBpZiB0aGVyZSBhcmUgXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpdml0eSBvciBhdXRoZW50aWZpY2F0aW9uIGVycm9ycyB3aWxsIHRocm93IG9uIHNhdmluZyB0aGUgYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTZXJ2ZXIgZXJyb3IgdmFsaWRhdGluZyBaaXAgQ29kZScsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzLnZpZXdNb2RlbC5hZGRyZXNzKVxuICAgIC8vIEF2b2lkIGV4Y2Vzc2l2ZSByZXF1ZXN0cyBieSBzZXR0aW5nIGEgdGltZW91dCBzaW5jZSB0aGUgbGF0ZXN0IGNoYW5nZVxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgdGltZW91dDogMjAwLCBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnIH0gfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xuICAgIFxuICAgIGlmICghdGhpcy5hcHAubW9kZWwub25ib2FyZGluZy51cGRhdGVOYXZCYXIodGhpcy5uYXZCYXIpKSB7XG4gICAgICAgIC8vIFJlc2V0XG4gICAgICAgIHZhciBuYXYgPSB0aGlzLnZpZXdNb2RlbC51c2VyLmlzU2VydmljZVByb2Zlc3Npb25hbCgpID8gdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsTmF2QmFyIDogdGhpcy5jbGllbnROYXZCYXI7XG4gICAgICAgIHRoaXMubmF2QmFyLm1vZGVsLnVwZGF0ZVdpdGgobmF2LCB0cnVlKTtcbiAgICB9XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxuICAgIHRoaXMudmlld01vZGVsLmRpc2NhcmQoKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XG4gICAgXG4gICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XG4gICAgdGhpcy5hcHAubW9kZWwudXNlclByb2ZpbGUuc3luYygpO1xuICAgIHRoaXMuYXBwLm1vZGVsLmhvbWVBZGRyZXNzLnN5bmMoKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLnVzZXIgPSBhcHAubW9kZWwudXNlclByb2ZpbGUuZGF0YTtcblxuICAgIHRoaXMuaGVhZGVyVGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSA/XG4gICAgICAgICAgICAnSG93IGNhbiB3ZSByZWFjaCB5b3U/JyA6XG4gICAgICAgICAgICAnQ29udGFjdCBpbmZvcm1hdGlvbic7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gTGlzdCBvZiBwb3NzaWJsZSBlcnJvciBtZXNzYWdlcyByZWdpc3RlcmVkXG4gICAgLy8gYnkgbmFtZVxuICAgIHRoaXMuZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgICAgcG9zdGFsQ29kZToga28ub2JzZXJ2YWJsZSgnJylcbiAgICB9O1xuICAgIFxuICAgIC8vIFVzZXIgUHJvZmlsZVxuICAgIHZhciB1c2VyUHJvZmlsZSA9IGFwcC5tb2RlbC51c2VyUHJvZmlsZTtcbiAgICB2YXIgcHJvZmlsZVZlcnNpb24gPSB1c2VyUHJvZmlsZS5uZXdWZXJzaW9uKCk7XG4gICAgcHJvZmlsZVZlcnNpb24uaXNPYnNvbGV0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oaXRJcykge1xuICAgICAgICBpZiAoaXRJcykge1xuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xuICAgICAgICAgICAgLy8gRlVUVVJFOiB3YXJuIGFib3V0IGEgbmV3IHJlbW90ZSB2ZXJzaW9uIGFza2luZ1xuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyB3aXRoIGEgNTA5OkNvbmZsaWN0IHN0YXR1cyAoaXRzIGJvZHkgbXVzdCBjb250YWluIHRoZVxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxuICAgICAgICAgICAgLy8gcmVtb3RlIG9uZXM6XG4gICAgICAgICAgICBwcm9maWxlVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XG4gICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZVZlcnNpb24udmVyc2lvbjtcbiAgICBcbiAgICAvLyBUT0RPIGwxMG5cbiAgICB0aGlzLm1vbnRocyA9IGtvLm9ic2VydmFibGVBcnJheShbXG4gICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdKYW51YXJ5J30sXG4gICAgICAgIHsgaWQ6IDIsIG5hbWU6ICdGZWJydWFyeSd9LFxuICAgICAgICB7IGlkOiAzLCBuYW1lOiAnTWFyY2gnfSxcbiAgICAgICAgeyBpZDogNCwgbmFtZTogJ0FwcmlsJ30sXG4gICAgICAgIHsgaWQ6IDUsIG5hbWU6ICdNYXknfSxcbiAgICAgICAgeyBpZDogNiwgbmFtZTogJ0p1bmUnfSxcbiAgICAgICAgeyBpZDogNywgbmFtZTogJ0p1bHknfSxcbiAgICAgICAgeyBpZDogOCwgbmFtZTogJ0F1Z3VzdCd9LFxuICAgICAgICB7IGlkOiA5LCBuYW1lOiAnU2VwdGVtYmVyJ30sXG4gICAgICAgIHsgaWQ6IDEwLCBuYW1lOiAnT2N0b2Jlcid9LFxuICAgICAgICB7IGlkOiAxMSwgbmFtZTogJ05vdmVtYmVyJ30sXG4gICAgICAgIHsgaWQ6IDEyLCBuYW1lOiAnRGVjZW1iZXInfVxuICAgIF0pO1xuICAgIC8vIFdlIG5lZWQgdG8gdXNlIGEgc3BlY2lhbCBvYnNlcnZhYmxlIGluIHRoZSBmb3JtLCB0aGF0IHdpbGxcbiAgICAvLyB1cGRhdGUgdGhlIGJhY2stZW5kIHByb2ZpbGUuYmlydGhNb250aFxuICAgIHRoaXMuc2VsZWN0ZWRCaXJ0aE1vbnRoID0ga28uY29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBiaXJ0aE1vbnRoID0gdGhpcy5wcm9maWxlLmJpcnRoTW9udGgoKTtcbiAgICAgICAgICAgIHJldHVybiBiaXJ0aE1vbnRoID8gdGhpcy5tb250aHMoKVtiaXJ0aE1vbnRoIC0gMV0gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24obW9udGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZmlsZS5iaXJ0aE1vbnRoKG1vbnRoICYmIG1vbnRoLmlkIHx8IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMubW9udGhEYXlzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbiAgICBmb3IgKHZhciBpZGF5ID0gMTsgaWRheSA8PSAzMTsgaWRheSsrKSB7XG4gICAgICAgIHRoaXMubW9udGhEYXlzLnB1c2goaWRheSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhvbWUgQWRkcmVzc1xuICAgIHZhciBob21lQWRkcmVzcyA9IGFwcC5tb2RlbC5ob21lQWRkcmVzcztcbiAgICB2YXIgaG9tZUFkZHJlc3NWZXJzaW9uID0gaG9tZUFkZHJlc3MubmV3VmVyc2lvbigpO1xuICAgIGhvbWVBZGRyZXNzVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XG4gICAgICAgIGlmIChpdElzKSB7XG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXG4gICAgICAgICAgICAvLyBjb25maXJtYXRpb24gdG8gbG9hZCB0aGVtIG9yIGRpc2NhcmQgYW5kIG92ZXJ3cml0ZSB0aGVtO1xuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgdmVyc2lvbikuXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcbiAgICAgICAgICAgIGhvbWVBZGRyZXNzVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XG4gICAgdGhpcy5hZGRyZXNzID0gaG9tZUFkZHJlc3NWZXJzaW9uLnZlcnNpb247XG5cbiAgICAvLyBDb250cm9sIG9ic2VydmFibGVzOiBzcGVjaWFsIGJlY2F1c2UgbXVzdCBhIG1peFxuICAgIC8vIG9mIHRoZSBib3RoIHJlbW90ZSBtb2RlbHMgdXNlZCBpbiB0aGlzIHZpZXdtb2RlbFxuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJQcm9maWxlLmlzTG9ja2VkKCkgfHwgaG9tZUFkZHJlc3MuaXNMb2NrZWQoKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUuaXNMb2FkaW5nKCkgfHwgaG9tZUFkZHJlc3MuaXNMb2FkaW5nKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5pc1NhdmluZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlclByb2ZpbGUuaXNTYXZpbmcoKSB8fCBob21lQWRkcmVzcy5pc1NhdmluZygpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuaW5Qcm9ncmVzcygpID9cbiAgICAgICAgICAgICAgICAnU2F2ZSBhbmQgY29udGludWUnIDpcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnbG9hZGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8gQWN0aW9uc1xuXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcbiAgICAgICAgcHJvZmlsZVZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xuICAgICAgICBob21lQWRkcmVzc1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHByb2ZpbGVWZXJzaW9uLnB1c2hTYXZlKCksXG4gICAgICAgICAgICBob21lQWRkcmVzc1ZlcnNpb24ucHVzaFNhdmUoKVxuICAgICAgICBdKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhcHAubW9kZWwub25ib2FyZGluZy5pblByb2dyZXNzKCkpIHtcbiAgICAgICAgICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5nb05leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG59XG4iLCIvKipcbiAgICBDb252ZXJzYXRpb24gYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBDb252ZXJzYXRpb25BY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdJbmJveCcsIHtcbiAgICAgICAgYmFja0xpbms6ICdpbmJveCdcbiAgICB9KTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG5cbiAgICAvLyBSZXNldFxuICAgIHRoaXMudmlld01vZGVsLnRocmVhZElEKDApO1xuICAgIHRoaXMudmlld01vZGVsLnRocmVhZChudWxsKTtcblxuICAgIC8vIFBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cyB8fCBbXSxcbiAgICAgICAgdGhyZWFkSUQgPSBwYXJhbXNbMF0gfDA7XG5cbiAgICB0aGlzLnZpZXdNb2RlbC50aHJlYWRJRCh0aHJlYWRJRCk7XG4gICAgXG4gICAgLy8gTG9hZCB0aGUgZGF0YVxuICAgIGlmICh0aHJlYWRJRCkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbC50aHJlYWQuc3luYyh0aHJlYWRJRClcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBsb2FkaW5nIGNvbnZlcnNhdGlvbicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2soKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgIHRpdGxlOiAnQ29udmVyc2F0aW9uIE5vdCBGb3VuZCdcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjaygpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn07XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcblxuICAgIHRoaXMuaXNMb2FkaW5nID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5zdGF0ZS5pc0xvYWRpbmc7XG4gICAgdGhpcy5pc1N5bmNpbmcgPSBhcHAubW9kZWwubWVzc2FnaW5nLnN0YXRlLmlzU3luY2luZztcbiAgICB0aGlzLmlzU2F2aW5nID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5zdGF0ZS5pc1NhdmluZztcblxuICAgIHRoaXMudGhyZWFkSUQgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIHRoaXMudGhyZWFkID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5jcmVhdGVXaWxkY2FyZEl0ZW0oKTtcblxuICAgIHRoaXMuc3ViamVjdCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRocmVhZCgpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/XG4gICAgICAgICAgICAgICAgJ0xvYWRpbmcuLi4nIDpcbiAgICAgICAgICAgICAgICBtICYmIChtLnN1YmplY3QoKSB8fCAnJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpIHx8ICdDb252ZXJzYXRpb24gd2l0aG91dCBzdWJqZWN0J1xuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8vIElmIHRoZSBsYXN0IG1lc3NhZ2UgcmVmZXJlbmNlIGEgYm9va2luZywgaXNcbiAgICAvLyBhY2Nlc3NlZCB3aXRoOlxuICAgIHRoaXMuYm9va2luZ0lEID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gdGhpcy50aHJlYWQoKSAmJiB0aGlzLnRocmVhZCgpLm1lc3NhZ2VzKClbMF07XG4gICAgICAgIGlmIChtc2cgJiZcbiAgICAgICAgICAgIChtc2cuYXV4VCgpIHx8ICcnKS50b0xvd2VyQ2FzZSgpID09PSAnYm9va2luZycgJiZcbiAgICAgICAgICAgIG1zZy5hdXhJRCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnLmF1eElEKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xufVxuIiwiLyoqXG4gICAgRGFzaGJvYXJkIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIEFwcG9pbnRtZW50VmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvQXBwb2ludG1lbnRWaWV3JyksXG4gICAgVXNlckpvYlRpdGxlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1VzZXJKb2JUaXRsZScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gRGFzaGJvYXJkQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5sb2dnZWRVc2VyO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgLy8gbnVsbCBmb3IgbG9nb1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcihudWxsKTtcbiAgICBcbiAgICAvLyBHZXR0aW5nIGVsZW1lbnRzXG4gICAgdGhpcy4kbmV4dEJvb2tpbmcgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcjZGFzaGJvYXJkTmV4dEJvb2tpbmcnKTtcbiAgICB0aGlzLiR1cGNvbWluZ0Jvb2tpbmdzID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2Rhc2hib2FyZFVwY29taW5nQm9va2luZ3MnKTtcbiAgICB0aGlzLiRpbmJveCA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNkYXNoYm9hcmRJbmJveCcpO1xuICAgIHRoaXMuJHBlcmZvcm1hbmNlID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2Rhc2hib2FyZFBlcmZvcm1hbmNlJyk7XG4gICAgdGhpcy4kZ2V0TW9yZSA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJyNkYXNoYm9hcmRHZXRNb3JlJyk7XG4gICAgXG4gICAgLy8gVGVzdGluZ0RhdGFcbiAgICBzZXRTb21lVGVzdGluZ0RhdGEodGhpcy52aWV3TW9kZWwpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG4gICAgdmFyIHYgPSB0aGlzLnZpZXdNb2RlbCxcbiAgICAgICAgYXBwID0gdGhpcy5hcHAsXG4gICAgICAgIGFwcE1vZGVsID0gdGhpcy5hcHAubW9kZWw7XG4gICAgXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEuY29tcGxldGVkT25ib2FyZGluZykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVxdWVzdERhdGEuY29tcGxldGVkT25ib2FyZGluZykge1xuICAgICAgICAgICAgY2FzZSAnd2VsY29tZSc6IC8vIFNjaGVkdWxlIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ05pY2Ugd29yayEnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnWW91XFwnbGwgbm93IGJlIHRha2VuIHRvIHlvdXIgZGFzaGJvYXJkLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1BsZWFzZSB0cnkgdGhlIGZvbGxvd2luZzogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnMS4gQWN0aXZhdGUgeW91ciBtYXJrZXRwbGFjZSBwcm9maWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzIuIEFkZCBhIGZha2UgY2xpZW50IHVzaW5nICsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICczLiBBZGQgYSBmYWtlIGJvb2tpbmcgdXNpbmcgKycsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblRleHQ6ICdHb3QgaXQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIHByZWFwYXJlU2hvd0Vycm9yRm9yID0gZnVuY3Rpb24gcHJlYXBhcmVTaG93RXJyb3JGb3IodGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBkYXRhXG4gICAgaWYgKHYudXBjb21pbmdCb29raW5ncy5pdGVtcygpLmxlbmd0aCkge1xuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MuaXNTeW5jaW5nKHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLmlzTG9hZGluZyh0cnVlKTtcbiAgICB9XG4gICAgYXBwTW9kZWwuYm9va2luZ3MuZ2V0VXBjb21pbmdCb29raW5ncygpXG4gICAgLnRoZW4oZnVuY3Rpb24odXBjb21pbmcpIHtcblxuICAgICAgICBpZiAodXBjb21pbmcubmV4dEJvb2tpbmdJRCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzSUQgPSB2Lm5leHRCb29raW5nKCkgJiYgdi5uZXh0Qm9va2luZygpLnNvdXJjZUJvb2tpbmcoKS5ib29raW5nSUQoKTtcbiAgICAgICAgICAgIGlmICh1cGNvbWluZy5uZXh0Qm9va2luZ0lEICE9PSBwcmV2aW91c0lEKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYubmV4dEJvb2tpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB2Lm5leHRCb29raW5nLmlzU3luY2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHYubmV4dEJvb2tpbmcuaXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBNb2RlbC5jYWxlbmRhci5nZXRBcHBvaW50bWVudCh7IGJvb2tpbmdJRDogdXBjb21pbmcubmV4dEJvb2tpbmdJRCB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGFwdCkge1xuICAgICAgICAgICAgICAgICAgICB2Lm5leHRCb29raW5nKG5ldyBBcHBvaW50bWVudFZpZXcoYXB0LCBhcHApKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChwcmVhcGFyZVNob3dFcnJvckZvcignRXJyb3IgbG9hZGluZyBuZXh0IGJvb2tpbmcnKSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseVxuICAgICAgICAgICAgICAgICAgICB2Lm5leHRCb29raW5nLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHYubmV4dEJvb2tpbmcuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYubmV4dEJvb2tpbmcobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MudG9kYXkucXVhbnRpdHkodXBjb21pbmcudG9kYXkucXVhbnRpdHkpO1xuICAgICAgICB2LnVwY29taW5nQm9va2luZ3MudG9kYXkudGltZSh1cGNvbWluZy50b2RheS50aW1lICYmIG5ldyBEYXRlKHVwY29taW5nLnRvZGF5LnRpbWUpKTtcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLnRvbW9ycm93LnF1YW50aXR5KHVwY29taW5nLnRvbW9ycm93LnF1YW50aXR5KTtcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLnRvbW9ycm93LnRpbWUodXBjb21pbmcudG9tb3Jyb3cudGltZSAmJiBuZXcgRGF0ZSh1cGNvbWluZy50b21vcnJvdy50aW1lKSk7XG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy5uZXh0V2Vlay5xdWFudGl0eSh1cGNvbWluZy5uZXh0V2Vlay5xdWFudGl0eSk7XG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy5uZXh0V2Vlay50aW1lKHVwY29taW5nLm5leHRXZWVrLnRpbWUgJiYgbmV3IERhdGUodXBjb21pbmcubmV4dFdlZWsudGltZSkpO1xuICAgIH0pXG4gICAgLmNhdGNoKHByZWFwYXJlU2hvd0Vycm9yRm9yKCdFcnJvciBsb2FkaW5nIHVwY29taW5nIGJvb2tpbmdzJykpXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEZpbmFsbHlcbiAgICAgICAgdi51cGNvbWluZ0Jvb2tpbmdzLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHYudXBjb21pbmdCb29raW5ncy5pc1N5bmNpbmcoZmFsc2UpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIE1lc3NhZ2VzXG4gICAgdmFyIE1lc3NhZ2VWaWV3ID0gcmVxdWlyZSgnLi4vbW9kZWxzL01lc3NhZ2VWaWV3Jyk7XG4gICAgaWYgKHYuaW5ib3gubWVzc2FnZXMoKS5sZW5ndGgpXG4gICAgICAgIHYuaW5ib3guaXNTeW5jaW5nKHRydWUpO1xuICAgIGVsc2VcbiAgICAgICAgdi5pbmJveC5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgYXBwTW9kZWwubWVzc2FnaW5nLmdldExpc3QoKVxuICAgIC50aGVuKGZ1bmN0aW9uKHRocmVhZHMpIHtcbiAgICAgICAgdi5pbmJveC5tZXNzYWdlcyh0aHJlYWRzKCkubWFwKE1lc3NhZ2VWaWV3LmZyb21UaHJlYWQuYmluZChudWxsLCBhcHApKSk7XG4gICAgfSlcbiAgICAuY2F0Y2gocHJlYXBhcmVTaG93RXJyb3JGb3IoJ0Vycm9yIGxvYWRpbmcgbGF0ZXN0IG1lc3NhZ2VzJykpXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEZpbmFsbHlcbiAgICAgICAgdi5pbmJveC5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB2LmluYm94LmlzU3luY2luZyhmYWxzZSk7XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5zeW5jR2V0TW9yZSgpO1xufTtcblxuQS5wcm90b3R5cGUuc3luY0dldE1vcmUgPSBmdW5jdGlvbiBzeW5jR2V0TW9yZSgpIHtcbiAgICAvLyBDaGVjayB0aGUgJ3Byb2ZpbGUnIGFsZXJ0XG4gICAgdGhpcy5hcHAubW9kZWwudXNlckpvYlByb2ZpbGUuc3luY0xpc3QoKVxuICAgIC50aGVuKGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgdmFyIHllcCA9IGxpc3Quc29tZShmdW5jdGlvbihqb2IpIHtcbiAgICAgICAgICAgIGlmIChqb2Iuc3RhdHVzSUQoKSAhPT0gVXNlckpvYlRpdGxlLnN0YXR1cy5vbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlld01vZGVsLmdldE1vcmUucHJvZmlsZSghIXllcCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cblxudmFyIFVwY29taW5nQm9va2luZ3NTdW1tYXJ5ID0gcmVxdWlyZSgnLi4vbW9kZWxzL1VwY29taW5nQm9va2luZ3NTdW1tYXJ5JyksXG4gICAgTWFpbEZvbGRlciA9IHJlcXVpcmUoJy4uL21vZGVscy9NYWlsRm9sZGVyJyksXG4gICAgUGVyZm9ybWFuY2VTdW1tYXJ5ID0gcmVxdWlyZSgnLi4vbW9kZWxzL1BlcmZvcm1hbmNlU3VtbWFyeScpLFxuICAgIEdldE1vcmUgPSByZXF1aXJlKCcuLi9tb2RlbHMvR2V0TW9yZScpO1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLnVwY29taW5nQm9va2luZ3MgPSBuZXcgVXBjb21pbmdCb29raW5nc1N1bW1hcnkoKTtcbiAgICB0aGlzLnVwY29taW5nQm9va2luZ3MuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy51cGNvbWluZ0Jvb2tpbmdzLmlzU3luY2luZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuXG4gICAgdGhpcy5uZXh0Qm9va2luZyA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5uZXh0Qm9va2luZy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLm5leHRCb29raW5nLmlzU3luY2luZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIFxuICAgIHRoaXMuaW5ib3ggPSBuZXcgTWFpbEZvbGRlcih7XG4gICAgICAgIHRvcE51bWJlcjogNFxuICAgIH0pO1xuICAgIHRoaXMuaW5ib3guaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5pbmJveC5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBcbiAgICB0aGlzLnBlcmZvcm1hbmNlID0gbmV3IFBlcmZvcm1hbmNlU3VtbWFyeSgpO1xuICAgIFxuICAgIHRoaXMuZ2V0TW9yZSA9IG5ldyBHZXRNb3JlKCk7XG4gICAgXG4gICAgdGhpcy51c2VyID0gYXBwLm1vZGVsLnVzZXJQcm9maWxlLmRhdGE7XG59XG5cbi8qKiBURVNUSU5HIERBVEEgKiovXG5mdW5jdGlvbiBzZXRTb21lVGVzdGluZ0RhdGEodmlld01vZGVsKSB7XG4gICAgXG4gICAgLy92aWV3TW9kZWwucGVyZm9ybWFuY2UuZWFybmluZ3MuY3VycmVudEFtb3VudCgyNDAwKTtcbiAgICAvL3ZpZXdNb2RlbC5wZXJmb3JtYW5jZS5lYXJuaW5ncy5uZXh0QW1vdW50KDYyMDAuNTQpO1xuICAgIC8vdmlld01vZGVsLnBlcmZvcm1hbmNlLnRpbWVCb29rZWQucGVyY2VudCgwLjkzKTtcbiAgICBcbiAgICB2YXIgbW9yZURhdGEgPSB7fTtcbiAgICBpZiAodmlld01vZGVsLnVzZXIuaXNTZXJ2aWNlUHJvZmVzc2lvbmFsKCkpIHtcbiAgICAgICAgbW9yZURhdGEgPSB7XG4gICAgICAgICAgICBhdmFpbGFiaWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgcGF5bWVudHM6IGZhbHNlLFxuICAgICAgICAgICAgcHJvZmlsZTogZmFsc2UsXG4gICAgICAgICAgICBjb29wOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW9yZURhdGEgPSB7XG4gICAgICAgICAgICBhdmFpbGFiaWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgcGF5bWVudHM6IGZhbHNlLFxuICAgICAgICAgICAgcHJvZmlsZTogZmFsc2UsXG4gICAgICAgICAgICBjb29wOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpZXdNb2RlbC5nZXRNb3JlLm1vZGVsLnVwZGF0ZVdpdGgobW9yZURhdGEpO1xufVxuIiwiLyoqXG4gICAgZGF0ZXRpbWVQaWNrZXIgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIGdldERhdGVXaXRob3V0VGltZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldERhdGVXaXRob3V0VGltZScpO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBEYXRldGltZVBpY2tlckFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwoKTsgICAgXG4gICAgLy8gRGVmYXVsdHMgc2V0dGluZ3MgZm9yIG5hdkJhci5cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJycsIHtcbiAgICAgICAgaGVscElkOiAnZGF0ZXRpbWVQaWNrZXJIZWxwJ1xuICAgIH0pO1xuICAgIC8vIFNhdmUgZGVmYXVsdHMgdG8gcmVzdG9yZSBvbiB1cGRhdGVOYXZCYXJTdGF0ZSB3aGVuIG5lZWRlZDpcbiAgICB0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uID0gdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLm1vZGVsLnRvUGxhaW5PYmplY3QoKTtcblxuICAgIC8vIFJldHVybiB0aGUgc2VsZWN0ZWQgZGF0ZS10aW1lXG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgICAgIHZhciBkYXRldGltZSA9IHRoaXMudmlld01vZGVsLmNvbXBvbmVudCgpICYmIHRoaXMudmlld01vZGVsLmNvbXBvbmVudCgpLnNlbGVjdGVkRGF0ZXRpbWUoKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRldGltZSkge1xuICAgICAgICAgICAgLy8gUGFzcyB0aGUgc2VsZWN0ZWQgZGF0ZXRpbWUgaW4gdGhlIGluZm9cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWREYXRldGltZSA9IGRhdGV0aW1lO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUgPSB0aGlzLnZpZXdNb2RlbC5jb21wb25lbnQoKS5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUoKTtcbiAgICAgICAgICAgIC8vIEFuZCBnbyBiYWNrXG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLnJldHVyblJlcXVlc3QgPSBmdW5jdGlvbiByZXR1cm5SZXF1ZXN0KCkge1xuICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XG4gICAgfS5iaW5kKHRoaXMpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUudXBkYXRlTmF2QmFyU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVOYXZCYXJTdGF0ZSgpIHtcbiAgICBcbiAgICB2YXIgaGVhZGVyID0gdGhpcy5yZXF1ZXN0RGF0YS5oZWFkZXJUZXh0O1xuICAgIHRoaXMudmlld01vZGVsLmhlYWRlclRleHQoaGVhZGVyIHx8ICdTZWxlY3QgZGF0ZSBhbmQgdGltZScpO1xuXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEudGl0bGUpIHtcbiAgICAgICAgLy8gUmVwbGFjZSB0aXRsZVxuICAgICAgICB0aGlzLm5hdkJhci50aXRsZSh0aGlzLnJlcXVlc3REYXRhLnRpdGxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRpdGxlIG11c3QgYmUgZW1wdHlcbiAgICAgICAgdGhpcy5uYXZCYXIudGl0bGUoJycpO1xuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCh0aGlzLnJlcXVlc3REYXRhLm5hdlRpdGxlIHx8ICcnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluaykge1xuICAgICAgICB0aGlzLmNvbnZlcnRUb0NhbmNlbEFjdGlvbih0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCksIHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSZXNldCB0byBkZWZhdWx0cywgb3IgZ2l2ZW4gdGl0bGU6XG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5tb2RlbC51cGRhdGVXaXRoKHRoaXMuZGVmYXVsdExlZnRBY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YS5uYXZUaXRsZSlcbiAgICAgICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KHRoaXMucmVxdWVzdERhdGEubmF2VGl0bGUpO1xuICAgICAgICAvLyBVc2VzIGEgY3VzdG9tIGhhbmRsZXIgc28gaXQgcmV0dXJucyBrZWVwaW5nIHRoZSBnaXZlbiBzdGF0ZTpcbiAgICAgICAgdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLmhhbmRsZXIodGhpcy5yZXR1cm5SZXF1ZXN0KTtcbiAgICB9XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIC8vIFJlc2V0XG4gICAgaWYgKHRoaXMudmlld01vZGVsLmNvbXBvbmVudCgpKVxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5jb21wb25lbnQoKS5yZXNldCgpO1xuICAgIFxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIFBhcmFtZXRlcnM6IHBhc3MgYSByZXF1aXJlZCBkdXJhdGlvblxuICAgIHRoaXMudmlld01vZGVsLmNvbXBvbmVudCgpLnJlcXVpcmVkRHVyYXRpb25NaW51dGVzKHRoaXMucmVxdWVzdERhdGEucmVxdWlyZWREdXJhdGlvbiB8MCk7XG5cbiAgICAvLyBQcmVzZWxlY3QgdXNlcklEIGFuZCBhIGRhdGUsIG9yIGN1cnJlbnQgZGF0ZVxuICAgIHRoaXMudmlld01vZGVsLmNvbXBvbmVudCgpLnVzZXJJRCh0aGlzLmFwcC5tb2RlbC51c2VyKCkudXNlcklEKCkpO1xuICAgIHZhciBzZWxEYXRlID0gZ2V0RGF0ZVdpdGhvdXRUaW1lKHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWREYXRldGltZSk7XG4gICAgdGhpcy52aWV3TW9kZWwuY29tcG9uZW50KCkuc2VsZWN0ZWREYXRlKHNlbERhdGUpO1xuICAgIFxuICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcbiAgICB0aGlzLmhlYWRlclRleHQgPSBrby5vYnNlcnZhYmxlKCdTZWxlY3QgYSB0aW1lJyk7XG4gICAgdGhpcy5jb21wb25lbnQgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xufVxuIiwiLyoqXG4gICAgRWR1Y2F0aW9uIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gRWR1Y2F0aW9uQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignTWFya2V0cGxhY2UgUHJvZmlsZScsIHtcbiAgICAgICAgYmFja0xpbms6ICcvbWFya2V0cGxhY2VQcm9maWxlJ1xuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG4gICAgLy8gUmVxdWVzdCBhIHN5bmMgYW5kIGNhdGNoIGFueSBlcnJvclxuICAgIHRoaXMuYXBwLm1vZGVsLmVkdWNhdGlvbi5zeW5jKClcbiAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgbG9hZGluZyBlZHVjYXRpb24gaW5mb3JtYXRpb24nLFxuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBhcHAubW9kZWwuZWR1Y2F0aW9uLnN0YXRlLmlzTG9hZGluZztcbiAgICB0aGlzLmlzU3luY2luZyA9IGFwcC5tb2RlbC5lZHVjYXRpb24uc3RhdGUuaXNTeW5jaW5nO1xuXG4gICAgdGhpcy5saXN0ID0gYXBwLm1vZGVsLmVkdWNhdGlvbi5saXN0O1xufVxuIiwiLyoqXG4gICAgRWR1Y2F0aW9uRm9ybSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBFZHVjYXRpb25Gb3JtQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5sb2dnZWRVc2VyO1xuXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdFZHVjYXRpb24nKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnVwZGF0ZU5hdkJhclN0YXRlID0gZnVuY3Rpb24gdXBkYXRlTmF2QmFyU3RhdGUoKSB7XG5cbiAgICB2YXIgbGluayA9IHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayB8fCAnL2VkdWNhdGlvbi8nO1xuICAgIFxuICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgbGluayk7XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIFJlc2V0XG4gICAgdGhpcy52aWV3TW9kZWwudmVyc2lvbihudWxsKTtcblxuICAgIC8vIFBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cyB8fCBbXTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbC5lZHVjYXRpb25JRChwYXJhbXNbMF0gfDApO1xuICAgIFxuICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcbiAgICBcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuZWR1Y2F0aW9uSUQoKSA9PT0gMCkge1xuICAgICAgICAvLyBORVcgb25lXG4gICAgICAgIHRoaXMudmlld01vZGVsLnZlcnNpb24odGhpcy5hcHAubW9kZWwuZWR1Y2F0aW9uLm5ld0l0ZW0oKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBMT0FEXG4gICAgICAgIHRoaXMuYXBwLm1vZGVsLmVkdWNhdGlvbi5jcmVhdGVJdGVtVmVyc2lvbih0aGlzLnZpZXdNb2RlbC5lZHVjYXRpb25JRCgpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZWR1Y2F0aW9uVmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKGVkdWNhdGlvblZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC52ZXJzaW9uKGVkdWNhdGlvblZlcnNpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZy4nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBjbG9zZSBtb2RhbCwgZ28gYmFja1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjaygpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmVkdWNhdGlvbklEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5lZHVjYXRpb24uc3RhdGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBhcHAubW9kZWwuZWR1Y2F0aW9uLnN0YXRlLmlzU2F2aW5nO1xuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLmVkdWNhdGlvbi5zdGF0ZS5pc1N5bmNpbmc7XG4gICAgdGhpcy5pc0RlbGV0aW5nID0gYXBwLm1vZGVsLmVkdWNhdGlvbi5zdGF0ZS5pc0RlbGV0aW5nO1xuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEZWxldGluZygpIHx8IGFwcC5tb2RlbC5lZHVjYXRpb24uc3RhdGUuaXNMb2NrZWQoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLnZlcnNpb24gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIHRoaXMuaXRlbSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnNpb24oKTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5pc05ldyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLml0ZW0oKTtcbiAgICAgICAgcmV0dXJuIHAgJiYgIXAudXBkYXRlZERhdGUoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnTG9hZGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmluZyBjaGFuZ2VzJyA6IFxuICAgICAgICAgICAgICAgICAgICB2ICYmIHYuYXJlRGlmZmVyZW50KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmUgY2hhbmdlcycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmVkJ1xuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy51bnNhdmVkQ2hhbmdlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIHYgJiYgdi5hcmVEaWZmZXJlbnQoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmRlbGV0ZVRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzRGVsZXRpbmcoKSA/IFxuICAgICAgICAgICAgICAgICdEZWxldGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAnRGVsZXRlJ1xuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwcC5tb2RlbC5lZHVjYXRpb24uc2V0SXRlbSh0aGlzLml0ZW0oKS5tb2RlbC50b1BsYWluT2JqZWN0KCkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZXJzaW9uIHdpdGggc2VydmVyIGRhdGEuXG4gICAgICAgICAgICB0aGlzLml0ZW0oKS5tb2RlbC51cGRhdGVXaXRoKHNlcnZlckRhdGEpO1xuICAgICAgICAgICAgLy8gUHVzaCB2ZXJzaW9uIHNvIGl0IGFwcGVhcnMgYXMgc2F2ZWRcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbigpLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vIEdvIG91dFxuICAgICAgICAgICAgYXBwLnN1Y2Nlc3NTYXZlKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHNhdmluZy4nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmNvbmZpcm1SZW1vdmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEwxOE5cbiAgICAgICAgYXBwLm1vZGFscy5jb25maXJtKHtcbiAgICAgICAgICAgIHRpdGxlOiAnRGVsZXRlJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdBcmUgeW91IHN1cmU/IFRoZSBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nLFxuICAgICAgICAgICAgeWVzOiAnRGVsZXRlJyxcbiAgICAgICAgICAgIG5vOiAnS2VlcCdcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwcC5tb2RlbC5lZHVjYXRpb24uZGVsSXRlbSh0aGlzLmVkdWNhdGlvbklEKCkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gR28gb3V0XG4gICAgICAgICAgICAvLyBUT0RPOiBjdXN0b20gbWVzc2FnZT8/XG4gICAgICAgICAgICBhcHAuc3VjY2Vzc1NhdmUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZGVsZXRpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMueWVhcnNPcHRpb25zID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7IGkgPiAxOTAwOyBpLS0pIHtcbiAgICAgICAgICAgIGwucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbDtcbiAgICB9KTtcbn1cbiIsIi8qKlxuICAgIEZhcXMgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBGYXFzQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwoKTtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1RhbGsgdG8gdXMnKTtcbiAgICBcbiAgICAvLyBUZXN0aW5nRGF0YVxuICAgIC8vc2V0U29tZVRlc3RpbmdEYXRhKHRoaXMudmlld01vZGVsKTtcbiAgICB0aGlzLmN1cnJlbnRMYWJlbHMgPSAnJztcbiAgICB0aGlzLmxvYWRBcnRpY2xlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vbG9jb25vbWljcy56ZW5kZXNrLmNvbS9hcGkvdjIvaGVscF9jZW50ZXIvYXJ0aWNsZXMuanNvbj9sYWJlbF9uYW1lcz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuY3VycmVudExhYmVscyk7XG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIHZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgkLmdldCh1cmwpKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmZhcXMocmVzLmFydGljbGVzLm1hcChmdW5jdGlvbihhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGYXEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGFydC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhcnQudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYXJ0LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuZmFxcyhbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbigvKmVyciovKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwuc2VhcmNoVGV4dCgnJyk7XG4gICAgdGhpcy5sb2FkQXJ0aWNsZXMoKTtcbn07XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbCgpIHtcblxuICAgIHRoaXMuZmFxcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBcbiAgICB0aGlzLmZpbHRlcmVkRmFxcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXJjaFRleHQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mYXFzKCkuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciBuID0gdiAmJiB2LnRpdGxlKCkgfHwgJyc7XG4gICAgICAgICAgICBuICs9IHYgJiYgdi5kZXNjcmlwdGlvbigpIHx8ICcnO1xuICAgICAgICAgICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuLmluZGV4T2YocykgPiAtMTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpO1xuZnVuY3Rpb24gRmFxKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgaWQ6IDAsXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICcnXG4gICAgfSwgdmFsdWVzKTtcbn1cblxuLyoqIFRFU1RJTkcgREFUQSAqKi9cbi8vZnVuY3Rpb24gc2V0U29tZVRlc3RpbmdEYXRhKHZpZXdNb2RlbCkge1xuLy8gICAgXG4vLyAgICB2YXIgdGVzdGRhdGEgPSBbXG4vLyAgICAgICAgbmV3IEZhcSh7XG4vLyAgICAgICAgICAgIGlkOiAxLFxuLy8gICAgICAgICAgICB0aXRsZTogJ0hvdyBkbyBJIHNldCB1cCBhIG1hcmtldHBsYWNlIHByb2ZpbGU/Jyxcbi8vICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEZXNjcmlwdGlvbiBhYm91dCBob3cgSSBzZXQgdXAgYSBtYXJrZXRwbGFjZSBwcm9maWxlJ1xuLy8gICAgICAgIH0pLFxuLy8gICAgICAgIG5ldyBGYXEoe1xuLy8gICAgICAgICAgICBpZDogMixcbi8vICAgICAgICAgICAgdGl0bGU6ICdBbm90aGVyIGZhcScsXG4vLyAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQW5vdGhlciBkZXNjcmlwdGlvbidcbi8vICAgICAgICB9KVxuLy8gICAgXTtcbi8vICAgIHZpZXdNb2RlbC5mYXFzKHRlc3RkYXRhKTtcbi8vfVxuXG4iLCIvKipcbiAgICBGZWVkYmFjayBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEZlZWRiYWNrQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5sb2dnZWRVc2VyO1xuICAgIFxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignVGFsayB0byB1cycpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcbiIsIi8qKlxuICAgIEZlZWRiYWNrRm9ybSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBWb2NFbGVtZW50RW51bSA9IHJlcXVpcmUoJy4uL21vZGVscy9Wb2NFbGVtZW50RW51bScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gRmVlZGJhY2tGb3JtQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIFxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5sb2dnZWRVc2VyO1xuICAgIFxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignVGFsayB0byB1cycpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcGFyYW1zID0gdGhpcy5yZXF1ZXN0RGF0YS5yb3V0ZS5zZWdtZW50cyB8fCBbXTtcbiAgICB2YXIgZWxlbWVudE5hbWUgPSBwYXJhbXNbMF0gfHwgJycsXG4gICAgICAgIGVsZW1lbnRJRCA9IFZvY0VsZW1lbnRFbnVtW2VsZW1lbnROYW1lXSB8MDtcbiAgICBcbiAgICBpZiAoIWVsZW1lbnROYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGZWVkYmFjayBJZGVhczogQWNjZXNzaW5nIGZlZWRiYWNrIHdpdGhvdXQgc3BlY2lmeSBhbiBlbGVtZW50LCB1c2luZyBHZW5lcmFsICgwKScpO1xuICAgIH1cbiAgICBlbHNlIGlmICghVm9jRWxlbWVudEVudW0uaGFzT3duUHJvcGVydHkoZWxlbWVudE5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZlZWRiYWNrIElkZWFzOiBnaXZlbiBhIGJhZCBWT0MgRWxlbWVudCBuYW1lOicsIGVsZW1lbnROYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdNb2RlbC52b2NFbGVtZW50SUQoZWxlbWVudElEKTtcbn07XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgXG4gICAgdGhpcy5tZXNzYWdlID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgdGhpcy5iZWNvbWVDb2xsYWJvcmF0b3IgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLndhc1NlbnQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmlzU2VuZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMudm9jRWxlbWVudElEID0ga28ub2JzZXJ2YWJsZSgwKTtcblxuICAgIHZhciB1cGRhdGVXYXNTZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud2FzU2VudChmYWxzZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZS5zdWJzY3JpYmUodXBkYXRlV2FzU2VudCk7XG4gICAgdGhpcy5iZWNvbWVDb2xsYWJvcmF0b3Iuc3Vic2NyaWJlKHVwZGF0ZVdhc1NlbnQpO1xuICAgIFxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTZW5kaW5nKCkgPyAnU2VuZGluZy4uJyA6IHRoaXMud2FzU2VudCgpID8gJ1NlbnQnIDogJ1NlbmQnO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICAgIHRoaXMuaXNTZW5kaW5nKHRydWUpO1xuICAgICAgICBhcHAubW9kZWwuZmVlZGJhY2sucG9zdElkZWEoe1xuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlKCksXG4gICAgICAgICAgICBiZWNvbWVDb2xsYWJvcmF0b3I6IHRoaXMuYmVjb21lQ29sbGFib3JhdG9yKCksXG4gICAgICAgICAgICB2b2NFbGVtZW50SUQ6IHRoaXMudm9jRWxlbWVudElEKClcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZXNldCBhZnRlciBiZWluZyBzZW50XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UoJycpO1xuICAgICAgICAgICAgdGhpcy5iZWNvbWVDb2xsYWJvcmF0b3IoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy53YXNTZW50KHRydWUpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciBzZW5kaW5nIHlvdXIgZmVlZGJhY2snLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEFsd2F5c1xuICAgICAgICAgICAgdGhpcy5pc1NlbmRpbmcoZmFsc2UpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcbn1cbiIsIi8qKlxuICAgIEhvbWUgYWN0aXZpdHkgKGFrYSBTZWFyY2gpXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIHNuYXBQb2ludHMgPSByZXF1aXJlKCcuLi91dGlscy9zbmFwUG9pbnRzJyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBIb21lQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMubmF2QmFyID0gbnVsbDtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gbnVsbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHtcbiAgICAgICAgaXNBbm9ueW1vdXM6IHRoaXMuYXBwLm1vZGVsLnVzZXIoKS5pc0Fub255bW91c1xuICAgIH07XG4gICAgdmFyICRoZWFkZXIgPSB0aGlzLiRoZWFkZXIgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCdoZWFkZXInKTtcblxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRhY3Rpdml0eSxcbiAgICAgICAgZXZlbnQ6ICdzY3JvbGwtZml4ZWQtaGVhZGVyJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSwgd2hhdCkge1xuICAgICAgICAgICAgaWYgKHdoYXQgPT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgICAgICAkaGVhZGVyLmFkZENsYXNzKCdpcy1maXhlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJGhlYWRlci5yZW1vdmVDbGFzcygnaXMtZml4ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGFjdGl2aXR5LFxuICAgICAgICBldmVudDogJ3Njcm9sbC1zZWFyY2gnLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlLCB3aGF0KSB7XG4gICAgICAgICAgICBpZiAod2hhdCA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgICAgICRoZWFkZXIuYWRkQ2xhc3MoJ2lzLXNlYXJjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJGhlYWRlci5yZW1vdmVDbGFzcygnaXMtc2VhcmNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLl9yZWdpc3RlclNuYXBQb2ludHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciAkc2VhcmNoQm94ID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnI2hvbWVTZWFyY2gnKSxcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSBzZWFyY2ggYm94IGlzIGNvbXBsZXRlbHkgaGlkZGVuLCBhbmQgZ2V0IDEgb24gdGhlIHdvcnNlIGNhc2UgLS0gYmFkIHZhbHVlIGNvZXJjZWQgdG8gMCxcbiAgICAgICAgLy8gbmVnYXRpdmUgcmVzdWx0IGJlY2F1c2Ugc29tZSBsYWNrIG9mIGRhdGEgKGNvbnRlbnQgaGlkZGVuKVxuICAgICAgICBzZWFyY2hQb2ludCA9IE1hdGgubWF4KDEsIChcbiAgICAgICAgICAgIC8vIFRvcCBvZmZzZXQgd2l0aCB0aGUgc2Nyb2xsaW5nIGFyZWEgcGx1cyBjdXJyZW50IHNjcm9sbFRvcCB0byBrbm93IHRoZSBhY3R1YWwgcG9zaXRpb24gaW5zaWRlIHRoZSBwb3NpdGlvbmluZyBjb250ZXh0XG4gICAgICAgICAgICAvLyAoaXMgYW4gaXNzdWUgaWYgdGhlIHNlY3Rpb24gaXMgc2hvd2VkIHdpdGggc2Nyb2xsIGFwcGxpZWQgb24gdGhlIGFjdGl2aXR5KVxuICAgICAgICAgICAgJHNlYXJjaEJveC5vZmZzZXQoKS50b3AgKyB0aGlzLiRhY3Rpdml0eS5zY3JvbGxUb3AoKSArXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGJveCBoZWlnaHQgYnV0IHN1c3RyYWN0IHRoZSBoZWFkZXIgaGVpZ2h0IGJlY2F1c2UgdGhhdCBpcyBmaXhlZCBhbmQgb3ZlcmxhcHNcbiAgICAgICAgICAgICRzZWFyY2hCb3gub3V0ZXJIZWlnaHQoKSAtIHRoaXMuJGhlYWRlci5vdXRlckhlaWdodCgpXG4gICAgICAgICkgfDApO1xuICAgIFxuICAgIHZhciBwb2ludHNFdmVudHMgPSB7XG4gICAgICAgIC8vIEp1c3QgYWZ0ZXIgc3RhcnQgc2Nyb2xsaW5nXG4gICAgICAgIDA6ICdzY3JvbGwtZml4ZWQtaGVhZGVyJ1xuICAgIH07XG4gICAgcG9pbnRzRXZlbnRzW3NlYXJjaFBvaW50XSA9ICdzY3JvbGwtc2VhcmNoJztcblxuICAgIHNuYXBQb2ludHModGhpcy4kYWN0aXZpdHksIHBvaW50c0V2ZW50cyk7XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIGlmICghdGhpcy5fbm90Rmlyc3RTaG93KSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyU25hcFBvaW50cygpO1xuICAgICAgICB0aGlzLl9ub3RGaXJzdFNob3cgPSB0cnVlO1xuICAgIH1cbn07XG4iLCIvKipcbiAgICBJbmJveCBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgTWVzc2FnZVZpZXcgPSByZXF1aXJlKCcuLi9tb2RlbHMvTWVzc2FnZVZpZXcnKSxcbiAgICB0ZXh0U2VhcmNoID0gcmVxdWlyZSgnLi4vdXRpbHMvdGV4dFNlYXJjaCcpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gSW5ib3hBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCdJbmJveCcpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG4gICAgLy8gTWVzc2FnZXNcbiAgICB0aGlzLmFwcC5tb2RlbC5tZXNzYWdpbmcuZ2V0TGlzdCgpXG4gICAgLnRoZW4oZnVuY3Rpb24odGhyZWFkcykge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbC5zb3VyY2VUaHJlYWRzKHRocmVhZHMoKSk7XG4gICAgfS5iaW5kKHRoaXMpKVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgbWVzc2FnZXMnLFxuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuICAgIFxuICAgIHRoaXMuaXNMb2FkaW5nID0gYXBwLm1vZGVsLm1lc3NhZ2luZy5zdGF0ZS5pc0xvYWRpbmc7XG4gICAgdGhpcy5pc1N5bmNpbmcgPSBhcHAubW9kZWwubWVzc2FnaW5nLnN0YXRlLmlzU3luY2luZztcblxuICAgIHRoaXMuc291cmNlVGhyZWFkcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgXG4gICAgLy8gTk9URTogc2luY2UgY3VycmVudCBBUEktY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBvbmx5IGdldHNcbiAgICAvLyB0aGUgbGF0ZXN0IG1lc3NhZ2Ugd2l0aCBnZXRMaXN0LCB0aGUgc2VhcmNoIGlzIGRvbmUgaW4gdGhlXG4gICAgLy8gYm9keVRleHQgb2YgdGhlIGxhc3QgbWVzc2FnZSAoYWRkaXRpb25hbGx5IHRvIHRoZSB0aHJlYWQgc3ViamVjdClcbiAgICAvLyBldmVuIGlmIHRoaXMgaW1wbGVtZW50YXRpb24gdHJ5IHRvIGl0ZXJhdGUgYWxsIG1lc3NhZ2VzLlxuICAgIHRoaXMudGhyZWFkcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnNvdXJjZVRocmVhZHMoKSxcbiAgICAgICAgICAgIHMgPSB0aGlzLnNlYXJjaFRleHQoKTtcblxuICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGVsc2UgaWYgKCFzKVxuICAgICAgICAgICAgcmV0dXJuIHQubWFwKE1lc3NhZ2VWaWV3LmZyb21UaHJlYWQuYmluZChudWxsLCBhcHApKTtcbiAgICAgICAgZWxzZSAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdC5maWx0ZXIoZnVuY3Rpb24odGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgc3ViamVjdFxuICAgICAgICAgICAgICAgIGZvdW5kID0gdGV4dFNlYXJjaChzLCB0aHJlYWQuc3ViamVjdCgpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBjb250ZW50IG9mIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IHN0b3BzIG9uIGZpcnN0ICd0cnVlJyByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgdGhyZWFkLm1lc3NhZ2VzKCkuc29tZShmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdGV4dFNlYXJjaChzLCBtc2cuYm9keVRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9KS5tYXAoTWVzc2FnZVZpZXcuZnJvbVRocmVhZC5iaW5kKG51bGwsIGFwcCkpO1xuICAgIH0sIHRoaXMpO1xufVxuIiwiLyoqXG4gICAgSW5kZXggYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBJbmRleEFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBBbnkgdXNlciBjYW4gYWNjZXNzIHRoaXNcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gbnVsbDtcbiAgICBcbiAgICAvLyBudWxsIGZvciBsb2dvXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKG51bGwpO1xuICAgIHRoaXMubmF2QmFyLnJpZ2h0QWN0aW9uKG51bGwpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICBcbiAgICAvLyBJdCBjaGVja3MgaWYgdGhlIHVzZXIgaXMgbG9nZ2VkIHNvIHRoZW4gXG4gICAgLy8gdGhlaXIgJ2xvZ2dlZCBpbmRleCcgaXMgdGhlIGRhc2hib2FyZCBub3QgdGhpc1xuICAgIC8vIHBhZ2UgdGhhdCBpcyBmb2N1c2VkIG9uIGFub255bW91cyB1c2Vyc1xuICAgIGlmICghdGhpcy5hcHAubW9kZWwudXNlcigpLmlzQW5vbnltb3VzKCkpIHtcbiAgICAgICAgdGhpcy5hcHAuZ29EYXNoYm9hcmQoKTtcbiAgICB9XG59O1xuIiwiLyoqXG4gICAgSm9idGl0bGVzIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEpvYnRpdGxlc0FjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1NjaGVkdWxpbmcnLCB7XG4gICAgICAgIGJhY2tMaW5rOiAnL3NjaGVkdWxpbmcnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gT24gY2hhbmdpbmcgam9iVGl0bGVJRDpcbiAgICAvLyAtIGxvYWQgYWRkcmVzc2VzXG4gICAgLy8gLSBsb2FkIGpvYiB0aXRsZSBpbmZvcm1hdGlvblxuICAgIC8vIC0gbG9hZCBwcmljaW5nXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcblxuICAgICAgICAgICAgaWYgKGpvYlRpdGxlSUQpIHtcbiAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICAvLyBBZGRyZXNzZXNcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldExpc3Qoam9iVGl0bGVJRClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuYXNNb2RlbChsaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc2VzKGxpc3QpO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyBhZGRyZXNzZXMuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICAvLyBQcmljaW5nL1NlcnZpY2VzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLmdldExpc3Qoam9iVGl0bGVJRClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5hc01vZGVsKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcmljaW5nKGxpc3QpO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyBzZXJ2aWNlcy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vIEpvYiBUaXRsZVxuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwuam9iVGl0bGVzLmdldEpvYlRpdGxlKGpvYlRpdGxlSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oam9iVGl0bGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWxsIGluIGpvYiB0aXRsZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlTmFtZShqb2JUaXRsZS5zaW5ndWxhck5hbWUoKSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBqb2IgdGl0bGUuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZHJlc3NlcyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucHJpY2luZyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVOYW1lKCdKb2IgVGl0bGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuXG4gICAgLy8gUmVzZXQ6IGF2b2lkaW5nIGVycm9ycyBiZWNhdXNlIHBlcnNpc3RlZCBkYXRhIGZvciBkaWZmZXJlbnQgSUQgb24gbG9hZGluZ1xuICAgIC8vIG9yIG91dGRhdGVkIGluZm8gZm9yY2luZyB1cGRhdGVcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKDApO1xuXG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cyB8fCB7fTtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGpvYiB0aXRsZVxuICAgIHZhciBqb2JJRCA9IHBhcmFtc1swXSB8MDtcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYklEKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMuam9iVGl0bGVOYW1lID0ga28ub2JzZXJ2YWJsZSgnSm9iIFRpdGxlJyk7XG4gICAgXG4gICAgLy8gUmV0cmlldmVzIGEgY29tcHV0ZWQgdGhhdCB3aWxsIGxpbmsgdG8gdGhlIGdpdmVuIG5hbWVkIGFjdGl2aXR5IGFkZGluZyB0aGUgY3VycmVudFxuICAgIC8vIGpvYlRpdGxlSUQgYW5kIGEgbXVzdFJldHVybiBVUkwgdG8gcG9pbnQgdGhpcyBwYWdlIHNvIGl0cyByZW1lbWJlciB0aGUgYmFjayByb3V0ZVxuICAgIHRoaXMuZ2V0Sm9iVXJsVG8gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIC8vIFNhbXBsZSAnL3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy8nICsgam9iVGl0bGVJRCgpXG4gICAgICAgIHJldHVybiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICcvJyArIG5hbWUgKyAnLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICc/bXVzdFJldHVybj1qb2J0aXRsZXMvJyArIHRoaXMuam9iVGl0bGVJRCgpICtcbiAgICAgICAgICAgICAgICAnJnJldHVyblRleHQ9JyArIHRoaXMuam9iVGl0bGVOYW1lKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5hZGRyZXNzZXMgPSBrby5vYnNlcnZhYmxlKFtdKTtcbiAgICB0aGlzLnByaWNpbmcgPSBrby5vYnNlcnZhYmxlKFtdKTtcblxuICAgIC8vIENvbXB1dGVkIHNpbmNlIGl0IGNhbiBjaGVjayBzZXZlcmFsIGV4dGVybmEgbG9hZGluZ3NcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnN0YXRlLmlzTG9hZGluZygpIHx8XG4gICAgICAgICAgICBhcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLnN0YXRlLmlzTG9hZGluZygpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuYWRkcmVzc2VzQ291bnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPIGwxMG4uXG4gICAgICAgIC8vIFVzZSBpMThuZXh0IHBsdXJhbCBsb2NhbGl6YXRpb24gc3VwcG9ydCByYXRoZXIgdGhhbiB0aGlzIG1hbnVhbC5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5hZGRyZXNzZXMoKS5sZW5ndGgsXG4gICAgICAgICAgICBvbmUgPSAnMSBsb2NhdGlvbicsXG4gICAgICAgICAgICBtb3JlID0gJyBsb2NhdGlvbnMnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG9uZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gU21hbGwgbnVtYmVycywgbm8gbmVlZCBmb3IgZm9ybWF0dGluZ1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgbW9yZTtcblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMucHJpY2luZ0NvdW50ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgLy8gVE9ETyBsMTBuLlxuICAgICAgICAvLyBVc2UgaTE4bmV4dCBwbHVyYWwgbG9jYWxpemF0aW9uIHN1cHBvcnQgcmF0aGVyIHRoYW4gdGhpcyBtYW51YWwuXG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMucHJpY2luZygpLmxlbmd0aCxcbiAgICAgICAgICAgIG9uZSA9ICcxIHNlcnZpY2UnLFxuICAgICAgICAgICAgbW9yZSA9ICcgc2VydmljZXMnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG9uZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gU21hbGwgbnVtYmVycywgbm8gbmVlZCBmb3IgZm9ybWF0dGluZ1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgbW9yZTtcblxuICAgIH0sIHRoaXMpO1xuICAgIFxufVxuIiwiLyoqXG4gICAgTGVhcm5Nb3JlIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBMZWFybk1vcmVBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IG51bGw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICAvLyBudWxsIGZvciBsb2dvXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKG51bGwpO1xuICAgIHRoaXMubmF2QmFyLnJpZ2h0QWN0aW9uKG51bGwpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yb3V0ZSAmJlxuICAgICAgICBvcHRpb25zLnJvdXRlLnNlZ21lbnRzICYmXG4gICAgICAgIG9wdGlvbnMucm91dGUuc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudmlld01vZGVsLnByb2ZpbGUob3B0aW9ucy5yb3V0ZS5zZWdtZW50c1swXSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKCkge1xuICAgIHRoaXMucHJvZmlsZSA9IGtvLm9ic2VydmFibGUoJ2NsaWVudCcpO1xufVxuIiwiLyoqXG4gICAgTGljZW5zZXNDZXJ0aWZpY2F0aW9ucyBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gTGljZW5zZXNDZXJ0aWZpY2F0aW9uc0FjdGl2aXR5KCkge1xuXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5zZXJ2aWNlUHJvZmVzc2lvbmFsO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgLy8gRGVmYXVsdHMgc2V0dGluZ3MgZm9yIG5hdkJhci5cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0pvYiBUaXRsZScpO1xuXG4gICAgLy8gT24gY2hhbmdpbmcgam9iVGl0bGVJRDpcbiAgICAvLyAtIGxvYWQgbGljZW5zZXMvY2VydGlmaWNhdGlvbnNcbiAgICAvKiBUT0RPIFVuY29tbWVudCBhbmQgdXBkYXRlIG9uIGltcGxlbWVudGluZyBSRVNUIEFQSSBBcHBNb2RlbFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlELFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XG4gICAgICAgICAgICBpZiAoam9iVGl0bGVJRCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwubGljZW5zZXNDZXJ0aWZpY2F0aW9ucy5nZXRMaXN0KGpvYlRpdGxlSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIGZvciB1c2UgaW4gdGhlIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwubGlzdChsaXN0KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5saXN0KFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7Ki9cbiAgICAvLyBUT0RPIFJlbW92ZSBvbiBpbXBsZW1lbnRlZCBSRVNUIEFQSVxuICAgIHRoaXMudmlld01vZGVsLmxpc3QodGVzdGRhdGEoKSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHZhciBwYXJhbXMgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cztcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKHBhcmFtc1swXSB8MCk7XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMubGlzdCA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgXG4gICAgdGhpcy5pc1N5bmNpbmcgPSBhcHAubW9kZWwubGljZW5zZXNDZXJ0aWZpY2F0aW9ucy5zdGF0ZS5pc1N5bmNpbmcoKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGFwcC5tb2RlbC5saWNlbnNlc0NlcnRpZmljYXRpb25zLnN0YXRlLmlzTG9hZGluZygpO1xuXG4gICAgdGhpcy5hZGROZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVybCA9ICcjIWxpY2Vuc2VzQ2VydGlmaWNhdGlvbnNGb3JtLycgKyB0aGlzLmpvYlRpdGxlSUQoKSxcbiAgICAgICAgICAgIGNhbmNlbFVybCA9IGFwcC5zaGVsbC5jdXJyZW50Um91dGUudXJsO1xuICAgICAgICB2YXIgcmVxdWVzdCA9ICQuZXh0ZW5kKHt9LCB0aGlzLnJlcXVlc3REYXRhLCB7XG4gICAgICAgICAgICBjYW5jZWxMaW5rOiBjYW5jZWxVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcC5zaGVsbC5nbyh1cmwsIHJlcXVlc3QpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnNlbGVjdEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciB1cmwgPSAnL2xpY2Vuc2VzQ2VydGlmaWNhdGlvbnNGb3JtLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICcvJyArXG4gICAgICAgICAgICBpdGVtLmxpY2Vuc2VDZXJ0aWZpY2F0aW9uSUQoKSArICc/bXVzdFJldHVybj0nICsgXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoYXBwLnNoZWxsLmN1cnJlbnRSb3V0ZS51cmwpICtcbiAgICAgICAgICAgICcmcmV0dXJuVGV4dD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KCdDZXJ0aWZpY2F0aW9ucy9MaWNlbnNlcycpO1xuICAgICAgICBhcHAuc2hlbGwuZ28odXJsLCB0aGlzLnJlcXVlc3REYXRhKTtcbiAgICB9LmJpbmQodGhpcyk7XG59XG5cblxuICAgICAgICAgICAgICAgXG4vLyBUT0RPIFNBTUUgQ09ERSBBUyBJTiB2ZXJpZmljYXRpb25zIGFjdGl2aXR5LCB0byByZWZhY3RvciBhbmQgc2hhcmVcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpO1xuZnVuY3Rpb24gVmVyaWZpY2F0aW9uKHZhbHVlcykge1xuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIG5hbWU6ICcnXG4gICAgfSwgdmFsdWVzKTtcbn1cblZlcmlmaWNhdGlvbi5zdGF0dXMgPSB7XG4gICAgY29uZmlybWVkOiAxLFxuICAgIHBlbmRpbmc6IDIsXG4gICAgcmV2b2tlZDogMyxcbiAgICBvYnNvbGV0ZTogNFxufTtcbmZ1bmN0aW9uIGVudW1HZXROYW1lKHZhbHVlLCBlbnVtTGlzdCkge1xuICAgIHZhciBmb3VuZCA9IG51bGw7XG4gICAgT2JqZWN0LmtleXMoZW51bUxpc3QpLnNvbWUoZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoZW51bUxpc3Rba10gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGs7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuXG4vLy8gVEVTVERBVEFcbnZhciBVc2VyTGljZW5zZUNlcnRpZmljYXRpb24gPSByZXF1aXJlKCcuLi9tb2RlbHMvVXNlckxpY2Vuc2VDZXJ0aWZpY2F0aW9uJyk7XG52YXIgTGljZW5zZUNlcnRpZmljYXRpb24gPSByZXF1aXJlKCcuLi9tb2RlbHMvTGljZW5zZUNlcnRpZmljYXRpb24nKTtcbmZ1bmN0aW9uIHRlc3RkYXRhKCkge1xuICAgIFxuICAgIHZhciBiYXNlID0ge1xuICAgICAgICAxNzogbmV3IExpY2Vuc2VDZXJ0aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIGxpY2Vuc2VDZXJ0aWZpY2F0aW9uSUQ6IDE3LFxuICAgICAgICAgICAgbmFtZTogJ0NlcnRpZmllZCBNYXNzYWdlIFRoZXJhcGlzdCAoQ01UKScsXG4gICAgICAgICAgICBzdGF0ZVByb3ZpbmNlSUQ6IDEsXG4gICAgICAgICAgICBjb3VudHJ5SUQ6IDEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1JlcXVpcmVkIHRvIGNvbXBsZXRlIGF0IGxlYXN0IDUwMCBob3VycyBvZiBtYXNzYWdlIGVkdWNhdGlvbiBhbmQgdHJhaW5pbmcgYXQgYW4gYXBwcm92ZWQgbWFzc2FnZSB0aGVyYXB5IHNjaG9vbC4gIENNVHMgYWxzbyBtdXN0IHVuZGVyZ28gYmFja2dyb3VuZCBjaGVja3MsIGluY2x1ZGluZyBmaW5nZXJwcmludGluZyBhbmQgb3RoZXIgaWRlbnRpZmljYXRpb24gdmVyaWZpY2F0aW9uIHByb2NlZHVyZXMuJyxcbiAgICAgICAgICAgIGF1dGhvcml0eTogJ1RoZSBDYWxpZm9ybmlhIE1hc3NhZ2UgVGhlcmFweSBDb3VuY2lsIChDQU1UQyknLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uV2Vic2l0ZVVybDogJ2h0dHBzOi8vd3d3LmNhbXRjLm9yZy9WZXJpZnlDZXJ0aWZpY2F0aW9uLmFzcHgnLFxuICAgICAgICAgICAgaG93VG9HZXRMaWNlbnNlZFVybDogJ2h0dHBzOi8vd3d3LmNhbXRjLm9yZy9Gb3JtRG93bmxvYWRzL0NBTVRDQXBwbGljYXRpb25DaGVja2xpc3QucGRmJyxcbiAgICAgICAgICAgIG9wdGlvbkdyb3VwOiAnQ2VydGlmaWVkIE1hc3NhZ2UnLFxuICAgICAgICAgICAgY3JlYXRlZERhdGU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB1cGRhdGVkRGF0ZTogbmV3IERhdGUoKVxuICAgICAgICB9KSxcbiAgICAgICAgMTg6IG5ldyBMaWNlbnNlQ2VydGlmaWNhdGlvbih7XG4gICAgICAgICAgICBsaWNlbnNlQ2VydGlmaWNhdGlvbklEOiAxOCxcbiAgICAgICAgICAgIG5hbWU6ICdDZXJ0aWZpZWQgTWFzc2FnZSBQcmFjdGl0aW9uZXIgKENNUCknLFxuICAgICAgICAgICAgc3RhdGVQcm92aW5jZUlEOiAxLFxuICAgICAgICAgICAgY291bnRyeUlEOiAxLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdHZW5lcmFsbHkgbXVzdCBjb21wbGV0ZSBhdCBsZWFzdCAyNTAgaG91cnMgb2YgZWR1Y2F0aW9uIGFuZCB0cmFpbmluZy4gIENNUHMgYWxzbyBtdXN0IHVuZGVyZ28gYmFja2dyb3VuZCBjaGVja3MsIGluY2x1ZGluZyBmaW5nZXJwcmludGluZyBhbmQgb3RoZXIgaWRlbnRpZmljYXRpb24gdmVyaWZpY2F0aW9uIHByb2NlZHVyZXMuJyxcbiAgICAgICAgICAgIGF1dGhvcml0eTogJ1RoZSBDYWxpZm9ybmlhIE1hc3NhZ2UgVGhlcmFweSBDb3VuY2lsIChDQU1UQyknLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uV2Vic2l0ZVVybDogJ2h0dHBzOi8vd3d3LmNhbXRjLm9yZy9WZXJpZnlDZXJ0aWZpY2F0aW9uLmFzcHgnLFxuICAgICAgICAgICAgaG93VG9HZXRMaWNlbnNlZFVybDogJ2h0dHBzOi8vd3d3LmNhbXRjLm9yZy9Gb3JtRG93bmxvYWRzL0NBTVRDQXBwbGljYXRpb25DaGVja2xpc3QucGRmJyxcbiAgICAgICAgICAgIG9wdGlvbkdyb3VwOiAnQ2VydGlmaWVkIE1hc3NhZ2UnLFxuICAgICAgICAgICAgY3JlYXRlZERhdGU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB1cGRhdGVkRGF0ZTogbmV3IERhdGUoKVxuICAgICAgICB9KVxuICAgIH07XG4gICAgXG4gICAgLy8gQXVnbWVudCBNb2RlbCB3aXRoIHJlbGF0ZWQgaW5mb1xuICAgIGZ1bmN0aW9uIGF1Z21lbnQobSkge1xuICAgICAgICBtLmxpY2Vuc2VDZXJ0aWZpY2F0aW9uID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVt0aGlzLmxpY2Vuc2VDZXJ0aWZpY2F0aW9uSUQoKV0gfHwgbnVsbDtcbiAgICAgICAgfSwgbSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPIHN0YXR1c1RleHQgYW5kIGlzU3RhdHVzIGNvcGllZCBmcm9tIHZlcmlmaWNhdGlvbnMsIGRlZHVwZS9yZWZhY3RvclxuICAgICAgICBtLnN0YXR1c1RleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBMMThOXG4gICAgICAgICAgICB2YXIgc3RhdHVzVGV4dHNlblVTID0ge1xuICAgICAgICAgICAgICAgICd2ZXJpZmljYXRpb24uc3RhdHVzLmNvbmZpcm1lZCc6ICdDb25maXJtZWQnLFxuICAgICAgICAgICAgICAgICd2ZXJpZmljYXRpb24uc3RhdHVzLnBlbmRpbmcnOiAnUGVuZGluZycsXG4gICAgICAgICAgICAgICAgJ3ZlcmlmaWNhdGlvbi5zdGF0dXMucmV2b2tlZCc6ICdSZXZva2VkJyxcbiAgICAgICAgICAgICAgICAndmVyaWZpY2F0aW9uLnN0YXR1cy5vYnNvbGV0ZSc6ICdPYnNvbGV0ZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IGVudW1HZXROYW1lKHRoaXMuc3RhdHVzSUQoKSwgVmVyaWZpY2F0aW9uLnN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzVGV4dHNlblVTWyd2ZXJpZmljYXRpb24uc3RhdHVzLicgKyBzdGF0dXNDb2RlXTtcbiAgICAgICAgfSwgbSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBDaGVjayBpZiB2ZXJpZmljYXRpb24gaGFzIGEgZ2l2ZW4gc3RhdHVzIGJ5IG5hbWVcbiAgICAgICAgKiovXG4gICAgICAgIG0uaXNTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzTmFtZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5zdGF0dXNJRCgpO1xuICAgICAgICAgICAgcmV0dXJuIFZlcmlmaWNhdGlvbi5zdGF0dXNbc3RhdHVzTmFtZV0gPT09IGlkO1xuICAgICAgICB9LmJpbmQobSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBhdWdtZW50KG5ldyBVc2VyTGljZW5zZUNlcnRpZmljYXRpb24oe1xuICAgICAgICAgICAgdXNlcklEOiAxNDEsXG4gICAgICAgICAgICBqb2JUaXRsZUlEOiAxMDYsXG4gICAgICAgICAgICBzdGF0dXNJRDogMixcbiAgICAgICAgICAgIGxpY2Vuc2VDZXJ0aWZpY2F0aW9uSUQ6IDE4LFxuICAgICAgICAgICAgbGljZW5zZUNlcnRpZmljYXRpb25OdW1iZXI6IDIxMzQxMjM0LFxuICAgICAgICAgICAgc3RhdGVQcm92aW5jZUlEOiAxLFxuICAgICAgICAgICAgY291bnRyeUlEOiAxLFxuICAgICAgICAgICAgZXhwaXJhdGlvbkRhdGU6IG5ldyBEYXRlKDIwMTYsIDEsIDIwKSxcbiAgICAgICAgICAgIGxhc3RWZXJpZmllZERhdGU6IG5ldyBEYXRlKDIwMTUsIDMsIDIwKSxcbiAgICAgICAgICAgIGNyZWF0ZWREYXRlOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgdXBkYXRlZERhdGU6IG5ldyBEYXRlKClcbiAgICAgICAgfSkpLFxuICAgICAgICBhdWdtZW50KG5ldyBVc2VyTGljZW5zZUNlcnRpZmljYXRpb24oe1xuICAgICAgICAgICAgdXNlcklEOiAxNDEsXG4gICAgICAgICAgICBqb2JUaXRsZUlEOiAxMDYsXG4gICAgICAgICAgICBzdGF0dXNJRDogMSxcbiAgICAgICAgICAgIGxpY2Vuc2VDZXJ0aWZpY2F0aW9uSUQ6IDE3LFxuICAgICAgICAgICAgbGljZW5zZUNlcnRpZmljYXRpb25OdW1iZXI6IDk4NzY1NDMyMSxcbiAgICAgICAgICAgIHN0YXRlUHJvdmluY2VJRDogMSxcbiAgICAgICAgICAgIGNvdW50cnlJRDogMSxcbiAgICAgICAgICAgIGV4cGlyYXRpb25EYXRlOiBuZXcgRGF0ZSgyMDE2LCAxLCAyMCksXG4gICAgICAgICAgICBsYXN0VmVyaWZpZWREYXRlOiBuZXcgRGF0ZSgyMDE1LCAzLCAyMCksXG4gICAgICAgICAgICBjcmVhdGVkRGF0ZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVwZGF0ZWREYXRlOiBuZXcgRGF0ZSgpXG4gICAgICAgIH0pKVxuICAgIF07XG59XG4iLCIvKipcbiAgICBMaWNlbnNlc0NlcnRpZmljYXRpb25zRm9ybSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBMaWNlbnNlc0NlcnRpZmljYXRpb25zRm9ybUFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDtcblxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignQ2VydGlmaWNhdGlvbnMvTGljZW5zZXMnKTtcbiAgICB0aGlzLmRlZmF1bHROYXZCYXJTZXR0aW5ncyA9IHRoaXMubmF2QmFyLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xuXG4gICAgdmFyIGxpbmsgPSB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmsgfHwgJy9saWNlbnNlc0NlcnRpZmljYXRpb25zLyc7XG4gICAgXG4gICAgaWYgKHRoaXMudmlld01vZGVsLmlzTmV3KCkpXG4gICAgICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgbGluayk7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLm5hdkJhci5tb2RlbC51cGRhdGVXaXRoKHRoaXMuZGVmYXVsdE5hdkJhclNldHRpbmdzLCB0cnVlKTtcbn07XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG4gICAgXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLnZpZXdNb2RlbC52ZXJzaW9uKG51bGwpO1xuXG4gICAgLy8gUGFyYW1zXG4gICAgdmFyIHBhcmFtcyA9IHN0YXRlICYmIHN0YXRlLnJvdXRlICYmIHN0YXRlLnJvdXRlLnNlZ21lbnRzIHx8IFtdO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQocGFyYW1zWzBdIHwwKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5saWNlbnNlQ2VydGlmaWNhdGlvbklEKHBhcmFtc1sxXSB8MCk7XG4gICAgXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xuICAgIFxuICAgIC8vIFRPRE8gUmVtb3ZlIHdoZW4gQXBwTW9kZWxcbiAgICB2YXIgTW9kZWxWZXJzaW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvTW9kZWxWZXJzaW9uJyksXG4gICAgICAgIFVzZXJMaWNlbnNlQ2VydGlmaWNhdGlvbiA9IHJlcXVpcmUoJy4uL21vZGVscy9Vc2VyTGljZW5zZUNlcnRpZmljYXRpb24nKTtcbiAgICBcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuaXNOZXcoKSkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbC52ZXJzaW9uKG5ldyBNb2RlbFZlcnNpb24obmV3IFVzZXJMaWNlbnNlQ2VydGlmaWNhdGlvbigpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbC52ZXJzaW9uKG5ldyBNb2RlbFZlcnNpb24obmV3IFVzZXJMaWNlbnNlQ2VydGlmaWNhdGlvbih7XG4gICAgICAgICAgICB1c2VySUQ6IDE0MSxcbiAgICAgICAgICAgIGpvYlRpdGxlSUQ6IDEwNixcbiAgICAgICAgICAgIHN0YXR1c0lEOiAyLFxuICAgICAgICAgICAgbGljZW5zZUNlcnRpZmljYXRpb25JRDogMTgsXG4gICAgICAgICAgICBsaWNlbnNlQ2VydGlmaWNhdGlvbk51bWJlcjogMjEzNDEyMzQsXG4gICAgICAgICAgICBzdGF0ZVByb3ZpbmNlSUQ6IDEsXG4gICAgICAgICAgICBjb3VudHJ5SUQ6IDEsXG4gICAgICAgICAgICBleHBpcmF0aW9uRGF0ZTogbmV3IERhdGUoMjAxNiwgMSwgMjApLFxuICAgICAgICAgICAgbGFzdFZlcmlmaWVkRGF0ZTogbmV3IERhdGUoMjAxNSwgMywgMjApLFxuICAgICAgICAgICAgY3JlYXRlZERhdGU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB1cGRhdGVkRGF0ZTogbmV3IERhdGUoKVxuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICAvLyBUT0RPIElUIERPRVMgTk9UIFdPUktTIFRISVMgV0FZOiBpbiB0aGUgd2Vic2l0ZSBkYWhzYm9hcmQsIHRoZSBsaWNlbnNlSUQgaXMgcHJvdmlkZWRcbiAgICAvLyB0byB0aGUgZm9ybSwgYmVjYXVzZSB0aGVyZSBpcyBhIHNob3J0IGxpc3Qgb2YgdGhlbSBhdmFpbGFibGUsIE5PVCBhdXRvLWdlbmVyYXRlZC5cbiAgICAvLyBDSEVDSyBpZiBwdXQgYSBkcm9wZG93biBzZWxlY3Rpb24gb3IgbGlzdCBzZWxlY3Rpb24gaGVyZSBhbmQgdGhlbiBzaG93IHRoZSBmb3JtIG9yIFxuICAgIC8vIHB1dCB0aGUgbGlzdCBvZiBwb3NzaWJsZSBvbiB0aGUgbGlzdGluZyBwYWdlIChhdCAvbGljZW5zZXNDZXJ0aWZpY2F0aW9ucylcbiAgICBcbiAgICBpZiAodGhpcy52aWV3TW9kZWwubGljZW5zZUNlcnRpZmljYXRpb25JRCgpID09PSAwKSB7XG4gICAgICAgIC8vIE5FVyBvbmVcbiAgICAgICAgLyogVE9ETyBVbmNvbW1lbnQgd2hlbiBBcHBNb2RlbFxuICAgICAgICB0aGlzLnZpZXdNb2RlbC52ZXJzaW9uKHRoaXMuYXBwLm1vZGVsLmxpY2Vuc2VzQ2VydGlmaWNhdGlvbnMubmV3SXRlbSgpKTtcbiAgICAgICAgKi9cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIExPQURcbiAgICAgICAgLyogVE9ETyBVbmNvbW1lbnQgd2hlbiBBcHBNb2RlbFxuICAgICAgICB0aGlzLmFwcC5tb2RlbC5lZHVjYXRpb24uY3JlYXRlSXRlbVZlcnNpb24odGhpcy52aWV3TW9kZWwuZWR1Y2F0aW9uSUQoKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGVkdWNhdGlvblZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmIChlZHVjYXRpb25WZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwudmVyc2lvbihlZHVjYXRpb25WZXJzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gY2xvc2UgbW9kYWwsIGdvIGJhY2tcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2soKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7Ki9cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmxpY2Vuc2VDZXJ0aWZpY2F0aW9uSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgLy8gVE9ETyBVbmNvbW1lbnQgd2hlbiBhcHBtb2RlbFxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7IC8vIGFwcC5tb2RlbC5saWNlbnNlc0NlcnRpZmljYXRpb25zLnN0YXRlLmlzTG9hZGluZztcbiAgICB0aGlzLmlzU2F2aW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7IC8vYXBwLm1vZGVsLmxpY2Vuc2VzQ2VydGlmaWNhdGlvbnMuc3RhdGUuaXNTYXZpbmc7XG4gICAgdGhpcy5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTsgLy9hcHAubW9kZWwubGljZW5zZXNDZXJ0aWZpY2F0aW9ucy5zdGF0ZS5pc1N5bmNpbmc7XG4gICAgdGhpcy5pc0RlbGV0aW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7IC8vYXBwLm1vZGVsLmxpY2Vuc2VzQ2VydGlmaWNhdGlvbnMuc3RhdGUuaXNEZWxldGluZztcbiAgICB0aGlzLmlzTG9ja2VkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7IC8qa28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRGVsZXRpbmcoKSB8fCBhcHAubW9kZWwubGljZW5zZXNDZXJ0aWZpY2F0aW9ucy5zdGF0ZS5pc0xvY2tlZCgpO1xuICAgIH0sIHRoaXMpOyovXG4gICAgXG4gICAgdGhpcy5pc05ldyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGljZW5zZUNlcnRpZmljYXRpb25JRCgpID09PSAwO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMudmVyc2lvbiA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5pdGVtID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVyc2lvbigpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICAvLyBGaWVsZHMgZm9yIHRoZSBuZXctY2VydGlmaWNhdGlvbi1maWxlXG4gICAgdGhpcy5zdGF0ZVByb3ZpbmNlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMuZmlsZSA9IGtvLm9ic2VydmFibGUoJycpO1xuXG4gICAgdGhpcy51bnNhdmVkQ2hhbmdlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIHYgJiYgdi5hcmVEaWZmZXJlbnQoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmRlbGV0ZVRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzRGVsZXRpbmcoKSA/IFxuICAgICAgICAgICAgICAgICdEZWxldGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAnRGVsZXRlJ1xuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwcC5tb2RlbC5saWNlbnNlc0NlcnRpZmljYXRpb25zLnNldEl0ZW0odGhpcy5pdGVtKCkubW9kZWwudG9QbGFpbk9iamVjdCgpKVxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdmVyc2lvbiB3aXRoIHNlcnZlciBkYXRhLlxuICAgICAgICAgICAgdGhpcy5pdGVtKCkubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhKTtcbiAgICAgICAgICAgIC8vIFB1c2ggdmVyc2lvbiBzbyBpdCBhcHBlYXJzIGFzIHNhdmVkXG4gICAgICAgICAgICB0aGlzLnZlcnNpb24oKS5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XG4gICAgICAgICAgICAvLyBHbyBvdXRcbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBzYXZpbmcuJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5jb25maXJtUmVtb3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBMMThOXG4gICAgICAgIGFwcC5tb2RhbHMuY29uZmlybSh7XG4gICAgICAgICAgICB0aXRsZTogJ0RlbGV0ZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXJlIHlvdSBzdXJlPyBUaGUgb3BlcmF0aW9uIGNhbm5vdCBiZSB1bmRvbmUuJyxcbiAgICAgICAgICAgIHllczogJ0RlbGV0ZScsXG4gICAgICAgICAgICBubzogJ0tlZXAnXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAubW9kZWwubGljZW5zZXNDZXJ0aWZpY2F0aW9ucy5kZWxJdGVtKHRoaXMuam9iVGl0bGVJRCgpLCB0aGlzLmxpY2Vuc2VDZXJ0aWZpY2F0aW9uSUQoKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBHbyBvdXRcbiAgICAgICAgICAgIC8vIFRPRE86IGN1c3RvbSBtZXNzYWdlPz9cbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBkZWxldGluZy4nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gVE9ETyBDT01QTEVURTsgRlJPTSBBIE1PREVMLCBSRU1PVEU/XG4gICAgdGhpcy5zdGF0ZXNQcm92aW5jZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQkxPQiBjb3B5OlxuICAgICAgICByZXR1cm4gW3tcInN0YXRlUHJvdmluY2VJRFwiOlwiMjNcIixcIm5hbWVcIjpcIkFsYWJhbWFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI0OVwiLFwibmFtZVwiOlwiQWxhc2thXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNTJcIixcIm5hbWVcIjpcIkFtZXJpY2FuIFNhbW9hXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNDhcIixcIm5hbWVcIjpcIkFyaXpvbmFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIyNlwiLFwibmFtZVwiOlwiQXJrYW5zYXNcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI2MFwiLFwibmFtZVwiOlwiQXJtZWQgRm9yY2VzIEFtZXJpY2FzIChleGNlcHQgQ2FuYWRhKVwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjYxXCIsXCJuYW1lXCI6XCJBcm1lZCBGb3JjZXMgQ2FuYWRhLCBFdXJvcGUsIE1pZGRsZSBFYXN0LCBhbmQgQWZyaWNhXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNjJcIixcIm5hbWVcIjpcIkFybWVkIEZvcmNlcyBQYWNpZmljXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMVwiLFwibmFtZVwiOlwiQ2FsaWZvcm5pYVwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjM4XCIsXCJuYW1lXCI6XCJDb2xvcmFkb1wifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjZcIixcIm5hbWVcIjpcIkNvbm5lY3RpY3V0XCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMlwiLFwibmFtZVwiOlwiRGVsYXdhcmVcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI1MVwiLFwibmFtZVwiOlwiRGlzdHJpY3Qgb2YgQ29sdW1iaWFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI1N1wiLFwibmFtZVwiOlwiRmVkZXJhdGVkIFN0YXRlcyBvZiBNaWNyb25lc2lhXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMjhcIixcIm5hbWVcIjpcIkZsb3JpZGFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI1XCIsXCJuYW1lXCI6XCJHZW9yZ2lhXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNTNcIixcIm5hbWVcIjpcIkd1YW1cIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI1MFwiLFwibmFtZVwiOlwiSGF3YWlpXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNDNcIixcIm5hbWVcIjpcIklkYWhvXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMjJcIixcIm5hbWVcIjpcIklsbGlub2lzXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMjBcIixcIm5hbWVcIjpcIkluZGlhbmFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIzMFwiLFwibmFtZVwiOlwiSW93YVwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjM0XCIsXCJuYW1lXCI6XCJLYW5zYXNcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIxNlwiLFwibmFtZVwiOlwiS2VudHVja3lcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIxOVwiLFwibmFtZVwiOlwiTG91aXNpYW5hXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMjRcIixcIm5hbWVcIjpcIk1haW5lXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNThcIixcIm5hbWVcIjpcIk1hcnNoYWxsIElzbGFuZHNcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI4XCIsXCJuYW1lXCI6XCJNYXJ5bGFuZFwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjdcIixcIm5hbWVcIjpcIk1hc3NhY2h1c2V0dHNcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIyN1wiLFwibmFtZVwiOlwiTWljaGlnYW5cIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIzMlwiLFwibmFtZVwiOlwiTWlubmVzb3RhXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMjFcIixcIm5hbWVcIjpcIk1pc3Npc3NpcHBpXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMjVcIixcIm5hbWVcIjpcIk1pc3NvdXJpXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNDFcIixcIm5hbWVcIjpcIk1vbnRhbmFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIzN1wiLFwibmFtZVwiOlwiTmVicmFza2FcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIzNlwiLFwibmFtZVwiOlwiTmV2YWRhXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMTBcIixcIm5hbWVcIjpcIk5ldyBIYW1wc2hpcmVcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI0XCIsXCJuYW1lXCI6XCJOZXcgSmVyc2V5XCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNDdcIixcIm5hbWVcIjpcIk5ldyBNZXhpY29cIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIxMlwiLFwibmFtZVwiOlwiTmV3IFlvcmtcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIxM1wiLFwibmFtZVwiOlwiTm9ydGggQ2Fyb2xpbmFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIzOVwiLFwibmFtZVwiOlwiTm9ydGggRGFrb3RhXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNTRcIixcIm5hbWVcIjpcIk5vcnRoZXJuIE1hcmlhbmEgSXNsYW5kc1wifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjE4XCIsXCJuYW1lXCI6XCJPaGlvXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNDZcIixcIm5hbWVcIjpcIk9rbGFob21hXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMzNcIixcIm5hbWVcIjpcIk9yZWdvblwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjU5XCIsXCJuYW1lXCI6XCJQYWxhdVwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjNcIixcIm5hbWVcIjpcIlBlbm5zeWx2YW5pYVwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjU1XCIsXCJuYW1lXCI6XCJQdWVydG8gUmljb1wifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjE0XCIsXCJuYW1lXCI6XCJSaG9kZSBJc2xhbmRcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI5XCIsXCJuYW1lXCI6XCJTb3V0aCBDYXJvbGluYVwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjQwXCIsXCJuYW1lXCI6XCJTb3V0aCBEYWtvdGFcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIxN1wiLFwibmFtZVwiOlwiVGVubmVzc2VlXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMjlcIixcIm5hbWVcIjpcIlRleGFzXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNTZcIixcIm5hbWVcIjpcIlUuUy4gVmlyZ2luIElzbGFuZHNcIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI0NVwiLFwibmFtZVwiOlwiVXRhaFwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjE1XCIsXCJuYW1lXCI6XCJWZXJtb250XCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiMTFcIixcIm5hbWVcIjpcIlZpcmdpbmlhXCJ9LHtcInN0YXRlUHJvdmluY2VJRFwiOlwiNDJcIixcIm5hbWVcIjpcIldhc2hpbmd0b25cIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCIzNVwiLFwibmFtZVwiOlwiV2VzdCBWaXJnaW5pYVwifSx7XCJzdGF0ZVByb3ZpbmNlSURcIjpcIjMxXCIsXCJuYW1lXCI6XCJXaXNjb25zaW5cIn0se1wic3RhdGVQcm92aW5jZUlEXCI6XCI0NFwiLFwibmFtZVwiOlwiV3lvbWluZ1wifV07XG4gICAgfSk7XG59XG4iLCIvKipcbiAgICBMb2dpbiBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBMb2dpbkFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuYW5vbnltb3VzO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCdMb2cgaW4nKTtcbiAgICB0aGlzLm5hdkJhci5yaWdodEFjdGlvbihudWxsKTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIGxvZy1pbiByZXF1ZXN0IHdoZW4gaXMgcmVxdWVzdGVkIGJ5IHRoZSBmb3JtOlxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5pc0xvZ2luZ0luLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAodiA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBsb2dpbmdcblxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBzdGF0ZTpcbiAgICAgICAgICAgICAgICB2YXIgJGJ0biA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJ1t0eXBlPVwic3VibWl0XCJdJyk7XG4gICAgICAgICAgICAgICAgJGJ0bi5idXR0b24oJ2xvYWRpbmcnKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGVycm9yIHNvIG1ha2VzIGNsZWFyIHdlXG4gICAgICAgICAgICAgICAgLy8gYXJlIGF0dGVtcHRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yKCcnKTtcblxuICAgICAgICAgICAgICAgIHZhciBlbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvZ2luZ0luKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgJGJ0bi5idXR0b24oJ3Jlc2V0Jyk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgY2xlYW4tdXAgZXJyb3IgKHRvIGZvcmNlIHNvbWUgdmlldyB1cGRhdGVzKSxcbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSBhbmQgYWJvcnQgb24gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjaGVja2luZyBlcnJvciBvbiBlYWNoIGZpZWxkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld01vZGVsLnVzZXJuYW1lLmVycm9yKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucGFzc3dvcmQuZXJyb3IoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yKCdSZXZpZXcgeW91ciBkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5sb2dpbihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwudXNlcm5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucGFzc3dvcmQoKVxuICAgICAgICAgICAgICAgICkudGhlbihmdW5jdGlvbigvKmxvZ2luRGF0YSovKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwubG9naW5FcnJvcignJyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZGVkKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZvcm0gZGF0YVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC51c2VybmFtZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnBhc3N3b3JkKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3REYXRhICYmIHRoaXMucmVxdWVzdERhdGEucmVkaXJlY3RVcmwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nbyh0aGlzLnJlcXVlc3REYXRhLnJlZGlyZWN0VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAuZ29EYXNoYm9hcmQoKTtcblxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGVyciAmJiBlcnIucmVzcG9uc2VKU09OICYmIGVyci5yZXNwb25zZUpTT04uZXJyb3JNZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgJiYgZXJyLnN0YXR1c1RleHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZGVkKCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRm9jdXMgZmlyc3QgYmFkIGZpZWxkIG9uIGVycm9yXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmxvZ2luRXJyb3IsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gTG9naW4gaXMgZWFzeSBzaW5jZSB3ZSBtYXJrIGJvdGggdW5pcXVlIGZpZWxkc1xuICAgICAgICAgICAgLy8gYXMgZXJyb3Igb24gbG9naW5FcnJvciAoaXRzIGEgZ2VuZXJhbCBmb3JtIGVycm9yKVxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy4kYWN0aXZpdHkuZmluZCgnOmlucHV0JykuZ2V0KDApO1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlucHV0LmJsdXIoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy52aWV3TW9kZWwuZmFjZWJvb2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZiID0gcmVxdWlyZSgnLi4vdXRpbHMvZmFjZWJvb2tVdGlscycpO1xuICAgICAgICBcbiAgICAgICAgLy8gTm90aWZ5IHN0YXRlOlxuICAgICAgICB2YXIgJGJ0biA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJ1t0eXBlPVwic3VibWl0XCJdJyk7XG4gICAgICAgICRidG4uYnV0dG9uKCdsb2FkaW5nJyk7XG5cbiAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgZXJyb3Igc28gbWFrZXMgY2xlYXIgd2VcbiAgICAgICAgLy8gYXJlIGF0dGVtcHRpbmdcbiAgICAgICAgdGhpcy52aWV3TW9kZWwubG9naW5FcnJvcignJyk7XG5cbiAgICAgICAgXG4gICAgICAgIHZhciBlbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaXNMb2dpbmdJbihmYWxzZSk7XG4gICAgICAgICAgICAkYnRuLmJ1dHRvbigncmVzZXQnKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIGVtYWlsLHVzZXJfYWJvdXRfbWVcbiAgICAgICAgZmIubG9naW4oeyBzY29wZTogJ2VtYWlsJyB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHAubW9kZWwuZmFjZWJvb2tMb2dpbihyZXN1bHQuYXV0aC5hY2Nlc3NUb2tlbilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKC8qbG9naW5EYXRhKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yKCcnKTtcbiAgICAgICAgICAgICAgICBlbmRlZCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZvcm0gZGF0YVxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnVzZXJuYW1lKCcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wYXNzd29yZCgnJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0RGF0YSAmJiB0aGlzLnJlcXVlc3REYXRhLnJlZGlyZWN0VXJsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nbyh0aGlzLnJlcXVlc3REYXRhLnJlZGlyZWN0VXJsKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLmdvRGFzaGJvYXJkKCk7XG5cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcblxuICAgICAgICAgICAgdmFyIG1zZyA9IGVyciAmJiBlcnIucmVzcG9uc2VKU09OICYmIGVyci5yZXNwb25zZUpTT04uZXJyb3JNZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgZXJyICYmIGVyci5zdGF0dXNUZXh0IHx8XG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgbG9naW4nO1xuXG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5sb2dpbkVycm9yKG1zZyk7XG4gICAgICAgICAgICBlbmRlZCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbnZhciBGb3JtQ3JlZGVudGlhbHMgPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL0Zvcm1DcmVkZW50aWFscycpO1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoKSB7XG5cbiAgICB2YXIgY3JlZGVudGlhbHMgPSBuZXcgRm9ybUNyZWRlbnRpYWxzKCk7ICAgIFxuICAgIHRoaXMudXNlcm5hbWUgPSBjcmVkZW50aWFscy51c2VybmFtZTtcbiAgICB0aGlzLnBhc3N3b3JkID0gY3JlZGVudGlhbHMucGFzc3dvcmQ7XG5cbiAgICB0aGlzLmxvZ2luRXJyb3IgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICBcbiAgICB0aGlzLmlzTG9naW5nSW4gPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBcbiAgICB0aGlzLnBlcmZvcm1Mb2dpbiA9IGZ1bmN0aW9uIHBlcmZvcm1Mb2dpbigpIHtcblxuICAgICAgICB0aGlzLmlzTG9naW5nSW4odHJ1ZSk7ICAgICAgICBcbiAgICB9LmJpbmQodGhpcyk7XG59XG4iLCIvKipcbiAgICBMb2dvdXQgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBMb2dvdXRBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIHRoaXMuYXBwLm1vZGVsLmxvZ291dCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEFub255bW91cyB1c2VyIGFnYWluXG4gICAgICAgIHZhciBuZXdBbm9uID0gdGhpcy5hcHAubW9kZWwudXNlcigpLmNvbnN0cnVjdG9yLm5ld0Fub255bW91cygpO1xuICAgICAgICB0aGlzLmFwcC5tb2RlbC51c2VyKCkubW9kZWwudXBkYXRlV2l0aChuZXdBbm9uKTtcblxuICAgICAgICAvLyBHbyBpbmRleFxuICAgICAgICB0aGlzLmFwcC5zaGVsbC5nbygnLycpO1xuICAgICAgICBcbiAgICB9LmJpbmQodGhpcykpO1xufTtcbiIsIi8qKlxuICAgIE1hcmtldHBsYWNlSm9idGl0bGVzIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIE1hcmtldHBsYWNlSm9idGl0bGVzQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignTWFya2V0cGxhY2UgcHJvZmlsZScsIHtcbiAgICAgICAgYmFja0xpbms6ICcvbWFya2V0cGxhY2VQcm9maWxlJ1xuICAgIH0pO1xuXG4gICAgLy8gT24gY2hhbmdpbmcgam9iVGl0bGVJRDpcbiAgICAvLyAtIGxvYWQgYWRkcmVzc2VzXG4gICAgLy8gLSBsb2FkIGpvYiB0aXRsZSBpbmZvcm1hdGlvblxuICAgIC8vIC0gbG9hZCBwcmljaW5nXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcblxuICAgICAgICAgICAgaWYgKGpvYlRpdGxlSUQpIHtcbiAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICAvLyBBZGRyZXNzZXNcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldExpc3Qoam9iVGl0bGVJRClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuYXNNb2RlbChsaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc2VzKGxpc3QpO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyBhZGRyZXNzZXMuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICAvLyBQcmljaW5nL1NlcnZpY2VzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLmdldExpc3Qoam9iVGl0bGVJRClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5hc01vZGVsKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcmljaW5nKGxpc3QpO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyBzZXJ2aWNlcy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vIEpvYiBUaXRsZVxuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIFRpdGxlIGFuZCBVc2VyIFByb2ZpbGVcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC51c2VySm9iUHJvZmlsZS5nZXRVc2VySm9iVGl0bGVBbmRKb2JUaXRsZShqb2JUaXRsZUlEKVxuICAgICAgICAgICAgICAgIC8vdGhpcy5hcHAubW9kZWwuam9iVGl0bGVzLmdldEpvYlRpdGxlKGpvYlRpdGxlSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oam9iKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIGpvYiB0aXRsZSByZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGUoam9iLmpvYlRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwudXNlckpvYlRpdGxlKGpvYi51c2VySm9iVGl0bGUpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB5b3VyIGpvYiB0aXRsZS4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuYWRkcmVzc2VzKFtdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcmljaW5nKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuXG4gICAgLy8gUmVzZXQ6IGF2b2lkaW5nIGVycm9ycyBiZWNhdXNlIHBlcnNpc3RlZCBkYXRhIGZvciBkaWZmZXJlbnQgSUQgb24gbG9hZGluZ1xuICAgIC8vIG9yIG91dGRhdGVkIGluZm8gZm9yY2luZyB1cGRhdGVcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKDApO1xuXG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cyB8fCB7fTtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGpvYiB0aXRsZVxuICAgIHZhciBqb2JJRCA9IHBhcmFtc1swXSB8MDtcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYklEKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLmpvYlRpdGxlSUQgPSBrby5vYnNlcnZhYmxlKDApO1xuICAgIHRoaXMuam9iVGl0bGUgPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIHRoaXMudXNlckpvYlRpdGxlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICB0aGlzLmpvYlRpdGxlTmFtZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGogPSB0aGlzLmpvYlRpdGxlKCk7XG4gICAgICAgIHJldHVybiBqICYmIGouc2luZ3VsYXJOYW1lKCkgfHwgJ0pvYiBUaXRsZSc7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8gUmV0cmlldmVzIGEgY29tcHV0ZWQgdGhhdCB3aWxsIGxpbmsgdG8gdGhlIGdpdmVuIG5hbWVkIGFjdGl2aXR5IGFkZGluZyB0aGUgY3VycmVudFxuICAgIC8vIGpvYlRpdGxlSUQgYW5kIGEgbXVzdFJldHVybiBVUkwgdG8gcG9pbnQgdGhpcyBwYWdlIHNvIGl0cyByZW1lbWJlciB0aGUgYmFjayByb3V0ZVxuICAgIHRoaXMuZ2V0Sm9iVXJsVG8gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIC8vIFNhbXBsZSAnL3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy8nICsgam9iVGl0bGVJRCgpXG4gICAgICAgIHJldHVybiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICcvJyArIG5hbWUgKyAnLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICc/bXVzdFJldHVybj1tYXJrZXRwbGFjZUpvYnRpdGxlcy8nICsgdGhpcy5qb2JUaXRsZUlEKCkgK1xuICAgICAgICAgICAgICAgICcmcmV0dXJuVGV4dD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuam9iVGl0bGVOYW1lKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuaXNBY3RpdmVTdGF0dXMgPSBrby5wdXJlQ29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy51c2VySm9iVGl0bGUoKTtcbiAgICAgICAgICAgIHJldHVybiBqICYmIGouc3RhdHVzSUQoKSA9PT0gMSB8fCBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLnVzZXJKb2JUaXRsZSgpICYmIHRoaXMudXNlckpvYlRpdGxlKCkuc3RhdHVzSUQoKTtcbiAgICAgICAgICAgIGlmICh2ID09PSB0cnVlICYmIHN0YXR1cyA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckpvYlRpdGxlKCkuc3RhdHVzSUQoMSk7XG4gICAgICAgICAgICAgICAgLy8gUHVzaCBjaGFuZ2UgdG8gYmFjay1lbmRcbiAgICAgICAgICAgICAgICBhcHAubW9kZWwudXNlckpvYlByb2ZpbGUucmVhY3RpdmF0ZVVzZXJKb2JUaXRsZSh0aGlzLmpvYlRpdGxlSUQoKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHsgdGl0bGU6ICdFcnJvciBlbmFibGluZyBhIEpvYiBUaXRsZScsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ID09PSBmYWxzZSAmJiBzdGF0dXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJKb2JUaXRsZSgpLnN0YXR1c0lEKDMpO1xuICAgICAgICAgICAgICAgIC8vIFB1c2ggY2hhbmdlIHRvIGJhY2stZW5kXG4gICAgICAgICAgICAgICAgYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLmRlYWN0aXZhdGVVc2VySm9iVGl0bGUodGhpcy5qb2JUaXRsZUlEKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7IHRpdGxlOiAnRXJyb3IgZGlzYWJsaW5nIGEgSm9iIFRpdGxlJywgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3duZXI6IHRoaXNcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnN0YXR1c0xhYmVsID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZVN0YXR1cygpID8gJ09OJyA6ICdPRkYnO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuY2FuY2VsbGF0aW9uUG9saWN5TGFiZWwgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwaWQgPSB0aGlzLnVzZXJKb2JUaXRsZSgpICYmIHRoaXMudXNlckpvYlRpdGxlKCkuY2FuY2VsbGF0aW9uUG9saWN5SUQoKTtcbiAgICAgICAgLy8gVE9ETyBmZXRjaCBwb2xpY3kgSUQgbGFiZWxcbiAgICAgICAgcmV0dXJuIHBpZCA9PT0gMyA/ICdGbGV4aWJsZScgOiBwaWQgPT09IDIgPyAnTW9kZXJhdGUnIDogJ1N0cmljdCc7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5pbnN0YW50Qm9va2luZyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlckpvYlRpdGxlKCkgJiYgdGhpcy51c2VySm9iVGl0bGUoKS5pbnN0YW50Qm9va2luZygpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuaW5zdGFudEJvb2tpbmdMYWJlbCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFudEJvb2tpbmcoKSA/ICdPTicgOiAnT0ZGJztcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLnRvZ2dsZUluc3RhbnRCb29raW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5pbnN0YW50Qm9va2luZygpO1xuICAgICAgICBpZiAodGhpcy51c2VySm9iVGl0bGUoKSkge1xuICAgICAgICAgICAgLy8gQ2hhbmdlIGltbWVkaWF0ZWx5LCB3aGlsZSBzYXZpbmcgaW4gYmFja2dyb3VuZFxuICAgICAgICAgICAgdGhpcy51c2VySm9iVGl0bGUoKS5pbnN0YW50Qm9va2luZyghY3VycmVudCk7XG4gICAgICAgICAgICAvLyBQdXNoIGNoYW5nZSB0byBzZXJ2ZXJcbiAgICAgICAgICAgIHZhciBwbGFpbiA9IHRoaXMudXNlckpvYlRpdGxlKCkubW9kZWwudG9QbGFpbk9iamVjdCgpO1xuICAgICAgICAgICAgcGxhaW4uaW5zdGFudEJvb2tpbmcgPSAhY3VycmVudDtcblxuICAgICAgICAgICAgYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLnNldFVzZXJKb2JUaXRsZShwbGFpbilcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7IHRpdGxlOiAnRXJyb3Igc2F2aW5nIEluc3RhbnQgQm9va2luZyBwcmVmZXJlbmNlJywgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgICAgICAvLyBPbiBlcnJvciwgb3JpZ2luYWwgdmFsdWUgbXVzdCBiZSByZXN0b3JlZCAoc28gY2FuIGF0dGVtcHQgdG8gY2hhbmdlIGl0IGFnYWluKVxuICAgICAgICAgICAgICAgIHRoaXMudXNlckpvYlRpdGxlKCkuaW5zdGFudEJvb2tpbmcoY3VycmVudCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vLyBSZWxhdGVkIG1vZGVscyBpbmZvcm1hdGlvblxuICAgIFxuICAgIHRoaXMuYWRkcmVzc2VzID0ga28ub2JzZXJ2YWJsZShbXSk7XG4gICAgdGhpcy5wcmljaW5nID0ga28ub2JzZXJ2YWJsZShbXSk7XG4gICAgdGhpcy5saWNlbnNlQ2VydGlmaWNhdGlvbnMgPSBrby5vYnNlcnZhYmxlKFtdKTtcbiAgICB0aGlzLndvcmtQaG90b3MgPSBrby5vYnNlcnZhYmxlKFtdKTtcblxuICAgIC8vIENvbXB1dGVkIHNpbmNlIGl0IGNhbiBjaGVjayBzZXZlcmFsIGV4dGVybmEgbG9hZGluZ3NcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnN0YXRlLmlzTG9hZGluZygpIHx8XG4gICAgICAgICAgICBhcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLnN0YXRlLmlzTG9hZGluZygpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuYWRkcmVzc2VzQ291bnQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPIGwxMG4uXG4gICAgICAgIC8vIFVzZSBpMThuZXh0IHBsdXJhbCBsb2NhbGl6YXRpb24gc3VwcG9ydCByYXRoZXIgdGhhbiB0aGlzIG1hbnVhbC5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5hZGRyZXNzZXMoKS5sZW5ndGgsXG4gICAgICAgICAgICBvbmUgPSAnMSBsb2NhdGlvbicsXG4gICAgICAgICAgICBtb3JlID0gJyBsb2NhdGlvbnMnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG9uZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gU21hbGwgbnVtYmVycywgbm8gbmVlZCBmb3IgZm9ybWF0dGluZ1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgbW9yZTtcblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMucHJpY2luZ0NvdW50ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgLy8gVE9ETyBsMTBuLlxuICAgICAgICAvLyBVc2UgaTE4bmV4dCBwbHVyYWwgbG9jYWxpemF0aW9uIHN1cHBvcnQgcmF0aGVyIHRoYW4gdGhpcyBtYW51YWwuXG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMucHJpY2luZygpLmxlbmd0aCxcbiAgICAgICAgICAgIG9uZSA9ICcxIHNlcnZpY2UnLFxuICAgICAgICAgICAgbW9yZSA9ICcgc2VydmljZXMnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG9uZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gU21hbGwgbnVtYmVycywgbm8gbmVlZCBmb3IgZm9ybWF0dGluZ1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgbW9yZTtcblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMubGljZW5zZXNDZXJ0aWZpY2F0aW9uc1N1bW1hcnkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYyA9IHRoaXMubGljZW5zZUNlcnRpZmljYXRpb25zKCk7XG4gICAgICAgIGlmIChsYyAmJiBsYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gRGV0ZWN0IFxuICAgICAgICAgICAgdmFyIHZlcmlmaWVkID0gMCxcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gMDtcbiAgICAgICAgICAgIGxjLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgIGlmIChsICYmIGwuc3RhdHVzSUQoKSA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsICYmIGwuc3RhdHVzSUQoKSA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZysrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBMMThOXG4gICAgICAgICAgICByZXR1cm4gdmVyaWZpZWQgKyAnIHZlcmlmaWVkLCAnICsgcGVuZGluZyArICcgcGVuZGluZyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBMMThOXG4gICAgICAgICAgICByZXR1cm4gJ1RoZXJlIGFyZSBub3QgdmVyaWZpY2F0aW9ucyc7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLndvcmtQaG90b3NTdW1tYXJ5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd3AgPSB0aGlzLndvcmtQaG90b3MoKTtcbiAgICAgICAgLy8gTDE4TlxuICAgICAgICBpZiAod3AgJiYgd3AubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiB3cC5sZW5ndGggKyAnIGltYWdlcyc7XG4gICAgICAgIGVsc2UgaWYgKHdwICYmIHdwLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiAnMSBpbWFnZSc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAnTm8gaW1hZ2VzJztcbiAgICB9LCB0aGlzKTtcbiAgICBcbn1cbiIsIi8qKlxuICAgIE1hcmtldHBsYWNlUHJvZmlsZSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBVc2VySm9iUHJvZmlsZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvVXNlckpvYlByb2ZpbGUnKSxcbiAgICBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBNYXJrZXRwbGFjZVByb2ZpbGVBY3Rpdml0eSgpIHtcblxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignTWFya2V0cGxhY2UgUHJvZmlsZScpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsLnNob3dNYXJrZXRwbGFjZUluZm8odHJ1ZSk7XG4gICAgdGhpcy52aWV3TW9kZWwuYmFzZVVybCgnL21hcmtldHBsYWNlSm9idGl0bGVzJyk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuXG4gICAgaWYgKHRoaXMudmlld01vZGVsLnVzZXIuaXNTZXJ2aWNlUHJvZmVzc2lvbmFsKCkpXG4gICAgICAgIHRoaXMudmlld01vZGVsLnN5bmMoKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICAvLyBKdXN0IHVzZSB0aGUgam9iIHByb2ZpbGUgdmlldyBtb2RlbCAoY3JlYXRlZCBmb3IgdGhlIGpvYiB0aXRsZSBsaXN0aW5nXG4gICAgLy8gYXQgJ3NjaGVkdWxpbmcnKSwgaW5zdGFuY2UsIGV4dGVuZCBhbmQgcmV0dXJuXG4gICAgdmFyIGpvYlZtID0gbmV3IFVzZXJKb2JQcm9maWxlVmlld01vZGVsKGFwcCk7XG4gICAgXG4gICAgLy8gVE9ETyByZWFkIHZlcmlmaWNhdGlvbnMgY291bnQgZnJvbSBtb2RlbDsgY29tcHV0ZWRcbiAgICBqb2JWbS52ZXJpZmljYXRpb25zQ291bnQgPSBrby5vYnNlcnZhYmxlKDMpO1xuICAgIFxuICAgIGpvYlZtLmRpc3BsYXllZFZlcmlmaWNhdGlvbnNOdW1iZXIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZlcmlmaWNhdGlvbnNDb3VudCA9IHRoaXMudmVyaWZpY2F0aW9uc0NvdW50KCk7XG4gICAgICAgIC8vIEZvcm1hdFxuICAgICAgICAvLyBMMThOXG4gICAgICAgIHJldHVybiAnKCcgKyB2ZXJpZmljYXRpb25zQ291bnQgKyAnKSc7XG4gICAgfSwgam9iVm0pO1xuXG4gICAgam9iVm0udmVyaWZpY2F0aW9uc1NlY29uZGFyeVRleHQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVE9ETyByZWFkIGNvdW50IGxpbWl0XG4gICAgICAgIHZhciB2ZXJpZmljYXRpb25zTGltaXQgPSAxMCxcbiAgICAgICAgICAgIGNvdW50ID0gdGhpcy52ZXJpZmljYXRpb25zQ291bnQoKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IHZlcmlmaWNhdGlvbnNMaW1pdCAtIGNvdW50O1xuICAgICAgICAvLyBGb3JtYXRcbiAgICAgICAgLy8gTDE4TlxuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/ICdZb3UgY2FuIGFkZCB1cCB0byAnICsgcmVtYWluaW5nICsgJyBtb3JlJyA6ICdZb3UgY2Fubm90IGFkZCBtb3JlJztcbiAgICB9LCBqb2JWbSk7XG4gICAgXG4gICAgam9iVm0uZGlzcGxheWVkTGFzdEJhY2tncm91bmRDaGVjayA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPIHJlYWQgbGFzdCBjaGVjayBkYXRlXG4gICAgICAgIHZhciBsYXN0RGF0ZSA9IG5ldyBEYXRlKDIwMTQsIDEwLCAxNCk7XG4gICAgICAgIHJldHVybiBtb21lbnQobGFzdERhdGUpLmZvcm1hdCgnTCcpO1xuICAgIH0sIGpvYlZtKTtcbiAgICBcbiAgICBqb2JWbS51c2VyID0gYXBwLm1vZGVsLnVzZXJQcm9maWxlLmRhdGE7XG5cbiAgICByZXR1cm4gam9iVm07XG59XG4iLCIvKipcbiAgICBPd25lckluZm8gYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBPd25lckluZm9BY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLnNlcnZpY2VQcm9mZXNzaW9uYWw7XG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdBY2NvdW50Jywge1xuICAgICAgICBiYWNrTGluazogJ2FjY291bnQnXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuIiwiLyoqXG4gICAgUGF5bWVudHMgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gUGF5bWVudHNBY3Rpdml0eSgpIHtcblxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gbnVsbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHt9O1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignUGF5bWVudHMnKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEE7XG4iLCIvKipcbiAgICBQZXJmb3JtYW5jZSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBQZXJmb3JtYW5jZUFjdGl2aXR5KCkge1xuXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSBudWxsO1xuICAgIHRoaXMudmlld01vZGVsID0ge307XG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKCdQZXJmb3JtYW5jZScpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQTtcbiIsIi8qKlxuICAgIFByaXZhY3lTZXR0aW5ncyBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBQcml2YWN5U2V0dGluZ3NBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG5cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ0FjY291bnQnLCB7XG4gICAgICAgIGJhY2tMaW5rOiAnYWNjb3VudCdcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy5hcHAubW9kZWwucHJpdmFjeVNldHRpbmdzLFxuICAgICAgICBldmVudDogJ2Vycm9yJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgcHJpdmFjeSBzZXR0aW5ncy4nIDogJ0Vycm9yIGxvYWRpbmcgcHJpdmFjeSBzZXR0aW5ncy4nO1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgdGl0bGU6IG1zZyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci50YXNrICYmIGVyci5lcnJvciB8fCBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSk7XG4gICAgXG4gICAgLy8gS2VlcCBkYXRhIHVwZGF0ZWQ6XG4gICAgdGhpcy5hcHAubW9kZWwucHJpdmFjeVNldHRpbmdzLnN5bmMoKTtcbiAgICAvLyBEaXNjYXJkIGFueSBwcmV2aW91cyB1bnNhdmVkIGVkaXRcbiAgICB0aGlzLnZpZXdNb2RlbC5kaXNjYXJkKCk7XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgXG4gICAgdGhpcy51c2VyID0gYXBwLm1vZGVsLnVzZXJQcm9maWxlLmRhdGE7XG5cbiAgICB2YXIgcHJpdmFjeVNldHRpbmdzID0gYXBwLm1vZGVsLnByaXZhY3lTZXR0aW5ncztcblxuICAgIHZhciBzZXR0aW5nc1ZlcnNpb24gPSBwcml2YWN5U2V0dGluZ3MubmV3VmVyc2lvbigpO1xuICAgIHNldHRpbmdzVmVyc2lvbi5pc09ic29sZXRlLnN1YnNjcmliZShmdW5jdGlvbihpdElzKSB7XG4gICAgICAgIGlmIChpdElzKSB7XG4gICAgICAgICAgICAvLyBuZXcgdmVyc2lvbiBmcm9tIHNlcnZlciB3aGlsZSBlZGl0aW5nXG4gICAgICAgICAgICAvLyBGVVRVUkU6IHdhcm4gYWJvdXQgYSBuZXcgcmVtb3RlIHZlcnNpb24gYXNraW5nXG4gICAgICAgICAgICAvLyBjb25maXJtYXRpb24gdG8gbG9hZCB0aGVtIG9yIGRpc2NhcmQgYW5kIG92ZXJ3cml0ZSB0aGVtO1xuICAgICAgICAgICAgLy8gdGhlIHNhbWUgaXMgbmVlZCBvbiBzYXZlKCksIGFuZCBvbiBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIHdpdGggYSA1MDk6Q29uZmxpY3Qgc3RhdHVzIChpdHMgYm9keSBtdXN0IGNvbnRhaW4gdGhlXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgdmVyc2lvbikuXG4gICAgICAgICAgICAvLyBSaWdodCBub3csIGp1c3Qgb3ZlcndyaXRlIGN1cnJlbnQgY2hhbmdlcyB3aXRoXG4gICAgICAgICAgICAvLyByZW1vdGUgb25lczpcbiAgICAgICAgICAgIHNldHRpbmdzVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzVmVyc2lvbi52ZXJzaW9uO1xuXG4gICAgdGhpcy5pc0xvY2tlZCA9IHByaXZhY3lTZXR0aW5ncy5pc0xvY2tlZDtcblxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnbG9hZGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXG4gICAgICAgICk7XG4gICAgfSwgcHJpdmFjeVNldHRpbmdzKTtcbiAgICBcbiAgICB0aGlzLmRpc2NhcmQgPSBmdW5jdGlvbiBkaXNjYXJkKCkge1xuICAgICAgICBzZXR0aW5nc1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICAgIHNldHRpbmdzVmVyc2lvbi5wdXNoU2F2ZSgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXBwLnN1Y2Nlc3NTYXZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yLCBtYW5hZ2VkIG9uIGV2ZW50XG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcbn1cbiIsIi8qKlxuICAgIFByb3ZpbGUgYWN0aXZpdHlcbiAgICBcbiAgICBWaXN1YWxpemVzIHRoZSBwdWJsaWMgcHJvZmlsZSBvZiBhIHVzZXIsIG9yIGN1cnJlbnQgdXNlclxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFByb2ZpbGVBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IG51bGw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICAvLyBudWxsIGZvciBsb2dvXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKG51bGwpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG4gICAgdmFyIHBhcmFtcyA9IG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cztcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXF1ZXN0ZWRVc2VySUQocGFyYW1zWzBdIHwwKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcblxuICAgIHRoaXMucmVxdWVzdGVkVXNlcklEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuaXNTeW5jaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgXG4gICAgdGhpcy5wcm9maWxlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0ZWRVc2VySUQoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gU2hvdyBjdXJyZW50IHVzZXIgcHJvZmlsZVxuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC51c2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBsb2FkIGFub3RoZXIgdXNlciBwcm9maWxlXG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbn1cbiIsIi8qKlxuICAgIFByb2ZpbGVQaWN0dXJlQmlvIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFByb2ZpbGVQaWN0dXJlQmlvQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdNYXJrZXRwbGFjZSBwcm9maWxlJywge1xuICAgICAgICBiYWNrTGluazogJ21hcmtldHBsYWNlUHJvZmlsZSdcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy5hcHAubW9kZWwubWFya2V0cGxhY2VQcm9maWxlLFxuICAgICAgICBldmVudDogJ2Vycm9yJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgeW91ciBkYXRhLicgOiAnRXJyb3IgbG9hZGluZyB5b3VyIGRhdGEuJztcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIuZXJyb3IgfHwgZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxuICAgIHRoaXMudmlld01vZGVsLmRpc2NhcmQoKTtcbiAgICBcbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcbiAgICB0aGlzLmFwcC5tb2RlbC5tYXJrZXRwbGFjZVByb2ZpbGUuc3luYygpO1xufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuXG4gICAgLy8gTWFya2V0cGxhY2UgUHJvZmlsZVxuICAgIHZhciBtYXJrZXRwbGFjZVByb2ZpbGUgPSBhcHAubW9kZWwubWFya2V0cGxhY2VQcm9maWxlO1xuICAgIHZhciBwcm9maWxlVmVyc2lvbiA9IG1hcmtldHBsYWNlUHJvZmlsZS5uZXdWZXJzaW9uKCk7XG4gICAgcHJvZmlsZVZlcnNpb24uaXNPYnNvbGV0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oaXRJcykge1xuICAgICAgICBpZiAoaXRJcykge1xuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xuICAgICAgICAgICAgLy8gRlVUVVJFOiB3YXJuIGFib3V0IGEgbmV3IHJlbW90ZSB2ZXJzaW9uIGFza2luZ1xuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyB3aXRoIGEgNTA5OkNvbmZsaWN0IHN0YXR1cyAoaXRzIGJvZHkgbXVzdCBjb250YWluIHRoZVxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxuICAgICAgICAgICAgLy8gcmVtb3RlIG9uZXM6XG4gICAgICAgICAgICBwcm9maWxlVmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBBY3R1YWwgZGF0YSBmb3IgdGhlIGZvcm06XG4gICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZVZlcnNpb24udmVyc2lvbjtcbiAgICBcbiAgICAvLyBDb250cm9sIG9ic2VydmFibGVzOiBzcGVjaWFsIGJlY2F1c2UgbXVzdCBhIG1peFxuICAgIC8vIG9mIHRoZSBib3RoIHJlbW90ZSBtb2RlbHMgdXNlZCBpbiB0aGlzIHZpZXdtb2RlbFxuICAgIHRoaXMuaXNMb2NrZWQgPSBtYXJrZXRwbGFjZVByb2ZpbGUuaXNMb2NrZWQ7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBtYXJrZXRwbGFjZVByb2ZpbGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBtYXJrZXRwbGFjZVByb2ZpbGUuaXNTYXZpbmc7XG5cbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXG4gICAgICAgICAgICAgICAgICAgICdzYXZpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgICAgICdTYXZlJ1xuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gQWN0aW9uc1xuXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcbiAgICAgICAgcHJvZmlsZVZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICAgIHByb2ZpbGVWZXJzaW9uLnB1c2hTYXZlKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcHAuc3VjY2Vzc1NhdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gY2F0Y2ggZXJyb3IsIG1hbmFnZWQgb24gZXZlbnRcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuIiwiLyoqXG4gICAgU2NoZWR1bGluZyBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBVc2VySm9iUHJvZmlsZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvVXNlckpvYlByb2ZpbGUnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFNjaGVkdWxpbmdBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVXNlckpvYlByb2ZpbGVWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhcignU2NoZWR1bGluZycpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coc3RhdGUpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIHN0YXRlKTtcblxuICAgIHRoaXMudmlld01vZGVsLnN5bmMoKTtcbn07XG4iLCIvKipcbiAgICBTY2hlZHVsaW5nUHJlZmVyZW5jZXMgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gU2NoZWR1bGluZ1ByZWZlcmVuY2VzQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5zZXJ2aWNlUHJvZmVzc2lvbmFsO1xuXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdTY2hlZHVsaW5nJywge1xuICAgICAgICBiYWNrTGluazogJ3NjaGVkdWxpbmcnXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuYXBwLm1vZGVsLnNjaGVkdWxpbmdQcmVmZXJlbmNlcyxcbiAgICAgICAgZXZlbnQ6ICdlcnJvcicsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdmFyIG1zZyA9IGVyci50YXNrID09PSAnc2F2ZScgPyAnRXJyb3Igc2F2aW5nIHNjaGVkdWxpbmcgcHJlZmVyZW5jZXMuJyA6ICdFcnJvciBsb2FkaW5nIHNjaGVkdWxpbmcgcHJlZmVyZW5jZXMuJztcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxuICAgIHRoaXMuYXBwLm1vZGVsLnNjaGVkdWxpbmdQcmVmZXJlbmNlcy5zeW5jKCk7XG4gICAgLy8gRGlzY2FyZCBhbnkgcHJldmlvdXMgdW5zYXZlZCBlZGl0XG4gICAgdGhpcy52aWV3TW9kZWwuZGlzY2FyZCgpO1xufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuXG4gICAgdmFyIHNjaGVkdWxpbmdQcmVmZXJlbmNlcyA9IGFwcC5tb2RlbC5zY2hlZHVsaW5nUHJlZmVyZW5jZXM7XG5cbiAgICB2YXIgcHJlZnNWZXJzaW9uID0gc2NoZWR1bGluZ1ByZWZlcmVuY2VzLm5ld1ZlcnNpb24oKTtcbiAgICBwcmVmc1ZlcnNpb24uaXNPYnNvbGV0ZS5zdWJzY3JpYmUoZnVuY3Rpb24oaXRJcykge1xuICAgICAgICBpZiAoaXRJcykge1xuICAgICAgICAgICAgLy8gbmV3IHZlcnNpb24gZnJvbSBzZXJ2ZXIgd2hpbGUgZWRpdGluZ1xuICAgICAgICAgICAgLy8gRlVUVVJFOiB3YXJuIGFib3V0IGEgbmV3IHJlbW90ZSB2ZXJzaW9uIGFza2luZ1xuICAgICAgICAgICAgLy8gY29uZmlybWF0aW9uIHRvIGxvYWQgdGhlbSBvciBkaXNjYXJkIGFuZCBvdmVyd3JpdGUgdGhlbTtcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGlzIG5lZWQgb24gc2F2ZSgpLCBhbmQgb24gc2VydmVyIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyB3aXRoIGEgNTA5OkNvbmZsaWN0IHN0YXR1cyAoaXRzIGJvZHkgbXVzdCBjb250YWluIHRoZVxuICAgICAgICAgICAgLy8gc2VydmVyIHZlcnNpb24pLlxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCBqdXN0IG92ZXJ3cml0ZSBjdXJyZW50IGNoYW5nZXMgd2l0aFxuICAgICAgICAgICAgLy8gcmVtb3RlIG9uZXM6XG4gICAgICAgICAgICBwcmVmc1ZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWN0dWFsIGRhdGEgZm9yIHRoZSBmb3JtOlxuICAgIHRoaXMucHJlZnMgPSBwcmVmc1ZlcnNpb24udmVyc2lvbjtcblxuICAgIHRoaXMuaXNMb2NrZWQgPSBzY2hlZHVsaW5nUHJlZmVyZW5jZXMuaXNMb2NrZWQ7XG5cbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID8gXG4gICAgICAgICAgICAgICAgICAgICdzYXZpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgICAgICdTYXZlJ1xuICAgICAgICApO1xuICAgIH0sIHNjaGVkdWxpbmdQcmVmZXJlbmNlcyk7XG4gICAgXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcbiAgICAgICAgcHJlZnNWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgICBwcmVmc1ZlcnNpb24ucHVzaFNhdmUoKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5pbmNyZW1lbnRzRXhhbXBsZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdHIgPSAnZS5nLiAnLFxuICAgICAgICAgICAgaW5jU2l6ZSA9IHRoaXMuaW5jcmVtZW50c1NpemVJbk1pbnV0ZXMoKSxcbiAgICAgICAgICAgIG0gPSBtb21lbnQoeyBob3VyOiAxMCwgbWludXRlOiAwIH0pLFxuICAgICAgICAgICAgaG91cnMgPSBbbS5mb3JtYXQoJ0hIOm1tJyldO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGhvdXJzLnB1c2goXG4gICAgICAgICAgICAgICAgbS5hZGQoaW5jU2l6ZSwgJ21pbnV0ZXMnKVxuICAgICAgICAgICAgICAgIC5mb3JtYXQoJ0hIOm1tJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IGhvdXJzLmpvaW4oJywgJyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICBcbiAgICB9LCB0aGlzLnByZWZzKTtcbn1cbiIsIi8qKlxuICAgIFNlcnZpY2UgQWRkcmVzc2VzIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXG4gICAgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBTZXJ2aWNlQWRkcmVzc2VzQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLnNlcnZpY2VQcm9mZXNzaW9uYWw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignSm9iIFRpdGxlJywge1xuICAgICAgICBiYWNrTGluazogJy9zY2hlZHVsaW5nJ1xuICAgIH0pO1xuICAgIC8vIFNhdmUgZGVmYXVsdHMgdG8gcmVzdG9yZSBvbiB1cGRhdGVOYXZCYXJTdGF0ZSB3aGVuIG5lZWRlZDpcbiAgICB0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uID0gdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XG5cbiAgICAvLyBPbiBjaGFuZ2luZyBqb2JUaXRsZUlEOlxuICAgIC8vIC0gbG9hZCBhZGRyZXNzZXNcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oam9iVGl0bGVJRCkge1xuICAgICAgICAgICAgaWYgKGpvYlRpdGxlSUQpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgZGF0YSBmb3IgdGhlIEpvYiB0aXRsZSBJRFxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLmpvYlRpdGxlcy5nZXRKb2JUaXRsZShqb2JUaXRsZUlEKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGpvYlRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgZm9yIHVzZSBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZShqb2JUaXRsZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBuYXZiYXIgKG1heSBpbmRpY2F0ZSB0aGUgam9iVGl0bGUgbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGFkZHJlc3Nlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHAubW9kZWwuc2VydmljZUFkZHJlc3Nlcy5nZXRMaXN0KGpvYlRpdGxlSUQpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuYXNNb2RlbChsaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc2VydmljZUFkZHJlc3Nlcy5zb3VyY2VBZGRyZXNzZXMobGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnNvdXJjZUFkZHJlc3NlcyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGUobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICBcbiAgICAvLyBHbyBiYWNrIHdpdGggdGhlIHNlbGVjdGVkIGFkZHJlc3Mgd2hlbiB0cmlnZ2VyZWQgaW4gdGhlIGZvcm0vdmlld1xuICAgIHRoaXMudmlld01vZGVsLnJldHVyblNlbGVjdGVkID0gZnVuY3Rpb24oYWRkcmVzc0lELCBqb2JUaXRsZUlEKSB7XG4gICAgICAgIC8vIFBhc3MgdGhlIHNlbGVjdGVkIGNsaWVudCBpbiB0aGUgaW5mb1xuICAgICAgICB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkQWRkcmVzc0lEID0gYWRkcmVzc0lEO1xuICAgICAgICB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkSm9iVGl0bGVJRCA9IGpvYlRpdGxlSUQ7XG4gICAgICAgIC8vIEFuZCBnbyBiYWNrXG4gICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvQmFjayh0aGlzLnJlcXVlc3REYXRhKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5yZXR1cm5SZXF1ZXN0ID0gZnVuY3Rpb24gcmV0dXJuUmVxdWVzdCgpIHtcbiAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xuICAgIH0uYmluZCh0aGlzKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLmFwcGx5T3duTmF2YmFyUnVsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjEwXG4gICAgXG4gICAgdmFyIGl0SXMgPSB0aGlzLnZpZXdNb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmlzU2VsZWN0aW9uTW9kZSgpO1xuXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEudGl0bGUpIHtcbiAgICAgICAgLy8gUmVwbGFjZSB0aXRsZSBieSB0aXRsZSBpZiByZXF1aXJlZFxuICAgICAgICB0aGlzLm5hdkJhci50aXRsZSh0aGlzLnJlcXVlc3REYXRhLnRpdGxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRpdGxlIG11c3QgYmUgZW1wdHlcbiAgICAgICAgdGhpcy5uYXZCYXIudGl0bGUoJycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmspIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0VG9DYW5jZWxBY3Rpb24odGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLCB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmssIHRoaXMucmVxdWVzdERhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVzZXQgdG8gZGVmYXVsdHMsIG9yIGdpdmVuIHRpdGxlOlxuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkubW9kZWwudXBkYXRlV2l0aCh0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEubmF2VGl0bGUpXG4gICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCh0aGlzLnJlcXVlc3REYXRhLm5hdlRpdGxlKTtcblxuICAgICAgICB2YXIgamlkID0gdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCgpLFxuICAgICAgICAgICAgam5hbWUgPSB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZSgpICYmIHRoaXMudmlld01vZGVsLmpvYlRpdGxlKCkuc2luZ3VsYXJOYW1lKCkgfHwgJ1NjaGVkdWxpbmcnLFxuICAgICAgICAgICAgdXJsID0gdGhpcy5tdXN0UmV0dXJuVG8gfHwgKGppZCAmJiAnL2pvYnRpdGxlcy8nICsgamlkIHx8ICcvc2NoZWR1bGluZycpO1xuXG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5saW5rKHVybCk7XG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KGpuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXRJcyAmJiAhdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKSB7XG4gICAgICAgIC8vIFVzZXMgYSBjdXN0b20gaGFuZGxlciBzbyBpdCByZXR1cm5zIGtlZXBpbmcgdGhlIGdpdmVuIHN0YXRlOlxuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkuaGFuZGxlcih0aGlzLnJldHVyblJlcXVlc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKSB7XG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5oYW5kbGVyKG51bGwpO1xuICAgIH1cbn07XG5cbkEucHJvdG90eXBlLnVwZGF0ZU5hdkJhclN0YXRlID0gZnVuY3Rpb24gdXBkYXRlTmF2QmFyU3RhdGUoKSB7XG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eToxMlxuXG4gICAgdmFyIGl0SXMgPSB0aGlzLnZpZXdNb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmlzU2VsZWN0aW9uTW9kZSgpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsLmhlYWRlclRleHQoaXRJcyA/ICdTZWxlY3Qgb3IgYWRkIGEgc2VydmljZSBsb2NhdGlvbicgOiAnTG9jYXRpb25zJyk7XG5cbiAgICAvLyBQZXJmb3JtIHVwZGF0ZXMgdGhhdCBhcHBseSB0aGlzIHJlcXVlc3Q6XG4gICAgdGhpcy5hcHAubW9kZWwub25ib2FyZGluZy51cGRhdGVOYXZCYXIodGhpcy5uYXZCYXIpIHx8XG4gICAgLy90aGlzLmFwcC5hcHBseU5hdmJhck11c3RSZXR1cm4odGhpcy5yZXF1ZXN0RGF0YSkgfHxcbiAgICB0aGlzLmFwcGx5T3duTmF2YmFyUnVsZXMoKTtcbn07XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIFJlbWVtYmVyIHJvdXRlIHRvIGdvIGJhY2ssIGZyb20gYSByZXF1ZXN0IG9mICdtdXN0UmV0dXJuJyBvciBsYXN0IHJlcXVlc3RlZFxuICAgIHRoaXMubXVzdFJldHVyblRvID0gdGhpcy5yZXF1ZXN0RGF0YS5yb3V0ZS5xdWVyeS5tdXN0UmV0dXJuIHx8IHRoaXMubXVzdFJldHVyblRvO1xuXG4gICAgLy8gUmVzZXQ6IGF2b2lkaW5nIGVycm9ycyBiZWNhdXNlIHBlcnNpc3RlZCBkYXRhIGZvciBkaWZmZXJlbnQgSUQgb24gbG9hZGluZ1xuICAgIC8vIG9yIG91dGRhdGVkIGluZm8gZm9yY2luZyB1cGRhdGVcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKDApO1xuICAgIHRoaXMudmlld01vZGVsLnJlcXVlc3REYXRhID0gdGhpcy5yZXF1ZXN0RGF0YTtcblxuICAgIHRoaXMudmlld01vZGVsLnNlcnZpY2VBZGRyZXNzZXMuaXNTZWxlY3Rpb25Nb2RlKG9wdGlvbnMuc2VsZWN0QWRkcmVzcyA9PT0gdHJ1ZSk7XG4gICAgdGhpcy52aWV3TW9kZWwuY2xpZW50SUQob3B0aW9ucy5jbGllbnRJRCB8fCBudWxsKTtcblxuICAgIHZhciBwYXJhbXMgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cztcbiAgICB2YXIgam9iVGl0bGVJRCA9IHBhcmFtc1swXSB8MDtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBpdCBjb21lcyBmcm9tIGFuIGFkZHJlc3NFZGl0b3IgdGhhdFxuICAgIC8vIHJlY2VpdmVkIHRoZSBmbGFnICdyZXR1cm5OZXdBc1NlbGVjdGVkJyBhbmQgYW5cbiAgICAvLyBhZGRyZXNzSUQ6IHdlIHdlcmUgaW4gc2VsZWN0aW9uIG1vZGUtPmNyZWF0aW5nIGFkZHJlc3MtPm11c3RcbiAgICAvLyByZXR1cm4gdGhlIGp1c3QgY3JlYXRlZCBhZGRyZXNzIHRvIHRoZSBwcmV2aW91cyBwYWdlXG4gICAgaWYgKG9wdGlvbnMucmV0dXJuTmV3QXNTZWxlY3RlZCA9PT0gdHJ1ZSAmJlxuICAgICAgICBvcHRpb25zLmFkZHJlc3NJRCkge1xuICAgICAgICBcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnJldHVybk5ld0FzU2VsZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5yZXR1cm5TZWxlY3RlZChvcHRpb25zLmFkZHJlc3NJRCwgam9iVGl0bGVJRCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgMSk7XG4gICAgICAgIC8vIHF1aWNrIHJldHVyblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRChqb2JUaXRsZUlEKTtcblxuICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcbiAgICBcbiAgICBpZiAoam9iVGl0bGVJRCA9PT0gMCkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZXMuc3luYygpO1xuICAgIH1cbn07XG5cbnZhciBVc2VySm9iUHJvZmlsZSA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvVXNlckpvYlByb2ZpbGUnKSxcbiAgICBTZXJ2aWNlQWRkcmVzc2VzID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9TZXJ2aWNlQWRkcmVzc2VzJyk7XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLnNlcnZpY2VBZGRyZXNzZXMgPSBuZXcgU2VydmljZUFkZHJlc3NlcygpO1xuXG4gICAgdGhpcy5oZWFkZXJUZXh0ID0ga28ub2JzZXJ2YWJsZSgnTG9jYXRpb25zJyk7XG4gICAgXG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICB0aGlzLmpvYlRpdGxlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICAvLyBPcHRpb25hbGx5LCBzb21lIHRpbWVzIGEgY2xpZW50SUQgY2FuIGJlIHBhc3NlZCBpbiBvcmRlciB0byBjcmVhdGVcbiAgICAvLyBhIGxvY2F0aW9uIGZvciB0aGF0IGNsaWVudCB3aGVyZSBwZXJmb3JtIGEgd29yay5cbiAgICB0aGlzLmNsaWVudElEID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICBcbiAgICB0aGlzLmpvYlRpdGxlcyA9IG5ldyBVc2VySm9iUHJvZmlsZShhcHApO1xuICAgIHRoaXMuam9iVGl0bGVzLmJhc2VVcmwoJy9zZXJ2aWNlQWRkcmVzcycpO1xuICAgIHRoaXMuam9iVGl0bGVzLnNlbGVjdEpvYlRpdGxlID0gZnVuY3Rpb24oam9iVGl0bGUpIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuam9iVGl0bGVJRChqb2JUaXRsZS5qb2JUaXRsZUlEKCkpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLnNlcnZpY2VBZGRyZXNzZXMuc3RhdGUuaXNTeW5jaW5nKCk7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFkZCA9IGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLnN0YXRlLmlzTG9hZGluZygpLFxuICAgICAgICAgICAgam9icyA9IHRoaXMuam9iVGl0bGVzLmlzTG9hZGluZygpO1xuICAgICAgICByZXR1cm4gYWRkIHx8IGpvYnM7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5nb05leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSkge1xuICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuZ29OZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUmVwbGFjZSBkZWZhdWx0IHNlbGVjdEFkZHJlc3NcbiAgICB0aGlzLnNlcnZpY2VBZGRyZXNzZXMuc2VsZWN0QWRkcmVzcyA9IGZ1bmN0aW9uKHNlbGVjdGVkQWRkcmVzcywgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZUFkZHJlc3Nlcy5pc1NlbGVjdGlvbk1vZGUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gUnVuIG1ldGhvZCBpbmplY3RlZCBieSB0aGUgYWN0aXZpdHkgdG8gcmV0dXJuIGEgXG4gICAgICAgICAgICAvLyBzZWxlY3RlZCBhZGRyZXNzOlxuICAgICAgICAgICAgdGhpcy5yZXR1cm5TZWxlY3RlZChcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3MuYWRkcmVzc0lEKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzLmpvYlRpdGxlSUQoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFwcC5zaGVsbC5nbygnYWRkcmVzc0VkaXRvci9zZXJ2aWNlLycgK1xuICAgICAgICAgICAgICAgIHRoaXMuam9iVGl0bGVJRCgpICtcbiAgICAgICAgICAgICAgICAnLycgKyBzZWxlY3RlZEFkZHJlc3MuYWRkcmVzc0lEKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuYWRkU2VydmljZUxvY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cmwgPSAnIyFhZGRyZXNzRWRpdG9yL3NlcnZpY2UvJyArIHRoaXMuam9iVGl0bGVJRCgpICsgJy9zZXJ2aWNlTG9jYXRpb24nO1xuICAgICAgICB2YXIgcmVxdWVzdCA9ICQuZXh0ZW5kKHt9LCB0aGlzLnJlcXVlc3REYXRhLCB7XG4gICAgICAgICAgICByZXR1cm5OZXdBc1NlbGVjdGVkOiB0aGlzLnNlcnZpY2VBZGRyZXNzZXMuaXNTZWxlY3Rpb25Nb2RlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcC5zaGVsbC5nbyh1cmwsIHJlcXVlc3QpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmFkZFNlcnZpY2VBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cmwgPSAnIyFhZGRyZXNzRWRpdG9yL3NlcnZpY2UvJyArIHRoaXMuam9iVGl0bGVJRCgpICsgJy9zZXJ2aWNlQXJlYSc7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gJC5leHRlbmQoe30sIHRoaXMucmVxdWVzdERhdGEsIHtcbiAgICAgICAgICAgIHJldHVybk5ld0FzU2VsZWN0ZWQ6IHRoaXMuc2VydmljZUFkZHJlc3Nlcy5pc1NlbGVjdGlvbk1vZGUoKVxuICAgICAgICB9KTtcbiAgICAgICAgYXBwLnNoZWxsLmdvKHVybCwgcmVxdWVzdCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuYWRkQ2xpZW50TG9jYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVybCA9ICcjIWFkZHJlc3NFZGl0b3Ivc2VydmljZS8nICsgdGhpcy5qb2JUaXRsZUlEKCkgKyAnL2NsaWVudExvY2F0aW9uLycgKyB0aGlzLmNsaWVudElEKCk7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gJC5leHRlbmQoe30sIHRoaXMucmVxdWVzdERhdGEsIHtcbiAgICAgICAgICAgIHJldHVybk5ld0FzU2VsZWN0ZWQ6IHRoaXMuc2VydmljZUFkZHJlc3Nlcy5pc1NlbGVjdGlvbk1vZGUoKVxuICAgICAgICB9KTtcbiAgICAgICAgYXBwLnNoZWxsLmdvKHVybCwgcmVxdWVzdCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMub25ib2FyZGluZ05leHRSZWFkeSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNpbiA9IGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSxcbiAgICAgICAgICAgIGhhc0l0ZW1zID0gdGhpcy5zZXJ2aWNlQWRkcmVzc2VzLnNvdXJjZUFkZHJlc3NlcygpLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgcmV0dXJuIGlzaW4gJiYgaGFzSXRlbXM7XG4gICAgfSwgdGhpcyk7XG59XG4iLCIvKipcbiAgICBTZXJ2aWNlUHJvZmVzc2lvbmFsIFNlcnZpY2UgYWN0aXZpdHlcbiAgICBcbiAgICBUT0RPOiBVc2UgU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UgVmlld01vZGVsIGFuZCB0ZW1wbGF0ZVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLnNlcnZpY2VQcm9mZXNzaW9uYWw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKHRoaXMuYXBwKTtcbiAgICAvLyBEZWZhdWx0cyBzZXR0aW5ncyBmb3IgbmF2QmFyLlxuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignSm9iIFRpdGxlJywge1xuICAgICAgICBiYWNrTGluazogJy9zY2hlZHVsaW5nJ1xuICAgIH0pO1xuICAgIC8vIFNhdmUgZGVmYXVsdHMgdG8gcmVzdG9yZSBvbiB1cGRhdGVOYXZCYXJTdGF0ZSB3aGVuIG5lZWRlZDpcbiAgICB0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uID0gdGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XG4gICAgXG4gICAgLy8gT24gY2hhbmdpbmcgam9iVGl0bGVJRDpcbiAgICAvLyAtIGxvYWQgcHJpY2luZ1xuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZSxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oLypqb2JUaXRsZSovKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgbmF2YmFyIChtYXkgaW5kaWNhdGUgdGhlIGpvYlRpdGxlIG5hbWUpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgLy8gT24gY2hhbmdpbmcgam9iVGl0bGVJRDpcbiAgICAvLyAtIGxvYWQgcHJpY2luZ1xuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlELFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XG4gICAgICAgICAgICBpZiAoam9iVGl0bGVJRCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBkYXRhIGZvciB0aGUgSm9iIHRpdGxlIElEIGFuZCBwcmljaW5nIHR5cGVzLlxuICAgICAgICAgICAgICAgIC8vIFRoZXkgYXJlIGVzc2VudGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRMaXN0KClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpvYlRpdGxlID0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBmb3IgdXNlIGluIHRoZSB2aWV3XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlKGpvYlRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHByaWNpbmdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5nZXRMaXN0KGpvYlRpdGxlSUQpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5hc01vZGVsKGxpc3QpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBwcmVzZXRzIHNlbGVjdGlvbiBmcm9tIHJlcXVlc3REYXRhXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVzZXQgPSB0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkU2VydmljZXMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB0aGlzLnZpZXdNb2RlbC5zZWxlY3RlZFNlcnZpY2VzO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBpc1NlbGVjdGVkIHByb3BlcnR5IHRvIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZVNlbGVjdGVkID0gcHJlc2V0LnNvbWUoZnVuY3Rpb24ocHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHIuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCA9PT0gaXRlbS5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaXNTZWxlY3RlZCA9IGtvLm9ic2VydmFibGUocHJlU2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxpc3QobGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5saXN0KFtdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgXG4gICAgLy8gR28gYmFjayB3aXRoIHRoZSBzZWxlY3RlZCBwcmljaW5nIHdoZW4gdHJpZ2dlcmVkIGluIHRoZSBmb3JtL3ZpZXdcbiAgICB0aGlzLnZpZXdNb2RlbC5yZXR1cm5TZWxlY3RlZCA9IGZ1bmN0aW9uKHByaWNpbmcsIGpvYlRpdGxlSUQpIHtcbiAgICAgICAgLy8gUGFzcyB0aGUgc2VsZWN0ZWQgY2xpZW50IGluIHRoZSBpbmZvXG4gICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRTZXJ2aWNlcyA9IHByaWNpbmc7XG4gICAgICAgIHRoaXMucmVxdWVzdERhdGEuc2VsZWN0ZWRKb2JUaXRsZUlEID0gam9iVGl0bGVJRDtcbiAgICAgICAgLy8gQW5kIGdvIGJhY2tcbiAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnJldHVyblJlcXVlc3QgPSBmdW5jdGlvbiByZXR1cm5SZXF1ZXN0KCkge1xuICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2sodGhpcy5yZXF1ZXN0RGF0YSk7XG4gICAgfS5iaW5kKHRoaXMpO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuYXBwbHlPd25OYXZiYXJSdWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6MTBcbiAgICBcbiAgICB2YXIgaXRJcyA9IHRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZSgpO1xuXG4gICAgaWYgKHRoaXMucmVxdWVzdERhdGEudGl0bGUpIHtcbiAgICAgICAgLy8gUmVwbGFjZSB0aXRsZSBieSB0aXRsZSBpZiByZXF1aXJlZFxuICAgICAgICB0aGlzLm5hdkJhci50aXRsZSh0aGlzLnJlcXVlc3REYXRhLnRpdGxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRpdGxlIG11c3QgYmUgZW1wdHlcbiAgICAgICAgdGhpcy5uYXZCYXIudGl0bGUoJycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmspIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0VG9DYW5jZWxBY3Rpb24odGhpcy5uYXZCYXIubGVmdEFjdGlvbigpLCB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmssIHRoaXMucmVxdWVzdERhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVzZXQgdG8gZGVmYXVsdHMsIG9yIGdpdmVuIHRpdGxlOlxuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkubW9kZWwudXBkYXRlV2l0aCh0aGlzLmRlZmF1bHRMZWZ0QWN0aW9uLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdERhdGEubmF2VGl0bGUpXG4gICAgICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCh0aGlzLnJlcXVlc3REYXRhLm5hdlRpdGxlKTtcblxuICAgICAgICB2YXIgamlkID0gdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCgpLFxuICAgICAgICAgICAgam5hbWUgPSB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZSgpICYmIHRoaXMudmlld01vZGVsLmpvYlRpdGxlKCkuc2luZ3VsYXJOYW1lKCkgfHwgJ1NjaGVkdWxpbmcnLFxuICAgICAgICAgICAgdXJsID0gdGhpcy5tdXN0UmV0dXJuVG8gfHwgKGppZCAmJiAnL2pvYnRpdGxlcy8nICsgamlkIHx8ICcvc2NoZWR1bGluZycpO1xuXG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5saW5rKHVybCk7XG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS50ZXh0KGpuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXRJcyAmJiAhdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKSB7XG4gICAgICAgIC8vIFVzZXMgYSBjdXN0b20gaGFuZGxlciBzbyBpdCByZXR1cm5zIGtlZXBpbmcgdGhlIGdpdmVuIHN0YXRlOlxuICAgICAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkuaGFuZGxlcih0aGlzLnJldHVyblJlcXVlc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdGhpcy5yZXF1ZXN0RGF0YS5jYW5jZWxMaW5rKSB7XG4gICAgICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5oYW5kbGVyKG51bGwpO1xuICAgIH1cbn07XG5cbkEucHJvdG90eXBlLnVwZGF0ZU5hdkJhclN0YXRlID0gZnVuY3Rpb24gdXBkYXRlTmF2QmFyU3RhdGUoKSB7XG4gICAgdmFyIGl0SXMgPSB0aGlzLnZpZXdNb2RlbC5pc1NlbGVjdGlvbk1vZGUoKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXJUZXh0KGl0SXMgPyAnU2VsZWN0IHNlcnZpY2VzJyA6ICdTZXJ2aWNlcycpO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gdXBkYXRlcyB0aGF0IGFwcGx5IHRoaXMgcmVxdWVzdDpcbiAgICB0aGlzLmFwcC5tb2RlbC5vbmJvYXJkaW5nLnVwZGF0ZU5hdkJhcih0aGlzLm5hdkJhcikgfHxcbiAgICAvL3RoaXMuYXBwLmFwcGx5TmF2YmFyTXVzdFJldHVybih0aGlzLnJlcXVlc3REYXRhKSB8fFxuICAgIHRoaXMuYXBwbHlPd25OYXZiYXJSdWxlcygpO1xufTtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6OFxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgXG4gICAgLy8gUmVtZW1iZXIgcm91dGUgdG8gZ28gYmFjaywgZnJvbSBhIHJlcXVlc3Qgb2YgJ211c3RSZXR1cm4nIG9yIGxhc3QgcmVxdWVzdGVkXG4gICAgdGhpcy5tdXN0UmV0dXJuVG8gPSB0aGlzLnJlcXVlc3REYXRhLnJvdXRlLnF1ZXJ5Lm11c3RSZXR1cm4gfHwgdGhpcy5tdXN0UmV0dXJuVG87XG4gICAgICAgIFxuICAgIFxuICAgIC8vIFJlc2V0OiBhdm9pZGluZyBlcnJvcnMgYmVjYXVzZSBwZXJzaXN0ZWQgZGF0YSBmb3IgZGlmZmVyZW50IElEIG9uIGxvYWRpbmdcbiAgICAvLyBvciBvdXRkYXRlZCBpbmZvIGZvcmNpbmcgdXBkYXRlXG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCgwKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5zZWxlY3RlZFNlcnZpY2VzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMudmlld01vZGVsLnJlcXVlc3REYXRhID0gdGhpcy5yZXF1ZXN0RGF0YTtcblxuICAgIHRoaXMudmlld01vZGVsLmlzU2VsZWN0aW9uTW9kZSh0aGlzLnJlcXVlc3REYXRhLnNlbGVjdFByaWNpbmcgPT09IHRydWUpO1xuICAgIFxuICAgIC8vIFBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50cztcbiAgICB2YXIgam9iVGl0bGVJRCA9IHBhcmFtc1swXSB8MDtcbiAgICBpZiAoam9iVGl0bGVJRCA9PT0gMCAmJiBvcHRpb25zLnNlbGVjdGVkSm9iVGl0bGVJRCA+IDApXG4gICAgICAgIGpvYlRpdGxlSUQgPSBvcHRpb25zLnNlbGVjdGVkSm9iVGl0bGVJRCB8MDtcblxuICAgIHZhciBpc0FkZGl0aW9uTW9kZSA9IHBhcmFtc1swXSA9PT0gJ25ldycgfHwgcGFyYW1zWzFdID09PSAnbmV3JztcbiAgICBpZiAoaXNBZGRpdGlvbk1vZGUpIHtcbiAgICAgICAgLy8gU2V0cyByZWZlcnJlciBhcyBjYW5jZWxMaW5rXG4gICAgICAgIHZhciByZWYgPSB0aGlzLmFwcC5zaGVsbC5yZWZlcnJlclJvdXRlO1xuICAgICAgICByZWYgPSByZWYgJiYgcmVmLnVybCB8fCAnLyc7XG4gICAgICAgIHRoaXMucmVxdWVzdERhdGEuY2FuY2VsTGluayA9IHJlZjtcbiAgICAgICAgLy8gU2V0IGZvciBlZGl0b3IgbGlua3MgaW4gdGhlIHZpZXdcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY2FuY2VsTGluayhyZWYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU2V0IHRoaXMgcGFnZSBhcyBjYW5jZWxMaW5rIGZvciBlZGl0b3IgbGlua3MgaW4gdGhlIHZpZXdcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY2FuY2VsTGluaygnL3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlLycgKyB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKCkpO1xuICAgIH1cblxuICAgIHRoaXMudmlld01vZGVsLmlzQWRkaXRpb25Nb2RlKGlzQWRkaXRpb25Nb2RlKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZU5hdkJhclN0YXRlKCk7XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYlRpdGxlSUQpO1xuICAgIFxuICAgIGlmIChqb2JUaXRsZUlEID09PSAwKSB7XG4gICAgICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlcy5zeW5jKCk7XG4gICAgfVxufTtcblxudmFyIFVzZXJKb2JQcm9maWxlID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9Vc2VySm9iUHJvZmlsZScpO1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmhlYWRlclRleHQgPSBrby5vYnNlcnZhYmxlKCdTZXJ2aWNlcycpO1xuICAgIFxuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5qb2JUaXRsZSA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5pc0FkZGl0aW9uTW9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuY2FuY2VsTGluayA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgXG4gICAgdGhpcy5qb2JUaXRsZXMgPSBuZXcgVXNlckpvYlByb2ZpbGUoYXBwKTtcbiAgICB0aGlzLmpvYlRpdGxlcy5iYXNlVXJsKCcvc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UnKTtcbiAgICB0aGlzLmpvYlRpdGxlcy5zZWxlY3RKb2JUaXRsZSA9IGZ1bmN0aW9uKGpvYlRpdGxlKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmpvYlRpdGxlSUQoam9iVGl0bGUuam9iVGl0bGVJRCgpKTtcbiAgICAgICAgdmFyIHVybCA9ICdzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZS8nICsgam9iVGl0bGUuam9iVGl0bGVJRCgpO1xuICAgICAgICBpZiAodGhpcy5pc0FkZGl0aW9uTW9kZSgpKVxuICAgICAgICAgICAgdXJsICs9ICcvbmV3JztcbiAgICAgICAgLy8gcHVzaFN0YXRlIGNhbm5vdCBiZSB1c2VkIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGggdGhlIFxuICAgICAgICAvLyBzZWxlY3Rpb24gbG9naWMgKG9uIG5ldy1ib29raW5nIHByb2dyZXNzKVxuICAgICAgICAvLyBUT0RPOiBjb21tZW50ZWQgdW50aWwgdGhlIGJ1ZyB3aXRoIHJlcGxhY2VTdGF0ZSBpbiBIYXNoYmFuZ0hpc3RvcnkgaXMgZml4ZWRcbiAgICAgICAgLy9hcHAuc2hlbGwucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIHVybCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5saXN0ID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcblxuICAgIHRoaXMuaXNMb2FkaW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBhcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLnN0YXRlLmlzTG9hZGluZygpIHx8XG4gICAgICAgICAgICBhcHAubW9kZWwucHJpY2luZ1R5cGVzLnN0YXRlLmlzTG9hZGluZygpIHx8XG4gICAgICAgICAgICBhcHAubW9kZWwuam9iVGl0bGVzLnN0YXRlLmlzTG9hZGluZygpXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgdGhpcy5pc0xvY2tlZCA9IHRoaXMuaXNMb2FkaW5nO1xuXG4gICAgLy8gRXNwZWNpYWwgbW9kZSB3aGVuIGluc3RlYWQgb2YgcGljayBhbmQgZWRpdCB3ZSBhcmUganVzdCBzZWxlY3RpbmdcbiAgICB0aGlzLmlzU2VsZWN0aW9uTW9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxuICAgICAgICAgICAgICAgICdsb2FkaW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgICdTYXZlIGFuZCBjb250aW51ZSdcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICAvLyBHcm91cGVkIGxpc3Qgb2YgcHJpY2luZ3M6XG4gICAgLy8gRGVmaW5lZCBncm91cHMgYnkgcHJpY2luZyB0eXBlXG4gICAgdGhpcy5ncm91cGVkU2VydmljZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0KCk7XG4gICAgICAgIHZhciBpc1NlbGVjdGlvbiA9IHRoaXMuaXNTZWxlY3Rpb25Nb2RlKCk7XG4gICAgICAgIHZhciBncm91cE5hbWVQcmVmaXggPSBpc1NlbGVjdGlvbiA/ICdTZWxlY3QgJyA6ICcnO1xuXG4gICAgICAgIHZhciBncm91cHMgPSBbXSxcbiAgICAgICAgICAgIGdyb3Vwc0xpc3QgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWRkaXRpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgIGdyb3VwcyA9IF8uZ3JvdXBCeShsaXN0LCBmdW5jdGlvbihwcmljaW5nSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmljaW5nSXRlbS5wcmljaW5nVHlwZUlEKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgaW5kZXhlZCBvYmplY3QgaW50byBhbiBhcnJheSB3aXRoIHNvbWUgbWV0YS1kYXRhXG4gICAgICAgICAgICBncm91cHNMaXN0ID0gT2JqZWN0LmtleXMoZ3JvdXBzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmljaW5nOiBncm91cHNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgcHJpY2luZyBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHAubW9kZWwucHJpY2luZ1R5cGVzLmdldE9ic2VydmFibGVJdGVtKGtleSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdyLmdyb3VwID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cE5hbWVQcmVmaXggKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUoKSAmJiB0aGlzLnR5cGUoKS5wbHVyYWxOYW1lKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZXJ2aWNlcydcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LCBncik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNpbmNlIHRoZSBncm91cHNMaXN0IGlzIGJ1aWx0IGZyb20gdGhlIGV4aXN0ZW50IHByaWNpbmcgaXRlbXNcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHJlY29yZHMgZm9yIHNvbWUgcHJpY2luZyB0eXBlIChvciBub3RoaW5nIHdoZW5cbiAgICAgICAgLy8ganVzdCBjcmVhdGVkIHRoZSBqb2IgdGl0bGUpLCB0aGF0IHR5cGVzL2dyb3VwcyBhcmUgbm90IGluY2x1ZGVkLFxuICAgICAgICAvLyBzbyByZXZpZXcgYW5kIGluY2x1ZGUgbm93LlxuICAgICAgICAvLyBOT1RFOiBhcyBhIGdvb2Qgc2lkZSBlZmZlY3Qgb2YgdGhpcyBhcHByb2FjaCwgcHJpY2luZyB0eXBlcyB3aXRoXG4gICAgICAgIC8vIHNvbWUgcHJpY2luZyB3aWxsIGFwcGVhciBmaXJzdCBpbiB0aGUgbGlzdCAobmVhcmVzdCB0byB0aGUgdG9wKVxuICAgICAgICB2YXIgcHJpY2luZ1R5cGVzID0gdGhpcy5qb2JUaXRsZSgpICYmIHRoaXMuam9iVGl0bGUoKS5wcmljaW5nVHlwZXMoKTtcbiAgICAgICAgaWYgKHByaWNpbmdUeXBlcyAmJiBwcmljaW5nVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmljaW5nVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoam9iVHlwZSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciB0eXBlSUQgPSBqb2JUeXBlLnByaWNpbmdUeXBlSUQoKTtcbiAgICAgICAgICAgICAgICAvLyBOb3QgaWYgYWxyZWFkeSBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGlmIChncm91cHMuaGFzT3duUHJvcGVydHkodHlwZUlEKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGdyID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmljaW5nOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRPYnNlcnZhYmxlSXRlbSh0eXBlSUQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBnci5ncm91cCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBOYW1lUHJlZml4ICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlKCkgJiYgdGhpcy50eXBlKCkucGx1cmFsTmFtZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VydmljZXMnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgZ3IpO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXBzTGlzdC5wdXNoKGdyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyb3Vwc0xpc3Q7XG5cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc2VsZWN0ZWRTZXJ2aWNlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgLyoqXG4gICAgICAgIFRvZ2dsZSB0aGUgc2VsZWN0aW9uIHN0YXR1cyBvZiBhIHByaWNpbmcsIGFkZGluZ1xuICAgICAgICBvciByZW1vdmluZyBpdCBmcm9tIHRoZSAnc2VsZWN0ZWRTZXJ2aWNlcycgYXJyYXkuXG4gICAgKiovXG4gICAgdGhpcy50b2dnbGVTZXJ2aWNlU2VsZWN0aW9uID0gZnVuY3Rpb24ocHJpY2luZykge1xuXG4gICAgICAgIHZhciBpbkluZGV4ID0gLTEsXG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFNlcnZpY2VzKCkuc29tZShmdW5jdGlvbihzZWxlY3RlZFNlcnZpY2VzLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkU2VydmljZXMgPT09IHByaWNpbmcpIHtcbiAgICAgICAgICAgICAgICBpbkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByaWNpbmcuaXNTZWxlY3RlZCghaXNTZWxlY3RlZCk7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2VydmljZXMuc3BsaWNlKGluSW5kZXgsIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2VydmljZXMucHVzaChwcmljaW5nKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5vbmJvYXJkaW5nTmV4dFJlYWR5ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc2luID0gYXBwLm1vZGVsLm9uYm9hcmRpbmcuaW5Qcm9ncmVzcygpLFxuICAgICAgICAgICAgaGFzUHJpY2luZyA9IHRoaXMubGlzdCgpLmxlbmd0aCA+IDA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaXNpbiAmJiBoYXNQcmljaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8qKlxuICAgICAgICBFbmRzIHRoZSBzZWxlY3Rpb24gcHJvY2VzcywgcmVhZHkgdG8gY29sbGVjdCBzZWxlY3Rpb25cbiAgICAgICAgYW5kIHBhc3NpbmcgaXQgdG8gdGhlIHJlcXVlc3RlciBhY3Rpdml0eS5cbiAgICAgICAgV29ya3MgdG9vIHRvIHBhc3MgdG8gdGhlIG5leHQgb25ib2FyZGluZyBzdGVwXG4gICAgKiovXG4gICAgdGhpcy5lbmRTZWxlY3Rpb24gPSBmdW5jdGlvbihkYXRhLCBldmVudCkge1xuICAgICAgICBcbiAgICAgICAgaWYgKGFwcC5tb2RlbC5vbmJvYXJkaW5nLmluUHJvZ3Jlc3MoKSkge1xuICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuZ29OZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSdW4gbWV0aG9kIGluamVjdGVkIGJ5IHRoZSBhY3Rpdml0eSB0byByZXR1cm4gYSBcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkIGFkZHJlc3M6XG4gICAgICAgICAgICB0aGlzLnJldHVyblNlbGVjdGVkKFxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTZXJ2aWNlcygpLm1hcChmdW5jdGlvbihwcmljaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEOiBrby51bndyYXAocHJpY2luZy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUHJpY2U6IGtvLnVud3JhcChwcmljaW5nLnByaWNlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuam9iVGl0bGVJRCgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZWRpdFNlcnZpY2UgPSBmdW5jdGlvbihwcmljaW5nKSB7XG4gICAgICAgIGFwcC5zaGVsbC5nbygnc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VFZGl0b3IvJyArIHRoaXMuam9iVGl0bGVJRCgpICsgJy8nICsgcHJpY2luZy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKCkpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgSGFuZGxlciBmb3IgdGhlIGxpc3R2aWV3IGl0ZW1zLCBtYW5hZ2luZyBlZGl0aW9uIGFuZCBzZWxlY3Rpb24gZGVwZW5kaW5nIG9uIGN1cnJlbnQgbW9kZVxuICAgICoqL1xuICAgIHRoaXMudGFwU2VydmljZSA9IGZ1bmN0aW9uKHByaWNpbmcsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNlcnZpY2VTZWxlY3Rpb24ocHJpY2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRTZXJ2aWNlKHByaWNpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMudGFwTmV3U2VydmljZSA9IGZ1bmN0aW9uKGdyb3VwLCBldmVudCkge1xuICAgICAgICBcbiAgICAgICAgdmFyIHVybCA9ICcjIXNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlRWRpdG9yLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICcvbmV3LycgKyAoZ3JvdXAudHlwZSgpICYmIGdyb3VwLnR5cGUoKS5wcmljaW5nVHlwZUlEKCkpO1xuXG4gICAgICAgIC8vIFBhc3Npbmcgb3JpZ2luYWwgZGF0YSwgZm9yIGluLXByb2dyZXNzIHByb2Nlc3MgKGFzIG5ldy1ib29raW5nKVxuICAgICAgICAvLyBhbmQgdGhlIHNlbGVjdGVkIHRpdGxlIHNpbmNlIHRoZSBVUkwgY291bGQgbm90IGJlIHVwZGF0ZWQgcHJvcGVybHlcbiAgICAgICAgLy8gKHNlZSB0aGUgYW5vdGF0ZWQgY29tbWVudCBhYm91dCByZXBsYWNlU3RhdGUgYnVnIG9uIHRoaXMgZmlsZSlcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAkLmV4dGVuZCh7fSwgdGhpcy5yZXF1ZXN0RGF0YSwge1xuICAgICAgICAgICAgc2VsZWN0ZWRKb2JUaXRsZUlEOiB0aGlzLmpvYlRpdGxlSUQoKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNhbmNlbExpbmspIHtcbiAgICAgICAgICAgICQuZXh0ZW5kKHJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxMaW5rOiB0aGlzLmNhbmNlbExpbmsoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gaW4gc2VsZWN0aW9uIG1vZGU6XG4gICAgICAgIC8vIEFkZCBjdXJyZW50IHNlbGVjdGlvbiBhcyBwcmVzZWxlY3Rpb24sIHNvIGNhbiBiZSByZWNvdmVyZWQgbGF0ZXIgYW5kIFxuICAgICAgICAvLyB0aGUgZWRpdG9yIGNhbiBhZGQgdGhlIG5ldyBwcmljaW5nIHRvIHRoZSBsaXN0XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNlbGVjdGVkU2VydmljZXMgPSB0aGlzLnNlbGVjdGVkU2VydmljZXMoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwcmljaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRDoga28udW53cmFwKHByaWNpbmcuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCksXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUHJpY2U6IGtvLnVud3JhcChwcmljaW5nLnRvdGFsUHJpY2UpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwLnNoZWxsLmdvKHVybCwgcmVxdWVzdCk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuIiwiLyoqXG4gICAgU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VFZGl0b3IgYWN0aXZpdHlcbiAgICBcbiAgICBUT0RPOiBNb2RlbFZlcnNpb24gaXMgTk9UIGJlaW5nIHVzZWQsIHNvIG5vIGdldHRpbmcgdXBkYXRlcyBpZiBzZXJ2ZXIgdXBkYXRlc1xuICAgIHRoZSBkYXRhIGFmdGVyIGxvYWQgKGRhdGEgbG9hZCBpcyByZXF1ZXN0ZWQgYnV0IGdldCBmaXJzdCBmcm9tIGNhY2hlKS4gVXNlXG4gICAgdmVyc2lvbiBhbmQgZ2V0IHN5bmMnZWQgZGF0YSB3aGVuIHJlYWR5LCBhbmQgYWRkaXRpb25hbGx5IG5vdGlmaWNhdGlvbiB0b1xuICAgIG92ZXJyaWRlIGNoYW5nZXMgaWYgc2VydmVyIGRhdGEgaXMgZGlmZmVyZW50IHRoYXQgYW55IGxvY2FsIGNoYW5nZS5cbioqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKSxcbiAgICBQcmljaW5nVHlwZSA9IHJlcXVpcmUoJy4uL21vZGVscy9QcmljaW5nVHlwZScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VFZGl0b3JBY3Rpdml0eSgpIHtcblxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMubmF2QmFyID0gQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhcignU2VydmljZXMnKTtcbiAgICBcbiAgICAvLy8gR28gb3V0IGFmdGVyIHNhdmUgc3VjY2VzZnVsbHkgYW4gaXRlbS5cbiAgICAvLy8gUHJpY2luZyBpcyBhIHBsYWluIG9iamVjdFxuICAgIHRoaXMudmlld01vZGVsLm9uU2F2ZSA9IGZ1bmN0aW9uKHByaWNpbmcpIHtcbiAgICAgICAgLy8gR28gYmFjayBvbiBzYXZlLlxuICAgICAgICAvLyBJZiB3ZSBjb21lcyB3aXRoIGEgc2VsZWN0aW9uIG9mIHByaWNpbmcsIHdlIG11c3QgYWRkIHRoZSBuZXcgb25lXG4gICAgICAgIC8vIHRoZXJlIGFuZCBqdXN0IGdvIGJhY2sgKHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlIGlzIGluIHNlbGVjdGlvbiBtb2RlKSBrZWVwaW5nXG4gICAgICAgIC8vIGFueSByZXF1ZXN0RGF0YSBmb3IgaW4tcHJvZ3Jlc3Mgc3RhdGUuXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3REYXRhLnNlbGVjdGVkU2VydmljZXMpIHtcbiAgICAgICAgICAgIC8vIElzIGFuIGFycmF5IG9mIHBsYWluIG9iamVjdHMgb2YganVzdCBJRCBhbmQgdG90YWxQcmljZVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS5zZWxlY3RlZFNlcnZpY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQ6IHByaWNpbmcuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCxcbiAgICAgICAgICAgICAgICB0b3RhbFByaWNlOiBwcmljaW5nLnRvdGFsUHJpY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSnVzdCBleGVjdXRlIHRoZSBzdGFuZGFyZCBzYXZlIHByb2Nlc3NcbiAgICAgICAgICAgIHRoaXMuYXBwLnN1Y2Nlc3NTYXZlKCk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xuXG4gICAgdmFyIGxpbmsgPSB0aGlzLnJlcXVlc3REYXRhLmNhbmNlbExpbmsgfHwgJy9zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZS8nICsgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRCgpO1xuICAgIFxuICAgIHRoaXMuY29udmVydFRvQ2FuY2VsQWN0aW9uKHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKSwgbGluayk7XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhvcHRpb25zKSB7XG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eToxMCAgICBcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLnZpZXdNb2RlbC53YXNSZW1vdmVkKGZhbHNlKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZVZlcnNpb24obnVsbCk7XG4gICAgdGhpcy52aWV3TW9kZWwucHJpY2luZ1R5cGUobnVsbCk7XG5cbiAgICAvLyBQYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHMgfHwgW107XG5cbiAgICB2YXIgam9iVGl0bGVJRCA9IHBhcmFtc1swXSB8MCxcbiAgICAgICAgLy8gUGFyYW1ldGVyIFsxXSBjYW4gYmUgJ25ldycgZm9sbG93ZWQgYnkgYSBwcmljaW5nVHlwZUlEIGFzIFsyXVxuICAgICAgICBwcmljaW5nVHlwZUlEID0gcGFyYW1zWzFdID09PSAnbmV3JyA/IHBhcmFtc1syXSB8MCA6IDAsXG4gICAgICAgIC8vIE9yIGEgcHJpY2luZ0lEXG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQgPSBwYXJhbXNbMV0gfDA7XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKGpvYlRpdGxlSUQpO1xuICAgIHRoaXMudmlld01vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQoc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCk7XG4gICAgXG4gICAgdGhpcy51cGRhdGVOYXZCYXJTdGF0ZSgpO1xuICAgIFxuICAgIC8qKlxuICAgICAgICBUaGUgcHJpY2luZyByZWNvcmQgbmVlZHMgc29tZSBzcGVjaWFsIHNldC11cCBhZnRlciBjcmVhdGlvbi9sb2FkaW5nIGFuZCBiZWZvcmVcbiAgICAgICAgYmVpbmcgcHJlc2VudGVkIHRvIHRoZSB1c2VyLCBiZWNhdXNlIHNwZWNpYWwgdmFsdWUtcnVsZXMuXG4gICAgKiovXG4gICAgdmFyIHByaWNpbmdTZXR1cCA9IGZ1bmN0aW9uIHByaWNpbmdTZXR1cCgpIHtcbiAgICAgICAgLy8gUHJpY2luZyBmaWVsZHMgdGhhdCBoYXMgYSBzcGVjaWFsIGluaXRpYWwgdmFsdWVcbiAgICAgICAgdmFyIGMgPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50KCk7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAvLyBOYW1lOiBtdXN0IGJlIHRoZSBQcmljaW5nVHlwZS5maXhlZE5hbWUgZXZlciBpZiBhbnksIG9yXG4gICAgICAgICAgICAvLyAgIHRoZSBuYW1lIHNhdmVkIGluIHRoZSBwcmljaW5nIG9yXG4gICAgICAgICAgICAvLyAgIHRoZSBzdWdnZXN0ZWROYW1lIGFzIGxhc3QgZmFsbGJhY2tcbiAgICAgICAgICAgIGMucHJpY2luZy5uYW1lKGMudHlwZS5maXhlZE5hbWUoKSB8fCBjLnByaWNpbmcubmFtZSgpIHx8IGMudHlwZS5zdWdnZXN0ZWROYW1lKCkpO1xuICAgICAgICAgICAgLy8gUmVxdWlyZWQgY2FsbCBhZnRlciBsb2FkaW5nIGEgcHJpY2luZyB0byByZWZsZWN0IGRhdGEgY29ycmVjdGx5IChjYW5ub3QgYmUgYXV0b21hdGVkKVxuICAgICAgICAgICAgYy5wcmljaW5nLnJlZnJlc2hOb1ByaWNlUmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHZhciBzaG93SW52YWxpZFJlcXVlc3RFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgIHRpdGxlOiAnSW52YWxpZCByZXF1ZXN0JyxcbiAgICAgICAgICAgIGVycm9yOiB7IGpvYlRpdGxlSUQ6IGpvYlRpdGxlSUQsIHByaWNpbmdUeXBlSUQ6IHByaWNpbmdUeXBlSUQsIHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQ6IHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQgfVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIE9uIGNsb3NlIG1vZGFsLCBnbyBiYWNrXG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nb0JhY2soKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgaWYgKHByaWNpbmdUeXBlSUQpIHtcbiAgICAgICAgLy8gTG9hZCB0aGUgcHJpY2luZyBUeXBlXG4gICAgICAgIHRoaXMuYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRJdGVtKHByaWNpbmdUeXBlSUQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwucHJpY2luZ1R5cGUodHlwZSk7XG4gICAgICAgICAgICAgICAgLy8gTmV3IHByaWNpbmdcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZVZlcnNpb24odGhpcy5hcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLm5ld0l0ZW1WZXJzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgam9iVGl0bGVJRDogam9iVGl0bGVJRCxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2luZ1R5cGVJRDogcHJpY2luZ1R5cGVJRFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBwcmljaW5nU2V0dXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNob3dJbnZhbGlkUmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBwcmljaW5nXG4gICAgICAgIHRoaXMuYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5nZXRJdGVtVmVyc2lvbihqb2JUaXRsZUlELCBzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VWZXJzaW9uKSB7XG4gICAgICAgICAgICBpZiAoc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgcHJpY2luZyB0eXBlIGJlZm9yZSBwdXQgdGhlIHZlcnNpb25cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRvIGxldCB0aGUgJ2NhdGNoJyB0byBnZXQgYW55IGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRJdGVtKHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlVmVyc2lvbi52ZXJzaW9uLnByaWNpbmdUeXBlSUQoKSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5wcmljaW5nVHlwZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlVmVyc2lvbihzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZVZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2luZ1NldHVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93SW52YWxpZFJlcXVlc3RFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hvd0ludmFsaWRSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE9uIGNsb3NlIG1vZGFsLCBnbyBiYWNrXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2hvd0ludmFsaWRSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czogMzUqL1xuXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICAvLyBtYW5hZ2VkIG1hbnVhbGx5IGluc3RlYWQgb2ZcbiAgICAvL2FwcC5tb2RlbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMuc3RhdGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBhcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzLnN0YXRlLmlzU2F2aW5nO1xuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5zdGF0ZS5pc1N5bmNpbmc7XG4gICAgdGhpcy5pc0RlbGV0aW5nID0gYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5zdGF0ZS5pc0RlbGV0aW5nO1xuICAgIHRoaXMuam9iVGl0bGVJRCA9IGtvLm9ic2VydmFibGUoMCk7XG4gICAgdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICAvLyBMMTBOXG4gICAgdGhpcy5tb25leVN5bWJvbCA9IGtvLm9ic2VydmFibGUoJyQnKTtcbiAgICBcbiAgICB0aGlzLnByaWNpbmdUeXBlID0ga28ub2JzZXJ2YWJsZShuZXcgUHJpY2luZ1R5cGUoKSk7XG5cbiAgICB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlVmVyc2lvbiA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlVmVyc2lvbigpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaGVhZGVyID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdMb2FkaW5nLi4uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlVmVyc2lvbigpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMucHJpY2luZ1R5cGUoKTtcbiAgICAgICAgICAgIHJldHVybiB0ICYmIHQuc2luZ3VsYXJOYW1lKCkgfHwgJ1NlcnZpY2UnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdVbmtub3cgc2VydmljZSBvciB3YXMgZGVsZXRlZCc7XG4gICAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8vIFF1aWNrZXIgYWNjZXNzIGluIGZvcm0sIHVuZGVyIGEgJ3dpdGgnXG4gICAgdGhpcy5jdXJyZW50ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMucHJpY2luZ1R5cGUoKSxcbiAgICAgICAgICAgIHAgPSB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodCAmJiBwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHQsXG4gICAgICAgICAgICAgICAgcHJpY2luZzogcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMud2FzUmVtb3ZlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIFxuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEZWxldGluZygpIHx8IGFwcC5tb2RlbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMuc3RhdGUuaXNMb2NrZWQoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmlzTmV3ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UoKTtcbiAgICAgICAgcmV0dXJuIHAgJiYgIXAudXBkYXRlZERhdGUoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlVmVyc2lvbigpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxuICAgICAgICAgICAgICAgICdMb2FkaW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxuICAgICAgICAgICAgICAgICAgICAnU2F2aW5nIGNoYW5nZXMnIDogXG4gICAgICAgICAgICAgICAgICAgIHYgJiYgdi5hcmVEaWZmZXJlbnQoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnU2F2ZSBjaGFuZ2VzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnU2F2ZWQnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnVuc2F2ZWRDaGFuZ2VzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VWZXJzaW9uKCk7XG4gICAgICAgIHJldHVybiB2ICYmIHYuYXJlRGlmZmVyZW50KCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5kZWxldGVUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0RlbGV0aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnRGVsZXRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgJ0RlbGV0ZSdcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5zZXRJdGVtKHRoaXMuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UoKS5tb2RlbC50b1BsYWluT2JqZWN0KCkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZXJzaW9uIHdpdGggc2VydmVyIGRhdGEuXG4gICAgICAgICAgICB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlKCkubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhKTtcbiAgICAgICAgICAgIC8vIFB1c2ggdmVyc2lvbiBzbyBpdCBhcHBlYXJzIGFzIHNhdmVkXG4gICAgICAgICAgICB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlVmVyc2lvbigpLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWZ0ZXIgc2F2ZSBsb2dpYyBwcm92aWRlZCBieSB0aGUgYWN0aXZpdHksIGluamVjdGVkIGluIHRoZSB2aWV3OlxuICAgICAgICAgICAgdGhpcy5vblNhdmUoc2VydmVyRGF0YSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHNhdmluZy4nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmNvbmZpcm1SZW1vdmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE8gQmV0dGVyIGwxMG4gb3IgcmVwbGFjZSBieSBhIG5ldyBwcmVzZXQgZmllbGQgb24gcHJpY2luZ1R5cGUuZGVsZXRlTGFiZWxcbiAgICAgICAgdmFyIHAgPSB0aGlzLnByaWNpbmdUeXBlKCk7XG4gICAgICAgIGFwcC5tb2RhbHMuY29uZmlybSh7XG4gICAgICAgICAgICB0aXRsZTogJ0RlbGV0ZSAnICsgKHAgJiYgcC5zaW5ndWxhck5hbWUoKSksXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXJlIHlvdSBzdXJlPyBUaGUgb3BlcmF0aW9uIGNhbm5vdCBiZSB1bmRvbmUuJyxcbiAgICAgICAgICAgIHllczogJ0RlbGV0ZScsXG4gICAgICAgICAgICBubzogJ0tlZXAnXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGFwcC5tb2RlbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMuZGVsSXRlbSh0aGlzLmpvYlRpdGxlSUQoKSwgdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKCkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy53YXNSZW1vdmVkKHRydWUpO1xuICAgICAgICAgICAgLy8gR28gb3V0IHRoZSBkZWxldGVkIGxvY2F0aW9uXG4gICAgICAgICAgICBhcHAuc2hlbGwuZ29CYWNrKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGRlbGV0aW5nLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcbn1cbiIsIi8qKlxuICAgIFNlcnZpY2VQcm9mZXNzaW9uYWxXZWJzaXRlIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFNlcnZpY2VQcm9mZXNzaW9uYWxXZWJzaXRlQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSB0aGlzLmFwcC5Vc2VyVHlwZS5zZXJ2aWNlUHJvZmVzc2lvbmFsO1xuXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdNYXJrZXRwbGFjZSBQcm9maWxlJywge1xuICAgICAgICBiYWNrTGluazogJ21hcmtldHBsYWNlUHJvZmlsZSdcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy5hcHAubW9kZWwubWFya2V0cGxhY2VQcm9maWxlLFxuICAgICAgICBldmVudDogJ2Vycm9yJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gZXJyLnRhc2sgPT09ICdzYXZlJyA/ICdFcnJvciBzYXZpbmcgeW91ciB3ZWJzaXRlLicgOiAnRXJyb3IgbG9hZGluZyB5b3VyIHdlYnNpdGUuJztcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxuICAgIHRoaXMuYXBwLm1vZGVsLm1hcmtldHBsYWNlUHJvZmlsZS5zeW5jKCk7XG4gICAgLy8gRGlzY2FyZCBhbnkgcHJldmlvdXMgdW5zYXZlZCBlZGl0XG4gICAgdGhpcy52aWV3TW9kZWwuZGlzY2FyZCgpO1xufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuXG4gICAgdmFyIG1hcmtldHBsYWNlUHJvZmlsZSA9IGFwcC5tb2RlbC5tYXJrZXRwbGFjZVByb2ZpbGU7XG5cbiAgICB2YXIgcHJvZmlsZVZlcnNpb24gPSBtYXJrZXRwbGFjZVByb2ZpbGUubmV3VmVyc2lvbigpO1xuICAgIHByb2ZpbGVWZXJzaW9uLmlzT2Jzb2xldGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGl0SXMpIHtcbiAgICAgICAgaWYgKGl0SXMpIHtcbiAgICAgICAgICAgIC8vIG5ldyB2ZXJzaW9uIGZyb20gc2VydmVyIHdoaWxlIGVkaXRpbmdcbiAgICAgICAgICAgIC8vIEZVVFVSRTogd2FybiBhYm91dCBhIG5ldyByZW1vdGUgdmVyc2lvbiBhc2tpbmdcbiAgICAgICAgICAgIC8vIGNvbmZpcm1hdGlvbiB0byBsb2FkIHRoZW0gb3IgZGlzY2FyZCBhbmQgb3ZlcndyaXRlIHRoZW07XG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBpcyBuZWVkIG9uIHNhdmUoKSwgYW5kIG9uIHNlcnZlciByZXNwb25zZVxuICAgICAgICAgICAgLy8gd2l0aCBhIDUwOTpDb25mbGljdCBzdGF0dXMgKGl0cyBib2R5IG11c3QgY29udGFpbiB0aGVcbiAgICAgICAgICAgIC8vIHNlcnZlciB2ZXJzaW9uKS5cbiAgICAgICAgICAgIC8vIFJpZ2h0IG5vdywganVzdCBvdmVyd3JpdGUgY3VycmVudCBjaGFuZ2VzIHdpdGhcbiAgICAgICAgICAgIC8vIHJlbW90ZSBvbmVzOlxuICAgICAgICAgICAgcHJvZmlsZVZlcnNpb24ucHVsbCh7IGV2ZW5JZk5ld2VyOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWN0dWFsIGRhdGEgZm9yIHRoZSBmb3JtOlxuICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGVWZXJzaW9uLnZlcnNpb247XG5cbiAgICB0aGlzLmlzTG9ja2VkID0gbWFya2V0cGxhY2VQcm9maWxlLmlzTG9ja2VkO1xuXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoKSA/IFxuICAgICAgICAgICAgICAgICdsb2FkaW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxuICAgICAgICAgICAgICAgICAgICAnc2F2aW5nLi4uJyA6IFxuICAgICAgICAgICAgICAgICAgICAnU2F2ZSdcbiAgICAgICAgKTtcbiAgICB9LCBtYXJrZXRwbGFjZVByb2ZpbGUpO1xuICAgIFxuICAgIHRoaXMuZGlzY2FyZCA9IGZ1bmN0aW9uIGRpc2NhcmQoKSB7XG4gICAgICAgIHByb2ZpbGVWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgICAgcHJvZmlsZVZlcnNpb24ucHVzaFNhdmUoKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxuICAgICAgICB9KTtcbiAgICB9O1xufVxuIiwiLyoqXG4gICAgU2VydmljZXNPdmVydmlldyBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbnZhciBBID0gQWN0aXZpdHkuZXh0ZW5kcyhmdW5jdGlvbiBTZXJ2aWNlc092ZXJ2aWV3QWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdKb2IgVGl0bGUnKTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KHN0YXRlKSB7XG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLnZpZXdNb2RlbC5qb2JUaXRsZUlEKG51bGwpO1xuICAgIHRoaXMudmlld01vZGVsLmludHJvKG51bGwpO1xuICAgIHRoaXMudmlld01vZGVsLnNlcnZpY2VBdHRyaWJ1dGVzLnByb3Bvc2VkU2VydmljZUF0dHJpYnV0ZXMoe30pO1xuICAgIFxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIHZhciBwYXJhbXMgPSBzdGF0ZSAmJiBzdGF0ZS5yb3V0ZSAmJiBzdGF0ZS5yb3V0ZS5zZWdtZW50cztcbiAgICB2YXIgamlkID0gcGFyYW1zWzBdIHwwO1xuICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQoamlkKTtcblxuICAgIGlmIChqaWQpIHtcbiAgICAgICAgLy8gTG9hZCBpdFxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmdVc2VySm9iVGl0bGUodHJ1ZSk7XG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLmdldFVzZXJKb2JUaXRsZShqaWQpLFxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc2VydmljZUF0dHJpYnV0ZXNDb250cm9sLmxvYWQoamlkKSxcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXNDb250cm9sLmxvYWQoamlkKVxuICAgICAgICBdKVxuICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhcykge1xuICAgICAgICAgICAgdmFyIHVzZXJKb2JUaXRsZSA9IGRhdGFzICYmIGRhdGFzWzBdO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgZnVsbCByZWNvcmQgZm9yIHRoZSBzYXZpbmdcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsLnVzZXJKb2JUaXRsZSh1c2VySm9iVGl0bGUpO1xuICAgICAgICAgICAgLy8gbG9jYWwgY29weSBvZiBpbnRyb1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaW50cm8odXNlckpvYlRpdGxlLmludHJvKCkpO1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuaXNMb2FkaW5nVXNlckpvYlRpdGxlKGZhbHNlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsb2FkaW5nLicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc0xvYWRpbmdVc2VySm9iVGl0bGUoZmFsc2UpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSnVzdCBlbXB0eVxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5zZXJ2aWNlQXR0cmlidXRlc0NvbnRyb2wucmVzZXQoKTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlc0NvbnRyb2wucmVzZXQoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoYXBwKSB7XG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICBcbiAgICB0aGlzLmlzTG9hZGluZ1VzZXJKb2JUaXRsZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMudXNlckpvYlRpdGxlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICAvLyBMb2NhbCBjb3B5IG9mIHRoZSBpbnRybywgcmF0aGVyIHRoYW4gdXNlXG4gICAgLy8gaXQgZGlyZWN0bHkgZnJvbSB0aGUgdXNlckpvYlRpdGxlIHRvIGF2b2lkIHRoYXQgZ2V0cyBzYXZlZFxuICAgIC8vIGluIG1lbW9yeSB3aXRob3V0IHByZXNzICdzYXZlJ1xuICAgIHRoaXMuaW50cm8gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIFxuICAgIHRoaXMuc2VydmljZUF0dHJpYnV0ZXNDb250cm9sID0gYXBwLm1vZGVsLnNlcnZpY2VBdHRyaWJ1dGVzLm5ld0l0ZW1WZXJzaW9uKCk7XG4gICAgdGhpcy5zZXJ2aWNlQXR0cmlidXRlcyA9IHRoaXMuc2VydmljZUF0dHJpYnV0ZXNDb250cm9sLnZlcnNpb247XG4gICAgdGhpcy5qb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzQ29udHJvbCA9IGFwcC5tb2RlbC5qb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzLm5ld0l0ZW1WZXJzaW9uKCk7XG4gICAgdGhpcy5qb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzID0gdGhpcy5qb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzQ29udHJvbC5vcmlnaW5hbDtcbiAgICBcbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nVXNlckpvYlRpdGxlKCkgfHxcbiAgICAgICAgICAgIHRoaXMuc2VydmljZUF0dHJpYnV0ZXNDb250cm9sLnN0YXRlLmlzTG9hZGluZygpIHx8XG4gICAgICAgICAgICB0aGlzLmpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXNDb250cm9sLnN0YXRlLmlzTG9hZGluZygpXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5pc1NhdmluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTG9hZGluZygpIHx8IHRoaXMuaXNTYXZpbmcoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIENvbWJpbmVkIGFycmF5IG9mIHNlcnZpY2UgYXR0cmlidXRlIGNhdGVnb3JpZXMgZm9yIGFsbCB0aGUgYXZhaWxhYmxlIGFuZFxuICAgIC8vIGluZm9ybWF0aW9uIGZvciB0aGUgc2VsZWN0ZWQgYnkgdGhlIHVzZXIsIHdpdGggbWV0aG9kcyBtb2RpZnkgYW5kIHF1ZXJ5IHRoZSBsaXN0c1xuICAgIHRoaXMuY2F0ZWdvcmllc1ZpZXcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1c2VyQXR0cyA9IHRoaXMuc2VydmljZUF0dHJpYnV0ZXM7XG4gICAgICAgIHJldHVybiB0aGlzLmpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXMuc2VydmljZUF0dHJpYnV0ZXMoKS5tYXAoZnVuY3Rpb24oY2F0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZXNDYXRlZ29yeVZNKGNhdCwgdXNlckF0dHMpO1xuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZygpID8gXG4gICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZygpID9cbiAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmUnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1anQgPSB0aGlzLnVzZXJKb2JUaXRsZSgpO1xuICAgICAgICBpZiAodWp0KSB7XG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nKHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgcGxhaW4gPSB1anQubW9kZWwudG9QbGFpbk9iamVjdCgpO1xuICAgICAgICAgICAgcGxhaW4uaW50cm8gPSB0aGlzLmludHJvKCk7XG5cbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VBdHRyaWJ1dGVzQ29udHJvbC5zYXZlKCksXG4gICAgICAgICAgICAgICAgYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLnNldFVzZXJKb2JUaXRsZShwbGFpbilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBhIGJhY2tncm91bmQgam9iVGl0bGVBdHRyaWJ1dGVzIHJlZnJlc2ggaWYgbmV3IG9uZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBzdWJtaXR0ZWQgZm9yIGluc2VydGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnNlcnZpY2VBdHRyaWJ1dGVzLnByb3Bvc2VkU2VydmljZUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcENhdHMgPSBwcm9wcyAmJiBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BDYXRzICYmIHByb3BDYXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlcmVBcmVOZXdzID0gcHJvcENhdHMucmVkdWNlKGZ1bmN0aW9uKHN1bSwgaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdCA9IHByb3BzW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIChjYXQgJiYgY2F0Lmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCkgPiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhlcmVBcmVOZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXNDb250cm9sLmxvYWQodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VBdHRyaWJ1dGVzLnByb3Bvc2VkU2VydmljZUF0dHJpYnV0ZXMoe30pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHsgdGl0bGU6ICdFcnJvciBzYXZpbmcgeW91ciBTZXJ2aWNlcyBPdmVydmlldycsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuXG52YXIgU2VydmljZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uL21vZGVscy9TZXJ2aWNlQXR0cmlidXRlJyk7XG5cbmZ1bmN0aW9uIEF0dHJpYnV0ZXNDYXRlZ29yeVZNKGNhdCwgdXNlckF0dHMpIHtcbiAgICBcbiAgICB2YXIgY2F0SUQgPSBjYXQuc2VydmljZUF0dHJpYnV0ZUNhdGVnb3J5SUQoKTtcbiAgICB2YXIgc2VsZWN0ZWRBdHRzSWRzID0gdXNlckF0dHMuc2VydmljZUF0dHJpYnV0ZXMuZ2V0U2VydmljZUNhdGVnb3J5QXR0cmlidXRlcyhjYXRJRCk7XG4gICAgdGhpcy5jYXRlZ29yeSA9IGtvLm9ic2VydmFibGUoY2F0KTtcbiAgICBcbiAgICAvLyBBbiBhcnJheSBvZiBtb2RlbHMgZm9yIHZpc3VhbGl6YXRpb24gZnJvbSB0aGUgbGlzdCBvZiBwcm9wb3NlZCBuYW1lcyBmb3IgYWRkaXRpb25cbiAgICB0aGlzLnByb3Bvc2VkU2VydmljZUF0dHJpYnV0ZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHVzZXJBdHRzLnByb3Bvc2VkU2VydmljZUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzW2NhdElEXSAmJiBwcm9wc1tjYXRJRF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNbY2F0SURdLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXJ2aWNlQXR0cmlidXRlKHsgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnNlbGVjdGVkQXR0cmlidXRlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF0dHMgPSBjYXQuc2VydmljZUF0dHJpYnV0ZXMoKS5maWx0ZXIoZnVuY3Rpb24oYXR0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRBdHRzSWRzKCkuaW5kZXhPZihhdHQuc2VydmljZUF0dHJpYnV0ZUlEKCkpID4gLTE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhdHRzLmNvbmNhdC5hcHBseShhdHRzLCB0aGlzLnByb3Bvc2VkU2VydmljZUF0dHJpYnV0ZXMoKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBBdmFpbGFibGUsIG5vdCBzZWxlY3RlZCwgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hdmFpbGFibGVBdHRyaWJ1dGVzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcG9zZWRTZXJ2aWNlQXR0cmlidXRlcygpLFxuICAgICAgICAgICAgYXR0cyA9IHNlbGVjdGVkQXR0c0lkcygpO1xuICAgICAgICByZXR1cm4gY2F0LnNlcnZpY2VBdHRyaWJ1dGVzKCkuZmlsdGVyKGZ1bmN0aW9uKGF0dCkge1xuICAgICAgICAgICAgdmFyIHRvSW5jbHVkZSA9IGF0dHMuaW5kZXhPZihhdHQuc2VydmljZUF0dHJpYnV0ZUlEKCkpID09PSAtMTtcbiAgICAgICAgICAgIGlmICh0b0luY2x1ZGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE5vdCBmb3VuZCBpbiBJRHMsIHRyeSB3aXRoIHByb3Bvc2VkIE5hbWVzOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZXJ5KGZ1bmN0aW9uKHByb3BBdHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0Lm5hbWUoKSAhPT0gcHJvcEF0dC5uYW1lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZVNlYXJjaCA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIHZhciBmb3VuZEF0dEl0ZW0gPSBmdW5jdGlvbihhdHQsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZSgpID09PSBhdHQubmFtZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09uZSA9IHRoaXMuYXR0cmlidXRlU2VhcmNoKCkgfHwgJycsXG4gICAgICAgICAgICBpc0VtcHR5ID0gL15cXHMqJC8udGVzdChuZXdPbmUpLFxuICAgICAgICAgICAgd2FzRm91bmQgPSB0aGlzLnNlbGVjdGVkQXR0cmlidXRlcygpLnNvbWUoZm91bmRBdHRJdGVtLmJpbmQobnVsbCwgeyBuYW1lOiBuZXdPbmUgfSkpO1xuICAgICAgICBpZiAoIWlzRW1wdHkgJiYgIXdhc0ZvdW5kKSB7XG4gICAgICAgICAgICB1c2VyQXR0cy5wcm9wb3NlZFNlcnZpY2VBdHRyaWJ1dGVzLnB1c2goY2F0SUQsIG5ld09uZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuYXR0cmlidXRlU2VhcmNoKCcnKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2VsZWN0QXR0cmlidXRlID0gZnVuY3Rpb24oYXR0KSB7XG4gICAgICAgIHVzZXJBdHRzLnNlcnZpY2VBdHRyaWJ1dGVzLnB1c2goY2F0SUQsIGF0dC5zZXJ2aWNlQXR0cmlidXRlSUQoKSk7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0KSB7XG4gICAgICAgIHZhciBpZCA9IGF0dC5zZXJ2aWNlQXR0cmlidXRlSUQoKTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgdXNlckF0dHMuc2VydmljZUF0dHJpYnV0ZXMucmVtb3ZlKGNhdElELCBpZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVzZXJBdHRzLnByb3Bvc2VkU2VydmljZUF0dHJpYnV0ZXMucmVtb3ZlKGNhdElELCBhdHQubmFtZSgpKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gQXZhaWxhYmxlIGF0dHJpYnV0ZXMgZmlsdGVyZWQgb3V0IGJ5IHRoZSBzZWFyY2ggdGV4dFxuICAgIHZhciB0ZXh0U2VhcmNoID0gcmVxdWlyZSgnLi4vdXRpbHMvdGV4dFNlYXJjaCcpO1xuICAgIHRoaXMuYXV0b2NvbXBsZXRlQXR0cmlidXRlcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuYXR0cmlidXRlU2VhcmNoKCksXG4gICAgICAgICAgICBhID0gdGhpcy5hdmFpbGFibGVBdHRyaWJ1dGVzKCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24oYXR0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFNlYXJjaChzLCBhdHQubmFtZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG59XG4iLCIvKipcbiAgICBTaWdudXAgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5JyksXG4gICAgU2lnbnVwVk0gPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL1NpZ251cCcpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gU2lnbnVwQWN0aXZpdHkoKSB7XG4gICAgXG4gICAgQWN0aXZpdHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFNpZ251cFZNKHRoaXMuYXBwKTtcbiAgICAvLyBudWxsIGZvciBMb2dvXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTZWN0aW9uTmF2QmFyKG51bGwpO1xuICAgIHRoaXMubmF2QmFyLnJpZ2h0QWN0aW9uKG51bGwpO1xuICAgIFxuICAgIC8vIFJlZGlyY2VjdCBvbiBzdWNjZXNzXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLFxuICAgICAgICBldmVudDogJ3NpZ25lZHVwJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHAuZ29EYXNoYm9hcmQpXG4gICAgICAgICAgICAgICAgLy8gSW4gQXBwXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuZ29EYXNoYm9hcmQoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBJbiBTcGxhc2hcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nbygnIyFzcGxhc2hUaGFua3MvJyArIHRoaXMucHJvZmlsZSgpKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRm9jdXMgZmlyc3QgYmFkIGZpZWxkIG9uIGVycm9yXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLFxuICAgICAgICBldmVudDogJ3NpZ251cGVycm9yJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9jdXMgZmlyc3QgZmllbGQgd2l0aCBlcnJvclxuICAgICAgICAgICAgICAgIHZhciAkZWwgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCcuZm9ybS1ncm91cC5oYXMtZXJyb3I6Zmlyc3QnKS5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdHJ5aW5nIHN5bmNocm9ub3VzbHkgd2lsbCBub3Qgd29yayBvbiBzb21lIGNhc2VzXG4gICAgICAgICAgICAgICAgICAgICRlbC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIHRoaXMudmlld01vZGVsLnJlc2V0KCk7XG5cbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIFxuICAgIHZhciBwID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHMgJiYgb3B0aW9ucy5yb3V0ZS5zZWdtZW50c1swXSB8fCAnJztcbiAgICB0aGlzLnZpZXdNb2RlbC5wcm9maWxlKHApO1xufTtcbiIsIi8qKlxuICAgIFRlcm1zIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gVGVybXNBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gQW55IHVzZXIgY2FuIGFjY2VzcyB0aGlzXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IG51bGw7XG4gICAgXG4gICAgLy8gbnVsbCBmb3IgbG9nb3NcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIobnVsbCk7XG4gICAgdGhpcy5uYXZCYXIucmlnaHRBY3Rpb24obnVsbCk7XG4gICAgdGhpcy4kYWN0aXZpdHkuZmluZCgnI3Rlcm1zLWluZGV4IGEnKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICQodGhpcykudGFiKCdzaG93Jyk7XG4gICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCAnIyF0ZXJtcy8nICsgJCh0aGlzKS5hdHRyKCdocmVmJykucmVwbGFjZSgvXiMvLCAnJykpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIHZhciB0YWJOYW1lID0gc3RhdGUgJiYgc3RhdGUucm91dGUuc2VnbWVudHMgJiYgc3RhdGUucm91dGUuc2VnbWVudHNbMF0gfHwgJ3Rlcm1zLW9mLXNlcnZpY2UnO1xuICAgIHZhciB0YWIgPSB0aGlzLiRhY3Rpdml0eS5maW5kKCdbaHJlZj1cIiN0ZXJtcy0nICsgdGFiTmFtZSArICdcIl0nKTtcbiAgICBpZiAodGFiLmxlbmd0aCkgdGFiLnRhYignc2hvdycpO1xufTtcbiIsIi8qKlxuICAgIHRleHRFZGl0b3IgYWN0aXZpdHlcbioqL1xuLy9nbG9iYWwgd2luZG93XG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gVGV4dEVkaXRvckFjdGl2aXR5KCkge1xuICAgIFxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIC8vIFRpdGxlIGlzIGVtcHR5LCBzaW5jZSB3ZSBhcmUgaW4gJ2dvIGJhY2snIG1vZGUgYWxsIHRoZSB0aW1lIGhlcmVcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJycpO1xuICAgIHRoaXMubmF2QmFyLmxlZnRBY3Rpb24oKS5oYW5kbGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xuICAgIH0uYmluZCh0aGlzLnZpZXdNb2RlbCkpO1xuICAgIFxuICAgIC8vIEdldHRpbmcgZWxlbWVudHNcbiAgICB0aGlzLiR0ZXh0YXJlYSA9IHRoaXMuJGFjdGl2aXR5LmZpbmQoJ3RleHRhcmVhJyk7XG4gICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMuJHRleHRhcmVhLmdldCgwKTtcbiAgICBcbiAgICAvLyBIYW5kbGVyIGZvciB0aGUgJ3NhdmVkJyBldmVudCBzbyB0aGUgYWN0aXZpdHlcbiAgICAvLyByZXR1cm5zIGJhY2sgdG8gdGhlIHJlcXVlc3RlciBhY3Rpdml0eSBnaXZpbmcgaXRcbiAgICAvLyB0aGUgbmV3IHRleHRcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwsXG4gICAgICAgIGV2ZW50OiAnc2F2ZWQnLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5mbyB3aXRoIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGF0YS50ZXh0ID0gdGhpcy52aWV3TW9kZWwudGV4dCgpO1xuICAgICAgICAgICAgLy8gYW5kIHBhc3MgaXQgYmFja1xuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGVyIHRoZSBjYW5jZWwgZXZlbnRcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy52aWV3TW9kZWwsXG4gICAgICAgIGV2ZW50OiAnY2FuY2VsJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4sIG5vdGhpbmcgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ29CYWNrKHRoaXMucmVxdWVzdERhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIFNldCBuYXZpZ2F0aW9uIHRpdGxlIG9yIG5vdGhpbmdcbiAgICB0aGlzLm5hdkJhci5sZWZ0QWN0aW9uKCkudGV4dCh0aGlzLnJlcXVlc3REYXRhLm5hdlRpdGxlIHx8ICcnKTtcbiAgICBcbiAgICAvLyBGaWVsZCBoZWFkZXJcbiAgICB0aGlzLnZpZXdNb2RlbC5oZWFkZXJUZXh0KHRoaXMucmVxdWVzdERhdGEuaGVhZGVyKTtcbiAgICB0aGlzLnZpZXdNb2RlbC50ZXh0KHRoaXMucmVxdWVzdERhdGEudGV4dCk7XG4gICAgICAgIFxuICAgIC8vIElubWVkaWF0ZSBmb2N1cyB0byB0aGUgdGV4dGFyZWEgZm9yIGJldHRlciB1c2FiaWxpdHlcbiAgICB0aGlzLnRleHRhcmVhLmZvY3VzKCk7XG4gICAgdGhpcy4kdGV4dGFyZWEuY2xpY2soKTtcbiAgICAvLyBJTVBPUlRBTlQ6IFdPUktBUk9VTkQ6IGZvciBpT1M6IG9uIGlPUyAoY2hlY2tlZCB1cCB0byA4LjMsIDIwMTUtMDUtMjApLCB0aGUgb3BlbmluZyBvZiB0aGUgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIG1ha2VzIGEgc2Nyb2xsIGRvd24gb2YgdGhlIHZpZXdwb3J0LCBoaWRpbmcgdGhlIHRleHQgZmllbGQsIGhlYWRlciwgYW55dGhpbmcsIGFuZCBvbmx5IHRoZVxuICAgIC8vIGJsYW5rIGFyZWEgZ2V0cyBzaG93ZWQuIFRoYXQgYmFkIGF1dG9zY3JvbGwgY2FuIGJlIGZpeGVkIG9uIHRoaXMgc2luZ2xlIGNhc2Ugd2l0aCBuZXh0IHRyaWNrXG4gICAgLy8gd2l0aG91dCBmbGlja2VyaW5nIG9yIGJhZCBlZmZlY3RzIChhbmQgYWx0ZXJuYXRpdmUsIGdlbmVyaWMgYXBwcm9hY2ggaXMgZG8gaXQgb24gdGhlIGtleWJvYXJkU2hvd1xuICAgIC8vIGV2ZW50LCBidXQgdGhlcmUgYSBmbGlja2VyaW5nIGhhcHBlbnMgYW5kIG1heSBhZmZlY3QgY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm8gbmVlZCBvciBjYW4gYmUgd29yc2VcbiAgICAvLyBpZiBmaWVsZCB2aXNpYmlsaXR5IGFuZCBhY3R1YWwgc2Nyb2xsIGlzIG5vdCBjaGVja2VkKTpcbiAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG59O1xuXG5mdW5jdGlvbiBWaWV3TW9kZWwoKSB7XG5cbiAgICB0aGlzLmhlYWRlclRleHQgPSBrby5vYnNlcnZhYmxlKCdUZXh0Jyk7XG5cbiAgICAvLyBUZXh0IHRvIGVkaXRcbiAgICB0aGlzLnRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcblxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdzYXZlZCcpO1xuICAgIH07XG59XG5cblZpZXdNb2RlbC5faW5oZXJpdHMoRXZlbnRFbWl0dGVyKTtcbiIsIi8qKlxuICAgIFVzZXJGZWVzIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFjdGl2aXR5ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFVzZXJGZWVzQWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IG51bGw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB7fTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ093bmVyIGluZm9ybWF0aW9uJywge1xuICAgICAgICBiYWNrTGluazogJ293bmVySW5mbydcbiAgICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEE7XG4iLCIvKipcbiAgICBWZXJpZmljYXRpb25zIGFjdGl2aXR5XG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFZlcmlmaWNhdGlvbnNBY3Rpdml0eSgpIHtcblxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUubG9nZ2VkVXNlcjtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIC8vIERlZmF1bHRzIHNldHRpbmdzIGZvciBuYXZCYXIuXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdNYXJrZXRwbGFjZSBQcm9maWxlJywge1xuICAgICAgICBiYWNrTGluazogJy9tYXJrZXRwbGFjZVByb2ZpbGUnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2V0dXAgc3BlY2lhbCBsaW5rcyBiZWhhdmlvciB0byBhZGQvcGVyZm9ybSBzcGVjaWZpYyB2ZXJpZmljYXRpb25zXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGFjdGl2aXR5LFxuICAgICAgICBldmVudDogJ2NsaWNrJyxcbiAgICAgICAgc2VsZWN0b3I6ICdbaHJlZj1cIiNyZXNlbmRFbWFpbENvbmZpcm1hdGlvblwiXScsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5hcHAubW9kYWxzLnNob3dOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUTy1ETzogcmVzZW5kIGVtYWlsIGNvbmZpcm1hdGlvbidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcih7XG4gICAgICAgIHRhcmdldDogdGhpcy4kYWN0aXZpdHksXG4gICAgICAgIGV2ZW50OiAnY2xpY2snLFxuICAgICAgICBzZWxlY3RvcjogJ1tocmVmPVwiI2Nvbm5lY3RXaXRoRmFjZWJvb2tcIl0nLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93Tm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVE8tRE86IGFzayBmb3IgY29ubmVjdCB3aXRoIEZhY2Vib29rIEFQSSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn0pO1xuXG5leHBvcnRzLmluaXQgPSBBLmluaXQ7XG5cbkEucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIFxuICAgIHRoaXMuYXBwLm1vZGVsLnVzZXJWZXJpZmljYXRpb25zLmdldExpc3QoKVxuICAgIC50aGVuKGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwudXNlclZlcmlmaWNhdGlvbnMobGlzdCgpKTtcbiAgICB9LmJpbmQodGhpcykpXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHsgdGl0bGU6ICdFcnJvciBsb2FkaW5nIHlvdXIgdmVyaWZpY2F0aW9ucycsIGVycm9yOiBlcnIgfSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcbiAgICBcbiAgICB0aGlzLmlzU3luY2luZyA9IGFwcC5tb2RlbC51c2VyVmVyaWZpY2F0aW9ucy5zdGF0ZS5pc1N5bmNpbmc7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBhcHAubW9kZWwudXNlclZlcmlmaWNhdGlvbnMuc3RhdGUuaXNMb2FkaW5nO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBhcHAubW9kZWwudXNlclZlcmlmaWNhdGlvbnMuc3RhdGUuaXNTYXZpbmc7XG5cbiAgICB0aGlzLnVzZXJWZXJpZmljYXRpb25zID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG5cbiAgICB0aGlzLmVtYWlsSW5mbyA9IGtvLm9ic2VydmFibGUoJ1BsZWFzZSBjbGljayBvbiBcIlZlcmlmeSBteSBhY2NvdW50XCIgaW4gdGhlIGUtbWFpbCB3ZSBzZW50IHlvdSB0byB2ZXJpZnkgeW91ciBhZGRyZXNzLiA8YSBjbGFzcz1cImJ0biBidG4tbGluayBidG4tYmxvY2tcIiAgaHJlZj1cIiNyZXNlbmRFbWFpbENvbmZpcm1hdGlvblwiPkNsaWNrIGhlcmUgdG8gcmVzZW5kLjwvYT4nKTtcbiAgICB0aGlzLmZhY2Vib29rSW5mbyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRwbCA9ICdMZXR0aW5nIHBvdGVudGlhbCBfX2tpbmRfXyBrbm93IHlvdSBoYXZlIGEgdHJ1c3RlZCBvbmxpbmUgcHJlc2VuY2UgaGVscHMgdGhlbSBrbm93IHlvdVxcJ3JlIHJlYWwuIDxhIGNsYXNzPVwiYnRuIGJ0bi1saW5rIGJ0bi1ibG9ja1wiIGhyZWY9XCIjY29ubmVjdFdpdGhGYWNlYm9va1wiPkNsaWNrIGhlcmUgdG8gY29ubmVjdCB5b3VyIGFjY291bnQuPC9hPic7XG4gICAgICAgIHJldHVybiB0cGwucmVwbGFjZSgvX19raW5kX18vLCBhcHAubW9kZWwudXNlcigpLmlzU2VydmljZVByb2Zlc3Npb25hbCgpID8gJ2NsaWVudHMnIDogJ3NlcnZpY2UgcHJvZmVzc2lvbmFscycpO1xuICAgIH0pO1xufVxuXG4vKlxudmFyIFVzZXJWZXJpZmljYXRpb24gPSByZXF1aXJlKCcuLi9tb2RlbHMvVXNlclZlcmlmaWNhdGlvbicpLFxuICAgIFZlcmlmaWNhdGlvbiA9IHJlcXVpcmUoJy4uL21vZGVscy9WZXJpZmljYXRpb24nKTtcblxuZnVuY3Rpb24gdGVzdGRhdGEoKSB7XG4gICAgXG4gICAgdmFyIHZlckEgPSBuZXcgVmVyaWZpY2F0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6ICdFbWFpbCdcbiAgICAgICAgfSksXG4gICAgICAgIHZlckIgPSBuZXcgVmVyaWZpY2F0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6ICdGYWNlYm9vaydcbiAgICAgICAgfSksXG4gICAgICAgIHZlckMgPSBuZXcgVmVyaWZpY2F0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6ICdMb2Nvbm9taWNcXCdzIHVzZXItcmV2aWV3ZWQnXG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFVzZXJWZXJpZmljYXRpb24oe1xuICAgICAgICAgICAgc3RhdHVzSUQ6IFZlcmlmaWNhdGlvbi5zdGF0dXMuY29uZmlybWVkLFxuICAgICAgICAgICAgbGFzdFZlcmlmaWVkRGF0ZTogbmV3IERhdGUoMjAxNSwgMSwgMTIsIDEwLCAyMywgMzIpLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uOiB2ZXJBXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgVXNlclZlcmlmaWNhdGlvbih7XG4gICAgICAgICAgICBzdGF0dXNJRDogVmVyaWZpY2F0aW9uLnN0YXR1cy5yZXZva2VkLFxuICAgICAgICAgICAgbGFzdFZlcmlmaWVkRGF0ZTogbmV3IERhdGUoMjAxNSwgNSwgMjAsIDE2LCA0LCAwKSxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbjogdmVyQlxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFVzZXJWZXJpZmljYXRpb24oe1xuICAgICAgICAgICAgc3RhdHVzSUQ6IFZlcmlmaWNhdGlvbi5zdGF0dXMucGVuZGluZyxcbiAgICAgICAgICAgIGxhc3RWZXJpZmllZERhdGU6IG5ldyBEYXRlKDIwMTQsIDExLCAzMCwgMTksIDU0LCA0KSxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbjogdmVyQ1xuICAgICAgICB9KVxuICAgIF07XG59XG4qL1xuIiwiLyoqXG4gICAgV2Vla2x5U2NoZWR1bGUgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0aXZpdHkgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0FjdGl2aXR5Jyk7XG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG52YXIgQSA9IEFjdGl2aXR5LmV4dGVuZHMoZnVuY3Rpb24gV2Vla2x5U2NoZWR1bGVBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFZpZXdNb2RlbCh0aGlzLmFwcCk7XG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLnNlcnZpY2VQcm9mZXNzaW9uYWw7XG5cbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIoJ1NjaGVkdWxpbmcnLCB7XG4gICAgICAgIGJhY2tMaW5rOiAnc2NoZWR1bGluZydcbiAgICB9KTtcbiAgICB0aGlzLmRlZmF1bHROYXZCYXIgPSB0aGlzLm5hdkJhci5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpO1xuICAgIFxuICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmFwcC5tb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUsXG4gICAgICAgIGV2ZW50OiAnZXJyb3InLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBlcnIudGFzayA9PT0gJ3NhdmUnID8gJ0Vycm9yIHNhdmluZyB5b3VyIHdlZWtseSBzY2hlZHVsZS4nIDogJ0Vycm9yIGxvYWRpbmcgeW91ciB3ZWVrbHkgc2NoZWR1bGUuJztcbiAgICAgICAgICAgIHRoaXMuYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBtc2csXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciAmJiBlcnIudGFzayAmJiBlcnIuZXJyb3IgfHwgZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG59KTtcblxuZXhwb3J0cy5pbml0ID0gQS5pbml0O1xuXG5BLnByb3RvdHlwZS51cGRhdGVOYXZCYXJTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZU5hdkJhclN0YXRlKCkge1xuICAgIFxuICAgIGlmICghdGhpcy5hcHAubW9kZWwub25ib2FyZGluZy51cGRhdGVOYXZCYXIodGhpcy5uYXZCYXIpKSB7XG4gICAgICAgIC8vIFJlc2V0XG4gICAgICAgIHRoaXMubmF2QmFyLm1vZGVsLnVwZGF0ZVdpdGgodGhpcy5kZWZhdWx0TmF2QmFyLCB0cnVlKTtcbiAgICB9XG59O1xuXG5BLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhzdGF0ZSkge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgc3RhdGUpO1xuICAgIFxuICAgIHRoaXMudXBkYXRlTmF2QmFyU3RhdGUoKTtcbiAgICBcbiAgICAvLyBLZWVwIGRhdGEgdXBkYXRlZDpcbiAgICB0aGlzLmFwcC5tb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUuc3luYygpO1xuICAgIC8vIERpc2NhcmQgYW55IHByZXZpb3VzIHVuc2F2ZWQgZWRpdFxuICAgIHRoaXMudmlld01vZGVsLmRpc2NhcmQoKTtcbn07XG5cbmZ1bmN0aW9uIFZpZXdNb2RlbChhcHApIHtcblxuICAgIHZhciBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUgPSBhcHAubW9kZWwuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlO1xuXG4gICAgdmFyIHNjaGVkdWxlVmVyc2lvbiA9IHNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5uZXdWZXJzaW9uKCk7XG4gICAgc2NoZWR1bGVWZXJzaW9uLmlzT2Jzb2xldGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGl0SXMpIHtcbiAgICAgICAgaWYgKGl0SXMpIHtcbiAgICAgICAgICAgIC8vIG5ldyB2ZXJzaW9uIGZyb20gc2VydmVyIHdoaWxlIGVkaXRpbmdcbiAgICAgICAgICAgIC8vIEZVVFVSRTogd2FybiBhYm91dCBhIG5ldyByZW1vdGUgdmVyc2lvbiBhc2tpbmdcbiAgICAgICAgICAgIC8vIGNvbmZpcm1hdGlvbiB0byBsb2FkIHRoZW0gb3IgZGlzY2FyZCBhbmQgb3ZlcndyaXRlIHRoZW07XG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBpcyBuZWVkIG9uIHNhdmUoKSwgYW5kIG9uIHNlcnZlciByZXNwb25zZVxuICAgICAgICAgICAgLy8gd2l0aCBhIDUwOTpDb25mbGljdCBzdGF0dXMgKGl0cyBib2R5IG11c3QgY29udGFpbiB0aGVcbiAgICAgICAgICAgIC8vIHNlcnZlciB2ZXJzaW9uKS5cbiAgICAgICAgICAgIC8vIFJpZ2h0IG5vdywganVzdCBvdmVyd3JpdGUgY3VycmVudCBjaGFuZ2VzIHdpdGhcbiAgICAgICAgICAgIC8vIHJlbW90ZSBvbmVzOlxuICAgICAgICAgICAgc2NoZWR1bGVWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEFjdHVhbCBkYXRhIGZvciB0aGUgZm9ybTpcbiAgICB0aGlzLnNjaGVkdWxlID0gc2NoZWR1bGVWZXJzaW9uLnZlcnNpb247XG5cbiAgICB0aGlzLmlzTG9ja2VkID0gc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLmlzTG9ja2VkO1xuICAgIHRoaXMuaXNTYXZpbmcgPSBzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUuaXNTYXZpbmc7XG5cbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5pblByb2dyZXNzKCkgP1xuICAgICAgICAgICAgICAgICdTYXZlIGFuZCBjb250aW51ZScgOlxuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ2xvYWRpbmcuLi4nIDogXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoKSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NhdmluZy4uLicgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICdTYXZlJ1xuICAgICAgICApO1xuICAgIH0sIHNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSk7XG4gICAgXG4gICAgdGhpcy5kaXNjYXJkID0gZnVuY3Rpb24gZGlzY2FyZCgpIHtcbiAgICAgICAgc2NoZWR1bGVWZXJzaW9uLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgICAgc2NoZWR1bGVWZXJzaW9uLnB1c2hTYXZlKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYXBwLm1vZGVsLm9uYm9hcmRpbmcuaW5Qcm9ncmVzcygpKSB7XG4gICAgICAgICAgICAgICAgYXBwLm1vZGVsLm9uYm9hcmRpbmcuZ29OZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcC5zdWNjZXNzU2F2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjYXRjaCBlcnJvciwgbWFuYWdlZCBvbiBldmVudFxuICAgICAgICB9KTtcbiAgICB9O1xufVxuIiwiLyoqXG4gICAgV2VsY29tZSBhY3Rpdml0eVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFdlbGNvbWVBY3Rpdml0eSgpIHtcbiAgICBcbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IHRoaXMuYXBwLlVzZXJUeXBlLmxvZ2dlZFVzZXI7XG4gICAgXG4gICAgdmFyIGFwcCA9IHRoaXMuYXBwO1xuICAgIFxuICAgIHRoaXMudmlld01vZGVsID0ge1xuICAgICAgICBzdGFydE9uYm9hcmRpbmc6IGZ1bmN0aW9uIHN0YXJ0T25ib2FyZGluZygpIHtcbiAgICAgICAgICAgIGFwcC5tb2RlbC5vbmJvYXJkaW5nLmdvTmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLm5hdkJhciA9IG5ldyBBY3Rpdml0eS5OYXZCYXIoe1xuICAgICAgICB0aXRsZTogbnVsbCxcbiAgICAgICAgbGVmdEFjdGlvbjogQWN0aXZpdHkuTmF2QWN0aW9uLmdvTG9nb3V0LFxuICAgICAgICByaWdodEFjdGlvbjogbnVsbFxuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcbiIsIi8qKlxuICAgIFdvcmtQaG90b3MgYWN0aXZpdHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcbiAgICBBY3Rpdml0eSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQWN0aXZpdHknKTtcblxudmFyIEEgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIFdvcmtQaG90b3NBY3Rpdml0eSgpIHtcblxuICAgIEFjdGl2aXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gdGhpcy5hcHAuVXNlclR5cGUuc2VydmljZVByb2Zlc3Npb25hbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwodGhpcy5hcHApO1xuICAgIC8vIERlZmF1bHRzIHNldHRpbmdzIGZvciBuYXZCYXIuXG4gICAgdGhpcy5uYXZCYXIgPSBBY3Rpdml0eS5jcmVhdGVTdWJzZWN0aW9uTmF2QmFyKCdKb2IgVGl0bGUnKTtcblxuICAgIC8vIE9uIGNoYW5naW5nIGpvYlRpdGxlSUQ6XG4gICAgLy8gLSBsb2FkIHBob3Rvc1xuICAgIC8qIFRPRE8gVW5jb21tZW50IGFuZCB1cGRhdGUgb24gaW1wbGVtZW50aW5nIFJFU1QgQVBJIEFwcE1vZGVsXG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMudmlld01vZGVsLmpvYlRpdGxlSUQsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcbiAgICAgICAgICAgIGlmIChqb2JUaXRsZUlEKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGRhdGEgZm9yIHRoZSBKb2IgdGl0bGUgSURcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RlbC53b3JrcGhvdG9zLmdldExpc3Qoam9iVGl0bGVJRClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgZm9yIHVzZSBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5saXN0KGxpc3QpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmxpc3QoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTsqL1xuICAgIC8vIFRPRE8gUmVtb3ZlIG9uIGltcGxlbWVudGVkIFJFU1QgQVBJXG4gICAgdGhpcy52aWV3TW9kZWwubGlzdCh0ZXN0ZGF0YSgpKTtcbiAgICBcbiAgICAvLyBFdmVudCBoYW5kbGVycyBmb3IgcGhvdG8gbGlzdCBtYW5hZ2VtZW50XG4gICAgdGhpcy5yZWdpc3RlckhhbmRsZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMuJGFjdGl2aXR5LFxuICAgICAgICBzZWxlY3RvcjogJy5Xb3JrUGhvdG9zLWltZ0J0bicsXG4gICAgICAgIGV2ZW50OiAnY2xpY2snLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgJChldmVudC50YXJnZXQpLmNsb3Nlc3QoJ2xpJykudG9nZ2xlQ2xhc3MoJ2lzLXNlbGVjdGVkJyk7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgIH0pO1xufSk7XG5cbmV4cG9ydHMuaW5pdCA9IEEuaW5pdDtcblxuQS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cob3B0aW9ucykge1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcGFyYW1zID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvdXRlICYmIG9wdGlvbnMucm91dGUuc2VnbWVudHM7XG4gICAgdGhpcy52aWV3TW9kZWwuam9iVGl0bGVJRChwYXJhbXNbMF0gfDApO1xufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKGFwcCkge1xuXG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICB0aGlzLmxpc3QgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xuICAgIFxuICAgIHRoaXMuaXNTeW5jaW5nID0gYXBwLm1vZGVsLmxpY2Vuc2VzQ2VydGlmaWNhdGlvbnMuc3RhdGUuaXNTeW5jaW5nKCk7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBhcHAubW9kZWwubGljZW5zZXNDZXJ0aWZpY2F0aW9ucy5zdGF0ZS5pc0xvYWRpbmcoKTtcblxuICAgIHRoaXMuYWRkTmV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFBpY2sgYSBuZXcgcGhvdG9cbiAgICAgICAgdGhpcy5vcGVuUGhvdG9QaWNrZXIoKVxuICAgICAgICAudGhlbihmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgIHZhciBuZXdJdGVtID0gbmV3IFdvcmtQaG90byh7XG4gICAgICAgICAgICAgICAgdXJsOiBpbWcsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHsgZXJyb3I6IGVyciwgdGl0bGU6ICdFcnJvciBnZXR0aW5nIHBob3RvLicgfSk7XG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMucmVtb3ZlSW1nID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAvLyBQaWNrIGFub3RoZXIgcGhvdG8gdG8gcmVwbGFjZSBvbiAnaXRlbSdcbiAgICAgICAgdGhpcy5saXN0LnJlbW92ZShpdGVtKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm9wZW5QaG90b1BpY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKmdsb2JhbCBuYXZpZ2F0b3IsQ2FtZXJhKi9cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5jYW1lcmEgJiYgbmF2aWdhdG9yLmNhbWVyYS5nZXRQaWN0dXJlKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmNhbWVyYS5nZXRQaWN0dXJlKGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZyBpT1Mgbm90ZTogaHR0cDovL3BsdWdpbnMuY29yZG92YS5pby8jL3BhY2thZ2Uvb3JnLmFwYWNoZS5jb3Jkb3ZhLmNhbWVyYVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25UeXBlOiBDYW1lcmEuRGVzdGluYXRpb25UeXBlLkZJTEVfVVJJLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRXaWR0aDogNDQ2LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQ6IDMzMixcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBDYW1lcmEuTWVkaWFUeXBlLlBJQ1RVUkUsXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RPcmllbnRhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYnVnIGlPUyBub3RlOiBodHRwOi8vcGx1Z2lucy5jb3Jkb3ZhLmlvLyMvcGFja2FnZS9vcmcuYXBhY2hlLmNvcmRvdmEuY2FtZXJhXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgZXJyb3I6ICdVbnN1cHBvcnRlZCcsIG1lc3NhZ2U6ICdJbXBvc3NpYmxlIHRvIGdldCBwaG90byBmcm9tIGRldmljZScgfSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy51cGRhdGVTb3J0ID0gZnVuY3Rpb24oLyppbmZvKi8pIHtcbiAgICAgICAgLy8gVE9ET1xuICAgIH07XG59XG5cblxuXG4vLy8gVEVTVERBVEFcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL01vZGVsJyk7XG5mdW5jdGlvbiBXb3JrUGhvdG8odmFsdWVzKSB7XG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgdGl0bGU6ICcnXG4gICAgfSwgdmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gdGVzdGRhdGEoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFdvcmtQaG90byh7IHVybDogJ2h0dHBzOi8vbG9jb25vbWljcy5jb20vaW1nL3VzZXJwaG90b3MvdTI5Ni8wYzk1ZGJjY2FmZDE0OTUzYTk0YmRlODZlZmY0ZDM0YS00NDJ4MzMyLmpwZycsIHRpdGxlOiAnVGVzdGluZyBwaG90byAxJyB9KSxcbiAgICAgICAgbmV3IFdvcmtQaG90byh7IHVybDogJ2h0dHBzOi8vbG9jb25vbWljcy5jb20vaW1nL3VzZXJwaG90b3MvdTI5Ni8zZWIxNDA3M2NiNmE0NTEzOGI2ZmQ5NmI0NTliZjNhMS00NDJ4MzMyLmpwZycsIHRpdGxlOiAnVGVzdGluZyBwaG90byAyJyB9KSxcbiAgICAgICAgbmV3IFdvcmtQaG90byh7IHVybDogJ2h0dHBzOi8vbG9jb25vbWljcy5jb20vaW1nL3VzZXJwaG90b3MvdTI5Ni8wYzk1ZGJjY2FmZDE0OTUzYTk0YmRlODZlZmY0ZDM0YS00NDJ4MzMyLmpwZycsIHRpdGxlOiAnVGVzdGluZyBwaG90byAzJyB9KSxcbiAgICAgICAgbmV3IFdvcmtQaG90byh7IHVybDogJ2h0dHBzOi8vbG9jb25vbWljcy5jb20vaW1nL3VzZXJwaG90b3MvdTI5Ni8zZWIxNDA3M2NiNmE0NTEzOGI2ZmQ5NmI0NTliZjNhMS00NDJ4MzMyLmpwZycsIHRpdGxlOiAnVGVzdGluZyBwaG90byA0JyB9KVxuICAgIF07XG59IiwiLyoqXG4gICAgUmVnaXN0cmF0aW9uIG9mIGN1c3RvbSBodG1sIGNvbXBvbmVudHMgdXNlZCBieSB0aGUgQXBwLlxuICAgIEFsbCB3aXRoICdhcHAtJyBhcyBwcmVmaXguXG4gICAgXG4gICAgU29tZSBkZWZpbml0aW9ucyBtYXkgYmUgaW5jbHVkZWQgb24tbGluZSByYXRoZXIgdGhhbiBvbiBzZXBhcmF0ZWRcbiAgICBmaWxlcyAodmlld21vZGVscyksIHRlbXBsYXRlcyBhcmUgbGlua2VkIHNvIG5lZWQgdG8gYmUgXG4gICAgaW5jbHVkZWQgaW4gdGhlIGh0bWwgZmlsZSB3aXRoIHRoZSBzYW1lIElEIHRoYXQgcmVmZXJlbmNlZCBoZXJlLFxuICAgIHVzdWFsbHkgdXNpbmcgYXMgRE9NIElEIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGNvbXBvbmVudCB3aXRoIHN1Zml4ICctdGVtcGxhdGUnLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxuICAgIHByb3BUb29scyA9IHJlcXVpcmUoJy4vdXRpbHMvanNQcm9wZXJ0aWVzVG9vbHMnKSxcbiAgICBnZXRPYnNlcnZhYmxlID0gcmVxdWlyZSgnLi91dGlscy9nZXRPYnNlcnZhYmxlJyk7XG5cbmV4cG9ydHMucmVnaXN0ZXJBbGwgPSBmdW5jdGlvbihhcHApIHtcbiAgICBcbiAgICAvLy8gbmF2YmFyLWFjdGlvblxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1uYXZiYXItYWN0aW9uJywge1xuICAgICAgICB0ZW1wbGF0ZTogeyBlbGVtZW50OiAnbmF2YmFyLWFjdGlvbi10ZW1wbGF0ZScgfSxcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcblxuICAgICAgICAgICAgcHJvcFRvb2xzLmRlZmluZUdldHRlcih0aGlzLCAnYWN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFjdGlvbiAmJiBwYXJhbXMubmF2QmFyKCkgP1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubmF2QmFyKClbcGFyYW1zLmFjdGlvbl0oKSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLy8gdW5sYWJlbGVkLWlucHV0XG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlcignYXBwLXVubGFiZWxlZC1pbnB1dCcsIHtcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ3VubGFiZWxlZC1pbnB1dC10ZW1wbGF0ZScgfSxcbiAgICAgICAgdmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcblxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGdldE9ic2VydmFibGUocGFyYW1zLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGUgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5kaXNhYmxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHVzZXJBdHRyID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuYXR0cik7XG4gICAgICAgICAgICB0aGlzLmF0dHIgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSB1c2VyQXR0cigpIHx8IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgYXR0ciwge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMucGxhY2Vob2xkZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGdldE9ic2VydmFibGUocGFyYW1zLnR5cGUpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy50eXBlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUoKSB8fCAndGV4dCc7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vLyBmZWVkYmFjay1lbnRyeVxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1mZWVkYmFjay1lbnRyeScsIHtcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ2ZlZWRiYWNrLWVudHJ5LXRlbXBsYXRlJyB9LFxuICAgICAgICB2aWV3TW9kZWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuXG4gICAgICAgICAgICB0aGlzLnNlY3Rpb24gPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5zZWN0aW9uIHx8ICcnKTtcbiAgICAgICAgICAgIHRoaXMudXJsID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnL2ZlZWRiYWNrRm9ybS8nICsgdGhpcy5zZWN0aW9uKCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vLyBmZWVkYmFjay1lbnRyeVxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC10aW1lLXNsb3QtdGlsZScsIHtcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ3RpbWUtc2xvdC10aWxlLXRlbXBsYXRlJyB9LFxuICAgICAgICB2aWV3TW9kZWw6IHJlcXVpcmUoJy4vdmlld21vZGVscy9UaW1lU2xvdCcpXG4gICAgfSk7XG4gICAgXG4gICAgLy8vIGxvYWRpbmctc3Bpbm5lclxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1sb2FkaW5nLXNwaW5uZXInLCB7XG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICdsb2FkaW5nLXNwaW5uZXItdGVtcGxhdGUnIH0sXG4gICAgICAgIHZpZXdNb2RlbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9ICdsb2FkaW5nU3Bpbm5lcic7XG4gICAgICAgICAgICB0aGlzLm1vZCA9IGdldE9ic2VydmFibGUocGFyYW1zLm1vZCB8fCAnJyk7XG4gICAgICAgICAgICB0aGlzLmNzc0NsYXNzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kcyA9ICh0aGlzLm1vZCgpIHx8ICcnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYyArPSAnICcgKyBiYXNlICsgJy0tJyArIG1vZHMuam9pbignICcgKyBiYXNlICsgJy0tJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8vIGFwcG9pbnRtZW50LWNhcmRcbiAgICBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdhcHAtYXBwb2ludG1lbnQtY2FyZCcsIHtcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ2FwcG9pbnRtZW50LWNhcmQtdGVtcGxhdGUnIH0sXG4gICAgICAgIHZpZXdNb2RlbDogcmVxdWlyZSgnLi92aWV3bW9kZWxzL0FwcG9pbnRtZW50Q2FyZCcpXG4gICAgfSk7XG4gICAgXG4gICAgLy8vIGpvYiB0aXRsZXMgbGlzdFxuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1qb2ItdGl0bGVzLWxpc3QnLCB7XG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICdqb2ItdGl0bGVzLWxpc3QtdGVtcGxhdGUnIH0sXG4gICAgICAgIHZpZXdNb2RlbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLmpvYlRpdGxlcyA9IGdldE9ic2VydmFibGUocGFyYW1zLmpvYlRpdGxlcyB8fCBbXSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEpvYlRpdGxlID0gcGFyYW1zLnNlbGVjdEpvYlRpdGxlIHx8IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICB0aGlzLnNob3dNYXJrZXRwbGFjZUluZm8gPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5zaG93TWFya2V0cGxhY2VJbmZvIHx8IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vLyBTdGFyc1xuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1zdGFycy1yYXRpbmcnLCB7XG4gICAgICAgIHRlbXBsYXRlOiB7IGVsZW1lbnQ6ICdzdGFycy1yYXRpbmctdGVtcGxhdGUnIH0sXG4gICAgICAgIHZpZXdNb2RlbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnJhdGluZyA9IGdldE9ic2VydmFibGUocGFyYW1zLnJhdGluZyB8fCAyLjUpO1xuICAgICAgICAgICAgdGhpcy50b3RhbCA9IGdldE9ic2VydmFibGUocGFyYW1zLnRvdGFsIHx8IDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnN0YXJzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5yYXRpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIFN1cHBvcnQgaGFsZiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGkgPD0gciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy50b3RhbFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBDb25kaXRpb25hbCBmb3JtYXR0aW5nIGZvciBiaWcgbnVtYmVycyBjYXNlc1xuICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyB0aGlzLnRvdGFsKCkgKyAnKSc7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vLyBTZXJ2aWNlUHJvZmVzc2lvbmFsSW5mb1xuICAgIHZhciBQdWJsaWNVc2VyID0gcmVxdWlyZSgnLi9tb2RlbHMvUHVibGljVXNlcicpO1xuICAgIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcC1zZXJ2aWNlLXByb2Zlc3Npb25hbC1pbmZvJywge1xuICAgICAgICBzeW5jaHJvbm91czogdHJ1ZSxcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ3NlcnZpY2UtcHJvZmVzc2lvbmFsLWluZm8tdGVtcGxhdGUnIH0sXG4gICAgICAgIHZpZXdNb2RlbDoge1xuICAgICAgICAgICAgY3JlYXRlVmlld01vZGVsOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBQdWJsaWNVc2VyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuYXBpKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYXBpKHZpZXcpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8vIERhdGV0aW1lUGlja2VyXG4gICAgdmFyIERhdGVUaW1lUGlja2VyVk0gPSByZXF1aXJlKCcuL3ZpZXdtb2RlbHMvRGF0ZXRpbWVQaWNrZXInKTtcbiAgICBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdhcHAtZGF0ZXRpbWUtcGlja2VyJywge1xuICAgICAgICBzeW5jaHJvbm91czogdHJ1ZSxcbiAgICAgICAgdGVtcGxhdGU6IHsgZWxlbWVudDogJ2RhdGV0aW1lLXBpY2tlci10ZW1wbGF0ZScgfSxcbiAgICAgICAgdmlld01vZGVsOiB7XG4gICAgICAgICAgICBjcmVhdGVWaWV3TW9kZWw6IGZ1bmN0aW9uKHBhcmFtcywgY29tcG9uZW50SW5mbykge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGVUaW1lUGlja2VyVk0oYXBwLCBjb21wb25lbnRJbmZvLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmFwaSlcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFwaSh2aWV3KTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrby5pc09ic2VydmFibGUodmlld1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdba2V5XShrby51bndyYXAocGFyYW1zW2tleV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHBhcmFtc1trZXldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1trZXldLnN1YnNjcmliZShwYXJhbXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuIiwiLyoqXG4gICAgTmF2YmFyIGV4dGVuc2lvbiBvZiB0aGUgQXBwLFxuICAgIGFkZHMgdGhlIGVsZW1lbnRzIHRvIG1hbmFnZSBhIHZpZXcgbW9kZWxcbiAgICBmb3IgdGhlIE5hdkJhciBhbmQgYXV0b21hdGljIGNoYW5nZXNcbiAgICB1bmRlciBzb21lIG1vZGVsIGNoYW5nZXMgbGlrZSB1c2VyIGxvZ2luL2xvZ291dFxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxuICAgIE5hdkJhciA9IHJlcXVpcmUoJy4vdmlld21vZGVscy9OYXZCYXInKSxcbiAgICBOYXZBY3Rpb24gPSByZXF1aXJlKCcuL3ZpZXdtb2RlbHMvTmF2QWN0aW9uJyk7XG5cbmV4cG9ydHMuZXh0ZW5kcyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgICBcbiAgICAvLyBSRVZJRVc6IHN0aWxsIG5lZWRlZD8gTWF5YmUgdGhlIHBlciBhY3Rpdml0eSBuYXZCYXIgbWVhbnNcbiAgICAvLyB0aGlzIGlzIG5vdCBuZWVkZWQuIFNvbWUgcHJldmlvdXMgbG9naWMgd2FzIGFscmVhZHkgcmVtb3ZlZFxuICAgIC8vIGJlY2F1c2Ugd2FzIHVzZWxlc3MuXG4gICAgLy9cbiAgICAvLyBBZGp1c3QgdGhlIG5hdmJhciBzZXR1cCBkZXBlbmRpbmcgb24gY3VycmVudCB1c2VyLFxuICAgIC8vIHNpbmNlIGRpZmZlcmVudCB0aGluZ3MgYXJlIG5lZWQgZm9yIGxvZ2dlZC1pbi9vdXQuXG4gICAgZnVuY3Rpb24gYWRqdXN0VXNlckJhcigpIHtcblxuICAgICAgICB2YXIgdXNlciA9IGFwcC5tb2RlbC51c2VyKCk7XG5cbiAgICAgICAgaWYgKHVzZXIuaXNBbm9ueW1vdXMoKSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBhcHAubmF2QmFyKCkubGVmdEFjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHByZXYgIT09IE5hdkFjdGlvbi5tZW51T3V0KSB7XG4gICAgICAgICAgICAgICAgYXBwLm5hdkJhcigpLmxlZnRBY3Rpb24oTmF2QWN0aW9uLm1lbnVPdXQpO1xuICAgICAgICAgICAgICAgIGFwcC5uYXZCYXIoKS5wcmV2TGVmdEFjdGlvbiA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBwLm5hdkJhcigpLnByZXZMZWZ0QWN0aW9uKSB7XG4gICAgICAgICAgICBhcHAubmF2QmFyKCkubGVmdEFjdGlvbihhcHAubmF2QmFyKCkucHJldkxlZnRBY3Rpb24pO1xuICAgICAgICAgICAgYXBwLm5hdkJhcigpLnByZXZMZWZ0QWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDb21tZW50ZWQgbGluZXMsIHVzZWQgcHJldmlvdXNseSBidXQgdW51c2VkIG5vdywgaXQgbXVzdCBiZSBlbm91Z2ggd2l0aCB0aGUgdXBkYXRlXG4gICAgLy8gcGVyIGFjdGl2aXR5IGNoYW5nZVxuICAgIC8vYXBwLm1vZGVsLnVzZXIoKS5pc0Fub255bW91cy5zdWJzY3JpYmUodXBkYXRlU3RhdGVzT25Vc2VyQ2hhbmdlKTtcbiAgICAvL2FwcC5tb2RlbC51c2VyKCkub25ib2FyZGluZ1N0ZXAuc3Vic2NyaWJlKHVwZGF0ZVN0YXRlc09uVXNlckNoYW5nZSk7XG4gICAgXG4gICAgYXBwLm5hdkJhciA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgXG4gICAgdmFyIHJlZnJlc2hOYXYgPSBmdW5jdGlvbiByZWZyZXNoTmF2KCkge1xuICAgICAgICAvLyBUcmlnZ2VyIGV2ZW50IHRvIGZvcmNlIGEgY29tcG9uZW50IHVwZGF0ZVxuICAgICAgICAkKCcuQXBwTmF2JykudHJpZ2dlcignY29udGVudENoYW5nZScpO1xuICAgIH07XG4gICAgdmFyIGF1dG9SZWZyZXNoTmF2ID0gZnVuY3Rpb24gYXV0b1JlZnJlc2hOYXYoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGFjdGlvbi50ZXh0LnN1YnNjcmliZShyZWZyZXNoTmF2KTtcbiAgICAgICAgICAgIGFjdGlvbi5pc1RpdGxlLnN1YnNjcmliZShyZWZyZXNoTmF2KTtcbiAgICAgICAgICAgIGFjdGlvbi5pY29uLnN1YnNjcmliZShyZWZyZXNoTmF2KTtcbiAgICAgICAgICAgIGFjdGlvbi5pc01lbnUuc3Vic2NyaWJlKHJlZnJlc2hOYXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBVcGRhdGUgdGhlIG5hdiBtb2RlbCB1c2luZyB0aGUgQWN0aXZpdHkgZGVmYXVsdHNcbiAgICAgICAgLy8gVE9ETyBMb29rIGEgd2F5IHRvIHJlcGxhY2UgYWxsIHRoaXMgY29tcGxleCBuYXZiYXIgbG9naWMsIG1heWJlIHBlclxuICAgICAgICAvLyBhY3Rpdml0eSBuYWJ2YXJzLCBtb3JlIG1vZGVsIGhlbHBlcnMgYW5kIGdsb2JhbCBzdGF0ZSBoZWxwZXJzLlxuICAgICoqL1xuICAgIGFwcC51cGRhdGVBcHBOYXYgPSBmdW5jdGlvbiB1cGRhdGVBcHBOYXYoYWN0aXZpdHksIHN0YXRlKSB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGFjdGl2aXR5IGhhcyBpdHMgb3duXG4gICAgICAgIGlmICgnbmF2QmFyJyBpbiBhY3Rpdml0eSkge1xuICAgICAgICAgICAgaWYgKGFjdGl2aXR5Lm5hdkJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEFjdGl2aXR5IHJlcXVpcmVzIG5vIG1lbnUsIGNyZWF0ZSBhIGhpZGRlbiBOYXZCYXIgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBhcHAubmF2QmFyKG5ldyBOYXZCYXIoe1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc3BlY2lhbGl6aWVkIGFjdGl2aXR5IGJhciBkYXRhXG4gICAgICAgICAgICAgICAgYXBwLm5hdkJhcihhY3Rpdml0eS5uYXZCYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgb25lXG4gICAgICAgICAgICBhcHAubmF2QmFyKG5ldyBOYXZCYXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghYXBwLmFwcGx5TmF2YmFyTXVzdFJldHVybihzdGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIENoYW5nZXMgZGVwZW5kaW5nIG9uIG5vbi1sb2dnZWQgdXNlclxuICAgICAgICAgICAgYWRqdXN0VXNlckJhcigpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZWZyZXNoTmF2KCk7XG4gICAgICAgIGF1dG9SZWZyZXNoTmF2KGFwcC5uYXZCYXIoKS5sZWZ0QWN0aW9uKCkpO1xuICAgICAgICBhdXRvUmVmcmVzaE5hdihhcHAubmF2QmFyKCkucmlnaHRBY3Rpb24oKSk7XG4gICAgfTtcbiAgICBcbiAgICBhcHAuYXBwbHlOYXZiYXJNdXN0UmV0dXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnJvdXRlICYmIHN0YXRlLnJvdXRlLnF1ZXJ5ICYmXG4gICAgICAgICAgICBzdGF0ZS5yb3V0ZS5xdWVyeS5tdXN0UmV0dXJuKSB7XG4gICAgICAgICAgICB2YXIgcmV0dXJuTGluayA9IGRlY29kZVVSSUNvbXBvbmVudChzdGF0ZS5yb3V0ZS5xdWVyeS5tdXN0UmV0dXJuKTtcbiAgICAgICAgICAgIC8vIEEgdGV4dCBjYW4gYmUgcHJvdmlkZWRcbiAgICAgICAgICAgIHZhciByZXR1cm5UZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHN0YXRlLnJvdXRlLnF1ZXJ5LnJldHVyblRleHQgfHwgJycpO1xuICAgICAgICAgICAgaWYgKHJldHVybkxpbmsgPT09ICcxJyB8fCByZXR1cm5MaW5rID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGFjdGlvbiBmb3JjZWQgdG8gYmUgYSBnby1iYWNrXG4gICAgICAgICAgICAgICAgYXBwLm5hdkJhcigpLmxlZnRBY3Rpb24oTmF2QWN0aW9uLmdvQmFjay5tb2RlbC5jbG9uZSh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHJldHVyblRleHQsXG4gICAgICAgICAgICAgICAgICAgIGlzU2hlbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzVGl0bGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGFjdGlvbiBmb3JjZSB0byByZXR1cm4gdG8gdGhlIGdpdmVuIFVSTFxuICAgICAgICAgICAgICAgIGFwcC5uYXZCYXIoKS5sZWZ0QWN0aW9uKE5hdkFjdGlvbi5nb0JhY2subW9kZWwuY2xvbmUoe1xuICAgICAgICAgICAgICAgICAgICBsaW5rOiByZXR1cm5MaW5rLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiByZXR1cm5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBpc1NoZWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNUaXRsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFxuICAgIFxuICAgIC8qKlxuICAgICAgICBVcGRhdGUgdGhlIGFwcCBtZW51IHRvIGhpZ2hsaWdodCB0aGVcbiAgICAgICAgZ2l2ZW4gbGluayBuYW1lXG4gICAgKiovXG4gICAgYXBwLnVwZGF0ZU1lbnUgPSBmdW5jdGlvbiB1cGRhdGVNZW51KG5hbWUpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciAkbWVudSA9ICQoJy5BcHAtbWVudXMgLm5hdmJhci1jb2xsYXBzZScpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBhY3RpdmVcbiAgICAgICAgJG1lbnVcbiAgICAgICAgLmZpbmQoJ2xpJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgLy8gQWRkIGFjdGl2ZVxuICAgICAgICAkbWVudVxuICAgICAgICAuZmluZCgnLmdvLScgKyBuYW1lKVxuICAgICAgICAuY2xvc2VzdCgnbGknKVxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAvLyBIaWRlIG1lbnVcbiAgICAgICAgJG1lbnVcbiAgICAgICAgLmZpbHRlcignOnZpc2libGUnKVxuICAgICAgICAuY29sbGFwc2UoJ2hpZGUnKTtcbiAgICB9O1xuICAgIFxuICAgIGFwcC5zZXR1cE5hdkJhckJpbmRpbmcgPSBmdW5jdGlvbiBzZXR1cE5hdkJhckJpbmRpbmcoKSB7XG4gICAgICAgIC8vIFNldCBtb2RlbCBmb3IgdGhlIEFwcE5hdlxuICAgICAgICBhcHAubmF2QmFyQmluZGluZyA9IHtcbiAgICAgICAgICAgIG5hdkJhcjogYXBwLm5hdkJhcixcbiAgICAgICAgICAgIC8vIEJvdGg6IGFyZSBsYXRlciBmaWxsZWQgd2l0aCBhIGNhbGwgdG8gdGhlIG1vZGVsIG9uY2UgbG9hZGVkIGFuZCByZWFkeVxuICAgICAgICAgICAgcGhvdG9Vcmw6IGtvLm9ic2VydmFibGUoJ2Fib3V0OmJsYW5rJyksXG4gICAgICAgICAgICB1c2VyTmFtZToga28ub2JzZXJ2YWJsZSgnTWUnKSxcbiAgICAgICAgICAgIGlzU2VydmljZVByb2Zlc3Npb25hbDoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICBpc0NsaWVudDoga28ub2JzZXJ2YWJsZShmYWxzZSlcbiAgICAgICAgfTtcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyhhcHAubmF2QmFyQmluZGluZywgJCgnLkFwcE5hdicpLmdldCgwKSk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgUGVyZm9ybXMgdGhlICdiYWNrJyB0YXNrIGZyb20gdGhlIG5hdmJhciBsaW5rLCBpZiBhbnkuXG4gICAgICAgIFRoYXQgaXMsIHRyaWdnZXIgdGhlIGxlZnQgYWN0aW9uLlxuICAgICAgICBGYWxsYmFjayB0byBzaGVsbCBnb0JhY2tcbiAgICAqKi9cbiAgICBhcHAucGVyZm9ybXNOYXZCYXJCYWNrID0gZnVuY3Rpb24gcGVyZm9ybXNOYXZCYXJCYWNrKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5hdiA9IHRoaXMubmF2QmFyKCksXG4gICAgICAgICAgICBsZWZ0ID0gbmF2ICYmIG5hdi5sZWZ0QWN0aW9uKCksXG4gICAgICAgICAgICAkYnRuID0gJCgnLlNtYXJ0TmF2QmFyLWVkZ2UubGVmdCA+IGEuU21hcnROYXZCYXItYnRuJyk7XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgYW4gYWN0aW9uLCB0cmlnZ2VyIGxpa2UgYSBjbGljayBzbyBhbGwgdGhlIGhhbmRsZXJzXG4gICAgICAgIC8vIGF0dGFjaGVkIG9uIHNwYXJlIHBsYWNlcyBkbyB0aGVpciB3b3JrOlxuICAgICAgICBpZiAobGVmdCAmJiAhbGVmdC5pc01lbnUoKSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gJC5FdmVudCgnY2xpY2snKTtcbiAgICAgICAgICAgIGV2ZW50Lm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgJGJ0bi50cmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNoZWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNoZWxsLmdvQmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgSXQgc2hvd3MgYW4gdW5vYnRydXNpdmUgbm90aWZpY2F0aW9uIG9uIHRoZSBuYXZiYXIgcGxhY2UsIHRoYXRcbiAgICAgICAgaGlkZXMgYWZ0ZXIgYSBzaG9ydCB0aW1lb3V0XG4gICAgKiovXG4gICAgdmFyIGxhc3ROb3RpZmljYXRpb25UaW1lciA9IG51bGw7XG4gICAgYXBwLnNob3dOYXZCYXJOb3RpZmljYXRpb24gPSBmdW5jdGlvbiBzaG93TmF2QmFyTm90aWZpY2F0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBtc2cgPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5tZXNzYWdlIHx8ICdIZWxsbyBXb3JsZCEnLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5kdXJhdGlvbiB8fCAyMDAwLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gc2V0dGluZ3MgJiYgc2V0dGluZ3MudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDQwMCxcbiAgICAgICAgICAgICRlbCA9ICQoJy5BcHBOYXYgLlNtYXJ0TmF2QmFyLW5vdGlmaWNhdGlvbicpO1xuXG4gICAgICAgICRlbC50ZXh0KG1zZyk7XG4gICAgICAgICRlbC5mYWRlSW4odHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1hbnVhbCBoaWRlIG9uIGNsaWNraW5nXG4gICAgICAgICAgICAkZWxcbiAgICAgICAgICAgIC5vZmYoJ2NsaWNrLm1hbnVhbEhpZGUnKVxuICAgICAgICAgICAgLm9uKCdjbGljay5tYW51YWxIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJGVsLmZhZGVPdXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBdXRvIGhpZGUgYWZ0ZXIgdGltZW91dFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGxhc3ROb3RpZmljYXRpb25UaW1lcik7XG4gICAgICAgICAgICBsYXN0Tm90aWZpY2F0aW9uVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRlbC5mYWRlT3V0KHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQodGhpcykuZGVxdWV1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiIsIi8qKlxuICAgIExpc3Qgb2YgYWN0aXZpdGllcyBsb2FkZWQgaW4gdGhlIEFwcCxcbiAgICBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgYWN0aXZpdHkgbmFtZSBhcyB0aGUga2V5XG4gICAgYW5kIHRoZSBjb250cm9sbGVyIGFzIHZhbHVlLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpdml0eSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9BY3Rpdml0eScpO1xudmFyIEVtcHR5QWN0aXZpdHkgPSBBY3Rpdml0eS5leHRlbmRzKGZ1bmN0aW9uIEVtcHR5QWN0aXZpdHkoKSB7XG5cbiAgICBBY3Rpdml0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IG51bGw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB7fTtcbiAgICB0aGlzLm5hdkJhciA9IEFjdGl2aXR5LmNyZWF0ZVNlY3Rpb25OYXZCYXIoKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnX3Rlc3QnOiBFbXB0eUFjdGl2aXR5LFxuICAgICdjYWxlbmRhcic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9jYWxlbmRhcicpLFxuICAgICdkYXRldGltZVBpY2tlcic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9kYXRldGltZVBpY2tlcicpLFxuICAgICdjbGllbnRzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NsaWVudHMnKSxcbiAgICAnc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UnKSxcbiAgICAnc2VydmljZUFkZHJlc3Nlcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9zZXJ2aWNlQWRkcmVzc2VzJyksXG4gICAgJ3RleHRFZGl0b3InOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvdGV4dEVkaXRvcicpLFxuICAgICdkYXNoYm9hcmQnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvZGFzaGJvYXJkJyksXG4gICAgJ2FwcG9pbnRtZW50JzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2FwcG9pbnRtZW50JyksXG4gICAgJ2luZGV4JzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2luZGV4JyksXG4gICAgJ2xvZ2luJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2xvZ2luJyksXG4gICAgJ2xvZ291dCc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9sb2dvdXQnKSxcbiAgICAnbGVhcm5Nb3JlJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2xlYXJuTW9yZScpLFxuICAgICdzaWdudXAnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvc2lnbnVwJyksXG4gICAgJ2NvbnRhY3RJbmZvJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NvbnRhY3RJbmZvJyksXG4gICAgJ3dlbGNvbWUnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvd2VsY29tZScpLFxuICAgICdhZGRyZXNzRWRpdG9yJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2FkZHJlc3NFZGl0b3InKSxcbiAgICAnYWNjb3VudCc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9hY2NvdW50JyksXG4gICAgJ2luYm94JzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2luYm94JyksXG4gICAgJ2NvbnZlcnNhdGlvbic6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9jb252ZXJzYXRpb24nKSxcbiAgICAnc2NoZWR1bGluZyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9zY2hlZHVsaW5nJyksXG4gICAgJ2pvYnRpdGxlcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9qb2J0aXRsZXMnKSxcbiAgICAnZmVlZGJhY2snOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvZmVlZGJhY2snKSxcbiAgICAnZmFxcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9mYXFzJyksXG4gICAgJ2ZlZWRiYWNrRm9ybSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9mZWVkYmFja0Zvcm0nKSxcbiAgICAnY29udGFjdEZvcm0nOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvY29udGFjdEZvcm0nKSxcbiAgICAnY21zJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NtcycpLFxuICAgICdjbGllbnRFZGl0b3InOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvY2xpZW50RWRpdG9yJyksXG4gICAgJ3NjaGVkdWxpbmdQcmVmZXJlbmNlcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9zY2hlZHVsaW5nUHJlZmVyZW5jZXMnKSxcbiAgICAnY2FsZW5kYXJTeW5jaW5nJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2NhbGVuZGFyU3luY2luZycpLFxuICAgICd3ZWVrbHlTY2hlZHVsZSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy93ZWVrbHlTY2hlZHVsZScpLFxuICAgICdib29rTWVCdXR0b24nOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvYm9va01lQnV0dG9uJyksXG4gICAgJ293bmVySW5mbyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9vd25lckluZm8nKSxcbiAgICAncHJpdmFjeVNldHRpbmdzJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3ByaXZhY3lTZXR0aW5ncycpLFxuICAgICdhZGRKb2JUaXRsZXMnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvYWRkSm9iVGl0bGVzJyksXG4gICAgJ3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlRWRpdG9yJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlRWRpdG9yJyksXG4gICAgJ21hcmtldHBsYWNlUHJvZmlsZSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9tYXJrZXRwbGFjZVByb2ZpbGUnKSxcbiAgICAnbWFya2V0cGxhY2VKb2J0aXRsZXMnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvbWFya2V0cGxhY2VKb2J0aXRsZXMnKSxcbiAgICAncHJvZmlsZVBpY3R1cmVCaW8nOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvcHJvZmlsZVBpY3R1cmVCaW8nKSxcbiAgICAnc2VydmljZXNPdmVydmlldyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9zZXJ2aWNlc092ZXJ2aWV3JyksXG4gICAgJ3ZlcmlmaWNhdGlvbnMnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvdmVyaWZpY2F0aW9ucycpLFxuICAgICdlZHVjYXRpb24nOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvZWR1Y2F0aW9uJyksXG4gICAgJ3NlcnZpY2VQcm9mZXNzaW9uYWxXZWJzaXRlJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3NlcnZpY2VQcm9mZXNzaW9uYWxXZWJzaXRlJyksXG4gICAgJ2JhY2tncm91bmRDaGVjayc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9iYWNrZ3JvdW5kQ2hlY2snKSxcbiAgICAnZWR1Y2F0aW9uRm9ybSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9lZHVjYXRpb25Gb3JtJyksXG4gICAgJ2NhbmNlbGxhdGlvblBvbGljeSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9jYW5jZWxsYXRpb25Qb2xpY3knKSxcbiAgICAnbGljZW5zZXNDZXJ0aWZpY2F0aW9ucyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9saWNlbnNlc0NlcnRpZmljYXRpb25zJyksXG4gICAgJ2xpY2Vuc2VzQ2VydGlmaWNhdGlvbnNGb3JtJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL2xpY2Vuc2VzQ2VydGlmaWNhdGlvbnNGb3JtJyksXG4gICAgJ3dvcmtQaG90b3MnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvd29ya1Bob3RvcycpLFxuICAgICdwcm9maWxlJzogcmVxdWlyZSgnLi9hY3Rpdml0aWVzL3Byb2ZpbGUnKSxcbiAgICAnaG9tZSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9ob21lJyksXG4gICAgJ2Jvb2tpbmcnOiByZXF1aXJlKCcuL2FjdGl2aXRpZXMvYm9va2luZycpLFxuICAgICd0ZXJtcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy90ZXJtcycpLFxuICAgICdwYXltZW50cyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9wYXltZW50cycpLFxuICAgICd1c2VyRmVlcyc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy91c2VyRmVlcycpLFxuICAgICdwZXJmb3JtYW5jZSc6IHJlcXVpcmUoJy4vYWN0aXZpdGllcy9wZXJmb3JtYW5jZScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogR2xvYmFsIGRlcGVuZGVuY2llcyAqKi9cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5yZXF1aXJlKCdqcXVlcnktbW9iaWxlJyk7XG5yZXF1aXJlKCcuL3V0aWxzL2pxdWVyeS5tdWx0aWxpbmUnKTtcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5rby5iaW5kaW5nSGFuZGxlcnMuZm9ybWF0ID0gcmVxdWlyZSgna28vZm9ybWF0QmluZGluZycpLmZvcm1hdEJpbmRpbmc7XG52YXIgYm9vdGtub2NrID0gcmVxdWlyZSgnLi91dGlscy9ib290a25vY2tCaW5kaW5nSGVscGVycycpO1xucmVxdWlyZSgnLi91dGlscy9GdW5jdGlvbi5wcm90b3R5cGUuX2luaGVyaXRzJyk7XG5yZXF1aXJlKCcuL3V0aWxzL0Z1bmN0aW9uLnByb3RvdHlwZS5fZGVsYXllZCcpO1xuLy8gUG9seWZpbGwgZm9yIHVzZWZ1bCBub24tc3RhbmRhcmQgZmVhdHVyZSBGdW5jdGlvbi5uYW1lIGZvciBJRTkrXG4vLyAoZmVhdHVyZSB1c2VkIHRvIHNpbXBsaWZ5IGNyZWF0aW9uIG9mIEFjdGl2aXRpZXMgYW5kIE1vZGVscylcbnJlcXVpcmUoJy4vdXRpbHMvRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUtcG9seWZpbGwnKTtcbi8vIFByb21pc2UgcG9seWZpbGwsIHNvIGl0cyBub3QgJ3JlcXVpcmUnZCBwZXIgbW9kdWxlOlxucmVxdWlyZSgnZXM2LXByb21pc2UnKS5wb2x5ZmlsbCgpO1xuXG52YXIgbGF5b3V0VXBkYXRlRXZlbnQgPSByZXF1aXJlKCdsYXlvdXRVcGRhdGVFdmVudCcpO1xudmFyIEFwcE1vZGVsID0gcmVxdWlyZSgnLi9hcHBtb2RlbC9BcHBNb2RlbCcpO1xuXG4vLyBSZWdpc3RlciB0aGUgc3BlY2lhbCBsb2NhbGVcbnJlcXVpcmUoJy4vbG9jYWxlcy9lbi1VUy1MQycpO1xuXG52YXIgYXR0YWNoRmFzdENsaWNrID0gcmVxdWlyZSgnZmFzdGNsaWNrJykuYXR0YWNoO1xuXG4vKipcbiAgICBBIHNldCBvZiBmaXhlcy93b3JrYXJvdW5kcyBmb3IgQm9vdHN0cmFwIGJlaGF2aW9yL3BsdWdpbnNcbiAgICB0byBiZSBleGVjdXRlZCBiZWZvcmUgQm9vdHN0cmFwIGlzIGluY2x1ZGVkL2V4ZWN1dGVkLlxuICAgIEZvciBleGFtcGxlLCBiZWNhdXNlIG9mIGRhdGEtYmluZGluZyByZW1vdmluZy9jcmVhdGluZyBlbGVtZW50cyxcbiAgICBzb21lIG9sZCByZWZlcmVuY2VzIHRvIHJlbW92ZWQgaXRlbXMgbWF5IGdldCBhbGl2ZSBhbmQgbmVlZCB1cGRhdGUsXG4gICAgb3IgcmUtZW5hYmxpbmcgc29tZSBiZWhhdmlvcnMuXG4qKi9cbmZ1bmN0aW9uIHByZUJvb3RzdHJhcFdvcmthcm91bmRzKCkge1xuICAgIC8vIEludGVybmFsIEJvb3RzdHJhcCBzb3VyY2UgdXRpbGl0eVxuICAgIGZ1bmN0aW9uIGdldFRhcmdldEZyb21UcmlnZ2VyKCR0cmlnZ2VyKSB7XG4gICAgICAgIHZhciBocmVmLFxuICAgICAgICAgICAgdGFyZ2V0ID0gJHRyaWdnZXIuYXR0cignZGF0YS10YXJnZXQnKSB8fFxuICAgICAgICAgICAgKGhyZWYgPSAkdHJpZ2dlci5hdHRyKCdocmVmJykpICYmIFxuICAgICAgICAgICAgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJyk7IC8vIHN0cmlwIGZvciBpZTdcblxuICAgICAgICByZXR1cm4gJCh0YXJnZXQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBCdWc6IG5hdmJhci1jb2xsYXBzZSBlbGVtZW50cyBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZWlyIG9yaWdpbmFsXG4gICAgLy8gJHRyaWdnZXIsIGJ1dCB0aGF0IHRyaWdnZXIgY2FuIGNoYW5nZSBvbiBkaWZmZXJlbnQgJ2NsaWNrcycgb3JcbiAgICAvLyBnZXQgcmVtb3ZlZCB0aGUgb3JpZ2luYWwsIHNvIGl0IG11c3QgcmVmZXJlbmNlIHRoZSBuZXcgb25lXG4gICAgLy8gKHRoZSBsYXRlc3RzIGNsaWNrZWQsIGFuZCBub3QgdGhlIGNhY2hlZCBvbmUgdW5kZXIgdGhlICdkYXRhJyBBUEkpLiAgICBcbiAgICAvLyBOT1RFOiBoYW5kbGVyIG11c3QgZXhlY3V0ZSBiZWZvcmUgdGhlIEJvb3RzdHJhcCBoYW5kbGVyIGZvciB0aGUgc2FtZVxuICAgIC8vIGV2ZW50IGluIG9yZGVyIHRvIHdvcmsuXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmNvbGxhcHNlLmRhdGEtYXBpLndvcmthcm91bmQnLCAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICR0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgICR0YXJnZXQgPSBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdCksXG4gICAgICAgICAgICBkYXRhID0gJHRhcmdldCAmJiAkdGFyZ2V0LmRhdGEoJ2JzLmNvbGxhcHNlJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBhbnlcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHRyaWdnZXIgaW4gdGhlIGRhdGEgcmVmZXJlbmNlOlxuICAgICAgICAgICAgZGF0YS4kdHJpZ2dlciA9ICR0O1xuICAgICAgICB9XG4gICAgICAgIC8vIE9uIGVsc2UsIG5vdGhpbmcgdG8gZG8sIGEgbmV3IENvbGxhcHNlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxuICAgICAgICAvLyB3aXRoIHRoZSBjb3JyZWN0IHRhcmdldCwgdGhlIGZpcnN0IHRpbWVcbiAgICB9KTtcbn1cblxuLyoqXG4gICAgQXBwIHN0YXRpYyBjbGFzc1xuKiovXG52YXIgYXBwID0ge1xuICAgIHNoZWxsOiByZXF1aXJlKCcuL2FwcC5zaGVsbCcpLFxuICAgIFxuICAgIC8vIE5ldyBhcHAgbW9kZWwsIHRoYXQgc3RhcnRzIHdpdGggYW5vbnltb3VzIHVzZXJcbiAgICBtb2RlbDogbmV3IEFwcE1vZGVsKCksXG4gICAgXG4gICAgLyoqIExvYWQgYWN0aXZpdGllcyBjb250cm9sbGVycyAobm90IGluaXRpYWxpemVkKSAqKi9cbiAgICBhY3Rpdml0aWVzOiByZXF1aXJlKCcuL2FwcC5hY3Rpdml0aWVzJyksXG4gICAgXG4gICAgbW9kYWxzOiByZXF1aXJlKCcuL2FwcC5tb2RhbHMnKSxcbiAgICBcbiAgICAvKipcbiAgICAgICAgSnVzdCByZWRpcmVjdCB0aGUgYmV0dGVyIHBsYWNlIGZvciBjdXJyZW50IHVzZXIgYW5kIHN0YXRlLlxuICAgICAgICBOT1RFOiBJdHMgYSBkZWxheWVkIGZ1bmN0aW9uLCBzaW5jZSBvbiBtYW55IGNvbnRleHRzIG5lZWQgdG9cbiAgICAgICAgd2FpdCBmb3IgdGhlIGN1cnJlbnQgJ3JvdXRpbmcnIGZyb20gZW5kIGJlZm9yZSBkbyB0aGUgbmV3XG4gICAgICAgIGhpc3RvcnkgY2hhbmdlLlxuICAgICAgICBUT0RPOiBNYXliZSwgcmF0aGVyIHRoYW4gZGVsYXkgaXQsIGNhbiBzdG9wIGN1cnJlbnQgcm91dGluZ1xuICAgICAgICAoY2hhbmdlcyBvbiBTaGVsbCByZXF1aXJlZCkgYW5kIHBlcmZvcm0gdGhlIG5ldy5cbiAgICAgICAgVE9ETzogTWF5YmUgYWx0ZXJuYXRpdmUgdG8gcHJldmlvdXMsIHRvIHByb3ZpZGUgYSAncmVwbGFjZSdcbiAgICAgICAgaW4gc2hlbGwgcmF0aGVyIHRoYW4gYSBnbywgdG8gYXZvaWQgYXBwZW5kIHJlZGlyZWN0IGVudHJpZXNcbiAgICAgICAgaW4gdGhlIGhpc3RvcnksIHRoYXQgY3JlYXRlIHRoZSBwcm9ibGVtIG9mICdicm9rZW4gYmFjayBidXR0b24nXG4gICAgKiovXG4gICAgZ29EYXNoYm9hcmQ6IGZ1bmN0aW9uIGdvRGFzaGJvYXJkKCkge1xuICAgICAgICBcbiAgICAgICAgLy8gVG8gYXZvaWQgaW5maW5pdGUgbG9vcHMgaWYgd2UgYWxyZWFkeSBhcmUgcGVyZm9ybWluZyBcbiAgICAgICAgLy8gYSBnb0Rhc2hib2FyZCB0YXNrLCB3ZSBmbGFnIHRoZSBleGVjdXRpb25cbiAgICAgICAgLy8gYmVpbmcgY2FyZSBvZiB0aGUgZGVsYXkgaW50cm9kdWNlZCBpbiB0aGUgZXhlY3V0aW9uXG4gICAgICAgIGlmIChnb0Rhc2hib2FyZC5fZ29pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlbGF5ZWQgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIGluLXRoZS1taWRkbGVcbiAgICAgICAgICAgIC8vIHRhc2tzOiBqdXN0IGFsbG93aW5nIGN1cnJlbnQgcm91dGluZyB0byBmaW5pc2hcbiAgICAgICAgICAgIC8vIGJlZm9yZSBwZXJmb3JtIHRoZSAncmVkaXJlY3QnXG4gICAgICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgYnkgYSByZWFsIHJlZGlyZWN0IHRoYXQgaXMgYWJsZSB0b1xuICAgICAgICAgICAgLy8gY2FuY2VsIHRoZSBjdXJyZW50IGFwcC5zaGVsbCByb3V0aW5nIHByb2Nlc3MuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBnb0Rhc2hib2FyZC5fZ29pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9uYm9hcmRpbmcgPSB0aGlzLm1vZGVsLm9uYm9hcmRpbmcuc3RlcFVybCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9uYm9hcmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGVsbC5nbyhvbmJvYXJkaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlbGwuZ28oJy9kYXNoYm9hcmQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBKdXN0IGJlY2F1c2UgaXMgZGVsYXllZCwgbmVlZHNcbiAgICAgICAgICAgICAgICAvLyB0byBiZSBzZXQgb2ZmIGFmdGVyIGFuIGlubWVkaWF0ZSB0byBcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgaXMgc2V0IG9mZiBhZnRlciBhbnkgb3RoZXIgYXR0ZW1wdFxuICAgICAgICAgICAgICAgIC8vIHRvIGFkZCBhIGRlbGF5ZWQgZ29EYXNoYm9hcmQ6XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29EYXNoYm9hcmQuX2dvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqIENvbnRpbnVlIGFwcCBjcmVhdGlvbiB3aXRoIHRoaW5ncyB0aGF0IG5lZWQgYSByZWZlcmVuY2UgdG8gdGhlIGFwcCAqKi9cblxucmVxdWlyZSgnLi9hcHAtbmF2YmFyJykuZXh0ZW5kcyhhcHApO1xuXG5yZXF1aXJlKCcuL2FwcC1jb21wb25lbnRzJykucmVnaXN0ZXJBbGwoYXBwKTtcblxuYXBwLmdldEFjdGl2aXR5ID0gZnVuY3Rpb24gZ2V0QWN0aXZpdHkobmFtZSkge1xuICAgIHZhciBhY3Rpdml0eSA9IHRoaXMuYWN0aXZpdGllc1tuYW1lXTtcbiAgICBpZiAoYWN0aXZpdHkpIHtcbiAgICAgICAgdmFyICRhY3QgPSB0aGlzLnNoZWxsLml0ZW1zLmZpbmQobmFtZSk7XG4gICAgICAgIGlmICgkYWN0ICYmICRhY3QubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2aXR5LmluaXQoJGFjdCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuYXBwLmdldEFjdGl2aXR5Q29udHJvbGxlckJ5Um91dGUgPSBmdW5jdGlvbiBnZXRBY3Rpdml0eUNvbnRyb2xsZXJCeVJvdXRlKHJvdXRlKSB7XG4gICAgLy8gRnJvbSB0aGUgcm91dGUgb2JqZWN0LCB0aGUgaW1wb3J0YW50IHBpZWNlIGlzIHJvdXRlLm5hbWVcbiAgICAvLyB0aGF0IGNvbnRhaW5zIHRoZSBhY3Rpdml0eSBuYW1lIGV4Y2VwdCBpZiBpcyB0aGUgcm9vdFxuICAgIHZhciBhY3ROYW1lID0gcm91dGUubmFtZSB8fCB0aGlzLnNoZWxsLmluZGV4TmFtZTtcbiAgICBcbiAgICByZXR1cm4gdGhpcy5nZXRBY3Rpdml0eShhY3ROYW1lKTtcbn07XG5cbi8vIGFjY2Vzc0NvbnRyb2wgc2V0dXA6IGNhbm5vdCBiZSBzcGVjaWZpZWQgb24gU2hlbGwgY3JlYXRpb24gYmVjYXVzZVxuLy8gZGVwZW5kcyBvbiB0aGUgYXBwIGluc3RhbmNlXG5hcHAuc2hlbGwuYWNjZXNzQ29udHJvbCA9IHJlcXVpcmUoJy4vdXRpbHMvYWNjZXNzQ29udHJvbCcpKGFwcCk7XG5cbi8vIFNob3J0Y3V0IHRvIFVzZXJUeXBlIGVudW1lcmF0aW9uIHVzZWQgdG8gc2V0IHBlcm1pc3Npb25zXG5hcHAuVXNlclR5cGUgPSByZXF1aXJlKCcuL21vZGVscy9Vc2VyJykuVXNlclR5cGU7XG5cbi8vIE5ldyBtZXRob2QgZm9yIGNvbW1vbiBmb3JtcyBiZWhhdmlvciBhZnRlciBhIHN1Y2Nlc3NmdWwgc2F2ZSBvcGVyYXRpb24sXG4vLyB0aGUgYWN0aXZpdHkgZ29lcyBiYWNrIChmb2xsb3dpbmcgdGhlIG5hdmJhciBiYWNrLWxpbmsgb3Igc2hlbGwuZ29CYWNrKCkpXG4vLyBhbmQgbm90aWZ5aW5nIHdpdGggYSB0ZW1wb3JhcnkgdW5vYnRydXNpdmUgbmF2YmFyIG5vdGlmaWNhdGlvblxuYXBwLnN1Y2Nlc3NTYXZlID0gZnVuY3Rpb24gc3VjY2Vzc1NhdmUoc2V0dGluZ3MpIHtcbiAgICAvLyBkZWZhdWx0c1xuICAgIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICBtZXNzYWdlOiAnWW91ciBjaGFuZ2VzIGhhdmUgYmVlbiBzYXZlZCcsXG4gICAgICAgIGxpbms6IG51bGxcbiAgICB9LCBzZXR0aW5ncyk7XG4gICAgXG4gICAgLy8gc2hvdyBub3RpZmljYXRpb25cbiAgICB0aGlzLnNob3dOYXZCYXJOb3RpZmljYXRpb24oc2V0dGluZ3MpO1xuICAgIFxuICAgIC8vIHJlcXVlc3RlZCBsaW5rIG9yIGN1cnJlbnQgYWN0aXZpdHkgZ28gYmFja1xuICAgIGlmIChzZXR0aW5ncy5saW5rKVxuICAgICAgICB0aGlzLnNoZWxsLmdvKHNldHRpbmdzLmxpbmspO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5wZXJmb3Jtc05hdkJhckJhY2soeyBzaWxlbnRNb2RlOiB0cnVlIH0pO1xufTtcblxuLyoqIEFwcCBJbml0ICoqL1xudmFyIGFwcEluaXQgPSBmdW5jdGlvbiBhcHBJbml0KCkge1xuICAgIC8qanNoaW50IG1heHN0YXRlbWVudHM6NTAsbWF4Y29tcGxleGl0eToxNiAqL1xuICAgIFxuICAgIGF0dGFjaEZhc3RDbGljayhkb2N1bWVudC5ib2R5KTtcbiAgICBcbiAgICAvLyBKcXVlcnktdWkgY29tcG9uZW50cyB1c2VkXG4gICAgcmVxdWlyZSgnanF1ZXJ5LXVpL2F1dG9jb21wbGV0ZScpO1xuICAgIC8vIEtub2Nrb3V0IGJpbmRpbmcgZm9yIGpxdWVyeS11aSBzb3J0YWJsZS5cbiAgICAvLyBJdCBsb2FkcyBqcXVlcnktdWkgc29ydGFibGUgYW5kIGRyYWdnYWJsZSBhcyBkZXBlbmRlbmNpZXM6XG4gICAgcmVxdWlyZSgna25vY2tvdXQtc29ydGFibGUnKTtcbiAgICAvLyBKdXN0IEFGVEVSIGpxdWVyeS11aSBpcyBsb2FkZWQgKG9yIHRoZSBzZWxlY3RlZCBjb21wb25lbnRzKSwgbG9hZFxuICAgIC8vIHRoZSBmaXggZm9yIHRvdWNoIHN1cHBvcnQ6XG4gICAgcmVxdWlyZSgnanF1ZXJ5LnVpLnRvdWNoLXB1bmNoJyk7XG4gICAgXG4gICAgLy8gRW5hYmxpbmcgdGhlICdsYXlvdXRVcGRhdGUnIGpRdWVyeSBXaW5kb3cgZXZlbnQgdGhhdCBoYXBwZW5zIG9uIHJlc2l6ZSBhbmQgdHJhbnNpdGlvbmVuZCxcbiAgICAvLyBhbmQgY2FuIGJlIHRyaWdnZXJlZCBtYW51YWxseSBieSBhbnkgc2NyaXB0IHRvIG5vdGlmeSBjaGFuZ2VzIG9uIGxheW91dCB0aGF0XG4gICAgLy8gbWF5IHJlcXVpcmUgYWRqdXN0bWVudHMgb24gb3RoZXIgc2NyaXB0cyB0aGF0IGxpc3RlbiB0byBpdC5cbiAgICAvLyBUaGUgZXZlbnQgaXMgdGhyb3R0bGUsIGd1YXJhbnRpbmcgdGhhdCB0aGUgbWlub3IgaGFuZGxlcnMgYXJlIGV4ZWN1dGVkIHJhdGhlclxuICAgIC8vIHRoYW4gYSBsb3Qgb2YgdGhlbSBpbiBzaG9ydCB0aW1lIGZyYW1lcyAoYXMgaGFwcGVuIHdpdGggJ3Jlc2l6ZScgZXZlbnRzKS5cbiAgICBsYXlvdXRVcGRhdGVFdmVudC5sYXlvdXRVcGRhdGVFdmVudCArPSAnIG9yaWVudGF0aW9uY2hhbmdlJztcbiAgICBsYXlvdXRVcGRhdGVFdmVudC5vbigpO1xuICAgIFxuICAgIC8vIEtleWJvYXJkIHBsdWdpbiBldmVudHMgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggalF1ZXJ5IGV2ZW50cywgYnV0IG5lZWRlZCB0b1xuICAgIC8vIHRyaWdnZXIgYSBsYXlvdXRVcGRhdGUsIHNvIGhlcmUgYXJlIGNvbm5lY3RlZCwgbWFpbmx5IGZpeGluZyBidWdzIG9uIGlPUyB3aGVuIHRoZSBrZXlib2FyZFxuICAgIC8vIGlzIGhpZGRpbmcuXG4gICAgdmFyIHRyaWdMYXlvdXQgPSBmdW5jdGlvbiB0cmlnTGF5b3V0KCkge1xuICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignbGF5b3V0VXBkYXRlJyk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIHRyaWdMYXlvdXQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRoaWRlJywgdHJpZ0xheW91dCk7XG5cbiAgICAvLyBpT1MtNysgc3RhdHVzIGJhciBmaXguIEFwcGx5IG9uIHBsdWdpbiBsb2FkZWQgKGNvcmRvdmEvcGhvbmVnYXAgZW52aXJvbm1lbnQpXG4gICAgLy8gYW5kIGluIGFueSBzeXN0ZW0sIHNvIGFueSBvdGhlciBzeXN0ZW1zIGZpeCBpdHMgc29sdmVkIHRvbyBpZiBuZWVkZWQgXG4gICAgLy8ganVzdCB1cGRhdGluZyB0aGUgcGx1Z2luIChmdXR1cmUgcHJvb2YpIGFuZCBlbnN1cmUgaG9tb2dlbmVvdXMgY3Jvc3MgcGxhZnRmb3JtIGJlaGF2aW9yLlxuICAgIGlmICh3aW5kb3cuU3RhdHVzQmFyKSB7XG4gICAgICAgIC8vIEZpeCBpT1MtNysgb3ZlcmxheSBwcm9ibGVtXG4gICAgICAgIC8vIElzIGluIGNvbmZpZy54bWwgdG9vLCBidXQgc2VlbXMgbm90IHRvIHdvcmsgd2l0aG91dCBuZXh0IGNhbGw6XG4gICAgICAgIHdpbmRvdy5TdGF0dXNCYXIub3ZlcmxheXNXZWJWaWV3KGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yY2UgYW4gdXBkYXRlIGRlbGF5ZWQgdG8gZW5zdXJlIHVwZGF0ZSBhZnRlciBzb21lIHRoaW5ncyBkaWQgYWRkaXRpb25hbCB3b3JrXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2xheW91dFVwZGF0ZScpO1xuICAgIH0sIDIwMCk7XG4gICAgXG4gICAgLy8gQm9vdHN0cmFwXG4gICAgcHJlQm9vdHN0cmFwV29ya2Fyb3VuZHMoKTtcbiAgICByZXF1aXJlKCdib290c3RyYXAnKTtcbiAgICBcbiAgICAvLyBMb2FkIEtub2Nrb3V0IGJpbmRpbmcgaGVscGVyc1xuICAgIGJvb3Rrbm9jay5wbHVnSW4oa28pO1xuICAgIHJlcXVpcmUoJy4vdXRpbHMvYm9vdHN0cmFwU3dpdGNoQmluZGluZycpLnBsdWdJbihrbyk7XG4gICAgXG4gICAgLy8gUGx1Z2lucyBzZXR1cFxuICAgIGlmICh3aW5kb3cuY29yZG92YSAmJiB3aW5kb3cuY29yZG92YS5wbHVnaW5zICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQpIHtcbiAgICAgICAgLy8gRXhwbGljaXRlbHksIHdlIFdBTlQgYXV0byBzY3JvbGwgb24ga2V5Ym9hcmQgc2hvdyB1cC5cbiAgICAgICAgLy8gQ2FuIGJlIGRpc2FibGVkIG9ubHkgaWYgdGhlcmUgaXMgYSBqYXZhc2NyaXB0IHNvbHV0aW9uIHRvIGF1dG9zY3JvbGxcbiAgICAgICAgLy8gb24gaW5wdXQgZm9jdXMsIGVsc2UgYSBidWcgd2lsbCBoYXBwZW4gc3BlY2lhbGx5IG9uIGlPUyB3aGVyZSBpbnB1dFxuICAgICAgICAvLyBmaWVsZHMgZ2V0cyBoaWRkZW4gYnkgdGhlIG9uIHNjcmVlbiBrZXlib2FyZC5cbiAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5kaXNhYmxlU2Nyb2xsKGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRWFzeSBsaW5rcyB0byBzaGVsbCBhY3Rpb25zLCBsaWtlIGdvQmFjaywgaW4gaHRtbCBlbGVtZW50c1xuICAgIC8vIEV4YW1wbGU6IDxidXR0b24gZGF0YS1zaGVsbD1cImdvQmFjayAyXCI+R28gMiB0aW1lcyBiYWNrPC9idXR0b24+XG4gICAgLy8gTk9URTogSW1wb3J0YW50LCByZWdpc3RlcmVkIGJlZm9yZSB0aGUgc2hlbGwucnVuIHRvIGJlIGV4ZWN1dGVkXG4gICAgLy8gYmVmb3JlIGl0cyAnY2F0Y2ggYWxsIGxpbmtzJyBoYW5kbGVyXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJ1tkYXRhLXNoZWxsXScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gVXNpbmcgYXR0ciByYXRoZXIgdGhhbiB0aGUgJ2RhdGEnIEFQSSB0byBnZXQgdXBkYXRlZFxuICAgICAgICAvLyBET00gdmFsdWVzXG4gICAgICAgIHZhciBjbWRsaW5lID0gJCh0aGlzKS5hdHRyKCdkYXRhLXNoZWxsJykgfHwgJycsXG4gICAgICAgICAgICBhcmdzID0gY21kbGluZS5zcGxpdCgnICcpLFxuICAgICAgICAgICAgY21kID0gYXJnc1swXTtcblxuICAgICAgICBpZiAoY21kICYmIHR5cGVvZihhcHAuc2hlbGxbY21kXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFwcC5zaGVsbFtjbWRdLmFwcGx5KGFwcC5zaGVsbCwgYXJncy5zbGljZSgxKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENhbmNlbCBhbnkgb3RoZXIgYWN0aW9uIG9uIHRoZSBsaW5rLCB0byBhdm9pZCBkb3VibGUgbGlua2luZyByZXN1bHRzXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gT24gQ29yZG92YS9QaG9uZWdhcCBhcHAsIHNwZWNpYWwgdGFyZ2V0cyBtdXN0IGJlIGNhbGxlZCB1c2luZyB0aGUgd2luZG93Lm9wZW5cbiAgICAvLyBBUEkgdG8gZW5zdXJlIGlzIGNvcnJlY3RseSBvcGVuZWQgb24gdGhlIEluQXBwQnJvd3NlciAoX2JsYW5rKSBvciBzeXN0ZW0gZGVmYXVsdFxuICAgIC8vIGJyb3dzZXIgKF9zeXN0ZW0pLlxuICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnW3RhcmdldD1cIl9ibGFua1wiXSwgW3RhcmdldD1cIl9zeXN0ZW1cIl0nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpLCB0aGlzLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hlbiBhbiBhY3Rpdml0eSBpcyByZWFkeSBpbiB0aGUgU2hlbGw6XG4gICAgYXBwLnNoZWxsLm9uKGFwcC5zaGVsbC5ldmVudHMuaXRlbVJlYWR5LCBmdW5jdGlvbigkYWN0LCBzdGF0ZSkge1xuICAgICAgICBcbiAgICAgICAgLy8gTXVzdCBiZSB0aGUgc2FtZTpcbiAgICAgICAgdmFyIHJvdXRlTmFtZSA9IGFwcC5zaGVsbC5jdXJyZW50Um91dGUubmFtZTtcbiAgICAgICAgdmFyIGFjdE5hbWUgPSAkYWN0LmRhdGEoJ2FjdGl2aXR5Jyk7XG4gICAgICAgIC8vIElmIG5vdCwgc29tZSByYWNlIGNvbmRpdGlvbiwgbm90IHRoZSBzYW1lIHBhZ2UgZ28gb3V0XG4gICAgICAgIGlmIChyb3V0ZU5hbWUgIT09IGFjdE5hbWUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgJ2FjdGl2aXRpZXMnIGNvbnRyb2xsZXJzIHRvIHRoZWlyIHZpZXdzXG4gICAgICAgIHZhciBhY3Rpdml0eSA9IGFwcC5nZXRBY3Rpdml0eShhY3ROYW1lKTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgJ3Nob3cnIGxvZ2ljIG9mIHRoZSBhY3Rpdml0eSBjb250cm9sbGVyOlxuICAgICAgICBhY3Rpdml0eS5zaG93KHN0YXRlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoZSBzaG93IGxvZ2ljIG1heSBkbyBhIHJlZGlyZWN0LCBsb2FkaW5nIG90aGVyIGFjdGl2aXR5LCBkb3VibGUgY2hlY2tcbiAgICAgICAgcm91dGVOYW1lID0gYXBwLnNoZWxsLmN1cnJlbnRSb3V0ZS5uYW1lO1xuICAgICAgICBpZiAocm91dGVOYW1lICE9PSBhY3ROYW1lKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBtZW51XG4gICAgICAgIHZhciBtZW51SXRlbSA9IGFjdGl2aXR5Lm1lbnVJdGVtIHx8IGFjdE5hbWU7XG4gICAgICAgIGFwcC51cGRhdGVNZW51KG1lbnVJdGVtKTtcblxuICAgICAgICAvLyBVcGRhdGUgYXBwIG5hdmlnYXRpb25cbiAgICAgICAgYXBwLnVwZGF0ZUFwcE5hdihhY3Rpdml0eSwgc3RhdGUpO1xuICAgIH0pO1xuICAgIC8vIFdoZW4gYW4gYWN0aXZpdHkgaXMgaGlkZGVuXG4gICAgYXBwLnNoZWxsLm9uKGFwcC5zaGVsbC5ldmVudHMuY2xvc2VkLCBmdW5jdGlvbigkYWN0KSB7XG4gICAgICAgIFxuICAgICAgICAvLyBDb25uZWN0IHRoZSAnYWN0aXZpdGllcycgY29udHJvbGxlcnMgdG8gdGhlaXIgdmlld3NcbiAgICAgICAgdmFyIGFjdE5hbWUgPSAkYWN0LmRhdGEoJ2FjdGl2aXR5Jyk7XG4gICAgICAgIHZhciBhY3Rpdml0eSA9IGFwcC5nZXRBY3Rpdml0eShhY3ROYW1lKTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgJ2hpZGUnIGxvZ2ljIG9mIHRoZSBhY3Rpdml0eSBjb250cm9sbGVyOlxuICAgICAgICBpZiAoYWN0aXZpdHkuaGlkZSlcbiAgICAgICAgICAgIGFjdGl2aXR5LmhpZGUoKTtcbiAgICB9KTtcbiAgICAvLyBDYXRjaCBlcnJvcnMgb24gaXRlbS9wYWdlIGxvYWRpbmcsIHNob3dpbmcuLlxuICAgIGFwcC5zaGVsbC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3IoeyBlcnJvcjogZXJyIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNjcm9sbCB0byBlbGVtZW50IHdoZW4gY2xpY2tpbmcgYSB1c3VhbCBmcmFnbWVudCBsaW5rIChub3QgYSBwYWdlIGxpbmspXG4gICAgdmFyIHNjcm9sbFRvRWxlbWVudCA9IHJlcXVpcmUoJy4vdXRpbHMvc2Nyb2xsVG9FbGVtZW50Jyk7XG4gICAgYXBwLnNoZWxsLm9uKCdmcmFnbWVudE5hdmlnYXRpb24nLCBmdW5jdGlvbihocmVmKSB7XG4gICAgICAgIC8vIENoZWNrIGxpbmssIGF2b2lkaW5nIGVtcHR5IGxpbmtzXG4gICAgICAgIC8vIChocmVmIGNvbWVzIHdpdGggdGhlIGluaXRpYWwgaGFzaCBldmVyLCBzbyBlbXB0eSBpcyBqdXN0ICcjJylcbiAgICAgICAgaWYgKGhyZWYgPT09ICcjJykge1xuICAgICAgICAgICAgLy8gTm90aWZ5IGZvciBkZWJ1Z2dpbmcsIGJlY2F1c2UgdGhpcyBtYXkgYmUgdW53YW50ZWRcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnTmF2aWdhdGlvbiB0byBhbiBlbXB0eSBmcmFnbWVudCwgdGhpcyBtYXkgYmUgbm90IHdhbnRlZC4gJyArXG4gICAgICAgICAgICAgICAgJ0ZvciByb290IGxpbmtzLCB1c2UgXCIvXCI7IG9uIHNjcmlwdCBoYW5kbGVkIGxpbmtzLCBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0OyAnICtcbiAgICAgICAgICAgICAgICAnQSB0b3VjaCBldmVudCB3YXMgbGlzdGVuZWQgb24gYSBsaW5rLCBidXQgbm90IHRoZSBjbGljayBldmVudC4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTG9jYXRlIHRhcmdldFxuICAgICAgICAgICAgdmFyIHRhcmdldCA9ICQoaHJlZik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFNtb290aCBzY3JvbGxpbmcgd2l0aCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBzY3JvbGxUb0VsZW1lbnQodGFyZ2V0LCB7IGFuaW1hdGlvbjogeyBkdXJhdGlvbjogMzAwIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBOYXZiYXIgYmluZGluZ1xuICAgIGFwcC5zZXR1cE5hdkJhckJpbmRpbmcoKTtcbiAgICBcbiAgICB2YXIgU21hcnROYXZCYXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvU21hcnROYXZCYXInKTtcbiAgICB2YXIgbmF2QmFycyA9IFNtYXJ0TmF2QmFyLmdldEFsbCgpO1xuICAgIC8vIENyZWF0ZXMgYW4gZXZlbnQgYnkgbGlzdGVuaW5nIHRvIGl0LCBzbyBvdGhlciBzY3JpcHRzIGNhbiB0cmlnZ2VyXG4gICAgLy8gYSAnY29udGVudENoYW5nZScgZXZlbnQgdG8gZm9yY2UgYSByZWZyZXNoIG9mIHRoZSBuYXZiYXIgKHRvIFxuICAgIC8vIGNhbGN1bGF0ZSBhbmQgYXBwbHkgYSBuZXcgc2l6ZSk7IGV4cGVjdGVkIGZyb20gZHluYW1pYyBuYXZiYXJzXG4gICAgLy8gdGhhdCBjaGFuZ2UgaXQgY29udGVudCBiYXNlZCBvbiBvYnNlcnZhYmxlcy5cbiAgICBuYXZCYXJzLmZvckVhY2goZnVuY3Rpb24obmF2YmFyKSB7XG4gICAgICAgICQobmF2YmFyLmVsKS5vbignY29udGVudENoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbmF2YmFyLnJlZnJlc2goKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gTGlzdGVuIGZvciBtZW51IGV2ZW50cyAoY29sbGFwc2UgaW4gU21hcnROYXZCYXIpXG4gICAgLy8gdG8gYXBwbHkgdGhlIGJhY2tkcm9wOyBhZGQgYW5vdGhlciBjbGFzcywgZXhwbGljaXQgZm9yIGtub3cgdGhlIG1lbnUvbmF2IGlzIG9wZW5lZFxuICAgIHZhciB0b2dnbGluZ0JhY2tkcm9wID0gZmFsc2U7XG4gICAgJChkb2N1bWVudCkub24oJ3Nob3cuYnMuY29sbGFwc2UgaGlkZS5icy5jb2xsYXBzZScsICcuQXBwTmF2IC5uYXZiYXItY29sbGFwc2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdG9nZ2xpbmdCYWNrZHJvcCkge1xuICAgICAgICAgICAgdG9nZ2xpbmdCYWNrZHJvcCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZW5hYmxlZCA9IGUudHlwZSA9PT0gJ3Nob3cnO1xuICAgICAgICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCd1c2UtYmFja2Ryb3AnLCBlbmFibGVkKTtcbiAgICAgICAgICAgICQoJ2JvZHknKS50b2dnbGVDbGFzcygnaGFzLWFwcE5hdi1vcGVuJywgZW5hYmxlZCk7XG4gICAgICAgICAgICAvLyBIaWRlIGFueSBvdGhlciBvcGVuZWQgY29sbGFwc2VcbiAgICAgICAgICAgICQoJy5jb2xsYXBzaW5nLCAuY29sbGFwc2UuaW4nKS5jb2xsYXBzZSgnaGlkZScpO1xuICAgICAgICAgICAgdG9nZ2xpbmdCYWNrZHJvcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDYXRjaCB1bmNhdGNoIG1vZGVsIGVycm9yc1xuICAgIGFwcC5tb2RlbC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBBZGRpdGlvbmFsIGZvcm0gZWxlbWVudHMgYXR0cmlidXRlIGFuZCBiZWhhdmlvcjogZGF0YS1hdXRvc2VsZWN0PXRydWVcbiAgICAvLyBzZXRzIHRvIGF1dG9tYXRpY2FsbHkgc2VsZWN0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gaW5wdXQgdGV4dCBjb250cm9sXG4gICAgLy8gd2hlbiBnZXRzIHRoZSBmb2N1c1xuICAgICQoZG9jdW1lbnQpLm9uKCdmb2N1cycsICdbZGF0YS1hdXRvc2VsZWN0PVwidHJ1ZVwiXScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEFwcCBpbml0OlxuICAgIHZhciBhbGVydEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcnLFxuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGlmICh3aW5kb3cuaW5zdGFidWcpIHtcbiAgICAgICAgd2luZG93Lmluc3RhYnVnLmluaXQoe1xuICAgICAgICAgICAgaW9zVG9rZW46ICc1MTVkOWU5MGJkNjhhMTgxODJhMDVlMmE2ODY4OTg5NycsXG4gICAgICAgICAgICBhbmRyb2lkVG9rZW46ICc5ODU2MDU0ZTkyZTdhZTdhODMyNmYxNjY2NzAzZDUxZCdcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXBwLm1vZGVsLmluaXQoKVxuICAgIC50aGVuKGFwcC5zaGVsbC5ydW4uYmluZChhcHAuc2hlbGwpLCBhbGVydEVycm9yKVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBwYWdlIGFzIHJlYWR5XG4gICAgICAgICQoJ2h0bWwnKS5hZGRDbGFzcygnaXMtcmVhZHknKTtcbiAgICAgICAgLy8gQXMgYXBwLCBoaWRlcyBzcGxhc2ggc2NyZWVuXG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuKSB7XG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnNwbGFzaHNjcmVlbi5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENvbm5lY3QgdXNlcm5hbWUgaW4gbmF2YmFyLCBhbmQgdHlwZSBmbGFnc1xuICAgICAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB1ID0gYXBwLm1vZGVsLnVzZXJQcm9maWxlLmRhdGEsXG4gICAgICAgICAgICAgICAgbiA9IHUuZmlyc3ROYW1lKCk7XG4gICAgICAgICAgICBhcHAubmF2QmFyQmluZGluZy51c2VyTmFtZShuIHx8ICdNZScpO1xuICAgICAgICAgICAgYXBwLm5hdkJhckJpbmRpbmcuaXNTZXJ2aWNlUHJvZmVzc2lvbmFsKHUuaXNTZXJ2aWNlUHJvZmVzc2lvbmFsKCkpO1xuICAgICAgICAgICAgYXBwLm5hdkJhckJpbmRpbmcuaXNDbGllbnQodS5pc0NsaWVudCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvbm5lY3QgcGhvdG9VcmwgaW4gbmF2YmFyXG4gICAgICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG4gPSBhcHAubW9kZWwubWFya2V0cGxhY2VQcm9maWxlLmRhdGEucGhvdG9VcmwoKTtcbiAgICAgICAgICAgIGFwcC5uYXZCYXJCaW5kaW5nLnBob3RvVXJsKG4gfHwgJ2Fib3V0OmJsYW5rJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gT25ib2FyZGluZyBtb2RlbCBuZWVkcyBpbml0aWFsaXphdGlvblxuICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5pbml0KGFwcCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgb25ib2FyZGluZyBzdGVwIHRvIHJlZGlyZWN0IHRoZXJlIG9uIGFwcCBzdGFydFxuICAgICAgICB2YXIgc3RlcCA9IGFwcC5tb2RlbC51c2VyKCkub25ib2FyZGluZ1N0ZXAoKTtcbiAgICAgICAgaWYgKHN0ZXAgJiYgXG4gICAgICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5zZXRTdGVwKHN0ZXApKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gYXBwLm1vZGVsLm9uYm9hcmRpbmcuc3RlcFVybCgpO1xuICAgICAgICAgICAgYXBwLnNoZWxsLmdvKHVybCk7XG4gICAgICAgIH1cblxuICAgIH0sIGFsZXJ0RXJyb3IpO1xuXG4gICAgLy8gREVCVUdcbiAgICB3aW5kb3cuYXBwID0gYXBwO1xufTtcblxuLy8gQXBwIGluaXQgb24gcGFnZSByZWFkeSBhbmQgcGhvbmVnYXAgcmVhZHlcbmlmICh3aW5kb3cuY29yZG92YSkge1xuICAgIC8vIE9uIERPTS1SZWFkeSBmaXJzdFxuICAgICQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFBhZ2UgaXMgcmVhZHksIGRldmljZSBpcyB0b28/XG4gICAgICAgIC8vIE5vdGU6IENvcmRvdmEgZW5zdXJlcyB0byBjYWxsIHRoZSBoYW5kbGVyIGV2ZW4gaWYgdGhlXG4gICAgICAgIC8vIGV2ZW50IHdhcyBhbHJlYWR5IGZpcmVkLCBzbyBpcyBnb29kIHRvIGRvIGl0IGluc2lkZVxuICAgICAgICAvLyB0aGUgZG9tLXJlYWR5IGFuZCB3ZSBhcmUgZW5zdXJpbmcgdGhhdCBldmVyeXRoaW5nIGlzXG4gICAgICAgIC8vIHJlYWR5LlxuICAgICAgICAkKGRvY3VtZW50KS5vbignZGV2aWNlcmVhZHknLCBhcHBJbml0KTtcbiAgICB9KTtcbn0gZWxzZSB7XG4gICAgLy8gT25seSBvbiBET00tUmVhZHksIGZvciBpbiBicm93c2VyIGRldmVsb3BtZW50XG4gICAgJChhcHBJbml0KTtcbn1cbiIsIi8qKlxuICAgIEFjY2VzcyB0byB1c2UgZ2xvYmFsIEFwcCBNb2RhbHNcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vKipcbiAgICBHZW5lcmF0ZXMgYSB0ZXh0IG1lc3NhZ2UsIHdpdGggbmV3bGluZXMgaWYgbmVlZGVkLCBkZXNjcmliaW5nIHRoZSBlcnJvclxuICAgIG9iamVjdCBwYXNzZWQuXG4gICAgQHBhcmFtIGVycjphbnkgQXMgYSBzdHJpbmcsIGlzIHJldHVybmVkICdhcyBpcyc7IGFzIGZhbHN5LCBpdCByZXR1cm4gYSBnZW5lcmljXG4gICAgbWVzc2FnZSBmb3IgJ3Vua25vdyBlcnJvcic7IGFzIG9iamVjdCwgaXQgaW52ZXN0aWdhdGUgd2hhdCB0eXBlIG9mIGVycm9yIGlzIHRvXG4gICAgcHJvdmlkZSB0aGUgbW9yZSBtZWFuaW5mdWwgcmVzdWx0LCB3aXRoIGZhbGxiYWNrIHRvIEpTT04uc3RyaW5naWZ5IHByZWZpeGVkXG4gICAgd2l0aCAnVGVjaG5pY2FsIGRldGFpbHM6Jy5cbiAgICBPYmplY3RzIHJlY29nbml6ZWQ6XG4gICAgLSBYSFIvalF1ZXJ5IGZvciBKU09OIHJlc3BvbnNlczoganVzdCBvYmplY3RzIHdpdGggcmVzcG9uc2VKU09OIHByb3BlcnR5LCBpc1xuICAgICAgdXNlZCBhcyB0aGUgJ2Vycicgb2JqZWN0IGFuZCBwYXNzZWQgdG8gdGhlIG90aGVyIG9iamVjdCB0ZXN0cy5cbiAgICAtIE9iamVjdCB3aXRoICdlcnJvck1lc3NhZ2UnIChzZXJ2ZXItc2lkZSBmb3JtYXR0ZWQgZXJyb3IpLlxuICAgIC0gT2JqZWN0IHdpdGggJ21lc3NhZ2UnIHByb3BlcnR5LCBsaWtlIHRoZSBzdGFuZGFyZCBFcnJvciBjbGFzcyBhbmQgRXhjZXB0aW9uIG9iamVjdHMuXG4gICAgLSBPYmplY3Qgd2l0aCAnbmFtZScgcHJvcGVydHksIGxpa2UgdGhlIHN0YW5kYXJkIEV4Y2VwdGlvbiBvYmplY3RzLiBUaGUgbmFtZSwgaWYgYW55LFxuICAgICAgaXMgc2V0IGFzIHByZWZpeCBmb3IgdGhlICdtZXNzYWdlJyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAtIE9iamVjdCB3aXRoICdlcnJvcnMnIHByb3BlcnR5LiBFYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IG9yIG9iamVjdCBvd24ga2V5c1xuICAgICAgaXMgYXBwZW5kZWQgdG8gdGhlIGVycm9yTWVzc2FnZSBvciBtZXNzYWdlIHNlcGFyYXRlZCBieSBuZXdsaW5lLlxuKiovXG5leHBvcnRzLmdldEVycm9yTWVzc2FnZUZyb20gPSBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2VGcm9tKGVyciwgZGVmYXVsdFRleHQpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjE0LCBtYXhkZXB0aDo1Ki9cblxuICAgIGRlZmF1bHRUZXh0ID0gZGVmYXVsdFRleHQgfHwgJ1Vua25vdyBlcnJvcic7XG4gICAgXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRUZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YoZXJyKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVyciB8fCBkZWZhdWx0VGV4dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGlzIGEgWEhSIG9iamVjdCwgdXNlIGl0cyByZXNwb25zZSBhcyB0aGUgZXJyb3IuXG4gICAgICAgIGVyciA9IGVyci5yZXNwb25zZUpTT04gfHwgZXJyO1xuXG4gICAgICAgIHZhciBtc2cgPSBlcnIubmFtZSAmJiAoZXJyLm5hbWUgKyAnOiAnKSB8fCAnJztcbiAgICAgICAgbXNnICs9IGVyci5lcnJvck1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2UgfHwgJyc7XG5cbiAgICAgICAgaWYgKGVyci5lcnJvcnMpIHtcbiAgICAgICAgICAgIG1zZyArPSAnXFxuJyArIGV4cG9ydHMuc3RyaW5naWZ5RXJyb3JzTGlzdChlcnIuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEF2b2lkaW5nIHRoYXQgZW4gZXJyb3IgY29udmVydGluZyB0aGUgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2VzKVxuICAgICAgICAgICAgLy8gYnJlYWtzIHRoZSBlcnJvciBjb250cm9sIVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIganNlcnIgPSBKU09OLnN0cmluZ2lmeShlcnIpO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkaW5nIHRoYXQgZW1wdHkgcmVzdWx0cyAoZW1wdHkgc3RyaW5nIG9yIGVtcHR5IG9iamVjdCB3aGVuIHRoZXJlXG4gICAgICAgICAgICAgICAgLy8gaXMgbm8gZGV0YWlscyB0byBzaG93KSBtYWtlcyB1cyB0byBzaG93IGFuIGFubm95aW5nICd0ZWNobmljYWwgZGV0YWlscydcbiAgICAgICAgICAgICAgICB2YXIgaGFzTW9yZUluZm8gPSBqc2VyciAmJiBqc2VyciAhPT0gJ3t9JztcbiAgICAgICAgICAgICAgICAvLyBUb28gaWYgdGhlcmUgaXMgbm8gbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZSBvbmUgZXh0cmFjdGVkIHRvIGJ1aWxkIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UsIHNpbmNlIG9uIHRoYXQgY2FzZXMgdGhlICd0ZWNobmljYWwgZGV0YWlscycgd2lsbCBiZSBqdXN0IGEgXG4gICAgICAgICAgICAgICAgLy8ganNvbiBmb3JtYXR0ZWQgb2YgdGhlIHNhbWUgZGlzcGxheWVkIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW9yZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgaW5pdGlhbGx5LCByZS1lbmFibGVkIG9ubHkgaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGFuIHRoZSBvbmVzIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgaGFzTW9yZUluZm8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VQcm9wZXJ0aWVzTGlzdCA9IFsnbmFtZScsICdlcnJvck1lc3NhZ2UnLCAnbWVzc2FnZScsICdlcnJvcnMnXTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXJyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VQcm9wZXJ0aWVzTGlzdC5pbmRleE9mKGtleSkgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc01vcmVJbmZvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01vcmVJbmZvKVxuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJ1xcblxcblRlY2huaWNhbCBkZXRhaWxzOiAnICsganNlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1wb3NzaWJsZSB0byBzdHJpbmdpZnkgSlNPTiBlcnJvcicsIGVyciwgZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1zZyB8fCBkZWZhdWx0VGV4dDtcbiAgICB9XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeUVycm9yc0xpc3QgPSBmdW5jdGlvbiAoZXJyb3JzKSB7XG4gICAgdmFyIG1zZyA9ICcnO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9ycykpIHtcbiAgICAgICAgbXNnID0gZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbXNnID0gT2JqZWN0LmtleXMoZXJyb3JzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzW2tleV0uam9pbignXFxuJyk7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICByZXR1cm4gbXNnO1xufTtcblxuLyoqXG4gICAgU2hvdyBhbiBlcnJvciBtb2RhbCB0byBub3RpZnkgdGhlIHVzZXIuXG4gICAgQHBhcmFtIG9wdGlvbnM6T2JqZWN0IHtcbiAgICAgICAgbWVzc2FnZTpzdHJpbmcgREVQUkVDQVRFRC4gT3B0aW9uYWwuIEluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGVycm9yOnN0cmluZyBPcHRpb25hbC4gRXJyb3IvRXhjZXB0aW9uL1hIUiBvYmplY3QsIHVzZWQgdG8gYXV0b1xuICAgICAgICAgICAgZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UuIEl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciAnbWVzc2FnZSdcbiAgICAgICAgICAgIG9wdGlvbiwgZGlzY2FyZGluZyBhbiBlcnJvciBvYmplY3Qvc3RyaW5nIGlzIHBhc3NlZC5cbiAgICAgICAgICAgIEl0IHJlcGxhY2VzICdtZXNzYWdlJyBzaW5jZSBjYW4gZG8gdGhlIHNhbWUgYW5kIG1vcmUuXG4gICAgICAgIHRpdGxlOnN0cmluZyBPcHRpb25hbC4gVGhlIHRleHQgdG8gc2hvdyBpbiB0aGUgbW9kYWwncyBoZWFkZXIsXG4gICAgICAgICAgICB3aXRoIGZhbGxiYWNrIHRvIHRoZSBNb2RhbCdzIGRlZmF1bHQgdGl0bGUuXG4gICAgfVxuICAgIEByZXR1cm5zIFByb21pc2UuIEl0IHJlc29sdmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRpc21pc3NlZC9jbG9zZWQuXG4gICAgTm8gZm9ybWFsIHJlamVjdGlvbiBoYXBwZW5zLlxuKiovXG5leHBvcnRzLnNob3dFcnJvciA9IGZ1bmN0aW9uIHNob3dFcnJvck1vZGFsKG9wdGlvbnMpIHtcbiAgICBcbiAgICB2YXIgbW9kYWwgPSAkKCcjZXJyb3JNb2RhbCcpLFxuICAgICAgICBoZWFkZXIgPSBtb2RhbC5maW5kKCcjZXJyb3JNb2RhbC1sYWJlbCcpLFxuICAgICAgICBib2R5ID0gbW9kYWwuZmluZCgnI2Vycm9yTW9kYWwtYm9keScpO1xuICAgIFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIGVycm9yIG1lc3NhZ2VcbiAgICB2YXIgbXNnID0gYm9keS5kYXRhKCdkZWZhdWx0LXRleHQnKTtcblxuICAgIC8vIEVycm9yIG1lc3NhZ2UgZnJvbSBnaXZlbiBlcnJvciBvYmplY3QsIHdpdGggZmFsbGJhY2sgdG8gZGVmYXVsdCBvbmUuXG4gICAgLy8gREVQUkVDQVRFRCB0ZW1wb3Jhcmx5IHVzaW5nIHRoZSAnbWVzc2FnZScgb3B0aW9uLlxuICAgIG1zZyA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlRnJvbShvcHRpb25zLmVycm9yIHx8IG9wdGlvbnMubWVzc2FnZSwgbXNnKTtcblxuICAgIGJvZHkubXVsdGlsaW5lKG1zZyk7XG5cbiAgICBoZWFkZXIudGV4dChvcHRpb25zLnRpdGxlIHx8IGhlYWRlci5kYXRhKCdkZWZhdWx0LXRleHQnKSk7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgbW9kYWwubW9kYWwoJ3Nob3cnKTtcbiAgICAgICAgbW9kYWwub24oJ2hpZGUuYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAgICBTaG93IGNvbmZpcm1hdGlvbiBtb2RhbCB3aXRoIHR3byBidXR0b25zLlxuICAgIEBwYXJhbSBvcHRpb25zOm9iamVjdCB7XG4gICAgICAgIHRpdGxlOnN0cmluZyBIZWFkZXIgdGl0bGUgdGV4dFxuICAgICAgICBtZXNzYWdlOnN0cmluZyBNZXNzYWdlIHRleHRcbiAgICAgICAgeWVzOnN0cmluZyBZZXMgYnV0dG9uIGxhYmVsXG4gICAgICAgIG5vOnN0cmluZyBObyBidXR0b24gbGFiZWxcbiAgICB9XG4gICAgQHJldHVybnMgUHJvbWlzZS4gSXQgcmVzb2x2ZXMgaWYgYnV0dG9uICd5ZXMnIHByZXNzZWRcbiAgICBhbmQgcmVqZWN0IG9uIGJ1dHRvbiAnbm8nIHByZXNzZWQgb3IgbW9kYWwgZGlzbWlzc2VkL2Nsb3NlZC5cbioqL1xuZXhwb3J0cy5jb25maXJtID0gZnVuY3Rpb24gY29uZmlybShvcHRpb25zKSB7XG4gICAgXG4gICAgdmFyIG1vZGFsID0gJCgnI2NvbmZpcm1Nb2RhbCcpLFxuICAgICAgICBoZWFkZXIgPSBtb2RhbC5maW5kKCcjY29uZmlybU1vZGFsLWxhYmVsJyksXG4gICAgICAgIGJvZHkgPSBtb2RhbC5maW5kKCcjY29uZmlybU1vZGFsLWJvZHknKSxcbiAgICAgICAgeWVzQnRuID0gbW9kYWwuZmluZCgnI2NvbmZpcm1Nb2RhbC15ZXNCdG4nKSxcbiAgICAgICAgbm9CdG4gPSBtb2RhbC5maW5kKCcjY29uZmlybU1vZGFsLW5vQnRuJyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEZhbGxiYWNrIGVycm9yIG1lc3NhZ2VcbiAgICB2YXIgdGl0bGUgPSBoZWFkZXIuZGF0YSgnZGVmYXVsdC10ZXh0JyksXG4gICAgICAgIG1zZyA9IGJvZHkuZGF0YSgnZGVmYXVsdC10ZXh0JyksXG4gICAgICAgIHllcyA9IHllc0J0bi5kYXRhKCdkZWZhdWx0LXRleHQnKSxcbiAgICAgICAgbm8gPSBub0J0bi5kYXRhKCdkZWZhdWx0LXRleHQnKTtcblxuICAgIGJvZHkubXVsdGlsaW5lKG9wdGlvbnMubWVzc2FnZSB8fCBtc2cpO1xuICAgIGhlYWRlci50ZXh0KG9wdGlvbnMudGl0bGUgfHwgdGl0bGUpO1xuICAgIHllc0J0bi50ZXh0KG9wdGlvbnMueWVzIHx8IHllcyk7XG4gICAgbm9CdG4udGV4dChvcHRpb25zLm5vIHx8IG5vKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbW9kYWwubW9kYWwoJ3Nob3cnKTtcbiAgICAgICAgeWVzQnRuLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9CdG4ub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZGFsLm9uKCdoaWRlLmJzLm1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAgICBTaG93IGFuIGluZm9ybWF0aW9uIG1vZGFsIHRvIG5vdGlmeSB0aGUgdXNlciBhYm91dCBzb21ldGhpbmcuXG4gICAgQHBhcmFtIG9wdGlvbnM6T2JqZWN0IHtcbiAgICAgICAgbWVzc2FnZTpzdHJpbmcuIEluZm9ybWF0aXZlIG1lc3NhZ2UuXG4gICAgICAgIHRpdGxlOnN0cmluZyBPcHRpb25hbC4gVGhlIHRleHQgdG8gc2hvdyBpbiB0aGUgbW9kYWwncyBoZWFkZXIsXG4gICAgICAgICAgICB3aXRoIGZhbGxiYWNrIHRvIHRoZSBNb2RhbCdzIGRlZmF1bHQgdGl0bGUuXG4gICAgfVxuICAgIEByZXR1cm5zIFByb21pc2UuIEl0IHJlc29sdmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRpc21pc3NlZC9jbG9zZWQuXG4gICAgTm8gZm9ybWFsIHJlamVjdGlvbiBoYXBwZW5zLlxuKiovXG5leHBvcnRzLnNob3dOb3RpZmljYXRpb24gPSBmdW5jdGlvbiBzaG93Tm90aWZpY2F0aW9uKG9wdGlvbnMpIHtcbiAgICBcbiAgICB2YXIgbW9kYWwgPSAkKCcjbm90aWZpY2F0aW9uTW9kYWwnKSxcbiAgICAgICAgaGVhZGVyID0gbW9kYWwuZmluZCgnI25vdGlmaWNhdGlvbk1vZGFsLWxhYmVsJyksXG4gICAgICAgIGJ1dHRvbiA9IG1vZGFsLmZpbmQoJyNub3RpZmljYXRpb25Nb2RhbC1idXR0b24nKSxcbiAgICAgICAgYm9keSA9IG1vZGFsLmZpbmQoJyNub3RpZmljYXRpb25Nb2RhbC1ib2R5Jyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBcbiAgICAvLyBGYWxsYmFjayBtZXNzYWdlXG4gICAgdmFyIG1zZyA9IG9wdGlvbnMubWVzc2FnZSB8fCBib2R5LmRhdGEoJ2RlZmF1bHQtdGV4dCcpO1xuXG4gICAgYm9keS5tdWx0aWxpbmUobXNnKTtcblxuICAgIGhlYWRlci50ZXh0KG9wdGlvbnMudGl0bGUgfHwgaGVhZGVyLmRhdGEoJ2RlZmF1bHQtdGV4dCcpKTtcbiAgICBidXR0b24udGV4dChvcHRpb25zLmJ1dHRvblRleHQgfHwgYnV0dG9uLmRhdGEoJ2RlZmF1bHQtdGV4dCcpKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBtb2RhbC5tb2RhbCgnc2hvdycpO1xuICAgICAgICBtb2RhbC5vbignaGlkZS5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydHMuc2hvd1RpbWVQaWNrZXIgPSByZXF1aXJlKCcuL21vZGFscy90aW1lUGlja2VyJykuc2hvdztcblxuZXhwb3J0cy5zaG93VGV4dEVkaXRvciA9IHJlcXVpcmUoJy4vbW9kYWxzL3RleHRFZGl0b3InKS5zaG93O1xuIiwiLyoqXG4gICAgU2V0dXAgb2YgdGhlIHNoZWxsIG9iamVjdCB1c2VkIGJ5IHRoZSBhcHBcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcblxuLy92YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vYXBwLXNoZWxsLWhpc3RvcnknKS5jcmVhdGUoYmFzZVVybCk7XG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vdXRpbHMvc2hlbGwvaGFzaGJhbmdIaXN0b3J5Jyk7XG5cbi8vIFNoZWxsIGRlcGVuZGVuY2llc1xudmFyIHNoZWxsID0gcmVxdWlyZSgnLi91dGlscy9zaGVsbC9pbmRleCcpLFxuICAgIFNoZWxsID0gc2hlbGwuU2hlbGwsXG4gICAgRG9tSXRlbXNNYW5hZ2VyID0gc2hlbGwuRG9tSXRlbXNNYW5hZ2VyO1xuXG4vL3ZhciBpT1MgPSAvKGlQYWR8aVBob25lfGlQb2QpL2cudGVzdCggbmF2aWdhdG9yLnVzZXJBZ2VudCApO1xuXG4vLyBDcmVhdGluZyB0aGUgc2hlbGw6XG52YXIgc2hlbGwgPSBuZXcgU2hlbGwoe1xuXG4gICAgLy8gU2VsZWN0b3IsIERPTSBlbGVtZW50IG9yIGpRdWVyeSBvYmplY3QgcG9pbnRpbmdcbiAgICAvLyB0aGUgcm9vdCBvciBjb250YWluZXIgZm9yIHRoZSBzaGVsbCBpdGVtc1xuICAgIHJvb3Q6ICdBcHAtYWN0aXZpdGllcycsIC8vJ2JvZHknLFxuXG4gICAgLy8gSWYgaXMgbm90IGluIHRoZSBzaXRlIHJvb3QsIHRoZSBiYXNlIFVSTCBpcyByZXF1aXJlZDpcbiAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgIFxuICAgIGZvcmNlSGFzaGJhbmc6IHRydWUsXG5cbiAgICBpbmRleE5hbWU6ICdpbmRleCcsXG5cbiAgICBsaW5rRXZlbnQ6ICdjbGljaycsXG5cbiAgICAvLyBObyBuZWVkIGZvciBsb2FkZXIsIGV2ZXJ5dGhpbmcgY29tZXMgYnVuZGxlZFxuICAgIGxvYWRlcjogbnVsbCxcblxuICAgIC8vIEhpc3RvcnkgUG9seWZpbGw6XG4gICAgaGlzdG9yeTogSGlzdG9yeSxcblxuICAgIC8vIEEgRG9tSXRlbXNNYW5hZ2VyIG9yIGVxdWl2YWxlbnQgb2JqZWN0IGluc3RhbmNlIG5lZWRzIHRvXG4gICAgLy8gYmUgcHJvdmlkZWQ6XG4gICAgZG9tSXRlbXNNYW5hZ2VyOiBuZXcgRG9tSXRlbXNNYW5hZ2VyKHtcbiAgICAgICAgaWRBdHRyaWJ1dGVOYW1lOiAnZGF0YS1hY3Rpdml0eScsXG4gICAgICAgIHJvb3Q6ICcuQXBwLWFjdGl2aXRpZXMnXG4gICAgfSlcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoZWxsO1xuIiwiLyoqIFxuICAgIEFwcE1vZGVsIGV4dGVuc2lvbixcbiAgICBmb2N1c2VkIG9uIHRoZSBBY2NvdW50IHJlbGF0ZWQgQVBJczpcbiAgICAtIGxvZ2luXG4gICAgLSBsb2dvdXRcbiAgICAtIHNpZ251cFxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyk7XG5cbmV4cG9ydHMucGx1Z0luID0gZnVuY3Rpb24gKEFwcE1vZGVsKSB7XG4gICAgLyoqXG4gICAgICAgIFRyeSB0byBwZXJmb3JtIGFuIGF1dG9tYXRpYyBsb2dpbiBpZiB0aGVyZSBpcyBhIGxvY2FsXG4gICAgICAgIGNvcHkgb2YgY3JlZGVudGlhbHMgdG8gdXNlIG9uIHRoYXQsXG4gICAgICAgIGNhbGxpbmcgdGhlIGxvZ2luIG1ldGhvZCB0aGF0IHNhdmUgdGhlIHVwZGF0ZWRcbiAgICAgICAgZGF0YSBhbmQgcHJvZmlsZS5cbiAgICAqKi9cbiAgICBBcHBNb2RlbC5wcm90b3R5cGUudHJ5TG9naW4gPSBmdW5jdGlvbiB0cnlMb2dpbigpIHtcbiAgICAgICAgLy8gR2V0IHNhdmVkIGNyZWRlbnRpYWxzXG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCdjcmVkZW50aWFscycpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG9uZXMsIHRyeSB0byBsb2ctaW5cbiAgICAgICAgICAgIGlmIChjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgbG9naW4gd2l0aCB0aGF0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9naW4oXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFscy5wYXNzd29yZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2F2ZWQgY3JlZGVudGlhbHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIFBlcmZvcm1zIGEgbG9naW4gYXR0ZW1wdCB3aXRoIHRoZSBBUEkgYnkgdXNpbmdcbiAgICAgICAgdGhlIHByb3ZpZGVkIGNyZWRlbnRpYWxzLlxuICAgICoqL1xuICAgIEFwcE1vZGVsLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uIGxvZ2luKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBleHRyYSBoZWFkZXJzIHRvIGF0dGVtcHQgdGhlIGxvZ2luXG4gICAgICAgIHRoaXMucmVzdC5leHRyYUhlYWRlcnMgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3QucG9zdCgnbG9naW4nLCB7XG4gICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXG4gICAgICAgICAgICByZXR1cm5Qcm9maWxlOiB0cnVlXG4gICAgICAgIH0pLnRoZW4ocGVyZm9ybUxvY2FsTG9naW4odGhpcywgdXNlcm5hbWUsIHBhc3N3b3JkKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBQZXJmb3JtcyBhIGxvZ2luIGF0dGVtcHQgd2l0aCB0aGUgQVBJIGJ5IHVzaW5nXG4gICAgICAgIGEgRmFjZWJvb2sgYWNjZXNzVG9rZW4uXG4gICAgKiovXG4gICAgQXBwTW9kZWwucHJvdG90eXBlLmZhY2Vib29rTG9naW4gPSBmdW5jdGlvbiBmYWNlYm9va0xvZ2luKGFjY2Vzc1Rva2VuKSB7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGV4dHJhIGhlYWRlcnMgdG8gYXR0ZW1wdCB0aGUgbG9naW5cbiAgICAgICAgdGhpcy5yZXN0LmV4dHJhSGVhZGVycyA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdC5wb3N0KCdsb2dpbi9mYWNlYm9vaycsIHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBhY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIHJldHVyblByb2ZpbGU6IHRydWVcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihsb2dnZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJmb3JtTG9jYWxMb2dpbih0aGlzLCBsb2dnZWQuZW1haWwsIG51bGwpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgUGVyZm9ybXMgYSBsb2dvdXQsIHJlbW92aW5nIGNhY2hlZCBjcmVkZW50aWFsc1xuICAgICAgICBhbmQgcHJvZmlsZSBzbyB0aGUgYXBwIGNhbiBiZSBmaWxsZWQgdXAgd2l0aFxuICAgICAgICBuZXcgdXNlciBpbmZvcm1hdGlvbi5cbiAgICAgICAgSXQgY2FsbHMgdG8gdGhlIEFQSSBsb2dvdXQgY2FsbCB0b28sIHRvIHJlbW92ZVxuICAgICAgICBhbnkgc2VydmVyLXNpZGUgc2Vzc2lvbiBhbmQgbm90aWZpY2F0aW9uXG4gICAgICAgIChyZW1vdmVzIHRoZSBjb29raWUgdG9vLCBmb3IgYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgICB0aGF0IG1heSB1c2UgaXQpLlxuICAgICoqL1xuICAgIC8vIEZVVFVSRTogVE9SRVZJRVcgaWYgdGhlIC9sb2dvdXQgY2FsbCBjYW4gYmUgcmVtb3ZlZC5cbiAgICBBcHBNb2RlbC5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gbG9nb3V0KCkge1xuXG4gICAgICAgIC8vIExvY2FsIGFwcCBjbG9zZSBzZXNzaW9uXG4gICAgICAgIHRoaXMucmVzdC5leHRyYUhlYWRlcnMgPSBudWxsO1xuICAgICAgICBsb2NhbGZvcmFnZS5yZW1vdmVJdGVtKCdjcmVkZW50aWFscycpO1xuICAgICAgICBsb2NhbGZvcmFnZS5yZW1vdmVJdGVtKCdwcm9maWxlJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2NhbCBkYXRhIGNsZWFuLXVwIVxuICAgICAgICB0aGlzLmNsZWFyTG9jYWxEYXRhKCk7XG5cbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3YWl0IHRoZSByZXN1bHQgb2YgdGhlIFJFU1Qgb3BlcmF0aW9uXG4gICAgICAgIHRoaXMucmVzdC5wb3N0KCdsb2dvdXQnKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBBdHRlbXB0cyB0byBjcmVhdGUgYSB1c2VyIGFjY291bnQsIGdldHRpbmcgbG9nZ2VkXG4gICAgICAgIGlmIHN1Y2Nlc3NmdWxseSBsaWtlIHdoZW4gZG9pbmcgYSBsb2dpbiBjYWxsLlxuICAgICoqL1xuICAgIEFwcE1vZGVsLnByb3RvdHlwZS5zaWdudXAgPSBmdW5jdGlvbiBzaWdudXAoZGF0YSkge1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBleHRyYSBoZWFkZXJzIHRvIGF0dGVtcHQgdGhlIHNpZ251cFxuICAgICAgICB0aGlzLnJlc3QuZXh0cmFIZWFkcmVzID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIGRhdGEucmV0dXJuUHJvZmlsZSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyB0aGUgc2FtZSBhcyBpbiBhIGxvZ2luLCBhbmRcbiAgICAgICAgLy8gd2UgZG8gdGhlIHNhbWUgYXMgdGhlcmUgdG8gZ2V0IHRoZSB1c2VyIGxvZ2dlZFxuICAgICAgICAvLyBvbiB0aGUgYXBwIG9uIHNpZ24tdXAgc3VjY2Vzcy5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdC5wb3N0KCdzaWdudXA/dXRtX3NvdXJjZT1hcHAnLCBkYXRhKVxuICAgICAgICAudGhlbihwZXJmb3JtTG9jYWxMb2dpbih0aGlzLCBkYXRhLmVtYWlsLCBkYXRhLnBhc3N3b3JkKSk7XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIHBlcmZvcm1Mb2NhbExvZ2luKHRoaXNBcHBNb2RlbCwgdXNlcm5hbWUsIHBhc3N3b3JkKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obG9nZ2VkKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYW55IHByZXZpb3VzIGxvY2FsIGRhdGEgaWYgYW55OlxuICAgICAgICByZXR1cm4gdGhpc0FwcE1vZGVsLmNsZWFyTG9jYWxEYXRhKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8vIHVzZSBhdXRob3JpemF0aW9uIGtleSBmb3IgZWFjaFxuICAgICAgICAgICAgLy8gbmV3IFJlc3QgcmVxdWVzdFxuICAgICAgICAgICAgdGhpc0FwcE1vZGVsLnJlc3QuZXh0cmFIZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246ICdMQyBhbHU9JyArIGxvZ2dlZC51c2VySUQgKyAnLGFsaz0nICsgbG9nZ2VkLmF1dGhLZXlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGFzeW5jIGxvY2FsIHNhdmUsIGRvbid0IHdhaXRcbiAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0oJ2NyZWRlbnRpYWxzJywge1xuICAgICAgICAgICAgICAgIHVzZXJJRDogbG9nZ2VkLnVzZXJJRCxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIGF1dGhLZXk6IGxvZ2dlZC5hdXRoS2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogTG9jYWwgbmFtZSBrZXB0IGluIHN5bmMgd2l0aCBzZXQtdXAgYXQgQXBwTW9kZWwudXNlclByb2ZpbGVcbiAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0oJ3Byb2ZpbGUnLCBsb2dnZWQucHJvZmlsZSk7XG5cbiAgICAgICAgICAgIC8vIFNldCB1c2VyIGRhdGFcbiAgICAgICAgICAgIHRoaXNBcHBNb2RlbC51c2VyKCkubW9kZWwudXBkYXRlV2l0aChsb2dnZWQucHJvZmlsZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2dnZWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4iLCIvKipcbiAgICBJdCB1c2VzIHRoZSBzZXJ2ZXItc2lkZSBhdmFpbGFiaWxpdHkgQVBJLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuLi91dGlscy9DYWNoZUNvbnRyb2wnKSxcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG4gICAgXG4gICAgZnVuY3Rpb24gQXBpKCkge1xuICAgICAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMzApO1xuICAgIH1cbiAgICBBcGkuX2luaGVyaXRzKEV2ZW50RW1pdHRlcik7XG4gICAgXG4gICAgdmFyIGFwaSA9IG5ldyBBcGkoKTtcbiAgICBcbiAgICB2YXIgY2FjaGUgPSB7XG4gICAgICAgIHRpbWVzOiB7LypcbiAgICAgICAgICAgIFwidXNlcklELXN0YXJ0VGltZS1lbmRUaW1lXCI6IHtcbiAgICAgICAgICAgICAgICAvLyBGcm9tIHNlcnZlcjpcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRzU2l6ZUluTWludXRlczogMTUsXG4gICAgICAgICAgICAgICAgdGltZXM6IFt7c3RhcnRUaW1lOmlzb2RhdGV0aW1lLCBlbmRUaW1lOmlzb2RhdGV0aW1lLCBhdmFpbGFiaWxpdHk6c3RyaW5nXSxcbiAgICAgICAgICAgICAgICBjb250cm9sOiBuZXcgQ2FjaGVDb250cm9sKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi99XG4gICAgfTtcbiAgICBcbiAgICBhcGkuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgICAgIGNhY2hlLnRpbWVzID0ge307XG4gICAgICAgIHRoaXMuZW1pdCgnY2xlYXJDYWNoZScpO1xuICAgIH07XG4gICAgXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIGNyZWF0ZVRpbWVTbG90cyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NyZWF0ZVRpbWVTbG90cycpO1xuICAgIGZ1bmN0aW9uIHNhdmVUaW1lc0luQ2FjaGUocXVlcnlLZXksIGRhdGEpIHtcbiAgICAgICAgdmFyIGMgPSBjYWNoZS50aW1lc1txdWVyeUtleV07XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICBjLnRpbWVzID0gZGF0YS50aW1lcztcbiAgICAgICAgICAgIGMuaW5jcmVtZW50c1NpemVJbk1pbnV0ZXMgPSBkYXRhLmluY3JlbWVudHNTaXplSW5NaW51dGVzO1xuICAgICAgICAgICAgYy5jb250cm9sLnRvdWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjID0gY2FjaGUudGltZXNbcXVlcnlLZXldID0ge1xuICAgICAgICAgICAgICAgIHRpbWVzOiBkYXRhLnRpbWVzLFxuICAgICAgICAgICAgICAgIGluY3JlbWVudHNTaXplSW5NaW51dGVzOiBkYXRhLmluY3JlbWVudHNTaXplSW5NaW51dGVzLFxuICAgICAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBDYWNoZUNvbnRyb2woeyB0dGw6IHsgbWludXRlczogMSB9IH0pLFxuICAgICAgICAgICAgICAgIGdldEZyZWVUaW1lU2xvdHM6IGZ1bmN0aW9uKGR1cmF0aW9uLCBzbG90U2l6ZU1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBzbG90U2l6ZU1pbnV0ZXMgfHwgdGhpcy5pbmNyZW1lbnRzU2l6ZUluTWludXRlcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVTbG90cy5mb3JMaXN0KHRoaXMudGltZXMsIHNpemUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGFwaS50aW1lcyA9IGZ1bmN0aW9uIHRpbWVzKHVzZXJJRCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIWVuZCkgZW5kID0gbW9tZW50KHN0YXJ0KS5hZGQoMSwgJ2RheScpLnRvRGF0ZSgpO1xuICAgICAgICB2YXIgcXVlcnlLZXkgPSB1c2VySUQgKyAnLScgKyBzdGFydC50b0lTT1N0cmluZygpICsgJy0nICsgZW5kLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGNhY2hlLnRpbWVzLmhhc093blByb3BlcnR5KHF1ZXJ5S2V5KSAmJlxuICAgICAgICAgICAgIWNhY2hlLnRpbWVzW3F1ZXJ5S2V5XS5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGUudGltZXNbcXVlcnlLZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbW90ZSBsb2FkaW5nIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgndXNlcnMvJyArIHVzZXJJRCArICcvYXZhaWxhYmlsaXR5L3RpbWVzJywge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBSRVNUIEFQSSBpcyBub3QgZW5zdXJpbmcgcmVzdWx0c2V0cyBPTkxZIGluIHRoZSBzdGFydC1lbmRcbiAgICAgICAgICAgICAgICAvLyBkYXRlcywgYnV0IG9uIGFsbCBjb21wbGV0ZSBhdmFpbGFiaWxpdHlSYW5nZXMgdGhhdCB0b3VjaGVzIHRoYXQgY3JpdGVyaWEuXG4gICAgICAgICAgICAgICAgLy8gU086IEVuc3VyZSBvbmx5IHRoZSB3YW50ZWQgc2V0IG9mIGRhdGEgaXMgc2F2ZWRcbiAgICAgICAgICAgICAgICBkYXRhLnRpbWVzID0gY3JlYXRlVGltZVNsb3RzLmZpbHRlckxpc3RCeShkYXRhLnRpbWVzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGFuZCByZXR1cm46XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhdmVUaW1lc0luQ2FjaGUocXVlcnlLZXksIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG4iLCIvKiogQm9va2luZ3NcblxuICAgIElNUE9SVEFOVCEhIFNvbWUgQVBJcyBoZXJlIGFyZSBpbnRlbnRlZCBmb3IgdXNlIHRocm91Z2ggYXBwTW9kZWwuY2FsZW5kYXIgKGl0IGhhcyBjYWNoZSBhbmQgbW9yZSlcbiAgICBhbmQgbm90IGRpcmVjdGx5IGJ5IHRoZSBhcHAuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEJvb2tpbmcgPSByZXF1aXJlKCcuLi9tb2RlbHMvQm9va2luZycpLFxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgcmVzdDogYXBwTW9kZWwucmVzdCxcbiAgICAgICAgICAgIGdldEJvb2tpbmdzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtZS9ib29raW5ncycsIGZpbHRlcnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmF3SXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd0l0ZW1zICYmIHJhd0l0ZW1zLm1hcChmdW5jdGlvbihyYXdJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2tpbmcocmF3SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFwaS5nZXRCb29raW5nc0J5RGF0ZXMgPSBmdW5jdGlvbiBnZXRCb29raW5nc0J5RGF0ZXMoZGF0ZSwgZW5kKSB7XG4gICAgICAgIFxuICAgICAgICBlbmQgPSBlbmQgfHwgbW9tZW50KGRhdGUpLmNsb25lKCkuYWRkKDEsICdkYXlzJykudG9EYXRlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdGUgbG9hZGluZyBkYXRhXG4gICAgICAgIHJldHVybiBhcGkucmVtb3RlLmdldEJvb2tpbmdzKHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlLFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihib29raW5ncykge1xuICAgICAgICAgICAgLy8gUHV0IGluIGNhY2hlICh0aGV5IGFyZSBhbHJlYWR5IG1vZGVsIGluc3RhbmNlcylcbiAgICAgICAgICAgIHZhciBhcnIgPSBrby5vYnNlcnZhYmxlQXJyYXkoYm9va2luZ3MpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBvYnNlcnZhYmxlIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBHZXQgdXBjb21pbmcgYm9va2luZ3MgbWV0YS1pbmZvcm1hdGlvbiBmb3IgZGFzaGJvYXJkIHBhZ2VcbiAgICAqKi9cbiAgICBhcGkuZ2V0VXBjb21pbmdCb29raW5ncyA9IGZ1bmN0aW9uIGdldFVwY29taW5nQm9va2luZ3MoKSB7XG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnbWUvdXBjb21pbmctYm9va2luZ3MnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIEdldCBhIHNwZWNpZmljIGJvb2tpbmcgYnkgSURcbiAgICAqKi9cbiAgICBhcGkuZ2V0Qm9va2luZyA9IGZ1bmN0aW9uIGdldEJvb2tpbmcoaWQpIHtcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuIFByb21pc2UucmVqZWN0KCdUaGUgYm9va2luZ0lEIGlzIHJlcXVpcmVkIHRvIGdldCBhIGJvb2tpbmcnKTtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtZS9ib29raW5ncy8nICsgaWQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGJvb2tpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9va2luZyhib29raW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgQ29udmVydHMgYW4gQXBwb2ludG1lbnQgbW9kZWwgaW50byBhIHNpbXBsaWZpZWRcbiAgICAgICAgYm9va2luZyBwbGFpbiBvYmplY3QsIHN1aXRhYmxlIHRvIFJFU1QgQVBJIGZvciBlZGl0aW9uXG4gICAgKiovXG4gICAgYXBpLmFwcG9pbnRtZW50VG9TaW1wbGlmaWVkQm9va2luZyA9IGZ1bmN0aW9uKGFwdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYm9va2luZ0lEOiBhcHQuc291cmNlQm9va2luZygpLmJvb2tpbmdJRCgpLFxuICAgICAgICAgICAgam9iVGl0bGVJRDogYXB0LmpvYlRpdGxlSUQoKSxcbiAgICAgICAgICAgIGNsaWVudFVzZXJJRDogYXB0LmNsaWVudFVzZXJJRCgpLFxuICAgICAgICAgICAgYWRkcmVzc0lEOiBhcHQuYWRkcmVzc0lEKCksXG4gICAgICAgICAgICBzdGFydFRpbWU6IGFwdC5zdGFydFRpbWUoKSxcbiAgICAgICAgICAgIHByaWNpbmc6IGFwdC5wcmljaW5nKCkubWFwKGZ1bmN0aW9uKHByaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBmb3Igbm93LCB0aGUgUkVTVCBBUEkgYWxsb3cgb25seSBhIGxpc3Qgb2YgSURzLFxuICAgICAgICAgICAgICAgIC8vIG5vdCBvYmplY3RzLCBzbyBuZXh0IGxpbmUgaXMgcmVwbGFjZWQ6XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gcHJpY2luZy5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmljaW5nLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJlTm90ZXNUb0NsaWVudDogYXB0LnByZU5vdGVzVG9DbGllbnQoKSxcbiAgICAgICAgICAgIHByZU5vdGVzVG9TZWxmOiBhcHQucHJlTm90ZXNUb1NlbGYoKSxcbiAgICAgICAgICAgIHBvc3ROb3Rlc1RvQ2xpZW50OiBhcHQucG9zdE5vdGVzVG9DbGllbnQoKSxcbiAgICAgICAgICAgIHBvc3ROb3Rlc1RvU2VsZjogYXB0LnBvc3ROb3Rlc1RvU2VsZigpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAgQ29udmVyc3QgYSBCb29raW5nIG1vZGVsIGludG8gYSBzaW1wbGlmaWVkXG4gICAgICAgIGJvb2tpbmcgcGxhaW4gb2JqZWN0LCBzdWl0YWJsZSB0byBSRVNUIEFQSSBmb3IgZWRpdGlvblxuICAgICAgICBcbiAgICAgICAgT05MWSBGT1IgU0VSVklDRS1QUk9GRVNTSU9OQUwtQk9PS0lOR1NcbiAgICAqKi9cbiAgICBhcGkuYm9va2luZ1RvU2ltcGxpZmllZEJvb2tpbmcgPSBmdW5jdGlvbihib29raW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdERUJVRyB0byBzaW1wbGlmaWVkIGJvb2tpbmcnLCBib29raW5nLnByaWNpbmdTdW1tYXJ5KCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYm9va2luZ0lEOiBib29raW5nKCkuYm9va2luZ0lEKCksXG4gICAgICAgICAgICBjbGllbnRVc2VySUQ6IGJvb2tpbmcuY2xpZW50VXNlcklEKCksXG4gICAgICAgICAgICBhZGRyZXNzSUQ6IGJvb2tpbmcuYWRkcmVzc0lEKCksXG4gICAgICAgICAgICBzdGFydFRpbWU6IGJvb2tpbmcuc3RhcnRUaW1lKCksXG4gICAgICAgICAgICBwcmljaW5nOiBib29raW5nLnByaWNpbmdTdW1tYXJ5KCkgJiYgYm9va2luZy5wcmljaW5nU3VtbWFyeSgpLmRldGFpbHMoKS5wcmljaW5nXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHByaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBmb3Igbm93LCB0aGUgUkVTVCBBUEkgYWxsb3cgb25seSBhIGxpc3Qgb2YgSURzLFxuICAgICAgICAgICAgICAgIC8vIG5vdCBvYmplY3RzLCBzbyBuZXh0IGxpbmUgaXMgcmVwbGFjZWQ6XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gcHJpY2luZy5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmljaW5nLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJlTm90ZXNUb0NsaWVudDogYm9va2luZy5wcmVOb3Rlc1RvQ2xpZW50KCksXG4gICAgICAgICAgICBwcmVOb3Rlc1RvU2VsZjogYm9va2luZy5wcmVOb3Rlc1RvU2VsZigpLFxuICAgICAgICAgICAgcG9zdE5vdGVzVG9DbGllbnQ6IGJvb2tpbmcucG9zdE5vdGVzVG9DbGllbnQoKSxcbiAgICAgICAgICAgIHBvc3ROb3Rlc1RvU2VsZjogYm9va2luZy5wb3N0Tm90ZXNUb1NlbGYoKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICAgIENyZWF0ZXMvdXBkYXRlcyBhIGJvb2tpbmcgYnkgYSBzZXJ2aWNlIHByb2Zlc3Npb25hbCwgZ2l2ZW4gYSBzaW1wbGlmaWVkIGJvb2tpbmdcbiAgICAgICAgb2JqZWN0IG9yIGFuIEFwcG9pbnRtZW50IG1vZGVsIG9yIGEgQm9va2luZyBtb2RlbFxuICAgICoqL1xuICAgIGFwaS5zZXRTZXJ2aWNlUHJvZmVzc2lvbmFsQm9va2luZyA9IGZ1bmN0aW9uIHNldFNlcnZpY2VQcm9mZXNzaW9uYWxCb29raW5nKGJvb2tpbmcsIGFsbG93Qm9va1VuYXZhaWxhYmxlVGltZSkgeyAgICBcbiAgICAgICAgYm9va2luZyA9IGJvb2tpbmcuYm9va2luZ0lEID9cbiAgICAgICAgICAgIGFwaS5ib29raW5nVG9TaW1wbGlmaWVkQm9va2luZyhib29raW5nKSA6XG4gICAgICAgICAgICBib29raW5nLnNvdXJjZUJvb2tpbmcgP1xuICAgICAgICAgICAgICAgIGFwaS5hcHBvaW50bWVudFRvU2ltcGxpZmllZEJvb2tpbmcoYm9va2luZykgOlxuICAgICAgICAgICAgICAgIGJvb2tpbmdcbiAgICAgICAgO1xuXG4gICAgICAgIHZhciBpZCA9IGJvb2tpbmcuYm9va2luZ0lEIHx8ICcnLFxuICAgICAgICAgICAgbWV0aG9kID0gaWQgPyAncHV0JyA6ICdwb3N0JztcbiAgICAgICAgXG4gICAgICAgIGJvb2tpbmcuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lID0gYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lIHx8IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0W21ldGhvZF0oJ21lL3NlcnZpY2UtcHJvZmVzc2lvbmFsLWJvb2tpbmcvJyArIGlkLCBib29raW5nKVxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJCb29raW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvb2tpbmcoc2VydmVyQm9va2luZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICAgIFVzaW5nIGRhdGEgdG8gY3JlYXRlIGEgYm9va2luZyBmcm9tIGEgY3JlYXRlIGNsaWVudCBib29raW5nIGZvcm0sXG4gICAgICAgIGFzOiBib29raW5nLCBiaWxsaW5nQWRkcmVzcywgcGF5bWVudE1ldGhvZCwgcmVxdWVzdE9wdGlvbnMgKHByb21vdGlvbmFsQ29kZSwgYm9va0NvZGUsIGV0Yy4pXG4gICAgICAgIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHJlcXVlc3QgZmllbGRzIHRvIHBhc3MgaW4gdG8gdGhlIFJFU1QgQVBJIGFza2luZ1xuICAgICAgICBjcmVhdGUgdGhlIGNsaWVudCBib29raW5nLlxuXG4gICAgICAgIE5PVEU6IERvIE5PVCBjb25mdXNlIHdpdGggcHJldmlvdXMgaW50ZXJuYWwgY29uY2VwdCAnYm9va2luZyByZXF1ZXN0Jy4gSXMgY2FsbGVkIGFcbiAgICAgICAgcmVxdWVzdCBiZWNhdXNlIHRoZSBmaWVsZHMgYW5kIGRhdGEgcGFzc2VkIGluIHdoZW4gY3JlYXRpbmcgYSBib29raW5nIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgZnJvbSBhIGV4aXN0ZW50IGJvb2tpbmcuXG4gICAgKiovXG4gICAgdmFyIGNyZWF0ZUNsaWVudEJvb2tpbmdSZXF1ZXN0ID0gZnVuY3Rpb24oYm9va2luZywgcmVxdWVzdE9wdGlvbnMsIHBheW1lbnRNZXRob2QpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBiaWxsaW5nQWRkcmVzcyA9IHBheW1lbnRNZXRob2QgJiYgcGF5bWVudE1ldGhvZC5iaWxsaW5nQWRkcmVzcygpO1xuICAgICAgICBwYXltZW50TWV0aG9kID0gcGF5bWVudE1ldGhvZCAmJiBwYXltZW50TWV0aG9kLm1vZGVsLnRvUGxhaW5PYmplY3QoKTtcbiAgICAgICAgaWYgKGJpbGxpbmdBZGRyZXNzKSB7XG4gICAgICAgICAgICBiaWxsaW5nQWRkcmVzcyA9IGJpbGxpbmdBZGRyZXNzLm1vZGVsLnRvUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXltZW50TWV0aG9kLmJpbGxpbmdBZGRyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxVc2VySUQ6IGJvb2tpbmcuc2VydmljZVByb2Zlc3Npb25hbFVzZXJJRCgpLFxuICAgICAgICAgICAgam9iVGl0bGVJRDogYm9va2luZy5qb2JUaXRsZUlEKCksXG4gICAgICAgICAgICBzZXJ2aWNlU3RhcnRUaW1lOiBib29raW5nLnNlcnZpY2VEYXRlKCkgJiYgYm9va2luZy5zZXJ2aWNlRGF0ZSgpLnN0YXJ0VGltZSgpLFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmUxU3RhcnRUaW1lOiBib29raW5nLmFsdGVybmF0aXZlRGF0ZTEoKSAmJiBib29raW5nLmFsdGVybmF0aXZlRGF0ZTEoKS5zdGFydFRpbWUoKSxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlMlN0YXJ0VGltZTogYm9va2luZy5hbHRlcm5hdGl2ZURhdGUyKCkgJiYgYm9va2luZy5hbHRlcm5hdGl2ZURhdGUyKCkuc3RhcnRUaW1lKCksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlcnZpY2VBZGRyZXNzOiBib29raW5nLnNlcnZpY2VBZGRyZXNzKCkgJiYgYm9va2luZy5zZXJ2aWNlQWRkcmVzcygpLm1vZGVsLnRvUGxhaW5PYmplY3QoKSxcblxuICAgICAgICAgICAgc2VydmljZXM6IGJvb2tpbmcucHJpY2luZ1N1bW1hcnkoKSAmJiBib29raW5nLnByaWNpbmdTdW1tYXJ5KCkuZGV0YWlscygpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHByaWNpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpY2luZy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYm9va0NvZGU6IGtvLnVud3JhcChyZXF1ZXN0T3B0aW9ucy5ib29rQ29kZSksXG4gICAgICAgICAgICBwcm9tb3Rpb25hbENvZGU6IGtvLnVud3JhcChyZXF1ZXN0T3B0aW9ucy5wcm9tb3Rpb25hbENvZGUpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBPbmx5IGEgZ3JvdXAgb2YgZmllbGRzIGZyb20gYSBzdGFuZGFyZCBhZGRyZXNzIG9iamVjdCBhcmUgcmVhZCBieSB0aGUgc2VydmVyOlxuICAgICAgICAgICAgYmlsbGluZ0FkZHJlc3M6IGJpbGxpbmdBZGRyZXNzICYmIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzTGluZTE6IGJpbGxpbmdBZGRyZXNzLmFkZHJlc3NMaW5lMSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzTGluZTI6IGJpbGxpbmdBZGRyZXNzLmFkZHJlc3NMaW5lMixcbiAgICAgICAgICAgICAgICBwb3N0YWxDb2RlOiBiaWxsaW5nQWRkcmVzcy5wb3N0YWxDb2RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXltZW50TWV0aG9kOiBwYXltZW50TWV0aG9kXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgQ3JlYXRlcyBhIGNsaWVudCBib29raW5nXG4gICAgICAgIEBwYXJhbSBib29raW5nIG1vZGVsL0Jvb2tpbmdcbiAgICAgICAgQHBhcmFtIHJlcXVlc3RPcHRpb25zIHsgcHJvbW90aW9uYWxDb2RlLCBib29rQ29kZSB9XG4gICAgKiovXG4gICAgYXBpLnJlcXVlc3RDbGllbnRCb29raW5nID0gZnVuY3Rpb24gcmVxdWV0c0NsaWVudEJvb2tpbmcoYm9va2luZywgcmVxdWVzdE9wdGlvbnMsIGJpbGxpbmdBZGRyZXNzLCBwYXltZW50TWV0aG9kKSB7XG4gICAgICAgIHZhciBkYXRhID0gY3JlYXRlQ2xpZW50Qm9va2luZ1JlcXVlc3QoYm9va2luZywgcmVxdWVzdE9wdGlvbnMsIGJpbGxpbmdBZGRyZXNzLCBwYXltZW50TWV0aG9kKTtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucG9zdCgnbWUvY2xpZW50LWJvb2tpbmcnLCBkYXRhKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBBc2sgZm9yIGluaXRpYWxpemF0aW9uIGRhdGEgb2YgYSBuZXcgY2xpZW50IGJvb2tpbmdcbiAgICAgICAgXG4gICAgICAgIEBwYXJhbSBvcHRpb25zIHtcbiAgICAgICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxVc2VySUQ6aW50LFxuICAgICAgICAgICAgam9iVGl0bGVJRDppbnQsXG4gICAgICAgICAgICBib29rQ29kZTpzdHJpbmcgW09wdGlvbmFsXVxuICAgICAgICB9XG4gICAgKiovXG4gICAgYXBpLmdldE5ld0NsaWVudEJvb2tpbmcgPSBmdW5jdGlvbiBnZXROZXdDbGllbnRCb29raW5nKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtZS9jbGllbnQtYm9va2luZycsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xufTtcbiIsIi8qKlxuICAgIEl0IG9mZmVycyBhY2Nlc3MgdG8gY2FsZW5kYXIgZWxlbWVudHMgKGFwcG9pbnRtZW50cykgYW5kIGF2YWlsYWJpbGl0eVxuICAgIFxuICAgIEFwcG9pbnRtZW50cyBpcyBhbiBhYnN0cmFjdGlvbiBhcm91bmQgY2FsZW5kYXIgZXZlbnRzXG4gICAgdGhhdCBiZWhhdmUgYXMgYm9va2luZ3Mgb3IgYXMgZXZlbnRzICh3aGVyZSBib29raW5ncyBhcmUgYnVpbHRcbiAgICBvbiB0b3Agb2YgYW4gZXZlbnQgaW5zdGFuY2UgLS1hIGJvb2tpbmcgcmVjb3JkIG11c3QgaGF2ZSBldmVyIGEgc2VydmljZURhdGVJRCBldmVudCkuXG4gICAgXG4gICAgV2l0aCB0aGlzIGFwcE1vZGVsLCB0aGUgQVBJcyB0byBtYW5hZ2UgZXZlbnRzJmJvb2tpbmdzIGFyZSBjb21iaW5lZCB0byBvZmZlciByZWxhdGVkXG4gICAgcmVjb3JkcyBlYXNpZXIgaW4gQXBwb2ludG1lbnRzIG9iamVjdHMuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFwcG9pbnRtZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FwcG9pbnRtZW50JyksXG4gICAgRGF0ZUF2YWlsYWJpbGl0eSA9IHJlcXVpcmUoJy4uL21vZGVscy9EYXRlQXZhaWxhYmlsaXR5JyksXG4gICAgRGF0ZUNhY2hlID0gcmVxdWlyZSgnLi4vdXRpbHMvRGF0ZUNhY2hlJyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcblxuICAgIGZ1bmN0aW9uIEFwaSgpIHtcbiAgICAgICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDMwKTtcbiAgICB9XG4gICAgQXBpLl9pbmhlcml0cyhFdmVudEVtaXR0ZXIpO1xuICAgIFxuICAgIHZhciBhcGkgPSBuZXcgQXBpKCk7XG4gICAgXG4gICAgdmFyIGNhY2hlID0gbmV3IERhdGVDYWNoZSh7XG4gICAgICAgIE1vZGVsOiBEYXRlQXZhaWxhYmlsaXR5LFxuICAgICAgICB0dGw6IHsgbWludXRlczogMTAgfVxuICAgIH0pO1xuICAgIFxuICAgIGFwaS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjbGVhckNhY2hlJyk7XG4gICAgfTtcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAgICBHZXQgYSBnZW5lcmljIGNhbGVuZGFyIGFwcG9pbnRtZW50IG9iamVjdCwgbWFkZSBvZiBldmVudHMgYW5kL29yIGJvb2tpbmdzLFxuICAgICAgICBkZXBlbmRpbmcgb24gdGhlIGdpdmVuIElEIGluIHRoZSBpZHMgb2JqZWN0LlxuICAgICAgICBcbiAgICAgICAgVE9ETzogZ2V0cyBzaW5nbGUgYXB0IGZyb20gdGhlIERhdGVDYWNoZVxuICAgICoqL1xuICAgIGFwaS5nZXRBcHBvaW50bWVudCA9IGZ1bmN0aW9uIGdldEFwcG9pbnRtZW50KGlkcykge1xuXG4gICAgICAgIGlmIChpZHMuY2FsZW5kYXJFdmVudElEKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuZ2V0RXZlbnQoaWRzLmNhbGVuZGFyRXZlbnRJRClcbiAgICAgICAgICAgIC50aGVuKEFwcG9pbnRtZW50LmZyb21DYWxlbmRhckV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZHMuYm9va2luZ0lEKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwuYm9va2luZ3MuZ2V0Qm9va2luZyhpZHMuYm9va2luZ0lEKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYm9va2luZykge1xuICAgICAgICAgICAgICAgIC8vIEFuIGFwcG9pbnRtZW50IGZvciBib29raW5nIG5lZWRzIHRoZSBjb25maXJtZWQgZXZlbnQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuZ2V0RXZlbnQoYm9va2luZy5zZXJ2aWNlRGF0ZUlEKCkpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFwcG9pbnRtZW50LmZyb21Cb29raW5nKGJvb2tpbmcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdVbnJlY29nbml6ZWQgSUQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgYXBpLnNldEFwcG9pbnRtZW50ID0gZnVuY3Rpb24gc2V0QXBwb2ludG1lbnQoYXB0LCBhbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE86IFNhdmluZyBhcHQgbXVzdCBpbnZhbGlkYXRlIHRoZSBjYWNoZSBhbmQgZm9yY2UgZGF0ZVxuICAgICAgICAvLyBhdmFpbGFiaWxpdHkgY29tcHV0YXRpb24gd2l0aCBVSSB1cGRhdGUsIHdoZW4gc3RhcnQgdGltZSBvciBzdGFydCBlbmQgY2hhbmdlcyBcbiAgICAgICAgLy8gKGV2ZXIgd2hlbiBpbnNlcnRpbmcgYXB0KSwgZm9yIHRoZSBwcmV2aW91cyBkYXRlIGFuZCB0aGUgbmV3IG9uZSAoaWYgZGF0ZSBjaGFuZ2VkKVxuICAgICAgICAvLyBhbmQgb25seSBkYXRlIGF2YWlsYWJpbGl0eSBjb21wdXRhdGlvbiBpZiBkYXRlIGlzIHRoZSBzYW1lIGJ1dCB0aW1lIGNoYW5nZWQuXG4gICAgICAgIC8vIEFuZCB0cmlnZ2VycyBcInRoaXMuZW1pdCgnY2xlYXJDYWNoZScpO1wiIHBhc3NpbmcgYXMgcGFyYW1ldGVyIHRoZSBkYXRlcyBhcnJheSB0aGF0IG5lZWRzIHJlZnJlc2hcbiAgICAgICAgXG4gICAgICAgIC8vIElmIGlzIGEgYm9va2luZ1xuICAgICAgICBpZiAoYXB0LnNvdXJjZUJvb2tpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLmJvb2tpbmdzLnNldFNlcnZpY2VQcm9mZXNzaW9uYWxCb29raW5nKGFwdCwgYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYm9va2luZykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNsZWFyQ2FjaGUsIGVuaGFuY2UgYnkgZGlzY2FyZGluZyBvbmx5IHRoZSBjYWNoZSBmb3IgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgLy8gYW5kIG5ldyBkYXRlXG4gICAgICAgICAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRoZSBldmVudCBpbmZvcm1hdGlvbiB0b29cbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuZ2V0RXZlbnQoYm9va2luZy5zZXJ2aWNlRGF0ZUlEKCkpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFwcG9pbnRtZW50LmZyb21Cb29raW5nKGJvb2tpbmcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwdC5zb3VyY2VFdmVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuc2V0RXZlbnQoYXB0KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXBwb2ludG1lbnQuZnJvbUNhbGVuZGFyRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdVbnJlY29nbml6ZWQgYXBwb2ludG1lbnQgb2JqZWN0JykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgR2V0IGEgbGlzdCBvZiBnZW5lcmljIGNhbGVuZGFyIGFwcG9pbnRtZW50IG9iamVjdHMsIG1hZGUgb2YgZXZlbnRzIGFuZC9vciBib29raW5nc1xuICAgICAgICBieSBEYXRlLCBmcm9tIHRoZSByZW1vdGUgc291cmNlIGRpcmVjdGx5LlxuICAgICAgICBVc2VkIGludGVybmFsbHkgb25seSwgdG8gZ2V0IGFwcG9pbnRtZW50cyB3aXRoIGFuZCB3aXRob3V0IGZyZWUvdW5hdmFpbGFibGVcbiAgICAgICAgc2xvdHMgdXNlIGdldERhdGVBdmFpbGFiaWxpdHlcbiAgICAqKi9cbiAgICB2YXIgZ2V0UmVtb3RlQXBwb2ludG1lbnRzQnlEYXRlID0gZnVuY3Rpb24gZ2V0UmVtb3RlQXBwb2ludG1lbnRzQnlEYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGFwcE1vZGVsLmJvb2tpbmdzLmdldEJvb2tpbmdzQnlEYXRlcyhkYXRlKSxcbiAgICAgICAgICAgIGFwcE1vZGVsLmNhbGVuZGFyRXZlbnRzLmdldEV2ZW50c0J5RGF0ZXMoZGF0ZSlcbiAgICAgICAgXSkudGhlbihmdW5jdGlvbihncm91cCkge1xuXG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gZ3JvdXBbMV0sXG4gICAgICAgICAgICAgICAgYm9va2luZ3MgPSBncm91cFswXSxcbiAgICAgICAgICAgICAgICBhcHRzID0gW107XG5cbiAgICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXB0cyA9IEFwcG9pbnRtZW50Lmxpc3RGcm9tQ2FsZW5kYXJFdmVudHNCb29raW5ncyhldmVudHMoKSwgYm9va2luZ3MoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiBhcHRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBGZXRjaCBhcHBvaW50bWVudHMgYW5kIHNjaGVkdWxlIGluZm9ybWF0aW9uIGZvciB0aGUgZGF0ZSBmcm9tIHJlbW90ZVxuICAgICAgICBpbiBhIGNvbnZlbmllbnQgb2JqZWN0IHRvIHVzZSB3aXRoIHRoZSBEYXRlQXZhaWxhYmlsaXR5IG1vZGVsLlxuICAgICoqL1xuICAgIHZhciBnZXRSZW1vdGVEYXRlQXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24gZ2V0UmVtb3RlRGF0ZUF2YWlsYWJpbGl0eShkYXRlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBnZXRSZW1vdGVBcHBvaW50bWVudHNCeURhdGUoZGF0ZSksXG4gICAgICAgICAgICBhcHBNb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUubG9hZCgpLFxuICAgICAgICAgICAgYXBwTW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzLmxvYWQoKVxuICAgICAgICBdKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBhcHRzID0gcmVzdWx0WzBdLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gcmVzdWx0WzFdLFxuICAgICAgICAgICAgICAgIHdlZWtEYXlTY2hlZHVsZSA9IHNldHRpbmdzLndlZWtEYXlzW2RhdGUuZ2V0RGF5KCldKCksXG4gICAgICAgICAgICAgICAgcHJlZnMgPSByZXN1bHRbMl07XG5cbiAgICAgICAgICAgIHZhciBkYXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgICAgIGFwcG9pbnRtZW50c0xpc3Q6IGFwdHMgfHwgW10sXG4gICAgICAgICAgICAgICAgd2Vla0RheVNjaGVkdWxlOiB3ZWVrRGF5U2NoZWR1bGUsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGluZ1ByZWZlcmVuY2VzOiBwcmVmc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGRhdGVJbmZvO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBHZXQgdGhlIGFwcG9pbnRtZW50cyBhbmQgYXZhaWxhYmlsaXR5IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgICAgSXQgaGFzIGNhY2hlIGNvbnRyb2wsIGlmIHRoZXJlIGlzIGEgdmFsaWQgY29weSBpcyByZXR1cm5lZFxuICAgICAgICBhdCB0aGUgbW9tZW50LCBpZiBpcyByZWxvYWRlZCBhbmQgZXhpc3RzIG9uIGNhY2hlLCB0aGF0IGNvcHkgaXNcbiAgICAgICAgdXBkYXRlZCBzbyBhbGwgcHJldmlvdXMgaW5zdGFuY2VzIGdldCB0aGUgdXBkYXRlZCBkYXRhIHRvby5cbiAgICAqKi9cbiAgICBhcGkuZ2V0RGF0ZUF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGdldERhdGVBdmFpbGFiaWxpdHkoZGF0ZSkge1xuICAgICAgICBcbiAgICAgICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldFNpbmdsZShkYXRlKTtcblxuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVtb3RlRGF0ZUF2YWlsYWJpbGl0eShkYXRlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY2FjaGUgYW5kIHJldHVuIGRhdGEgYXMgY2xhc3MgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuc2V0KGRhdGUsIGRhdGVJbmZvKS5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIFxuICAgIC8vLy8vL1xuICAgIC8vIE5FVyBNVUxUSSBEQVRFUyBBUElcbiAgICBcbiAgICAvKipcbiAgICAgICAgR2V0IGEgbGlzdCBvZiBnZW5lcmljIGNhbGVuZGFyIGFwcG9pbnRtZW50IG9iamVjdHMsIG1hZGUgb2YgZXZlbnRzIGFuZC9vciBib29raW5nc1xuICAgICAgICBieSBEYXRlLCBmcm9tIHRoZSByZW1vdGUgc291cmNlIGRpcmVjdGx5LlxuICAgICAgICBVc2VkIGludGVybmFsbHkgb25seSwgdG8gZ2V0IGFwcG9pbnRtZW50cyB3aXRoIGFuZCB3aXRob3V0IGZyZWUvdW5hdmFpbGFibGVcbiAgICAgICAgc2xvdHMgdXNlIGdldERhdGVBdmFpbGFiaWxpdHlcbiAgICAqKi9cbiAgICB2YXIgZ2V0UmVtb3RlQXBwb2ludG1lbnRzQnlEYXRlcyA9IGZ1bmN0aW9uIGdldFJlbW90ZUFwcG9pbnRtZW50c0J5RGF0ZXMoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgYXBwTW9kZWwuYm9va2luZ3MuZ2V0Qm9va2luZ3NCeURhdGVzKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgYXBwTW9kZWwuY2FsZW5kYXJFdmVudHMuZ2V0RXZlbnRzQnlEYXRlcyhzdGFydCwgZW5kKVxuICAgICAgICBdKS50aGVuKGZ1bmN0aW9uKGdyb3VwKSB7XG5cbiAgICAgICAgICAgIHZhciBldmVudHMgPSBncm91cFsxXSxcbiAgICAgICAgICAgICAgICBib29raW5ncyA9IGdyb3VwWzBdLFxuICAgICAgICAgICAgICAgIGFwdHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhcHRzID0gQXBwb2ludG1lbnQubGlzdEZyb21DYWxlbmRhckV2ZW50c0Jvb2tpbmdzKGV2ZW50cygpLCBib29raW5ncygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR3JvdXAgYXB0cyBieSBkYXRlXG4gICAgICAgICAgICB2YXIgZ3JvdXBlZCA9IF8uZ3JvdXBCeShhcHRzLCBmdW5jdGlvbihhcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tZW50KGFwdC5zdGFydFRpbWUoKSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCB0aGUgZGF0ZXMgaW4gdGhlIHJhbmdlIGFyZSBmaWxsZWQsIHdpdGggZW1wdHkgYXJyYXlzIGluIHRoZSBob2xlcy5cbiAgICAgICAgICAgIC8vIE5PVEU6IHRoaXMgd2F5IG9mIGZpcnN0IGdyb3VwIGFwdHMgYW5kIHRoZW4gZmlsbCBnYXBzIG1ha2VzIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gICAgICAgICAgICAvLyB0byBkaXNwbGF5IHByb3BlcnRpZXMgb3V0IG9mIG9yZGVyIChpZiBzb21lIGhvbGUgbmVlZGVkIGJlaW5nIGZpbGxlZCBvdXQpLlxuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdGFydCk7XG4gICAgICAgICAgICB3aGlsZSAoZGF0ZSA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbW9tZW50KGRhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBlZC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICBncm91cGVkW2tleV0gPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIE5leHQgZGF0ZTpcbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICAgIEZldGNoIGFwcG9pbnRtZW50cyBhbmQgc2NoZWR1bGUgaW5mb3JtYXRpb24gZm9yIHRoZSBkYXRlcyBmcm9tIHJlbW90ZVxuICAgICAgICBpbiBhIGNvbnZlbmllbnQgb2JqZWN0IHRvIHVzZSB3aXRoIHRoZSBEYXRlQXZhaWxhYmlsaXR5IG1vZGVsXG4gICAgICAgIChyZXR1cm5zIGFuIGFycmF5IG9mIHRoZW0pLlxuICAgICoqL1xuICAgIHZhciBnZXRSZW1vdGVEYXRlc0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGdldFJlbW90ZURhdGVzQXZhaWxhYmlsaXR5KHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGdldFJlbW90ZUFwcG9pbnRtZW50c0J5RGF0ZXMoc3RhcnQsIGVuZCksXG4gICAgICAgICAgICBhcHBNb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUubG9hZCgpLFxuICAgICAgICAgICAgYXBwTW9kZWwuc2NoZWR1bGluZ1ByZWZlcmVuY2VzLmxvYWQoKVxuICAgICAgICBdKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBhcHRzRGF0ZXMgPSByZXN1bHRbMF0sXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSByZXN1bHRbMV0sXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgICAgICAgIHByZWZzID0gcmVzdWx0WzJdO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcHRzRGF0ZXMpLmZvckVhY2goZnVuY3Rpb24oZGF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gbW9tZW50KGRhdGVLZXksICdZWVlZLU1NLUREJykudG9EYXRlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHdlZWtEYXlTY2hlZHVsZSA9IHNldHRpbmdzLndlZWtEYXlzW2RhdGUuZ2V0RGF5KCldKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGFwcG9pbnRtZW50c0xpc3Q6IGFwdHNEYXRlc1tkYXRlS2V5XSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgd2Vla0RheVNjaGVkdWxlOiB3ZWVrRGF5U2NoZWR1bGUsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxpbmdQcmVmZXJlbmNlczogcHJlZnNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0c1tkYXRlS2V5XSA9IGRhdGVJbmZvO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGFwaS5nZXREYXRlc0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGdldERhdGVzQXZhaWxhYmlsaXR5KHN0YXJ0LCBlbmQpIHtcblxuICAgICAgICB2YXIgY2FjaGVSZXN1bHRzID0gY2FjaGUuZ2V0KHN0YXJ0LCBlbmQpO1xuICAgICAgICAvLyBXZSBrbm93IHdoYXQgZGF0ZXMgd2UgbmVlZCBhbmQgd2hhdCBkYXRhIGlzIGNhY2hlZCBhbHJlYWR5XG4gICAgICAgIC8vIElmIGFsbCBjYWNoZWQsIGp1c3QgcmVzb2x2ZSB0byBjYWNoZVxuICAgICAgICBpZiAoY2FjaGVSZXN1bHRzLm1pbkhvbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVSZXN1bHRzLmJ5RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJlcXVlc3QgYWxsIGRhdGVzIGluIHRoZSByYW5nZSAoZXZlbiBpZiBzb21lIGNhY2hlZCBpbiBiZXR3ZWVuKVxuICAgICAgICByZXR1cm4gZ2V0UmVtb3RlRGF0ZXNBdmFpbGFiaWxpdHkoY2FjaGVSZXN1bHRzLm1pbkhvbGUsIGNhY2hlUmVzdWx0cy5tYXhIb2xlKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyBBZGQgcmVzdWx0cyB0byBjYWNoZSwgY3JlYXRpbmcgRGF0ZUF2YWlsYWJpbGl0eSBvYmplY3RcbiAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhhdCB0byB0aGUgcmVzdWx0c2V0XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVJlc3VsdHMuYnlEYXRlW2RhdGVLZXldID0gY2FjaGUuc2V0KGRhdGVLZXksIHJlc3VsdHNbZGF0ZUtleV0pLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVJlc3VsdHMuYnlEYXRlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbiIsIi8qKiBFdmVudHNcblxuICAgIElNUE9SVEFOVCEhISEgQVBJIG5vdCB0byB1c2UgZGlyZWN0bHkgYnkgdGhlIGFwcCwgYnV0IHRocm91Z2ggYXBwTW9kZWwuY2FsZW5kYXIgKGl0IGhhcyBjYWNoZSBhbmQgbW9yZSlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsZW5kYXJFdmVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9DYWxlbmRhckV2ZW50JyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xuXG4gICAgdmFyIGFwaSA9IHtcbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICByZXN0OiBhcHBNb2RlbC5yZXN0LFxuICAgICAgICAgICAgZ2V0Q2FsZW5kYXJFdmVudHM6IGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ21lL2V2ZW50cycsIGZpbHRlcnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmF3SXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd0l0ZW1zICYmIHJhd0l0ZW1zLm1hcChmdW5jdGlvbihyYXdJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENhbGVuZGFyRXZlbnQocmF3SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFwaS5nZXRFdmVudHNCeURhdGVzID0gZnVuY3Rpb24gZ2V0RXZlbnRzQnlEYXRlcyhkYXRlLCBlbmQpIHtcbiAgICAgICAgXG4gICAgICAgIGVuZCA9IGVuZCB8fCBtb21lbnQoZGF0ZSkuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW90ZSBsb2FkaW5nIGRhdGFcbiAgICAgICAgcmV0dXJuIGFwaS5yZW1vdGUuZ2V0Q2FsZW5kYXJFdmVudHMoe1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGUsXG4gICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGV2ZW50cykge1xuXG4gICAgICAgICAgICAvLyBQdXQgaW4gYXJyYXkgKHRoZXkgYXJlIGFscmVhZHkgbW9kZWwgaW5zdGFuY2VzKVxuICAgICAgICAgICAgdmFyIGFyciA9IGtvLm9ic2VydmFibGVBcnJheShldmVudHMpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBvYnNlcnZhYmxlIGFycmF5XG4gICAgICAgICAgICAvLyBUT0RPIFJldmlldyByZWFsbHkgaWYgaGFzIHNlbnNlIHRvIGhhdmUgYW4gb2JzZXJ2YWJsZSBhcnJheSwgdGFrZSBjYXJlIG9mIGl0cyB1c2UgKG9uIGFwcG9pbnRtZW50cyBtYWlubHkpXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBHZXQgYSBzcGVjaWZpYyBldmVudCBieSBJRFxuICAgICoqL1xuICAgIGFwaS5nZXRFdmVudCA9IGZ1bmN0aW9uIGdldEV2ZW50KGlkKSB7XG4gICAgICAgIGlmICghaWQpIHJldHVybiBQcm9taXNlLnJlamVjdCgnVGhlIGNhbGVuZGFyRXZlbnRJRCBpcyByZXF1aXJlZCB0byBnZXQgYW4gZXZlbnQnKTtcblxuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ21lL2V2ZW50cy8nICsgaWQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGVuZGFyRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGFwaS5hcHBvaW50bWVudFRvU2ltcGxpZmllZEV2ZW50ID0gZnVuY3Rpb24oYXB0KSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgcnJ1bGUgPSBhcHQuc291cmNlRXZlbnQoKS5yZWN1cnJlbmNlUnVsZSgpO1xuICAgICAgICBpZiAocnJ1bGUpXG4gICAgICAgICAgICBycnVsZSA9IGFwdC5zb3VyY2VFdmVudCgpLnJlY3VycmVuY2VSdWxlKCkubW9kZWwudG9QbGFpbk9iamVjdCgpO1xuXG4gICAgICAgIHZhciBvY2NzID0gYXB0LnNvdXJjZUV2ZW50KCkucmVjdXJyZW5jZU9jY3VycmVuY2VzKCk7XG4gICAgICAgIGlmIChvY2NzKVxuICAgICAgICAgICAgb2NjcyA9IG9jY3MubWFwKGZ1bmN0aW9uKG9jYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvY2MgJiYgb2NjLm1vZGVsLnRvUGxhaW5PYmplY3QoKSB8fCBudWxsO1xuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKG9jYykgeyByZXR1cm4gb2NjICE9PSBudWxsOyB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBUaGUgc2FtZSBhcyBhcHQuc291cmNlRXZlbnQoKS5jYWxlbmRhckV2ZW50SUQoKVxuICAgICAgICAgICAgY2FsZW5kYXJFdmVudElEOiBhcHQuaWQoKSA8IDAgPyAwIDogYXB0LmlkKCksXG4gICAgICAgICAgICBldmVudFR5cGVJRDogYXB0LnNvdXJjZUV2ZW50KCkuZXZlbnRUeXBlSUQoKSxcbiAgICAgICAgICAgIHN1bW1hcnk6IGFwdC5zdW1tYXJ5KCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYXB0LmRlc2NyaXB0aW9uKCksXG4gICAgICAgICAgICBhdmFpbGFiaWxpdHlUeXBlSUQ6IGFwdC5zb3VyY2VFdmVudCgpLmF2YWlsYWJpbGl0eVR5cGVJRCgpLFxuICAgICAgICAgICAgbG9jYXRpb246IGFwdC5hZGRyZXNzU3VtbWFyeSgpLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBhcHQuc3RhcnRUaW1lKCksXG4gICAgICAgICAgICBlbmRUaW1lOiBhcHQuZW5kVGltZSgpLFxuICAgICAgICAgICAgaXNBbGxEYXk6IGFwdC5zb3VyY2VFdmVudCgpLmlzQWxsRGF5KCksXG4gICAgICAgICAgICByZWN1cnJlbmNlUnVsZTogcnJ1bGUsXG4gICAgICAgICAgICByZWN1cnJlbmNlT2NjdXJyZW5jZXM6IG9jY3NcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIENyZWF0ZXMvdXBkYXRlcyBhIGJvb2tpbmcsIGdpdmVuIGEgc2ltcGxpZmllZCBib29raW5nXG4gICAgICAgIG9iamVjdCBvciBhbiBBcHBvaW50bWVudCBtb2RlbCBvciBhIEJvb2tpbmcgbW9kZWxcbiAgICAqKi9cbiAgICBhcGkuc2V0RXZlbnQgPSBmdW5jdGlvbiBzZXRFdmVudChldmVudCkge1xuXG4gICAgICAgIGV2ZW50ID0gZXZlbnQuY2FsZW5kYXJFdmVudElEID9cbiAgICAgICAgICAgIGV2ZW50Lm1vZGVsLnRvUGxhaW5PYmplY3QoKSA6XG4gICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudCA/XG4gICAgICAgICAgICAgICAgYXBpLmFwcG9pbnRtZW50VG9TaW1wbGlmaWVkRXZlbnQoZXZlbnQpIDpcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICA7XG5cbiAgICAgICAgdmFyIGlkID0gZXZlbnQuY2FsZW5kYXJFdmVudElEIHx8ICcnLFxuICAgICAgICAgICAgbWV0aG9kID0gaWQgPyAncHV0JyA6ICdwb3N0JztcblxuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdFttZXRob2RdKCdtZS9ldmVudHMnICsgKGlkID8gJy8nIDogJycpICsgaWQsIGV2ZW50KVxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhckV2ZW50KHNlcnZlckV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuIiwiLyoqIENhbGVuZGFyIFN5bmNpbmcgYXBwIG1vZGVsXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBDYWxlbmRhclN5bmNpbmcgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ2FsZW5kYXJTeW5jaW5nJyksXG4gICAgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xuICAgICAgICBkYXRhOiBuZXcgQ2FsZW5kYXJTeW5jaW5nKCksXG4gICAgICAgIHR0bDogeyBtaW51dGVzOiAxIH0sXG4gICAgICAgIGxvY2FsU3RvcmFnZU5hbWU6ICdjYWxlbmRhclN5bmNpbmcnLFxuICAgICAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ21lL2NhbGVuZGFyLXN5bmNpbmcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnB1dCgnbWUvY2FsZW5kYXItc3luY2luZycsIHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRXh0ZW5kaW5nIHdpdGggdGhlIHNwZWNpYWwgQVBJIG1ldGhvZCAncmVzZXRFeHBvcnRVcmwnXG4gICAgcmVtLmlzUmVzZXRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICByZW0ucmVzZXRFeHBvcnRVcmwgPSBmdW5jdGlvbiByZXNldEV4cG9ydFVybCgpIHtcbiAgICAgICAgXG4gICAgICAgIHJlbS5pc1Jlc2V0aW5nKHRydWUpO1xuXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ21lL2NhbGVuZGFyLXN5bmNpbmcvcmVzZXQtZXhwb3J0LXVybCcpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHVwZGF0ZWRTeW5jU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHRoZSBjYWNoZWQgZGF0YVxuICAgICAgICAgICAgcmVtLmRhdGEubW9kZWwudXBkYXRlV2l0aCh1cGRhdGVkU3luY1NldHRpbmdzKTtcbiAgICAgICAgICAgIHJlbS5pc1Jlc2V0aW5nKGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRTeW5jU2V0dGluZ3M7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbS5jbGVhckNhY2hlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVtO1xufTtcbiIsIi8qKiBjbGllbnRzXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIENsaWVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9DbGllbnQnKTtcblxudmFyIExpc3RSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0xpc3RSZW1vdGVNb2RlbCcpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xuICAgIFxuICAgIHZhciBhcGkgPSBuZXcgTGlzdFJlbW90ZU1vZGVsKHtcbiAgICAgICAgbGlzdFR0bDogeyBtaW51dGVzOiAxIH0sXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAnY2xpZW50VXNlcklEJyxcbiAgICAgICAgTW9kZWw6IENsaWVudFxuICAgIH0pO1xuXG4gICAgYXBpLmFkZExvY2FsZm9yYWdlU3VwcG9ydCgnY2xpZW50cycpO1xuICAgIGFwaS5hZGRSZXN0U3VwcG9ydChhcHBNb2RlbC5yZXN0LCAnbWUvY2xpZW50cycpO1xuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAgICBQdWJsaWMgc2VhcmNoIG9mIHVzZXJzLCBwb3NzaWJsZSBjbGllbnRzIGJ5IHdlbGxcbiAgICAgICAga25vdyBmaWVsZHMsIHdpdGggZnVsbCB2YWx1ZSBtYXRjaC5cbiAgICAqKi9cbiAgICB2YXIgcHVibGljU2VhcmNoUmVxdWVzdCA9IG51bGw7XG4gICAgYXBpLnB1YmxpY1NlYXJjaCA9IGZ1bmN0aW9uIHB1YmxpY1NlYXJjaChzZWFyY2gpIHtcblxuICAgICAgICAvLyBPbmx5IG9uZSByZXF1ZXN0IGF0IGEgdGltZVxuICAgICAgICBpZiAocHVibGljU2VhcmNoUmVxdWVzdCAmJlxuICAgICAgICAgICAgcHVibGljU2VhcmNoUmVxdWVzdC5hYm9ydCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwdWJsaWNTZWFyY2hSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChhYm9ydEVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFib3J0aW5nIHJlcXVlc3QnLCBhYm9ydEVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciByZXF1ZXN0ID0gYXBwTW9kZWwucmVzdC5nZXQoJ21lL2NsaWVudHMvcHVibGljLXNlYXJjaCcsIHNlYXJjaCk7XG4gICAgICAgIHB1YmxpY1NlYXJjaFJlcXVlc3QgPSByZXF1ZXN0LnhocjtcbiAgICAgICAgXG4gICAgICAgIC8vIENhdGNoICdhYm9ydCcgdG8gYXZvaWQgY29tbXVuaWNhdGUgYSBmYWtlIGVycm9yIGluIHRoZSBwcm9taXNlOyB0aGVcbiAgICAgICAgLy8gcHJvbWlzZSB3aWxsIGp1c3Qgc29sdmUgYXMgc3VjY2VzcyB3aXRoIGVtcHR5IGFycmF5LlxuICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLnN0YXR1c1RleHQgPT09ICdhYm9ydCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgb25seSBpZiBpcyBub3QgYW4gJ2Fib3J0J1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgYWdhaW4sIHJlbW92ZWQgYnkgdGhlIGNhdGNoIHJldHVybmVkIHByb21pc2VcbiAgICAgICAgcmVxdWVzdC54aHIgPSBwdWJsaWNTZWFyY2hSZXF1ZXN0O1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xufTtcbiIsIi8qKiBFZHVjYXRpb24gKHVzZXIgZWR1Y2F0aW9uKVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VyRWR1Y2F0aW9uID0gcmVxdWlyZSgnLi4vbW9kZWxzL1VzZXJFZHVjYXRpb24nKTtcbnZhciBMaXN0UmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9MaXN0UmVtb3RlTW9kZWwnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcbiAgICBcbiAgICB2YXIgYXBpID0gbmV3IExpc3RSZW1vdGVNb2RlbCh7XG4gICAgICAgIGxpc3RUdGw6IHsgbWludXRlczogMSB9LFxuICAgICAgICBpdGVtSWRGaWVsZDogJ2VkdWNhdGlvbklEJyxcbiAgICAgICAgTW9kZWw6IFVzZXJFZHVjYXRpb25cbiAgICB9KTtcblxuICAgIGFwaS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQoJ2VkdWNhdGlvbicpO1xuXG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdtZS9lZHVjYXRpb24nKTtcbiAgICAvL2FwaS5hZGRNb2NrZWRSZW1vdGUodGVzdGRhdGEoKSk7XG4gICAgXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xufTtcbi8qXG5mdW5jdGlvbiB0ZXN0ZGF0YSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICBlZHVjYXRpb25JRDogMSxcbiAgICAgICAgICAgIGluc3RpdHV0aW9uTmFtZTogJ0Egc2Nob29sJyxcbiAgICAgICAgICAgIGRlZ3JlZUNlcnRpZmljYXRlOiAnVGhlIGRlZ3JlZScsXG4gICAgICAgICAgICBmaWVsZE9mU3R1ZHk6ICdGaWVsZCBvZiBzdHVkeScsXG4gICAgICAgICAgICBmcm9tWWVhckF0dGVuZGVkOiAxOTkzLFxuICAgICAgICAgICAgdG9ZZWFyQXR0ZW5kZWQ6IDE5OTZcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZWR1Y2F0aW9uSUQ6IDIsXG4gICAgICAgICAgICBpbnN0aXR1dGlvbk5hbWU6ICdFbXBpcmUgQmVhdXR5IFNjaG9vbCAtIFNjb3R0c2RhbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVkdWNhdGlvbklEOiAzLFxuICAgICAgICAgICAgaW5zdGl0dXRpb25OYW1lOiAnTUlUJyxcbiAgICAgICAgICAgIGRlZ3JlZUNlcnRpZmljYXRlOiAnQ29tcHV0ZXJpbmcnLFxuICAgICAgICAgICAgZmllbGRPZlN0dWR5OiAnU3lzdGVtcyBhZG1pbmlzdHJhdGlvbidcbiAgICAgICAgfVxuICAgIF07XG59XG4qLyIsIi8qKiBGZWVkYmFja1xuKiovXG4vL2dsb2JhbCBuYXZpZ2F0b3Isd2luZG93XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG4gICAgXG4gICAgdmFyIGdldFVzZXJEZXZpY2VJbmZvID0gZnVuY3Rpb24gZ2V0VXNlckRldmljZUluZm8oKSB7XG4gICAgICAgIHZhciBkZXYgPSB3aW5kb3cuZGV2aWNlIHx8IHtcbiAgICAgICAgICAgIHBsYXRmb3JtOiAnd2ViJyxcbiAgICAgICAgICAgIG1vZGVsOiAndW5rbm93JyxcbiAgICAgICAgICAgIGNvcmRvdmE6ICcnLFxuICAgICAgICAgICAgdmVyc2lvbjogJydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiBkZXYucGxhdGZvcm0sXG4gICAgICAgICAgICB2ZXJzaW9uOiBkZXYudmVyc2lvbixcbiAgICAgICAgICAgIG1vZGVsOiBkZXYubW9kZWwsXG4gICAgICAgICAgICBjb3Jkb3ZhOiBkZXYuY29yZG92YVxuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcGFyYW0gdmFsdWVzOk9iamVjdCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTpzdHJpbmcsXG4gICAgICAgICAgICAgICAgdm9jRWxlbWVudElEOmludCxcbiAgICAgICAgICAgICAgICBiZWNvbWVDb2xsYWJvcmF0b3I6Ym9vbGVhbixcbiAgICAgICAgICAgICAgICB1c2VyRGV2aWNlOnN0cmluZyAoYXV0b21hdGljKVxuICAgICAgICAgICAgfVxuICAgICAgICAqKi9cbiAgICAgICAgcG9zdElkZWE6IGZ1bmN0aW9uIHBvc3RJZGVhKHZhbHVlcykge1xuICAgICAgICAgICAgdmFsdWVzLnVzZXJEZXZpY2UgPSBKU09OLnN0cmluZ2lmeShnZXRVc2VyRGV2aWNlSW5mbygpKTtcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ2ZlZWRiYWNrL2lkZWFzJywgdmFsdWVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcGFyYW0gdmFsdWVzOk9iamVjdCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTpzdHJpbmcsXG4gICAgICAgICAgICAgICAgdm9jRWxlbWVudElEOmludCxcbiAgICAgICAgICAgICAgICB1c2VyRGV2aWNlOnN0cmluZyAoYXV0b21hdGljKVxuICAgICAgICAgICAgfVxuICAgICAgICAqKi9cbiAgICAgICAgcG9zdFN1cHBvcnQ6IGZ1bmN0aW9uIHBvc3RTdXBwb3J0KHZhbHVlcykge1xuICAgICAgICAgICAgdmFsdWVzLnVzZXJEZXZpY2UgPSBKU09OLnN0cmluZ2lmeShnZXRVc2VyRGV2aWNlSW5mbygpKTtcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ2ZlZWRiYWNrL3N1cHBvcnQnLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCIvKiogSG9tZSBBZGRyZXNzXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFkZHJlc3MgPSByZXF1aXJlKCcuLi9tb2RlbHMvQWRkcmVzcycpO1xuXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xuICAgIHZhciByZW0gPSBuZXcgUmVtb3RlTW9kZWwoe1xuICAgICAgICBkYXRhOiBuZXcgQWRkcmVzcygpLFxuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxuICAgICAgICBsb2NhbFN0b3JhZ2VOYW1lOiAnaG9tZUFkZHJlc3MnLFxuICAgICAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ21lL2FkZHJlc3Nlcy9ob21lJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ21lL2FkZHJlc3Nlcy9ob21lJywgdGhpcy5kYXRhLm1vZGVsLnRvUGxhaW5PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcmVtO1xufTtcbiIsIi8qKiBMb2dnZWQgdXNlciBzZXJ2aWNlIGF0dHJpYnV0ZXNcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSm9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL21vZGVscy9Kb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzJyk7XG5cbnZhciBHcm91cFJlbW90ZU1vZGVsID0gcmVxdWlyZSgnLi4vdXRpbHMvR3JvdXBSZW1vdGVNb2RlbCcpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xuICAgIHZhciBhcGkgPSBuZXcgR3JvdXBSZW1vdGVNb2RlbCh7XG4gICAgICAgIHR0bDogeyBob3VyczogMSB9LFxuICAgICAgICBpdGVtSWRGaWVsZDogJ2pvYlRpdGxlSUQnLFxuICAgICAgICBNb2RlbDogSm9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlc1xuICAgIH0pO1xuICAgIFxuICAgIGFwaS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQoJ2pvYi10aXRsZS1zZXJ2aWNlLWF0dHJpYnV0ZXMvJyk7XG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdqb2ItdGl0bGUtc2VydmljZS1hdHRyaWJ1dGVzLycpOyAgICBcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gYXBpO1xufTtcbiIsIi8qKiBGZXRjaCBKb2IgVGl0bGVzIGFuZCBQcmljaW5nIFR5cGVzIGluZm9ybWF0aW9uXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKSxcbiAgICBKb2JUaXRsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9Kb2JUaXRsZScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgICAgICBzdGF0ZTogIHtcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlID0ge1xuICAgICAgICAgICAgam9iVGl0bGVzOiB7fVxuICAgICAgICB9O1xuICAgIFxuICAgIGFwaS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgY2FjaGUuam9iVGl0bGVzID0ge307XG4gICAgfTtcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAgICBQdWJsaWMgQVBJXG4gICAgICAgIEdldCBhIEpvYiBUaXRsZSBpbmZvcm1hdGlvbiBieSBJRFxuICAgICoqL1xuICAgIGFwaS5nZXRKb2JUaXRsZSA9IGZ1bmN0aW9uIGdldEpvYlRpdGxlKGlkKSB7XG4gICAgICAgIGlmICghaWQpIHJldHVybiBQcm9taXNlLnJlamVjdCgnTmVlZHMgYW4gSUQgdG8gZ2V0IGEgSm9iIFRpdGxlJyk7XG5cbiAgICAgICAgLy8gRmlyc3QsIGluLW1lbW9yeSBjYWNoZVxuICAgICAgICBpZiAoY2FjaGUuam9iVGl0bGVzW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZS5qb2JUaXRsZXNbaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICAvLyBTZWNvbmQsIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCdqb2JUaXRsZXMvJyArIGlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oam9iVGl0bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoam9iVGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgaW4gbWVtb3J5IGFzIE1vZGVsIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmpvYlRpdGxlc1tpZF0gPSBuZXcgSm9iVGl0bGUoam9iVGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5qb2JUaXRsZXNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcmQgYW5kIGxhc3QsIHJlbW90ZSBsb2FkaW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnam9iLXRpdGxlcy8nICsgaWQpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGluIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0oJ2pvYlRpdGxlcy8nICsgaWQsIHJhdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBpbiBtZW1vcnkgYXMgTW9kZWwgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmpvYlRpdGxlc1tpZF0gPSBuZXcgSm9iVGl0bGUocmF3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuam9iVGl0bGVzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuIiwiLyoqIEFwcE1vZGVsLCBjZW50cmFsaXplcyBhbGwgdGhlIGRhdGEgZm9yIHRoZSBhcHAsXG4gICAgY2FjaGluZyBhbmQgc2hhcmluZyBkYXRhIGFjcm9zcyBhY3Rpdml0aWVzIGFuZCBwZXJmb3JtaW5nXG4gICAgcmVxdWVzdHNcbioqL1xudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXG4gICAgUmVzdCA9IHJlcXVpcmUoJy4uL3V0aWxzL1Jlc3QnKSxcbiAgICBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5mdW5jdGlvbiBBcHBNb2RlbCgpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygzMCk7XG59XG5cbkFwcE1vZGVsLl9pbmhlcml0cyhFdmVudEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcE1vZGVsO1xuXG5yZXF1aXJlKCcuL0FwcE1vZGVsLWFjY291bnQnKS5wbHVnSW4oQXBwTW9kZWwpO1xuXG4vKipcbiAgICBMb2FkIGNyZWRlbnRpYWxzIGZyb20gdGhlIGxvY2FsIHN0b3JhZ2UsIHdpdGhvdXQgZXJyb3IgaWYgdGhlcmUgaXMgbm90aGluZ1xuICAgIHNhdmVkLiBJZiBsb2FkIHByb2ZpbGUgZGF0YSB0b28sIHBlcmZvcm1pbmcgYW4gdHJ5TG9naW4gaWYgbm8gbG9jYWwgZGF0YS5cbioqL1xuQXBwTW9kZWwucHJvdG90eXBlLmxvYWRMb2NhbENyZWRlbnRpYWxzID0gZnVuY3Rpb24gbG9hZExvY2FsQ3JlZGVudGlhbHMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHsgLy8gTmV2ZXIgcmVqZWN0czogLCByZWplY3QpIHtcblxuICAgICAgICAvLyBDYWxsYmFjayB0byBqdXN0IHJlc29sdmUgd2l0aG91dCBlcnJvciAocGFzc2luZyBpbiB0aGUgZXJyb3JcbiAgICAgICAgLy8gdG8gdGhlICdyZXNvbHZlJyB3aWxsIG1ha2UgdGhlIHByb2Nlc3MgdG8gZmFpbCksXG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIGFuIGVycm9yIGZvciB0aGVcbiAgICAgICAgLy8gYXBwIGluaXQsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc2F2ZWQgaW5mb3JtYXRpb25cbiAgICAgICAgLy8gdGhlIGFwcCBoYXMgY29kZSB0byByZXF1ZXN0IGEgbG9naW4uXG4gICAgICAgIHZhciByZXNvbHZlQW55d2F5ID0gZnVuY3Rpb24oZG9lc25NYXR0ZXIpeyAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLndhcm5pbmcoJ0FwcCBNb2RlbCBJbml0IGVycicsIGRvZXNuTWF0dGVyKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBjcmVkZW50aWFscyBzYXZlZFxuICAgICAgICBsb2NhbGZvcmFnZS5nZXRJdGVtKCdjcmVkZW50aWFscycpLnRoZW4oZnVuY3Rpb24oY3JlZGVudGlhbHMpIHtcblxuICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWxzICYmXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHMudXNlcklEICYmXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHMudXNlcm5hbWUgJiZcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFscy5hdXRoS2V5KSB7XG5cbiAgICAgICAgICAgICAgICAvLyB1c2UgYXV0aG9yaXphdGlvbiBrZXkgZm9yIGVhY2hcbiAgICAgICAgICAgICAgICAvLyBuZXcgUmVzdCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0LmV4dHJhSGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0xDIGFsdT0nICsgY3JlZGVudGlhbHMudXNlcklEICsgJyxhbGs9JyArIGNyZWRlbnRpYWxzLmF1dGhLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEl0IGhhcyBjcmVkZW50aWFscyEgSGFzIGJhc2ljIHByb2ZpbGUgZGF0YT9cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgdXNlclByb2ZpbGUgd2lsbCBsb2FkIGZyb20gbG9jYWwgc3RvcmFnZSBvbiB0aGlzIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCwgYW5kIGxhemlseSByZXF1ZXN0IHVwZGF0ZWQgZGF0YSBmcm9tIHJlbW90ZSBzbyB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gY2F0Y2ggcmVtb3RlIGVycm9ycyB3aXRoIGV2ZW50c1xuICAgICAgICAgICAgICAgIHRoaXMudXNlclByb2ZpbGUub25jZSgnZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbXBvc3NpYmxlIHRvIGxvYWQgeW91ciBkYXRhLiBQbGVhc2UgY2hlY2sgeW91ciBJbnRlcm5ldCBjb25uZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJQcm9maWxlLmxvYWQoKS50aGVuKGZ1bmN0aW9uKHByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgcHJvZmlsZSBjYWNoZWQgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIHN1Y2Nlc2Z1bGx5XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBwcm9maWxlLCB3ZSBuZWVkIHRvIHJlcXVlc3QgaXQgdG8gYmUgYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gd29yayBjb3JyZWN0bHksIHNvIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IGEgbG9naW4gKHRoZSB0cnlMb2dpbiBwcm9jZXNzIHBlcmZvcm1zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGxvZ2luIHdpdGggdGhlIHNhdmVkIGNyZWRlbnRpYWxzIGFuZCBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb2ZpbGUgdG8gc2F2ZSBpdCBpbiB0aGUgbG9jYWwgY29weSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5TG9naW4oKS50aGVuKHJlc29sdmUsIHJlc29sdmVBbnl3YXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCByZXNvbHZlQW55d2F5KVxuICAgICAgICAgICAgICAgIC8vIFRoZSBlcnJvciBldmVudCBjYXRjaCBhbnkgZXJyb3IgaWYgaGFwcGVucywgc28gYXZvaWQgdW5jYXVnaHQgZXhjZXB0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBjb25zb2xlIGJ5IGNhdGNoaW5nIHRoZSBwcm9taXNlIGVycm9yXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkgeyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVuZCBzdWNjZXNzZnVsbHkuIE5vdCBsb2dnaW4gaXMgbm90IGFuIGVycm9yLFxuICAgICAgICAgICAgICAgIC8vIGlzIGp1c3QgdGhlIGZpcnN0IGFwcCBzdGFydC11cFxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpLCByZXNvbHZlQW55d2F5KTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqIEluaXRpYWxpemUgYW5kIHdhaXQgZm9yIGFueXRoaW5nIHVwICoqL1xuQXBwTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgIFxuICAgIC8vIExvY2FsIGRhdGFcbiAgICAvLyBUT0RPIEludmVzdGlnYXRlIHdoeSBhdXRvbWF0aWMgc2VsZWN0aW9uIGFuIEluZGV4ZWREQiBhcmVcbiAgICAvLyBmYWlsaW5nIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgd29yc2UtcGVyZm9ybWFuY2UgbG9jYWxzdG9yYWdlIGJhY2stZW5kXG4gICAgbG9jYWxmb3JhZ2UuY29uZmlnKHtcbiAgICAgICAgbmFtZTogJ0xvY29ub21pY3NBcHAnLFxuICAgICAgICB2ZXJzaW9uOiAwLjEsXG4gICAgICAgIHNpemUgOiA0OTgwNzM2LCAvLyBTaXplIG9mIGRhdGFiYXNlLCBpbiBieXRlcy4gV2ViU1FMLW9ubHkgZm9yIG5vdy5cbiAgICAgICAgc3RvcmVOYW1lIDogJ2tleXZhbHVlcGFpcnMnLFxuICAgICAgICBkZXNjcmlwdGlvbiA6ICdMb2Nvbm9taWNzIEFwcCcsXG4gICAgICAgIGRyaXZlcjogbG9jYWxmb3JhZ2UuTE9DQUxTVE9SQUdFXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRmlyc3QsIGdldCBhbnkgc2F2ZWQgbG9jYWwgY29uZmlnXG4gICAgLy8gTk9URTogZm9yIG5vdywgdGhpcyBpcyBvcHRpb25hbCwgdG8gZ2V0IGEgc2F2ZWQgc2l0ZVVybCByYXRoZXIgdGhhbiB0aGVcbiAgICAvLyBkZWZhdWx0IG9uZSwgaWYgYW55LlxuICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKCdjb25maWcnKVxuICAgIC50aGVuKGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAvLyBPcHRpb25hbCBjb25maWdcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbmZpZy5zaXRlVXJsKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGh0bWwgVVJMXG4gICAgICAgICAgICAkKCdodG1sJykuYXR0cignZGF0YS1zaXRlLXVybCcsIGNvbmZpZy5zaXRlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5zaXRlVXJsID0gJCgnaHRtbCcpLmF0dHIoJ2RhdGEtc2l0ZS11cmwnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucmVzdCA9IG5ldyBSZXN0KGNvbmZpZy5zaXRlVXJsICsgJy9hcGkvdjEvZW4tVVMvJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXR1cCBSZXN0IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIHRoaXMucmVzdC5vbkF1dGhvcml6YXRpb25SZXF1aXJlZCA9IGZ1bmN0aW9uKHJldHJ5KSB7XG5cbiAgICAgICAgICAgIHRoaXMudHJ5TG9naW4oKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9nZ2VkISBKdXN0IHJldHJ5XG4gICAgICAgICAgICAgICAgcmV0cnkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBXaXRoIGNvbmZpZyBsb2FkZWQgYW5kIFJFU1QgcmVhZHksIGxvYWQgYWxsIG1vZHVsZXNcbiAgICAgICAgdGhpcy5sb2FkTW9kdWxlcygpO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZTogY2hlY2sgdGhlIHVzZXIgaGFzIGxvZ2luIGRhdGEgYW5kIG5lZWRlZFxuICAgICAgICAvLyBjYWNoZWQgZGF0YSwgcmV0dXJuIGl0cyBwcm9taXNlXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRMb2NhbENyZWRlbnRpYWxzKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbkFwcE1vZGVsLnByb3RvdHlwZS5sb2FkTW9kdWxlcyA9IGZ1bmN0aW9uIGxvYWRNb2R1bGVzKCkge1xuICAgIC8vanNoaW50IG1heHN0YXRlbWVudHM6IDgwXG4gICAgXG4gICAgdGhpcy51c2VyUHJvZmlsZSA9IHJlcXVpcmUoJy4vQXBwTW9kZWwudXNlclByb2ZpbGUnKS5jcmVhdGUodGhpcyk7XG4gICAgLy8gTk9URTogQWxpYXMgZm9yIHRoZSB1c2VyIGRhdGFcbiAgICAvLyBUT0RPOlRPUkVWSUVXIGlmIGNvbnRpbnVlIHRvIG1ha2VzIHNlbnNlIHRvIGtlZXAgdGhpcyAndXNlcigpJyBhbGlhcywgZG9jdW1lbnRcbiAgICAvLyB3aGVyZSBpcyB1c2VkIGFuZCB3aHkgaXMgcHJlZmVycmVkIHRvIHRoZSBjYW5vbmljYWwgd2F5LlxuICAgIHRoaXMudXNlciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2VyUHJvZmlsZS5kYXRhO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5vbmJvYXJkaW5nID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5vbmJvYXJkaW5nJykuY3JlYXRlKHRoaXMpO1xuXG4gICAgdGhpcy5zY2hlZHVsaW5nUHJlZmVyZW5jZXMgPSByZXF1aXJlKCcuL0FwcE1vZGVsLnNjaGVkdWxpbmdQcmVmZXJlbmNlcycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLmNhbGVuZGFyU3luY2luZyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuY2FsZW5kYXJTeW5jaW5nJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5zaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUnKS5jcmVhdGUodGhpcyk7XG4gICAgdGhpcy5tYXJrZXRwbGFjZVByb2ZpbGUgPSByZXF1aXJlKCcuL0FwcE1vZGVsLm1hcmtldHBsYWNlUHJvZmlsZScpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLmhvbWVBZGRyZXNzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5ob21lQWRkcmVzcycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLnByaXZhY3lTZXR0aW5ncyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwucHJpdmFjeVNldHRpbmdzJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuYm9va2luZ3MgPSByZXF1aXJlKCcuL0FwcE1vZGVsLmJvb2tpbmdzJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuY2FsZW5kYXJFdmVudHMgPSByZXF1aXJlKCcuL0FwcE1vZGVsLmNhbGVuZGFyRXZlbnRzJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuam9iVGl0bGVzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5qb2JUaXRsZXMnKS5jcmVhdGUodGhpcyk7XG4gICAgdGhpcy51c2VySm9iUHJvZmlsZSA9IHJlcXVpcmUoJy4vQXBwTW9kZWwudXNlckpvYlByb2ZpbGUnKS5jcmVhdGUodGhpcyk7XG4gICAgdGhpcy5jYWxlbmRhciA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuY2FsZW5kYXInKS5jcmVhdGUodGhpcyk7XG4gICAgdGhpcy5zZXJ2aWNlQWRkcmVzc2VzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5zZXJ2aWNlQWRkcmVzc2VzJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMnKS5jcmVhdGUodGhpcyk7XG4gICAgdGhpcy5wcmljaW5nVHlwZXMgPSByZXF1aXJlKCcuL0FwcE1vZGVsLnByaWNpbmdUeXBlcycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2luZyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwubWVzc2FnaW5nJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuY2xpZW50cyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuY2xpZW50cycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLnBvc3RhbENvZGVzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5wb3N0YWxDb2RlcycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLmZlZWRiYWNrID0gcmVxdWlyZSgnLi9BcHBNb2RlbC5mZWVkYmFjaycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLmVkdWNhdGlvbiA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuZWR1Y2F0aW9uJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMubGljZW5zZXNDZXJ0aWZpY2F0aW9ucyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwubGljZW5zZXNDZXJ0aWZpY2F0aW9ucycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLnVzZXJzID0gcmVxdWlyZSgnLi9BcHBNb2RlbC51c2VycycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLmF2YWlsYWJpbGl0eSA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuYXZhaWxhYmlsaXR5JykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuc2VydmljZUF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL0FwcE1vZGVsLnNlcnZpY2VBdHRyaWJ1dGVzJykuY3JlYXRlKHRoaXMpO1xuICAgIHRoaXMuam9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vQXBwTW9kZWwuam9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlcycpLmNyZWF0ZSh0aGlzKTtcbiAgICB0aGlzLnVzZXJWZXJpZmljYXRpb25zID0gcmVxdWlyZSgnLi9BcHBNb2RlbC51c2VyVmVyaWZpY2F0aW9ucycpLmNyZWF0ZSh0aGlzKTtcbn07XG5cbi8qKlxuICAgIENsZWFyIHRoZSBsb2NhbCBzdG9yZWQgZGF0YSwgYnV0IHdpdGggY2FyZWZ1bCBmb3IgdGhlIHNwZWNpYWxcbiAgICBjb25maWcgZGF0YSB0aGF0IGlzIGtlcHQuXG4qKi9cbkFwcE1vZGVsLnByb3RvdHlwZS5jbGVhckxvY2FsRGF0YSA9IGZ1bmN0aW9uIGNsZWFyTG9jYWxEYXRhKCkge1xuICAgIC8vIEdldCBjb25maWdcbiAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnY29uZmlnJylcbiAgICAudGhlbihmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgLy8gQ2xlYXIgYWxsXG4gICAgICAgIGxvY2FsZm9yYWdlLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gU2V0IGNvbmZpZyBhZ2FpblxuICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgnY29uZmlnJywgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVHJpZ2dlciBub3RpZmljYXRpb24sIHNvIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgLy8gY2FuIG1ha2UgZnVydGhlciBjbGVhbi11cCBvciB0cnkgc3luY2hyb25pemF0aW9ucyxcbiAgICAgICAgLy8gZm9yIGV4YW1wbGUgdG8gY2xlYW4tdXAgaW4tbWVtb3J5IGNhY2hlLlxuICAgICAgICB0aGlzLmVtaXQoJ2NsZWFyTG9jYWxEYXRhJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG4iLCIvKiogU2VydmljZSBMaWNlbnNlc0NlcnRpZmljYXRpb25zXG5cbi8vIFRPRE8gSW5pdGlhbCB3b3JrLCBjb21wbGV0ZSBhbmQgdGVzdFxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VyTGljZW5zZUNlcnRpZmljYXRpb24gPSByZXF1aXJlKCcuLi9tb2RlbHMvVXNlckxpY2Vuc2VDZXJ0aWZpY2F0aW9uJyksXG4gICAgR3JvdXBMaXN0UmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9Hcm91cExpc3RSZW1vdGVNb2RlbCcpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xuXG4gICAgdmFyIGFwaSA9IG5ldyBHcm91cExpc3RSZW1vdGVNb2RlbCh7XG4gICAgICAgIC8vIENvbnNlcnZhdGl2ZSBjYWNoZSwganVzdCAxIG1pbnV0ZVxuICAgICAgICBsaXN0VHRsOiB7IG1pbnV0ZXM6IDEgfSxcbiAgICAgICAgZ3JvdXBJZEZpZWxkOiAnam9iVGl0bGVJRCcsXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAnbGljZW5zZUNlcnRpZmljYXRpb25JRCcsXG4gICAgICAgIE1vZGVsOiBVc2VyTGljZW5zZUNlcnRpZmljYXRpb25cbiAgICB9KTtcbiAgICBcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCd1c2VyTGljZW5zZUNlcnRpZmljYXRpb25zJyk7XG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdtZS91c2VyLWxpY2Vuc2UtY2VydGlmaWNhdGlvbnMvJyk7XG4gICAgXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwaS5jbGVhckNhY2hlKCk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGFwaTtcbn07XG4iLCIvKiogTWFya2V0cGxhY2VQcm9maWxlXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1hcmtldHBsYWNlUHJvZmlsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9NYXJrZXRwbGFjZVByb2ZpbGUnKTtcblxudmFyIFJlbW90ZU1vZGVsID0gcmVxdWlyZSgnLi4vdXRpbHMvUmVtb3RlTW9kZWwnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcbiAgICB2YXIgcmVtID0gbmV3IFJlbW90ZU1vZGVsKHtcbiAgICAgICAgZGF0YTogbmV3IE1hcmtldHBsYWNlUHJvZmlsZSgpLFxuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxuICAgICAgICBsb2NhbFN0b3JhZ2VOYW1lOiAnbWFya2V0cGxhY2VQcm9maWxlJyxcbiAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtZS9tYXJrZXRwbGFjZS1wcm9maWxlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ21lL21hcmtldHBsYWNlLXByb2ZpbGUnLCB0aGlzLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiByZW07XG59O1xuIiwiLyoqIEFwcE1vZGVsIGZvciBtZXNzYWdpbmc6IHRocmVhZHMgYW5kIG1lc3NhZ2VzXG5cbiAgICBOT1RFOiBJbml0aWFsIGJhc2ljIGltcGxlbWVudGF0aW9uXG4gICAgVE9ETzogUmVxdWlyZSBhZHZhbmNlZCBpbXBsZW1lbnRhdGlvbiwgbG9hZGluZyBhIGxpbWl0ZWRcbiAgICAgICAgYW1vdW50IG9mIHJlY29yZHMgZm9yIHRocmVhZHMgYW5kIG1lc3NhZ2VzIHBlciB0aHJlYWRcbiAgICAgICAgdXNpbmcgdGhlIGN1cnNvciBwYXJhbWV0ZXJzIG9mIHRoZSBSRVNUIEFQSSB0byBtYW5hZ2VcbiAgICAgICAgcGFnaW5nIGxvYWQuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRocmVhZCA9IHJlcXVpcmUoJy4uL21vZGVscy9UaHJlYWQnKSxcbiAgICBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuLi91dGlscy9DYWNoZUNvbnRyb2wnKSxcbiAgICBMaXN0UmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9MaXN0UmVtb3RlTW9kZWwnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcbiAgICBcbiAgICB2YXIgYXBpID0gbmV3IExpc3RSZW1vdGVNb2RlbCh7XG4gICAgICAgIGxpc3RUdGw6IHsgbWludXRlczogMSB9LFxuICAgICAgICBpdGVtSWRGaWVsZDogJ3RocmVhZElEJyxcbiAgICAgICAgTW9kZWw6IFRocmVhZFxuICAgIH0pO1xuXG4gICAgYXBpLmFkZExvY2FsZm9yYWdlU3VwcG9ydCgnbWVzc2FnaW5nJyk7XG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdtZS9tZXNzYWdpbmcnKTtcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBCYXNpYyBzdXBwb3J0IGlzIGZldGNoaW5nIGFsbCB0aHJlYWRzIHdpdGggdGhlIGxhdGVzdCBtZXNzYWdlIG9mIGVhY2ggb25lLlxuICAgIC8vIFJlcGxhY2UgZ2V0SXRlbSBidWlsdC1pbiB0byBkbyBub24gbG9jYWxseSBzYXZlZCwgZmV0Y2ggZm9yIGFsbCBtZXNzYWdlcyBpblxuICAgIC8vIGEgdGhyZWFkICh0aGUgdGhyZWFkIGlzIHRoZSBpdGVtKVxuICAgIHZhciBmdWxsVGhyZWFkc0NhY2hlID0gey8qXG4gICAgICAgIHRocmVhZElEOiB7IGNvbnRyb2w6IENhY2hlQ29udHJvbCwgdGhyZWFkOiBUaHJlYWQgfVxuICAgICovfTtcbiAgICB2YXIgZmV0Y2hUaHJlYWRSZW1vdGUgPSBmdW5jdGlvbih0aHJlYWRJRCkge1xuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ21lL21lc3NhZ2luZy8nICsgdGhyZWFkSUQsIHtcbiAgICAgICAgICAgIGxpbWl0OiAxMDAwIC8qIG1heCBtZXNzYWdlcyBpbiB0aGUgdGhyZWFkICovXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHRocmVhZCkge1xuICAgICAgICAgICAgaWYgKHRocmVhZCkge1xuICAgICAgICAgICAgICAgIHRocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkID0gZnVsbFRocmVhZHNDYWNoZVt0aHJlYWRJRF07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuY29udHJvbC5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQudGhyZWFkID0gdGhyZWFkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxUaHJlYWRzQ2FjaGVbdGhyZWFkSURdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogbmV3IENhY2hlQ29udHJvbCh7IHR0bDogeyBtaW51dGVzOiAxIH0gfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlYWQ6IHRocmVhZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmdWxsVGhyZWFkc0NhY2hlW3RocmVhZElEXS5jb250cm9sLmxhdGVzdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aHJlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBGb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBtYXJrQXNFbmRlZEFuZEZvbGxvd1VwID0gZnVuY3Rpb24oYW55KSB7XG4gICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xuICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGFueTtcbiAgICB9O1xuICAgIGFwaS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbSh0aHJlYWRJRCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gZnVsbFRocmVhZHNDYWNoZVt0aHJlYWRJRF07XG4gICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLnRocmVhZCkge1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFRocmVhZFJlbW90ZSh0aHJlYWRJRClcbiAgICAgICAgICAgICAgICAudGhlbihtYXJrQXNFbmRlZEFuZEZvbGxvd1VwLCBtYXJrQXNFbmRlZEFuZEZvbGxvd1VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZC50aHJlYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFRocmVhZFJlbW90ZSh0aHJlYWRJRClcbiAgICAgICAgICAgIC50aGVuKG1hcmtBc0VuZGVkQW5kRm9sbG93VXAsIG1hcmtBc0VuZGVkQW5kRm9sbG93VXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuIiwiLyoqXG4gICAgT25ib2FyZGluZyB0cmFja2luZyBpbmZvcm1hdGlvblxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBPbmJvYXJkaW5nUHJvZ3Jlc3MgPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL09uYm9hcmRpbmdQcm9ncmVzcycpLFxuICAgIE5hdkFjdGlvbiA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvTmF2QWN0aW9uJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG4gICAgXG4gICAgLy8gT25ib2FyZGluZyBtYW5hZ2VtZW50IGFuZCBzdGF0ZSwgaW5pdGlhbGx5IGVtcHR5IHNvIG5vIHByb2dyZXNzXG4gICAgdmFyIGFwaSA9IG5ldyBPbmJvYXJkaW5nUHJvZ3Jlc3MoKTtcbiAgICBcbiAgICAvLyBSZXF1aXJlcyBpbml0aWFsaXphdGlvbiB0byByZWNlaXZlIGFuZCBhcHAgaW5zdGFuY2VcbiAgICBhcGkuaW5pdCA9IGZ1bmN0aW9uIGluaXQoYXBwKSB7XG4gICAgICAgIGFwaS5hcHAgPSBhcHA7XG4gICAgfTtcbiAgICBcbiAgICAvLyBFeHRlbmRlZCB3aXRoIG5ldyBtZXRob2RzXG5cbiAgICAvLyBTZXQgdGhlIGNvcnJlY3Qgb25ib2FyZGluZyBwcm9ncmVzcyBhbmQgc3RlcCBnaXZlbiBhIHN0ZXAgcmVmZXJlbmNlXG4gICAgLy8gKHVzdWFsbHkgZnJvbSBkYXRhYmFzZSlcbiAgICBhcGkuc2V0U3RlcCA9IGZ1bmN0aW9uKHN0ZXBSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHN0ZXBSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBzdGVwSXRlbXMgPSBzdGVwUmVmZXJlbmNlLnNwbGl0KCc6JywgMiksXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBzdGVwSXRlbXNbMF0sXG4gICAgICAgICAgICAgICAgLy8gc3RlcCBpcyB0aGUgc2Vjb25kIHBhcnQsIG9yIGp1c3QgdGhlIHNhbWUgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgZnVsbCBuYW1lICh0aGF0IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBzdGVwcyB0aGF0IHNoYXJlXG4gICAgICAgICAgICAgICAgLy8gbmFtZSB3aXRoIHRoZSBncm91cCBhbmQgb25seSBuZWVkIHRvIGRlZmluZSB0aGUgZ3JvdXAgbmFtZSlcbiAgICAgICAgICAgICAgICBzdGVwID0gc3RlcEl0ZW1zWzFdIHx8IGdyb3VwO1xuXG4gICAgICAgICAgICAvLyBUcnkgdG8gc2V0IGN1cnJlbnQgc3RlcCwgZm9sbG93IHRvIGxvb2sgZm9yIGdyb3VwIGlmIGRvZXMgbm90IHN1Y2Nlc3NcbiAgICAgICAgICAgIGlmICh0aGlzLnNldFN0ZXBCeU5hbWUoc3RlcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2U6XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhIGdyb3VwIHRoYXQgbWF0Y2hlc1xuICAgICAgICAgICAgdmFyIGdyb3VwU3RlcHMgPSBPbmJvYXJkaW5nUHJvZ3Jlc3MucHJlZGVmaW5lZFN0ZXBHcm91cHNbZ3JvdXBdO1xuICAgICAgICAgICAgaWYgKGdyb3VwU3RlcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBzKGdyb3VwU3RlcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldFN0ZXBCeU5hbWUoc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHByb2dyZXNzOlxuICAgICAgICB0aGlzLm1vZGVsLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBnaXZlbiBuYXZiYXIgd2l0aCB0aGUgY3VycmVudCBvbmJvYXJkaW5nIGluZm9ybWF0aW9uIChvbmx5IGlmIGluIHByb2dyZXNzKVxuICAgIGFwaS51cGRhdGVOYXZCYXIgPSBmdW5jdGlvbihuYXZCYXIpIHtcbiAgICAgICAgdmFyIHllcCA9IHRoaXMuaW5Qcm9ncmVzcygpO1xuICAgICAgICBpZiAoeWVwKSB7XG4gICAgICAgICAgICAvLyBPbiAyMDE1LTA2LTE2ICM1NzUsIGNoYW5nZWQgZGVjaXNzaW9uIGZyb20gdXNlIGEgJ2dvIGJhY2snIGFjdGlvblxuICAgICAgICAgICAgLy8gKGNvbW1lbnRlZCBpbiBmb2xsb3dpbmcgbGluZXMpOlxuLy8gICAgICAgICAgICBuYXZCYXIubGVmdEFjdGlvbihOYXZBY3Rpb24uZ29CYWNrLm1vZGVsLmNsb25lKCkpO1xuLy8gICAgICAgICAgICBuYXZCYXIubGVmdEFjdGlvbigpLmhhbmRsZXIoZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICBhcGkuZ29QcmV2aW91cygpO1xuLy8gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRvIHVzZSB0aGUgTG9nLW91dCBhY3Rpb25cbiAgICAgICAgICAgIG5hdkJhci5sZWZ0QWN0aW9uKE5hdkFjdGlvbi5nb0xvZ291dCk7XG5cbiAgICAgICAgICAgIG5hdkJhci50aXRsZSh0aGlzLnByb2dyZXNzVGV4dCgpKTsgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVwO1xuICAgIH07XG4gICAgXG4gICAgYXBpLmdvTmV4dCA9IGZ1bmN0aW9uIGdvTmV4dCgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0ZXBOdW1iZXIoKTtcblxuICAgICAgICBjdXJyZW50Kys7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPiB0aGlzLnRvdGFsU3RlcHMoKSkge1xuICAgICAgICAgICAgLy8gSXQgZW5kZWQhIVxuICAgICAgICAgICAgdGhpcy5zdGVwTnVtYmVyKC0xKTtcbiAgICAgICAgICAgIGFwcE1vZGVsLnVzZXJQcm9maWxlLnNhdmVPbmJvYXJkaW5nU3RlcChudWxsKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnNoZWxsLmdvKCcvJywgeyBjb21wbGV0ZWRPbmJvYXJkaW5nOiBhcGkuZ3JvdXAoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdldCBuZXh0IHN0ZXBcbiAgICAgICAgICAgIHRoaXMuc3RlcE51bWJlcihjdXJyZW50KTtcbiAgICAgICAgICAgIGFwcE1vZGVsLnVzZXJQcm9maWxlLnNhdmVPbmJvYXJkaW5nU3RlcCh0aGlzLnN0ZXBSZWZlcmVuY2UoKSk7XG4gICAgICAgICAgICB0aGlzLmFwcC5zaGVsbC5nbyh0aGlzLnN0ZXBVcmwoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGFwaS5nb1ByZXZpb3VzID0gZnVuY3Rpb24gZ29QcmV2aW91cygpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0ZXBOdW1iZXIoKTtcblxuICAgICAgICBjdXJyZW50LS07XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPj0gMCAmJiBjdXJyZW50IDw9IHRoaXMudG90YWxTdGVwcygpKSB7XG4gICAgICAgICAgICAvLyBHZXQgcHJldmlvdXMgc3RlcFxuICAgICAgICAgICAgdGhpcy5zdGVwTnVtYmVyKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGVwTnVtYmVyKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwTW9kZWwudXNlclByb2ZpbGUuc2F2ZU9uYm9hcmRpbmdTdGVwKHRoaXMuc3RlcFJlZmVyZW5jZSgpKTtcbiAgICAgICAgdGhpcy5hcHAuc2hlbGwuZ28odGhpcy5zdGVwVXJsKCkpO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGFwaTtcbn07XG4iLCIvKiogUG9zdGFsIENvZGUuXG5cbiAgICBBY2Nlc3MgdGhlIEFQSSB0byB2YWxpZGF0ZSBhbmQgcmV0cmlldmUgaW5mb3JtYXRpb24gZm9yIGEgXG4gICAgZ2l2ZW4gcG9zdGFsIGNvZGUuXG4gICAgXG4gICAgSXQganVzdCBvZmZlcnMgYSAnZ2V0IHBvc3RhbCBjb2RlIGluZm8nIG1ldGhvZCByZXR1cm5pbmdcbiAgICBhIHBsYWluIG9iamVjdCBmcm9tIHRoZSBSRVNUIGVuZHBvaW50LlxuICAgIFxuICAgIENyZWF0ZXMgYW4gaW4tbWVtb3J5IGNhY2hlIGZvciBmcmVxdWVudGx5IHVzZWQgcG9zdGFsIGNvZGVzXG4qKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcblxuICAgIHZhciBhcGkgPSB7fSxcbiAgICAgICAgY2FjaGUgPSB7fTtcbiAgICBcbiAgICBhcGkuZ2V0SXRlbSA9IGZ1bmN0aW9uIGdldEl0ZW0ocG9zdGFsQ29kZSkge1xuICAgICAgICBcbiAgICAgICAgcG9zdGFsQ29kZSA9IHBvc3RhbENvZGUgfHwgJyc7XG4gICAgICAgIGlmICgvXlxccyokLy50ZXN0KHBvc3RhbENvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1Bvc3RhbCBDb2RlIE5vdCBWYWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBjYWNoZVxuICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkocG9zdGFsQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVbcG9zdGFsQ29kZV0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ3Bvc3RhbC1jb2Rlcy8nICsgcG9zdGFsQ29kZSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgLy8gU2F2ZSBjYWNoZVxuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtwb3N0YWxDb2RlXSA9IGluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhY2hlID0ge307XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGFwaTtcbn07XG4iLCIvKiogUHJpY2luZyBUeXBlc1xuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQcmljaW5nVHlwZSA9IHJlcXVpcmUoJy4uL21vZGVscy9QcmljaW5nVHlwZScpO1xuXG52YXIgTGlzdFJlbW90ZU1vZGVsID0gcmVxdWlyZSgnLi4vdXRpbHMvTGlzdFJlbW90ZU1vZGVsJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG4gICAgXG4gICAgdmFyIGFwaSA9IG5ldyBMaXN0UmVtb3RlTW9kZWwoe1xuICAgICAgICAvLyBUeXBlcyBkb2VzIG5vdCBjaGFuZ2VzIHVzdWFsbHksIHNvIGJpZyB0dGxcbiAgICAgICAgbGlzdFR0bDogeyBkYXlzOiAxIH0sXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAncHJpY2luZ1R5cGVJRCcsXG4gICAgICAgIE1vZGVsOiBQcmljaW5nVHlwZVxuICAgIH0pO1xuXG4gICAgYXBpLmFkZExvY2FsZm9yYWdlU3VwcG9ydCgncHJpY2luZy10eXBlcycpO1xuICAgIGFwaS5hZGRSZXN0U3VwcG9ydChhcHBNb2RlbC5yZXN0LCAncHJpY2luZy10eXBlcycpO1xuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG4iLCIvKiogUHJpdmFjeSBTZXR0aW5nc1xuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQcml2YWN5U2V0dGluZ3MgPSByZXF1aXJlKCcuLi9tb2RlbHMvUHJpdmFjeVNldHRpbmdzJyk7XG5cbnZhciBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbW90ZU1vZGVsJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG4gICAgdmFyIHJlbSA9IG5ldyBSZW1vdGVNb2RlbCh7XG4gICAgICAgIGRhdGE6IG5ldyBQcml2YWN5U2V0dGluZ3MoKSxcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3ByaXZhY3lTZXR0aW5ncycsXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnbWUvcHJpdmFjeS1zZXR0aW5ncycpO1xuICAgICAgICB9LFxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucHV0KCdtZS9wcml2YWN5LXNldHRpbmdzJywgdGhpcy5kYXRhLm1vZGVsLnRvUGxhaW5PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcmVtO1xufTtcbiIsIi8qKlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTY2hlZHVsaW5nUHJlZmVyZW5jZXMgPSByZXF1aXJlKCcuLi9tb2RlbHMvU2NoZWR1bGluZ1ByZWZlcmVuY2VzJyk7XG5cbnZhciBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbW90ZU1vZGVsJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG4gICAgdmFyIHJlbSA9IG5ldyBSZW1vdGVNb2RlbCh7XG4gICAgICAgIGRhdGE6IG5ldyBTY2hlZHVsaW5nUHJlZmVyZW5jZXMoKSxcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3NjaGVkdWxpbmdQcmVmZXJlbmNlcycsXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnbWUvc2NoZWR1bGluZy1wcmVmZXJlbmNlcycpO1xuICAgICAgICB9LFxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucHV0KCdtZS9zY2hlZHVsaW5nLXByZWZlcmVuY2VzJywgdGhpcy5kYXRhLm1vZGVsLnRvUGxhaW5PYmplY3QoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVjb21wdXRlIGF2YWlsYWJpbGl0eSBhcyBzaWRlIGVmZmVjdCBvZiBzY2hlZHVsaW5nIHByZWZlcmVuY2VzIGNoYW5nZXNcbiAgICAgICAgICAgICAgICBhcHBNb2RlbC5jYWxlbmRhci5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgICAgICAgLy8gRm9yd2FyZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgYXBwTW9kZWwub24oJ2NsZWFyTG9jYWxEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbS5jbGVhckNhY2hlKCk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHJlbTtcbn07XG4iLCIvKiogU2VydmljZSBBZGRyZXNzZXNcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4uL21vZGVscy9BZGRyZXNzJyksXG4gICAgR3JvdXBMaXN0UmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9Hcm91cExpc3RSZW1vdGVNb2RlbCcpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShhcHBNb2RlbCkge1xuXG4gICAgdmFyIGFwaSA9IG5ldyBHcm91cExpc3RSZW1vdGVNb2RlbCh7XG4gICAgICAgIC8vIENvbnNlcnZhdGl2ZSBjYWNoZSwganVzdCAxIG1pbnV0ZVxuICAgICAgICBsaXN0VHRsOiB7IG1pbnV0ZXM6IDEgfSxcbiAgICAgICAgZ3JvdXBJZEZpZWxkOiAnam9iVGl0bGVJRCcsXG4gICAgICAgIGl0ZW1JZEZpZWxkOiAnYWRkcmVzc0lEJyxcbiAgICAgICAgTW9kZWw6IEFkZHJlc3NcbiAgICB9KTtcbiAgICBcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdhZGRyZXNzZXMvc2VydmljZS8nKTtcbiAgICBhcGkuYWRkUmVzdFN1cHBvcnQoYXBwTW9kZWwucmVzdCwgJ21lL2FkZHJlc3Nlcy9zZXJ2aWNlLycpO1xuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBhcGk7XG59O1xuIiwiLyoqIExvZ2dlZCB1c2VyIHNlcnZpY2UgYXR0cmlidXRlc1xuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VySm9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL21vZGVscy9Vc2VySm9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlcycpO1xuXG52YXIgR3JvdXBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0dyb3VwUmVtb3RlTW9kZWwnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcbiAgICB2YXIgYXBpID0gbmV3IEdyb3VwUmVtb3RlTW9kZWwoe1xuICAgICAgICB0dGw6IHsgbWludXRlczogMSB9LFxuICAgICAgICBpdGVtSWRGaWVsZDogJ2pvYlRpdGxlSUQnLFxuICAgICAgICBNb2RlbDogVXNlckpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXNcbiAgICB9KTtcbiAgICBcbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdzZXJ2aWNlLWF0dHJpYnV0ZXMvJyk7XG4gICAgYXBpLmFkZFJlc3RTdXBwb3J0KGFwcE1vZGVsLnJlc3QsICdtZS9zZXJ2aWNlLWF0dHJpYnV0ZXMvJyk7ICAgIFxuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBhcGk7XG59O1xuIiwiLyoqIFNlcnZpY2UgcHJvZmVzc2lvbmFsIHNlcnZpY2VcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UgPSByZXF1aXJlKCcuLi9tb2RlbHMvU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UnKSxcbiAgICBHcm91cExpc3RSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0dyb3VwTGlzdFJlbW90ZU1vZGVsJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG5cbiAgICB2YXIgYXBpID0gbmV3IEdyb3VwTGlzdFJlbW90ZU1vZGVsKHtcbiAgICAgICAgLy8gQ29uc2VydmF0aXZlIGNhY2hlLCBqdXN0IDEgbWludXRlXG4gICAgICAgIGxpc3RUdGw6IHsgbWludXRlczogMSB9LFxuICAgICAgICBncm91cElkRmllbGQ6ICdqb2JUaXRsZUlEJyxcbiAgICAgICAgaXRlbUlkRmllbGQ6ICdzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEJyxcbiAgICAgICAgTW9kZWw6IFNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlXG4gICAgfSk7XG5cbiAgICBhcGkuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KCdzZXJ2aWNlLXByb2Zlc3Npb25hbC1zZXJ2aWNlcy8nKTtcbiAgICBhcGkuYWRkUmVzdFN1cHBvcnQoYXBwTW9kZWwucmVzdCwgJ21lL3NlcnZpY2UtcHJvZmVzc2lvbmFsLXNlcnZpY2VzLycpO1xuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBhcGk7XG59O1xuIiwiLyoqXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9TaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUnKSxcbiAgICBSZW1vdGVNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbW90ZU1vZGVsJyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbi8vIEEgbGlzdCBvZiB3ZWVrIGRheSBwcm9wZXJ0aWVzIG5hbWVzIGFsbG93ZWRcbi8vIHRvIGJlIHBhcnQgb2YgdGhlIG9iamVjdHMgZGVzY3JpYmluZyB3ZWVrbHkgc2NoZWR1bGVcbi8vIChzaW1wbGlmaWVkIG9yIGNvbXBsZXRlL3Nsb3QgYmFzZWQpXG4vLyBKdXN0IGxvd2VjYXNlZCBlbmdsaXNoIG5hbWVzXG52YXIgd2Vla0RheVByb3BlcnRpZXMgPSBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5J107XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG4gICAgdmFyIHJlbSA9IG5ldyBSZW1vdGVNb2RlbCh7XG4gICAgICAgIGRhdGE6IG5ldyBTaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUoKSxcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcbiAgICAgICAgbG9jYWxTdG9yYWdlTmFtZTogJ3dlZWtseVNjaGVkdWxlJyxcbiAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtZS93ZWVrbHktc2NoZWR1bGUnKVxuICAgICAgICAgICAgLnRoZW4oZnJvbVdlZWtseVNjaGVkdWxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgICAgICAgIHZhciBwbGFpbkRhdGEgPSB0b1dlZWtseVNjaGVkdWxlKHRoaXMuZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpKTtcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnB1dCgnbWUvd2Vla2x5LXNjaGVkdWxlJywgcGxhaW5EYXRhKVxuICAgICAgICAgICAgLnRoZW4oZnJvbVdlZWtseVNjaGVkdWxlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZWNvbXB1dGUgYXZhaWxhYmlsaXR5IGFzIHNpZGUgZWZmZWN0IG9mIHNjaGVkdWxlXG4gICAgICAgICAgICAgICAgYXBwTW9kZWwuY2FsZW5kYXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgICAgICAgIC8vIEZvcndhcmQgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZW0uY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiByZW07XG59O1xuXG4vKipcbiAgICBCYXNpY2FsbHksIGZyb20gYSBtdWx0aSBkYXRlIHRpbWVSYW5nZXMgc3RydWN0dXJlXG4gICAgdG8gYSBzaW1pbGFyIHdpdGggb25seSBvbmUgdGltZVJhbmdlIHBlciBkYXRlIGFuZFxuICAgIG1hbmFnZWQgaW4gbWludXRlcyBpbiBhICdmcm9tLXRvJyBzdHJ1Y3R1cmUuXG4gICAgXG4gICAgU291cmNlIHN0cnVjdHVyZSAoc29tZSB3ZWVrZGF5cyByZW1vdmVkIGZvciBicmV2aXR5KToge1xuICAgICAgICBcInRpbWVab25lXCI6IFwiQW1lcmljYS9Mb3NfQW5nZWxlc1wiLFxuICAgICAgICBcInN1bmRheVwiOiBbe1xuICAgICAgICAgICAgXCJzdGFydFwiOiBcIjAwOjAwOjAwXCIsXG4gICAgICAgICAgICBcImVuZFwiOiBcIjIzOjU5OjU5XCJcbiAgICAgICAgfV0sXG4gICAgICAgIFwibW9uZGF5XCI6IFtdLFxuICAgICAgICBcInR1ZXNkYXlcIjogbnVsbCxcbiAgICAgICAgXCJzYXR1cmRheVwiOiBbe1xuICAgICAgICAgICAgXCJzdGFydFwiOiBcIjEwOjAwOjAwXCIsXG4gICAgICAgICAgICBcImVuZFwiOiBcIjE0OjAwOjAwXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJzdGFydFwiOiBcIjE2OjMwOjAwXCIsXG4gICAgICAgICAgICBcImVuZFwiOiBcIjIwOjMwOjAwXCJcbiAgICAgICAgfV0sXG4gICAgICAgIFwiaXNBbGxUaW1lXCI6IGZhbHNlXG4gICAgfVxuKiovXG5mdW5jdGlvbiBmcm9tV2Vla2x5U2NoZWR1bGUod2Vla2x5U2NoZWR1bGUpIHtcbiAgICBcbiAgICAvLyBOZXcgc2ltcGxpZmllZCBvYmplY3QsIGFzIGEgcGxhaW4gb2JqZWN0IHdpdGhcbiAgICAvLyB3ZWVrZGF5cyBwcm9wZXJ0aWVzIGFuZCBmcm9tLXRvIHByb3BlcnRpZXMgbGlrZTpcbiAgICAvLyB7IHN1bmRheTogeyBmcm9tOiAwLCB0bzogNjAgfSB9XG4gICAgLy8gU2luY2UgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBjb25zdW1lZCBieSBmZXRjaC1wdXNoXG4gICAgLy8gb3BlcmF0aW9ucywgYW5kIGxhdGVyIGJ5IGFuICdtb2RlbC51cGRhdGVXaXRoJyBvcGVyYXRpb24sXG4gICAgLy8gc28gcGxhaW4gaXMgc2ltcGxlIGFuZCBiZXR0ZXIgb24gcGVyZm9ybWFuY2U7IGNhbiBiZVxuICAgIC8vIGNvbnZlcnRlZCBlYXNpbHkgdG8gdGhlIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSBvYmplY3QuXG4gICAgdmFyIHNpbXBsZVdTID0ge1xuICAgICAgICB0aW1lWm9uZTogd2Vla2x5U2NoZWR1bGUudGltZVpvbmUgfHwgJycsXG4gICAgICAgIGlzQWxsVGltZTogd2Vla2x5U2NoZWR1bGUuaXNBbGxUaW1lXG4gICAgfTtcblxuICAgIC8vIFJlYWQgdGltZVJhbmdlcyBwZXIgd2Vlay1kYXlcbiAgICBPYmplY3Qua2V5cyh3ZWVrbHlTY2hlZHVsZSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbih3ZWVrZGF5KSB7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgaXMgYSB3ZWVrZGF5IHByb3BlcnR5LCBvciBleGl0IGVhcmx5XG4gICAgICAgIGlmICh3ZWVrRGF5UHJvcGVydGllcy5pbmRleE9mKHdlZWtkYXkpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpbWVSYW5nZXMgPSB3ZWVrbHlTY2hlZHVsZVt3ZWVrZGF5XTtcblxuICAgICAgICBpZiAodGltZVJhbmdlcyAmJiB0aW1lUmFuZ2VzWzBdKSB7XG4gICAgICAgICAgICAvLyBUaW1lcyBjb21lcyBpbiBJU08gZm9ybWF0IFwiMDA6MDA6MDBcIiB0aGF0IHdlIGNvbnZlcnQgdG8gbWludXRlc1xuICAgICAgICAgICAgLy8gKGVub3VnaCBwcmVjaXNpb24gZm9yIHNpbXBsaWZpZWQgd2Vla2x5IHNjaGVkdWxlKVxuICAgICAgICAgICAgLy8gdXNpbmcgbW9tZW50LmR1cmF0aW9uXG4gICAgICAgICAgICBzaW1wbGVXU1t3ZWVrZGF5XSA9IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBtb21lbnQuZHVyYXRpb24odGltZVJhbmdlc1swXS5zdGFydCkuYXNNaW51dGVzKCkgfDAsXG4gICAgICAgICAgICAgICAgdG86IG1vbWVudC5kdXJhdGlvbih0aW1lUmFuZ2VzWzBdLmVuZCkuYXNNaW51dGVzKCkgfDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERvbmUhXG4gICAgcmV0dXJuIHNpbXBsZVdTO1xufVxuXG4vKipcbiAgICBQYXNzIGluIGEgcGxhaW4gb2JqZWN0LCBub3QgYSBtb2RlbCxcbiAgICBnZXR0aW5nIGFuIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhlIEFQSSBlbmRwb2ludC5cbiAgICBcbiAgICBJdCByZXR1cm5zIGEgc3RydWN0dXJlIGxpa2UgdGhlIGlucHV0IHNvdXJjZSBleHBlY3RlZCBhdCBmcm9tV2Vla2x5U2NoZWR1bGVcbioqL1xuZnVuY3Rpb24gdG9XZWVrbHlTY2hlZHVsZShzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUpIHtcbiAgICBcbiAgICAvLyBSZXN1bHRpbmcgc3RydWN0dXJlXG4gICAgdmFyIHdlZWtseVNjaGVkdWxlID0ge1xuICAgICAgICB0aW1lWm9uZTogc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlLnRpbWVab25lLFxuICAgICAgICBpc0FsbFRpbWU6IHNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5pc0FsbFRpbWVcbiAgICB9O1xuXG4gICAgLy8gQXZvaWQgZXh0cmEgd29yayBpZiBpcyBhbGwgdGltZSwgc2luY2UgYWxsIG90aGVyIHByb3BlcnRpZXNcbiAgICAvLyB3aWxsIGdldCBkaXNjYXJkZWQgb24gdGhhdCBjYXNlLlxuICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIHRoZSB3ZWVrZGF5cyBwcm9wZXJ0aWVzIHdpdGggdGhlIHRpbWVSYW5nZXNcbiAgICBpZiAoIXdlZWtseVNjaGVkdWxlLmlzQWxsVGltZSkge1xuICAgICAgICAvLyBQZXIgd2Vla2RheVxuICAgICAgICBPYmplY3Qua2V5cyhzaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUpXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHdlZWtkYXkpIHtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IGlzIGEgd2Vla2RheSBwcm9wZXJ0eSwgb3IgZXhpdCBlYXJseVxuICAgICAgICAgICAgaWYgKHdlZWtEYXlQcm9wZXJ0aWVzLmluZGV4T2Yod2Vla2RheSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2ltcGxlRGF5ID0gc2ltcGxpZmllZFdlZWtseVNjaGVkdWxlW3dlZWtkYXldO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBtaW51dGVzIHRvIElTTyB0aW1lIGZvcm1hdCAoMDA6MDA6MDApXG4gICAgICAgICAgICAvLyBhbmQgYWRkIGl0IHRvIGEgbmV3IGFycmF5IHdpdGggYSBzaW5nbGUgdGltZVJhbmdlOlxuICAgICAgICAgICAgd2Vla2x5U2NoZWR1bGVbd2Vla2RheV0gPSBbe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBtaW51dGVzVG9UaW1lU3RyaW5nKHNpbXBsZURheS5mcm9tIHwwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG1pbnV0ZXNUb1RpbWVTdHJpbmcoc2ltcGxlRGF5LnRvIHwwKVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERvbmUhXG4gICAgcmV0dXJuIHdlZWtseVNjaGVkdWxlO1xufVxuXG4vKipcbiAgICBpbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uICd0byBzdHJpbmcgd2l0aCB0d28gZGlnaXRzIGFsbW9zdCdcbioqL1xuZnVuY3Rpb24gdHdvRGlnaXRzKG4pIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihuIC8gMTApICsgJycgKyBuICUgMTA7XG59XG5cbi8qKlxuICAgIENvbnZlcnQgYSBudW1iZXIgb2YgbWludXRlc1xuICAgIGluIGEgc3RyaW5nIGxpa2U6IDAwOjAwOjAwIChob3VyczptaW51dGVzOnNlY29uZHMpXG4qKi9cbmZ1bmN0aW9uIG1pbnV0ZXNUb1RpbWVTdHJpbmcobWludXRlcykge1xuICAgIHZhciBkID0gbW9tZW50LmR1cmF0aW9uKG1pbnV0ZXMsICdtaW51dGVzJyksXG4gICAgICAgIGggPSBkLmhvdXJzKCksXG4gICAgICAgIG0gPSBkLm1pbnV0ZXMoKSxcbiAgICAgICAgcyA9IGQuc2Vjb25kcygpO1xuICAgIFxuICAgIHJldHVybiAoXG4gICAgICAgIHR3b0RpZ2l0cyhoKSArICc6JyArXG4gICAgICAgIHR3b0RpZ2l0cyhtKSArICc6JyArXG4gICAgICAgIHR3b0RpZ2l0cyhzKVxuICAgICk7XG59XG4iLCIvKipcbiAgICBNb2RlbCBBUEkgdG8gbWFuYWdlIHRoZSBjb2xsZWN0aW9uIG9mIEpvYiBUaXRsZXMgYXNzaWduZWRcbiAgICB0byB0aGUgY3VycmVudCB1c2VyIGFuZCBpdHMgd29ya2luZyBkYXRhLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VySm9iVGl0bGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvVXNlckpvYlRpdGxlJyksXG4gICAgQ2FjaGVDb250cm9sID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2FjaGVDb250cm9sJyksXG4gICAgbG9jYWxmb3JhZ2UgPSByZXF1aXJlKCdsb2NhbGZvcmFnZScpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGFwcE1vZGVsKSB7XG5cbiAgICB2YXIgYXBpID0ge30sXG4gICAgICAgIGRlZmF1bHRUdGwgPSB7IG1pbnV0ZXM6IDEgfSxcbiAgICAgICAgY2FjaGUgPSB7XG4gICAgICAgICAgICAvLyBBcnJheSBvZiB1c2VyIGpvYiB0aXRsZXMgbWFraW5nXG4gICAgICAgICAgICAvLyBpdHMgcHJvZmlsZVxuICAgICAgICAgICAgdXNlckpvYlByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICBjYWNoZTogbmV3IENhY2hlQ29udHJvbCh7IHR0bDogZGVmYXVsdFR0bCB9KSxcbiAgICAgICAgICAgICAgICBsaXN0OiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gSW5kZXhlZCBsaXN0IGJ5IGpvYlRpdGxlSUQgdG8gdGhlIHVzZXIgam9iIHRpdGxlcyBtb2RlbHNcbiAgICAgICAgICAgIC8vIGluIHRoZSBsaXN0IGFuZCBjYWNoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgdXNlckpvYlRpdGxlczogey8qXG4gICAgICAgICAgICAgICAgam9iVGl0bGVJRDogeyBtb2RlbDogb2JqZWN0LCBjYWNoZTogQ2FjaGVDb250cm9sIH1cbiAgICAgICAgICAgICovfVxuICAgICAgICB9O1xuICAgIFxuICAgIC8vIE9ic2VydmFibGUgbGlzdFxuICAgIGFwaS5saXN0ID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbiAgICAvLyBOT1RFOiBCYXNpYyBpbXBsZW1lbnRhdGlvbiwgdG8gZW5oYW5jZVxuICAgIGFwaS5zeW5jTGlzdCA9IGZ1bmN0aW9uIHN5bmNMaXN0KCkge1xuICAgICAgICByZXR1cm4gYXBpLmdldFVzZXJKb2JQcm9maWxlKCkudGhlbihmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICBhcGkubGlzdChsaXN0KTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGFwaS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgY2FjaGUudXNlckpvYlByb2ZpbGUuY2FjaGUubGF0ZXN0ID0gbnVsbDtcbiAgICAgICAgY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdCA9IFtdO1xuICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzID0ge307XG4gICAgfTtcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBpLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAgICBDb252ZXJ0IHJhdyBhcnJheSBvZiBqb2IgdGl0bGVzIHJlY29yZHMgaW50b1xuICAgICAgICBhbiBpbmRleGVkIGFycmF5IG9mIG1vZGVscywgYWN0dWFsbHkgYW4gb2JqZWN0XG4gICAgICAgIHdpdGggSUQgbnVtYmVycyBhcyBwcm9wZXJ0aWVzLFxuICAgICAgICBhbmQgY2FjaGUgaXQgaW4gbWVtb3J5LlxuICAgICoqL1xuICAgIGZ1bmN0aW9uIG1hcFRvVXNlckpvYlByb2ZpbGUocmF3SXRlbXMpIHtcbiAgICAgICAgY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdCA9IFtdO1xuICAgICAgICBjYWNoZS51c2VySm9iVGl0bGVzID0ge307XG5cbiAgICAgICAgaWYgKHJhd0l0ZW1zKSB7XG4gICAgICAgICAgICByYXdJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKHJhd0l0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG5ldyBVc2VySm9iVGl0bGUocmF3SXRlbSk7XG4gICAgICAgICAgICAgICAgY2FjaGUudXNlckpvYlByb2ZpbGUubGlzdC5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIC8vIFNhdmluZyBhbmQgaW5kZXhlZCBjb3B5IGFuZCBwZXIgaXRlbSBjYWNoZSBpbmZvXG4gICAgICAgICAgICAgICAgc2V0R2V0VXNlckpvYlRpdGxlVG9DYWNoZShyYXdJdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBvYnNlcnZhYmxlXG4gICAgICAgIGFwaS5saXN0KGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjYWNoZSBzdGF0ZVxuICAgICAgICBjYWNoZS51c2VySm9iUHJvZmlsZS5jYWNoZS5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3Q7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAgICBHZXQgdGhlIGZ1bGwgam9iUHJvZmlsZSBmcm9tIGxvY2FsIGNvcHksIHRocm93aW5nIGEgUHJvbWlzZSByZWplY3QgZXhjZXB0aW9uIGlmIG5vdGhpbmdcbiAgICAqKi9cbiAgICBmdW5jdGlvbiBnZXRVc2VySm9iUHJvZmlsZUZyb21Mb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZm9yYWdlLmdldEl0ZW0oJ3VzZXJKb2JQcm9maWxlJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odXNlckpvYlByb2ZpbGUpIHtcbiAgICAgICAgICAgIGlmICh1c2VySm9iUHJvZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBUb1VzZXJKb2JQcm9maWxlKHVzZXJKb2JQcm9maWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiBudWxsIHNpbmNlIHRoZXJlIGlzIG5vIGRhdGEsIHRoZSBwcm9taXNlIGNhbiBjYXRjaFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gZGF0YSBhbmQgYXR0ZW1wdCBhIHJlbW90ZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgICAgU2V0IGEgcmF3IHVzZXJKb2JQcm9maWxlIHJlY29yZCAoZnJvbSBzZXJ2ZXIpIGFuZCBzZXQgaXQgaW4gdGhlXG4gICAgICAgIGNhY2hlLCBjcmVhdGluZyBvciB1cGRhdGluZyB0aGUgbW9kZWwgKHNvIGFsbCB0aGUgdGltZSB0aGUgc2FtZSBtb2RlbCBpbnN0YW5jZVxuICAgICAgICBpcyB1c2VkKSBhbmQgY2FjaGUgY29udHJvbCBpbmZvcm1hdGlvbi5cbiAgICAgICAgUmV0dXJucyB0aGUgbW9kZWwgaW5zdGFuY2UuXG4gICAgKiovXG4gICAgZnVuY3Rpb24gc2V0R2V0VXNlckpvYlRpdGxlVG9DYWNoZShyYXdJdGVtKSB7XG4gICAgICAgIHZhciBjID0gY2FjaGUudXNlckpvYlRpdGxlc1tyYXdJdGVtLmpvYlRpdGxlSURdIHx8IHt9O1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG1vZGVsIGlmIGV4aXN0cywgc28gZ2V0IHJlZmxlY3RlZCB0byBhbnlvbmUgY29uc3VtaW5nIGl0XG4gICAgICAgIGlmIChjLm1vZGVsKSB7XG4gICAgICAgICAgICBjLm1vZGVsLm1vZGVsLnVwZGF0ZVdpdGgocmF3SXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCB0aW1lLCBjcmVhdGUgbW9kZWxcbiAgICAgICAgICAgIGMubW9kZWwgPSBuZXcgVXNlckpvYlRpdGxlKHJhd0l0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBjYWNoZSBjb250cm9sXG4gICAgICAgIGlmIChjLmNhY2hlKSB7XG4gICAgICAgICAgICBjLmNhY2hlLmxhdGVzdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjLmNhY2hlID0gbmV3IENhY2hlQ29udHJvbCh7IHR0bDogZGVmYXVsdFR0bCB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwcm9maWxlIGxpc3QsIGFkZCBvciB1cGRhdGU6XG4gICAgICAgIHZhciBmdWxsTGlzdCA9ICBjYWNoZS51c2VySm9iUHJvZmlsZS5saXN0O1xuICAgICAgICBpZiAoZnVsbExpc3QpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IG51bGw7XG4gICAgICAgICAgICBmdWxsTGlzdC5zb21lKGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0LmpvYlRpdGxlSUQoKSA9PT0gcmF3SXRlbS5qb2JUaXRsZUlEKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgZm91bmQubW9kZWwudXBkYXRlV2l0aChyYXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZ1bGxMaXN0LnB1c2goYy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJldHVybiB0aGUgbW9kZWwsIHVwZGF0ZWQgb3IganVzdCBjcmVhdGVkXG4gICAgICAgIHJldHVybiBjLm1vZGVsO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgICAgR2V0IHRoZSBjb250ZW50IGZyb20gdGhlIGNhY2hlLCBmb3IgZnVsbCBwcm9maWxlXG4gICAgICAgIGFuZCBzYXZlIGl0IGluIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgTk9URSBJdCBoYXMgbm8gc2Vuc2UgaW4gY3VycmVudCBpbXBsZW1lbnRhdGlvbiAocHJvYmxlbSBvZiBmZXRjaFxuICAgICAgICBqb2IgdGl0bGUgd2l0aG91dCBhIGZ1bGwgam9iIHByb2ZpbGUgaW4gY2FjaGUvbG9jYWwpXG4gICAgKiovXG4gICAgLypmdW5jdGlvbiBzYXZlQ2FjaGVJbkxvY2FsKCkge1xuICAgICAgICB2YXIgcGxhaW4gPSBjYWNoZS51c2VySm9iUHJvZmlsZS5saXN0Lm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAvLyBFYWNoIGl0ZW0gaXMgYSBtb2RlbCwgZ2V0IGl0IGluIHBsYWluOlxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubW9kZWwudG9QbGFpbk9iamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgndXNlckpvYlByb2ZpbGUnLCBwbGFpbik7XG4gICAgfSovXG4gICAgXG4gICAgLy8gUHJpdmF0ZSwgZmV0Y2ggZnJvbSByZW1vdGVcbiAgICB2YXIgZmV0Y2hVc2VySm9iUHJvZmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcmQgYW5kIGxhc3QsIHJlbW90ZSBsb2FkaW5nXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnbWUvdXNlci1qb2ItcHJvZmlsZScpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgIC8vIENhY2hlIGluIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0oJ3VzZXJKb2JQcm9maWxlJywgcmF3KTtcbiAgICAgICAgICAgIHJldHVybiBtYXBUb1VzZXJKb2JQcm9maWxlKHJhdyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICAgIFB1YmxpYyBBUElcbiAgICAgICAgR2V0IHRoZSBjb21wbGV0ZSBsaXN0IG9mIFVzZXJKb2JUaXRsZSBmb3JcbiAgICAgICAgYWxsIHRoZSBKb2JUaXRsZXMgYXNzaWduZWQgdG8gdGhlIGN1cnJlbnQgdXNlclxuICAgICoqL1xuICAgIGFwaS5nZXRVc2VySm9iUHJvZmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgbm8gY2FjaGUgb3IgbXVzdCByZXZhbGlkYXRlLCBnbyByZW1vdGVcbiAgICAgICAgLy8gKHRoZSBmaXJzdCBsb2FkaW5nIGlzIGV2ZXIgJ211c3QgcmV2YWxpZGF0ZScpXG4gICAgICAgIGlmIChjYWNoZS51c2VySm9iUHJvZmlsZS5jYWNoZS5tdXN0UmV2YWxpZGF0ZSgpKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBjYWNoZSwgaXMgZmlyc3QgbG9hZCwgc28gdHJ5IGxvY2FsXG4gICAgICAgICAgICBpZiAoIWNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2NhbCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFVzZXJKb2JQcm9maWxlRnJvbUxvY2FsKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhdW5jaCByZW1vdGUgZm9yIHN5bmNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZVByb21pc2UgPSBmZXRjaFVzZXJKb2JQcm9maWxlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW90ZSBmYWxsYmFjazogSWYgbm8gbG9jYWwsIHdhaXQgZm9yIHJlbW90ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGEgOiByZW1vdGVQcm9taXNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gY2FjaGUsIG5vIGxvY2FsLCBvciBvYnNvbGV0ZSwgZ28gcmVtb3RlOlxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFVzZXJKb2JQcm9maWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBjYWNoZSBhbmQgaXMgc3RpbGwgdmFsaWQ6XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLnVzZXJKb2JQcm9maWxlLmxpc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBQcml2YXRlLCBmZXRjaCBmcm9tIHJlbW90ZVxuICAgIHZhciBmZXRjaFVzZXJKb2JUaXRsZSA9IGZ1bmN0aW9uKGpvYlRpdGxlSUQpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCdtZS91c2VyLWpvYi1wcm9maWxlLycgKyBqb2JUaXRsZUlEKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyYXcpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgdG8gY2FjaGUgYW5kIGdldCBtb2RlbFxuICAgICAgICAgICAgdmFyIG0gPSBzZXRHZXRVc2VySm9iVGl0bGVUb0NhY2hlKHJhdyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGNhY2hlIHNhdmluZyBmb3Igc2luZ2xlIGpvYi10aXRsZXMsIGN1cnJlbnRseVxuICAgICAgICAgICAgLy8gaXQgbmVlZHMgdG8gc2F2ZSB0aGUgcHJvZmlsZSBjYWNoZSwgdGhhdCBtYXkgbm90IGV4aXN0cyBpZlxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHJlcXVlc3QgaXMgZm9yIGEgc2luZ2xlIGpvYiB0aXRsZS5cbiAgICAgICAgICAgIC8vIE5leHQgbGluZXMgYXJlIHRvIHNhdmUgZnVsbCBwcm9maWxlLCBub3QgdmFsaWQgaGVyZS5cbiAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWxcbiAgICAgICAgICAgIC8vc2F2ZUNhY2hlSW5Mb2NhbCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXR1cm4gbW9kZWxcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBwdXNoTmV3VXNlckpvYlRpdGxlID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBqb2IgdGl0bGUgaW4gcmVtb3RlXG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ21lL3VzZXItam9iLXByb2ZpbGUnLCAkLmV4dGVuZCh7XG4gICAgICAgICAgICBqb2JUaXRsZUlEOiAwLFxuICAgICAgICAgICAgam9iVGl0bGVOYW1lOiAnJyxcbiAgICAgICAgICAgIGludHJvOiAnJyxcbiAgICAgICAgICAgIGNhbmNlbGxhdGlvblBvbGljeUlEOiBudWxsLFxuICAgICAgICAgICAgaW5zdGFudEJvb2tpbmc6IGZhbHNlXG4gICAgICAgIH0sIHZhbHVlcykpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJhdykge1xuICAgICAgICAgICAgLy8gU2F2ZSB0byBjYWNoZSBhbmQgZ2V0IG1vZGVsXG4gICAgICAgICAgICB2YXIgbSA9IHNldEdldFVzZXJKb2JUaXRsZVRvQ2FjaGUocmF3KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgY2FjaGUgc2F2aW5nIGZvciBzaW5nbGUgam9iLXRpdGxlcywgY3VycmVudGx5XG4gICAgICAgICAgICAvLyBpdCBuZWVkcyB0byBzYXZlIHRoZSBwcm9maWxlIGNhY2hlLCB0aGF0IG1heSBub3QgZXhpc3RzIGlmXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgcmVxdWVzdCBpcyBmb3IgYSBzaW5nbGUgam9iIHRpdGxlLlxuICAgICAgICAgICAgLy8gTmV4dCBsaW5lcyBhcmUgdG8gc2F2ZSBmdWxsIHByb2ZpbGUsIG5vdCB2YWxpZCBoZXJlLlxuICAgICAgICAgICAgLy8gU2F2ZSBpbiBsb2NhbFxuICAgICAgICAgICAgLy9zYXZlQ2FjaGVJbkxvY2FsKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJldHVybiBtb2RlbFxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICAgIFB1YmxpYyBBUElcbiAgICAgICAgR2V0IGEgVXNlckpvYlRpdGxlIHJlY29yZCBmb3IgdGhlIGdpdmVuXG4gICAgICAgIEpvYlRpdGxlSUQgYW5kIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgKiovXG4gICAgYXBpLmdldFVzZXJKb2JUaXRsZSA9IGZ1bmN0aW9uIChqb2JUaXRsZUlEKSB7XG4gICAgICAgIC8vIFF1aWNrIGVycm9yXG4gICAgICAgIGlmICgham9iVGl0bGVJRCkgcmV0dXJuIFByb21pc2UucmVqZWN0KCdKb2IgVGl0bGUgSUQgcmVxdWlyZWQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vIGNhY2hlIG9yIG11c3QgcmV2YWxpZGF0ZSwgZ28gcmVtb3RlXG4gICAgICAgIGlmICghY2FjaGUudXNlckpvYlRpdGxlc1tqb2JUaXRsZUlEXSB8fFxuICAgICAgICAgICAgY2FjaGUudXNlckpvYlRpdGxlc1tqb2JUaXRsZUlEXS5jYWNoZS5tdXN0UmV2YWxpZGF0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hVc2VySm9iVGl0bGUoam9iVGl0bGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IGNhY2hlXG4gICAgICAgICAgICBpZiAoY2FjaGUudXNlckpvYlRpdGxlc1tqb2JUaXRsZUlEXSAmJlxuICAgICAgICAgICAgICAgIGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0ubW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLnVzZXJKb2JUaXRsZXNbam9iVGl0bGVJRF0ubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kLCBsb2NhbCBzdG9yYWdlLCB3aGVyZSB3ZSBoYXZlIHRoZSBmdWxsIGpvYiBwcm9maWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFVzZXJKb2JQcm9maWxlRnJvbUxvY2FsKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigvKnVzZXJKb2JQcm9maWxlKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG5lZWQgZm9yIHRoZSBwYXJhbWV0ZXIsIHRoZSBkYXRhIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIG1lbW9yeSBhbmQgaW5kZXhlZCwgbG9vayBmb3IgdGhlIGpvYiB0aXRsZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUudXNlckpvYlRpdGxlc1tqb2JUaXRsZUlEXS5tb2RlbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vIElmIG5vIGxvY2FsIGNvcHkgKGVycm9yIG9uIHByb21pc2UpLFxuICAgICAgICAgICAgICAgIC8vIG9yIHRoYXQgZG9lcyBub3QgY29udGFpbnMgdGhlIGpvYiB0aXRsZSAoZXJyb3Igb24gJ3RoZW4nKTpcbiAgICAgICAgICAgICAgICAvLyBUaGlyZCBhbmQgbGFzdCwgcmVtb3RlIGxvYWRpbmdcbiAgICAgICAgICAgICAgICAuY2F0Y2goZmV0Y2hVc2VySm9iVGl0bGUuYmluZChudWxsLCBqb2JUaXRsZUlEKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBQdXNoIGNoYW5nZXMgdG8gcmVtb3RlLiBTdGF0dXNJRCBjYW4gTk9UIGJlIG1vZGlmaWVkIHdpdGggdGhpcyBBUEksIHVzZSBzcGVjaWZpY1xuICAgICAgICBkZWFjdGl2YXRlL3JlYWN0aXZhdGUgbWV0aG9kc1xuICAgICoqL1xuICAgIGFwaS5zZXRVc2VySm9iVGl0bGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnB1dCgnbWUvdXNlci1qb2ItcHJvZmlsZS8nICsgdmFsdWVzLmpvYlRpdGxlSUQsIHZhbHVlcylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmF3KSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRvIGNhY2hlIGFuZCBnZXQgbW9kZWxcbiAgICAgICAgICAgIHZhciBtID0gc2V0R2V0VXNlckpvYlRpdGxlVG9DYWNoZShyYXcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBjYWNoZSBzYXZpbmcgZm9yIHNpbmdsZSBqb2ItdGl0bGVzLCBjdXJyZW50bHlcbiAgICAgICAgICAgIC8vIGl0IG5lZWRzIHRvIHNhdmUgdGhlIHByb2ZpbGUgY2FjaGUsIHRoYXQgbWF5IG5vdCBleGlzdHMgaWZcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCByZXF1ZXN0IGlzIGZvciBhIHNpbmdsZSBqb2IgdGl0bGUuXG4gICAgICAgICAgICAvLyBOZXh0IGxpbmVzIGFyZSB0byBzYXZlIGZ1bGwgcHJvZmlsZSwgbm90IHZhbGlkIGhlcmUuXG4gICAgICAgICAgICAvLyBTYXZlIGluIGxvY2FsXG4gICAgICAgICAgICAvL3NhdmVDYWNoZUluTG9jYWwoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmV0dXJuIG1vZGVsXG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBhcGkuY3JlYXRlVXNlckpvYlRpdGxlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gcHVzaE5ld1VzZXJKb2JUaXRsZSh2YWx1ZXMpO1xuICAgIH07XG4gICAgXG4gICAgYXBpLmRlYWN0aXZhdGVVc2VySm9iVGl0bGUgPSBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ21lL3VzZXItam9iLXByb2ZpbGUvJyArIChqb2JUaXRsZUlEfDApICsgJy9kZWFjdGl2YXRlJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmF3KSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRvIGNhY2hlIGFuZCBnZXQgbW9kZWxcbiAgICAgICAgICAgIHZhciBtID0gc2V0R2V0VXNlckpvYlRpdGxlVG9DYWNoZShyYXcpO1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgYXBpLnJlYWN0aXZhdGVVc2VySm9iVGl0bGUgPSBmdW5jdGlvbihqb2JUaXRsZUlEKSB7XG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LnBvc3QoJ21lL3VzZXItam9iLXByb2ZpbGUvJyArIChqb2JUaXRsZUlEfDApICsgJy9yZWFjdGl2YXRlJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmF3KSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRvIGNhY2hlIGFuZCBnZXQgbW9kZWxcbiAgICAgICAgICAgIHZhciBtID0gc2V0R2V0VXNlckpvYlRpdGxlVG9DYWNoZShyYXcpO1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqIEFESVRJT05BTCBVVElMSVRJRVMgKiovXG4gICAgYXBpLmdldFVzZXJKb2JUaXRsZUFuZEpvYlRpdGxlID0gZnVuY3Rpb24gZ2V0VXNlckpvYlRpdGxlQW5kSm9iVGl0bGUoam9iVGl0bGVJRCkge1xuICAgICAgICByZXR1cm4gYXBpLmdldFVzZXJKb2JUaXRsZShqb2JUaXRsZUlEKVxuICAgICAgICAudGhlbihmdW5jdGlvbih1c2VySm9iVGl0bGUpIHtcbiAgICAgICAgICAgIC8vIFZlcnkgdW5saWtlbHkgZXJyb3JcbiAgICAgICAgICAgIGlmICghdXNlckpvYlRpdGxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTm90IEZvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExKREk6XG4gICAgICAgICAgICAgICAgICAgICAgICAnWW91IGhhdmUgbm90IHRoaXMgam9iIHRpdGxlIGluIHlvdXIgcHJvZmlsZS4gJyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01heWJlIHdhcyBkZWxldGVkIGZyb20geW91ciBwcm9maWxlIHJlY2VudGx5LidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgam9iIHRpdGxlIGluZm8gdG9vXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHVzZXJKb2JUaXRsZSxcbiAgICAgICAgICAgICAgICBhcHBNb2RlbC5qb2JUaXRsZXMuZ2V0Sm9iVGl0bGUoam9iVGl0bGVJRClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbihhbGwpIHtcbiAgICAgICAgICAgIHZhciBqb2JUaXRsZSA9IGFsbFsxXTtcbiAgICAgICAgICAgIC8vIFZlcnkgdW5saWtlbHkgZXJyb3JcbiAgICAgICAgICAgIGlmICgham9iVGl0bGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdOb3QgRm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBMSkRJOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGpvYiB0aXRsZSBkb2VzIG5vdCBleGlzdC4nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGpvYlRpdGxlSUQ6IGpvYlRpdGxlSUQsXG4gICAgICAgICAgICAgICAgdXNlckpvYlRpdGxlOiBhbGxbMF0sXG4gICAgICAgICAgICAgICAgam9iVGl0bGU6IGpvYlRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBhcGk7XG59O1xuIiwiLyoqIFVzZXJQcm9maWxlXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFVzZXIgPSByZXF1aXJlKCcuLi9tb2RlbHMvVXNlcicpO1xuXG52YXIgUmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9SZW1vdGVNb2RlbCcpLFxuICAgIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcbiAgICB2YXIgcmVtID0gbmV3IFJlbW90ZU1vZGVsKHtcbiAgICAgICAgZGF0YTogVXNlci5uZXdBbm9ueW1vdXMoKSxcbiAgICAgICAgdHRsOiB7IG1pbnV0ZXM6IDEgfSxcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBLZWVwIHRoZSBuYW1lIGluIHN5bmMgd2l0aCBzZXQtdXAgYXQgQXBwTW9kZWwtYWNjb3VudFxuICAgICAgICBsb2NhbFN0b3JhZ2VOYW1lOiAncHJvZmlsZScsXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgnbWUvcHJvZmlsZScpO1xuICAgICAgICB9LFxuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QucHV0KCdtZS9wcm9maWxlJywgdGhpcy5kYXRhLm1vZGVsLnRvUGxhaW5PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBhcHBNb2RlbC5vbignY2xlYXJMb2NhbERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtLmNsZWFyQ2FjaGUoKTtcbiAgICB9KTtcbiAgICBcbiAgICByZW0uc2F2ZU9uYm9hcmRpbmdTdGVwID0gZnVuY3Rpb24gc2F2ZU9uYm9hcmRpbmdTdGVwKHN0ZXBSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZihzdGVwUmVmZXJlbmNlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN0ZXBSZWZlcmVuY2UgPSByZW0uZGF0YS5vbmJvYXJkaW5nU3RlcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtLmRhdGEub25ib2FyZGluZ1N0ZXAoc3RlcFJlZmVyZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5wdXQoJ21lL3Byb2ZpbGUvdHJhY2tpbmcnLCB7XG4gICAgICAgICAgICBvbmJvYXJkaW5nU3RlcDogc3RlcFJlZmVyZW5jZVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIElmIHN1Y2Nlc3MsIHNhdmUgcGVyc2lzdGVudCBsb2NhbCBjb3B5IG9mIHRoZSBkYXRhIHRvIGVuc3VyZSB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBvbmJvYXJkaW5nU3RlcCBpcyBzYXZlZFxuICAgICAgICAgICAgbG9jYWxmb3JhZ2Uuc2V0SXRlbShyZW0ubG9jYWxTdG9yYWdlTmFtZSwgcmVtLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCgpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gcmVtO1xufTtcbiIsIi8qKiBVc2VyIFZlcmlmaWNhdGlvbnNcblxuICAgIFRPRE8gTWF5YmUgdGhlIExpc3RSZW1vdGVNb2RlbCBpcyBub3QgdGhlIG1vc3QgYXBwcm9waWF0ZWQgYmVjYXVzZSBpdCBhbGxvd3MgMSBJRFxuICAgIHdoaWxlIHVzZXItdmVyaWZpY2F0aW9ucyBoYXZlIG11bHRpLUlEIGZpZWxkcyBhbmQgdGhlcmUgaXMgbm8gYW4gaW52aWR1YWwgYWNjZXNzLFxuICAgIGJ1dCBpdCdzIHJlYWxseSBhIGxpc3Qgbm90IGEgZmxhdCBSZW1vdGVNb2RlbC5cbiAgICBOT1RFIE1heSByZXF1aXJlIGEgcXVlcnkgcGVyIGpvYi10aXRsZSBpbiBmdXR1cmU/IE9yIGp1c3QgZmlsdGVyaW5nIHRoZSBsaXN0P1xuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VyVmVyaWZpY2F0aW9uID0gcmVxdWlyZSgnLi4vbW9kZWxzL1VzZXJWZXJpZmljYXRpb24nKSxcbiAgICBMaXN0UmVtb3RlTW9kZWwgPSByZXF1aXJlKCcuLi91dGlscy9MaXN0UmVtb3RlTW9kZWwnKTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcblxuICAgIHZhciBhcGkgPSBuZXcgTGlzdFJlbW90ZU1vZGVsKHtcbiAgICAgICAgbGlzdFR0bDogeyBtaW51dGVzOiAxMCB9LFxuICAgICAgICBpdGVtSWRGaWVsZDogJ3ZlcmlmaWNhdGlvbklEJyxcbiAgICAgICAgTW9kZWw6IFVzZXJWZXJpZmljYXRpb25cbiAgICB9KTtcblxuICAgIGFwaS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQoJ3VzZXItdmVyaWZpY2F0aW9ucycpO1xuICAgIGFwaS5hZGRSZXN0U3VwcG9ydChhcHBNb2RlbC5yZXN0LCAnbWUvdmVyaWZpY2F0aW9ucycpO1xuICAgIFxuICAgIGFwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcGkuY2xlYXJDYWNoZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG4iLCIvKipcbiAgICBRdWVyeSBwdWJsaWMgZGF0YSBmcm9tIG90aGVyIHVzZXJzIGluIHRoZSBtYXJrZXRwbGFjZSxcbiAgICB1c3VhbGx5IGNsaWVudCBmZXRjaGluZyBzZXJ2aWNlIHByb2Zlc3Npb25hbHMgZGF0YVxuICAgIHRvIHZpZXcgcHJvZmlsZSwgYm9vayB0aGVtLCBldGMuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoYXBwTW9kZWwpIHtcbiAgICBcbiAgICB2YXIgYXBpID0ge307XG5cbiAgICAvL2FwcE1vZGVsLm9uKCdjbGVhckxvY2FsRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgIC8vICAgIGFwaS5jbGVhckNhY2hlKCk7XG4gICAgLy99KTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgR2V0IHRoZSB1c2VyIGluZGV4L3N1bW1hcnkgaW5mb3JtYXRpb24uIFRoYXQgaW5jbHVkZXNcbiAgICAgICAgYW4gb2JqZWN0IHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXMgdGhhdCBtYXRjaGVzIHRoZSByZXN1bHRzXG4gICAgICAgIGZyb20gb3RoZXIgaW5kaXZpZHVhbCBBUElzLCB0byBnZXQgaW4gb25lIGNhbGwgaW5mb3JtYXRpb25cbiAgICAgICAgbGlrZSBwcm9maWxlLCByYXRpbmcsIHZlcmlmaWNhdGlvbnNTdW1tYXJ5LCBqb2JQcm9maWxlLlxuICAgICAgICBVc2VmdWxsIHRvIGxvYWQgZmFzdGVyIGEgdXNlciBwdWJsaWMgcHJvZmlsZSwgc2VydmljZSBwcm9mZXNzaW9uYWxcbiAgICAgICAgaW5mb3JtYXRpb24gdG8gc3RhcnQgYSBib29raW5nIHByb2Nlc3Mgb3IgdGhlIHVzZXIgaW5mb3JtYXRpb25cbiAgICAgICAgd2lkZ2V0cy5cbiAgICAqKi9cbiAgICBhcGkuZ2V0VXNlciA9IGZ1bmN0aW9uKHVzZXJJRCkge1xuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ3VzZXJzLycgKyAodXNlcklEIHwwKSk7XG4gICAgfTtcbiAgICBcbiAgICBhcGkuZ2V0UHJvZmlsZSA9IGZ1bmN0aW9uKHVzZXJJRCkge1xuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ3VzZXJzLycgKyAodXNlcklEIHwwKSArICcvcHJvZmlsZScpO1xuICAgIH07XG4gICAgXG4gICAgYXBpLmdldEpvYlByb2ZpbGUgPSBmdW5jdGlvbih1c2VySUQpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2Vycy8nICsgKHVzZXJJRCB8MCkgKyAnL2pvYi1wcm9maWxlJyk7XG4gICAgfTtcbiAgICBhcGkuZ2V0Sm9iVGl0bGUgPSBmdW5jdGlvbih1c2VySUQsIGpvYlRpdGxlSUQpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2Vycy8nICsgKHVzZXJJRCB8MCkgKyAnL2pvYi1wcm9maWxlLycgKyAoam9iVGl0bGVJRCB8MCkpO1xuICAgIH07XG4gICAgXG4gICAgLy8gVE9ETyBSRU1PVkUgVEhJUyBPTEQ/PyBSRVBMQUNFRCBCWSBTRVJWRVItU0lERSBBcHBNb2RlbC5hdmFpbGFiaWxpdHk/XG4gICAgdmFyIGdldEF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIGdldEF2YWlsYWJpbGl0eSh1c2VySUQsIGZvcm1hdCwgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2Vycy8nICsgKHVzZXJJRCB8MCkgKyAnL2F2YWlsYWJpbGl0eS8nICsgZm9ybWF0LCBxdWVyeSk7XG4gICAgfTtcbiAgICBhcGkuZ2V0QXZhaWxhYmlsaXR5UGVyRGF0ZSA9IGZ1bmN0aW9uKHVzZXJJRCwgc3RhcnREYXRlLCBlbmREYXRlKSB7XG4gICAgICAgIHJldHVybiBnZXRBdmFpbGFiaWxpdHkodXNlcklELCAnZGF0ZXMnLCB7IHN0YXJ0OiBzdGFydERhdGUsIGVuZDogZW5kRGF0ZSB9KTtcbiAgICB9O1xuICAgIGFwaS5nZXRBdmFpbGFiaWxpdHlJbnNTbG90cyA9IGZ1bmN0aW9uKHVzZXJJRCwgc3RhcnREYXRlLCBlbmREYXRlKSB7XG4gICAgICAgIHJldHVybiBnZXRBdmFpbGFiaWxpdHkodXNlcklELCAnc2xvdHMnLCB7IHN0YXJ0OiBzdGFydERhdGUsIGVuZDogZW5kRGF0ZSB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFJhdGluZ3MgPSBmdW5jdGlvbiBnZXRSYXRpbmdzKG1vZGlmaWVyLCB1c2VySUQpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2Vycy8nICsgKHVzZXJJRCB8MCkgKyAnL3JhdGluZ3MnICsgKG1vZGlmaWVyID8gJy8nICsgbW9kaWZpZXIgOiAnJykpO1xuICAgIH07XG4gICAgYXBpLmdldFVzZXJSYXRpbmdzID0gZ2V0UmF0aW5ncy5iaW5kKGFwaSwgbnVsbCk7XG4gICAgYXBpLmdldENsaWVudFJhdGluZ3MgPSBnZXRSYXRpbmdzLmJpbmQoYXBpLCAnY2xpZW50Jyk7XG4gICAgYXBpLmdldFNlcnZpY2VQcm9mZXNzaW9uYWxSYXRpbmdzID0gZ2V0UmF0aW5ncy5iaW5kKGFwaSwgJ3NlcnZpY2UtcHJvZmVzc2lvbmFsJyk7XG4gICAgYXBpLmdldEpvYlRpdGxlUmF0aW5ncyA9IGZ1bmN0aW9uKHVzZXJJRCwgam9iVGl0bGVJRCkgeyByZXR1cm4gZ2V0UmF0aW5ncyhqb2JUaXRsZUlEIHwwLCB1c2VySUQpOyB9O1xuICAgIFxuICAgIGFwaS5nZXRTZXJ2aWNlQWRkcmVzc2VzID0gZnVuY3Rpb24odXNlcklELCBqb2JUaXRsZUlEKSB7XG4gICAgICAgIHJldHVybiBhcHBNb2RlbC5yZXN0LmdldCgndXNlcnMvJyArICh1c2VySUQgfDApICsgJy9zZXJ2aWNlLWFkZHJlc3Nlcy8nICsgKGpvYlRpdGxlSUQgfDApKTtcbiAgICB9O1xuXG4gICAgYXBpLmdldFNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcyA9IGZ1bmN0aW9uKHNlcnZpY2VQcm9mZXNzaW9uYWxVc2VySUQsIGpvYlRpdGxlSUQpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2Vycy8nICsgKHNlcnZpY2VQcm9mZXNzaW9uYWxVc2VySUQgfDApICsgJy9zZXJ2aWNlLXByb2Zlc3Npb25hbC1zZXJ2aWNlcy8nICsgKGpvYlRpdGxlSUQgfDApKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXRWZXJpZmljYXRpb25zU3VtbWFyeSA9IGZ1bmN0aW9uIGdldFZlcmlmaWNhdGlvbnNTdW1tYXJ5KG1vZGlmaWVyLCB1c2VySUQpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1vZGVsLnJlc3QuZ2V0KCd1c2Vycy8nICsgKHVzZXJJRCB8MCkgKyAnL3ZlcmlmaWNhdGlvbnMtc3VtbWFyeScgKyAobW9kaWZpZXIgPyAnLycgKyBtb2RpZmllciA6ICcnKSk7XG4gICAgfTtcbiAgICBhcGkuZ2V0VXNlclZlcmlmaWNhdGlvbnNTdW1tYXJ5ID0gZ2V0VmVyaWZpY2F0aW9uc1N1bW1hcnkuYmluZChhcGksIG51bGwpO1xuICAgIGFwaS5nZXRDbGllbnRWZXJpZmljYXRpb25zU3VtbWFyeSA9IGdldFZlcmlmaWNhdGlvbnNTdW1tYXJ5LmJpbmQoYXBpLCAnY2xpZW50Jyk7XG4gICAgYXBpLmdldFNlcnZpY2VQcm9mZXNzaW9uYWxWZXJpZmljYXRpb25zU3VtbWFyeSA9IGdldFZlcmlmaWNhdGlvbnNTdW1tYXJ5LmJpbmQoYXBpLCAnc2VydmljZS1wcm9mZXNzaW9uYWwnKTtcbiAgICBhcGkuZ2V0Sm9iVGl0bGVWZXJpZmljYXRpb25zU3VtbWFyeSA9IGZ1bmN0aW9uKHVzZXJJRCwgam9iVGl0bGVJRCkgeyByZXR1cm4gZ2V0VmVyaWZpY2F0aW9uc1N1bW1hcnkoam9iVGl0bGVJRCB8MCwgdXNlcklEKTsgfTtcblxuICAgIGFwaS5nZXRTZXJ2aWNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIGdldFNlcnZpY2VBdHRyaWJ1dGVzKHVzZXJJRCwgam9iVGl0bGVJRCkge1xuICAgICAgICByZXR1cm4gYXBwTW9kZWwucmVzdC5nZXQoJ3VzZXJzLycgKyAodXNlcklEIHwwKSArICcvc2VydmljZS1hdHRyaWJ1dGVzLycgKyAoam9iVGl0bGVJRCB8MCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xufTsiLCIvKipcbiAgICBBY3Rpdml0eSBiYXNlIGNsYXNzXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBOYXZBY3Rpb24gPSByZXF1aXJlKCcuLi92aWV3bW9kZWxzL05hdkFjdGlvbicpLFxuICAgIE5hdkJhciA9IHJlcXVpcmUoJy4uL3ZpZXdtb2RlbHMvTmF2QmFyJyk7XG5cbnJlcXVpcmUoJy4uL3V0aWxzL0Z1bmN0aW9uLnByb3RvdHlwZS5faW5oZXJpdHMnKTtcblxuLyoqXG4gICAgQWN0aXZpdHkgY2xhc3MgZGVmaW5pdGlvblxuKiovXG5mdW5jdGlvbiBBY3Rpdml0eSgkYWN0aXZpdHksIGFwcCkge1xuXG4gICAgdGhpcy4kYWN0aXZpdHkgPSAkYWN0aXZpdHk7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG5cbiAgICAvLyBEZWZhdWx0IGFjY2VzcyBsZXZlbDogYW55b25lXG4gICAgLy8gQWN0aXZpdGllcyBjYW4gdXNlIHRoZSBlbnVtZXJhdGlvbjogdGhpcy5hcHAuVXNlclR5cGVcbiAgICB0aGlzLmFjY2Vzc0xldmVsID0gbnVsbDsgXG4gICAgXG4gICAgLy8gVE9ETzogRnV0dXJlIHVzZSBvZiBhIHZpZXdTdGF0ZSwgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAgLy8gb2YgcGFydCBvZiB0aGUgdmlld01vZGVsIHRvIGJlIHVzZWQgYXMgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVcbiAgICAvLyBoaXN0b3J5IGFuZCBiZXR3ZWVuIGFjdGl2aXRpZXMgY2FsbHMuXG4gICAgdGhpcy52aWV3U3RhdGUgPSB7fTtcbiAgICBcbiAgICAvLyBPYmplY3QgdG8gaG9sZCB0aGUgb3B0aW9ucyBwYXNzZWQgb24gJ3Nob3cnIGFzIGEgcmVzdWx0XG4gICAgLy8gb2YgYSByZXF1ZXN0IGZyb20gYW5vdGhlciBhY3Rpdml0eVxuICAgIHRoaXMucmVxdWVzdERhdGEgPSBudWxsO1xuXG4gICAgLy8gRGVmYXVsdCBuYXZCYXIgb2JqZWN0LlxuICAgIHRoaXMubmF2QmFyID0gbmV3IE5hdkJhcih7XG4gICAgICAgIHRpdGxlOiBudWxsLCAvLyBudWxsIGZvciBsb2dvXG4gICAgICAgIGxlZnRBY3Rpb246IG51bGwsXG4gICAgICAgIHJpZ2h0QWN0aW9uOiBudWxsXG4gICAgfSk7XG4gICAgXG4gICAgLy8gS25vY2tvdXQgYmluZGluZyBvZiB2aWV3U3RhdGUgZGVsYXllZCB0byBmaXJzdCBzaG93XG4gICAgLy8gdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCBzdWJjbGFzc2VzIHJlcGxhY2luZyB0aGUgdmlld1N0YXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aXZpdHk7XG5cbi8qKlxuICAgIFNldC11cCB2aXN1YWxpemF0aW9uIG9mIHRoZSB2aWV3IHdpdGggdGhlIGdpdmVuIG9wdGlvbnMvc3RhdGUsXG4gICAgd2l0aCBhIHJlc2V0IG9mIGN1cnJlbnQgc3RhdGUuXG4gICAgTXVzdCBiZSBleGVjdXRlZCBldmVyeSB0aW1lIHRoZSBhY3Rpdml0eSBpcyBwdXQgaW4gdGhlIGN1cnJlbnQgdmlldy5cbioqL1xuQWN0aXZpdHkucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93KG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBtdXN0IGtlZXAgdmlld1N0YXRlIHVwIHRvIGRhdGUgdXNpbmcgb3B0aW9ucy9zdGF0ZS5cbiAgICAvL2NvbnNvbGUubG9nKCdBY3Rpdml0eSBzaG93JywgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICBpZiAoIXRoaXMuX19iaW5kaW5nRG9uZSkge1xuICAgICAgICAvLyBBIHZpZXcgbW9kZWwgYW5kIGJpbmRpbmdzIGJlaW5nIGFwcGxpZWQgaXMgZXZlciByZXF1aXJlZFxuICAgICAgICAvLyBldmVuIG9uIEFjdGl2aXRpZXMgd2l0aG91dCBuZWVkIGZvciBhIHZpZXcgbW9kZWwsIHNpbmNlXG4gICAgICAgIC8vIHRoZSB1c2Ugb2YgY29tcG9uZW50cyBhbmQgdGVtcGxhdGVzLCBvciBhbnkgb3RoZXIgZGF0YS1iaW5kXG4gICAgICAgIC8vIHN5bnRheCwgcmVxdWlyZXMgdG8gYmUgaW4gYSBjb250ZXh0IHdpdGggYmluZGluZyBlbmFibGVkOlxuICAgICAgICBrby5hcHBseUJpbmRpbmdzKHRoaXMudmlld01vZGVsIHx8IHt9LCB0aGlzLiRhY3Rpdml0eS5nZXQoMCkpO1xuICAgICAgICB0aGlzLl9fYmluZGluZ0RvbmUgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnJlcXVlc3REYXRhID0gb3B0aW9ucztcbiAgICBcbiAgICAvLyBFbmFibGUgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuICAgIC8vIFZhbGlkYXRpb24gb2YgZWFjaCBzZXR0aW5ncyBvYmplY3QgaXMgcGVyZm9ybWVkXG4gICAgLy8gb24gcmVnaXN0ZXJlZCwgYXZvaWRlZCBoZXJlLlxuICAgIGlmICh0aGlzLl9oYW5kbGVycyAmJlxuICAgICAgICB0aGlzLl9oYW5kbGVyc0FyZUNvbm5lY3RlZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpcyBhbiBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5ldmVudCAmJiBzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNldHRpbmdzLnRhcmdldC5zdWJzY3JpYmUoc2V0dGluZ3MuaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgLy8gT2JzZXJ2YWJsZXMgaGFzIG5vdCBhICd1bnN1YnNjcmliZScgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgLy8gdGhleSByZXR1cm4gYW4gb2JqZWN0IHRoYXQgbXVzdCBiZSAnZGlzcG9zZWQnLlxuICAgICAgICAgICAgICAgIC8vIFNhdmluZyB0aGF0IHdpdGggc2V0dGluZ3MgdG8gYWxsb3cgJ3Vuc3Vic2NyaWJlJyBsYXRlci5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5fc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5tZWRpYXRlIGV4ZWN1dGlvbjogaWYgY3VycmVudCBvYnNlcnZhYmxlIHZhbHVlIGlzIGRpZmZlcmVudFxuICAgICAgICAgICAgICAgIC8vIHRoYW4gcHJldmlvdXMgb25lLCBleGVjdXRlIHRoZSBoYW5kbGVyOlxuICAgICAgICAgICAgICAgIC8vICh0aGlzIGF2b2lkIHRoYXQgYSBjaGFuZ2VkIHN0YXRlIGdldCBvbWl0dGVkIGJlY2F1c2UgaGFwcGVuZWRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHN1YnNjcmlwdGlvbiB3YXMgb2ZmOyBpdCBtZWFucyBhIGZpcnN0IHRpbWUgZXhlY3V0aW9uIHRvbykuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogJ3VuZGVmaW5lZCcgdmFsdWUgb24gb2JzZXJ2YWJsZSBtYXkgY2F1c2UgdGhpcyB0byBmYWxsXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLl9sYXRlc3RTdWJzY3JpYmVkVmFsdWUgIT09IHNldHRpbmdzLnRhcmdldCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhhbmRsZXIuY2FsbChzZXR0aW5ncy50YXJnZXQsIHNldHRpbmdzLnRhcmdldCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnRhcmdldC5vbihzZXR0aW5ncy5ldmVudCwgc2V0dGluZ3Muc2VsZWN0b3IsIHNldHRpbmdzLmhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MudGFyZ2V0Lm9uKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudGFyZ2V0Lm9uKHNldHRpbmdzLmV2ZW50LCBzZXR0aW5ncy5oYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjdGl2aXR5LnNob3c6IEJhZCByZWdpc3RlcmVkIGhhbmRsZXInLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUbyBhdm9pZCBkb3VibGUgY29ubmVjdGlvbnM6XG4gICAgICAgIC8vIE5PVEU6IG1heSBoYXBwZW4gdGhhdCAnc2hvdycgZ2V0cyBjYWxsZWQgc2V2ZXJhbCB0aW1lcyB3aXRob3V0IGEgJ2hpZGUnXG4gICAgICAgIC8vIGluIGJldHdlZW4sIGJlY2F1c2UgJ3Nob3cnIGFjdHMgYXMgYSByZWZyZXNoZXIgcmlnaHQgbm93IGV2ZW4gZnJvbSBzZWdtZW50XG4gICAgICAgIC8vIGNoYW5nZXMgZnJvbSB0aGUgc2FtZSBhY3Rpdml0eS5cbiAgICAgICAgdGhpcy5faGFuZGxlcnNBcmVDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICAgIFBlcmZvcm0gdGFza3MgdG8gc3RvcCBhbnl0aGluZyBydW5uaW5nIG9yIHN0b3AgaGFuZGxlcnMgZnJvbSBsaXN0ZW5pbmcuXG4gICAgTXVzdCBiZSBleGVjdXRlZCBldmVyeSB0aW1lIHRoZSBhY3Rpdml0eSBpcyBoaWRkZW4vcmVtb3ZlZCBcbiAgICBmcm9tIHRoZSBjdXJyZW50IHZpZXcuXG4qKi9cbkFjdGl2aXR5LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICBcbiAgICAvLyBEaXNhYmxlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgICBpZiAodGhpcy5faGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihzZXR0aW5ncykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYW4gb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX3N1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBsYXRlc3Qgb2JzZXJ2YWJsZSB2YWx1ZSB0byBtYWtlIGEgY29tcGFyaXNpb25cbiAgICAgICAgICAgICAgICAvLyBuZXh0IHRpbWUgaXMgZW5hYmxlZCB0byBlbnN1cmUgaXMgZXhlY3V0ZWQgaWYgdGhlcmUgd2FzXG4gICAgICAgICAgICAgICAgLy8gYSBjaGFuZ2Ugd2hpbGUgZGlzYWJsZWQ6XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX2xhdGVzdFN1YnNjcmliZWRWYWx1ZSA9IHNldHRpbmdzLnRhcmdldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MudGFyZ2V0Lm9mZikge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudGFyZ2V0Lm9mZihzZXR0aW5ncy5ldmVudCwgc2V0dGluZ3Muc2VsZWN0b3IsIHNldHRpbmdzLmhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudGFyZ2V0Lm9mZihzZXR0aW5ncy5ldmVudCwgc2V0dGluZ3MuaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy50YXJnZXQucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy50YXJnZXQucmVtb3ZlTGlzdGVuZXIoc2V0dGluZ3MuZXZlbnQsIHNldHRpbmdzLmhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQWN0aXZpdHkuaGlkZTogQmFkIHJlZ2lzdGVyZWQgaGFuZGxlcicsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9oYW5kbGVyc0FyZUNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICAgIFJlZ2lzdGVyIGEgaGFuZGxlciB0aGF0IGFjdHMgb24gYW4gZXZlbnQgb3Igc3Vic2NyaXB0aW9uIG5vdGlmaWNhdGlvbixcbiAgICB0aGF0IHdpbGwgYmUgZW5hYmxlZCBvbiBBY3Rpdml0eS5zaG93IGFuZCBkaXNhYmxlZCBvbiBBY3Rpdml0eS5oaWRlLlxuXG4gICAgQHBhcmFtIHNldHRpbmdzOm9iamVjdCB7XG4gICAgICAgIHRhcmdldDogalF1ZXJ5LCBFdmVudEVtaXR0ZXIsIEtub2Nrb3V0Lm9ic2VydmFibGUuIFJlcXVpcmVkXG4gICAgICAgIGV2ZW50OiBzdHJpbmcuIEV2ZW50IG5hbWUgKGNhbiBoYXZlIG5hbWVzcGFjZXMsIHNldmVyYWwgZXZlbnRzIGFsbG93ZWQpLiBJdHMgcmVxdWlyZWQgZXhjZXB0IHdoZW4gdGhlIHRhcmdldCBpcyBhbiBvYnNlcnZhYmxlLCB0aGVyZSBtdXN0XG4gICAgICAgICAgICBiZSBvbWl0dGVkLlxuICAgICAgICBoYW5kbGVyOiBGdW5jdGlvbi4gUmVxdWlyZWQsXG4gICAgICAgIHNlbGVjdG9yOiBzdHJpbmcuIE9wdGlvbmFsLiBGb3IgalF1ZXJ5IGV2ZW50cyBvbmx5LCBwYXNzZWQgYXMgdGhlXG4gICAgICAgICAgICBzZWxlY3RvciBmb3IgZGVsZWdhdGVkIGhhbmRsZXJzLlxuICAgIH1cbioqL1xuQWN0aXZpdHkucHJvdG90eXBlLnJlZ2lzdGVySGFuZGxlciA9IGZ1bmN0aW9uIHJlZ2lzdGVySGFuZGxlcihzZXR0aW5ncykge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6OCAqL1xuICAgIFxuICAgIGlmICghc2V0dGluZ3MpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVnaXN0ZXIgcmVxdWlyZSBhIHNldHRpbmdzIG9iamVjdCcpO1xuICAgIFxuICAgIGlmICghc2V0dGluZ3MudGFyZ2V0IHx8ICghc2V0dGluZ3MudGFyZ2V0Lm9uICYmICFzZXR0aW5ncy50YXJnZXQuc3Vic2NyaWJlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgaXMgbnVsbCBvciBub3QgYSBqUXVlcnksIEV2ZW50RW1taXRlciBvciBPYnNlcnZhYmxlIG9iamVjdCcpO1xuICAgIFxuICAgIGlmICh0eXBlb2Yoc2V0dGluZ3MuaGFuZGxlcikgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFzZXR0aW5ncy5ldmVudCAmJiAhc2V0dGluZ3MudGFyZ2V0LnN1YnNjcmliZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IGlzIG51bGw7IGl0XFwncyByZXF1aXJlZCBmb3Igbm9uIG9ic2VydmFibGUgb2JqZWN0cycpO1xuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMgfHwgW107XG5cbiAgICB0aGlzLl9oYW5kbGVycy5wdXNoKHNldHRpbmdzKTtcbn07XG5cbi8qKlxuICAgIFN0YXRpYyB1dGlsaXRpZXNcbioqL1xuLy8gRm9yIGNvbW1vZGl0eSwgY29tbW9uIGNsYXNzZXMgYXJlIGV4cG9zZWQgYXMgc3RhdGljIHByb3BlcnRpZXNcbkFjdGl2aXR5Lk5hdkJhciA9IE5hdkJhcjtcbkFjdGl2aXR5Lk5hdkFjdGlvbiA9IE5hdkFjdGlvbjtcblxuLy8gUXVpY2sgY3JlYXRpb24gb2YgY29tbW9uIHR5cGVzIG9mIE5hdkJhclxuQWN0aXZpdHkuY3JlYXRlU2VjdGlvbk5hdkJhciA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25OYXZCYXIodGl0bGUpIHtcbiAgICByZXR1cm4gbmV3IE5hdkJhcih7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgbGVmdEFjdGlvbjogTmF2QWN0aW9uLm1lbnVJbixcbiAgICAgICAgcmlnaHRBY3Rpb246IE5hdkFjdGlvbi5tZW51TmV3SXRlbVxuICAgIH0pO1xufTtcblxuQWN0aXZpdHkuY3JlYXRlU3Vic2VjdGlvbk5hdkJhciA9IGZ1bmN0aW9uIGNyZWF0ZVN1YnNlY3Rpb25OYXZCYXIodGl0bGUsIG9wdGlvbnMpIHtcbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBcbiAgICB2YXIgZ29CYWNrT3B0aW9ucyA9IHtcbiAgICAgICAgdGV4dDogdGl0bGUsXG4gICAgICAgIGlzVGl0bGU6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYmFja0xpbmspIHtcbiAgICAgICAgZ29CYWNrT3B0aW9ucy5saW5rID0gb3B0aW9ucy5iYWNrTGluaztcbiAgICAgICAgZ29CYWNrT3B0aW9ucy5pc1NoZWxsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBOYXZCYXIoe1xuICAgICAgICB0aXRsZTogJycsIC8vIE5vIHRpdGxlXG4gICAgICAgIGxlZnRBY3Rpb246IE5hdkFjdGlvbi5nb0JhY2subW9kZWwuY2xvbmUoZ29CYWNrT3B0aW9ucyksXG4gICAgICAgIHJpZ2h0QWN0aW9uOiBvcHRpb25zLmhlbHBJZCA/XG4gICAgICAgICAgICBOYXZBY3Rpb24uZ29IZWxwSW5kZXgubW9kZWwuY2xvbmUoe1xuICAgICAgICAgICAgICAgIGxpbms6ICcjJyArIG9wdGlvbnMuaGVscElkXG4gICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICBOYXZBY3Rpb24uZ29IZWxwSW5kZXhcbiAgICB9KTtcbn07XG5cbkFjdGl2aXR5LnByb3RvdHlwZS5jcmVhdGVDYW5jZWxBY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVDYW5jZWxBY3Rpb24oY2FuY2VsTGluaywgc3RhdGUpIHtcbiAgICBcbiAgICB2YXIgYXBwID0gdGhpcy5hcHA7XG4gICAgXG4gICAgdmFyIGFjdGlvbiA9IG5ldyBOYXZBY3Rpb24oe1xuICAgICAgICBsaW5rOiBjYW5jZWxMaW5rLFxuICAgICAgICB0ZXh0OiAnY2FuY2VsJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rKCksXG4gICAgICAgICAgICAgICAgZW9wdGlvbnMgPSBldmVudCAmJiBldmVudC5vcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZ29MaW5rID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspXG4gICAgICAgICAgICAgICAgICAgIGFwcC5zaGVsbC5nbyhsaW5rLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhcHAuc2hlbGwuZ29CYWNrKHN0YXRlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEEgc2lsZW50TW9kZSBwYXNzZWQgdG8gdGhlIGV2ZW50IHJlcXVpcmVzXG4gICAgICAgICAgICAvLyBhdm9pZCB0aGUgbW9kYWwgKHVzZWQgd2hlbiBleGVjdXRpbmcgYSBzYXZpbmcgdGFzayBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgIGlmIChlb3B0aW9ucy5zaWxlbnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgZ29MaW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIEwxOE5cbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBcmUgeW91IHN1cmU/JyxcbiAgICAgICAgICAgICAgICAgICAgeWVzOiAnWWVzJyxcbiAgICAgICAgICAgICAgICAgICAgbm86ICdObydcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25maXJtZWQgY2FuY2VsbGF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBnb0xpbmsoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFjdGlvbjtcbn07XG5cbkFjdGl2aXR5LnByb3RvdHlwZS5jb252ZXJ0VG9DYW5jZWxBY3Rpb24gPSBmdW5jdGlvbiBjb252ZXJ0VG9DYW5jZWxBY3Rpb24oYWN0aW9uTW9kZWwsIGNhbmNlbExpbmspIHtcbiAgICB2YXIgY2FuY2VsID0gdGhpcy5jcmVhdGVDYW5jZWxBY3Rpb24oY2FuY2VsTGluayk7XG4gICAgYWN0aW9uTW9kZWwubW9kZWwudXBkYXRlV2l0aChjYW5jZWwpO1xuICAgIC8vIERVREU6IGhhbmRsZXIgaXMgY3BpZWQgYnkgdXBkYXRlV2l0aD9cbiAgICBhY3Rpb25Nb2RlbC5oYW5kbGVyKGNhbmNlbC5oYW5kbGVyKCkpO1xufTtcblxuLyoqXG4gICAgU2luZ2xldG9uIGhlbHBlclxuKiovXG52YXIgc2luZ2xlbnRvbkluc3RhbmNlcyA9IHt9O1xudmFyIGNyZWF0ZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbihBY3Rpdml0eUNsYXNzLCAkYWN0aXZpdHksIGFwcCkge1xuICAgIFxuICAgIGlmIChzaW5nbGVudG9uSW5zdGFuY2VzW0FjdGl2aXR5Q2xhc3MubmFtZV0gaW5zdGFuY2VvZiBBY3Rpdml0eUNsYXNzKSB7XG4gICAgICAgIHJldHVybiBzaW5nbGVudG9uSW5zdGFuY2VzW0FjdGl2aXR5Q2xhc3MubmFtZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcyA9IG5ldyBBY3Rpdml0eUNsYXNzKCRhY3Rpdml0eSwgYXBwKTtcbiAgICAgICAgc2luZ2xlbnRvbkluc3RhbmNlc1tBY3Rpdml0eUNsYXNzLm5hbWVdID0gcztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufTtcbi8vIEV4YW1wbGUgb2YgdXNlXG4vL2V4cG9ydHMuaW5pdCA9IGNyZWF0ZVNpbmdsZXRvbi5iaW5kKG51bGwsIEFjdGl2aXR5Q2xhc3MpO1xuXG4vKipcbiAgICBTdGF0aWMgbWV0aG9kIGV4dGVuZHMgdG8gaGVscCBpbmhlcml0YW5jZS5cbiAgICBBZGRpdGlvbmFsbHksIGl0IGFkZHMgYSBzdGF0aWMgaW5pdCBtZXRob2QgcmVhZHkgZm9yIHRoZSBuZXcgY2xhc3NcbiAgICB0aGF0IGdlbmVyYXRlcy9yZXRyaWV2ZXMgdGhlIHNpbmdsZXRvbi5cbioqL1xuQWN0aXZpdHkuZXh0ZW5kcyA9IGZ1bmN0aW9uIGV4dGVuZHNBY3Rpdml0eShDbGFzc0ZuKSB7XG4gICAgXG4gICAgQ2xhc3NGbi5faW5oZXJpdHMoQWN0aXZpdHkpO1xuICAgIFxuICAgIENsYXNzRm4uaW5pdCA9IGNyZWF0ZVNpbmdsZXRvbi5iaW5kKG51bGwsIENsYXNzRm4pO1xuICAgIFxuICAgIHJldHVybiBDbGFzc0ZuO1xufTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGF0ZVBpY2tlciBKUyBDb21wb25lbnQsIHdpdGggc2V2ZXJhbFxuICogbW9kZXMgYW5kIG9wdGlvbmFsIGlubGluZS1wZXJtYW5lbnQgdmlzdWFsaXphdGlvbi5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBMb2Nvbm9taWNzIENvb3AuXG4gKlxuICogQmFzZWQgb246XG4gKiBib290c3RyYXAtZGF0ZXBpY2tlci5qcyBcbiAqIGh0dHA6Ly93d3cuZXllY29uLnJvL2Jvb3RzdHJhcC1kYXRlcGlja2VyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDEyIFN0ZWZhbiBQZXRyZVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7IFxuXG52YXIgY2xhc3NlcyA9IHtcbiAgICBjb21wb25lbnQ6ICdEYXRlUGlja2VyJyxcbiAgICBtb250aHM6ICdEYXRlUGlja2VyLW1vbnRocycsXG4gICAgZGF5czogJ0RhdGVQaWNrZXItZGF5cycsXG4gICAgbW9udGhEYXk6ICdkYXknLFxuICAgIG1vbnRoOiAnbW9udGgnLFxuICAgIHllYXI6ICd5ZWFyJyxcbiAgICB5ZWFyczogJ0RhdGVQaWNrZXIteWVhcnMnLFxuICAgIHdlZWtEYXlzOiAnRGF0ZVBpY2tlci13ZWVrRGF5cycsXG4gICAgYWN0aXZlOiAnYWN0aXZlJ1xufTtcblxudmFyIGV2ZW50cyA9IHtcbiAgICBkYXlSZW5kZXJlZDogJ2RheVJlbmRlcmVkJyxcbiAgICBkYXRlQ2hhbmdlZDogJ2RhdGVDaGFuZ2VkJyxcbiAgICBzaG93OiAnc2hvdycsXG4gICAgaGlkZTogJ2hpZGUnLFxuICAgIGRhdGVTZXQ6ICdkYXRlU2V0JyxcbiAgICAvLyBJTVBPUlRBTlQ6IFRyaWdnZXJlZCBhZnRlciBhIHZhbHVlIGlzIHNldCBvciB1cGRhdGVkIGluIHRoZSB2aWV3RGF0ZSBwcm9wZXJ0eVxuICAgIC8vIHdpdGhvdXQgY2hlY2sgaWYgdGhlIHNhbWUgb3Igbm90IChidXQgb3BlcmF0aW9ucyB1cGRhdGluZyBpdCBoYXBwZW5zIG9uIGEgY2hhbmdlKVxuICAgIC8vIEFORCBhZnRlciBpcyBjaGFuZ2VkIGFuZCBjYWxlbmRhciBmaWxsZWQgKGZpbGwgbWV0aG9kIGNhbGxlZCwgc28gRE9NIHJlZmxlY3RzIHRoZSBuZXcgdmlld0RhdGUpLlxuICAgIHZpZXdEYXRlQ2hhbmdlZDogJ3ZpZXdEYXRlQ2hhbmdlZCdcbn07XG5cbnZhciBEUEdsb2JhbCA9IHtcbiAgICBtb2RlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBjbHNOYW1lOiAnZGF5cycsXG4gICAgICAgICAgICBuYXZGbmM6ICdNb250aCcsXG4gICAgICAgICAgICBuYXZTdGVwOiAxXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsc05hbWU6ICdtb250aHMnLFxuICAgICAgICAgICAgbmF2Rm5jOiAnRnVsbFllYXInLFxuICAgICAgICAgICAgbmF2U3RlcDogMVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBjbHNOYW1lOiAneWVhcnMnLFxuICAgICAgICAgICAgbmF2Rm5jOiAnRnVsbFllYXInLFxuICAgICAgICAgICAgbmF2U3RlcDogMTBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xzTmFtZTogJ2RheScsXG4gICAgICAgICAgICBuYXZGbmM6ICdEYXRlJyxcbiAgICAgICAgICAgIG5hdlN0ZXA6IDFcbiAgICAgICAgfVxuICAgIF0sXG4gICAgZGF0ZXM6e1xuICAgICAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiLCBcIlN1bmRheVwiXSxcbiAgICAgICAgZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl0sXG4gICAgICAgIGRheXNNaW46IFtcIlN1XCIsIFwiTVwiLCBcIlR1XCIsIFwiV1wiLCBcIlRoXCIsIFwiRlwiLCBcIlNhXCIsIFwiU3VcIl0sXG4gICAgICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgICAgIG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbiAgICB9LFxuICAgIGlzTGVhcFllYXI6IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoKCh5ZWFyICUgNCA9PT0gMCkgJiYgKHllYXIgJSAxMDAgIT09IDApKSB8fCAoeWVhciAlIDQwMCA9PT0gMCkpO1xuICAgIH0sXG4gICAgZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gWzMxLCAoRFBHbG9iYWwuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xuICAgIH0sXG4gICAgcGFyc2VGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCl7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBmb3JtYXQubWF0Y2goL1suXFwvXFwtXFxzXS4qPy8pLFxuICAgICAgICAgICAgcGFydHMgPSBmb3JtYXQuc3BsaXQoL1xcVysvKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3NlcGFyYXRvcjogc2VwYXJhdG9yLCBwYXJ0czogcGFydHN9O1xuICAgIH0sXG4gICAgcGFyc2VEYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxMSovXG4gICAgICAgIHZhciBwYXJ0cyA9IGRhdGUuc3BsaXQoZm9ybWF0LnNlcGFyYXRvciksXG4gICAgICAgICAgICB2YWw7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBkYXRlLnNldEhvdXJzKDApO1xuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoMCk7XG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcygwKTtcbiAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IGZvcm1hdC5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXkgPSBkYXRlLmdldERhdGUoKSwgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGNudCA9IGZvcm1hdC5wYXJ0cy5sZW5ndGg7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KHBhcnRzW2ldLCAxMCl8fDE7XG4gICAgICAgICAgICAgICAgc3dpdGNoKGZvcm1hdC5wYXJ0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXREYXRlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0TW9udGgodmFsIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IDIwMDAgKyB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKDIwMDAgKyB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3l5eXknOlxuICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAwICwwICwwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIGZvcm1hdERhdGU6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCl7XG4gICAgICAgIHZhciB2YWwgPSB7XG4gICAgICAgICAgICBkOiBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIG06IGRhdGUuZ2V0TW9udGgoKSArIDEsXG4gICAgICAgICAgICB5eTogZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgeXl5eTogZGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgIH07XG4gICAgICAgIHZhbC5kZCA9ICh2YWwuZCA8IDEwID8gJzAnIDogJycpICsgdmFsLmQ7XG4gICAgICAgIHZhbC5tbSA9ICh2YWwubSA8IDEwID8gJzAnIDogJycpICsgdmFsLm07XG4gICAgICAgIGRhdGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wLCBjbnQgPSBmb3JtYXQucGFydHMubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcbiAgICAgICAgICAgIGRhdGUucHVzaCh2YWxbZm9ybWF0LnBhcnRzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUuam9pbihmb3JtYXQuc2VwYXJhdG9yKTtcbiAgICB9LFxuICAgIGhlYWRUZW1wbGF0ZTogJzx0aGVhZD4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzx0cj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJwcmV2XCI+JmxzYXF1bzs8L3RoPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0aCBjb2xzcGFuPVwiNVwiIGNsYXNzPVwic3dpdGNoXCI+PC90aD4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJuZXh0XCI+JnJzYXF1bzs8L3RoPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nK1xuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nLFxuICAgIGNvbnRUZW1wbGF0ZTogJzx0Ym9keT48dHI+PHRkIGNvbHNwYW49XCI3XCI+PC90ZD48L3RyPjwvdGJvZHk+J1xufTtcbkRQR2xvYmFsLnRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5jb21wb25lbnQgKyAnXCI+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMuZGF5cyArICdcIj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCIgdGFibGUtY29uZGVuc2VkXCI+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRFBHbG9iYWwuaGVhZFRlbXBsYXRlK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRib2R5PjwvdGJvZHk+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc2VzLm1vbnRocyArICdcIj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc2VzLnllYXJzICsgJ1wiPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRFBHbG9iYWwuY29udFRlbXBsYXRlK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L3RhYmxlPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JytcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2Pic7XG5EUEdsb2JhbC5tb2Rlc1NldCA9IHtcbiAgICAnZGF0ZSc6IERQR2xvYmFsLm1vZGVzWzNdLFxuICAgICdtb250aCc6IERQR2xvYmFsLm1vZGVzWzBdLFxuICAgICd5ZWFyJzogRFBHbG9iYWwubW9kZXNbMV0sXG4gICAgJ2RlY2FkZSc6IERQR2xvYmFsLm1vZGVzWzJdXG59O1xuXG4vLyBQaWNrZXIgb2JqZWN0XG52YXIgRGF0ZVBpY2tlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvKmpzaGludCBtYXhzdGF0ZW1lbnRzOjQwLG1heGNvbXBsZXhpdHk6MjQqL1xuICAgIHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgdGhpcy5mb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChvcHRpb25zLmZvcm1hdHx8dGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUtZm9ybWF0Jyl8fCdtbS9kZC95eXl5Jyk7XG4gICAgXG4gICAgdGhpcy5pc0lucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpO1xuICAgIHRoaXMuY29tcG9uZW50ID0gdGhpcy5lbGVtZW50LmlzKCcuZGF0ZScpID8gdGhpcy5lbGVtZW50LmZpbmQoJy5hZGQtb24nKSA6IGZhbHNlO1xuICAgIHRoaXMuaXNQbGFjZWhvbGRlciA9IHRoaXMuZWxlbWVudC5pcygnLmNhbGVuZGFyLXBsYWNlaG9sZGVyJyk7XG4gICAgXG4gICAgdGhpcy5waWNrZXIgPSAkKERQR2xvYmFsLnRlbXBsYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuaXNQbGFjZWhvbGRlciA/IHRoaXMuZWxlbWVudCA6ICdib2R5JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAkLnByb3h5KHRoaXMuY2xpY2ssIHRoaXMpKTtcbiAgICB0aGlzLnBpY2tlci5hZGRDbGFzcyh0aGlzLmlzUGxhY2Vob2xkZXIgPyAnJyA6ICdkcm9wZG93bi1tZW51Jyk7XG4gICAgaWYgKG9wdGlvbnMuZXh0cmFDbGFzc2VzKVxuICAgICAgICB0aGlzLnBpY2tlci5hZGRDbGFzcyhvcHRpb25zLmV4dHJhQ2xhc3Nlcyk7XG4gICAgXG4gICAgaWYgKHRoaXMuaXNQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnBpY2tlci5zaG93KCk7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuZGF0YSgnZGF0ZScpID09ICd0b2RheScpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50cy5zaG93LFxuICAgICAgICAgICAgZGF0ZTogdGhpcy5kYXRlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSW5wdXQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uKHtcbiAgICAgICAgICAgIGZvY3VzOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcyksXG4gICAgICAgICAgICAvL2JsdXI6ICQucHJveHkodGhpcy5oaWRlLCB0aGlzKSxcbiAgICAgICAgICAgIGtleXVwOiAkLnByb3h5KHRoaXMudXBkYXRlLCB0aGlzKVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpe1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQub24oJ2NsaWNrJywgJC5wcm94eSh0aGlzLnNob3csIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5vbignY2xpY2snLCAkLnByb3h5KHRoaXMuc2hvdywgdGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qIFRvdWNoIGV2ZW50cyB0byBzd2lwZSBkYXRlcyAqL1xuICAgIHRoaXMuZWxlbWVudFxuICAgIC5vbignc3dpcGVsZWZ0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubW92ZURhdGUoJ25leHQnKTtcbiAgICB9LmJpbmQodGhpcykpXG4gICAgLm9uKCdzd2lwZXJpZ2h0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubW92ZURhdGUoJ3ByZXYnKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgLyogU2V0LXVwIHZpZXcgbW9kZSAqL1xuICAgIHRoaXMubWluVmlld01vZGUgPSBvcHRpb25zLm1pblZpZXdNb2RlfHx0aGlzLmVsZW1lbnQuZGF0YSgnZGF0ZS1taW52aWV3bW9kZScpfHwwO1xuICAgIGlmICh0eXBlb2YgdGhpcy5taW5WaWV3TW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1pblZpZXdNb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgICAgICAgIHRoaXMubWluVmlld01vZGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgICAgICAgIHRoaXMubWluVmlld01vZGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLm1pblZpZXdNb2RlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZpZXdNb2RlID0gb3B0aW9ucy52aWV3TW9kZXx8dGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUtdmlld21vZGUnKXx8MDtcbiAgICBpZiAodHlwZW9mIHRoaXMudmlld01vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy52aWV3TW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnbW9udGhzJzpcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdGFydFZpZXdNb2RlID0gdGhpcy52aWV3TW9kZTtcbiAgICB0aGlzLndlZWtTdGFydCA9IG9wdGlvbnMud2Vla1N0YXJ0fHx0aGlzLmVsZW1lbnQuZGF0YSgnZGF0ZS13ZWVrc3RhcnQnKXx8MDtcbiAgICB0aGlzLndlZWtFbmQgPSB0aGlzLndlZWtTdGFydCA9PT0gMCA/IDYgOiB0aGlzLndlZWtTdGFydCAtIDE7XG4gICAgdGhpcy5vblJlbmRlciA9IG9wdGlvbnMub25SZW5kZXI7XG4gICAgdGhpcy5maWxsRG93KCk7XG4gICAgdGhpcy5maWxsTW9udGhzKCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICB0aGlzLnNob3dNb2RlKCk7XG59O1xuXG5EYXRlUGlja2VyLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRGF0ZVBpY2tlcixcbiAgICBcbiAgICBfdHJpZ2dlclZpZXdEYXRlQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZpZXdNb2RlTmFtZSA9IERQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdLmNsc05hbWU7XG4gICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKGV2ZW50cy52aWV3RGF0ZUNoYW5nZWQsIFt7IHZpZXdEYXRlOiB0aGlzLnZpZXdEYXRlLCB2aWV3TW9kZTogdmlld01vZGVOYW1lIH1dKTtcbiAgICB9LFxuICAgIFxuICAgIHNob3c6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5waWNrZXIuc2hvdygpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub3V0ZXJIZWlnaHQoKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICB0aGlzLnBsYWNlKCk7XG4gICAgICAgICQod2luZG93KVxuICAgICAgICAgICAgLm9mZigncmVzaXplLmRhdGVwaWNrZXInKVxuICAgICAgICAgICAgLm9uKCdyZXNpemUuZGF0ZXBpY2tlcicsICQucHJveHkodGhpcy5wbGFjZSwgdGhpcykpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzSW5wdXQpIHtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICQoZG9jdW1lbnQpXG4gICAgICAgIC5vZmYoJ21vdXNlZG93bi5kYXRlcGlja2VyJylcbiAgICAgICAgLm9uKCdtb3VzZWRvd24uZGF0ZXBpY2tlcicsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgICAgIGlmICgkKGV2LnRhcmdldCkuY2xvc2VzdCgnLicgKyBjbGFzc2VzLmNvbXBvbmVudCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgICAgICB0eXBlOiBldmVudHMuc2hvdyxcbiAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF0ZVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMucGlja2VyLmhpZGUoKTtcbiAgICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLmRhdGVwaWNrZXInLCB0aGlzLnBsYWNlKTtcbiAgICAgICAgdGhpcy52aWV3TW9kZSA9IHRoaXMuc3RhcnRWaWV3TW9kZTtcbiAgICAgICAgdGhpcy5zaG93TW9kZSgpO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbnB1dCkge1xuICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdtb3VzZWRvd24uZGF0ZXBpY2tlcicsIHRoaXMuaGlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLnNldCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgICAgICB0eXBlOiBldmVudHMuaGlkZSxcbiAgICAgICAgICAgIGRhdGU6IHRoaXMuZGF0ZVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmb3JtYXRlZCA9IERQR2xvYmFsLmZvcm1hdERhdGUodGhpcy5kYXRlLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGlmICghdGhpcy5pc0lucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpe1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpLnByb3AoJ3ZhbHVlJywgZm9ybWF0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnLCBmb3JtYXRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucHJvcCgndmFsdWUnLCBmb3JtYXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoZXZlbnRzLmRhdGVTZXQsIFt0aGlzLmRhdGUsIGZvcm1hdGVkXSk7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgICAgU2V0cyBhIGRhdGUgYXMgdmFsdWUgYW5kIG5vdGlmeSB3aXRoIGFuIGV2ZW50LlxuICAgICAgICBQYXJhbWV0ZXIgZG9udE5vdGlmeSBpcyBvbmx5IGZvciBjYXNlcyB3aGVyZSB0aGUgY2FsZW5kYXIgb3JcbiAgICAgICAgc29tZSByZWxhdGVkIGNvbXBvbmVudCBnZXRzIGFscmVhZHkgdXBkYXRlZCBidXQgdGhlIGhpZ2hsaWdodGVkXG4gICAgICAgIGRhdGUgbmVlZHMgdG8gYmUgdXBkYXRlZCB3aXRob3V0IGNyZWF0ZSBpbmZpbml0ZSByZWN1cnNpb24gXG4gICAgICAgIGJlY2F1c2Ugb2Ygbm90aWZpY2F0aW9uLiBJbiBvdGhlciBjYXNlLCBkb250IHVzZS5cbiAgICAqKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24obmV3RGF0ZSwgZG9udE5vdGlmeSkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld0RhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUobmV3RGF0ZSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUobmV3RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoKTtcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSwgMSwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICAvLyBUT0RPIE11c3QgY2hlY2sgZG9udE5vdGlmeT9cbiAgICAgICAgdGhpcy5fdHJpZ2dlclZpZXdEYXRlQ2hhbmdlKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZG9udE5vdGlmeSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gTm90aWZ5OlxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50cy5kYXRlQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXG4gICAgICAgICAgICAgICAgdmlld01vZGU6IERQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdLmNsc05hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGU7XG4gICAgfSxcbiAgICBcbiAgICBnZXRWaWV3RGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdEYXRlO1xuICAgIH0sXG4gICAgXG4gICAgbW92ZVZhbHVlOiBmdW5jdGlvbihkaXIsIG1vZGUpIHtcbiAgICAgICAgLy8gZGlyIGNhbiBiZTogJ3ByZXYnLCAnbmV4dCdcbiAgICAgICAgaWYgKFsncHJldicsICduZXh0J10uaW5kZXhPZihkaXIgJiYgZGlyLnRvTG93ZXJDYXNlKCkpID09IC0xKVxuICAgICAgICAgICAgLy8gTm8gdmFsaWQgb3B0aW9uOlxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgbW9kZSBpcyB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgbW9kZSA9IG1vZGUgP1xuICAgICAgICAgICAgRFBHbG9iYWwubW9kZXNTZXRbbW9kZV0gOlxuICAgICAgICAgICAgRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV07XG5cbiAgICAgICAgdGhpcy5kYXRlWydzZXQnICsgbW9kZS5uYXZGbmNdLmNhbGwoXG4gICAgICAgICAgICB0aGlzLmRhdGUsXG4gICAgICAgICAgICB0aGlzLmRhdGVbJ2dldCcgKyBtb2RlLm5hdkZuY10uY2FsbCh0aGlzLmRhdGUpICsgXG4gICAgICAgICAgICBtb2RlLm5hdlN0ZXAgKiAoZGlyID09PSAncHJldicgPyAtMSA6IDEpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5kYXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZTtcbiAgICB9LFxuICAgIFxuICAgIHBsYWNlOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vZmZzZXQoKSA6IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcbiAgICAgICAgdGhpcy5waWNrZXIuY3NzKHtcbiAgICAgICAgICAgIHRvcDogb2Zmc2V0LnRvcCArIHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnRcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG5ld0RhdGUpe1xuICAgICAgICB0aGlzLmRhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoXG4gICAgICAgICAgICB0eXBlb2YgbmV3RGF0ZSA9PT0gJ3N0cmluZycgPyBuZXdEYXRlIDogKHRoaXMuaXNJbnB1dCA/IHRoaXMuZWxlbWVudC5wcm9wKCd2YWx1ZScpIDogdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSksXG4gICAgICAgICAgICB0aGlzLmZvcm1hdFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5kYXRlLmdldEZ1bGxZZWFyKCksIHRoaXMuZGF0ZS5nZXRNb250aCgpLCAxLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJWaWV3RGF0ZUNoYW5nZSgpO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0RGF5c0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyLmZpbmQoJy4nICsgY2xhc3Nlcy5kYXlzICsgJyAuJyArIGNsYXNzZXMubW9udGhEYXkpO1xuICAgIH0sXG4gICAgXG4gICAgZmlsbERvdzogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRvd0NudCA9IHRoaXMud2Vla1N0YXJ0O1xuICAgICAgICB2YXIgaHRtbCA9ICc8dHIgY2xhc3M9XCInICsgY2xhc3Nlcy53ZWVrRGF5cyArICdcIj4nO1xuICAgICAgICB3aGlsZSAoZG93Q250IDwgdGhpcy53ZWVrU3RhcnQgKyA3KSB7XG4gICAgICAgICAgICBodG1sICs9ICc8dGggY2xhc3M9XCJkb3dcIj4nK0RQR2xvYmFsLmRhdGVzLmRheXNNaW5bKGRvd0NudCsrKSU3XSsnPC90aD4nO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gJzwvdHI+JztcbiAgICAgICAgdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLmRheXMgKyAnIHRoZWFkJykuYXBwZW5kKGh0bWwpO1xuICAgIH0sXG4gICAgXG4gICAgZmlsbE1vbnRoczogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IDEyKSB7XG4gICAgICAgICAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc2VzLm1vbnRoICsgJ1wiPicrRFBHbG9iYWwuZGF0ZXMubW9udGhzU2hvcnRbaSsrXSsnPC9zcGFuPic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLm1vbnRocyArICcgdGQnKS5hcHBlbmQoaHRtbCk7XG4gICAgfSxcbiAgICBcbiAgICBmaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czo3MCwgbWF4Y29tcGxleGl0eToyOCovXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSksXG4gICAgICAgICAgICB5ZWFyID0gZC5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgbW9udGggPSBkLmdldE1vbnRoKCksXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHRoaXMuZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZmlyc3QgZGF0ZSB0byBzaG93LCB1c3VhbGx5IG9uIHByZXZpb3VzIG1vbnRoOlxuICAgICAgICB2YXIgcHJldk1vbnRoID0gbmV3IERhdGUoeWVhciwgbW9udGgtMSwgMjgsMCwwLDAsMCksXG4gICAgICAgICAgICBsYXN0RGF5UHJldk1vbnRoID0gRFBHbG9iYWwuZ2V0RGF5c0luTW9udGgocHJldk1vbnRoLmdldEZ1bGxZZWFyKCksIHByZXZNb250aC5nZXRNb250aCgpKTtcbiAgICAgICAgLy8gTDE4Tj9cbiAgICAgICAgcHJldk1vbnRoLnNldERhdGUobGFzdERheVByZXZNb250aCk7XG4gICAgICAgIHByZXZNb250aC5zZXREYXRlKGxhc3REYXlQcmV2TW9udGggLSAocHJldk1vbnRoLmdldERheSgpIC0gdGhpcy53ZWVrU3RhcnQgKyA3KSU3KTsgICAgICAgIFxuXG4gICAgICAgIC8vIElNUE9SVEFOVDogQXZvaWQgZHVwbGljYXRlZCB3b3JrLCBieSBjaGVja2luZyB3ZSBhcmUgc3RpbGwgc2hvd2luZyB0aGUgc2FtZSBtb250aCxcbiAgICAgICAgLy8gc28gbm90IG5lZWQgdG8gJ3JlLXJlbmRlcicgZXZlcnl0aGluZywgb25seSBzd2FwIHRoZSBhY3RpdmUgZGF0ZVxuICAgICAgICBpZiAodGhpcy5fcHJldkRhdGUgJiYgdGhpcy5fcHJldkRhdGUuZ2V0TW9udGgoKSA9PT0gdGhpcy52aWV3RGF0ZS5nZXRNb250aCgpKSB7XG4gICAgICAgICAgICB2YXIgdGJvZHkgPSB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMuZGF5cyArICcgdGJvZHknKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBhY3RpdmUgZGF0ZSBtYXJrXG4gICAgICAgICAgICAvLyAodmlld0RhdGUgaGFzIGVmZmVjdGl2ZWx5IHRoZSB2YWx1ZSBvZiBwcmV2aW91cyBhY3RpdmUgZGF0ZSwgYnV0IGRvaW5nIGEgY2xhc3Mgc2VhcmNoIHdva3MgdG9vIDotKVxuICAgICAgICAgICAgdGJvZHkuZmluZCgnLicgKyBjbGFzc2VzLm1vbnRoRGF5ICsgJy4nICsgY2xhc3Nlcy5hY3RpdmUpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoY2xhc3Nlcy5hY3RpdmUpO1xuXG4gICAgICAgICAgICAvLyBBZGQgZGF0ZSBtYXJrIHRvIGN1cnJlbnRcbiAgICAgICAgICAgIHZhciBkaWZmID0gbGFzdERheVByZXZNb250aCAtIHByZXZNb250aC5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgaW5kZXggPSBkaWZmICsgdGhpcy5kYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgICAgICBpcm93ID0gKGluZGV4IC8gNykgfDAsXG4gICAgICAgICAgICAgICAgaWNvbCA9IGluZGV4ICUgNztcbiAgICAgICAgICAgIHRib2R5LmZpbmQoJ3RyOmVxKCcgKyBpcm93ICsgJykgdGQ6ZXEoJyArIGljb2wgKyAnKScpLmFkZENsYXNzKGNsYXNzZXMuYWN0aXZlKTsgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9wcmV2RGF0ZSA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpO1xuICAgICAgICAgICAgLy8gRE9ORTpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2RGF0ZSA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpO1xuXG4gICAgICAgIC8vIEhlYWRlclxuICAgICAgICB0aGlzLnBpY2tlclxuICAgICAgICAuZmluZCgnLicgKyBjbGFzc2VzLmRheXMgKyAnIHRoOmVxKDEpJylcbiAgICAgICAgLmh0bWwoRFBHbG9iYWwuZGF0ZXMubW9udGhzW21vbnRoXSArICcgJyArIHllYXIpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBlbmRpbmdcbiAgICAgICAgdmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHByZXZNb250aCk7XG4gICAgICAgIG5leHRNb250aC5zZXREYXRlKG5leHRNb250aC5nZXREYXRlKCkgKyA0Mik7XG4gICAgICAgIG5leHRNb250aCA9IG5leHRNb250aC52YWx1ZU9mKCk7XG4gICAgICAgIHZhciBodG1sID0gW107XG4gICAgICAgIHZhciBjbHNOYW1lLFxuICAgICAgICAgICAgcHJldlksXG4gICAgICAgICAgICBwcmV2TTtcbiAgICAgICAgICAgIFxuICAgICAgICBpZiAodGhpcy5fZGF5c0NyZWF0ZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBiYXNlIGh0bWwgKGZpcnN0IHRpbWUgb25seSlcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdG8gY29uc3RydWN0b3JcbiAgICAgICAgICAgIGZvcih2YXIgciA9IDA7IHIgPCA2OyByKyspIHtcbiAgICAgICAgICAgICAgICBodG1sLnB1c2goJzx0cj4nKTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGMgPSAwOyBjIDwgNzsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCgnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMubW9udGhEYXkgKyAnXCI+PHNwYW4+Jm5ic3A7PC9zcGFuPjwvdGQ+Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWwucHVzaCgnPC90cj4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLmRheXMgKyAnIHRib2R5JykuZW1wdHkoKS5hcHBlbmQoaHRtbC5qb2luKCcnKSk7XG4gICAgICAgICAgICB0aGlzLl9kYXlzQ3JlYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZGF5cyB2YWx1ZXMgICAgXG4gICAgICAgIHZhciB3ZWVrVHIgPSB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMuZGF5cyArICcgdGJvZHkgdHI6Zmlyc3QtY2hpbGQoKScpO1xuICAgICAgICB2YXIgZGF5VGQgPSBudWxsO1xuICAgICAgICB3aGlsZShwcmV2TW9udGgudmFsdWVPZigpIDwgbmV4dE1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFdlZWtEYXlJbmRleCA9IHByZXZNb250aC5nZXREYXkoKSAtIHRoaXMud2Vla1N0YXJ0O1xuXG4gICAgICAgICAgICBjbHNOYW1lID0gdGhpcy5vblJlbmRlcihwcmV2TW9udGgpO1xuICAgICAgICAgICAgcHJldlkgPSBwcmV2TW9udGguZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIHByZXZNID0gcHJldk1vbnRoLmdldE1vbnRoKCk7XG4gICAgICAgICAgICBpZiAoKHByZXZNIDwgbW9udGggJiYgIHByZXZZID09PSB5ZWFyKSB8fCAgcHJldlkgPCB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgY2xzTmFtZSArPSAnIG9sZCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChwcmV2TSA+IG1vbnRoICYmIHByZXZZID09PSB5ZWFyKSB8fCBwcmV2WSA+IHllYXIpIHtcbiAgICAgICAgICAgICAgICBjbHNOYW1lICs9ICcgbmV3JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2TW9udGgudmFsdWVPZigpID09PSBjdXJyZW50RGF0ZSkge1xuICAgICAgICAgICAgICAgIGNsc05hbWUgKz0gJyAnICsgY2xhc3Nlcy5hY3RpdmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRheVRkID0gd2Vla1RyLmZpbmQoJ3RkOmVxKCcgKyBjdXJyZW50V2Vla0RheUluZGV4ICsgJyknKTtcbiAgICAgICAgICAgIGRheVRkXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBjbGFzc2VzLm1vbnRoRGF5ICsgJyAnICsgY2xzTmFtZSlcbiAgICAgICAgICAgIC5kYXRhKCdkYXRlLXRpbWUnLCBwcmV2TW9udGgudG9JU09TdHJpbmcoKSlcbiAgICAgICAgICAgIC5jaGlsZHJlbignc3BhbicpLnRleHQocHJldk1vbnRoLmdldERhdGUoKSk7XG5cbiAgICAgICAgICAgIHRoaXMucGlja2VyLnRyaWdnZXIoZXZlbnRzLmRheVJlbmRlcmVkLCBbZGF5VGRdKTtcblxuICAgICAgICAgICAgLy8gTmV4dCB3ZWVrP1xuICAgICAgICAgICAgaWYgKHByZXZNb250aC5nZXREYXkoKSA9PT0gdGhpcy53ZWVrRW5kKSB7XG4gICAgICAgICAgICAgICAgd2Vla1RyID0gd2Vla1RyLm5leHQoJ3RyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2TW9udGguc2V0RGF0ZShwcmV2TW9udGguZ2V0RGF0ZSgpKzEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRZZWFyID0gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbW9udGhzID0gdGhpcy5waWNrZXIuZmluZCgnLicgKyBjbGFzc2VzLm1vbnRocylcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3RoOmVxKDEpJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKHllYXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3NwYW4nKS5yZW1vdmVDbGFzcyhjbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgIGlmIChjdXJyZW50WWVhciA9PT0geWVhcikge1xuICAgICAgICAgICAgbW9udGhzLmVxKHRoaXMuZGF0ZS5nZXRNb250aCgpKS5hZGRDbGFzcyhjbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgICAgeWVhciA9IHBhcnNlSW50KHllYXIvMTAsIDEwKSAqIDEwO1xuICAgICAgICB2YXIgeWVhckNvbnQgPSB0aGlzLnBpY2tlci5maW5kKCcuJyArIGNsYXNzZXMueWVhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3RoOmVxKDEpJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoeWVhciArICctJyArICh5ZWFyICsgOSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKCd0ZCcpO1xuICAgICAgICBcbiAgICAgICAgeWVhciAtPSAxO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHRoaXMuX3llYXJzQ3JlYXRlZCAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAtMTsgaSA8IDExOyBpKyspIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc2VzLnllYXIgKyAoaSA9PT0gLTEgfHwgaSA9PT0gMTAgPyAnIG9sZCcgOiAnJykrKGN1cnJlbnRZZWFyID09PSB5ZWFyID8gJyAnICsgY2xhc3Nlcy5hY3RpdmUgOiAnJykrJ1wiPicreWVhcisnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgeWVhciArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB5ZWFyQ29udC5odG1sKGh0bWwpO1xuICAgICAgICAgICAgdGhpcy5feWVhcnNDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHllYXJTcGFuID0geWVhckNvbnQuZmluZCgnc3BhbjpmaXJzdC1jaGlsZCgpJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAtMTsgaSA8IDExOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvL2h0bWwgKz0gJzxzcGFuIGNsYXNzPVwieWVhcicrKGkgPT09IC0xIHx8IGkgPT09IDEwID8gJyBvbGQnIDogJycpKyhjdXJyZW50WWVhciA9PT0geWVhciA/ICcgJyArIGNsYXNzZXMuYWN0aXZlIDogJycpKydcIj4nK3llYXIrJzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgIHllYXJTcGFuXG4gICAgICAgICAgICAgICAgLnRleHQoeWVhcilcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneWVhcicgKyAoaSA9PT0gLTEgfHwgaSA9PT0gMTAgPyAnIG9sZCcgOiAnJykgKyAoY3VycmVudFllYXIgPT09IHllYXIgPyAnICcgKyBjbGFzc2VzLmFjdGl2ZSA6ICcnKSk7XG4gICAgICAgICAgICAgICAgeWVhciArPSAxO1xuICAgICAgICAgICAgICAgIHllYXJTcGFuID0geWVhclNwYW4ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBtb3ZlRGF0ZTogZnVuY3Rpb24oZGlyLCBtb2RlKSB7XG4gICAgICAgIC8vIGRpciBjYW4gYmU6ICdwcmV2JywgJ25leHQnXG4gICAgICAgIGlmIChbJ3ByZXYnLCAnbmV4dCddLmluZGV4T2YoZGlyICYmIGRpci50b0xvd2VyQ2FzZSgpKSA9PSAtMSlcbiAgICAgICAgICAgIC8vIE5vIHZhbGlkIG9wdGlvbjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAvLyBkZWZhdWx0IG1vZGUgaXMgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIG1vZGUgPSBtb2RlIHx8IHRoaXMudmlld01vZGU7XG5cbiAgICAgICAgdGhpcy52aWV3RGF0ZVsnc2V0JytEUEdsb2JhbC5tb2Rlc1ttb2RlXS5uYXZGbmNdLmNhbGwoXG4gICAgICAgICAgICB0aGlzLnZpZXdEYXRlLFxuICAgICAgICAgICAgdGhpcy52aWV3RGF0ZVsnZ2V0JytEUEdsb2JhbC5tb2Rlc1ttb2RlXS5uYXZGbmNdLmNhbGwodGhpcy52aWV3RGF0ZSkgKyBcbiAgICAgICAgICAgIERQR2xvYmFsLm1vZGVzW21vZGVdLm5hdlN0ZXAgKiAoZGlyID09PSAncHJldicgPyAtMSA6IDEpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyVmlld0RhdGVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5zZXQoKTtcbiAgICB9LFxuXG4gICAgY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxNiwgbWF4c3RhdGVtZW50czozMCovXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3NwYW4ubW9udGgsIHNwYW4ueWVhciwgdGQsIHRoJyk7XG4gICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgbW9udGgsIHllYXI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZU1vbnRoWWVhciA9IGZ1bmN0aW9uIGNvbXBsZXRlTW9udGhZZWFyKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudHMuZGF0ZUNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZTogRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TW9kZSgtMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNDbGFzcygnc3dpdGNoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93TW9kZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC5oYXNDbGFzcygncHJldicpIHx8XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmhhc0NsYXNzKCduZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlRGF0ZSh0YXJnZXRbMF0uY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC5oYXNDbGFzcyhjbGFzc2VzLm1vbnRoKSkge1xuICAgICAgICAgICAgICAgIG1vbnRoID0gdGFyZ2V0LnBhcmVudCgpLmZpbmQoJ3NwYW4nKS5pbmRleCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0RhdGUuc2V0TW9udGgobW9udGgpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlTW9udGhZZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclZpZXdEYXRlQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQuaGFzQ2xhc3MoY2xhc3Nlcy55ZWFyKSkge1xuICAgICAgICAgICAgICAgIHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDA7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3RGF0ZS5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZU1vbnRoWWVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJWaWV3RGF0ZUNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0Lmhhc0NsYXNzKGNsYXNzZXMubW9udGhEYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXMoJy5kaXNhYmxlZCcpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IHBhcnNlSW50KHRhcmdldC50ZXh0KCksIDEwKXx8MTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSB0aGlzLnZpZXdEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoICs9IHRhcmdldC5oYXNDbGFzcygnb2xkJykgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaGFzQ2xhc3MoJ25ldycpID8gMSA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgeWVhciA9IHRoaXMudmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwwLDAsMCwwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBNYXRoLm1pbigyOCwgZGF5KSwwLDAsMCwwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJWaWV3RGF0ZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudHMuZGF0ZUNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZTogRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG1vdXNlZG93bjogZnVuY3Rpb24oZSl7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuICAgIFxuICAgIHNob3dNb2RlOiBmdW5jdGlvbihkaXIpIHtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZSA9IE1hdGgubWF4KHRoaXMubWluVmlld01vZGUsIE1hdGgubWluKDIsIHRoaXMudmlld01vZGUgKyBkaXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpY2tlci5maW5kKCc+ZGl2JykuaGlkZSgpLmZpbHRlcignLicgKyBjbGFzc2VzLmNvbXBvbmVudCArICctJyArIERQR2xvYmFsLm1vZGVzW3RoaXMudmlld01vZGVdLmNsc05hbWUpLnNob3coKTtcbiAgICB9XG59O1xuXG4kLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcbiAgICB2YXIgdmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIHJldHVybmVkO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbjtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAkdGhpcy5kYXRhKCdkYXRlcGlja2VyJywgKGRhdGEgPSBuZXcgRGF0ZVBpY2tlcih0aGlzLCAkLmV4dGVuZCh7fSwgJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzLG9wdGlvbnMpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm5lZCA9IGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCB2YWxzKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIG1ldGhvZD9cbiAgICAgICAgICAgIGlmICh0eXBlb2YocmV0dXJuZWQpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIEdvIG91dCB0aGUgbG9vcCB0byByZXR1cm4gdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudC1tZXRob2QgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9sbG93IG5leHQgbG9vcCBpdGVtXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mKHJldHVybmVkKSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiByZXR1cm5lZDtcbiAgICBlbHNlXG4gICAgICAgIC8vIGNoYWluaW5nOlxuICAgICAgICByZXR1cm4gdGhpcztcbn07XG5cbiQuZm4uZGF0ZXBpY2tlci5kZWZhdWx0cyA9IHtcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oLypkYXRlKi8pIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG4kLmZuLmRhdGVwaWNrZXIuQ29uc3RydWN0b3IgPSBEYXRlUGlja2VyO1xuXG4vKiogUHVibGljIEFQSSAqKi9cbmV4cG9ydHMuRGF0ZVBpY2tlciA9IERhdGVQaWNrZXI7XG5leHBvcnRzLmRlZmF1bHRzID0gRFBHbG9iYWw7XG5leHBvcnRzLnV0aWxzID0gRFBHbG9iYWw7XG4iLCIvKipcbiAgICBTbWFydE5hdkJhciBjb21wb25lbnQuXG4gICAgUmVxdWlyZXMgaXRzIENTUyBjb3VudGVycGFydC5cbiAgICBcbiAgICBDcmVhdGVkIGJhc2VkIG9uIHRoZSBwcm9qZWN0OlxuICAgIFxuICAgIFByb2plY3QtVHlzb25cbiAgICBXZWJzaXRlOiBodHRwczovL2dpdGh1Yi5jb20vYzJwcm9kcy9Qcm9qZWN0LVR5c29uXG4gICAgQXV0aG9yOiBjMnByb2RzXG4gICAgTGljZW5zZTpcbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAgICBDb3B5cmlnaHQgKGMpIDIwMTMgYzJwcm9kc1xuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAgICB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gICAgdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICAgIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mXG4gICAgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG4gICAgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SXG4gICAgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSXG4gICAgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKiovXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vKipcbiAgICBJbnRlcm5hbCB1dGlsaXR5LlxuICAgIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZvciBhIERPTSBub2RlXG4qKi9cbnZhciBjbGVhck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHdoaWxlKG5vZGUuZmlyc3RDaGlsZCl7XG4gICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG59O1xuXG4vKipcbiAgICBDYWxjdWxhdGVzIGFuZCBhcHBsaWVzIHRoZSBiZXN0IHNpemluZyBhbmQgZGlzdHJpYnV0aW9uIGZvciB0aGUgdGl0bGVcbiAgICBkZXBlbmRpbmcgb24gY29udGVudCBhbmQgYnV0dG9ucy5cbiAgICBQYXNzIGluIHRoZSB0aXRsZSBlbGVtZW50LCBidXR0b25zIG11c3QgYmUgZm91bmQgYXMgc2libGluZ3Mgb2YgaXQuXG4qKi9cbnZhciB0ZXh0Ym94UmVzaXplID0gZnVuY3Rpb24gdGV4dGJveFJlc2l6ZShlbCkge1xuICAgIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAyOCwgbWF4Y29tcGxleGl0eToxMSAqL1xuICAgIFxuICAgIHZhciBsZWZ0YnRuID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuU21hcnROYXZCYXItZWRnZS5sZWZ0JylbMF07XG4gICAgdmFyIHJpZ2h0YnRuID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuU21hcnROYXZCYXItZWRnZS5yaWdodCcpWzBdO1xuICAgIGlmICh0eXBlb2YgbGVmdGJ0biA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGVmdGJ0biA9IHtcbiAgICAgICAgICAgIG9mZnNldFdpZHRoOiAwLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJpZ2h0YnRuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByaWdodGJ0biA9IHtcbiAgICAgICAgICAgIG9mZnNldFdpZHRoOiAwLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICB2YXIgbWFyZ2luID0gTWF0aC5tYXgobGVmdGJ0bi5vZmZzZXRXaWR0aCwgcmlnaHRidG4ub2Zmc2V0V2lkdGgpO1xuICAgIGVsLnN0eWxlLm1hcmdpbkxlZnQgPSBtYXJnaW4gKyAncHgnO1xuICAgIGVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luICsgJ3B4JztcbiAgICB2YXIgdG9vTG9uZyA9IChlbC5vZmZzZXRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoKSA/IHRydWUgOiBmYWxzZTtcbiAgICBpZiAodG9vTG9uZykge1xuICAgICAgICBpZiAobGVmdGJ0bi5vZmZzZXRXaWR0aCA8IHJpZ2h0YnRuLm9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gbGVmdGJ0bi5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICBlbC5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc3R5bGUubWFyZ2luUmlnaHQgPSByaWdodGJ0bi5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICBlbC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgdG9vTG9uZyA9IChlbC5vZmZzZXRXaWR0aDxlbC5zY3JvbGxXaWR0aCkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGlmICh0b29Mb25nKSB7XG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cCgnYXJyb3cnKS50ZXN0KGxlZnRidG4uY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNsZWFyTm9kZShsZWZ0YnRuLmNoaWxkTm9kZXNbMV0pO1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLm1hcmdpbkxlZnQgPSAnMjZweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cCgnYXJyb3cnKS50ZXN0KHJpZ2h0YnRuLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUocmlnaHRidG4uY2hpbGROb2Rlc1sxXSk7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUubWFyZ2luUmlnaHQgPSAnMjZweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnRzLnRleHRib3hSZXNpemUgPSB0ZXh0Ym94UmVzaXplO1xuXG4vKipcbiAgICBTbWFydE5hdkJhciBjbGFzcywgaW5zdGFudGlhdGUgd2l0aCBhIERPTSBlbGVtZW50XG4gICAgcmVwcmVzZW50aW5nIGEgbmF2YmFyLlxuICAgIEFQSTpcbiAgICAtIHJlZnJlc2g6IHVwZGF0ZXMgdGhlIGNvbnRyb2wgdGFraW5nIGNhcmUgb2YgdGhlIG5lZWRlZFxuICAgICAgICB3aWR0aCBmb3IgdGl0bGUgYW5kIGJ1dHRvbnNcbioqL1xudmFyIFNtYXJ0TmF2QmFyID0gZnVuY3Rpb24gU21hcnROYXZCYXIoZWwpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgXG4gICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIGggPSAkKGVsKS5jaGlsZHJlbignaDEnKS5nZXQoMCk7XG4gICAgICAgIGlmIChoKVxuICAgICAgICAgICAgdGV4dGJveFJlc2l6ZShoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZWZyZXNoKCk7IFxufTtcblxuZXhwb3J0cy5TbWFydE5hdkJhciA9IFNtYXJ0TmF2QmFyO1xuXG4vKipcbiAgICBHZXQgaW5zdGFuY2VzIGZvciBhbGwgdGhlIFNtYXJ0TmF2QmFyIGVsZW1lbnRzIGluIHRoZSBET01cbioqL1xuZXhwb3J0cy5nZXRBbGwgPSBmdW5jdGlvbiBnZXRBbGwoKSB7XG4gICAgdmFyIGFsbCA9ICQoJy5TbWFydE5hdkJhcicpO1xuICAgIHJldHVybiAkLm1hcChhbGwsIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIG5ldyBTbWFydE5hdkJhcihpdGVtKTsgfSk7XG59O1xuXG4vKipcbiAgICBSZWZyZXNoIGFsbCBTbWFydE5hdkJhciBmb3VuZCBpbiB0aGUgZG9jdW1lbnQuXG4qKi9cbmV4cG9ydHMucmVmcmVzaEFsbCA9IGZ1bmN0aW9uIHJlZnJlc2hBbGwoKSB7XG4gICAgJCgnLlNtYXJ0TmF2QmFyID4gaDEnKS5lYWNoKGZ1bmN0aW9uKCkgeyB0ZXh0Ym94UmVzaXplKHRoaXMpOyB9KTtcbn07XG4iLCIvKipcbiAgICBDdXN0b20gTG9jb25vbWljcyAnbG9jYWxlJyBzdHlsZXMgZm9yIGRhdGUvdGltZXMuXG4gICAgSXRzIGEgYml0IG1vcmUgJ2Nvb2wnIHJlbmRlcmluZyBkYXRlcyA7LSlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG4vLyBTaW5jZSB0aGUgdGFzayBvZiBkZWZpbmUgYSBsb2NhbGUgY2hhbmdlc1xuLy8gdGhlIGN1cnJlbnQgZ2xvYmFsIGxvY2FsZSwgd2Ugc2F2ZSBhIHJlZmVyZW5jZVxuLy8gYW5kIHJlc3RvcmUgaXQgbGF0ZXIgc28gbm90aGluZyBjaGFuZ2VkLlxudmFyIGN1cnJlbnQgPSBtb21lbnQubG9jYWxlKCk7XG5cbm1vbWVudC5sb2NhbGUoJ2VuLVVTLUxDJywge1xuICAgIG1lcmlkaWVtUGFyc2UgOiAvW2FwXVxcLj9cXC4/L2ksXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3AnIDogJ1AnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYScgOiAnQSc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbGVuZGFyIDoge1xuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXldJyxcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXldJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3ddJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW2xhc3RdIGRkZGQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTS9EJ1xuICAgIH0sXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgIExUOiAnaDptbWEnLFxuICAgICAgICBMVFM6ICdoOm1tOnNzYScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgbDogJ00vRC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIERvIFlZWVknLFxuICAgICAgICBsbDogJ01NTSBEIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIERvIFlZWVkgTFQnLFxuICAgICAgICBsbGw6ICdNTU0gRCBZWVlZIExUJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRG8gWVlZWSBMVCcsXG4gICAgICAgIGxsbGw6ICdkZGQsIE1NTSBEIFlZWVkgTFQnXG4gICAgfVxufSk7XG5cbi8vIFJlc3RvcmUgbG9jYWxlXG5tb21lbnQubG9jYWxlKGN1cnJlbnQpO1xuIiwiLyoqXG4gICAgU2hvd3MgYSB0ZXh0YXJlYSBmaWVsZCB0byBpbnRyb2R1Y2Ugb3IgY2hhbmdlIGEgdGV4dCwgdXNlZnVsbCBcbiAgICBmb3IgaW50ZXJmYWNlcyBsaWtlIENhcmRzIHdoZXJlIGFuIGlubGluZSB0ZXh0YXJlYSBpcyBub3Qgd2FudGVkLlxuICAgIFxuICAgIEBwYXJhbSBvcHRpb25zOk9iamVjdCB7XG4gICAgICAgIHRpdGxlOnN0cmluZyBPcHRpb25hbC4gVGhlIHRleHQgdG8gc2hvdyBpbiB0aGUgbW9kYWwncyBoZWFkZXIsXG4gICAgICAgICAgICB3aXRoIGZhbGxiYWNrIHRvIHRoZSBNb2RhbCdzIGRlZmF1bHQgdGl0bGUuXG4gICAgfVxuICAgIEByZXR1cm5zIFByb21pc2UuIEl0IHJlc29sdmVzIHdoZW4gYSBidXR0b24gaXMgcHJlc3NlZCB3aXRoIHRoZSBpbnRyb2R1Y2VkIHRleHQgb24gJ3NhdmUnLlxuICAgIElzIHJlamVjdGVkIHdoZW4gdGhlIG1vZGFsIGlzIGRpc21pc3NlZC9jbG9zZWQsIGxpa2Ugd2hlbiBwcmVzc2luZyAnY2FuY2VsJywgJ3JldHVybicgb3IgJ2Nsb3NlJy5cbioqL1xuLypnbG9iYWwgd2luZG93Ki9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbmV4cG9ydHMuc2hvdyA9IGZ1bmN0aW9uIHNob3dUZXh0RWRpdG9yKG9wdGlvbnMpIHtcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjEwXG5cbiAgICB2YXIgbW9kYWwgPSAkKCcjdGV4dEVkaXRvck1vZGFsJyksXG4gICAgICAgIHZtID0gbW9kYWwuZGF0YSgndmlld21vZGVsJyk7XG4gICAgXG4gICAgaWYgKCF2bSkge1xuICAgICAgICB2bSA9IG5ldyBUZXh0RWRpdG9yTW9kZWwoKTtcblxuICAgICAgICBrby5hcHBseUJpbmRpbmdzKHZtLCBtb2RhbC5nZXQoMCkpO1xuICAgICAgICBtb2RhbC5kYXRhKCd2aWV3bW9kZWwnLCB2bSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXG4gICAgLy8gSW5wdXQgb3B0aW9ucyBhbmQgZGF0YVxuICAgIHZtLnRpdGxlKG9wdGlvbnMudGl0bGUgfHwgJycpO1xuICAgIHZtLnRleHQob3B0aW9ucy50ZXh0IHx8ICcnKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGVyc1xuICAgICAgICB2YXIgc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh2bS50ZXh0KCkpO1xuICAgICAgICAgICAgbW9kYWwubW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBKdXN0IGNsb3NlZCB3aXRob3V0IHBpY2sgYW55dGhpbmcsIHJlamVjdHNcbiAgICAgICAgbW9kYWwub2ZmKCdoaWRlLmJzLm1vZGFsJyk7XG4gICAgICAgIC8vIFJlamVjdCBvbiBoaWRlIGV2ZW50LCBidXQgZG8gbm90IHBhc3MgdGhlIGV2ZW50IGluIHRoZVxuICAgICAgICAvLyBmaXJzdCBwYXJhbWV0ZXIgKHRoZSBlcnJvciBpcyBudWxsLCBzaW5jZSB0aGVyZSBpcyBubyBlcnJvcikuXG4gICAgICAgIG1vZGFsLm9uKCdoaWRlLmJzLm1vZGFsJywgcmVqZWN0LmJpbmQobnVsbCwgbnVsbCkpO1xuICAgICAgICBtb2RhbC5vZmYoJ2NsaWNrJywgJyN0ZXh0RWRpdG9yTW9kYWwtc2F2ZScpO1xuICAgICAgICBtb2RhbC5vbignY2xpY2snLCAnI3RleHRFZGl0b3JNb2RhbC1zYXZlJywgc2F2ZSk7XG5cbiAgICAgICAgLy8gQXV0b2ZvY3VzXG4gICAgICAgIG1vZGFsLm9uZSgnc2hvd24uYnMubW9kYWwnLCBmdW5jdGlvbigpIHsgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkdGV4dCA9IG1vZGFsLmZpbmQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICAvLyBJbm1lZGlhdGUgZm9jdXMgdG8gdGhlIHRleHRhcmVhIGZvciBiZXR0ZXIgdXNhYmlsaXR5XG4gICAgICAgICAgICAkdGV4dC5mb2N1cygpO1xuICAgICAgICAgICAgJHRleHQuY2xpY2soKTtcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogV09SS0FST1VORDogZm9yIGlPUzogb24gaU9TIChjaGVja2VkIHVwIHRvIDguMywgMjAxNS0wNS0yMCksIHRoZSBvcGVuaW5nIG9mIHRoZSB2aXJ0dWFsIGtleWJvYXJkXG4gICAgICAgICAgICAvLyBtYWtlcyBhIHNjcm9sbCBkb3duIG9mIHRoZSB2aWV3cG9ydCwgaGlkaW5nIHRoZSB0ZXh0IGZpZWxkLCBoZWFkZXIsIGFueXRoaW5nLCBhbmQgb25seSB0aGVcbiAgICAgICAgICAgIC8vIGJsYW5rIGFyZWEgZ2V0cyBzaG93ZWQuIFRoYXQgYmFkIGF1dG9zY3JvbGwgY2FuIGJlIGZpeGVkIG9uIHRoaXMgc2luZ2xlIGNhc2Ugd2l0aCBuZXh0IHRyaWNrXG4gICAgICAgICAgICAvLyB3aXRob3V0IGZsaWNrZXJpbmcgb3IgYmFkIGVmZmVjdHMgKGFuZCBhbHRlcm5hdGl2ZSwgZ2VuZXJpYyBhcHByb2FjaCBpcyBkbyBpdCBvbiB0aGUga2V5Ym9hcmRTaG93XG4gICAgICAgICAgICAvLyBldmVudCwgYnV0IHRoZXJlIGEgZmxpY2tlcmluZyBoYXBwZW5zIGFuZCBtYXkgYWZmZWN0IGNhc2VzIHdoZXJlIHRoZXJlIGlzIG5vIG5lZWQgb3IgY2FuIGJlIHdvcnNlXG4gICAgICAgICAgICAvLyBpZiBmaWVsZCB2aXNpYmlsaXR5IGFuZCBhY3R1YWwgc2Nyb2xsIGlzIG5vdCBjaGVja2VkKTpcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgfSwgMTAwKTsgfSk7XG4gICAgICAgIFxuICAgICAgICBtb2RhbC5tb2RhbCgnc2hvdycpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gVGV4dEVkaXRvck1vZGVsKCkge1xuICAgIHRoaXMudGl0bGUgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICB0aGlzLnRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8vIGludGVybmFsIHV0aWxpdHkgZnVuY3Rpb24gJ3RvIHN0cmluZyB3aXRoIHR3byBkaWdpdHMgYWxtb3N0J1xuZnVuY3Rpb24gdHdvRGlnaXRzKG4pIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihuIC8gMTApICsgJycgKyBuICUgMTA7XG59XG5cbi8qKlxuICAgIFNob3dzIGEgdGltZSBwaWNrZXIsIGJhc2VkIG9uIGRpZmZlcmVudCBkcm9wZG93bnMgZm9yIGVhY2ggdGltZSBwYXJ0LlxuICAgIFN1cHBvcnRzIGhvdXJzIGFuZCBtaW51dGVzICh3aXRoIGFtL3BtIGZvciBVUyBsb2NhbGUpXG4gICAgQHBhcmFtIG9wdGlvbnM6T2JqZWN0IHtcbiAgICAgICAgdGl0bGU6c3RyaW5nIE9wdGlvbmFsLiBUaGUgdGV4dCB0byBzaG93IGluIHRoZSBtb2RhbCdzIGhlYWRlcixcbiAgICAgICAgICAgIHdpdGggZmFsbGJhY2sgdG8gdGhlIE1vZGFsJ3MgZGVmYXVsdCB0aXRsZS5cbiAgICB9XG4gICAgQHJldHVybnMgUHJvbWlzZS4gSXQgcmVzb2x2ZXMgd2hlbiBhIGJ1dHRvbiBpcyBwcmVzc2VkLCB3aXRoIG51bGwgb24gJ3Vuc2V0J1xuICAgIGFuZCBhbiBvYmplY3Qgd2l0aCB7IHRpbWU6b2JqZWN0LCB0aW1lU3RyaW5nOnN0cmluZyB9IG9uICdzZWxlY3QnLlxuICAgIFRoZSB0aW1lIG9iamVjdCBpcyBqdXN0IGEgcGxhaW4gb2JqZWN0IGFzIHsgaG91cnM6IDAsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgIElzIHJlamVjdGVkIHdoZW4gdGhlIG1vZGFsIGlzIGRpc21pc3NlZC9jbG9zZWQgd2l0aG91dCAndW5zZXQnIG9yICdzZWxlY3QnLlxuKiovXG5leHBvcnRzLnNob3cgPSBmdW5jdGlvbiBzaG93VGltZVBpY2tlcihvcHRpb25zKSB7XG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eToxMFxuXG4gICAgdmFyIG1vZGFsID0gJCgnI3RpbWVQaWNrZXJNb2RhbCcpLFxuICAgICAgICB2bSA9IG1vZGFsLmRhdGEoJ3ZpZXdtb2RlbCcpO1xuICAgIFxuICAgIGlmICghdm0pIHtcbiAgICAgICAgdm0gPSBuZXcgVGltZVBpY2tlck1vZGVsKCk7XG5cbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyh2bSwgbW9kYWwuZ2V0KDApKTtcbiAgICAgICAgbW9kYWwuZGF0YSgndmlld21vZGVsJywgdm0pO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRpdGxlXG4gICAgdm0udGl0bGUob3B0aW9ucy50aXRsZSB8fCAnU2VsZWN0IHRpbWUnKTtcbiAgICB2bS5zdGVwSW5NaW51dGVzKG9wdGlvbnMuc3RlcEluTWludXRlcyB8fCA1KTtcbiAgICBpZiAodHlwZW9mKG9wdGlvbnMuc2VsZWN0ZWRUaW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdm0uc2VsZWN0ZWRUaW1lU3RyaW5nKG9wdGlvbnMuc2VsZWN0ZWRUaW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZtLnNlbGVjdGVkVGltZShvcHRpb25zLnNlbGVjdGVkVGltZSB8fCB7fSk7XG4gICAgfVxuICAgIHZtLnVuc2V0TGFiZWwob3B0aW9ucy51bnNldExhYmVsIHx8ICdSZW1vdmUnKTtcbiAgICB2bS5zZWxlY3RMYWJlbChvcHRpb25zLnNlbGVjdExhYmVsIHx8ICdTZWxlY3QnKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGVyc1xuICAgICAgICB2YXIgdW5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICBtb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICB0aW1lOiB2bS5zZWxlY3RlZFRpbWUoKSxcbiAgICAgICAgICAgICAgICB0aW1lU3RyaW5nOiB2bS5zZWxlY3RlZFRpbWVTdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEp1c3QgY2xvc2VkIHdpdGhvdXQgcGljayBhbnl0aGluZywgcmVqZWN0c1xuICAgICAgICBtb2RhbC5vZmYoJ2hpZGUuYnMubW9kYWwnKTtcbiAgICAgICAgbW9kYWwub24oJ2hpZGUuYnMubW9kYWwnLCByZWplY3QpO1xuICAgICAgICBtb2RhbC5vZmYoJ2NsaWNrJywgJy50aW1lUGlja2VyTW9kYWwtdW5zZXQnKTtcbiAgICAgICAgbW9kYWwub24oJ2NsaWNrJywgJy50aW1lUGlja2VyTW9kYWwtdW5zZXQnLCB1bnNldCk7XG4gICAgICAgIG1vZGFsLm9mZignY2xpY2snLCAnLnRpbWVQaWNrZXJNb2RhbC1zZWxlY3QnKTtcbiAgICAgICAgbW9kYWwub24oJ2NsaWNrJywgJy50aW1lUGlja2VyTW9kYWwtc2VsZWN0Jywgc2VsZWN0KTtcblxuICAgICAgICBtb2RhbC5tb2RhbCgnc2hvdycpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gVGltZVBpY2tlck1vZGVsKCkge1xuICAgIFxuICAgIC8vIFNldC11cCB2aWV3bW9kZWwgYW5kIGJpbmRpbmdcbiAgICB2YXIgdm0gPSB7XG4gICAgICAgIHRpdGxlOiBrby5vYnNlcnZhYmxlKCcnKSxcbiAgICAgICAgcGlja2VkSG91cjoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgcGlja2VkTWludXRlOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICBwaWNrZWRBbXBtOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICBzdGVwSW5NaW51dGVzOiBrby5vYnNlcnZhYmxlKDUpLFxuICAgICAgICB1bnNldExhYmVsOiBrby5vYnNlcnZhYmxlKCdSZW1vdmUnKSxcbiAgICAgICAgc2VsZWN0TGFiZWw6IGtvLm9ic2VydmFibGUoJ1NlbGVjdCcpXG4gICAgfTtcbiAgICAvLyBUT0RPOiBNYWtlIGxvY2FsaXphdGlvbiBjaGFuZ2VzIHdpdGggYW55IGFwcCBsb2NhbGUgY2hhbmdlLCB3aXRoIHRpbWVpbnRlcnZhbCxcbiAgICAvLyBhcyBhIGNvbXB1dGVkIG9yIGNoYW5nZWQgYnkgZXZlbnRzOlxuICAgIHZtLmxvY2FsZSA9IGtvLm9ic2VydmFibGUoeyBsYW5nOiAnZW4nLCByZWdpb246ICdVUycgfSk7XG5cbiAgICB2bS5ob3VyVmFsdWVzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWdpb24gPSB0aGlzLmxvY2FsZSgpLnJlZ2lvbjtcbiAgICAgICAgdmFyIHN0ZXAgPSAodGhpcy5zdGVwSW5NaW51dGVzKCkgLyA2MCkgfDA7XG4gICAgICAgIC8vIElNUE9SVEFOVDogYXZvaWQgaW5maW5pdGUgbG9vcHM6XG4gICAgICAgIGlmIChzdGVwIDw9IDApIHN0ZXAgPSAxO1xuICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICBpO1xuICAgICAgICBpZiAocmVnaW9uID09PSAnVVMnKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgbGFiZWw6IDEyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCAxMjsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sIHZtKTtcbiAgICB2bS5taW51dGVWYWx1ZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgLy92YXIgcmVnaW9uID0gdGhpcy5sb2NhbGUoKS5yZWdpb247XG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwSW5NaW51dGVzKCkgfDA7XG4gICAgICAgIC8vIElNUE9SVEFOVDogYXZvaWQgaW5maW5pdGUgbG9vcHM6XG4gICAgICAgIGlmIChzdGVwIDw9IDApIHN0ZXAgPSAxO1xuICAgICAgICAvLyBObyBtaW51dGVzP1xuICAgICAgICBpZiAoc3RlcCA+PSA2MCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgLy9pZiAocmVnaW9uID09PSAnVVMnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjA7IGkgKz0gc3RlcCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0d29EaWdpdHMoaSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSwgdm0pO1xuICAgIHZtLmFtcG1WYWx1ZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IHRoaXMubG9jYWxlKCkucmVnaW9uO1xuXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ1VTJykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLCAvLyBhZGRlZCB0byBob3Vyc1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnQU0nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMTIsIC8vIGFkZGVkIHRvIGhvdXJzXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdQTSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSwgdm0pO1xuXG4gICAgdm0uc2VsZWN0ZWRUaW1lID0ga28uY29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG91cnM6IHRoaXMucGlja2VkSG91cigpICsgdGhpcy5waWNrZWRBbXBtKCksXG4gICAgICAgICAgICAgICAgbWludXRlczogdGhpcy5waWNrZWRNaW51dGUoKSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih2KSAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBmb3IgdGhlIHRpbWUgcGlja2VyLiBWYWx1ZTonLCB2KTtcbiAgICAgICAgICAgIHYgPSB2IHx8IHt9O1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHRoaXMubG9jYWxlKCkucmVnaW9uO1xuICAgICAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ1VTJykge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja2VkSG91cigodi5ob3VycyAvIDEyKSB8MCk7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrZWRNaW51dGUodi5taW51dGVzIHwwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tlZEFtcG0oKHYuaG91cnMgJSAxMikgfDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrZWRIb3VyKHYuaG91cnMgfDApO1xuICAgICAgICAgICAgICAgIHRoaXMucGlja2VkTWludXRlKHYubWludXRlcyB8MCk7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrZWRBbXBtKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdm1cbiAgICB9KTtcblxuICAgIHZtLnNlbGVjdGVkVGltZVN0cmluZyA9IGtvLmNvbXB1dGVkKHtcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuc2VsZWN0ZWRUaW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gdHdvRGlnaXRzKHQuaG91cnMpICsgJzonICsgdHdvRGlnaXRzKHQubWludXRlcykgKyAnOicgKyB0d29EaWdpdHModC5zZWNvbmRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHYgPSB2IHx8ICcnO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gdi5zcGxpdCgnOicpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRpbWUoe1xuICAgICAgICAgICAgICAgIGhvdXJzOiBwYXJ0c1swXSB8MCxcbiAgICAgICAgICAgICAgICBtaW51dGVzOiBwYXJ0c1sxXSB8MCxcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiBwYXJ0c1syXSB8MFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bmVyOiB2bVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB2bTtcbn1cbiIsIi8qKiBBZGRyZXNzIG1vZGVsICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBBZGRyZXNzKHZhbHVlcykge1xuXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgYWRkcmVzc0lEOiAwLFxuICAgICAgICBhZGRyZXNzTmFtZTogJycsXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXG4gICAgICAgIHVzZXJJRDogMCxcbiAgICAgICAgYWRkcmVzc0xpbmUxOiBudWxsLFxuICAgICAgICBhZGRyZXNzTGluZTI6IG51bGwsXG4gICAgICAgIHBvc3RhbENvZGU6IG51bGwsXG4gICAgICAgIGNpdHk6IG51bGwsIC8vIEF1dG9maWxsZWQgYnkgc2VydmVyXG4gICAgICAgIHN0YXRlUHJvdmluY2VDb2RlOiBudWxsLCAvLyBBdXRvZmlsbGVkIGJ5IHNlcnZlclxuICAgICAgICBzdGF0ZVByb3ZpbmNlTmFtZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcbiAgICAgICAgY291bnRyeUNvZGU6IG51bGwsIC8vIElTTyBBbHBoYS0yIGNvZGUsIEV4LjogJ1VTJ1xuICAgICAgICBsYXRpdHVkZTogbnVsbCxcbiAgICAgICAgbG9uZ2l0dWRlOiBudWxsLFxuICAgICAgICBzcGVjaWFsSW5zdHJ1Y3Rpb25zOiBudWxsLFxuICAgICAgICBpc1NlcnZpY2VBcmVhOiBmYWxzZSxcbiAgICAgICAgaXNTZXJ2aWNlTG9jYXRpb246IGZhbHNlLFxuICAgICAgICBzZXJ2aWNlUmFkaXVzOiAwLFxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsIC8vIEF1dG9maWxsZWQgYnkgc2VydmVyXG4gICAgICAgIGtpbmQ6ICcnIC8vIEF1dG9maWxsZWQgYnkgc2VydmVyXG4gICAgfSwgdmFsdWVzKTtcbiAgICBcbiAgICB0aGlzLnNpbmdsZUxpbmUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBsaXN0ID0gW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzTGluZTEoKSxcbiAgICAgICAgICAgIHRoaXMuY2l0eSgpLFxuICAgICAgICAgICAgdGhpcy5wb3N0YWxDb2RlKCksXG4gICAgICAgICAgICB0aGlzLnN0YXRlUHJvdmluY2VDb2RlKClcbiAgICAgICAgXTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbih2KSB7IHJldHVybiAhIXY7IH0pLmpvaW4oJywgJyk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLy8gVE9ETzogbmVlZGVkPyBsMTBuPyBtdXN0IGJlIHByb3ZpZGVkIGJ5IHNlcnZlciBzaWRlP1xuICAgIHZhciBjb3VudHJpZXMgPSB7XG4gICAgICAgICdVUyc6ICdVbml0ZWQgU3RhdGVzJyxcbiAgICAgICAgJ0VTJzogJ1NwYWluJ1xuICAgIH07XG4gICAgdGhpcy5jb3VudHJ5TmFtZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY291bnRyaWVzW3RoaXMuY291bnRyeUNvZGUoKV0gfHwgJ3Vua25vdyc7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBVc2VmdWwgR1BTIG9iamVjdCB3aXRoIHRoZSBmb3JtYXQgdXNlZCBieSBHb29nbGUgTWFwc1xuICAgIHRoaXMubGF0bG5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXQ6IHRoaXMubGF0aXR1ZGUoKSxcbiAgICAgICAgICAgIGxuZzogdGhpcy5sb25naXR1ZGUoKVxuICAgICAgICB9O1xuICAgIH0sIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFkZHJlc3M7XG5cbi8vIFB1YmxpYyBFbnVtZXJhdGlvbiBmb3IgdGhlICdraW5kJyBwcm9wZXJ0eTpcbkFkZHJlc3Mua2luZCA9IHtcbiAgICBob21lOiAnaG9tZScsXG4gICAgYmlsbGluZzogJ2JpbGxpbmcnLFxuICAgIHNlcnZpY2U6ICdzZXJ2aWNlJ1xufTtcbiIsIi8qKiBBcHBvaW50bWVudCBtb2RlbCAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcbiAgICBQcmljaW5nU3VtbWFyeURldGFpbCA9IHJlcXVpcmUoJy4vUHJpY2luZ1N1bW1hcnlEZXRhaWwnKSxcbiAgICBDYWxlbmRhckV2ZW50ID0gcmVxdWlyZSgnLi9DYWxlbmRhckV2ZW50JyksXG4gICAgQm9va2luZyA9IHJlcXVpcmUoJy4vQm9va2luZycpO1xuXG5mdW5jdGlvbiBBcHBvaW50bWVudCh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIC8vIEFuIGFwcG9pbnRtZW50IGV2ZXIgcmVmZXJlbmNlcyBhbiBldmVudCwgYW5kIGl0cyAnaWQnIGlzIGEgQ2FsZW5kYXJFdmVudElEXG4gICAgICAgIC8vIGV2ZW4gaWYgb3RoZXIgY29tcGxlbWVudGFyeSBvYmplY3QgYXJlIHVzZWQgYXMgJ3NvdXJjZSdcbiAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgIFxuICAgICAgICBzdGFydFRpbWU6IG51bGwsXG4gICAgICAgIGVuZFRpbWU6IG51bGwsXG4gICAgICAgIFxuICAgICAgICAvLyBDb21tb25FdmVudCBmaWVsZHM6XG4gICAgICAgIHN1bW1hcnk6ICdOZXcgYm9va2luZycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICBcbiAgICAgICAgLy8gRXZlbnQgc3BlY2lmaWMgZmllbGRzOlxuICAgICAgICBpc0FsbERheTogZmFsc2UsXG5cbiAgICAgICAgLy8gRmllbGRzIHNwZWNpZmljIGZvciBib29raW5nc1xuICAgICAgICBwcmljZTogMCxcbiAgICAgICAgLy8gQWN0dWFsIGJvb2tpbmdzIGZpZWxkcyB0byB1c2Ugb24gcG9zdC9wdXRcbiAgICAgICAgY2xpZW50VXNlcklEOiBudWxsLFxuICAgICAgICBwcmljaW5nOiB7XG4gICAgICAgICAgICBNb2RlbDogUHJpY2luZ1N1bW1hcnlEZXRhaWwsXG4gICAgICAgICAgICBpc0FycmF5OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGFkZHJlc3NJRDogbnVsbCxcbiAgICAgICAgcHJlTm90ZXNUb0NsaWVudDogbnVsbCxcbiAgICAgICAgcG9zdE5vdGVzVG9DbGllbnQ6IG51bGwsXG4gICAgICAgIHByZU5vdGVzVG9TZWxmOiBudWxsLFxuICAgICAgICBwb3N0Tm90ZXNUb1NlbGY6IG51bGwsXG4gICAgICAgIFxuICAgICAgICBqb2JUaXRsZUlEOiAwLFxuICAgICAgICBcbiAgICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgICBcbiAgICAgICAgc291cmNlRXZlbnQ6IHtcbiAgICAgICAgICAgIE1vZGVsOiBDYWxlbmRhckV2ZW50LFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZUJvb2tpbmc6IHtcbiAgICAgICAgICAgIE1vZGVsOiBCb29raW5nLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gICAgICAgIH1cbiAgICB9LCB2YWx1ZXMpO1xuXG4gICAgLy8gU21hcnQgdmlzdWFsaXphdGlvbiBvZiBkYXRlIGFuZCB0aW1lXG4gICAgdGhpcy5kaXNwbGF5ZWREYXRlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLnN0YXJ0VGltZSgpKS5sb2NhbGUoJ2VuLVVTLUxDJykuY2FsZW5kYXIoKTtcbiAgICAgICAgXG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5kaXNwbGF5ZWRTdGFydFRpbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuc3RhcnRUaW1lKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5mb3JtYXQoJ0xUJyk7XG4gICAgICAgIFxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZGlzcGxheWVkRW5kVGltZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBtb21lbnQodGhpcy5lbmRUaW1lKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5mb3JtYXQoJ0xUJyk7XG4gICAgICAgIFxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZGlzcGxheWVkVGltZVJhbmdlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkU3RhcnRUaW1lKCkgKyAnLScgKyB0aGlzLmRpc3BsYXllZEVuZFRpbWUoKTtcbiAgICAgICAgXG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5pdFN0YXJ0ZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGFydFRpbWUoKSAmJiBuZXcgRGF0ZSgpID49IHRoaXMuc3RhcnRUaW1lKCkpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuaXRFbmRlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVuZFRpbWUoKSAmJiBuZXcgRGF0ZSgpID49IHRoaXMuZW5kVGltZSgpKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmlzTmV3ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmlkKCkpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuc3RhdGVIZWFkZXIgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5pZCgpID4gMCAmJiB0aGlzLnNvdXJjZUV2ZW50KCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VCb29raW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJ0NhbGVuZGFyIGJsb2NrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXRTdGFydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdEVuZGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICdDb21wbGV0ZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICdOb3cnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSAnVXBjb21pbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIFxuICAgIH0sIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcG9pbnRtZW50O1xuXG4vKipcbiAgICBDcmVhdGVzIGFuIGFwcG9pbnRtZW50IGluc3RhbmNlIGZyb20gYSBDYWxlbmRhckV2ZW50IG1vZGVsIGluc3RhbmNlXG4qKi9cbkFwcG9pbnRtZW50LmZyb21DYWxlbmRhckV2ZW50ID0gZnVuY3Rpb24gZnJvbUNhbGVuZGFyRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgYXB0ID0gbmV3IEFwcG9pbnRtZW50KCk7XG4gICAgXG4gICAgLy8gSW5jbHVkZSBldmVudCBpbiBhcHRcbiAgICBhcHQuaWQoZXZlbnQuY2FsZW5kYXJFdmVudElEKCkpO1xuICAgIGFwdC5zdGFydFRpbWUoZXZlbnQuc3RhcnRUaW1lKCkpO1xuICAgIGFwdC5lbmRUaW1lKGV2ZW50LmVuZFRpbWUoKSk7XG4gICAgYXB0LnN1bW1hcnkoZXZlbnQuc3VtbWFyeSgpKTtcbiAgICBhcHQuZGVzY3JpcHRpb24oZXZlbnQuZGVzY3JpcHRpb24oKSk7XG4gICAgYXB0LmlzQWxsRGF5KGV2ZW50LmlzQWxsRGF5KCkpO1xuICAgIGFwdC5yZWFkT25seShldmVudC5yZWFkT25seSgpKTtcbiAgICBhcHQuc291cmNlRXZlbnQoZXZlbnQpO1xuICAgIFxuICAgIHJldHVybiBhcHQ7XG59O1xuXG4vKipcbiAgICBDcmVhdGVzIGFuIGFwcG9pbnRtZW50IGluc3RhbmNlIGZyb20gYSBCb29raW5nIGFuZCBhIENhbGVuZGFyRXZlbnQgbW9kZWwgaW5zdGFuY2VzXG4qKi9cbkFwcG9pbnRtZW50LmZyb21Cb29raW5nID0gZnVuY3Rpb24gZnJvbUJvb2tpbmcoYm9va2luZywgZXZlbnQpIHtcbiAgICAvLyBJbmNsdWRlIGV2ZW50IGluIGFwdFxuICAgIHZhciBhcHQgPSBBcHBvaW50bWVudC5mcm9tQ2FsZW5kYXJFdmVudChldmVudCk7XG4gICAgXG4gICAgLy8gSW5jbHVkZSBib29raW5nIGluIGFwdFxuICAgIGFwdC5jbGllbnRVc2VySUQoYm9va2luZy5jbGllbnRVc2VySUQoKSk7XG4gICAgYXB0LmFkZHJlc3NJRChib29raW5nLnNlcnZpY2VBZGRyZXNzSUQoKSk7XG4gICAgYXB0LmpvYlRpdGxlSUQoYm9va2luZy5qb2JUaXRsZUlEKCkpO1xuICAgIGFwdC5wcmljaW5nKGJvb2tpbmcucHJpY2luZ1N1bW1hcnkoKSAmJiBib29raW5nLnByaWNpbmdTdW1tYXJ5KCkuZGV0YWlscygpKTtcbiAgICBhcHQucHJlTm90ZXNUb0NsaWVudChib29raW5nLnByZU5vdGVzVG9DbGllbnQoKSk7XG4gICAgYXB0LnBvc3ROb3Rlc1RvQ2xpZW50KGJvb2tpbmcucG9zdE5vdGVzVG9DbGllbnQoKSk7XG4gICAgYXB0LnByZU5vdGVzVG9TZWxmKGJvb2tpbmcucHJlTm90ZXNUb1NlbGYoKSk7XG4gICAgYXB0LnBvc3ROb3Rlc1RvU2VsZihib29raW5nLnBvc3ROb3Rlc1RvU2VsZigpKTtcbiAgICBcbiAgICAvLyBPbiBib29raW5ncywgcmVhZE9ubHkgbXVzdCBzZXQgdG8gZmFsc2UgKGlzIHNlbnQgYXMgdHJ1ZSBldmVyIGZyb21cbiAgICAvLyB0aGUgc2VydmVyLCB0byBwcmV2ZW50IGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgdGhlIGV2ZW50IHRoYXQgaXMgcGFydCBvZlxuICAgIC8vIGEgYm9va2luZ1xuICAgIGFwdC5yZWFkT25seShmYWxzZSk7XG5cbiAgICB2YXIgcHJpY2VzID0gYm9va2luZy5wcmljaW5nU3VtbWFyeSgpO1xuICAgIGlmIChwcmljZXMpIHtcbiAgICAgICAgLy8gVE9ETyBTZXR0aW5nIHNlcnZpY2UgcHJvZmVzc2lvbmFsIHByaWNlLCBmb3IgY2xpZW50cyBtdXN0IGJlXG4gICAgICAgIC8vIGp1c3QgdG90YWxQcmljZSgpXG4gICAgICAgIGFwdC5wcmljZShwcmljZXMudG90YWxQcmljZSgpIC0gcHJpY2VzLnBGZWVQcmljZSgpKTtcbiAgICB9XG5cbiAgICBhcHQuc291cmNlQm9va2luZyhib29raW5nKTtcblxuICAgIHJldHVybiBhcHQ7XG59O1xuXG4vKipcbiAgICBDcmVhdGVzIGEgbGlzdCBvZiBhcHBvaW50bWVudCBpbnN0YW5jZXMgZnJvbSB0aGUgbGlzdCBvZiBldmVudHMgYW5kIGJvb2tpbmdzLlxuICAgIFRoZSBib29raW5ncyBsaXN0IG11c3QgY29udGFpbiBldmVyeSBib29raW5nIHRoYXQgYmVsb25ncyB0byB0aGUgZXZlbnRzIG9mIHR5cGVcbiAgICAnYm9va2luZycgZnJvbSB0aGUgbGlzdCBvZiBldmVudHMuXG4qKi9cbkFwcG9pbnRtZW50Lmxpc3RGcm9tQ2FsZW5kYXJFdmVudHNCb29raW5ncyA9IGZ1bmN0aW9uIGxpc3RGcm9tQ2FsZW5kYXJFdmVudHNCb29raW5ncyhldmVudHMsIGJvb2tpbmdzKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5tYXAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGJvb2tpbmcgPSBudWxsO1xuICAgICAgICBib29raW5ncy5zb21lKGZ1bmN0aW9uKHNlYXJjaEJvb2tpbmcpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHNlYXJjaEJvb2tpbmcuc2VydmljZURhdGVJRCgpID09PSBldmVudC5jYWxlbmRhckV2ZW50SUQoKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIGJvb2tpbmcgPSBzZWFyY2hCb29raW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYm9va2luZylcbiAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tQm9va2luZyhib29raW5nLCBldmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBBcHBvaW50bWVudC5mcm9tQ2FsZW5kYXJFdmVudChldmVudCk7XG4gICAgfSk7XG59O1xuXG5BcHBvaW50bWVudC5zcGVjaWFsSWRzID0ge1xuICAgIGxvYWRpbmc6IDAsXG4gICAgZW1wdHlEYXRlOiAtMSxcbiAgICBmcmVlOiAtMixcbiAgICBuZXdFdmVudDogLTMsXG4gICAgbmV3Qm9va2luZzogLTQsXG4gICAgdW5hdmFpbGFibGU6IC01LFxuICAgIHByZXBhcmF0aW9uVGltZTogLTZcbn07XG5cbnZhciBUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvVGltZScpO1xuLyoqXG4gICAgQ3JlYXRlcyBhbiBBcHBvaW50bWVudCBpbnN0YW5jZSB0aGF0IHJlcHJlc2VudHMgYSBjYWxlbmRhciBzbG90IG9mXG4gICAgZnJlZS9zcGFyZSB0aW1lLCBmb3IgdGhlIGdpdmVuIHRpbWUgcmFuZ2UsIG9yIHRoZSBmdWxsIGdpdmVuIGRhdGUuXG4gICAgQHBhcmFtIG9wdGlvbnM6T2JqZWN0IHtcbiAgICAgICAgZGF0ZTpEYXRlLiBPcHRpb25hbC4gVXNlZCB0byBjcmVhdGUgYSBmdWxsIGRhdGUgc2xvdCBvciBkZWZhdWx0IGZvciBzdGFydC9lbmRcbiAgICAgICAgICAgIHRvIGRhdGUgc3RhcnQgb3IgZGF0ZSBlbmRcbiAgICAgICAgc3RhcnQ6RGF0ZS4gT3B0aW9uYWwuIEJlZ2dpbmluZyBvZiB0aGUgc2xvdFxuICAgICAgICBlbmQ6RGF0ZS4gT3B0aW9uYWwuIEVuZGluZyBvZiB0aGUgc2xvdFxuICAgICAgICB0ZXh0OnN0cmluZy4gT3B0aW9uYWwgWydGcmVlJ10uIFRvIGFsbG93IGV4dGVybmFsIGxvY2FsaXphdGlvbiBvZiB0aGUgdGV4dC5cbiAgICB9XG4qKi9cbkFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90ID0gZnVuY3Rpb24gbmV3RnJlZVNsb3Qob3B0aW9ucykge1xuICAgIFxuICAgIHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgbmV3IFRpbWUob3B0aW9ucy5kYXRlLCAwLCAwLCAwKSxcbiAgICAgICAgZW5kID0gb3B0aW9ucy5lbmQgfHwgbmV3IFRpbWUob3B0aW9ucy5kYXRlLCAwLCAwLCAwKTtcblxuICAgIHJldHVybiBuZXcgQXBwb2ludG1lbnQoe1xuICAgICAgICBpZDogQXBwb2ludG1lbnQuc3BlY2lhbElkcy5mcmVlLFxuXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnQsXG4gICAgICAgIGVuZFRpbWU6IGVuZCxcblxuICAgICAgICBzdW1tYXJ5OiBvcHRpb25zLnRleHQgfHwgJ0ZyZWUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbFxuICAgIH0pO1xufTtcblxuQXBwb2ludG1lbnQubmV3VW5hdmFpbGFibGVTbG90ID0gZnVuY3Rpb24gbmV3VW5hdmFpbGFibGVTbG90KG9wdGlvbnMpIHtcbiAgICBcbiAgICB2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IG5ldyBUaW1lKG9wdGlvbnMuZGF0ZSwgMCwgMCwgMCksXG4gICAgICAgIGVuZCA9IG9wdGlvbnMuZW5kIHx8IG5ldyBUaW1lKG9wdGlvbnMuZGF0ZSwgMCwgMCwgMCk7XG5cbiAgICByZXR1cm4gbmV3IEFwcG9pbnRtZW50KHtcbiAgICAgICAgaWQ6IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMudW5hdmFpbGFibGUsXG5cbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydCxcbiAgICAgICAgZW5kVGltZTogZW5kLFxuXG4gICAgICAgIHN1bW1hcnk6IG9wdGlvbnMudGV4dCB8fCAnVW5hdmFpbGFibGUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbFxuICAgIH0pO1xufTtcblxuQXBwb2ludG1lbnQubmV3UHJlcGFyYXRpb25UaW1lU2xvdCA9IGZ1bmN0aW9uIG5ld1ByZXBhcmF0aW9uVGltZVNsb3Qob3B0aW9ucykge1xuXG4gICAgdmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCBuZXcgVGltZShvcHRpb25zLmRhdGUsIDAsIDAsIDApLFxuICAgICAgICBlbmQgPSBvcHRpb25zLmVuZCB8fCBuZXcgVGltZShvcHRpb25zLmRhdGUsIDAsIDAsIDApO1xuXG4gICAgcmV0dXJuIG5ldyBBcHBvaW50bWVudCh7XG4gICAgICAgIGlkOiBBcHBvaW50bWVudC5zcGVjaWFsSWRzLnByZXBhcmF0aW9uVGltZSxcblxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0LFxuICAgICAgICBlbmRUaW1lOiBlbmQsXG5cbiAgICAgICAgc3VtbWFyeTogb3B0aW9ucy50ZXh0IHx8ICdQcmVwYXJhdGlvbiB0aW1lJyxcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGxcbiAgICB9KTtcbn07IiwiLyoqIEJvb2tpbmcgbW9kZWwuXG5cbiAgICBEZXNjcmliZXMgYSBib29raW5nIGFuZCByZWxhdGVkIGRhdGEsXG4gICAgbWFpbmx5IHRoZSBwcmljaW5nIHN1bW1hcnkgYW5kIGRldGFpbHMsIGJ1dFxuICAgIGNhbiBob2xkIG90aGVyIHJlbGF0ZWQgZGF0YSBpZiBvcHRpb25hbGx5IGxvYWRlZFxuICAgIChhZGRyZXNzLCBkYXRlcywgcHVibGljVXNlckpvYlRpdGxlKVxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgUHJpY2luZ1N1bW1hcnkgPSByZXF1aXJlKCcuL1ByaWNpbmdTdW1tYXJ5JyksXG4gICAgUHVibGljVXNlckpvYlRpdGxlID0gcmVxdWlyZSgnLi9QdWJsaWNVc2VySm9iVGl0bGUnKSxcbiAgICBBZGRyZXNzID0gcmVxdWlyZSgnLi9BZGRyZXNzJyksXG4gICAgRXZlbnREYXRlcyA9IHJlcXVpcmUoJy4vRXZlbnREYXRlcycpO1xuXG5mdW5jdGlvbiBCb29raW5nKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgYm9va2luZ0lEOiAwLFxuICAgICAgICBjbGllbnRVc2VySUQ6IDAsXG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxVc2VySUQ6IDAsXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXG4gICAgICAgIGxhbmd1YWdlSUQ6IDAsXG4gICAgICAgIGNvdW50cnlJRDogMCxcbiAgICAgICAgYm9va2luZ1N0YXR1c0lEOiAwLFxuICAgICAgICBib29raW5nVHlwZUlEOiAwLFxuICAgICAgICBjYW5jZWxsYXRpb25Qb2xpY3lJRDogMCxcbiAgICAgICAgcGFyZW50Qm9va2luZ0lEOiBudWxsLFxuICAgICAgICBcbiAgICAgICAgc2VydmljZUFkZHJlc3NJRDogbnVsbCxcbiAgICAgICAgc2VydmljZURhdGVJRDogbnVsbCxcbiAgICAgICAgYWx0ZXJuYXRpdmVEYXRlMUlEOiBudWxsLFxuICAgICAgICBhbHRlcm5hdGl2ZURhdGUySUQ6IG51bGwsXG4gICAgICAgIFxuICAgICAgICBwcmljaW5nU3VtbWFyeUlEOiAwLFxuICAgICAgICBwcmljaW5nU3VtbWFyeVJldmlzaW9uOiAwLFxuICAgICAgICBwYXltZW50TGFzdEZvdXJDYXJkTnVtYmVyRGlnaXRzOiBudWxsLFxuICAgICAgICB0b3RhbFByaWNlUGFpZEJ5Q2xpZW50OiBudWxsLFxuICAgICAgICB0b3RhbFNlcnZpY2VGZWVzUGFpZEJ5Q2xpZW50OiBudWxsLFxuICAgICAgICB0b3RhbFBhaWRUb1NlcnZpY2VQcm9mZXNzaW9uYWw6IG51bGwsXG4gICAgICAgIHRvdGFsU2VydmljZUZlZXNQYWlkQnlTZXJ2aWNlUHJvZmVzc2lvbmFsOiBudWxsLFxuXG4gICAgICAgIGluc3RhbnRCb29raW5nOiBmYWxzZSxcbiAgICAgICAgZmlyc3RUaW1lQm9va2luZzogZmFsc2UsXG4gICAgICAgIHNlbmRSZW1pbmRlcjogZmFsc2UsXG4gICAgICAgIHNlbmRQcm9tb3Rpb25hbDogZmFsc2UsXG4gICAgICAgIHJlY3VycmVudDogZmFsc2UsXG4gICAgICAgIG11bHRpU2Vzc2lvbjogZmFsc2UsXG4gICAgICAgIHByaWNpbmdBZGp1c3RtZW50QXBwbGllZDogZmFsc2UsXG4gICAgICAgIHBheW1lbnRFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgcGF5bWVudENvbGxlY3RlZDogZmFsc2UsXG4gICAgICAgIHBheW1lbnRhdXRob3JpemVkOiBmYWxzZSxcbiAgICAgICAgYXdhaXRpbmdSZXNwb25zZUZyb21Vc2VySUQ6IG51bGwsXG4gICAgICAgIHByaWNpbmdBZGp1c3RtZW50UmVxdWVzdGVkOiBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsLFxuICAgICAgICBcbiAgICAgICAgc3BlY2lhbFJlcXVlc3RzOiBudWxsLFxuICAgICAgICBwcmVOb3Rlc1RvQ2xpZW50OiBudWxsLFxuICAgICAgICBwb3N0Tm90ZXNUb0NsaWVudDogbnVsbCxcbiAgICAgICAgcHJlTm90ZXNUb1NlbGY6IG51bGwsXG4gICAgICAgIHBvc3ROb3Rlc1RvU2VsZjogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIHJldmlld2VkQnlTZXJ2aWNlUHJvZmVzc2lvbmFsOiBmYWxzZSxcbiAgICAgICAgcmV2aWV3ZWRCeUNsaWVudDogZmFsc2UsXG4gICAgICAgIFxuICAgICAgICBwcmljaW5nU3VtbWFyeTogbmV3IFByaWNpbmdTdW1tYXJ5KCksXG4gICAgICAgIHNlcnZpY2VBZGRyZXNzOiB7XG4gICAgICAgICAgICBNb2RlbDogQWRkcmVzc1xuICAgICAgICB9LFxuICAgICAgICBzZXJ2aWNlRGF0ZToge1xuICAgICAgICAgICAgTW9kZWw6IEV2ZW50RGF0ZXNcbiAgICAgICAgfSxcbiAgICAgICAgYWx0ZXJuYXRpdmVEYXRlMToge1xuICAgICAgICAgICAgTW9kZWw6IEV2ZW50RGF0ZXNcbiAgICAgICAgfSxcbiAgICAgICAgYWx0ZXJuYXRpdmVEYXRlMjoge1xuICAgICAgICAgICAgTW9kZWw6IEV2ZW50RGF0ZXNcbiAgICAgICAgfSxcbiAgICAgICAgdXNlckpvYlRpdGxlOiB7XG4gICAgICAgICAgICBNb2RlbDogUHVibGljVXNlckpvYlRpdGxlXG4gICAgICAgIH1cbiAgICB9LCB2YWx1ZXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJvb2tpbmc7XG5cbkJvb2tpbmcuZnJvbSA9IGZ1bmN0aW9uIGZyb20oZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBkYXRhLm1hcChCb29raW5nLmZyb20pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb29raW5nKGRhdGEpO1xuICAgIH1cbn07XG4iLCIvKiogQm9va2luZ1N1bW1hcnkgbW9kZWwgKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG4gICAgXG5mdW5jdGlvbiBCb29raW5nU3VtbWFyeSh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHF1YW50aXR5OiAwLFxuICAgICAgICBjb25jZXB0OiAnJyxcbiAgICAgICAgdGltZTogbnVsbCxcbiAgICAgICAgdGltZUZvcm1hdDogJyBbQF0gaDptbWEnXG4gICAgfSwgdmFsdWVzKTtcblxuICAgIHRoaXMucGhyYXNlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB0ID0gdGhpcy50aW1lRm9ybWF0KCkgJiYgXG4gICAgICAgICAgICB0aGlzLnRpbWUoKSAmJiBcbiAgICAgICAgICAgIG1vbWVudCh0aGlzLnRpbWUoKSkuZm9ybWF0KHRoaXMudGltZUZvcm1hdCgpKSB8fFxuICAgICAgICAgICAgJyc7ICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2VwdCgpICsgdDtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMudXJsID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXJsID0gdGhpcy50aW1lKCkgJiZcbiAgICAgICAgICAgICcvY2FsZW5kYXIvJyArIHRoaXMudGltZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0sIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJvb2tpbmdTdW1tYXJ5O1xuIiwiLyoqXG4gICAgRXZlbnQgbW9kZWxcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBFeGFtcGxlIEpTT04gKHJldHVybmVkIGJ5IHRoZSBSRVNUIEFQSSk6XG57XG4gIFwiRXZlbnRJRFwiOiAzNTMsXG4gIFwiVXNlcklEXCI6IDE0MSxcbiAgXCJFdmVudFR5cGVJRFwiOiAzLFxuICBcIlN1bW1hcnlcIjogXCJIb3VzZWtlZXBlciBzZXJ2aWNlcyBmb3IgSm9obiBELlwiLFxuICBcIkF2YWlsYWJpbGl0eVR5cGVJRFwiOiAzLFxuICBcIlN0YXJ0VGltZVwiOiBcIjIwMTQtMDMtMjVUMDg6MDA6MDBaXCIsXG4gIFwiRW5kVGltZVwiOiBcIjIwMTQtMDMtMjVUMTg6MDA6MDBaXCIsXG4gIFwiS2luZFwiOiAwLFxuICBcIklzQWxsRGF5XCI6IGZhbHNlLFxuICBcIlRpbWVab25lXCI6IFwiMDE6MDA6MDBcIixcbiAgXCJMb2NhdGlvblwiOiBcIm51bGxcIixcbiAgXCJVcGRhdGVkRGF0ZVwiOiBcIjIwMTQtMTAtMzBUMTU6NDQ6NDkuNjUzXCIsXG4gIFwiQ3JlYXRlZERhdGVcIjogbnVsbCxcbiAgXCJEZXNjcmlwdGlvblwiOiBcInRlc3QgZGVzY3JpcHRpb24gb2YgYSBSRVNUIGV2ZW50XCIsXG4gIFwiUmVjdXJyZW5jZVJ1bGVcIjoge1xuICAgIFwiRnJlcXVlbmN5VHlwZUlEXCI6IDUwMixcbiAgICBcIkludGVydmFsXCI6IDEsXG4gICAgXCJVbnRpbFwiOiBcIjIwMTQtMDctMDFUMDA6MDA6MDBcIixcbiAgICBcIkNvdW50XCI6IG51bGwsXG4gICAgXCJFbmRpbmdcIjogXCJkYXRlXCIsXG4gICAgXCJTZWxlY3RlZFdlZWtEYXlzXCI6IFtcbiAgICAgIDEsXG4gICAgXSxcbiAgICBcIk1vbnRobHlXZWVrRGF5XCI6IGZhbHNlLFxuICAgIFwiSW5jb21wYXRpYmxlXCI6IGZhbHNlLFxuICAgIFwiVG9vTWFueVwiOiBmYWxzZVxuICB9LFxuICBcIlJlY3VycmVuY2VPY2N1cnJlbmNlc1wiOiBudWxsLFxuICBcIlJlYWRPbmx5XCI6IGZhbHNlXG59Ki9cblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBSZWN1cnJlbmNlUnVsZSh2YWx1ZXMpIHtcbiAgICBNb2RlbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBmcmVxdWVuY3lUeXBlSUQ6IDAsXG4gICAgICAgIGludGVydmFsOiAxLCAvLzpJbnRlZ2VyXG4gICAgICAgIHVudGlsOiBudWxsLCAvLzpEYXRlXG4gICAgICAgIGNvdW50OiBudWxsLCAvLzpJbnRlZ2VyXG4gICAgICAgIGVuZGluZzogbnVsbCwgLy8gOnN0cmluZyBQb3NzaWJsZSB2YWx1ZXMgYWxsb3dlZDogJ25ldmVyJywgJ2RhdGUnLCAnb2N1cnJlbmNlcydcbiAgICAgICAgc2VsZWN0ZWRXZWVrRGF5czogW10sIC8vIDppbnRlZ2VyW10gMDpTdW5kYXlcbiAgICAgICAgbW9udGhseVdlZWtEYXk6IGZhbHNlLFxuICAgICAgICBpbmNvbXBhdGlibGU6IGZhbHNlLFxuICAgICAgICB0b29NYW55OiBmYWxzZVxuICAgIH0sIHZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIFJlY3VycmVuY2VPY2N1cnJlbmNlKHZhbHVlcykge1xuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHN0YXJ0VGltZTogbnVsbCwgLy86RGF0ZVxuICAgICAgICBlbmRUaW1lOiBudWxsIC8vOkRhdGVcbiAgICB9LCB2YWx1ZXMpO1xufVxuICAgXG5mdW5jdGlvbiBDYWxlbmRhckV2ZW50KHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgdmFsdWVzOiBkYXRlcyBtdXN0IGJlIGNvbnZlcnRlZFxuICAgIC8vIHRvIGEgRGF0ZSBvYmplY3QuIFRoZXkgY29tZSBhcyBJU08gc3RyaW5nXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIHNvbWV0aGluZyBnZW5lcmljLCBvciBldmVuIGluIE1vZGVsIGRlZmluaXRpb25zLFxuICAgIC8vIGFuZCB1c2UgZm9yIHVwZGF0ZWQvY3JlYXRlZERhdGUgYXJvdW5kIGFsbCB0aGUgcHJvamVjdFxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzLnN0YXJ0VGltZSA9IHZhbHVlcy5zdGFydFRpbWUgJiYgbmV3IERhdGUoRGF0ZS5wYXJzZSh2YWx1ZXMuc3RhcnRUaW1lKSkgfHwgbnVsbDtcbiAgICAgICAgdmFsdWVzLmVuZFRpbWUgPSB2YWx1ZXMuZW5kVGltZSAmJiBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlcy5lbmRUaW1lKSkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBjYWxlbmRhckV2ZW50SUQ6IDAsXG4gICAgICAgIHVzZXJJRDogMCxcbiAgICAgICAgZXZlbnRUeXBlSUQ6IDMsXG4gICAgICAgIHN1bW1hcnk6ICcnLFxuICAgICAgICBhdmFpbGFiaWxpdHlUeXBlSUQ6IDAsXG4gICAgICAgIHN0YXJ0VGltZTogbnVsbCxcbiAgICAgICAgZW5kVGltZTogbnVsbCxcbiAgICAgICAga2luZDogMCxcbiAgICAgICAgaXNBbGxEYXk6IGZhbHNlLFxuICAgICAgICB0aW1lWm9uZTogJ1onLFxuICAgICAgICBsb2NhdGlvbjogbnVsbCxcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxuICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgICAgcmVjdXJyZW5jZVJ1bGU6IHtcbiAgICAgICAgICAgIE1vZGVsOiBSZWN1cnJlbmNlUnVsZVxuICAgICAgICB9LFxuICAgICAgICByZWN1cnJlbmNlT2NjdXJyZW5jZXM6IHtcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWUsXG4gICAgICAgICAgICBNb2RlbDogUmVjdXJyZW5jZU9jY3VycmVuY2VcbiAgICAgICAgfVxuICAgIH0sIHZhbHVlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsZW5kYXJFdmVudDtcblxuQ2FsZW5kYXJFdmVudC5SZWN1cnJlbmNlUnVsZSA9IFJlY3VycmVuY2VSdWxlO1xuQ2FsZW5kYXJFdmVudC5SZWN1cnJlbmNlT2NjdXJyZW5jZSA9IFJlY3VycmVuY2VPY2N1cnJlbmNlO1xuIiwiLyoqXG4gICAgQ2FsZW5kYXJTeW5jaW5nIG1vZGVsLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbmZ1bmN0aW9uIENhbGVuZGFyU3luY2luZyh2YWx1ZXMpIHtcblxuICAgIE1vZGVsKHRoaXMpO1xuXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgaWNhbEV4cG9ydFVybDogJycsXG4gICAgICAgIGljYWxJbXBvcnRVcmw6ICcnXG4gICAgfSwgdmFsdWVzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYWxlbmRhclN5bmNpbmc7XG4iLCIvKiogY2xpZW50IG1vZGVsICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBDbGllbnQodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgY2xpZW50VXNlcklEOiAwLFxuICAgICAgICBcbiAgICAgICAgZmlyc3ROYW1lOiAnJyxcbiAgICAgICAgbGFzdE5hbWU6ICcnLFxuICAgICAgICBzZWNvbmRMYXN0TmFtZTogJycsXG4gICAgICAgIGVtYWlsOiAnJyxcbiAgICAgICAgcGhvbmU6IG51bGwsXG4gICAgICAgIGNhblJlY2VpdmVTbXM6IGZhbHNlLFxuICAgICAgICBiaXJ0aE1vbnRoRGF5OiBudWxsLFxuICAgICAgICBiaXJ0aE1vbnRoOiBudWxsLFxuICAgICAgICBcbiAgICAgICAgbm90ZXNBYm91dENsaWVudDogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgZWRpdGFibGU6IGZhbHNlXG4gICAgfSwgdmFsdWVzKTtcblxuICAgIHRoaXMuZnVsbE5hbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuZmlyc3ROYW1lKCkgfHwgJycpICsgJyAnICsgKHRoaXMubGFzdE5hbWUoKSB8fCAnJykpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuYmlydGhEYXkgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmJpcnRoTW9udGhEYXkoKSAmJlxuICAgICAgICAgICAgdGhpcy5iaXJ0aE1vbnRoKCkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVE9ETyBpMTBuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXJ0aE1vbnRoKCkgKyAnLycgKyB0aGlzLmJpcnRoTW9udGhEYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuIiwiLyoqXG4gICAgS2VlcHMgYSBkYXRlIGF2YWlsYWJpbGl0eSBvYmplY3QgdGhhdCBpbmNsdWRlcyBhIGxpc3Qgb2YgYXBwb2ludG1lbnRzXG4gICAgdGhhdCBmaWxscyBhbGwgdGhlIHRpbWVzIGluIHRoZSBkYXRlIChmb2xsb3dpbmcgdGhlIHdlZWtEYXlTY2hlZHVsZSBhbmQgZnJlZS91bmF2YWlsYWJsZVxuICAgIHRpbWVzKSBhbmQgc3VtbWFyeSBvZiB0aGUgYXZhaWxhYmlsaXR5IHN0YXR1cyBvZiB0aGUgZGF0ZS5cbiAgICBVcGRhdGluZyB0aGUgbWFpbiBwcm9wZXJ0aWVzOiBhcHBvaW50bWVudHNMaXN0LCBkYXRlLCB3ZWVrRGF5U2NoZWR1bGUsIHRoZSBjb21wbGV0ZVxuICAgIGxpc3QgYW5kIHN1bW1hcmllcyBhdXRvIGNhbGN1bGF0ZSB0byBzaG93IHRoZSBwcm9wZXIgbGlzdGluZy5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvTW9kZWwnKTtcbnZhciBBcHBvaW50bWVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9BcHBvaW50bWVudCcpLFxuICAgIFdlZWtEYXlTY2hlZHVsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9XZWVrRGF5U2NoZWR1bGUnKSxcbiAgICBTY2hlZHVsaW5nUHJlZmVyZW5jZXMgPSByZXF1aXJlKCcuLi9tb2RlbHMvU2NoZWR1bGluZ1ByZWZlcmVuY2VzJyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIGF2YWlsYWJpbGl0eUNhbGN1bGF0aW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvYXZhaWxhYmlsaXR5Q2FsY3VsYXRpb24nKSxcbiAgICBnZXREYXRlV2l0aG91dFRpbWUgPSByZXF1aXJlKCcuLi91dGlscy9nZXREYXRlV2l0aG91dFRpbWUnKTtcblxuZnVuY3Rpb24gRGF0ZUF2YWlsYWJpbGl0eSh2YWx1ZXMpIHtcblxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGRhdGU6IG51bGwsIC8vIERhdGVcbiAgICAgICAgd2Vla0RheVNjaGVkdWxlOiB7XG4gICAgICAgICAgICBNb2RlbDogV2Vla0RheVNjaGVkdWxlXG4gICAgICAgIH0sXG4gICAgICAgIGFwcG9pbnRtZW50c0xpc3Q6IHtcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWUsXG4gICAgICAgICAgICBNb2RlbDogQXBwb2ludG1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgc2NoZWR1bGluZ1ByZWZlcmVuY2VzOiB7XG4gICAgICAgICAgICBNb2RlbDogU2NoZWR1bGluZ1ByZWZlcmVuY2VzXG4gICAgICAgIH1cbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIC8qKlxuICAgICAgICA6YXJyYXk8QXBwb2ludG1lbnQ+IExpc3Qgb2YgYXBwb2ludG1lbnRzIGZvciBhbGwgdGhlIHRpbWVzIGluIHRoZSBkYXRlLlxuICAgICAgICBJdCBpbnRyb2R1Y2VzIGZyZWUgYW5kIHVuYXZhaWxhYmxlIGFwcG9pbnRtZW50cyB1c2luZyBhcHBvaW50bWVudHNMaXN0IGFzIGJhc2VcbiAgICAgICAgZm9yIGFjdHVhbCAqYnVzeSogYXBwb2ludG1lbnRzIGFuZCB0aGUgcnVsZXMgb2Ygd2Vla0RheVNjaGVkdWxlXG4gICAgKiovXG4gICAgdGhpcy5saXN0ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXZhaWxhYmlsaXR5Q2FsY3VsYXRpb24uZmlsbERheUF2YWlsYWJpbGl0eShcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgpLCB0aGlzLmFwcG9pbnRtZW50c0xpc3QoKSwgdGhpcy53ZWVrRGF5U2NoZWR1bGUoKSwgdGhpcy5zY2hlZHVsaW5nUHJlZmVyZW5jZXMoKVxuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICAgIDppbnRcbiAgICAgICAgTnVtYmVyIG9mIG1pbnV0ZXMgc2NoZWR1bGVkIGZvciB3b3JrIGluIGEgZ2VuZXJpYy9lbXB0eSBkYXlcbiAgICAgICAgYmFzZWQgb24gdGhlIGluZm9ybWF0aW9uIGF0IHdlZWtEYXlTY2hlZHVsZS5cbiAgICAqKi9cbiAgICB0aGlzLndvcmtEYXlNaW51dGVzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NoZWR1bGUgPSB0aGlzLndlZWtEYXlTY2hlZHVsZSgpO1xuICAgICAgICAvLyBmcm9tLXRvIGFyZSBtaW51dGVzIG9mIHRoZSBkYXksIHNvIGl0cyBlYXN5IHRvIGNhbGN1bGF0ZVxuICAgICAgICByZXR1cm4gKHNjaGVkdWxlLnRvKCkgLSBzY2hlZHVsZS5mcm9tKCkpIHwwO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICAgIDppbnRcbiAgICAgICAgTnVtYmVyIG9mIG1pbnV0ZXMgYXZhaWxhYmxlIHRvIGJlIHNjaGVkdWxlZCBpbiB0aGlzIGRhdGVcbiAgICAgICAgaW5zaWRlIHRoZSB3b3JrIHRpbWUgKHdlZWtEYXlTY2hlZHVsZS5cbiAgICAgICAgSXQncyB0aGUgc3VtIG9mIGFsbCAnRnJlZScgYXBwb2ludG1lbnRzIGluIHRoZSBkYXRlLlxuICAgICoqL1xuICAgIHRoaXMuYXZhaWxhYmxlTWludXRlcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdCgpLnJlZHVjZShmdW5jdGlvbihtaW51dGVzLCBhcHQpIHtcbiAgICAgICAgICAgIGlmIChhcHQuaWQoKSA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy5mcmVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV0ID0gbW9tZW50KGFwdC5lbmRUaW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICBzdCA9IG1vbWVudChhcHQuc3RhcnRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIG1pbnV0ZXMgKz0gZXQuZGlmZihzdCwgJ21pbnV0ZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW51dGVzO1xuICAgICAgICB9LCAwKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAgICA6aW50XG4gICAgICAgIFBlcmNlbnRhZ2UgbnVtYmVyIGZyb20gMCB0byAxMDAgb2YgdGltZVxuICAgICAgICBhdmFpbGFibGUgdGltZSBpbiB0aGUgZGF0ZSAoYXZhaWxhYmxlTWludXRlcyAvIHdvcmtEYXlNaW51dGVzKVxuICAgICoqL1xuICAgIHRoaXMuYXZhaWxhYmxlUGVyY2VudCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKCh0aGlzLmF2YWlsYWJsZU1pbnV0ZXMoKSAvIHRoaXMud29ya0RheU1pbnV0ZXMoKSkgKiAxMDApKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAgICA6c3RyaW5nXG4gICAgICAgIEEgdGV4dCB2YWx1ZSBmcm9tIGFuIGVudW1lcmF0aW9uIHRoYXQgcmVwcmVzZW50c1xuICAgICAgICAgICAgcmFuZ2VzIG9mIGF2YWlsYWJsZVBlcmNlbnQsIHN1aXRhYmxlIGZvciBoaWdoIGxldmVsIHVzZSBhcyBDU1MgY2xhc3Nlcy5cbiAgICAgICAgICAgIFNwZWNpYWwgY2FzZSBvbiBwYXN0IGRhdGUtdGltZSwgd2hlbiBpdCByZXR1cm5zICdwYXN0JyByYXRoZXIgdGhhbiB0aGVcbiAgICAgICAgICAgIGF2YWlsYWJpbGl0eSwgc2luY2UgcGFzdCB0aW1lcyBhcmUgbm90IGF2YWlsYWJpbGUgZm9yIGFueXRoaW5nIG5ldyAoY2FuJ3QgY2hhbmdlIHRoZSBwYXN0ISA7LSlcbiAgICAgICAgICAgIENhbiBiZTogJ25vbmUnLCAnbG93JywgJ21lZGl1bScsICdmdWxsJywgJ3Bhc3QnXG4gICAgKiovXG4gICAgdGhpcy5hdmFpbGFibGVUYWcgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwZXJjID0gdGhpcy5hdmFpbGFibGVQZXJjZW50KCksXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5kYXRlKCksXG4gICAgICAgICAgICB0b2RheSA9IGdldERhdGVXaXRob3V0VGltZSgpO1xuXG4gICAgICAgIGlmIChkYXRlIDwgdG9kYXkpXG4gICAgICAgICAgICByZXR1cm4gJ3Bhc3QnO1xuICAgICAgICBlbHNlIGlmIChwZXJjID49IDEwMClcbiAgICAgICAgICAgIHJldHVybiAnZnVsbCc7XG4gICAgICAgIGVsc2UgaWYgKHBlcmMgPj0gNTApXG4gICAgICAgICAgICByZXR1cm4gJ21lZGl1bSc7XG4gICAgICAgIGVsc2UgaWYgKHBlcmMgPiAwKVxuICAgICAgICAgICAgcmV0dXJuICdsb3cnO1xuICAgICAgICBlbHNlIC8vIDw9IDBcbiAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLyoqXG4gICAgICAgIFJldHJpZXZlIGEgbGlzdCBvZiBkYXRlLXRpbWVzIHRoYXQgYXJlIGZyZWUsIGF2YWlsYWJsZSB0byBiZSB1c2VkLFxuICAgICAgICBpbiB0aGlzIGRhdGUgd2l0aCBhIHNlcGFyYXRpb24gYmV0d2VlbiBlYWNoIG9mIHRoZSBnaXZlbiBzbG90U2l6ZVxuICAgICAgICBpbiBtaW51dGVzIG9yIHVzaW5nIHRoZSBkZWZhdWx0IGZyb20gdGhlIHNjaGVkdWxpbmcgcHJlZmVyZW5jZXNcbiAgICAgICAgaW5jbHVkZWQgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICBUaGUgcGFyYW1ldGVyICdkdXJhdGlvbicgKGluIG1pbnV0ZXMpIGFsbG93cyB0aGF0IHJldHVybmVkIHNsb3RzXG4gICAgICAgIGFyZSBmcmVlIGFsbW9zdCBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLiBUaGlzIGFsbG93cyB0byBjaG9vc2UgdGltZXNcbiAgICAgICAgdGhhdCBmaXQgdGhlIG5lZWRlZCBzZXJ2aWNlIGR1cmF0aW9uLlxuICAgICoqL1xuICAgIHZhciBjcmVhdGVUaW1lU2xvdHMgPSByZXF1aXJlKCcuLi91dGlscy9jcmVhdGVUaW1lU2xvdHMnKTtcbiAgICB0aGlzLmdldEZyZWVUaW1lU2xvdHMgPSBmdW5jdGlvbiBnZXRGcmVlVGltZVNsb3RzKGR1cmF0aW9uLCBzbG90U2l6ZU1pbnV0ZXMpIHtcbiAgICAgICAgXG4gICAgICAgIHNsb3RTaXplTWludXRlcyA9IHNsb3RTaXplTWludXRlcyB8fCB0aGlzLnNjaGVkdWxpbmdQcmVmZXJlbmNlcygpLmluY3JlbWVudHNTaXplSW5NaW51dGVzKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWR1cmF0aW9uKVxuICAgICAgICAgICAgZHVyYXRpb24gPSBzbG90U2l6ZU1pbnV0ZXM7XG4gICAgICAgIFxuICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZGF0ZSgpLFxuICAgICAgICAgICAgdG9kYXkgPSBnZXREYXRlV2l0aG91dFRpbWUoKTtcbiAgICBcbiAgICAgICAgLy8gUXVpY2sgcmV0dXJuIGlmIHdpdGggZW1wdHkgbGlzdCB3aGVuXG4gICAgICAgIC8vIC0gcGFzdCBkYXRlIChubyB0aW1lKVxuICAgICAgICAvLyAtIG5vIGF2YWlsYWJsZSB0aW1lIChhbHJlYWR5IGNvbXB1dGVkKVxuICAgICAgICBpZiAoZGF0ZSA8IHRvZGF5IHx8XG4gICAgICAgICAgICB0aGlzLmF2YWlsYWJsZU1pbnV0ZXMoKSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVGltZVNsb3RzLmZvckxpc3QodGhpcy5nZXRGcmVlQXZhaWxhYmxlU2xvdHMoKSwgc2xvdFNpemVNaW51dGVzLCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBSZXR1cm5zIGEgbGlzdCBvZiBvYmplY3RzIG9mIHR5cGUgQXZhaWxhYmxlU2xvdFxuICAgICAgICAoIHsgc3RhcnRUaW1lOkRhdGUsIGVuZFRpbWU6RGF0ZSwgYXZhaWxhYmlsaXR5OidmcmVlJyB9IClcbiAgICAgICAgZm9yIGV2ZXJ5IGZyZWUvYXZhaWxhYmxlIHRpbWUgcmFuZ2UgaW4gdGhlIGRhdGVcbiAgICAqKi9cbiAgICB0aGlzLmdldEZyZWVBdmFpbGFibGVTbG90cyA9IGZ1bmN0aW9uIGdldEZyZWVBdmFpbGFibGVTbG90cygpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5kYXRlKCksXG4gICAgICAgICAgICB0b2RheSA9IGdldERhdGVXaXRob3V0VGltZSgpO1xuICAgIFxuICAgICAgICAvLyBRdWljayByZXR1cm4gd2l0aCBlbXB0eSBsaXN0IHdoZW5cbiAgICAgICAgLy8gLSBwYXN0IGRhdGUgKG5vIHRpbWUpXG4gICAgICAgIC8vIC0gbm8gYXZhaWxhYmxlIHRpbWUgKGFscmVhZHkgY29tcHV0ZWQpXG4gICAgICAgIGlmIChkYXRlIDwgdG9kYXkgfHxcbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlTWludXRlcygpIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzbG90cyA9IFtdO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBldmVyeSBmcmVlIGFwcG9pbnRtZW50XG4gICAgICAgICAgICB0aGlzLmxpc3QoKS5mb3JFYWNoKGZ1bmN0aW9uIChhcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXB0LmlkKCkgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMuZnJlZSkge1xuICAgICAgICAgICAgICAgICAgICBzbG90cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJpbGl0eTogJ2ZyZWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBhcHQuc3RhcnRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lOiBhcHQuZW5kVGltZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNsb3RzO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlQXZhaWxhYmlsaXR5O1xuIiwiLyoqXG4gICAgQSBkYXRlcyByYW5nZSwgc2ltcGxpZmllZCBpbmZvIHVzdWFsbHkgbmVlZGVkIGZyb20gYW4gQ2FsZW5kYXJFdmVudC5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEV2ZW50RGF0ZXModmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBzdGFydFRpbWU6IG51bGwsXG4gICAgICAgIGVuZFRpbWU6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMuZHVyYXRpb24gPSBrby5jb21wdXRlZCh7XG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnN0YXJ0VGltZSgpLFxuICAgICAgICAgICAgICAgIGUgPSB0aGlzLmVuZFRpbWUoKTtcbiAgICAgICAgICAgIGlmICghcyB8fCAhZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZSAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zdGFydFRpbWUoKTtcblxuICAgICAgICAgICAgaWYgKCEodmFsdWUgfHwgdmFsdWUgPT09IDApIHx8ICFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRUaW1lKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1vbWVudChzKS5jbG9uZSgpLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmVuZFRpbWUobmV3RW5kLnRvRGF0ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duZXI6IHRoaXNcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTbWFydCB2aXN1YWxpemF0aW9uIG9mIGRhdGUgYW5kIHRpbWVcbiAgICB0aGlzLmRpc3BsYXllZERhdGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuc3RhcnRUaW1lKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5jYWxlbmRhcigpO1xuICAgICAgICBcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmRpc3BsYXllZFN0YXJ0VGltZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBtb21lbnQodGhpcy5zdGFydFRpbWUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcbiAgICAgICAgXG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5kaXNwbGF5ZWRFbmRUaW1lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLmVuZFRpbWUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcbiAgICAgICAgXG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5kaXNwbGF5ZWRUaW1lUmFuZ2UgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5ZWRTdGFydFRpbWUoKSArICctJyArIHRoaXMuZGlzcGxheWVkRW5kVGltZSgpO1xuICAgICAgICBcbiAgICB9LCB0aGlzKTtcbn07XG4iLCIvKiogRXhwZXJpZW5jZUxldmVsIG1vZGVsLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbmZ1bmN0aW9uIEV4cGVyaWVuY2VMZXZlbCh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGV4cGVyaWVuY2VMZXZlbElEOiAwLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgIC8vY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXG4gICAgfSwgdmFsdWVzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFeHBlcmllbmNlTGV2ZWw7XG4iLCIvKiogR2V0TW9yZSBtb2RlbCAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcbiAgICBMaXN0Vmlld0l0ZW0gPSByZXF1aXJlKCcuL0xpc3RWaWV3SXRlbScpO1xuXG5mdW5jdGlvbiBHZXRNb3JlKHZhbHVlcykge1xuXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBhdmFpbGFiaWxpdHk6IGZhbHNlLFxuICAgICAgICBwYXltZW50czogZmFsc2UsXG4gICAgICAgIHByb2ZpbGU6IGZhbHNlLFxuICAgICAgICBjb29wOiB0cnVlXG4gICAgfSwgdmFsdWVzKTtcblxuICAgIHZhciBhdmFpbGFibGVJdGVtcyA9IHtcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBuZXcgTGlzdFZpZXdJdGVtKHtcbiAgICAgICAgICAgIGNvbnRlbnRMaW5lMTogJ0NvbXBsZXRlIHlvdXIgYXZhaWxhYmlsaXR5IHRvIGNyZWF0ZSBhIGNsZWFuZXIgY2FsZW5kYXInLFxuICAgICAgICAgICAgbWFya2VySWNvbjogJ2ZhIGZhLWZ3IGZhLWNhbGVuZGFyJ1xuICAgICAgICB9KSxcbiAgICAgICAgcGF5bWVudHM6IG5ldyBMaXN0Vmlld0l0ZW0oe1xuICAgICAgICAgICAgY29udGVudExpbmUxOiAnU3RhcnQgYWNjZXB0aW5nIHBheW1lbnRzIHRocm91Z2ggTG9jb25vbWljcycsXG4gICAgICAgICAgICBtYXJrZXJJY29uOiAnZmEgaW9uIGlvbi1jYXJkJ1xuICAgICAgICB9KSxcbiAgICAgICAgcHJvZmlsZTogbmV3IExpc3RWaWV3SXRlbSh7XG4gICAgICAgICAgICBjb250ZW50TGluZTE6ICdBY3RpdmF0ZSB5b3VyIHByb2ZpbGUgaW4gdGhlIG1hcmtldHBsYWNlJyxcbiAgICAgICAgICAgIG1hcmtlckljb246ICdmYSBpb24gaW9uLWNhc2gnLFxuICAgICAgICAgICAgbGluazogJy9tYXJrZXRwbGFjZVByb2ZpbGUnXG4gICAgICAgIH0pLFxuICAgICAgICBjb29wOiBuZXcgTGlzdFZpZXdJdGVtKHtcbiAgICAgICAgICAgIGNvbnRlbnRMaW5lMTogJ0xlYXJuIG1vcmUgYWJvdXQgb3VyIGNvb3BlcmF0aXZlJyxcbiAgICAgICAgICAgIG1hcmtlckljb246ICdmYSBmYS1nYXZlbCdcbiAgICAgICAgfSlcbiAgICB9O1xuXG4gICAgdGhpcy5pdGVtcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIFxuICAgICAgICBPYmplY3Qua2V5cyhhdmFpbGFibGVJdGVtcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXNba2V5XSgpKVxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goYXZhaWxhYmxlSXRlbXNba2V5XSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdldE1vcmU7XG4iLCIvKipcbiAgICBJbnB1dFBheW1lbnRNZXRob2QgTW9kZWwsIHJlcHJlc2VudHNcbiAgICB0aGUgZGF0YSB0byBiZSBmaWxsZWQgaW4gYSBib29raW5nIHJlcXVlc3RcbiAgICBmb3IgcGF5bWVudCBpbmZvcm1hdGlvbi5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vQWRkcmVzcycpLFxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZnVuY3Rpb24gSW5wdXRQYXltZW50TWV0aG9kKHZhbHVlcykge1xuXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgcGF5bWVudE1ldGhvZElEOiAwLFxuICAgICAgICBuYW1lT25DYXJkOiAnJyxcbiAgICAgICAgY2FyZE51bWJlcjogbnVsbCxcbiAgICAgICAgZXhwaXJhdGlvbk1vbnRoOiBudWxsLFxuICAgICAgICBleHBpcmF0aW9uWWVhcjogbnVsbCxcbiAgICAgICAgc2VjdXJpdHlDb2RlOiBudWxsLFxuICAgICAgICBiaWxsaW5nQWRkcmVzczogeyBNb2RlbDogQWRkcmVzcyB9LFxuICAgICAgICBzYXZlUGF5bWVudDogZmFsc2VcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMuZXhwaXJhdGlvbk1vbnRoWWVhciA9IGtvLmNvbXB1dGVkKHtcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuZXhwaXJhdGlvbk1vbnRoKCksXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZXhwaXJhdGlvblllYXIoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFtICYmICF5KSByZXR1cm4gJyc7XG5cbiAgICAgICAgICAgIHJldHVybiBwYWRMZWZ0KG0sIDIsICcwJykgKyAnLycgKyBwYWRMZWZ0KHksIDQsICcwJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gdmFsdWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGlyYXRpb25Nb250aChwYWRMZWZ0KHBhcnRzWzBdIHwwLCAyLCAnMCcpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGlyYXRpb25ZZWFyKHBhZExlZnQocGFydHNbMV0gfDAsIDQsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0UGF5bWVudE1ldGhvZDtcblxuZnVuY3Rpb24gcGFkTGVmdCh2LCBsZW5ndGgsIHBhZExldHRlcikge1xuICAgIGlmICghdikgcmV0dXJuICcnO1xuICAgIHYgPSB2LnRvU3RyaW5nKCk7XG4gICAgd2hpbGUgKHYubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgIHYgPSBwYWRMZXR0ZXIgKyB2O1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuIiwiLyoqIEpvYlRpdGxlIG1vZGVsICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIEpvYlRpdGxlUHJpY2luZ1R5cGUgPSByZXF1aXJlKCcuL0pvYlRpdGxlUHJpY2luZ1R5cGUnKTtcblxuZnVuY3Rpb24gSm9iVGl0bGUodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgam9iVGl0bGVJRDogMCxcbiAgICAgICAgc2luZ3VsYXJOYW1lOiAnJyxcbiAgICAgICAgcGx1cmFsTmFtZTogJycsXG4gICAgICAgIGFsaWFzZXM6ICcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgc2VhcmNoRGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxuICAgIH0sIHZhbHVlcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZklEKFsnam9iVGl0bGVJRCddKTtcblxuICAgIC8vIFRPRE86IHJldmlldyBpZiwgbm90IHJlZ2lzdGVyZWQgYXMgYSBwcm9wZXJ0eSwgdGhlIGxpc3QgaXMgdXBkYXRlZFxuICAgIC8vIG9uIHN5bmNzIGJ5IHVzaW5nIG1vZGVsLnVwZGF0ZVdpdGhcblxuICAgIC8vIFByaWNpbmcgVHlwZXMgcmVsYXRpb25zaGlwLFxuICAgIC8vIGNvbGxlY3Rpb24gb2YgSm9iVGl0bGVQcmljaW5nVHlwZSBlbnRpdGllc1xuICAgIHRoaXMucHJpY2luZ1R5cGVzID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcbiAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5wcmljaW5nVHlwZXMpIHtcbiAgICAgICAgdmFsdWVzLnByaWNpbmdUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGpvYnByaWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucHJpY2luZ1R5cGVzLnB1c2gobmV3IEpvYlRpdGxlUHJpY2luZ1R5cGUoam9icHJpY2luZykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBKb2JUaXRsZTtcbiIsIi8qKlxuICAgIERlZmluZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEgSm9iVGl0bGUgYW5kIGEgUHJpY2luZ1R5cGUuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBKb2JUaXRsZVByaWNpbmdUeXBlKHZhbHVlcykge1xuXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgcHJpY2luZ1R5cGVJRDogMCxcbiAgICAgICAgLy8gTk9URTogQ2xpZW50IFR5cGUgaXMgbW9zdGx5IHVudXNlZCB0b2RheSBidXQgZXhpc3RzXG4gICAgICAgIC8vIG9uIGFsbCBkYXRhYmFzZSByZWNvcmRzLiBJdCB1c2VzIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIC8vIG9mIDEgYWxsIHRoZSB0aW1lIGZvciBub3cuXG4gICAgICAgIGNsaWVudFR5cGVJRDogMSxcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXG4gICAgfSwgdmFsdWVzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZklEKFsncHJpY2luZ1R5cGVJRCcsICdjbGllbnRUeXBlSUQnXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSm9iVGl0bGVQcmljaW5nVHlwZTtcbiIsIi8qKiBKb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzIG1vZGVsLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgU2VydmljZUF0dHJpYnV0ZUNhdGVnb3J5ID0gcmVxdWlyZSgnLi9TZXJ2aWNlQXR0cmlidXRlQ2F0ZWdvcnknKSxcbiAgICBFeHBlcmllbmNlTGV2ZWwgPSByZXF1aXJlKCcuL0V4cGVyaWVuY2VMZXZlbCcpO1xuXG5mdW5jdGlvbiBKb2JUaXRsZVNlcnZpY2VBdHRyaWJ1dGVzKHZhbHVlcykge1xuXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBqb2JUaXRsZUlEOiAwLFxuICAgICAgICBzZXJ2aWNlQXR0cmlidXRlczoge1xuICAgICAgICAgICAgaXNBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgIE1vZGVsOiBTZXJ2aWNlQXR0cmlidXRlQ2F0ZWdvcnlcbiAgICAgICAgfSxcbiAgICAgICAgZXhwZXJpZW5jZUxldmVsczoge1xuICAgICAgICAgICAgaXNBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgIE1vZGVsOiBFeHBlcmllbmNlTGV2ZWxcbiAgICAgICAgfSxcbiAgICAgICAgbGFuZ3VhZ2VJRDogMCxcbiAgICAgICAgY291bnRyeUlEOiAwXG4gICAgICAgIC8vY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIC8vdXBkYXRlZERhdGU6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXM7XG4iLCIvKiogTGljZW5zZUNlcnRpZmljYXRpb24gbW9kZWwgKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuZnVuY3Rpb24gTGljZW5zZUNlcnRpZmljYXRpb24odmFsdWVzKSB7XG5cbiAgICBNb2RlbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBsaWNlbnNlQ2VydGlmaWNhdGlvbklEOiAwLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgc3RhdGVQcm92aW5jZUlEOiAwLFxuICAgICAgICBjb3VudHJ5SUQ6IDAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICBhdXRob3JpdHk6IG51bGwsXG4gICAgICAgIHZlcmlmaWNhdGlvbldlYnNpdGVVcmw6IG51bGwsXG4gICAgICAgIGhvd1RvR2V0TGljZW5zZWRVcmw6IG51bGwsXG4gICAgICAgIG9wdGlvbkdyb3VwOiBudWxsLFxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsIC8vIEF1dG9maWxsZWQgYnkgc2VydmVyXG4gICAgfSwgdmFsdWVzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZklEKFsnbGljZW5zZUNlcnRpZmljYXRpb25JRCddKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaWNlbnNlQ2VydGlmaWNhdGlvbjtcbiIsIi8qKiBMaXN0Vmlld0l0ZW0gbW9kZWwuXG5cbiAgICBEZXNjcmliZXMgYSBnZW5lcmljIGl0ZW0gb2YgYVxuICAgIExpc3RWaWV3IGNvbXBvbmVudC5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBMaXN0Vmlld0l0ZW0odmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBtYXJrZXJMaW5lMTogbnVsbCxcbiAgICAgICAgbWFya2VyTGluZTI6IG51bGwsXG4gICAgICAgIG1hcmtlckljb246IG51bGwsXG4gICAgICAgIFxuICAgICAgICBjb250ZW50TGluZTE6ICcnLFxuICAgICAgICBjb250ZW50TGluZTI6IG51bGwsXG4gICAgICAgIGxpbms6ICcjJyxcblxuICAgICAgICBhY3Rpb25JY29uOiBudWxsLFxuICAgICAgICBhY3Rpb25UZXh0OiBudWxsLFxuICAgICAgICBcbiAgICAgICAgY2xhc3NOYW1lczogJydcblxuICAgIH0sIHZhbHVlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdFZpZXdJdGVtO1xuIiwiLyoqIE1haWxGb2xkZXIgbW9kZWwgKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5mdW5jdGlvbiBNYWlsRm9sZGVyKHZhbHVlcykge1xuXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIHRvcE51bWJlcjogMTBcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMudG9wID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uIHRvcChudW0pIHtcbiAgICAgICAgaWYgKG51bSkgdGhpcy50b3BOdW1iZXIobnVtKTtcbiAgICAgICAgcmV0dXJuIF8uZmlyc3QodGhpcy5tZXNzYWdlcygpLCB0aGlzLnRvcE51bWJlcigpKTtcbiAgICB9LCB0aGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYWlsRm9sZGVyO1xuIiwiLyoqIE1hcmtldHBsYWNlUHJvZmlsZSBtb2RlbCAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZnVuY3Rpb24gTWFya2V0cGxhY2VQcm9maWxlKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHVzZXJJRDogMCxcbiAgICAgICAgXG4gICAgICAgIHB1YmxpY0JpbzogJycsXG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxQcm9maWxlVXJsU2x1ZzogJycsXG4gICAgICAgIC8vIFRoaXMgaXMgYSBzZXJ2ZXItc2lkZSBjb21wdXRlZCB2YXJpYWJsZSAocmVhZC1vbmx5IGZvciB0aGUgdXNlcikgZm9yIGEgTG9jb25vbWljcyBhZGRyZXNzXG4gICAgICAgIC8vIGNyZWF0ZWQgdXNpbmcgdGhlIHNlcnZpY2VQcm9mZXNzaW9uYWxQcm9maWxlVXJsU2x1ZyBpZiBhbnkgb3IgdGhlIGZhbGxiYWNrIHN5c3RlbSBVUkwuXG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxQcm9maWxlVXJsOiAnJyxcbiAgICAgICAgLy8gU3BlY2lmeSBhbiBleHRlcm5hbCB3ZWJzaXRlIG9mIHRoZSBzZXJ2aWNlUHJvZmVzc2lvbmFsLlxuICAgICAgICBzZXJ2aWNlUHJvZmVzc2lvbmFsV2Vic2l0ZVVybDogJycsXG4gICAgICAgIC8vIFNlcnZlci1zaWRlIGdlbmVyYXRlZCBjb2RlIHRoYXQgYWxsb3dzIHRvIGlkZW50aWZpY2F0ZSBzcGVjaWFsIGJvb2tpbmcgcmVxdWVzdHNcbiAgICAgICAgLy8gZnJvbSB0aGUgYm9vay1tZS1ub3cgYnV0dG9uLiBUaGUgc2VydmVyIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBldmVyIGEgdmFsdWUgb24gdGhpcyBmb3Igc2VydmljZVByb2Zlc3Npb25hbHMuXG4gICAgICAgIGJvb2tDb2RlOiAnJyxcblxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgb2JzZXJ2YWJsZTogcGhvdG9VcmwsIGlzIGEgd2VsbCBrbm93IFVSTCwgbm8gc2F2ZWQgb24gZGF0YWJhc2UsIGJhc2VkIG9uIHRoZSB1c2VySURcbiAgICAvLyBhbmQgdGhlIGNoYW5uZWwgYmVpbmcgaW4gdXNlXG4gICAgdGhpcy5waG90b1VybCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgICAgICAgdmFyIHNpdGVVcmwgPSAkKCdodG1sJykuYXR0cignZGF0YS1zaXRlLXVybCcpIHx8ICdodHRwczovL2xvY29ub21pY3MuY29tJztcbiAgICAgICAgcmV0dXJuIHNpdGVVcmwgKyAnL2VuLVVTL1Byb2ZpbGUvUGhvdG8vJyArIHRoaXMudXNlcklEKCk7XG4gICAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWFya2V0cGxhY2VQcm9maWxlO1xuIiwiLyoqIE1lc3NhZ2UgbW9kZWwuXG5cbiAgICBEZXNjcmliZXMgYSBtZXNzYWdlIHRoYXQgYmVsb25ncyB0byBhIFRocmVhZC5cbiAgICBBIG1lc3NhZ2UgY291bGQgYmUgb2YgZGlmZmVyZW50IHR5cGVzLFxuICAgIGFzIGlucXVpcmllcywgYm9va2luZ3MsIGJvb2tpbmcgcmVxdWVzdHMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbmZ1bmN0aW9uIE1lc3NhZ2UodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBtZXNzYWdlSUQ6IDAsXG4gICAgICAgIHRocmVhZElEOiAwLFxuICAgICAgICBzZW50QnlVc2VySUQ6IG51bGwsXG4gICAgICAgIHR5cGVJRDogbnVsbCxcbiAgICAgICAgYXV4VDogbnVsbCxcbiAgICAgICAgYXV4SUQ6IG51bGwsXG4gICAgICAgIGJvZHlUZXh0OiAnJyxcbiAgICAgICAgXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgLy8gU21hcnQgdmlzdWFsaXphdGlvbiBvZiBkYXRlIGFuZCB0aW1lXG4gICAgdGhpcy5kaXNwbGF5ZWREYXRlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuY3JlYXRlZERhdGUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmNhbGVuZGFyKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5kaXNwbGF5ZWRUaW1lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuY3JlYXRlZERhdGUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcbiAgICB9LCB0aGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuIiwiLyoqIE1lc3NhZ2UgbW9kZWwuXG5cbiAgICBEZXNjcmliZXMgYSBtZXNzYWdlIGZyb20gYSBNYWlsRm9sZGVyLlxuICAgIEEgbWVzc2FnZSBjb3VsZCBiZSBvZiBkaWZmZXJlbnQgdHlwZXMsXG4gICAgYXMgaW5xdWlyaWVzLCBib29raW5ncywgYm9va2luZyByZXF1ZXN0cy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxuZnVuY3Rpb24gTWVzc2FnZVZpZXcodmFsdWVzLCBhcHApIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGlkOiAwLFxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXG4gICAgICAgIFxuICAgICAgICBzdWJqZWN0OiAnJyxcbiAgICAgICAgY29udGVudDogbnVsbCxcbiAgICAgICAgbGluazogJyMnLFxuICAgICAgICBcbiAgICAgICAgdGFnOiAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogJycsXG4gICAgICAgIFxuICAgICAgICBzb3VyY2VUaHJlYWQ6IG51bGwsXG4gICAgICAgIHNvdXJjZU1lc3NhZ2U6IG51bGxcblxuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgLy8gU21hcnQgdmlzdWFsaXphdGlvbiBvZiBkYXRlIGFuZCB0aW1lXG4gICAgdGhpcy5kaXNwbGF5ZWREYXRlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzLmNyZWF0ZWREYXRlKCkpLmxvY2FsZSgnZW4tVVMtTEMnKS5jYWxlbmRhcigpO1xuICAgICAgICBcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmRpc3BsYXllZFRpbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuY3JlYXRlZERhdGUoKSkubG9jYWxlKCdlbi1VUy1MQycpLmZvcm1hdCgnTFQnKTtcblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMucXVpY2tEYXRlVGltZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmNyZWF0ZWREYXRlKCk7XG5cbiAgICAgICAgdmFyIG0gPSBtb21lbnQoZGF0ZSkubG9jYWxlKCdlbi1VUy1MQycpLFxuICAgICAgICAgICAgdCA9IG1vbWVudCgpLnN0YXJ0T2YoJ2RheScpO1xuXG4gICAgICAgIGlmIChtLmlzQWZ0ZXIodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmZvcm1hdCgnTFQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtLmZyb21Ob3coKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuY2xpZW50ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zb3VyY2VNZXNzYWdlKCk7XG4gICAgICAgIGlmICghcyB8fCAhYXBwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgY2lkID0gcy5zZW50QnlVc2VySUQoKTtcbiAgICAgICAgaWYgKGNpZCkge1xuICAgICAgICAgICAgaWYgKGNpZCA9PT0gYXBwLm1vZGVsLnVzZXJQcm9maWxlLmRhdGEudXNlcklEKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC51c2VyUHJvZmlsZS5kYXRhO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwuY2xpZW50cy5nZXRPYnNlcnZhYmxlSXRlbShjaWQsIHRydWUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgdGhpcylcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVZpZXc7XG5cbi8qKlxuICAgIENyZWF0ZXMgYSBNZXNzYWdlVmlldyBpbnN0YW5jZSBmcm9tIGEgVGhyZWFkIGluc3RhbmNlLlxuICAgIEl0J3MgYmV0dGVyIHRvIGhhdmUgYWxtb3N0IG9uZSBtZXNzYWdlIGluIHRoZSB0aHJlYWQgKHRoZSBsYXRlc3RcbiAgICBvbmUgZmlyc3QsIG9yIHRoZSBvbmUgdG8gaGlnaGxpZ2h0KSB0byBidWlsZCBhXG4gICAgbW9yZSBkZXRhaWxlZCBNZXNzYWdlVmlld1xuKiovXG5NZXNzYWdlVmlldy5mcm9tVGhyZWFkID0gZnVuY3Rpb24oYXBwLCB0aHJlYWQpIHtcbiAgICBcbiAgICB2YXIgbXNnID0gdGhyZWFkLm1lc3NhZ2VzKCk7XG4gICAgbXNnID0gbXNnICYmIG1zZ1swXSB8fCBudWxsO1xuICAgIFxuICAgIC8vIFRPRE86IG1vcmUgZGlmZmVyZW50IHRhZy9jbGFzc2VzIGRlcGVuZGluZyBvbiBib29raW5nIHN0YXRlIGFzIHBlciBkZXNpZ25cbiAgICAvLyBOT1RFOiBUaGF0IHJlcXVpcmVzIHRvIGxvYWQgdGhlIGJvb2tpbmcgb3IgcmVxdWVzdCBieSBhdXhJRCBhbmQgd2FpdCBmb3IgaXRcbiAgICB2YXIgdGFnLCBjbGFzc05hbWVzO1xuICAgIGlmIChtc2cuYXV4VCgpID09PSAnQm9va2luZycpIHtcbiAgICAgICAgdGFnID0gJ0Jvb2tpbmcnO1xuICAgICAgICBjbGFzc05hbWVzID0gJ3RleHQtc3VjY2Vzcyc7XG4gICAgfVxuICAgIC8vIFRPRE8gRm9yIHN0YXRlPT1yZXF1ZXN0IG11c3QgYmVcbiAgICAvKntcbiAgICAgICAgdGFnID0gJ0Jvb2tpbmcgcmVxdWVzdCc7XG4gICAgICAgIGNsYXNzTmFtZXMgPSAndGV4dC13YXJuaW5nJztcbiAgICB9Ki9cbiAgICBcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWaWV3KHtcbiAgICAgICAgc291cmNlVGhyZWFkOiB0aHJlYWQsXG4gICAgICAgIHNvdXJjZU1lc3NhZ2U6IG1zZyxcbiAgICAgICAgaWQ6IHRocmVhZC50aHJlYWRJRCgpLFxuICAgICAgICBjcmVhdGVkRGF0ZTogdGhyZWFkLmNyZWF0ZWREYXRlKCksXG4gICAgICAgIHVwZGF0ZWREYXRlOiB0aHJlYWQudXBkYXRlZERhdGUoKSxcbiAgICAgICAgc3ViamVjdDogdGhyZWFkLnN1YmplY3QoKSxcbiAgICAgICAgY29udGVudDogbXNnICYmIG1zZy5ib2R5VGV4dCgpIHx8ICcnLFxuICAgICAgICBsaW5rOiAnIyEvY29udmVyc2F0aW9uLycgKyB0aHJlYWQudGhyZWFkSUQoKSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXNcbiAgICB9LCBhcHApO1xufTtcbiIsIi8qKlxuICAgIE1vZGVsIGNsYXNzIHRvIGhlbHAgYnVpbGQgbW9kZWxzLlxuXG4gICAgSXMgbm90IGV4YWN0bHkgYW4gJ09PUCBiYXNlJyBjbGFzcywgYnV0IHByb3ZpZGVzXG4gICAgdXRpbGl0aWVzIHRvIG1vZGVscyBhbmQgYSBtb2RlbCBkZWZpbml0aW9uIG9iamVjdFxuICAgIHdoZW4gZXhlY3V0ZWQgaW4gdGhlaXIgY29uc3RydWN0b3JzIGFzOlxuICAgIFxuICAgICcnJ1xuICAgIGZ1bmN0aW9uIE15TW9kZWwoKSB7XG4gICAgICAgIE1vZGVsKHRoaXMpO1xuICAgICAgICAvLyBOb3csIHRoZXJlIGlzIGEgdGhpcy5tb2RlbCBwcm9wZXJ0eSB3aXRoXG4gICAgICAgIC8vIGFuIGluc3RhbmNlIG9mIHRoZSBNb2RlbCBjbGFzcywgd2l0aCBcbiAgICAgICAgLy8gdXRpbGl0aWVzIGFuZCBtb2RlbCBzZXR0aW5ncy5cbiAgICB9XG4gICAgJycnXG4gICAgXG4gICAgVGhhdCBhdXRvIGNyZWF0aW9uIG9mICdtb2RlbCcgcHJvcGVydHkgY2FuIGJlIGF2b2lkZWRcbiAgICB3aGVuIHVzaW5nIHRoZSBvYmplY3QgaW5zdGFudGlhdGlvbiBzeW50YXggKCduZXcnIGtleXdvcmQpOlxuICAgIFxuICAgICcnJ1xuICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChvYmopO1xuICAgIC8vIFRoZXJlIGlzIG5vIGEgJ29iai5tb2RlbCcgcHJvcGVydHksIGNhbiBiZVxuICAgIC8vIGFzc2lnbmVkIHRvIHdoYXRldmVyIHByb3BlcnR5IG9yIG5vdGhpbmcuXG4gICAgJycnXG4qKi9cbid1c2Ugc3RyaWN0JztcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5rby5tYXBwaW5nID0gcmVxdWlyZSgna25vY2tvdXQubWFwcGluZycpO1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBjbG9uZSA9IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIG9iaik7IH07XG52YXIgY2xvbmVWYWx1ZSA9IGZ1bmN0aW9uKHZhbCwgZGVlcENvcHkpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiAxMCovXG4gICAgaWYgKHR5cGVvZih2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBBIERhdGUgb2JqZWN0IGlzIGEgc3BlY2lhbCBjYXNlOiBldmVuIGJlaW5nXG4gICAgICAgIC8vIGFuIG9iamVjdCwgdHJlYXQgYXMgYSBiYXNpYyB0eXBlLCBiZWluZyBjb3BpZWQgYXNcbiAgICAgICAgLy8gYSBuZXcgaW5zdGFuY2UgaW5kZXBlbmRlbnQgb2YgdGhlIGRlZXBDb3B5IG9wdGlvblxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgLy8gQSBkYXRlIGNsb25lXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWVwQ29weSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVWYWx1ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsICYmIHZhbC5tb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBtb2RlbCBjb3B5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5tb2RlbC50b1BsYWluT2JqZWN0KGRlZXBDb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFBsYWluICdzdGFuZGFyZCcgb2JqZWN0IGNsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVlcENvcHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBTaGFsbG93IGNvcHlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT24gZWxzZSwgbGVmdCB1bmRlZmluZWQsIG5vIHJlZmVyZW5jZXMsIG5vIGNsb25lcyxcbiAgICAgICAgLy8gZGlzY2FyZGVkIHZhbHVlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBBIGJhc2ljIHR5cGUgdmFsdWUgaXMgYWxyZWFkeSBjb3BpZWQvY2xvbmVkIGJ5IGphdmFzY3JpcHRcbiAgICAgICAgLy8gb24gZXZlcnkgYXNzaWdubWVudFxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIE1vZGVsKG1vZGVsT2JqZWN0KSB7XG4gICAgXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgICAvLyBFeGVjdXRlZCBhcyBhIGZ1bmN0aW9uLCBpdCBtdXN0IGNyZWF0ZVxuICAgICAgICAvLyBhIE1vZGVsIGluc3RhbmNlXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChtb2RlbE9iamVjdCk7XG4gICAgICAgIC8vIGFuZCByZWdpc3RlciBhdXRvbWF0aWNhbGx5IGFzIHBhcnRcbiAgICAgICAgLy8gb2YgdGhlIG1vZGVsT2JqZWN0IGluICdtb2RlbCcgcHJvcGVydHlcbiAgICAgICAgbW9kZWxPYmplY3QubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gXG4gICAgLy8gSXQgaW5jbHVkZXMgYSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdFxuICAgIHRoaXMubW9kZWxPYmplY3QgPSBtb2RlbE9iamVjdDtcbiAgICAvLyBJdCBtYWludGFpbnMgYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIGZpZWxkc1xuICAgIHRoaXMucHJvcGVydGllc0xpc3QgPSBbXTtcbiAgICB0aGlzLmZpZWxkc0xpc3QgPSBbXTtcbiAgICB0aGlzLnByb3BlcnRpZXNEZWZzID0ge307XG4gICAgdGhpcy5maWVsZHNEZWZzID0ge307XG4gICAgLy8gSXQgYWxsb3cgc2V0dGluZyB0aGUgJ2tvLm1hcHBpbmcuZnJvbUpTJyBtYXBwaW5nIG9wdGlvbnNcbiAgICAvLyB0byBjb250cm9sIGNvbnZlcnNpb25zIGZyb20gcGxhaW4gSlMgb2JqZWN0cyB3aGVuIFxuICAgIC8vICd1cGRhdGVXaXRoJy5cbiAgICB0aGlzLm1hcHBpbmdPcHRpb25zID0ge307XG4gICAgXG4gICAgLy8gVGltZXN0YW1wIHdpdGggdGhlIGRhdGUgb2YgbGFzdCBjaGFuZ2VcbiAgICAvLyBpbiB0aGUgZGF0YSAoYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gY2hhbmdlc1xuICAgIC8vIGhhcHBlbnMgb24gcHJvcGVydGllczsgZmllbGRzIG9yIGFueSBvdGhlciBtZW1iZXJcbiAgICAvLyBhZGRlZCB0byB0aGUgbW9kZWwgY2Fubm90IGJlIG9ic2VydmVkIGZvciBjaGFuZ2VzLFxuICAgIC8vIHJlcXVpcmluZyBtYW51YWwgdXBkYXRpbmcgd2l0aCBhICduZXcgRGF0ZSgpJywgYnV0IGlzXG4gICAgLy8gYmV0dGVyIHRvIHVzZSBwcm9wZXJ0aWVzLlxuICAgIC8vIEl0cyByYXRlZCB0byB6ZXJvIGp1c3QgdG8gYXZvaWQgdGhhdCBjb25zZWN1dGl2ZVxuICAgIC8vIHN5bmNocm9ub3VzIGNoYW5nZXMgZW1pdCBsb3Qgb2Ygbm90aWZpY2F0aW9ucywgc3BlY2lhbGx5XG4gICAgLy8gd2l0aCBidWxrIHRhc2tzIGxpa2UgJ3VwZGF0ZVdpdGgnLlxuICAgIHRoaXMuZGF0YVRpbWVzdGFtcCA9IGtvLm9ic2VydmFibGUobmV3IERhdGUoKSkuZXh0ZW5kKHsgcmF0ZUxpbWl0OiAwIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuXG4vKipcbiAgICBJbnRlcm5hbCB1dGlsaXR5IHRvIG1hcCBhIHZhbHVlIGdpdmVuIGl0cyBwcm9wZXJ0eS9maWVsZFxuICAgIGRlZmluaXRpb25cbioqL1xuZnVuY3Rpb24gcHJlcGFyZVZhbHVlQnlEZWYodmFsLCBkZWYpIHtcbiAgICBpZiAoZGVmLmlzQXJyYXkgJiYgXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWwpICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWwgPSBbXTtcbiAgICB9XG4gICAgaWYgKGRlZiAmJiBkZWYuTW9kZWwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBkZWYuTW9kZWwgfHxcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YoaXRlbSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICdhcyBpcydcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRlZi5Nb2RlbChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIGRlZi5Nb2RlbCkgJiZcbiAgICAgICAgICAgICAgICB2YWwgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YodmFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXcgZGVmLk1vZGVsKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmKGdpdmVuVmFsLCBpbml0aWFsVmFsKSB7XG4gICAgXG4gICAgdmFyIGRlZixcbiAgICAgICAgaXNNb2RlbCA9IGdpdmVuVmFsICYmIGdpdmVuVmFsLm1vZGVsIGluc3RhbmNlb2YgTW9kZWwsXG4gICAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGdpdmVuVmFsKSxcbiAgICAgICAgaXNPYmplY3QgPSB0eXBlb2YoZ2l2ZW5WYWwpID09PSAnb2JqZWN0JyAmJiAhKGdpdmVuVmFsIGluc3RhbmNlb2YgRGF0ZSk7XG5cbiAgICBpZiAoZ2l2ZW5WYWwgIT09IG51bGwgJiYgIWlzTW9kZWwgJiYgaXNPYmplY3QgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgZGVmID0gZ2l2ZW5WYWw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWYgPSB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdpdmVuVmFsLFxuICAgICAgICAgICAgaXNBcnJheTogaXNBcnJheVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNNb2RlbClcbiAgICAgICAgICAgIGRlZi5Nb2RlbCA9IGdpdmVuVmFsLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBcbiAgICBpbml0aWFsVmFsID0gdHlwZW9mKGluaXRpYWxWYWwpID09PSAndW5kZWZpbmVkJyA/IGRlZi5kZWZhdWx0VmFsdWUgOiBpbml0aWFsVmFsO1xuICAgIGRlZi5pbml0aWFsVmFsdWUgPSBwcmVwYXJlVmFsdWVCeURlZihpbml0aWFsVmFsLCBkZWYpO1xuICAgIFxuICAgIHJldHVybiBkZWY7XG59XG5cbi8qKlxuICAgIERlZmluZSBvYnNlcnZhYmxlIHByb3BlcnRpZXMgdXNpbmcgdGhlIGdpdmVuXG4gICAgcHJvcGVydGllcyBvYmplY3QgZGVmaW5pdGlvbiB0aGF0IGluY2x1ZGVzIGRlIGRlZmF1bHQgdmFsdWVzLFxuICAgIGFuZCBzb21lIG9wdGlvbmFsIGluaXRpYWxWYWx1ZXMgKG5vcm1hbGx5IHRoYXQgaXMgcHJvdmlkZWQgZXh0ZXJuYWxseVxuICAgIGFzIGEgcGFyYW1ldGVyIHRvIHRoZSBtb2RlbCBjb25zdHJ1Y3Rvciwgd2hpbGUgZGVmYXVsdCB2YWx1ZXMgYXJlXG4gICAgc2V0IGluIHRoZSBjb25zdHJ1Y3RvcikuXG4gICAgVGhhdCBwcm9wZXJ0aWVzIGJlY29tZSBtZW1iZXJzIG9mIHRoZSBtb2RlbE9iamVjdCwgc2ltcGxpZnlpbmcgXG4gICAgbW9kZWwgZGVmaW5pdGlvbnMuXG4gICAgXG4gICAgSXQgdXNlcyBLbm9ja291dC5vYnNlcnZhYmxlIGFuZCBvYnNlcnZhYmxlQXJyYXksIHNvIHByb3BlcnRpZXNcbiAgICBhcmUgZnVudGlvbnMgdGhhdCByZWFkcyB0aGUgdmFsdWUgd2hlbiBubyBhcmd1bWVudHMgb3Igc2V0cyB3aGVuXG4gICAgb25lIGFyZ3VtZW50IGlzIHBhc3NlZCBvZi5cbioqL1xuTW9kZWwucHJvdG90eXBlLmRlZlByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGluaXRpYWxWYWx1ZXMpIHtcblxuICAgIGluaXRpYWxWYWx1ZXMgPSBpbml0aWFsVmFsdWVzIHx8IHt9O1xuXG4gICAgdmFyIG1vZGVsT2JqZWN0ID0gdGhpcy5tb2RlbE9iamVjdCxcbiAgICAgICAgcHJvcGVydGllc0xpc3QgPSB0aGlzLnByb3BlcnRpZXNMaXN0LFxuICAgICAgICBkZWZzID0gdGhpcy5wcm9wZXJ0aWVzRGVmcyxcbiAgICAgICAgZGF0YVRpbWVzdGFtcCA9IHRoaXMuZGF0YVRpbWVzdGFtcDtcblxuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYW5kIHJlZ2lzdGVyIGRlZmluaXRpb25cbiAgICAgICAgdmFyIGRlZiA9IGNyZWF0ZURlZihwcm9wZXJ0aWVzW2tleV0sIGluaXRpYWxWYWx1ZXNba2V5XSk7XG4gICAgICAgIGRlZnNba2V5XSA9IGRlZjtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIG9ic2VydmFibGUgcHJvcGVydHlcbiAgICAgICAgbW9kZWxPYmplY3Rba2V5XSA9IEFycmF5LmlzQXJyYXkoZGVmLmluaXRpYWxWYWx1ZSkgP1xuICAgICAgICAgICAga28ub2JzZXJ2YWJsZUFycmF5KGRlZi5pbml0aWFsVmFsdWUpIDpcbiAgICAgICAgICAgIGtvLm9ic2VydmFibGUoZGVmLmluaXRpYWxWYWx1ZSk7XG5cbiAgICAgICAgLy8gUmVtZW1iZXIgZGVmYXVsdFxuICAgICAgICBtb2RlbE9iamVjdFtrZXldLl9kZWZhdWx0VmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgICAgICAvLyByZW1lbWJlciBpbml0aWFsXG4gICAgICAgIG1vZGVsT2JqZWN0W2tleV0uX2luaXRpYWxWYWx1ZSA9IGRlZi5pbml0aWFsVmFsdWU7ICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHN1YnNjcmliZXIgdG8gdXBkYXRlIHRoZSB0aW1lc3RhbXAgb24gY2hhbmdlc1xuICAgICAgICBtb2RlbE9iamVjdFtrZXldLnN1YnNjcmliZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRhdGFUaW1lc3RhbXAobmV3IERhdGUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBpbnRlcm5hbCByZWdpc3RyeVxuICAgICAgICBwcm9wZXJ0aWVzTGlzdC5wdXNoKGtleSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRpbWVzdGFtcCBhZnRlciB0aGUgYnVsayBjcmVhdGlvbi5cbiAgICBkYXRhVGltZXN0YW1wKG5ldyBEYXRlKCkpO1xufTtcblxuLyoqXG4gICAgRGVmaW5lIGZpZWxkcyBhcyBwbGFpbiBtZW1iZXJzIG9mIHRoZSBtb2RlbE9iamVjdCB1c2luZ1xuICAgIHRoZSBmaWVsZHMgb2JqZWN0IGRlZmluaXRpb24gdGhhdCBpbmNsdWRlcyBkZWZhdWx0IHZhbHVlcyxcbiAgICBhbmQgc29tZSBvcHRpb25hbCBpbml0aWFsVmFsdWVzLlxuICAgIFxuICAgIEl0cyBsaWtlIGRlZlByb3BlcnRpZXMsIGJ1dCBmb3IgcGxhaW4ganMgdmFsdWVzIHJhdGhlciB0aGFuIG9ic2VydmFibGVzLlxuKiovXG5Nb2RlbC5wcm90b3R5cGUuZGVmRmllbGRzID0gZnVuY3Rpb24gZGVmRmllbGRzKGZpZWxkcywgaW5pdGlhbFZhbHVlcykge1xuXG4gICAgaW5pdGlhbFZhbHVlcyA9IGluaXRpYWxWYWx1ZXMgfHwge307XG5cbiAgICB2YXIgbW9kZWxPYmplY3QgPSB0aGlzLm1vZGVsT2JqZWN0LFxuICAgICAgICBkZWZzID0gdGhpcy5maWVsZHNEZWZzLFxuICAgICAgICBmaWVsZHNMaXN0ID0gdGhpcy5maWVsZHNMaXN0O1xuXG4gICAgT2JqZWN0LmtleXMoZmllbGRzKS5lYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCByZWdpc3RlciBkZWZpbml0aW9uXG4gICAgICAgIHZhciBkZWYgPSBjcmVhdGVEZWYoZmllbGRzW2tleV0sIGluaXRpYWxWYWx1ZXNba2V5XSk7XG4gICAgICAgIGRlZnNba2V5XSA9IGRlZjtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBmaWVsZCB3aXRoIGluaXRpYWwgdmFsdWVcbiAgICAgICAgbW9kZWxPYmplY3Rba2V5XSA9IGRlZi5pbml0aWFsVmFsdWU7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdG8gdGhlIGludGVybmFsIHJlZ2lzdHJ5XG4gICAgICAgIGZpZWxkc0xpc3QucHVzaChrZXkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gICAgU3RvcmUgdGhlIGxpc3Qgb2YgZmllbGRzIHRoYXQgbWFrZSB0aGUgSUQvcHJpbWFyeSBrZXlcbiAgICBhbmQgY3JlYXRlIGFuIGFsaWFzICdpZCcgcHJvcGVydHkgdGhhdCByZXR1cm5zIHRoZVxuICAgIHZhbHVlIGZvciB0aGUgSUQgZmllbGQgb3IgYXJyYXkgb2YgdmFsdWVzIHdoZW4gbXVsdGlwbGVcbiAgICBmaWVsZHMuXG4qKi9cbk1vZGVsLnByb3RvdHlwZS5kZWZJRCA9IGZ1bmN0aW9uIGRlZklEKGZpZWxkc05hbWVzKSB7XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIGxpc3RcbiAgICB0aGlzLmlkRmllbGRzTmFtZXMgPSBmaWVsZHNOYW1lcztcbiAgICBcbiAgICAvLyBEZWZpbmUgSUQgb2JzZXJ2YWJsZVxuICAgIGlmIChmaWVsZHNOYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gUmV0dXJucyBzaW5nbGUgdmFsdWVcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzTmFtZXNbMF07XG4gICAgICAgIHRoaXMubW9kZWxPYmplY3QuaWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tmaWVsZF0oKTtcbiAgICAgICAgfSwgdGhpcy5tb2RlbE9iamVjdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVsT2JqZWN0LmlkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkc05hbWVzLm1hcChmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tmaWVsZE5hbWVdKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LCB0aGlzLm1vZGVsT2JqZWN0KTtcbiAgICB9XG59O1xuXG4vKipcbiAgICBBbGxvd3MgdG8gcmVnaXN0ZXIgYSBwcm9wZXJ0eSAocHJldmlvdXNseSBkZWZpbmVkKSBhcyBcbiAgICB0aGUgbW9kZWwgdGltZXN0YW1wLCBzbyBnZXRzIHVwZGF0ZWQgb24gYW55IGRhdGEgY2hhbmdlXG4gICAgKGtlZXAgaW4gc3luYyB3aXRoIHRoZSBpbnRlcm5hbCBkYXRhVGltZXN0YW1wKS5cbioqL1xuTW9kZWwucHJvdG90eXBlLnJlZ1RpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlZ1RpbWVzdGFtcFByb3BlcnR5KHByb3BlcnR5TmFtZSkge1xuXG4gICAgdmFyIHByb3AgPSB0aGlzLm1vZGVsT2JqZWN0W3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKHR5cGVvZihwcm9wKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIG9ic2VydmFibGUgcHJvcGVydHkgd2l0aCBuYW1lIFsnICsgXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICddIHRvIHJlZ2lzdGVyIGFzIHRpbWVzdGFtcC4nXG4gICAgICAgKTtcbiAgICB9XG4gICAgLy8gQWRkIHN1YnNjcmliZXIgb24gaW50ZXJuYWwgdGltZXN0YW1wIHRvIGtlZXBcbiAgICAvLyB0aGUgcHJvcGVydHkgdXBkYXRlZFxuICAgIHRoaXMuZGF0YVRpbWVzdGFtcC5zdWJzY3JpYmUoZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICAgIHByb3AodGltZXN0YW1wKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICAgIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBhbmQgZmllbGRzXG4gICAgb2YgdGhlIG1vZGVsIG9iamVjdCwganVzdCB2YWx1ZXMuXG4gICAgXG4gICAgQHBhcmFtIGRlZXBDb3B5OmJvb2wgSWYgbGVmdCB1bmRlZmluZWQsIGRvIG5vdCBjb3B5IG9iamVjdHMgaW5cbiAgICB2YWx1ZXMgYW5kIG5vdCByZWZlcmVuY2VzLiBJZiBmYWxzZSwgZG8gYSBzaGFsbG93IGNvcHksIHNldHRpbmdcbiAgICB1cCByZWZlcmVuY2VzIGluIHRoZSByZXN1bHQuIElmIHRydWUsIHRvIGEgZGVlcCBjb3B5IG9mIGFsbCBvYmplY3RzLlxuKiovXG5Nb2RlbC5wcm90b3R5cGUudG9QbGFpbk9iamVjdCA9IGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QoZGVlcENvcHkpIHtcblxuICAgIHZhciBwbGFpbiA9IHt9LFxuICAgICAgICBtb2RlbE9iaiA9IHRoaXMubW9kZWxPYmplY3Q7XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZShwcm9wZXJ0eSwgdmFsKSB7XG4gICAgICAgIHZhciBjbG9uZWRWYWx1ZSA9IGNsb25lVmFsdWUodmFsLCBkZWVwQ29weSk7XG4gICAgICAgIGlmICh0eXBlb2YoY2xvbmVkVmFsdWUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGxhaW5bcHJvcGVydHldID0gY2xvbmVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByb3BlcnRpZXNMaXN0LmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgLy8gUHJvcGVydGllcyBhcmUgb2JzZXJ2YWJsZXMsIHNvIGZ1bmN0aW9ucyB3aXRob3V0IHBhcmFtczpcbiAgICAgICAgdmFyIHZhbCA9IG1vZGVsT2JqW3Byb3BlcnR5XSgpO1xuXG4gICAgICAgIHNldFZhbHVlKHByb3BlcnR5LCB2YWwpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5maWVsZHNMaXN0LmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgLy8gRmllbGRzIGFyZSBqdXN0IHBsYWluIG9iamVjdCBtZW1iZXJzIGZvciB2YWx1ZXMsIGp1c3QgY29weTpcbiAgICAgICAgdmFyIHZhbCA9IG1vZGVsT2JqW2ZpZWxkXTtcblxuICAgICAgICBzZXRWYWx1ZShmaWVsZCwgdmFsKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwbGFpbjtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS51cGRhdGVXaXRoID0gZnVuY3Rpb24gdXBkYXRlV2l0aChkYXRhLCBkZWVwQ29weSkge1xuICAgIFxuICAgIC8vIFdlIG5lZWQgYSBwbGFpbiBvYmplY3QgZm9yICdmcm9tSlMnLlxuICAgIC8vIElmIGlzIGEgbW9kZWwsIGV4dHJhY3QgdGhlaXIgcHJvcGVydGllcyBhbmQgZmllbGRzIGZyb21cbiAgICAvLyB0aGUgb2JzZXJ2YWJsZXMgKGZyb21KUyksIHNvIHdlIG5vdCBnZXQgY29tcHV0ZWRcbiAgICAvLyBvciBmdW5jdGlvbnMsIGp1c3QgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzIGFuZCBmaWVsZHNcbiAgICB2YXIgdGltZXN0YW1wID0gbnVsbDtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLm1vZGVsIGluc3RhbmNlb2YgTW9kZWwpIHtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCB0aGUgc2FtZSB0aW1lc3RhbXAsIHNvXG4gICAgICAgIC8vIHJlbWVtYmVyIGZvciBhZnRlciB0aGUgZnJvbUpTXG4gICAgICAgIHRpbWVzdGFtcCA9IGRhdGEubW9kZWwuZGF0YVRpbWVzdGFtcCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBkYXRhIHdpdGggYSBwbGFpbiBjb3B5IG9mIGl0c2VsZlxuICAgICAgICBkYXRhID0gZGF0YS5tb2RlbC50b1BsYWluT2JqZWN0KGRlZXBDb3B5KTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5tb2RlbE9iamVjdCxcbiAgICAgICAgZGVmcyA9IHRoaXMucHJvcGVydGllc0RlZnM7XG4gICAgdGhpcy5wcm9wZXJ0aWVzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciB2YWwgPSBkYXRhW3Byb3BlcnR5XSxcbiAgICAgICAgICAgIGRlZiA9IGRlZnNbcHJvcGVydHldO1xuICAgICAgICBpZiAodHlwZW9mKHZhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldKHByZXBhcmVWYWx1ZUJ5RGVmKHZhbCwgZGVmKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZnMgPSB0aGlzLmZpZWxkc0RlZnM7XG4gICAgdGhpcy5maWVsZHNMaXN0LmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGFbZmllbGRdLFxuICAgICAgICAgICAgZGVmID0gZGVmc1tmaWVsZF07XG4gICAgICAgIGlmICh0eXBlb2YodmFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRhcmdldFtmaWVsZF0gPSBwcmVwYXJlVmFsdWVCeURlZih2YWwsIGRlZik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNhbWUgdGltZXN0YW1wIGlmIGFueVxuICAgIGlmICh0aW1lc3RhbXApXG4gICAgICAgIHRoaXMubW9kZWxPYmplY3QubW9kZWwuZGF0YVRpbWVzdGFtcCh0aW1lc3RhbXApO1xufTtcblxuLyoqXG4gICAgR2l2ZW4gYSBwbGFpbiBvYmplY3QgaW4gYSBhY2NlcHRlZCBpbXBvcnQgc3RydWN0dXJlXG4gICAgKG5ldmVyIGEgTW9kZWwgaW5zdGFuY2UpLCBpdCBtYXBzXG4gICAgdGhlIGRhdGEgdG8gdGhlIG9iamVjdCBmb2xsb3dpbmcgYSBzZXQgb2YgbWFwcGluZyBvcHRpb25zXG4gICAgb2Yga28ubWFwcGluZy5cbiAgICBJZiB0aGUgZGF0YSBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBieSAndG9QbGFpbk9iamVjdCdcbiAgICB0aGVuIHVzZSAndXBkYXRlV2l0aCcgYmV0dGVyLlxuICAgIFxuICAgIFRPRE86IFJldmlldywgbm90IHVzZWQgc3RpbGwsIG5vIHN1cmUgaWYgcmVhbGx5IHVzZWZ1bCB0byBkZXBlbmRcbiAgICBvbiBrby5tYXBwaW5nIGFuZCB0aGlzLlxuKiovXG5Nb2RlbC5wcm90b3R5cGUubWFwRGF0YSA9IGZ1bmN0aW9uIG1hcERhdGEoZGF0YSwgb3B0aW9uYWxNYXBwaW5nKSB7XG4gICAga28ubWFwcGluZy5mcm9tSlMoZGF0YSwgb3B0aW9uYWxNYXBwaW5nIHx8IHRoaXMubWFwcGluZ09wdGlvbnMsIHRoaXMubW9kZWxPYmplY3QpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoZGF0YSwgZGVlcENvcHkpIHtcbiAgICAvLyBHZXQgYSBwbGFpbiBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0IGRhdGFcbiAgICB2YXIgcGxhaW4gPSB0aGlzLnRvUGxhaW5PYmplY3QoZGVlcENvcHkpO1xuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCBpbnN0YW5jZSwgdXNpbmcgdGhlIHNvdXJjZSBwbGFpbiBvYmplY3RcbiAgICAvLyBhcyBpbml0aWFsIHZhbHVlc1xuICAgIHZhciBjbG9uZWQgPSBuZXcgdGhpcy5tb2RlbE9iamVjdC5jb25zdHJ1Y3RvcihwbGFpbik7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjbG9uZWQgd2l0aCB0aGUgcHJvdmlkZWQgcGxhaW4gZGF0YSB1c2VkXG4gICAgICAgIC8vIHRvIHJlcGxhY2UgdmFsdWVzIG9uIHRoZSBjbG9uZWQgb25lLCBmb3IgcXVpY2sgb25lLXN0ZXAgY3JlYXRpb25cbiAgICAgICAgLy8gb2YgZGVyaXZlZCBvYmplY3RzLlxuICAgICAgICBjbG9uZWQubW9kZWwudXBkYXRlV2l0aChkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIG5vIGluaXRpYWwgZGlmZmVyZW50aWFsIGRhdGEsIGVuc3VyZSB0aGVcbiAgICAgICAgLy8gc2FtZSB0aW1lc3RhbXAgc2luY2UgdGhlIGNsb25lIGlzIHN0aWxsIGlkZW50aWNhbCB0byB0aGUgc291cmNlXG4gICAgICAgIGNsb25lZC5tb2RlbC5kYXRhVGltZXN0YW1wKHRoaXMubW9kZWxPYmplY3QubW9kZWwuZGF0YVRpbWVzdGFtcCgpKTtcbiAgICB9XG4gICAgLy8gQ2xvbmVkIG1vZGVsIHJlYWR5OlxuICAgIHJldHVybiBjbG9uZWQ7XG59O1xuXG4vKipcbiAgICBVcGRhdGVzIHRoZSBkYXRhVGltZXN0YW1wIHRvIHRoZSBjdXJyZW50IHVuaXF1ZSBkYXRldGltZSxcbiAgICBzbyB0aGUgbW9kZWwgYXBwZWFyIGFzIHRvdWNoZWQvdXBkYXRlZCwgZXZlbiBpZiBub3QgZGF0YSBjaGFuZ2UuXG4gICAgVXNlZnVsIHNvbWV0aW1lcyB0byBtYWtlIGEgZGlmZmVyZW5jZSBmcm9tIGEgY2xvbmVkIGluc3RhbmNlXG4gICAgc28gYXBwZWFyIGRpZmZlcmVudC5cbiAgICBOT1RFOiB0aGUgZGF0ZXRpbWUgc2V0IGlzIG5vdCBleGFjdGx5IHRoZSBjdXJyZW50IG9uZSwgaXMgdGhlIGN1cnJlbnRcbiAgICBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHBsdXMgb25lLFxuICAgIHRvIGVuc3VyZSB0aGF0IHRoZSB0aW1lc3RhbXAgaXMgZGlmZmVyZW50IG9uIGVkZ2UgY2FzZXMgd2hlcmUgdGhpc1xuICAgIG1ldGhvZCBpcyBjYWxsZWQganVzdCBhZnRlciBhIGNyZWF0aW9uIG9yIGNsb25hdGlvbiwgYmVjYXVzZSB0aGUgd2F5XG4gICAgamF2YXNjcmlwdCB3b3JrcyBhbmQgdGhlIGxpbWl0ZWQgbWlsbGlzZWNvbmRzIHByZWNpc2lvbiBvZiB0aGUgRGF0ZSBvYmplY3RcbiAgICB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHRoZSAndG91Y2hlZCcgZGF0ZSB3aWxsIGJlIHRoZSBzYW1lIGFzIGJlZm9yZSxcbiAgICB0aGF0cyBhdm9pZGVkIHdpdGggdGhpcyBzaW1wbGUgdHJpY2ssIHNvIHJlbWFpbnMgJ3VuaXF1ZScgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uLlxuKiovXG5Nb2RlbC5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbiB0b3VjaCgpIHtcbiAgICAvLyBXZSB1c2UgdGhlIGZ1bmN0aW9uIHdheSB0byBnZXQgbWlsbGlzZWNvbmRzLCBhZGQgMSBhbmQgY3JlYXRlIGluc3RhbmNlXG4gICAgdGhpcy5kYXRhVGltZXN0YW1wKG5ldyBEYXRlKERhdGUoKSArIDEpKTtcbn07XG5cbi8qKlxuICAgIFJlcGxhY2VzIGFsbCB0aGUgcHJvcGVydGllcyBhbmQgZmllbGRzIGRhdGEgaW4gdGhlIG1vZGVsIG9iamVjdFxuICAgIHdpdGggdGhlIGRlZmF1bHQgb25lcyBvZiB0aGUgY29uc3RydWN0b3IsIHBsdXMgb3B0aW9uYWwgbmV3IHByZXNldCBkYXRhLlxuKiovXG5Nb2RlbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldChwcmVzZXRzKSB7XG4gICAgXG4gICAgdmFyIG5ld0luc3RhbmNlID0gbmV3IHRoaXMubW9kZWxPYmplY3QuY29uc3RydWN0b3IocHJlc2V0cyk7XG5cbiAgICB0aGlzLnVwZGF0ZVdpdGgobmV3SW5zdGFuY2UsIHRydWUpO1xufTtcbiIsIi8qKiBQZXJmb3JtYW5jZVN1bW1hcnkgbW9kZWwgKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgTGlzdFZpZXdJdGVtID0gcmVxdWlyZSgnLi9MaXN0Vmlld0l0ZW0nKSxcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcbiAgICBudW1lcmFsID0gcmVxdWlyZSgnbnVtZXJhbCcpO1xuXG5mdW5jdGlvbiBQZXJmb3JtYW5jZVN1bW1hcnkodmFsdWVzKSB7XG5cbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICBcbiAgICAvLyBUT0RPOiBkZWZpbmUgZWFybmluZ3MgYW5kIHRpbWVCb29raW5nIGFzIHByb3BlcnRpZXMgd2l0aCBkZWYuTW9kZWw/XG5cbiAgICB0aGlzLmVhcm5pbmdzID0gbmV3IEVhcm5pbmdzKHZhbHVlcy5lYXJuaW5ncyk7XG4gICAgXG4gICAgdmFyIGVhcm5pbmdzTGluZSA9IG5ldyBMaXN0Vmlld0l0ZW0oKTtcbiAgICBlYXJuaW5nc0xpbmUubWFya2VyTGluZTEgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bSA9IG51bWVyYWwodGhpcy5jdXJyZW50QW1vdW50KCkpLmZvcm1hdCgnJDAsMCcpO1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH0sIHRoaXMuZWFybmluZ3MpO1xuICAgIGVhcm5pbmdzTGluZS5jb250ZW50TGluZTEgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudENvbmNlcHQoKTtcbiAgICB9LCB0aGlzLmVhcm5pbmdzKTtcbiAgICBlYXJuaW5nc0xpbmUubWFya2VyTGluZTIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bSA9IG51bWVyYWwodGhpcy5uZXh0QW1vdW50KCkpLmZvcm1hdCgnJDAsMCcpO1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH0sIHRoaXMuZWFybmluZ3MpO1xuICAgIGVhcm5pbmdzTGluZS5jb250ZW50TGluZTIgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENvbmNlcHQoKTtcbiAgICB9LCB0aGlzLmVhcm5pbmdzKTtcbiAgICBcblxuICAgIHRoaXMudGltZUJvb2tlZCA9IG5ldyBUaW1lQm9va2VkKHZhbHVlcy50aW1lQm9va2VkKTtcblxuICAgIHZhciB0aW1lQm9va2VkTGluZSA9IG5ldyBMaXN0Vmlld0l0ZW0oKTtcbiAgICB0aW1lQm9va2VkTGluZS5tYXJrZXJMaW5lMSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbnVtID0gbnVtZXJhbCh0aGlzLnBlcmNlbnQoKSkuZm9ybWF0KCcwJScpO1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH0sIHRoaXMudGltZUJvb2tlZCk7XG4gICAgdGltZUJvb2tlZExpbmUuY29udGVudExpbmUxID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNlcHQoKTtcbiAgICB9LCB0aGlzLnRpbWVCb29rZWQpO1xuICAgIFxuICAgIFxuICAgIHRoaXMuaXRlbXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgaXRlbXMucHVzaChlYXJuaW5nc0xpbmUpO1xuICAgICAgICBpdGVtcy5wdXNoKHRpbWVCb29rZWRMaW5lKTtcblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyZm9ybWFuY2VTdW1tYXJ5O1xuXG5mdW5jdGlvbiBFYXJuaW5ncyh2YWx1ZXMpIHtcblxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgXG4gICAgICAgICBjdXJyZW50QW1vdW50OiAwLFxuICAgICAgICAgY3VycmVudENvbmNlcHRUZW1wbGF0ZTogJ2FscmVhZHkgcGFpZCB0aGlzIG1vbnRoJyxcbiAgICAgICAgIG5leHRBbW91bnQ6IDAsXG4gICAgICAgICBuZXh0Q29uY2VwdFRlbXBsYXRlOiAncHJvamVjdGVkIHttb250aH0gZWFybmluZ3MnXG5cbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMuY3VycmVudENvbmNlcHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1vbnRoID0gbW9tZW50KCkuZm9ybWF0KCdNTU1NJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb25jZXB0VGVtcGxhdGUoKS5yZXBsYWNlKC9cXHttb250aFxcfS8sIG1vbnRoKTtcblxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5uZXh0Q29uY2VwdCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbW9udGggPSBtb21lbnQoKS5hZGQoMSwgJ21vbnRoJykuZm9ybWF0KCdNTU1NJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDb25jZXB0VGVtcGxhdGUoKS5yZXBsYWNlKC9cXHttb250aFxcfS8sIG1vbnRoKTtcblxuICAgIH0sIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBUaW1lQm9va2VkKHZhbHVlcykge1xuXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICBcbiAgICAgICAgcGVyY2VudDogMCxcbiAgICAgICAgY29uY2VwdFRlbXBsYXRlOiAnb2YgYXZhaWxhYmxlIHRpbWUgYm9va2VkIGluIHttb250aH0nXG4gICAgXG4gICAgfSwgdmFsdWVzKTtcbiAgICBcbiAgICB0aGlzLmNvbmNlcHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1vbnRoID0gbW9tZW50KCkuYWRkKDEsICdtb250aCcpLmZvcm1hdCgnTU1NTScpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jZXB0VGVtcGxhdGUoKS5yZXBsYWNlKC9cXHttb250aFxcfS8sIG1vbnRoKTtcblxuICAgIH0sIHRoaXMpO1xufVxuIiwiLyoqXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBQcmljaW5nU3VtbWFyeURldGFpbCA9IHJlcXVpcmUoJy4vUHJpY2luZ1N1bW1hcnlEZXRhaWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBQcmljaW5nU3VtbWFyeSh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHByaWNpbmdTdW1tYXJ5SUQ6IDAsXG4gICAgICAgIHByaWNpbmdTdW1tYXJ5UmV2aXNpb246IDAsXG4gICAgICAgIHNlcnZpY2VEdXJhdGlvbk1pbnV0ZXM6IG51bGwsXG4gICAgICAgIGZpcnN0U2Vzc2lvbkR1cmF0aW9uTWludXRlczogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIHN1YnRvdGFsUHJpY2U6IG51bGwsXG4gICAgICAgIGZlZVByaWNlOiBudWxsLFxuICAgICAgICB0b3RhbFByaWNlOiBudWxsLFxuICAgICAgICBwRmVlUHJpY2U6IG51bGwsXG4gICAgICAgIHN1YnRvdGFsUmVmdW5kZWQ6IG51bGwsXG4gICAgICAgIGZlZVJlZnVuZGVkOiBudWxsLFxuICAgICAgICB0b3RhbFJlZnVuZGVkOiBudWxsLFxuICAgICAgICBkYXRlUmVmdW5kZWQ6IG51bGwsXG4gICAgICAgIFxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGwsXG4gICAgICAgIFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBNb2RlbDogUHJpY2luZ1N1bW1hcnlEZXRhaWwsXG4gICAgICAgICAgICBpc0FycmF5OiB0cnVlXG4gICAgICAgIH1cbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMuc2VydmljZXNTdW1tYXJ5ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHMoKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGRldGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbC5zZXJ2aWNlTmFtZSgpO1xuICAgICAgICB9KS5qb2luKCcsICcpO1xuICAgIH0sIHRoaXMpXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiAyMCB9IH0pO1xufTtcbiIsIi8qKlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuZnVuY3Rpb24gUHJpY2luZ1N1bW1hcnlEZXRhaWwodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBwcmljaW5nU3VtbWFyeUlEOiAwLFxuICAgICAgICBwcmljaW5nU3VtbWFyeVJldmlzaW9uOiAwLFxuICAgICAgICBzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEOiAwLFxuICAgICAgICBzZXJ2aWNlUHJvZmVzc2lvbmFsRGF0YUlucHV0OiBudWxsLFxuICAgICAgICBjbGllbnREYXRhSW5wdXQ6IG51bGwsXG4gICAgICAgIGhvdXJseVByaWNlOiBudWxsLFxuICAgICAgICBwcmljZTogbnVsbCxcbiAgICAgICAgc2VydmljZUR1cmF0aW9uTWludXRlczogbnVsbCxcbiAgICAgICAgZmlyc3RTZXNzaW9uRHVyYXRpb25NaW51dGVzOiBudWxsLFxuICAgICAgICBzZXJ2aWNlTmFtZTogJycsXG4gICAgICAgIHNlcnZpY2VEZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgbnVtYmVyT2ZTZXNzaW9uczogMSxcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXG4gICAgfSwgdmFsdWVzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmljaW5nU3VtbWFyeURldGFpbDtcblxuUHJpY2luZ1N1bW1hcnlEZXRhaWwuZnJvbVNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSkge1xuICAgIC8vIFRPRE8gU3VwcG9ydCBzcGVjaWFsIGhvdXJseSBwcmljaW5ncywgaG91c2VrZWVwZXIsIGV0Yy5cbiAgICB2YXIgYWxsU2Vzc2lvbk1pbnV0ZXMgPSBzZXJ2aWNlLm51bWJlck9mU2Vzc2lvbnMgKCkgPiAwID9cbiAgICAgICAgc2VydmljZS5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKCkgKiBzZXJ2aWNlLm51bWJlck9mU2Vzc2lvbnMoKSA6XG4gICAgICAgIHNlcnZpY2Uuc2VydmljZUR1cmF0aW9uTWludXRlcygpO1xuXG4gICAgcmV0dXJuIG5ldyBQcmljaW5nU3VtbWFyeURldGFpbCh7XG4gICAgICAgIHNlcnZpY2VOYW1lOiBzZXJ2aWNlLm5hbWUoKSxcbiAgICAgICAgc2VydmljZURlc2NyaXB0aW9uOiBzZXJ2aWNlLmRlc2NyaXB0aW9uKCksXG4gICAgICAgIG51bWJlck9mU2Vzc2lvbnM6IHNlcnZpY2UubnVtYmVyT2ZTZXNzaW9ucygpLFxuICAgICAgICBzZXJ2aWNlRHVyYXRpb25NaW51dGVzOiBhbGxTZXNzaW9uTWludXRlcyxcbiAgICAgICAgZmlyc3RTZXNzaW9uRHVyYXRpb25NaW51dGVzOiBzZXJ2aWNlLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKSxcbiAgICAgICAgcHJpY2U6IHNlcnZpY2UucHJpY2UoKSxcbiAgICAgICAgc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRDogc2VydmljZS5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKCksXG4gICAgICAgIGhvdXJseVByaWNlOiAoc2VydmljZS5wcmljZVJhdGVVbml0KCkgfHwgJycpLnRvVXBwZXJDYXNlKCkgPT09ICdIT1VSJyA/IHNlcnZpY2UucHJpY2VSYXRlKCkgOiBudWxsXG4gICAgfSk7XG59O1xuIiwiLyoqXG4gICAgUHJpY2luZyBUeXBlIG1vZGVsXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBQcmljaW5nVHlwZSh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBwcmljaW5nVHlwZUlEOiAwLFxuICAgICAgICBzaW5ndWxhck5hbWU6ICcnLFxuICAgICAgICBwbHVyYWxOYW1lOiAnJyxcbiAgICAgICAgc2x1Z05hbWU6ICcnLFxuICAgICAgICBhZGROZXdMYWJlbDogbnVsbCxcbiAgICAgICAgc2VydmljZVByb2Zlc3Npb25hbERlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICAvLyBQcmljZUNhbGN1bGF0aW9uVHlwZSBlbnVtZXJhdGlvbiB2YWx1ZTpcbiAgICAgICAgcHJpY2VDYWxjdWxhdGlvbjogbnVsbCxcbiAgICAgICAgaXNBZGRvbjogZmFsc2UsXG4gICAgICAgIFxuICAgICAgICAvLyBGb3JtIFRleHRzXG4gICAgICAgIG5hbWVQbGFjZUhvbGRlcjogbnVsbCxcbiAgICAgICAgc3VnZ2VzdGVkTmFtZTogbnVsbCxcbiAgICAgICAgZml4ZWROYW1lOiBudWxsLFxuICAgICAgICBkdXJhdGlvbkxhYmVsOiBudWxsLFxuICAgICAgICBwcmljZUxhYmVsOiBudWxsLFxuICAgICAgICBwcmljZU5vdGU6IG51bGwsXG4gICAgICAgIGZpcnN0VGltZUNsaWVudHNPbmx5TGFiZWw6IG51bGwsXG4gICAgICAgIGRlc2NyaXB0aW9uUGxhY2VIb2xkZXI6IG51bGwsXG4gICAgICAgIHByaWNlUmF0ZVF1YW50aXR5TGFiZWw6IG51bGwsXG4gICAgICAgIHByaWNlUmF0ZVVuaXRMYWJlbDogbnVsbCxcbiAgICAgICAgbm9QcmljZVJhdGVMYWJlbDogbnVsbCxcbiAgICAgICAgbnVtYmVyT2ZTZXNzaW9uc0xhYmVsOiBudWxsLFxuICAgICAgICBpblBlcnNvblBob25lTGFiZWw6IG51bGwsXG4gICAgICAgIFxuICAgICAgICAvLyBBY3Rpb24gQW5kIFZhbGlkYXRpb24gVGV4dHNcbiAgICAgICAgc3VjY2Vzc09uRGVsZXRlOiBudWxsLFxuICAgICAgICBlcnJvck9uRGVsZXRlOiBudWxsLFxuICAgICAgICBzdWNjZXNzT25TYXZlOiBudWxsLFxuICAgICAgICBlcnJvck9uU2F2ZTogbnVsbCxcbiAgICAgICAgcHJpY2VSYXRlSXNSZXF1aXJlZFZhbGlkYXRpb25FcnJvcjogbnVsbCxcbiAgICAgICAgcHJpY2VSYXRlVW5pdElzUmVxdWlyZWRWYWxpZGF0aW9uRXJyb3I6IG51bGwsXG4gICAgICAgIFxuICAgICAgICAvLyBIZWxwIFRleHRzXG4gICAgICAgIGxlYXJuTW9yZUxhYmVsOiBudWxsLFxuICAgICAgICBsZWFybk1vcmVUZXh0OiBudWxsLFxuICAgICAgICBwcmljZVJhdGVMZWFybk1vcmVMYWJlbDogbnVsbCxcbiAgICAgICAgcHJpY2VSYXRlTGVhcm5Nb3JlVGV4dDogbnVsbCxcbiAgICAgICAgbm9QcmljZVJhdGVMZWFybk1vcmVMYWJlbDogbnVsbCxcbiAgICAgICAgbm9QcmljZVJhdGVMZWFybk1vcmVUZXh0OiBudWxsLFxuICAgICAgICBcbiAgICAgICAgLy8gQWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG4gICAgICAgIHJlcXVpcmVEdXJhdGlvbjogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVTZXJ2aWNlQXR0cmlidXRlczogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVTcGVjaWFsUHJvbW90aW9uOiBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIC8vIExpc3QgVGV4dHNcbiAgICAgICAgLy8vIFN1bW1hcnlGb3JtYXQgaXMgdGhlIGRlZmF1bHQgZm9ybWF0IGZvciBzdW1tYXJpZXMgKHJlcXVpcmVkKSxcbiAgICAgICAgLy8vIG90aGVyIGZvcm1hdHMgYXJlIGdvb2QgZm9yIGJldHRlciBkZXRhaWwsIGJ1dCBkZXBlbmRzXG4gICAgICAgIC8vLyBvbiBvdGhlciBvcHRpb25zIGNvbmZpZ3VyZWQgcGVyIHR5cGUuXG4gICAgICAgIC8vLyBXaWxkY2FyZHM6XG4gICAgICAgIC8vLyB7MH06IGR1cmF0aW9uXG4gICAgICAgIC8vLyB7MX06IHNlc3Npb25zXG4gICAgICAgIC8vLyB7Mn06IGlucGVyc29uL3Bob25lXG4gICAgICAgIHN1bW1hcnlGb3JtYXQ6IG51bGwsXG4gICAgICAgIHN1bW1hcnlGb3JtYXRNdWx0aXBsZVNlc3Npb25zOiBudWxsLFxuICAgICAgICBzdW1tYXJ5Rm9ybWF0Tm9EdXJhdGlvbjogbnVsbCxcbiAgICAgICAgc3VtbWFyeUZvcm1hdE11bHRpcGxlU2Vzc2lvbnNOb0R1cmF0aW9uOiBudWxsLFxuICAgICAgICB3aXRob3V0U2VydmljZUF0dHJpYnV0ZXNDbGllbnRNZXNzYWdlOiBudWxsLFxuICAgICAgICB3aXRob3V0U2VydmljZUF0dHJpYnV0ZXNTZXJ2aWNlUHJvZmVzc2lvbmFsTWVzc2FnZTogbnVsbCxcbiAgICAgICAgZmlyc3RUaW1lQ2xpZW50c09ubHlMaXN0VGV4dDogbnVsbCxcbiAgICAgICAgcHJpY2VSYXRlUXVhbnRpdHlMaXN0TGFiZWw6IG51bGwsXG4gICAgICAgIHByaWNlUmF0ZVVuaXRMaXN0TGFiZWw6IG51bGwsXG4gICAgICAgIG5vUHJpY2VSYXRlTGlzdE1lc3NhZ2U6IG51bGwsXG4gICAgICAgIFxuICAgICAgICAvLyBCb29raW5nL1ByaWNpbmdTdW1tYXJ5IFRleHRzXG4gICAgICAgIC8vLyBOYW1lQW5kU3VtbWFyeUZvcm1hdCBpcyB0aGUgZGVmYXVsdCBmb3JtYXQgZm9yIHN1bW1hcmllcyB3aXRoIHBhY2thZ2UgbmFtZSAocmVxdWlyZWQpLFxuICAgICAgICAvLy8gb3RoZXIgZm9ybWF0cyBhcmUgZ29vZCBmb3IgYmV0dGVyIGRldGFpbCwgYnV0IGRlcGVuZHNcbiAgICAgICAgLy8vIG9uIG90aGVyIG9wdGlvbnMgY29uZmlndXJlZCBwZXIgdHlwZS5cbiAgICAgICAgLy8vIFdpbGRjYXJkczpcbiAgICAgICAgLy8vIHswfTogcGFja2FnZSBuYW1lXG4gICAgICAgIC8vLyB7MX06IGR1cmF0aW9uXG4gICAgICAgIC8vLyB7Mn06IHNlc3Npb25zXG4gICAgICAgIC8vLyB7M306IGlucGVyc29uL3Bob25lXG4gICAgICAgIG5hbWVBbmRTdW1tYXJ5Rm9ybWF0OiBudWxsLFxuICAgICAgICBuYW1lQW5kU3VtbWFyeUZvcm1hdE11bHRpcGxlU2Vzc2lvbnM6IG51bGwsXG4gICAgICAgIG5hbWVBbmRTdW1tYXJ5Rm9ybWF0Tm9EdXJhdGlvbjogbnVsbCxcbiAgICAgICAgbmFtZUFuZFN1bW1hcnlGb3JtYXRNdWx0aXBsZVNlc3Npb25zTm9EdXJhdGlvbjogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8vIFJlY29yZCBtYWludGVuYW5jZVxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmSUQoWydwcmljaW5nVHlwZUlEJ10pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByaWNpbmdUeXBlO1xuXG4vLyBFbnVtZXJhdGlvbjpcbnZhciBQcmljZUNhbGN1bGF0aW9uVHlwZSA9IHtcbiAgICBGaXhlZFByaWNlOiAxLFxuICAgIEhvdXJseVByaWNlOiAyXG59O1xuXG5QcmljaW5nVHlwZS5QcmljZUNhbGN1bGF0aW9uVHlwZSA9IFByaWNlQ2FsY3VsYXRpb25UeXBlO1xuIiwiLyoqXG4gICAgUHJpdmFjeVNldHRpbmdzIG1vZGVsXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBQcml2YWN5U2V0dGluZ3ModmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdXNlcklEOiAwLFxuICAgICAgICBzbXNCb29raW5nQ29tbXVuaWNhdGlvbjogZmFsc2UsXG4gICAgICAgIHBob25lQm9va2luZ0NvbW11bmljYXRpb246IGZhbHNlLFxuICAgICAgICBsb2Nvbm9taWNzQ29tbXVuaXR5Q29tbXVuaWNhdGlvbjogZmFsc2UsXG4gICAgICAgIGxvY29ub21pY3NEYm1DYW1wYWlnbnM6IGZhbHNlLFxuICAgICAgICBwcm9maWxlU2VvUGVybWlzc2lvbjogZmFsc2UsXG4gICAgICAgIGxvY29ub21pY3NNYXJrZXRpbmdDYW1wYWlnbnM6IGZhbHNlLFxuICAgICAgICBjb0JyYW5kZWRQYXJ0bmVyUGVybWlzc2lvbnM6IGZhbHNlLFxuICAgICAgICBjcmVhdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmSUQoWyd1c2VySUQnXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpdmFjeVNldHRpbmdzO1xuIiwiLyoqXG4gICAgQ29sbGVjdGlvbiBvZiBwdWJsaWMgaW5mb3JtYXRpb24gZnJvbSBhIHVzZXIsXG4gICAgaG9sZGVkIG9uIGRpZmZlcmVudCBtb2RlbHNcbiAgICBcbiAgICBUT0RPOiBTb21lIGZpZWxkcyBpbnRyb2R1Y2VkIHRvIGhlbHAgdGhlIFNlcnZpY2VQcm9mZXNzaW9uYWxJbmZvIGNvbXBvbmVudCwgYnV0IG1heSByZXF1aXJlIHJlZmFjdG9yXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIFB1YmxpY1VzZXJQcm9maWxlID0gcmVxdWlyZSgnLi9QdWJsaWNVc2VyUHJvZmlsZScpLFxuICAgIFB1YmxpY1VzZXJSYXRpbmcgPSByZXF1aXJlKCcuL1B1YmxpY1VzZXJSYXRpbmcnKSxcbiAgICBQdWJsaWNVc2VyVmVyaWZpY2F0aW9uc1N1bW1hcnkgPSByZXF1aXJlKCcuL1B1YmxpY1VzZXJWZXJpZmljYXRpb25zU3VtbWFyeScpLFxuICAgIFB1YmxpY1VzZXJKb2JUaXRsZSA9IHJlcXVpcmUoJy4vUHVibGljVXNlckpvYlRpdGxlJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5mdW5jdGlvbiBQdWJsaWNVc2VyKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHByb2ZpbGU6IHsgTW9kZWw6IFB1YmxpY1VzZXJQcm9maWxlIH0sXG4gICAgICAgIHJhdGluZzogeyBNb2RlbDogUHVibGljVXNlclJhdGluZyB9LFxuICAgICAgICB2ZXJpZmljYXRpb25zU3VtbWFyeTogeyBNb2RlbDogUHVibGljVXNlclZlcmlmaWNhdGlvbnNTdW1tYXJ5IH0sXG4gICAgICAgIGpvYlByb2ZpbGU6IHtcbiAgICAgICAgICAgIE1vZGVsOiBQdWJsaWNVc2VySm9iVGl0bGUsXG4gICAgICAgICAgICBpc0FycmF5OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE8gVG8gaW1wbGVtZW50IG9uIHNlcnZlciwgUkVTVCBBUElcbiAgICAgICAgYmFja2dyb3VuZENoZWNrUGFzc2VkOiBudWxsLCAvLyBudWxsLCB0cnVlLCBmYWxzZVxuICAgICAgICAvLyBVdGlsaXR5IGRhdGEgZm9yIFNlcnZpY2VQcm9mZXNzaW9uYWxJbmZvXG4gICAgICAgIHNlbGVjdGVkSm9iVGl0bGVJRDogbnVsbCxcbiAgICAgICAgaXNDbGllbnRGYXZvcml0ZTogZmFsc2VcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIC8vIFV0aWxpdGllcyBmb3IgU2VydmljZVByb2Zlc3Npb25hbEluZm9cbiAgICB0aGlzLnNlbGVjdGVkSm9iVGl0bGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBqaWQgPSB0aGlzLnNlbGVjdGVkSm9iVGl0bGVJRCgpLFxuICAgICAgICAgICAganAgPSB0aGlzLmpvYlByb2ZpbGUoKTtcbiAgICAgICAgaWYgKCFqaWQgfHwgIWpwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGZvdW5kID0gbnVsbDtcbiAgICAgICAganAuc29tZShmdW5jdGlvbihqb2JUaXRsZSkge1xuICAgICAgICAgICAgaWYgKGpvYlRpdGxlLmpvYlRpdGxlSUQoKSA9PT0gamlkKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBqb2JUaXRsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmJhY2tncm91bmRDaGVja0xhYmVsID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuYmFja2dyb3VuZENoZWNrUGFzc2VkKCk7XG4gICAgICAgIGlmICh2ID09PSB0cnVlKSByZXR1cm4gJ09LJztcbiAgICAgICAgZWxzZSBpZiAodiA9PT0gZmFsc2UpIHJldHVybiAnRkFJTEVEJztcbiAgICAgICAgZWxzZSByZXR1cm4gJyc7XG4gICAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljVXNlcjtcbiIsIi8qKlxuICAgIFB1YmxpY1VzZXJKb2JUaXRsZSBtb2RlbCwgcmVsYXRpb25zaGlwIGJldHdlZW4gYW4gdXNlciBhbmQgYVxuICAgIGpvYiB0aXRsZSBhbmQgdGhlIG1haW4gZGF0YSBhdHRhY2hlZCB0byB0aGF0IHJlbGF0aW9uIGZvclxuICAgIHB1YmxpYyBhY2Nlc3MgKGludGVybmFsIGZpZWxkcyBhdm9pZGVkKSBhbmQgYWRkaXRpb25hbFxuICAgIHVzZWZ1bCBqb2IgdGl0bGUgaW5mbyAoc2hvcnRjdXQgdG8gam9iIHRpdGxlIG5hbWVzIGZvciBjb252ZW5pZW5jZSkuXG4gICAgXG4gICAgVGhlIG1vZGVsIGhhcyBvcHRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbGlua1xuICAgIHRvIG90aGVyIG1vZGVsIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gYSBzcGVjaWZpYyBqb2JUaXRsZVxuICAgIGZvciBjb252ZW5pZW5jZSB3aGVuIHF1ZXJ5aW5nIGEgd2lkZXIgc2V0IG9mIGluZm9ybWF0aW9uXG4gICAgYW5kIGtlZXAgaXQgb3JnYW5pemVkIHVuZGVyIHRoaXMgbW9kZWwgaW5zdGFuY2VzLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcbiAgICBQdWJsaWNVc2VyUmF0aW5nID0gcmVxdWlyZSgnLi9QdWJsaWNVc2VyUmF0aW5nJyksXG4gICAgUHVibGljVXNlclZlcmlmaWNhdGlvbnNTdW1tYXJ5ID0gcmVxdWlyZSgnLi9QdWJsaWNVc2VyVmVyaWZpY2F0aW9uc1N1bW1hcnknKTtcblxuZnVuY3Rpb24gUHVibGljVXNlckpvYlRpdGxlKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHVzZXJJRDogMCxcbiAgICAgICAgam9iVGl0bGVJRDogMCxcbiAgICAgICAgaW50cm86IG51bGwsXG4gICAgICAgIGNhbmNlbGxhdGlvblBvbGljeUlEOiAwLFxuICAgICAgICBpbnN0YW50Qm9va2luZzogZmFsc2UsXG4gICAgICAgIGpvYlRpdGxlU2luZ3VsYXJOYW1lOiAnJyxcbiAgICAgICAgam9iVGl0bGVQbHVyYWxOYW1lOiAnJyxcbiAgICAgICAgXG4gICAgICAgIHJhdGluZzogeyBNb2RlbDogUHVibGljVXNlclJhdGluZyB9LFxuICAgICAgICB2ZXJpZmljYXRpb25zU3VtbWFyeTogeyBNb2RlbDogUHVibGljVXNlclZlcmlmaWNhdGlvbnNTdW1tYXJ5IH0sXG4gICAgfSwgdmFsdWVzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmSUQoWyd1c2VySUQnLCAnam9iVGl0bGVJRCddKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQdWJsaWNVc2VySm9iVGl0bGU7XG4iLCIvKipcbiAgICBQdWJsaWMgaW5mb3JtYXRpb24gZnJvbSBhIHVzZXIuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZnVuY3Rpb24gUHVibGljVXNlclByb2ZpbGUodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdXNlcklEOiAwLFxuICAgICAgICBmaXJzdE5hbWU6IDAsXG4gICAgICAgIGxhc3ROYW1lOiAwLFxuICAgICAgICBzZWNvbmRMYXN0TmFtZTogMCxcbiAgICAgICAgYnVzaW5lc3NOYW1lOiAwLFxuICAgICAgICBwdWJsaWNCaW86IDAsXG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxQcm9maWxlVXJsU2x1ZzogbnVsbCxcbiAgICAgICAgc2VydmljZVByb2Zlc3Npb25hbFdlYnNpdGVVcmw6IG51bGwsXG4gICAgICAgIHBob3RvVXJsOiBudWxsLFxuICAgICAgICBlbWFpbDogbnVsbCxcbiAgICAgICAgcGhvbmU6IG51bGwsXG4gICAgICAgIGlzU2VydmljZVByb2Zlc3Npb25hbDogZmFsc2UsXG4gICAgICAgIGlzQ2xpZW50OiBmYWxzZSxcbiAgICAgICAgdXBkYXRlZERhdGU6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMuZnVsbE5hbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuYW1lUGFydHMgPSBbdGhpcy5maXJzdE5hbWUoKV07XG4gICAgICAgIGlmICh0aGlzLmxhc3ROYW1lKCkpXG4gICAgICAgICAgICBuYW1lUGFydHMucHVzaCh0aGlzLmxhc3ROYW1lKCkpO1xuICAgICAgICBpZiAodGhpcy5zZWNvbmRMYXN0TmFtZSgpKVxuICAgICAgICAgICAgbmFtZVBhcnRzLnB1c2godGhpcy5zZWNvbmRMYXN0TmFtZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmFtZVBhcnRzLmpvaW4oJyAnKTtcbiAgICB9LCB0aGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQdWJsaWNVc2VyUHJvZmlsZTtcbiIsIi8qKlxuICAgIFJhdGluZyB2YWx1ZXMgZm9yIHVzZXIsIGFzIHVzZXIsIGNsaWVudC4gc2VydmljZSBwcm9mZXNzaW9uYWxcbiAgICBvciBqb2IgdGl0bGUgc3BlY2lmaWMuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBQdWJsaWNVc2VyUmF0aW5nKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHJhdGluZzE6IDAsXG4gICAgICAgIHJhdGluZzI6IDAsXG4gICAgICAgIHJhdGluZzM6IDAsXG4gICAgICAgIHJhdGluZ0F2ZXJhZ2U6IDAsXG4gICAgICAgIHRvdGFsUmF0aW5nczogMCxcbiAgICAgICAgc2VydmljZUhvdXJzOiAwLFxuICAgICAgICBsYXN0UmF0aW5nRGF0ZTogbnVsbFxuICAgIH0sIHZhbHVlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljVXNlclJhdGluZztcbiIsIi8qKlxuICAgIE51bWJlciBvZiB2ZXJpZmljYXRpb25zIGZvciB0aGUgdXNlciwgYXMgdXNlciwgY2xpZW50LCBzZXJ2aWNlIHByb2Zlc3Npb25hbFxuICAgIG9yIGpvYiB0aXRsZSBzcGVjaWZpYywgcGVyIGdyb3VwIG9mIHZlcmlmaWNhdGlvbnNcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbmZ1bmN0aW9uIFB1YmxpY1VzZXJWZXJpZmljYXRpb25zR3JvdXAodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdmVyaWZpY2F0aW9uc0NvdW50OiAwLFxuICAgICAgICBncm91cE5hbWU6ICcnLFxuICAgICAgICBncm91cElEOiAnJ1xuICAgIH0sIHZhbHVlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljVXNlclZlcmlmaWNhdGlvbnNHcm91cDtcbiIsIi8qKlxuICAgIE51bWJlciBvZiB2ZXJpZmljYXRpb25zIGFuZCBncm91cGVkIGNvdW50cy5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgUHVibGljVXNlclZlcmlmaWNhdGlvbnNHcm91cCA9IHJlcXVpcmUoJy4vUHVibGljVXNlclZlcmlmaWNhdGlvbnNHcm91cCcpO1xuXG5mdW5jdGlvbiBQdWJsaWNVc2VyVmVyaWZpY2F0aW9uc1N1bW1hcnkodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdG90YWw6IDAsXG4gICAgICAgIGdyb3VwczogUHVibGljVXNlclZlcmlmaWNhdGlvbnNHcm91cFxuICAgIH0sIHZhbHVlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljVXNlclZlcmlmaWNhdGlvbnNTdW1tYXJ5O1xuIiwiLyoqXG4gICAgU2NoZWR1bGluZ1ByZWZlcmVuY2VzIG1vZGVsLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbmZ1bmN0aW9uIFNjaGVkdWxpbmdQcmVmZXJlbmNlcyh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGFkdmFuY2VUaW1lOiAyNCwgLy8gSG91cnNcbiAgICAgICAgYmV0d2VlblRpbWU6IDAsIC8vIEhvdXJzXG4gICAgICAgIGluY3JlbWVudHNTaXplSW5NaW51dGVzOiAxNVxuICAgIH0sIHZhbHVlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZWR1bGluZ1ByZWZlcmVuY2VzO1xuIiwiLyoqIFNlcnZpY2VBdHRyaWJ1dGUgbW9kZWwuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuZnVuY3Rpb24gU2VydmljZUF0dHJpYnV0ZSh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHNlcnZpY2VBdHRyaWJ1dGVJRDogMCxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsXG4gICAgICAgIC8vY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIC8vdXBkYXRlZERhdGU6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2VBdHRyaWJ1dGU7XG4iLCIvKiogU2VydmljZUF0dHJpYnV0ZUNhdGVnb3J5IG1vZGVsLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgU2VydmljZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vU2VydmljZUF0dHJpYnV0ZScpO1xuXG5mdW5jdGlvbiBTZXJ2aWNlQXR0cmlidXRlQ2F0ZWdvcnkodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBzZXJ2aWNlQXR0cmlidXRlQ2F0ZWdvcnlJRDogMCxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICByZXF1aXJlZElucHV0OiBmYWxzZSxcbiAgICAgICAgZWxpZ2libGVGb3JQYWNrYWdlczogZmFsc2UsXG4gICAgICAgIHNlcnZpY2VBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBpc0FycmF5OiB0cnVlLFxuICAgICAgICAgICAgTW9kZWw6IFNlcnZpY2VBdHRyaWJ1dGVcbiAgICAgICAgfVxuICAgICAgICAvL2NyZWF0ZWREYXRlOiBudWxsLFxuICAgICAgICAvL3VwZGF0ZWREYXRlOiBudWxsXG4gICAgfSwgdmFsdWVzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlQXR0cmlidXRlQ2F0ZWdvcnk7XG4iLCIvKipcbiAgICBTZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZSBtb2RlbDogbWFuYWdlcyBhbiBpbmRpdmlkdWFsXG4gICAgc2VydmljZSBmcm9tIHRoZSB1c2VyIGFuZCBhIHNwZWNpZmljIGpvYiB0aXRsZS5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIG51bWVyYWwgPSByZXF1aXJlKCdudW1lcmFsJyk7XG5cbmZ1bmN0aW9uIFNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQ6IDAsXG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxVc2VySUQ6IDAsXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXG4gICAgICAgIHByaWNpbmdUeXBlSUQ6IDAsXG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgcHJpY2U6IG51bGwsXG4gICAgICAgIHNlcnZpY2VEdXJhdGlvbk1pbnV0ZXM6IG51bGwsXG4gICAgICAgIGZpcnN0VGltZUNsaWVudHNPbmx5OiBmYWxzZSxcbiAgICAgICAgbnVtYmVyT2ZTZXNzaW9uczogMSxcbiAgICAgICAgcHJpY2VSYXRlOiBudWxsLFxuICAgICAgICBwcmljZVJhdGVVbml0OiAnaG91cicsXG4gICAgICAgIC8vIFNwZWNpYWwgcHJvcGVydHksIG5vdCBpbiBzb3VyY2UgZGF0YSBqdXN0IG9ubHkgYW4gZXhwbGljaXRcbiAgICAgICAgLy8gd2F5IHRvIGF2b2lkIHZhbGlkYXRpb24gb2YgcHJpY2VSYXRlIGlmIG5vdCBleHBsaWNpdCB2YWx1ZSBzZXRcbiAgICAgICAgbm9QcmljZVJhdGU6IGZhbHNlLFxuICAgICAgICBpc1Bob25lOiBmYWxzZSxcbiAgICAgICAgLy8gQXJyYXkgb2YgaW50ZWdlcnMsIElEcyBvZiBzZXJ2aWNlQXR0cmlidXRlc1xuICAgICAgICBzZXJ2aWNlQXR0cmlidXRlczogW10sXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLFxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbFxuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZJRChbJ3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQnXSk7XG4gICAgXG4gICAgLy8gT25lIHdheSBlZmZlY3Q6IHNldCBwcmljZVJhdGUgdG8gbnVsbCB3aGVuIHNldHRpbmcgb24gbm9QcmljZVJhdGVcbiAgICAvLyBCdXQgbm90aGluZyBvbiBvZmYgYW5kIG5vIG90aGVyIHJlbGF0aW9ucyB0byBhdm9pZCBiYWQgc2lkZSBlZmZlY3RzLlxuICAgIHRoaXMubm9QcmljZVJhdGUuc3Vic2NyaWJlKGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJpY2VSYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLyoqXG4gICAgICAgIEFzayBmb3IgYSByZWZyZXNoIG9mIHRoZSBub1ByaWNlUmF0ZSwgdGhhdCBtdXN0IGJlICd0cnVlJyBpZiB0aGUgcmVjb3JkIGV4aXN0cyBhbmRcbiAgICAgICAgaGFzIG5vIHByaWNlUmF0ZSAodG8gcmVtZW1iZXIgdGhlIHByZXZpb3VzIHZhbHVlIHNldCBieSB0aGUgdXNlciBhYm91dCBub1ByaWNlUmF0ZSkuXG4gICAgICAgIEl0IGVuc3VyZSB0aGF0IHRoZSBpbnRlcm5hbCB0aW1lc3RhbXAga2VlcCB1bnRvdWNoZWQuXG4gICAgICAgIENhbm5vdCBiZSBhdXRvbWF0aWMsIHNvIG5lZWQgdG8gYmUgY2FsbGVkIG1hbnVhbGx5IGFmdGVyIGEgZGF0YSBsb2FkIHRoYXQgZG9lcyBub3RcbiAgICAgICAgd2FudCB0byByZWZsZWN0IHRoaXMgY2hhbmdlIGFzIGEgZGF0YSBjaGFuZ2UuXG4gICAgKiovXG4gICAgdGhpcy5yZWZyZXNoTm9QcmljZVJhdGUgPSBmdW5jdGlvbiByZWZyZXNoTm9QcmljZVJhdGUoKSB7XG4gICAgICAgIC8vIE5vdCBUbyBTdGF0ZSBQcmljZSBSYXRlOiBpZiBpcyBhIHNhdmVkIHByaWNpbmcsIG1hcmsgdGhlIG5vUHJpY2VSYXRlIGlmIHByaWNlIHJhdGUgaXNcbiAgICAgICAgLy8gbnVsbCBvciAwOyBjYW5ub3QgYmUgZG9uZSB3aXRoIGEgc3Vic2NyaXB0aW9uIG9uIHByaWNlUmF0ZSBjaGFuZ2VzIGJlY2F1c2Ugd2lsbCBoYXZlXG4gICAgICAgIC8vIHRoZSBiYWQgc2lkZSBlZmZlY3Qgb2YgYXV0byBtYXJrIG5vUHJpY2VSYXRlIG9uIHNldHRpbmcgMCBvbiBwcmljZVJhdGUsIGJyZWFraW5nIHRoZVxuICAgICAgICAvLyBleHBsaWNpdCBwdXJwb3NlIG9mIHRoZSBub1ByaWNlUmF0ZSBjaGVja2JveDpcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCgpICYmICh0aGlzLnByaWNlUmF0ZSgpIHwwKSA8PSAwKSB7XG4gICAgICAgICAgICB2YXIgdHMgPSB0aGlzLm1vZGVsLmRhdGFUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIHRoaXMubm9QcmljZVJhdGUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBTZXQgYWdhaW4gdGltZXN0YW1wIHNvIHRoZSBtb2RlbCBhcHBlYXIgYXMgdW50b3VjaGVkLlxuICAgICAgICAgICAgdGhpcy5tb2RlbC5kYXRhVGltZXN0YW1wKHRzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBbHRlcm5hdGl2ZSBlZGl0aW9uIG9mIHRoZSBzZXJ2aWNlRHVyYXRpb25NaW51dGVzIGZpZWxkczpcbiAgICAvLyBTcGxpdGVkIGFzIGhvdXJzIGFuZCBtaW51dGVzXG4gICAgdmFyIGlzID0gcmVxdWlyZSgnaXNfanMnKTtcbiAgICB0aGlzLmR1cmF0aW9uSG91cnNQYXJ0ID0ga28ucHVyZUNvbXB1dGVkKHtcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZnVsbE1pbnV0ZXMgPSB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGlzLm5vdC5udW1iZXIoZnVsbE1pbnV0ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gKChmdWxsTWludXRlc3wwKSAvIDYwKSB8MDtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGhvdXJzKSB7XG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IHRoaXMuZHVyYXRpb25NaW51dGVzUGFydCgpIHwwO1xuICAgICAgICAgICAgLy8gVmFsdWUgY29tZXMgZnJvbSB0ZXh0XG4gICAgICAgICAgICBob3VycyA9IHBhcnNlSW50KGhvdXJzLCAxMCk7XG4gICAgICAgICAgICBpZiAoaXMubm90Lm51bWJlcihob3VycykpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZUR1cmF0aW9uTWludXRlcygoaG91cnN8MCkgKiA2MCArIG1pbnV0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xuICAgIHRoaXMuZHVyYXRpb25NaW51dGVzUGFydCA9IGtvLnB1cmVDb21wdXRlZCh7XG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZ1bGxNaW51dGVzID0gdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKCk7XG5cbiAgICAgICAgICAgIGlmIChpcy5ub3QubnVtYmVyKGZ1bGxNaW51dGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIChmdWxsTWludXRlc3wwKSAlIDYwO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24obWludXRlcykge1xuICAgICAgICAgICAgdmFyIGhvdXJzID0gdGhpcy5kdXJhdGlvbkhvdXJzUGFydCgpIHwwO1xuICAgICAgICAgICAgLy8gVmFsdWUgY29tZXMgZnJvbSB0ZXh0XG4gICAgICAgICAgICBtaW51dGVzID0gcGFyc2VJbnQobWludXRlcywgMTApO1xuICAgICAgICAgICAgaWYgKGlzLm5vdC5udW1iZXIobWludXRlcykpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlRHVyYXRpb25NaW51dGVzKG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZUR1cmF0aW9uTWludXRlcyhob3VycyAqIDYwICsgKG1pbnV0ZXN8MCkpO1xuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xuICAgIFxuICAgIFxuICAgIC8vLyBWaXN1YWwgcmVwcmVzZW50YXRpb24gb2Ygc2V2ZXJhbCBmaWVsZHNcbiAgICBcbiAgICB0aGlzLmR1cmF0aW9uVGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSB0aGlzLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKSB8fCAwO1xuICAgICAgICAvLyBUT0RPOiBsMTBuXG4gICAgICAgIHJldHVybiBtaW51dGVzID8gbnVtZXJhbChtaW51dGVzKS5mb3JtYXQoJzAsMCcpICsgJyBtaW51dGVzJyA6ICcnO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuc2Vzc2lvbnNBbmREdXJhdGlvbiA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlc3Npb25zID0gdGhpcy5udW1iZXJPZlNlc3Npb25zKCksXG4gICAgICAgICAgICBkdXIgPSB0aGlzLmR1cmF0aW9uVGV4dCgpO1xuICAgICAgICBpZiAoc2Vzc2lvbnMgPiAxKVxuICAgICAgICAgICAgLy8gVE9ETzogbDEwblxuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25zICsgJyBzZXNzaW9ucywgJyArIGR1cjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGR1cjtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuZGlzcGxheWVkUHJpY2UgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmljZSA9IHRoaXMucHJpY2UoKSxcbiAgICAgICAgICAgIHJhdGUgPSB0aGlzLnByaWNlUmF0ZSgpLFxuICAgICAgICAgICAgdW5pdCA9IHRoaXMucHJpY2VSYXRlVW5pdCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0gcHJpY2UgfHwgcmF0ZTtcbiAgICAgICAgLy8gRm9ybWF0dGluZ1xuICAgICAgICByZXN1bHQgPSBudW1lcmFsKHJlc3VsdCkuZm9ybWF0KCckMCwwJyk7XG4gICAgICAgIC8vIElmIGlzIG5vdCBwcmljZSBidXQgcmF0ZSwgYWRkIHVuaXRcbiAgICAgICAgaWYgKCFwcmljZSAmJiByYXRlICYmIHVuaXQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLycgKyB1bml0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2U7XG4iLCIvKipcbiAgICBTaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGUgbW9kZWwuXG4gICAgXG4gICAgSXRzICdzaW1wbGlmaWVkJyBiZWNhdXNlIGl0IHByb3ZpZGVzIGFuIEFQSVxuICAgIGZvciBzaW1wbGUgdGltZSByYW5nZSBwZXIgd2VlayBkYXksXG4gICAgYSBwYWlyIG9mIGZyb20tdG8gdGltZXMuXG4gICAgR29vZCBmb3IgY3VycmVudCBzaW1wbGUgVUkuXG4gICAgXG4gICAgVGhlIG9yaWdpbmFsIHdlZWtseSBzY2hlZHVsZSBkZWZpbmVzIHRoZSBzY2hlZHVsZVxuICAgIGluIDE1IG1pbnV0ZXMgc2xvdHMsIHNvIG11bHRpcGxlIHRpbWUgcmFuZ2VzIGNhblxuICAgIGV4aXN0cyBwZXIgd2VlayBkYXksIGp1c3QgbWFya2luZyBlYWNoIHNsb3RcbiAgICBhcyBhdmFpbGFibGUgb3IgdW5hdmFpbGFibGUuIFRoZSBBcHBNb2RlbFxuICAgIHdpbGwgZmlsbCB0aGlzIG1vZGVsIGluc3RhbmNlcyBwcm9wZXJseSBtYWtpbmdcbiAgICBhbnkgY29udmVyc2lvbiBmcm9tL3RvIHRoZSBzb3VyY2UgZGF0YS5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcbiAgICBXZWVrRGF5U2NoZWR1bGUgPSByZXF1aXJlKCcuL1dlZWtEYXlTY2hlZHVsZScpO1xuXG4vKipcbiAgICBJdCBhdHRlbXBzIHRvIGxvY2F0ZSBsb2NhbC9zeXN0ZW0gdGltZXpvbmUsXG4gICAgZ2V0dGluZyB0aGUgZmlyc3QgSUFOQSB0emlkIHRoYXQgbWF0Y2hlcyBcbiAgICBsb2NhbCBzZXR1cC5cbioqL1xuZnVuY3Rpb24gZGV0ZWN0TG9jYWxUaW1lem9uZSgpIHtcbiAgICB2YXIgeWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgd2ludGVyID0gbmV3IERhdGUoeWVhciwgMSwgMSksXG4gICAgICAgIHdpbk9mZiA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICBzdW1tZXIgPSBuZXcgRGF0ZSh5ZWFyLCA2LCAxKSxcbiAgICAgICAgc3VtT2ZmID0gc3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAgICAgIGZvdW5kID0gbnVsbDtcblxuICAgIG1vbWVudC50ei5uYW1lcygpLnNvbWUoZnVuY3Rpb24odHopIHtcbiAgICAgICAgdmFyIHpvbmUgPSBtb21lbnQudHouem9uZSh0eik7XG4gICAgICAgIGlmICh6b25lLm9mZnNldCh3aW50ZXIpID09PSB3aW5PZmYgJiZcbiAgICAgICAgICAgIHpvbmUub2Zmc2V0KHN1bW1lcikgPT09IHN1bU9mZikge1xuICAgICAgICAgICBmb3VuZCA9IHpvbmU7XG4gICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuICAgIE1haW4gbW9kZWwgZGVmaW5pbmcgdGhlIHdlZWsgc2NoZWR1bGVcbiAgICBwZXIgd2VlayBkYXRlLCBvciBqdXN0IHNldCBhbGwgZGF5cyB0aW1lc1xuICAgIGFzIGF2YWlsYWJsZSB3aXRoIGEgc2luZ2xlIGZsYWcuXG4qKi9cbmZ1bmN0aW9uIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZSh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHN1bmRheTogbmV3IFdlZWtEYXlTY2hlZHVsZSgpLFxuICAgICAgICBtb25kYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcbiAgICAgICAgdHVlc2RheTogbmV3IFdlZWtEYXlTY2hlZHVsZSgpLFxuICAgICAgICB3ZWRuZXNkYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcbiAgICAgICAgdGh1cnNkYXk6IG5ldyBXZWVrRGF5U2NoZWR1bGUoKSxcbiAgICAgICAgZnJpZGF5OiBuZXcgV2Vla0RheVNjaGVkdWxlKCksXG4gICAgICAgIHNhdHVyZGF5OiBuZXcgV2Vla0RheVNjaGVkdWxlKCksXG4gICAgICAgIGlzQWxsVGltZTogZmFsc2UsXG4gICAgICAgIHRpbWVab25lOiAnJ1xuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgLy8gSW5kZXggYWNjZXNzXG4gICAgdGhpcy53ZWVrRGF5cyA9IFtcbiAgICAgICAgdGhpcy5zdW5kYXksXG4gICAgICAgIHRoaXMubW9uZGF5LFxuICAgICAgICB0aGlzLnR1ZXNkYXksXG4gICAgICAgIHRoaXMud2VkbmVzZGF5LFxuICAgICAgICB0aGlzLnRodXJzZGF5LFxuICAgICAgICB0aGlzLmZyaWRheSxcbiAgICAgICAgdGhpcy5zYXR1cmRheVxuICAgIF07XG4gICAgXG4gICAgdGhpcy50aW1lWm9uZURpc3BsYXlOYW1lID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0emlkID0gdGhpcy50aW1lWm9uZSgpLFxuICAgICAgICAgICAgdHogPSBtb21lbnQudHoodHppZCksXG4gICAgICAgICAgICBuYW1lID0gdHoudHooKTtcbiAgICAgICAgXG4gICAgICAgIC8vICFtb21lbnQudHouem9uZUV4aXN0cywganVzdCBjaGVjayB0aGUgbmFtZSBpcyBlbm91Z2hcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWx0eiA9IGRldGVjdExvY2FsVGltZXpvbmUoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbHR6KVxuICAgICAgICAgICAgICAgIHR6ID0gbW9tZW50LnR6KGxvY2FsdHoubmFtZSk7XG4gICAgICAgICAgICBpZiAodHopXG4gICAgICAgICAgICAgICAgbmFtZSA9IHR6LnR6KCk7XG4gICAgICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVab25lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgIHJldHVybiBuYW1lOyAvLyArICcgKCcgKyB0ei56b25lQWJicigpICsgJyknO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxpZmllZFdlZWtseVNjaGVkdWxlO1xuIiwiLyoqIFRocmVhZCBtb2RlbC5cblxuICAgIERlc2NyaWJlcyBhIHRocmVhZCBvZiBtZXNzYWdlcy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIE1lc3NhZ2UgPSByZXF1aXJlKCcuL01lc3NhZ2UnKTtcblxuZnVuY3Rpb24gVGhyZWFkKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdGhyZWFkSUQ6IDAsXG4gICAgICAgIFxuICAgICAgICBjbGllbnRVc2VySUQ6IG51bGwsXG4gICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxVc2VySUQ6IG51bGwsXG4gICAgICAgIGpvYlRpdGxlSUQ6IG51bGwsXG4gICAgICAgIHN0YXR1c0lEOiBudWxsLFxuICAgICAgICBzdWJqZWN0OiBudWxsLFxuICAgICAgICBcbiAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgIGlzQXJyYXk6IHRydWUsXG4gICAgICAgICAgICBNb2RlbDogTWVzc2FnZVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsICAgICAgICBcbiAgICB9LCB2YWx1ZXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRocmVhZDtcbiIsIi8qKiBVcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeSBtb2RlbCAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcbiAgICBCb29raW5nU3VtbWFyeSA9IHJlcXVpcmUoJy4vQm9va2luZ1N1bW1hcnknKTtcblxuZnVuY3Rpb24gVXBjb21pbmdCb29raW5nc1N1bW1hcnkoKSB7XG5cbiAgICBNb2RlbCh0aGlzKTtcbiAgICBcbiAgICAvLyBUT0RPOiBkZWZpbmUgdG9kYXksIHRvbW9ycm93IGFuZCBuZXh0V2VlayBhc1xuICAgIC8vIHByb3BlcnRpZXMgd2l0aCBkZWZhdWx0IE1vZGVsP1xuICAgIC8vIFJldmlldyBob3cgdXBkYXRlIGhhcHBlbnMgb24gaG9tZS9kYXNoYm9hcmQsIGl0IGNhbiBoZWxwc1xuICAgIC8vIHRvIHNpbXBsaWZ5IHRoYXRcblxuICAgIHRoaXMudG9kYXkgPSBuZXcgQm9va2luZ1N1bW1hcnkoe1xuICAgICAgICBjb25jZXB0OiAnbW9yZSB0b2RheScsXG4gICAgICAgIHRpbWVGb3JtYXQ6ICcgW2VuZGluZyBAXSBoOm1tYSdcbiAgICB9KTtcbiAgICB0aGlzLnRvbW9ycm93ID0gbmV3IEJvb2tpbmdTdW1tYXJ5KHtcbiAgICAgICAgY29uY2VwdDogJ3RvbW9ycm93JyxcbiAgICAgICAgdGltZUZvcm1hdDogJyBbc3RhcnRpbmcgQF0gaDptbWEnXG4gICAgfSk7XG4gICAgdGhpcy5uZXh0V2VlayA9IG5ldyBCb29raW5nU3VtbWFyeSh7XG4gICAgICAgIGNvbmNlcHQ6ICduZXh0IHdlZWsnLFxuICAgICAgICB0aW1lRm9ybWF0OiBudWxsXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5pdGVtcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIFxuICAgICAgICAvL2lmICh0aGlzLnRvZGF5LnF1YW50aXR5KCkpXG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy50b2RheSk7XG4gICAgICAgIC8vaWYgKHRoaXMudG9tb3Jyb3cucXVhbnRpdHkoKSlcbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLnRvbW9ycm93KTtcbiAgICAgICAgLy9pZiAodGhpcy5uZXh0V2Vlay5xdWFudGl0eSgpKVxuICAgICAgICBpdGVtcy5wdXNoKHRoaXMubmV4dFdlZWspO1xuXG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCB0aGlzKTtcbiAgICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVcGNvbWluZ0Jvb2tpbmdzU3VtbWFyeTtcbiIsIi8qKiBVc2VyIG1vZGVsICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG4vLyBFbnVtIFVzZXJUeXBlXG52YXIgVXNlclR5cGUgPSB7XG4gICAgbm9uZTogMCxcbiAgICBhbm9ueW1vdXM6IDEsXG4gICAgY2xpZW50OiAyLFxuICAgIHNlcnZpY2VQcm9mZXNzaW9uYWw6IDQsXG4gICAgLy8gQWxsIE1lbWJlcnMgKG1lbWJlci1vbmx5OjgpIGFyZSBzZXJ2aWNlIHByb2Zlc3Npb25hbHMgdG9vOiA0KzhcbiAgICBtZW1iZXI6IDEyLFxuICAgIGFkbWluOiAxNixcbiAgICAvLyBBbGwgdXNlcnMgZXhjZXB0IGFub255bW91cyBhbmQgc3lzdGVtOlxuICAgIGxvZ2dlZFVzZXI6IDMwLFxuICAgIC8vIEFsbCB1c2VycyBleGNlcHQgc3lzdGVtLFxuICAgIHVzZXI6IDMxLFxuICAgIHN5c3RlbTogMzJcbn07XG5cbmZ1bmN0aW9uIFVzZXIodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdXNlcklEOiAwLFxuICAgICAgICBlbWFpbDogJycsXG4gICAgICAgIFxuICAgICAgICBmaXJzdE5hbWU6ICcnLFxuICAgICAgICBsYXN0TmFtZTogJycsXG4gICAgICAgIHNlY29uZExhc3ROYW1lOiAnJyxcbiAgICAgICAgYnVzaW5lc3NOYW1lOiAnJyxcbiAgICAgICAgXG4gICAgICAgIGFsdGVybmF0aXZlRW1haWw6ICcnLFxuICAgICAgICBwaG9uZTogJycsXG4gICAgICAgIGNhblJlY2VpdmVTbXM6ICcnLFxuICAgICAgICBiaXJ0aE1vbnRoRGF5OiBudWxsLFxuICAgICAgICBiaXJ0aE1vbnRoOiBudWxsLFxuICAgICAgICBcbiAgICAgICAgaXNTZXJ2aWNlUHJvZmVzc2lvbmFsOiBmYWxzZSxcbiAgICAgICAgaXNDbGllbnQ6IGZhbHNlLFxuICAgICAgICBpc01lbWJlcjogZmFsc2UsXG4gICAgICAgIGlzQWRtaW46IGZhbHNlLFxuICAgICAgICBcbiAgICAgICAgcGhvdG9Vcmw6IG51bGwsXG5cbiAgICAgICAgb25ib2FyZGluZ1N0ZXA6IG51bGwsXG4gICAgICAgIGFjY291bnRTdGF0dXNJRDogMCxcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXG4gICAgfSwgdmFsdWVzKTtcblxuICAgIHRoaXMuZnVsbE5hbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuYW1lUGFydHMgPSBbdGhpcy5maXJzdE5hbWUoKV07XG4gICAgICAgIGlmICh0aGlzLmxhc3ROYW1lKCkpXG4gICAgICAgICAgICBuYW1lUGFydHMucHVzaCh0aGlzLmxhc3ROYW1lKCkpO1xuICAgICAgICBpZiAodGhpcy5zZWNvbmRMYXN0TmFtZSgpKVxuICAgICAgICAgICAgbmFtZVBhcnRzLnB1c2godGhpcy5zZWNvbmRMYXN0TmFtZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmFtZVBhcnRzLmpvaW4oJyAnKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmJpcnRoRGF5ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5iaXJ0aE1vbnRoRGF5KCkgJiZcbiAgICAgICAgICAgIHRoaXMuYmlydGhNb250aCgpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRPRE8gaTEwblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmlydGhNb250aCgpICsgJy8nICsgdGhpcy5iaXJ0aE1vbnRoRGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMudXNlclR5cGUgPSBrby5wdXJlQ29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5pc0NsaWVudCgpLFxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmlzU2VydmljZVByb2Zlc3Npb25hbCgpLFxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmlzQWRtaW4oKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHVzZXJUeXBlID0gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbm9ueW1vdXMoKSlcbiAgICAgICAgICAgICAgICB1c2VyVHlwZSA9IHVzZXJUeXBlIHwgVXNlclR5cGUuYW5vbnltb3VzO1xuICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgdXNlclR5cGUgPSB1c2VyVHlwZSB8IFVzZXJUeXBlLmNsaWVudDtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIHVzZXJUeXBlID0gdXNlclR5cGUgfCBVc2VyVHlwZS5zZXJ2aWNlUHJvZmVzc2lvbmFsO1xuICAgICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICAgICAgdXNlclR5cGUgPSB1c2VyVHlwZSB8IFVzZXJUeXBlLmFkbWluO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdXNlclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qIE5PVEU6IE5vdCByZXF1aXJlZCBmb3Igbm93OlxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odikge1xuICAgICAgICB9LCovXG4gICAgICAgIG93bmVyOiB0aGlzXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5pc0Fub255bW91cyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy51c2VySUQoKSA8IDE7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLyoqXG4gICAgICAgIEl0IG1hdGNoZXMgYSBVc2VyVHlwZSBmcm9tIHRoZSBlbnVtZXJhdGlvbj9cbiAgICAqKi9cbiAgICB0aGlzLmlzVXNlclR5cGUgPSBmdW5jdGlvbiBpc1VzZXJUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVzZXJUeXBlKCkgJiB0eXBlKTtcbiAgICB9LmJpbmQodGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlcjtcblxuVXNlci5Vc2VyVHlwZSA9IFVzZXJUeXBlO1xuXG4vKiBDcmVhdGludCBhbiBhbm9ueW1vdXMgdXNlciB3aXRoIHNvbWUgcHJlc3NldHMgKi9cblVzZXIubmV3QW5vbnltb3VzID0gZnVuY3Rpb24gbmV3QW5vbnltb3VzKCkge1xuICAgIHJldHVybiBuZXcgVXNlcih7XG4gICAgICAgIHVzZXJJRDogMCxcbiAgICAgICAgZW1haWw6ICcnLFxuICAgICAgICBmaXJzdE5hbWU6ICcnLFxuICAgICAgICBvbmJvYXJkaW5nU3RlcDogbnVsbFxuICAgIH0pO1xufTtcbiIsIi8qKlxuICAgIFJlcHJlc2VudHMgYW4gVXNlciBFZHVjYXRpb24gcmVjb3JkXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBVc2VyRWR1Y2F0aW9uKHZhbHVlcykge1xuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGVkdWNhdGlvbklEOiAwLFxuICAgICAgICB1c2VySUQ6IDAsXG4gICAgICAgIGluc3RpdHV0aW9uTmFtZTogJycsXG4gICAgICAgIGRlZ3JlZUNlcnRpZmljYXRlOiAnJyxcbiAgICAgICAgZmllbGRPZlN0dWR5OiAnJyxcbiAgICAgICAgZnJvbVllYXJBdHRlbmRlZDogbnVsbCxcbiAgICAgICAgdG9ZZWFyQXR0ZW5kZWQ6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJFZHVjYXRpb247XG4iLCIvKipcbiAgICBVc2VySm9iVGl0bGUgbW9kZWwsIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGFuIHVzZXIgYW5kIGFcbiAgICBqb2IgdGl0bGUgYW5kIHRoZSBtYWluIGRhdGEgYXR0YWNoZWQgdG8gdGhhdCByZWxhdGlvbi5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbmZ1bmN0aW9uIFVzZXJKb2JUaXRsZSh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICB1c2VySUQ6IDAsXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXG4gICAgICAgIGludHJvOiBudWxsLFxuICAgICAgICBzdGF0dXNJRDogMCxcbiAgICAgICAgY2FuY2VsbGF0aW9uUG9saWN5SUQ6IDAsXG4gICAgICAgIGluc3RhbnRCb29raW5nOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlZERhdGU6IG51bGwsXG4gICAgICAgIHVwZGF0ZWREYXRlOiBudWxsXG4gICAgfSwgdmFsdWVzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZklEKFsndXNlcklEJywgJ2pvYlRpdGxlSUQnXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlckpvYlRpdGxlO1xuXG4vLyBQdWJsaWMgRW51bWVyYXRpb24gZm9yIHRoZSAnc3RhdHVzSUQnIHByb3BlcnR5OlxuVXNlckpvYlRpdGxlLnN0YXR1cyA9IHtcbiAgICAvLyBQcm9maWxlIGlzIGNvbXBsZXRlIGFuZCBwdWJsaWNcbiAgICBvbjogMSxcbiAgICAvLyBQcm9maWxlIGNhbm5vdCBiZSBPbi9wdWJsaWMgYmVjYXVzZSBpcyBpbmNvbXBsZXRlOlxuICAgIGluY29tcGxldGU6IDIsXG4gICAgLy8gVXNlciBjaG9vc2UgdG8gZGlzYWJsZSAoaXQncyBzdXBwb3NlZCB0byBiZSBjb21wbGV0ZSwgYnV0IGRpc2FibGVkIGJ5IHVzZXIgYW5kIHdpbGwgZG91YmxlIGNoZWNrIGJlZm9yZSBhY3RpdmF0aW9uKVxuICAgIG9mZjogM1xufTtcbiIsIi8qKiBVc2VySm9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlcyBtb2RlbC5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuLy8gTmVlZGVkIHV0aWxpdHkgdG8gZXh0ZW5kIHdpdGggbWV0aG9kcyB0aGUgb2JzZXJ2YWJsZVxuLy8gcHJvcGVydGllcyB0aGF0IGhvbGRzIGEgcGxhaW4gb2JqZWN0IGFzIGRpY3Rpb25hcnlcbi8vIG9mIGF0dHJpYnV0ZXMgcGVyIGNhdGVnb3J5LlxuLy8gSXQncyB1c2VmdWwgZm9yIGF0dElEcyBhbmQgYXR0TmFtZXMuXG5mdW5jdGlvbiBleHRlbmRWYWx1ZXNCeUNhdGVnb3J5KG9icykge1xuICAgIC8vIEFsaWFzIHRvIG5vdGlmeSBjaGFuZ2VzLCBpZiBjaGFuZ2UgYSBzb3VyY2UgcGxhaW4gdmFsdWUgaXMgbmVlZGVkLCB0aGlzIG11c3RcbiAgICAvLyBiZSBtYW51YWxseSBjYWxsZWQgdG8gZW5zdXJlIHVwZGF0ZXMuXG4gICAgb2JzLm5vdGlmeUNoYW5nZXMgPSBvYnMudmFsdWVIYXNNdXRhdGVkO1xuXG4gICAgb2JzLnNlcnZpY2VBdHRyaWJ1dGVDYXRlZ29yaWVzSURzID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JzKCkgfHwge30pLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAoa2V5IHwwKSA9PT0gMDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSW5kZXhlZCBsaXN0IG9mIG9ic2VydmVycyB0byBkZXRlY3QgY2hhbmdlcyBpbiBjYXRlZ29yaWVzIHZhbHVlcywgYWxsb3dpbmdcbiAgICAvLyB0aGUgY2F0LWF0dHMgb2JzZXJ2ZXJzIHRvIHJlY29tcHV0ZSBvbmx5IG9uIGNoYW5nZXMgb24gaXRzIGNhdGVnb3JpZXMsIGJlaW5nIG1vcmVcbiAgICAvLyBvcHRpbWFsLlxuICAgIHZhciBjYXRzT2JzID0ge307XG5cbiAgICAvLyBHZXRzIGFuIG9ic2VydmFibGUgZm9yIGFycmF5IHRoYXQga2VlcHMgaW4gc3luYyB3aXRoIHNvdXJjZSBjaGFuZ2VzXG4gICAgLy8gRE8gTk9UIFBVU0gvUkVNT1ZFIGRhdGEgdG8gdGhlIHJlc3VsdGluZyBhcnJheSwgdXNlIHRoZSBvYnMucHVzaCBhbmQgb2JzLnJlbW92ZSBtZXRob2RzIGZvciBkYXRhIGNoYW5nZXNcbiAgICBvYnMuZ2V0U2VydmljZUNhdGVnb3J5QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGNhdElEKSB7XG4gICAgICAgIHZhciBjYXRPYnMgPSBjYXRzT2JzW2NhdElEXSA9IGNhdHNPYnNbY2F0SURdIHx8IGtvLm9ic2VydmFibGUoe30pO1xuICAgICAgICByZXR1cm4ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZWNvbXB1dGUgd2hlbiBzb3VyY2UgdmFsdWUgY2hhbmdlZCBmb3IgdGhlIGNhdGVvZ3J5XG4gICAgICAgICAgICB2YXIgYmFzZSA9IG9icy5wZWVrKCk7XG4gICAgICAgICAgICAvLyBhY2Nlc3Mgbm90aWZpZXIgb2JzZXJ2YWJsZSBzbyB0aGlzIHJlY29tcHV0ZXMgb24gY2hhbmdlcyBkZXRlY3RlZDpcbiAgICAgICAgICAgIGNhdE9icygpO1xuICAgICAgICAgICAgLy8gR2V0IGNhdGVnb3J5IGRhdGE6XG4gICAgICAgICAgICByZXR1cm4gYmFzZSAmJiBiYXNlW2NhdElEXSB8fCBbXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBPbiBhIHJlYWwgYnVsayBjaGFuZ2UsIHRyaWdnZXIgYWwgY2F0cyBvYnNlcnZlcnNcbiAgICB2YXIgcHJldlZhbHVlID0gb2JzKCk7XG4gICAgb2JzLnN1YnNjcmliZShmdW5jdGlvbih2KSB7XG4gICAgICAgIC8vIHJlYWxseSBjaGFuZ2VkP1xuICAgICAgICBpZiAodiAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY2F0c09icykuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IGNoYW5nZXNcbiAgICAgICAgICAgICAgICBhLnZhbHVlSGFzTXV0YXRlZCAmJiBhLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG9icy5wdXNoID0gZnVuY3Rpb24oY2F0SUQsIGF0dElEKSB7XG4gICAgICAgIHZhciB2ID0gb2JzKCk7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgLy8gTm8gdmFsdWUgYXQgYWxsISBDcmVhdGUgb2JqZWN0LCBhbmQgZmlyc3QgY2F0ZWdvcnkgd2l0aCB0aGlzIGZpcnN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgdiA9IHt9O1xuICAgICAgICAgICAgdltjYXRJRF0gPSBbYXR0SURdO1xuICAgICAgICAgICAgb2JzKHYpO1xuICAgICAgICAgICAgaWYgKGNhdHNPYnNbY2F0SURdKSBjYXRzT2JzW2NhdElEXS52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYXQgPSB2W2NhdElEXSB8fCAodltjYXRJRF0gPSBbXSk7XG4gICAgICAgICAgICAvLyBEb3VibGUgY2hlY2sgaXQgZG9lcyBub3QgZXhpc3RzIGFscmVhZHlcbiAgICAgICAgICAgIGlmIChjYXQuaW5kZXhPZihhdHRJRCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2F0LnB1c2goYXR0SUQpO1xuICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgb24gYWxsIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgb2JzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIG9uIHRoaXMgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBpZiAoY2F0c09ic1tjYXRJRF0pIGNhdHNPYnNbY2F0SURdLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG9icy5yZW1vdmUgPSBmdW5jdGlvbihjYXRJRCwgYXR0SUQpIHtcbiAgICAgICAgdmFyIHYgPSBvYnMoKSxcbiAgICAgICAgICAgIGNhdCA9IHYgJiYgdltjYXRJRF07XG4gICAgICAgIGlmIChjYXQpIHtcbiAgICAgICAgICAgIHZhciBpID0gY2F0LmluZGV4T2YoYXR0SUQpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGNhdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgb2JzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2F0c09ic1tjYXRJRF0pIGNhdHNPYnNbY2F0SURdLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gUHVibGljIE1vZGVsXG5mdW5jdGlvbiBVc2VySm9iVGl0bGVTZXJ2aWNlQXR0cmlidXRlcyh2YWx1ZXMpIHtcbiAgICBcbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIHVzZXJJRDogMCxcbiAgICAgICAgam9iVGl0bGVJRDogMCxcbiAgICAgICAgc2VydmljZUF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICBwcm9wb3NlZFNlcnZpY2VBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgZXhwZXJpZW5jZUxldmVsSUQ6IGZhbHNlLFxuICAgICAgICBsYW5ndWFnZUlEOiAwLFxuICAgICAgICBjb3VudHJ5SUQ6IDBcbiAgICAgICAgLy9jcmVhdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgLy91cGRhdGVkRGF0ZTogbnVsbFxuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgZXh0ZW5kVmFsdWVzQnlDYXRlZ29yeSh0aGlzLnNlcnZpY2VBdHRyaWJ1dGVzKTtcbiAgICBleHRlbmRWYWx1ZXNCeUNhdGVnb3J5KHRoaXMucHJvcG9zZWRTZXJ2aWNlQXR0cmlidXRlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlckpvYlRpdGxlU2VydmljZUF0dHJpYnV0ZXM7XG4iLCIvKiogVXNlckxpY2Vuc2VDZXJ0aWZpY2F0aW9uIG1vZGVsICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5mdW5jdGlvbiBVc2VyTGljZW5zZUNlcnRpZmljYXRpb24odmFsdWVzKSB7XG5cbiAgICBNb2RlbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICB1c2VySUQ6IDAsXG4gICAgICAgIGpvYlRpdGxlSUQ6IDAsXG4gICAgICAgIHN0YXR1c0lEOiAwLFxuICAgICAgICBsaWNlbnNlQ2VydGlmaWNhdGlvbklEOiAwLFxuICAgICAgICBsaWNlbnNlQ2VydGlmaWNhdGlvblVybDogJycsXG4gICAgICAgIGxpY2Vuc2VDZXJ0aWZpY2F0aW9uTnVtYmVyOiAwLFxuICAgICAgICBsaWNlbnNlQ2VydGlmaWNhdGlvblN0YXR1czogMCxcbiAgICAgICAgZXhwaXJhdGlvbkRhdGU6IG51bGwsXG4gICAgICAgIGlzc3VlRGF0ZTogbnVsbCxcbiAgICAgICAgY291bnRyeUlEOiAwLFxuICAgICAgICBzdGF0ZVByb3ZpbmNlSUQ6IDAsXG4gICAgICAgIGNvdW50eUlEOiAwLFxuICAgICAgICBjaXR5OiAnJyxcbiAgICAgICAgZmlyc3ROYW1lOiBudWxsLFxuICAgICAgICBsYXN0TmFtZTogbnVsbCxcbiAgICAgICAgbWlkZGxlSW5pdGlhbDogbnVsbCxcbiAgICAgICAgc2Vjb25kTGFzdE5hbWU6IG51bGwsXG4gICAgICAgIGJ1c2luZXNzTmFtZTogbnVsbCxcbiAgICAgICAgYWN0aW9uczogbnVsbCxcbiAgICAgICAgY29tbWVudHM6IG51bGwsXG4gICAgICAgIHZlcmlmaWVkQnk6IG51bGwsXG4gICAgICAgIGxhc3RWZXJpZmllZERhdGU6IG51bGwsXG4gICAgICAgIGNyZWF0ZWREYXRlOiBudWxsLCAvLyBBdXRvZmlsbGVkIGJ5IHNlcnZlclxuICAgICAgICB1cGRhdGVkRGF0ZTogbnVsbCwgLy8gQXV0b2ZpbGxlZCBieSBzZXJ2ZXJcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmSUQoWyd1c2VySUQnLCAnam9iVGl0bGVJRCcsICdsaWNlbnNlQ2VydGlmaWNhdGlvbklEJ10pO1xuICAgIFxuICAgIHRoaXMuY291bnR5TmFtZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVE9ETyBJbXBsZW1lbnQgbG9vay11cCBvZiBjb3VudGllcywgYSBoYXJkbHkgY2FjaGVkIHZlcnNpb24gbXVzdCBleGlzdHMgZXZlclxuICAgICAgICByZXR1cm4gJ0FsYW1lZGEnO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuc3RhdGVQcm92aW5jZU5hbWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE8gSW1wbGVtZW50IGxvb2stdXAsIGEgaGFyZGx5IGNhY2hlZCB2ZXJzaW9uIG11c3QgZXhpc3RzIGV2ZXJcbiAgICAgICAgcmV0dXJuICdDYWxpZm9ybmlhJztcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLnN0YXRlUHJvdmluY2VDb2RlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPIEltcGxlbWVudCBsb29rLXVwLCBhIGhhcmRseSBjYWNoZWQgdmVyc2lvbiBtdXN0IGV4aXN0cyBldmVyXG4gICAgICAgIHJldHVybiAnQ0EnO1xuICAgIH0sIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJMaWNlbnNlQ2VydGlmaWNhdGlvbjtcbiIsIi8qKlxuICAgIFVzZXJWZXJpZmljYXRpb24gbW9kZWxcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIFZlcmlmaWNhdGlvbiA9IHJlcXVpcmUoJy4vVmVyaWZpY2F0aW9uJyk7XG5cbmZ1bmN0aW9uIFVzZXJWZXJpZmljYXRpb24odmFsdWVzKSB7XG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgdXNlcklEOiAwLFxuICAgICAgICB2ZXJpZmljYXRpb25JRDogMCxcbiAgICAgICAgam9iVGl0bGVJRDogMCxcbiAgICAgICAgbGFzdFZlcmlmaWVkRGF0ZTogbnVsbCxcbiAgICAgICAgc3RhdHVzSUQ6IDAsXG4gICAgICAgIHZlcmlmaWNhdGlvbjoge1xuICAgICAgICAgICAgTW9kZWw6IFZlcmlmaWNhdGlvblxuICAgICAgICB9XG4gICAgfSwgdmFsdWVzKTtcbiAgICBcbiAgICAvLyBMMThOXG4gICAgdmFyIHN0YXR1c1RleHRzZW5VUyA9IHtcbiAgICAgICAgJ3ZlcmlmaWNhdGlvbi5zdGF0dXMuY29uZmlybWVkJzogJ0NvbmZpcm1lZCcsXG4gICAgICAgICd2ZXJpZmljYXRpb24uc3RhdHVzLnBlbmRpbmcnOiAnUGVuZGluZycsXG4gICAgICAgICd2ZXJpZmljYXRpb24uc3RhdHVzLnJldm9rZWQnOiAnUmV2b2tlZCcsXG4gICAgICAgICd2ZXJpZmljYXRpb24uc3RhdHVzLm9ic29sZXRlJzogJ09ic29sZXRlJ1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXR1c1RleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGF0dXNOYW1lID0gVmVyaWZpY2F0aW9uLmdldFN0YXR1c05hbWUodGhpcy5zdGF0dXNJRCgpKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1c1RleHRzZW5VU1sndmVyaWZpY2F0aW9uLnN0YXR1cy4nICsgc3RhdHVzTmFtZV07XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgICAgQ2hlY2sgaWYgdmVyaWZpY2F0aW9uIGhhcyBhIGdpdmVuIHN0YXR1cyBieSBuYW1lXG4gICAgKiovXG4gICAgdGhpcy5pc1N0YXR1cyA9IGZ1bmN0aW9uIChzdGF0dXNOYW1lKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuc3RhdHVzSUQoKTtcbiAgICAgICAgcmV0dXJuIFZlcmlmaWNhdGlvbi5zdGF0dXNbc3RhdHVzTmFtZV0gPT09IGlkO1xuICAgIH0uYmluZCh0aGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyVmVyaWZpY2F0aW9uO1xuIiwiLyoqXG4gICAgVmVyaWZpY2F0aW9uIE1vZGVsXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5mdW5jdGlvbiBWZXJpZmljYXRpb24odmFsdWVzKSB7XG4gICAgTW9kZWwodGhpcyk7XG5cbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICB2ZXJpZmljYXRpb25JRDogMCxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICBpY29uOiBudWxsLFxuICAgICAgICBzdW1tYXJ5R3JvdXA6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xufVxuXG5WZXJpZmljYXRpb24uc3RhdHVzID0ge1xuICAgIGNvbmZpcm1lZDogMSxcbiAgICBwZW5kaW5nOiAyLFxuICAgIHJldm9rZWQ6IDMsXG4gICAgb2Jzb2xldGU6IDRcbn07XG5cbi8vIFRPRE86IE1heWJlIGFzIGdlbmVyaWMgdXRpbGl0eT9cbmZ1bmN0aW9uIGVudW1HZXROYW1lKHZhbHVlLCBlbnVtTGlzdCkge1xuICAgIHZhciBmb3VuZCA9IG51bGw7XG4gICAgT2JqZWN0LmtleXMoZW51bUxpc3QpLnNvbWUoZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoZW51bUxpc3Rba10gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGs7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuVmVyaWZpY2F0aW9uLmdldFN0YXR1c05hbWUgPSBmdW5jdGlvbiBnZXRTdGF0dXNOYW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1HZXROYW1lKHZhbHVlLCBWZXJpZmljYXRpb24uc3RhdHVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVyaWZpY2F0aW9uO1xuIiwiLyoqXG4gICAgRW51bWVyYXRpb24gb2YgcG9zc2libGUgdmFsdWVzIGZvciBWb2NFbGVtZW50SURzLCBcbiAgICB1c2VkIHRvIGlkZW50aWZ5IHNlY3Rpb25zL2NvbXBvbmVudHMgd2hlbiBzZW5kaW5nIEZlZWRiYWNrLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdlbmVyYWw6IDAsXG4gICAgbnBzOiAxLFxuICAgIHNpZ251cDogMixcbiAgICBjYWxlbmRhcjogMyxcbiAgICBpbmJveDogNCxcbiAgICBzY2hlZHVsaW5nOiA1LFxuICAgIGNtczogNixcbiAgICBwYXltZW50czogNyxcbiAgICBwZXJmb3JtYW5jZTogOCxcbiAgICBtYXJrZXRwbGFjZVByb2ZpbGU6IDksXG4gICAgbW9iaWxlRnJpZW5kbHk6IDEwLCAvLyBlYXN5IG9mIHVzaW5nIG1vYmlsZS90YWJsZXQgYXBwL3dlYlxuICAgIGRlc2t0b3BGcmllbmRseTogMTEsIC8vIGVhc3kgb2YgdXNpbmcgZGVza3RvcCB3ZWJzaXRlXG4gICAgY29vcEJlbmVmaXRzOiAxMixcbiAgICBjb29wRmVlOiAxMyxcbiAgICBzZW5zZU9mQ29tbXVuaXR5OiAxNCxcbiAgICBjbGllbnRTZXJ2aWNlQWdlbnRzOiAxNSxcbiAgICBoZWxwUGFnZXM6IDE2XG59O1xuIiwiLyoqXG4gICAgU3VibW9kZWwgdGhhdCBpcyB1c2VkIG9uIHRoZSBTaW1wbGlmaWVkV2Vla2x5U2NoZWR1bGVcbiAgICBkZWZpbmluZyBhIHNpbmdsZSB3ZWVrIGRheSBhdmFpbGFiaWxpdHkgcmFuZ2UuXG4gICAgQSBmdWxsIGRheSBtdXN0IGhhdmUgdmFsdWVzIGZyb206MCB0bzoxNDQwLCBuZXZlclxuICAgIGJvdGggYXMgemVybyBiZWNhdXNlIHRoYXRzIGNvbnNpZGVyZWQgYXMgbm90IGF2YWlsYWJsZSxcbiAgICBzbyBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBpc0FsbERheSBwcm9wZXJ0eS5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5mdW5jdGlvbiBXZWVrRGF5U2NoZWR1bGUodmFsdWVzKSB7XG5cbiAgICBNb2RlbCh0aGlzKTtcblxuICAgIC8vIE5PVEU6IGZyb20tdG8gcHJvcGVyaWVzIGFzIG51bWJlcnNcbiAgICAvLyBmb3IgdGhlIG1pbnV0ZSBvZiB0aGUgZGF5LCBmcm9tIDAgKDAwOjAwKSB0byAxNDM5ICgyMzo1OSlcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogMFxuICAgIH0sIHZhbHVlcyk7XG4gICAgXG4gICAgLyoqXG4gICAgICAgIEl0IGFsbG93cyB0byBrbm93IGlmIHRoaXMgd2VlayBkYXkgaXMgXG4gICAgICAgIGVuYWJsZWQgZm9yIHdlZWtseSBzY2hlZHVsZSwganVzdCBpdFxuICAgICAgICBoYXMgZnJvbS10byB0aW1lcy5cbiAgICAgICAgSXQgYWxsb3dzIHRvIGJlIHNldCBhcyB0cnVlIHB1dHRpbmdcbiAgICAgICAgYSBkZWZhdWx0IHJhbmdlICg5YS01cCkgb3IgZmFsc2UgXG4gICAgICAgIHNldHRpbmcgYm90aCBhcyAwcC5cbiAgICAgICAgXG4gICAgICAgIFNpbmNlIG9uIHdyaXRlIHR3byBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgbW9kaWZpZWQsIGFuZFxuICAgICAgICBib3RoIGFyZSB1c2VkIGluIHRoZSByZWFkLCBhIHNpbmdsZSBjaGFuZ2UgdG8gdGhlIFxuICAgICAgICB2YWx1ZSB3aWxsIHRyaWdnZXIgdHdvIG5vdGlmaWNhdGlvbnM7IHRvIGF2b2lkIHRoYXQsXG4gICAgICAgIHRoZSBvYnNlcnZhYmxlIGlzIHJhdGUgbGltaXRlZCB3aXRoIGFuIGlubWVkaWF0ZSB2YWx1ZSxcbiAgICAgICAgc29uIG9ubHkgb25lIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZC5cbiAgICAqKi9cbiAgICB0aGlzLmlzRW5hYmxlZCA9IGtvLmNvbXB1dGVkKHtcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHR5cGVvZih0aGlzLmZyb20oKSkgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mKHRoaXMudG8oKSkgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tKCkgPCB0aGlzLnRvKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJhbmdlIDlhIC0gNXBcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21Ib3VyKDkpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9Ib3VyKDE3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudG9Ib3VyKDApO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3duZXI6IHRoaXNcbiAgICB9KS5leHRlbmQoeyByYXRlTGltaXQ6IDAgfSk7XG4gICAgXG4gICAgdGhpcy5pc0FsbERheSA9IGtvLmNvbXB1dGVkKHtcbiAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIChcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20oKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMudG8oKSA9PT0gMTQ0MFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKC8qdmFsKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSgwKTtcbiAgICAgICAgICAgIHRoaXMudG8oMTQ0MCk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bmVyOiB0aGlzXG4gICAgfSkuZXh0ZW5kKHsgcmF0ZUxpbWl0OiAwIH0pO1xuICAgIFxuICAgIC8vIEFkZGl0aW9uYWwgaW50ZXJmYWNlcyB0byBnZXQvc2V0IHRoZSBmcm9tL3RvIHRpbWVzXG4gICAgLy8gYnkgdXNpbmcgYSBkaWZmZXJlbnQgZGF0YSB1bml0IG9yIGZvcm1hdC5cbiAgICBcbiAgICAvLyBJbnRlZ2VyLCByb3VuZGVkLXVwLCBudW1iZXIgb2YgaG91cnNcbiAgICB0aGlzLmZyb21Ib3VyID0ga28uY29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZnJvbSgpIC8gNjApO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24oaG91cnMpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSgoaG91cnMgKiA2MCkgfDApO1xuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xuICAgIHRoaXMudG9Ib3VyID0ga28uY29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy50bygpIC8gNjApO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24oaG91cnMpIHtcbiAgICAgICAgICAgIHRoaXMudG8oKGhvdXJzICogNjApIHwwKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duZXI6IHRoaXNcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTdHJpbmcsIHRpbWUgZm9ybWF0ICgnaGg6bW0nKVxuICAgIHRoaXMuZnJvbVRpbWUgPSBrby5jb21wdXRlZCh7XG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbnV0ZXNUb1RpbWVTdHJpbmcodGhpcy5mcm9tKCkgfDApO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odGltZSkge1xuICAgICAgICAgICAgdGhpcy5mcm9tKHRpbWVTdHJpbmdUb01pbnV0ZXModGltZSkpO1xuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xuICAgIHRoaXMudG9UaW1lID0ga28uY29tcHV0ZWQoe1xuICAgICAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW51dGVzVG9UaW1lU3RyaW5nKHRoaXMudG8oKSB8MCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLnRvKHRpbWVTdHJpbmdUb01pbnV0ZXModGltZSkpO1xuICAgICAgICB9LFxuICAgICAgICBvd25lcjogdGhpc1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlZWtEYXlTY2hlZHVsZTtcblxuLy8vLyBVVElMUyxcbi8vIFRPRE8gT3JnYW5pemUgb3IgZXh0ZXJuYWxpemUuIHNvbWUgY29waWVkIGZvcm0gYXBwbW9kZWwuLlxuLyoqXG4gICAgaW50ZXJuYWwgdXRpbGl0eSBmdW5jdGlvbiAndG8gc3RyaW5nIHdpdGggdHdvIGRpZ2l0cyBhbG1vc3QnXG4qKi9cbmZ1bmN0aW9uIHR3b0RpZ2l0cyhuKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDEwKSArICcnICsgbiAlIDEwO1xufVxuXG4vKipcbiAgICBDb252ZXJ0IGEgbnVtYmVyIG9mIG1pbnV0ZXNcbiAgICBpbiBhIHN0cmluZyBsaWtlOiAwMDowMDowMCAoaG91cnM6bWludXRlczpzZWNvbmRzKVxuKiovXG5mdW5jdGlvbiBtaW51dGVzVG9UaW1lU3RyaW5nKG1pbnV0ZXMpIHtcbiAgICB2YXIgZCA9IG1vbWVudC5kdXJhdGlvbihtaW51dGVzLCAnbWludXRlcycpLFxuICAgICAgICBoID0gZC5ob3VycygpLFxuICAgICAgICBtID0gZC5taW51dGVzKCksXG4gICAgICAgIHMgPSBkLnNlY29uZHMoKTtcbiAgICBcbiAgICByZXR1cm4gKFxuICAgICAgICB0d29EaWdpdHMoaCkgKyAnOicgK1xuICAgICAgICB0d29EaWdpdHMobSkgKyAnOicgK1xuICAgICAgICB0d29EaWdpdHMocylcbiAgICApO1xufVxuXG5mdW5jdGlvbiB0aW1lU3RyaW5nVG9NaW51dGVzKHRpbWUpIHtcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHRpbWUpLmFzTWludXRlcygpIHwwO1xufSIsIi8qKlxuICAgIFV0aWxpdHkgdG8gaGVscCB0cmFjayB0aGUgc3RhdGUgb2YgY2FjaGVkIGRhdGFcbiAgICBtYW5hZ2luZyB0aW1lLCBwcmVmZXJlbmNlIGFuZCBpZiBtdXN0IGJlIHJldmFsaWRhdGVkXG4gICAgb3Igbm90LlxuICAgIFxuICAgIEl0cyBqdXN0IG1hbmFnZXMgbWV0YSBkYXRhLCBidXQgbm90IHRoZSBkYXRhIHRvIGJlIGNhY2hlZC5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbmZ1bmN0aW9uIENhY2hlQ29udHJvbChvcHRpb25zKSB7XG4gICAgXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBBIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3JcbiAgICAvLyBBbiBvYmplY3Qgd2l0aCBkZXNpcmVkIHVuaXRzIGFuZCBhbW91bnQsIGFsbCBvcHRpb25hbCxcbiAgICAvLyBhbnkgY29tYmluYXRpb24gd2l0aCBhbG1vc3Qgb25lIHNwZWNpZmllZCwgc2FtcGxlOlxuICAgIC8vIHsgeWVhcnM6IDAsIG1vbnRoczogMCwgd2Vla3M6IDAsIFxuICAgIC8vICAgZGF5czogMCwgaG91cnM6IDAsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9XG4gICAgdGhpcy50dGwgPSBtb21lbnQuZHVyYXRpb24ob3B0aW9ucy50dGwpLmFzTWlsbGlzZWNvbmRzKCk7XG4gICAgdGhpcy5sYXRlc3QgPSBvcHRpb25zLmxhdGVzdCB8fCBudWxsO1xuXG4gICAgdGhpcy5tdXN0UmV2YWxpZGF0ZSA9IGZ1bmN0aW9uIG11c3RSZXZhbGlkYXRlKCkge1xuICAgICAgICB2YXIgdGRpZmYgPSB0aGlzLmxhdGVzdCAmJiBuZXcgRGF0ZSgpIC0gdGhpcy5sYXRlc3QgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICByZXR1cm4gdGRpZmYgPiB0aGlzLnR0bDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMudG91Y2ggPSBmdW5jdGlvbiB0b3VjaCgpIHtcbiAgICAgICAgdGhpcy5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVDb250cm9sO1xuIiwiLyoqXG4gICAgS2VlcCBhbiBpbiBtZW1vcnkgY2FjaGUgb2YgZGF0YSBvcmdhbml6ZWQgYnkgZGF0ZSBhcyBrZXktdmFsdWUuXG4gICAgXG4gICAgSU1QT1JUQU5UOiBEYXRlIHdpdGhvdXQgdGltZSwgaW4gSVNPIGZvcm1hdCBZWVlZLU1NLURELCB1c2luZ1xuICAgIGxvY2FsIHRpbWV6b25lLiBBIGNoYW5nZSBvZiB0aW1lem9uZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgbXVzdFxuICAgIGludmFsaWRhdGUgdGhlIGNhY2hlICh0aHJvdWdoIC5jbGVhcigpKS5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JyksXG4gICAgQ2FjaGVDb250cm9sID0gcmVxdWlyZSgnLi9DYWNoZUNvbnRyb2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEYXRlQ2FjaGUoc2V0dGluZ3MpIHtcbiAgICBcbiAgICB0aGlzLk1vZGVsID0gc2V0dGluZ3MgJiYgc2V0dGluZ3MuTW9kZWwgfHwgbnVsbDtcbiAgICB0aGlzLnR0bCA9IHNldHRpbmdzICYmIHNldHRpbmdzLnR0bCB8fCB7IG1pbnV0ZXM6IDEgfTtcbiAgICBcbiAgICB0aGlzLmJ5RGF0ZSA9IHt9O1xuICAgIFxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ieURhdGUgPSB7fTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0U2luZ2xlID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgZGF0ZUtleSA9IGRhdGU7XG4gICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIGRhdGVLZXkgPSBtb21lbnQoZGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5ieURhdGUuaGFzT3duUHJvcGVydHkoZGF0ZUtleSkgJiZcbiAgICAgICAgICAgICF0aGlzLmJ5RGF0ZVtkYXRlS2V5XS5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnlEYXRlW2RhdGVLZXldLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgZGF0ZUtleSA9IGRhdGU7XG4gICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIGRhdGVLZXkgPSBtb21lbnQoZGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJ5RGF0ZVtkYXRlS2V5XTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoc3RhcnQpO1xuICAgICAgICB2YXIgcmVzdWx0c1BlckRhdGUgPSB7fSxcbiAgICAgICAgICAgIGhvbGVzID0gW10sXG4gICAgICAgICAgICBtaW5SZXF1ZXN0ID0gbnVsbCxcbiAgICAgICAgICAgIG1heFJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChkYXRlIDw9IGVuZCkge1xuICAgICAgICAgICAgdmFyIGRhdGVLZXkgPSBtb21lbnQoZGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLmJ5RGF0ZS5oYXNPd25Qcm9wZXJ0eShkYXRlS2V5KSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmJ5RGF0ZVtkYXRlS2V5XS5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzUGVyRGF0ZVtkYXRlS2V5XSA9IHRoaXMuYnlEYXRlW2RhdGVLZXldLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBob2xlcy5wdXNoKG5ldyBEYXRlKGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5leHQgZGF0ZTpcbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTb3J0IGhvbGVzXG4gICAgICAgIGhvbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA9PT0gYiA/IDAgOiBhIDwgYiA/IC0xIDogMTsgfSk7XG4gICAgICAgIC8vIG1pbiBob2xlIGlzIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgbWluUmVxdWVzdCA9IGhvbGVzLmxlbmd0aCA/IGhvbGVzWzBdIDogbnVsbDtcbiAgICAgICAgLy8gbWF4IGhvbGUgaXMgdGhlIGxhc3Qgb25lXG4gICAgICAgIG1heFJlcXVlc3QgPSBob2xlcy5sZW5ndGggPyBob2xlc1tob2xlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnlEYXRlOiByZXN1bHRzUGVyRGF0ZSxcbiAgICAgICAgICAgIGhvbGVzOiBob2xlcyxcbiAgICAgICAgICAgIG1pbkhvbGU6IG1pblJlcXVlc3QsXG4gICAgICAgICAgICBtYXhIb2xlOiBtYXhSZXF1ZXN0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uKGRhdGUsIGRhdGEpIHtcbiAgICAgICAgLy8gRGF0ZSBmb3JtYXR0aW5nLiBQcm92aWRlIGEgZm9ybWF0dGVkIGRhdGUgYXMgc3RyaW5nIGlzIHZhbGlkIHRvb1xuICAgICAgICB2YXIgZGF0ZUtleSA9IGRhdGU7XG4gICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIGRhdGVLZXkgPSBtb21lbnQoZGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgY2FjaGVcbiAgICAgICAgdmFyIGMgPSB0aGlzLmJ5RGF0ZVtkYXRlS2V5XTtcbiAgICAgICAgaWYgKGMgJiYgYy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5Nb2RlbClcbiAgICAgICAgICAgICAgICBjLmRhdGEubW9kZWwudXBkYXRlV2l0aChkYXRhKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLk1vZGVsID8gbmV3IHRoaXMuTW9kZWwoZGF0YSkgOiBkYXRhLFxuICAgICAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBDYWNoZUNvbnRyb2woeyB0dGw6IHRoaXMudHRsIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5ieURhdGVbZGF0ZUtleV0gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGMuY29udHJvbC50b3VjaCgpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9O1xufTtcbiIsIi8qKlxuICAgIE5ldyBGdW5jdGlvbiBtZXRob2Q6ICdfZGVsYXllZCcuXG4gICAgSXQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiwgd3JhcHBpbmcgdGhlIG9yaWdpbmFsIG9uZSxcbiAgICB0aGF0IG9uY2UgaXRzIGNhbGwgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIHRoZSBnaXZlbiBtaWxsaXNlY29uZHMsXG4gICAgdXNpbmcgYSBzZXRUaW1lb3V0LlxuICAgIFRoZSBuZXcgZnVuY3Rpb24gcmV0dXJucyAndW5kZWZpbmVkJyBzaW5jZSBpdCBoYXMgbm90IHRoZSByZXN1bHQsXG4gICAgYmVjYXVzZSBvZiB0aGF0IGlzIG9ubHkgc3VpdGFibGUgd2l0aCByZXR1cm4tZnJlZSBmdW5jdGlvbnMgXG4gICAgbGlrZSBldmVudCBoYW5kbGVycy5cbiAgICBcbiAgICBXaHk6IHNvbWV0aW1lcywgdGhlIGhhbmRsZXIgZm9yIGFuIGV2ZW50IG5lZWRzIHRvIGJlIGV4ZWN1dGVkXG4gICAgYWZ0ZXIgYSBkZWxheSBpbnN0ZWFkIG9mIGluc3RhbnRseS5cbioqL1xuRnVuY3Rpb24ucHJvdG90eXBlLl9kZWxheWVkID0gZnVuY3Rpb24gZGVsYXllZChtaWxsaXNlY29uZHMpIHtcbiAgICB2YXIgZm4gPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSwgbWlsbGlzZWNvbmRzKTtcbiAgICB9O1xufTtcbiIsIi8qKlxuICAgIEV4dGVuZGluZyB0aGUgRnVuY3Rpb24gY2xhc3Mgd2l0aCBhbiBpbmhlcml0cyBtZXRob2QuXG4gICAgXG4gICAgVGhlIGluaXRpYWwgbG93IGRhc2ggaXMgdG8gbWFyayBpdCBhcyBuby1zdGFuZGFyZC5cbioqL1xuRnVuY3Rpb24ucHJvdG90eXBlLl9pbmhlcml0cyA9IGZ1bmN0aW9uIF9pbmhlcml0cyhzdXBlckN0b3IpIHtcbiAgICB0aGlzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4iLCIvKipcbiAgICBGaXggRnVuY3Rpb24jbmFtZSBvbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0IChJRTkrKTpcbiAgICBcbiAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzA1NjUzMC8xNjIyMzQ2ICAgIFxuKiovXG4ndXNlIHN0cmljdCc7XG4vKmpzaGludCAtVzA2OCAqL1xuaWYgKCEoZnVuY3Rpb24gZigpIHt9KS5uYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvblxccyooXFxTKilcXHMqXFwoLylbMV07XG4gICAgICAgICAgICAvLyBGb3IgYmV0dGVyIHBlcmZvcm1hbmNlIG9ubHkgcGFyc2Ugb25jZSwgYW5kIHRoZW4gY2FjaGUgdGhlXG4gICAgICAgICAgICAvLyByZXN1bHQgdGhyb3VnaCBhIG5ldyBhY2Nlc3NvciBmb3IgcmVwZWF0ZWQgYWNjZXNzLlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfSk7XG59IiwiLyoqXG4gICAgR3JvdXBMaXN0UmVtb3RlTW9kZWxcbiAgICBVdGlsaXR5IGNsYXNzIGZvciBjb21tb24gY29kZSBmb3IgYSBkYXRhIGxpc3QgZW50aXR5IGZyb20gYSByZW1vdGUgc291cmNlLFxuICAgIHdpdGggbG9jYWwgY29weSBhbmQgY2FjaGUsIHdoZXJlIHRoZSBmdWxsIGxpc3QgaXMgbWFuYWdlZCBwZXIgZ3JvdXBzLFxuICAgIHdpdGhvdXQgcGFnaW5nL2N1cnNvciwgYWxsIHRoZSBncm91cCBkYXRhIG9uIGVhY2ggb3BlcmF0aW9uLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgSW5kZXhlZEdyb3VwTGlzdENhY2hlID0gcmVxdWlyZSgnLi9JbmRleGVkR3JvdXBMaXN0Q2FjaGUnKTtcblxuZnVuY3Rpb24gcmVxdWlyZWQodmFsLCBtc2cpIHtcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZih2YWwpID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnUmVxdWlyZWQgcGFyYW1ldGVyJyk7XG4gICAgZWxzZSByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBHcm91cExpc3RSZW1vdGVNb2RlbChzZXR0aW5ncykge1xuICAgIC8qanNoaW50IG1heHN0YXRlbWVudHM6MjgqL1xuICAgIFxuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgc2V0dGluZ3MubGlzdFR0bCA9IHJlcXVpcmVkKHNldHRpbmdzLmxpc3RUdGwsICdsaXN0VHRsIGlzIHJlcXVpcmVkJyk7XG4gICAgc2V0dGluZ3MuZ3JvdXBJZEZpZWxkID0gcmVxdWlyZWQoc2V0dGluZ3MuZ3JvdXBJZEZpZWxkLCAnZ3JvdXBJZEZpZWxkIGlzIHJlcXVpcmVkJyk7XG4gICAgc2V0dGluZ3MuaXRlbUlkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5pdGVtSWRGaWVsZCwgJ2l0ZW1JZEZpZWxkIGlzIHJlcXVpcmVkJyk7XG4gICAgLy8gRm9yIG5vdywgb3B0aW9uYWwgbW9kZWxcbiAgICBzZXR0aW5ncy5Nb2RlbCA9IHNldHRpbmdzLk1vZGVsIHx8IG51bGw7XG4gICAgLy8gUmVxdWlyZWQgZm9yIEFQSSBhZGRpdGlvbnNcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBpc0xvYWRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICBpc1N5bmNpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICBpc1NhdmluZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgIGlzRGVsZXRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpXG4gICAgfTtcblxuICAgIHZhciBjYWNoZSA9IG5ldyBJbmRleGVkR3JvdXBMaXN0Q2FjaGUoe1xuICAgICAgICBsaXN0VHRsOiBzZXR0aW5ncy5saXN0VHRsLFxuICAgICAgICBncm91cElkRmllbGQ6IHNldHRpbmdzLmdyb3VwSWRGaWVsZCxcbiAgICAgICAgaXRlbUlkRmllbGQ6IHNldHRpbmdzLml0ZW1JZEZpZWxkXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5jbGVhckNhY2hlID0gY2FjaGUuY2xlYXJDYWNoZTtcblxuICAgIHRoaXMuc3RhdGUuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTG9hZGluZygpIHx8IHRoaXMuaXNTYXZpbmcoKSB8fCB0aGlzLmlzRGVsZXRpbmcoKTtcbiAgICB9LCB0aGlzLnN0YXRlKTtcblxuICAgIC8qKiBEYXRhIFN0b3JlcyBNYW5hZ2VtZW50OiBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIHJlcGxhY2VkLCB3aXRoIGN1c3RvbSBjb2RlIG9yIHVzaW5nXG4gICAgICAgIHRoZSBoZWxwZXJzIGFkZGVkIHRvIHRoZSBjbGFzcyAoc2VlIGFkZFh4U3VwcG9ydCBwcm90b3R5cGUgbWV0aG9kcykuXG4gICAgKiovXG4gICAgZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7IHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7IH1cbiAgICB0aGlzLmZldGNoR3JvdXBGcm9tTG9jYWwgPSBub3RJbXBsZW1lbnRlZDtcbiAgICB0aGlzLmZldGNoR3JvdXBGcm9tUmVtb3RlID0gbm90SW1wbGVtZW50ZWQ7XG4gICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsID0gbm90SW1wbGVtZW50ZWQ7XG4gICAgdGhpcy5wdXNoR3JvdXBUb1JlbW90ZSA9IG5vdEltcGxlbWVudGVkO1xuICAgIHRoaXMucmVtb3ZlSXRlbUZyb21SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcblxuICAgIC8qKiBBUEkgZGVmaW5pdGlvbiAqKi9cbiAgICB2YXIgYXBpID0gdGhpcztcblxuICAgIGFwaS5nZXRMaXN0ID0gZnVuY3Rpb24gZ2V0TGlzdChncm91cElEKSB7XG4gICAgICAgIHZhciBjYWNoZUVudHJ5ID0gY2FjaGUuZ2V0R3JvdXBDYWNoZShncm91cElEKTtcblxuICAgICAgICBpZiAoY2FjaGVFbnRyeS5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIGNhY2hlIGRhdGEsIGlzIGZpcnN0IGxvYWQsIHRyeSBmcm9tIGxvY2FsXG4gICAgICAgICAgICBpZiAoIWNhY2hlRW50cnkubGlzdCkge1xuICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gRnJvbSBsb2NhbFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoR3JvdXBGcm9tTG9jYWwoZ3JvdXBJRClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhdW5jaCByZW1vdGUgZm9yIHN5bmNcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZVByb21pc2UgPSB0aGlzLmZldGNoR3JvdXBGcm9tUmVtb3RlKGdyb3VwSUQpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEdyb3VwQ2FjaGUoZ3JvdXBJRCwgc2VydmVyRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hHcm91cFRvTG9jYWwoZ3JvdXBJRCwgc2VydmVyRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdGUgZmFsbGJhY2s6IElmIG5vIGxvY2FsLCB3YWl0IGZvciByZW1vdGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhIDogcmVtb3RlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyIGEgbGlzdCwgZXZlbiBpZiBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0R3JvdXBDYWNoZShncm91cElELCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsKGdyb3VwSUQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBGcm9tIHJlbW90ZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoR3JvdXBGcm9tUmVtb3RlKGdyb3VwSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyIGEgbGlzdCwgZXZlbiBpZiBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0R3JvdXBDYWNoZShncm91cElELCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsKGdyb3VwSUQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGcm9tIGNhY2hlXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlRW50cnkubGlzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGFwaS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbShncm91cElELCBpdGVtSUQpIHtcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBUbyBzaW1wbGlmeSwgbG9hZCBhbGwgdGhlIGxpc3QgKGlzIGEgc2hvcnQgbGlzdClcbiAgICAgICAgLy8gYW5kIGxvb2sgZnJvbSBpdHMgY2FjaGVkIGluZGV4XG4gICAgICAgIC8vIFRPRE8gSW1wbGVtZW50IGl0ZW0gc2VydmVyIGxvb2stdXAuIEJlIGNhcmVmdWwgd2l0aCBjYWNoZSB1cGRhdGUsXG4gICAgICAgIC8vIGxpc3Qgc29ydGluZyBhbmQgc3RhdGUgZmxhZ3MuXG4gICAgICAgIHJldHVybiBhcGkuZ2V0TGlzdChncm91cElEKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEdldCBmcm9tIGNhY2hlZCBpbmRleFxuICAgICAgICAgICAgdmFyIGNhY2hlSXRlbSA9IGNhY2hlLmdldEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBFbmhhbmNlIG9uIGZ1dHVyZSB3aXRoIGFjdHVhbCBsb29rLXVwIGJ5IEFQSSBpdGVtSURcbiAgICAgICAgICAgIC8vIGlmIG5vdCBjYWNoZWQsIHRocm93aW5nIG5vdCBmb3VuZCBmcm9tIHRoZSBzZXJ2ZXIgKGp1c3QgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIG1pbm9yIGNhc2VzIHdoZW4gYSBuZXcgaXRlbSBpcyBub3Qgc3RpbGwgaW4gdGhlIGNhY2hlIGlmIGxpbmtlZFxuICAgICAgICAgICAgLy8gZnJvbSBvdGhlciBhcHAgZGF0YSkuIEFuZCBrZWVwIHVwZGF0ZWQgbGlzdCBjYWNoZSB3aXRoIHRoYXRcbiAgICAgICAgICAgIC8vIGl0ZW1zIGxvb2t1cFxuICAgICAgICAgICAgaWYgKCFjYWNoZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dyb3VwTGlzdFJlbW90ZU1vZGVsIE5vdCBmb3VuZCcsIGdyb3VwSUQsIGl0ZW1JRCwgc2V0dGluZ3MuTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVJdGVtLml0ZW07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgU2F2ZSBhbiBpdGVtIGluIGNhY2hlLCBsb2NhbCBhbmQgcmVtb3RlLlxuICAgICAgICBDYW4gYmUgbmV3IG9yIHVwZGF0ZWQuXG4gICAgICAgIFRoZSBJRHMgZ29lcyB3aXRoIGFsbCB0aGUgb3RoZXIgZGF0YSwgYmVpbmdcbiAgICAgICAgZ3JvdXBJRCByZXF1aXJlZCwgaXRlbUlEIHJlcXVpcmVkIGZvciB1cGRhdGVzXG4gICAgICAgIGJ1dCBmYWxzeSBmb3IgaW5zZXJ0aW9ucy5cbiAgICAgICAgQHBhcmFtIGRhdGE6b2JqZWN0IFBsYWluIG9iamVjdFxuICAgICoqL1xuICAgIGFwaS5zZXRJdGVtID0gZnVuY3Rpb24gc2V0SXRlbShkYXRhKSB7XG4gICAgICAgIGFwaS5zdGF0ZS5pc1NhdmluZyh0cnVlKTtcbiAgICAgICAgLy8gU2VuZCB0byByZW1vdGUgZmlyc3RcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaEdyb3VwVG9SZW1vdGUoZGF0YSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRGF0YSkge1xuICAgICAgICAgICAgLy8gU3VjY2VzcyEgdXBkYXRlIGxvY2FsIGNvcHkgd2l0aCByZXR1cm5lZCBkYXRhXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IHRvIHVzZSBzZXJ2ZXIgZGF0YSBoZXJlIHNvIHdlIGdldCB2YWx1ZXMgc2V0XG4gICAgICAgICAgICAvLyBieSB0aGUgc2VydmVyLCBhcyB1cGRhdGVzIGRhdGVzIGFuZCBpdGVtSUQgd2hlbiBjcmVhdGluZ1xuICAgICAgICAgICAgLy8gYSBuZXcgaXRlbS5cbiAgICAgICAgICAgIGlmIChzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwSUQgPSBzZXJ2ZXJEYXRhW3NldHRpbmdzLmdyb3VwSWRGaWVsZF07XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbiBjYWNoZVxuICAgICAgICAgICAgICAgIGNhY2hlLnNldEl0ZW1DYWNoZShncm91cElELCBzZXJ2ZXJEYXRhW3NldHRpbmdzLml0ZW1JZEZpZWxkXSwgc2VydmVyRGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbiBsb2NhbCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgLy8gSW4gbG9jYWwgbmVlZCB0byBiZSBzYXZlZCBhbGwgdGhlIGdyb3VwZWQgZGF0YSwgbm90IGp1c3RcbiAgICAgICAgICAgICAgICAvLyB0aGUgaXRlbTsgc2luY2Ugd2UgaGF2ZSB0aGUgY2FjaGUgbGlzdCB1cGRhdGVkLCB1c2UgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGZ1bGwgbGlzdCB0byBzYXZlIGxvY2FsXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoR3JvdXBUb0xvY2FsKGdyb3VwSUQsIGNhY2hlLmdldEdyb3VwQ2FjaGUoZ3JvdXBJRCkubGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VydmVyRGF0YTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBhcGkuZGVsSXRlbSA9IGZ1bmN0aW9uIGRlbEl0ZW0oZ3JvdXBJRCwgaXRlbUlEKSB7XG4gICAgICAgIFxuICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBpbiByZW1vdGUgZmlyc3RcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSXRlbUZyb21SZW1vdGUoZ3JvdXBJRCwgaXRlbUlEKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZW1vdmVkRGF0YSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGNhY2hlXG4gICAgICAgICAgICBjYWNoZS5kZWxJdGVtQ2FjaGUoZ3JvdXBJRCwgaXRlbUlEKTtcbiAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgLy8gSW4gbG9jYWwgbmVlZCB0byBiZSBzYXZlZCBhbGwgdGhlIGdyb3VwZWQgZGF0YTtcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlIGhhdmUgdGhlIGNhY2hlIGxpc3QgdXBkYXRlZCwgdXNlIHRoYXRcbiAgICAgICAgICAgIC8vIGZ1bGwgbGlzdCB0byBzYXZlIGxvY2FsXG4gICAgICAgICAgICB0aGlzLnB1c2hHcm91cFRvTG9jYWwoZ3JvdXBJRCwgY2FjaGUuZ2V0R3JvdXBDYWNoZShncm91cElEKS5saXN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXBpLnN0YXRlLmlzRGVsZXRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZERhdGE7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBpLnN0YXRlLmlzRGVsZXRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICAvKiogU29tZSBVdGlscyAqKi9cbiAgICBcbiAgICAvKipcbiAgICAgICAgR2VuZXJhdGVzIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgaW5tZWRpYXRlbHksXG4gICAgICAgIHdpdGggdGhlIGNhY2hlZCB2YWx1ZSBvciB1bmRlZmluZWQsXG4gICAgICAgIGxhdW5jaGluZyBhbiBpdGVtIGxvYWQgdGhhdCB3aWxsIHVwZGF0ZSB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICBvbiByZWFkeSBpZiB0aGVyZSBpcyBubyBjYWNoZWQgdmFsdWUuXG4gICAgICAgIEEgbWV0aG9kICdzeW5jJyBpcyBhZGRlZCB0byB0aGUgb2JzZXJ2YWJsZSBzbyBjYW4gYmUgcmVxdWVzdGVkXG4gICAgICAgIGEgZGF0YSBzeW5jL3JlbG9hZCBvbiBkZW1hbmQuXG4gICAgKiovXG4gICAgYXBpLmdldE9ic2VydmFibGVJdGVtID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZUl0ZW0oZ3JvdXBJRCwgaXRlbUlELCBhc01vZGVsKSB7XG4gICAgICAgIC8vIEdldCBmaXJzdCB2YWx1ZVxuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGNhY2hlLmdldEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQpO1xuICAgICAgICBmaXJzdFZhbHVlID0gZmlyc3RWYWx1ZSAmJiBmaXJzdFZhbHVlLml0ZW0gfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgb2JzID0ga28ub2JzZXJ2YWJsZShhc01vZGVsID8gYXBpLmFzTW9kZWwoZmlyc3RWYWx1ZSkgOiBmaXJzdFZhbHVlKTtcbiAgICAgICAgLy8gQ3JlYXRlIG1ldGhvZCAnc3luYydcbiAgICAgICAgb2JzLnN5bmMgPSBmdW5jdGlvbiBzeW5jT2JzZXJ2YWJsZUl0ZW0oKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW0oZ3JvdXBJRCwgaXRlbUlEKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChhc01vZGVsKVxuICAgICAgICAgICAgICAgICAgICBvYnMoKS5tb2RlbC51cGRhdGVXaXRoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEZpcnN0IGxvYWQgaWYgbm8gY2FjaGVkIHZhbHVlXG4gICAgICAgIGlmICghZmlyc3RWYWx1ZSlcbiAgICAgICAgICAgIG9icy5zeW5jKCk7XG4gICAgICAgIC8vIFJldHVyblxuICAgICAgICByZXR1cm4gb2JzO1xuICAgIH07XG4gICAgXG4gICAgYXBpLmFzTW9kZWwgPSBmdW5jdGlvbiBhc01vZGVsKG9iamVjdCkge1xuICAgICAgICB2YXIgTW9kZWwgPSB0aGlzLnNldHRpbmdzLk1vZGVsO1xuICAgICAgICAvLyBpZiBpcyBhbiBhcnJheSwgcmV0dXJuIGEgbGlzdCBvZiBtb2RlbHNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZWwoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZWwob2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgYXBpLmdldEl0ZW1Nb2RlbCA9IGZ1bmN0aW9uIGdldEl0ZW1Nb2RlbChncm91cElELCBpdGVtSUQpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5nZXRJdGVtKGdyb3VwSUQsIGl0ZW1JRClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBhcGkuYXNNb2RlbChkYXRhKSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdmFyIE1vZGVsVmVyc2lvbiA9IHJlcXVpcmUoJy4uL3V0aWxzL01vZGVsVmVyc2lvbicpO1xuICAgIGFwaS5nZXRJdGVtVmVyc2lvbiA9IGZ1bmN0aW9uIGdldEl0ZW1WZXJzaW9uKGdyb3VwSUQsIGl0ZW1JRCkge1xuICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW1Nb2RlbChncm91cElELCBpdGVtSUQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwgPyBuZXcgTW9kZWxWZXJzaW9uKG1vZGVsKSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgYXBpLm5ld0l0ZW1WZXJzaW9uID0gZnVuY3Rpb24gbmV3SXRlbVZlcnNpb24odmFsdWVzKSB7XG4gICAgICAgIC8vIE5ldyBvcmlnaW5hbCBhbmQgdmVyc2lvbiBmb3IgdGhlIG1vZGVsXG4gICAgICAgIHZhciB2ZXJzaW9uID0gbmV3IE1vZGVsVmVyc2lvbihuZXcgdGhpcy5zZXR0aW5ncy5Nb2RlbCh2YWx1ZXMpKTtcbiAgICAgICAgLy8gVG8gYmUgc3VyZSB0aGF0IHRoZSB2ZXJzaW9uIGFwcGVhciBhcyBzb21ldGhpbmcgJ25ldycsIHVuc2F2ZWQsXG4gICAgICAgIC8vIHdlIHVwZGF0ZSBpdHMgdGltZXN0YW1wIHRvIGJlIGRpZmZlcmVudCB0byB0aGUgb3JpZ2luYWwuXG4gICAgICAgIHZlcnNpb24udmVyc2lvbi5tb2RlbC50b3VjaCgpO1xuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwTGlzdFJlbW90ZU1vZGVsO1xuXG5Hcm91cExpc3RSZW1vdGVNb2RlbC5wcm90b3R5cGUuYWRkTG9jYWxmb3JhZ2VTdXBwb3J0ID0gZnVuY3Rpb24gYWRkTG9jYWxmb3JhZ2VTdXBwb3J0KGJhc2VOYW1lKSB7XG4gICAgdmFyIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKTtcblxuICAgIHRoaXMuZmV0Y2hHcm91cEZyb21Mb2NhbCA9IGZ1bmN0aW9uIGZldGNoRnJvbUxvY2FsKGdyb3VwSUQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZm9yYWdlLmdldEl0ZW0oYmFzZU5hbWUgKyBncm91cElEKTtcbiAgICB9O1xuICAgIHRoaXMucHVzaEdyb3VwVG9Mb2NhbCA9IGZ1bmN0aW9uIHB1c2hUb0xvY2FsKGdyb3VwSUQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZm9yYWdlLnNldEl0ZW0oYmFzZU5hbWUgKyBncm91cElELCBkYXRhKTtcbiAgICB9O1xufTtcblxuR3JvdXBMaXN0UmVtb3RlTW9kZWwucHJvdG90eXBlLmFkZFJlc3RTdXBwb3J0ID0gZnVuY3Rpb24gYWRkUmVzdFN1cHBvcnQocmVzdENsaWVudCwgYmFzZVVybCkge1xuICAgIFxuICAgIHRoaXMuZmV0Y2hHcm91cEZyb21SZW1vdGUgPSBmdW5jdGlvbiBmZXRjaEZyb21SZW1vdGUoZ3JvdXBJRCkge1xuICAgICAgICByZXR1cm4gcmVzdENsaWVudC5nZXQoYmFzZVVybCArIGdyb3VwSUQpO1xuICAgIH07XG4gICAgdGhpcy5wdXNoR3JvdXBUb1JlbW90ZSA9IGZ1bmN0aW9uIHB1c2hUb1JlbW90ZShkYXRhKSB7XG5cbiAgICAgICAgdmFyIGdyb3VwSUQgPSBkYXRhW3RoaXMuc2V0dGluZ3MuZ3JvdXBJZEZpZWxkXSxcbiAgICAgICAgICAgIGl0ZW1JRCA9IGRhdGFbdGhpcy5zZXR0aW5ncy5pdGVtSWRGaWVsZF0sXG4gICAgICAgICAgICBtZXRob2QgPSBkYXRhW3RoaXMuc2V0dGluZ3MuaXRlbUlkRmllbGRdID8gJ3B1dCcgOiAncG9zdCc7XG5cbiAgICAgICAgdmFyIHVybCA9IGJhc2VVcmwgKyBncm91cElEICsgKFxuICAgICAgICAgICAgaXRlbUlEID8gJy8nICsgaXRlbUlEIDogJydcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3RDbGllbnRbbWV0aG9kXSh1cmwsIGRhdGEpO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tUmVtb3RlKGdyb3VwSUQsIGl0ZW1JRCkge1xuICAgICAgICByZXR1cm4gcmVzdENsaWVudC5kZWxldGUoYmFzZVVybCArIGdyb3VwSUQgKyAnLycgKyBpdGVtSUQpO1xuICAgIH07XG59O1xuIiwiLyoqXG4gICAgR3JvdXBSZW1vdGVNb2RlbFxuICAgIFV0aWxpdHkgY2xhc3MgZm9yIGNvbW1vbiBjb2RlIHRoYXQgaGFzIHJlbW90ZSBlbnRpdGllcyBncm91cGVkXG4gICAgYnkgYSB2YWx1ZSBidXQgYWNjZXNlZCBhbGwgdGhlIHRpbWUgaW5kaXZpZHVhbGx5LlxuICAgIEl0IGhhcyBsb2NhbCBjb3B5IGFuZCBjYWNoZS5cbiAgICBEaWZmZXJlbmNlIHdpdGggR3JvdXBMaXN0UmVtb3RlTW9kZWwgaXRzIHRoYXQgdGhlIGNvbnRlbnQgaXMgTk9UXG4gICAgYSBsaXN0LCBidXQgYW4gZW50aXR5LlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgQ2FjaGVDb250cm9sID0gcmVxdWlyZSgnLi9DYWNoZUNvbnRyb2wnKTtcblxuZnVuY3Rpb24gcmVxdWlyZWQodmFsLCBtc2cpIHtcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZih2YWwpID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnUmVxdWlyZWQgcGFyYW1ldGVyJyk7XG4gICAgZWxzZSByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBHcm91cFJlbW90ZU1vZGVsKHNldHRpbmdzKSB7XG4gICAgXG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICBzZXR0aW5ncy50dGwgPSByZXF1aXJlZChzZXR0aW5ncy50dGwsICd0dGwgaXMgcmVxdWlyZWQnKTtcbiAgICBzZXR0aW5ncy5pdGVtSWRGaWVsZCA9IHJlcXVpcmVkKHNldHRpbmdzLml0ZW1JZEZpZWxkLCAnaXRlbUlkRmllbGQgaXMgcmVxdWlyZWQnKTtcbiAgICBzZXR0aW5ncy5Nb2RlbCA9IHJlcXVpcmVkKHNldHRpbmdzLk1vZGVsLCAnTW9kZWwgaXMgcmVxdWlyZWQnKTtcbiAgICAvLyBSZXF1aXJlZCBmb3IgQVBJIGFkZGl0aW9uc1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIGlzTG9hZGluZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgIGlzU3luY2luZzoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgIGlzU2F2aW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgaXNEZWxldGluZzoga28ub2JzZXJ2YWJsZShmYWxzZSlcbiAgICB9O1xuXG4gICAgdmFyIGNhY2hlID0ge1xuICAgICAgICAvLyAnaW5kZXhJRCc6IHsgZGF0YSwgY29udHJvbDpDYWNoZUNvbnRyb2wgfVxuICAgIH07XG4gICAgdmFyIHNldEl0ZW1DYWNoZSA9IGZ1bmN0aW9uKGl0ZW1JRCwgZGF0YSkge1xuICAgICAgICBpZiAoY2FjaGVbaXRlbUlEXSkge1xuICAgICAgICAgICAgY2FjaGVbaXRlbUlEXS5kYXRhLm1vZGVsLnVwZGF0ZVdpdGgoZGF0YSk7XG4gICAgICAgICAgICBjYWNoZVtpdGVtSURdLmNvbnRyb2wudG91Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlW2l0ZW1JRF0gPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogbmV3IHNldHRpbmdzLk1vZGVsKGRhdGEpLFxuICAgICAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBDYWNoZUNvbnRyb2woe1xuICAgICAgICAgICAgICAgICAgICB0dGw6IHNldHRpbmdzLnR0bFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZVtpdGVtSURdO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FjaGUgPSB7fTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGF0ZS5pc0xvY2tlZCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2FkaW5nKCkgfHwgdGhpcy5pc1NhdmluZygpIHx8IHRoaXMuaXNEZWxldGluZygpO1xuICAgIH0sIHRoaXMuc3RhdGUpO1xuXG4gICAgLyoqIERhdGEgU3RvcmVzIE1hbmFnZW1lbnQ6IGltcGxlbWVudGF0aW9uIG11c3QgYmUgcmVwbGFjZWQsIHdpdGggY3VzdG9tIGNvZGUgb3IgdXNpbmdcbiAgICAgICAgdGhlIGhlbHBlcnMgYWRkZWQgdG8gdGhlIGNsYXNzIChzZWUgYWRkWHhTdXBwb3J0IHByb3RvdHlwZSBtZXRob2RzKS5cbiAgICAqKi9cbiAgICBmdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTsgfVxuICAgIHRoaXMuZmV0Y2hJdGVtRnJvbUxvY2FsID0gbm90SW1wbGVtZW50ZWQ7XG4gICAgdGhpcy5mZXRjaEl0ZW1Gcm9tUmVtb3RlID0gbm90SW1wbGVtZW50ZWQ7XG4gICAgdGhpcy5wdXNoSXRlbVRvTG9jYWwgPSBub3RJbXBsZW1lbnRlZDtcbiAgICB0aGlzLnB1c2hJdGVtVG9SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcbiAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tTG9jYWwgPSBub3RJbXBsZW1lbnRlZDtcbiAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tUmVtb3RlID0gbm90SW1wbGVtZW50ZWQ7XG5cbiAgICAvKiogQVBJIGRlZmluaXRpb24gKiovXG4gICAgdmFyIGFwaSA9IHRoaXM7XG5cbiAgICBhcGkuZ2V0SXRlbSA9IGZ1bmN0aW9uIGdldEl0ZW0oaXRlbUlELCBmb3JjZVJlbW90ZUxvYWQpIHtcbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSBjYWNoZVtpdGVtSURdO1xuXG4gICAgICAgIGlmIChmb3JjZVJlbW90ZUxvYWQgfHwgIWNhY2hlRW50cnkgfHwgY2FjaGVFbnRyeS5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIGNhY2hlIGRhdGEsIGlzIGZpcnN0IGxvYWQsIHRyeSBmcm9tIGxvY2FsXG4gICAgICAgICAgICBpZiAoIWNhY2hlRW50cnkgfHwgIWNhY2hlRW50cnkuZGF0YSkge1xuICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gRnJvbSBsb2NhbFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoSXRlbUZyb21Mb2NhbChpdGVtSUQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYXVuY2ggcmVtb3RlIGZvciBzeW5jXG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdGVQcm9taXNlID0gdGhpcy5mZXRjaEl0ZW1Gcm9tUmVtb3RlKGl0ZW1JRClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2VydmVyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlZCA9IHNldEl0ZW1DYWNoZShpdGVtSUQsIHNlcnZlckRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoSXRlbVRvTG9jYWwoaXRlbUlELCBzZXJ2ZXJEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdGUgZmFsbGJhY2s6IElmIG5vIGxvY2FsLCB3YWl0IGZvciByZW1vdGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhIDogcmVtb3RlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkID0gc2V0SXRlbUNhY2hlKGl0ZW1JRCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkLmRhdGE7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gRnJvbSByZW1vdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEl0ZW1Gcm9tUmVtb3RlKGl0ZW1JRClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZWQgPSBzZXRJdGVtQ2FjaGUoaXRlbUlELCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoSXRlbVRvTG9jYWwoaXRlbUlELCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQuZGF0YTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZyb20gY2FjaGVcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVFbnRyeS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgU2F2ZSBhbiBpdGVtIGluIGNhY2hlLCBsb2NhbCBhbmQgcmVtb3RlLlxuICAgICAgICBDYW4gYmUgbmV3IG9yIHVwZGF0ZWQuXG4gICAgICAgIFRoZSBJRHMgZ29lcyB3aXRoIGFsbCB0aGUgb3RoZXIgZGF0YSwgYmVpbmdcbiAgICAgICAgaXRlbUlEIHJlcXVpcmVkIGZvciB1cGRhdGVzXG4gICAgICAgIGJ1dCBmYWxzeSBmb3IgaW5zZXJ0aW9ucy5cbiAgICAgICAgQHBhcmFtIGRhdGE6b2JqZWN0IFBsYWluIG9iamVjdFxuICAgICoqL1xuICAgIGFwaS5zZXRJdGVtID0gZnVuY3Rpb24gc2V0SXRlbShkYXRhKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgcGxhaW4gZGF0YSBpZiBpcyBtb2RlbFxuICAgICAgICBkYXRhID0gZGF0YSAmJiBkYXRhLm1vZGVsICYmIGRhdGEubW9kZWwudG9QbGFpbk9iamVjdCh0cnVlKSB8fCBkYXRhO1xuICAgICAgICBcbiAgICAgICAgYXBpLnN0YXRlLmlzU2F2aW5nKHRydWUpO1xuICAgICAgICAvLyBTZW5kIHRvIHJlbW90ZSBmaXJzdFxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoSXRlbVRvUmVtb3RlKGRhdGFbc2V0dGluZ3MuaXRlbUlkRmllbGRdLCBkYXRhKVxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkO1xuICAgICAgICAgICAgLy8gU3VjY2VzcyEgdXBkYXRlIGxvY2FsIGNvcHkgd2l0aCByZXR1cm5lZCBkYXRhXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IHRvIHVzZSBzZXJ2ZXIgZGF0YSBoZXJlIHNvIHdlIGdldCB2YWx1ZXMgc2V0XG4gICAgICAgICAgICAvLyBieSB0aGUgc2VydmVyLCBhcyB1cGRhdGVzIGRhdGVzIGFuZCBpdGVtSUQgd2hlbiBjcmVhdGluZ1xuICAgICAgICAgICAgLy8gYSBuZXcgaXRlbS5cbiAgICAgICAgICAgIGlmIChzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1JRCA9IHNlcnZlckRhdGFbc2V0dGluZ3MuaXRlbUlkRmllbGRdO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgaW4gY2FjaGVcbiAgICAgICAgICAgICAgICBjYWNoZWQgPSBzZXRJdGVtQ2FjaGUoc2VydmVyRGF0YVtzZXR0aW5ncy5pdGVtSWRGaWVsZF0sIHNlcnZlckRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgICAgIC8vIEluIGxvY2FsIG5lZWQgdG8gYmUgc2F2ZWQgYWxsIHRoZSBncm91cGVkIGRhdGEsIG5vdCBqdXN0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW07IHNpbmNlIHdlIGhhdmUgdGhlIGNhY2hlIGxpc3QgdXBkYXRlZCwgdXNlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBmdWxsIGxpc3QgdG8gc2F2ZSBsb2NhbFxuICAgICAgICAgICAgICAgIHRoaXMucHVzaEl0ZW1Ub0xvY2FsKGl0ZW1JRCwgY2FjaGVkLmRhdGEubW9kZWwudG9QbGFpbk9iamVjdCh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkICYmIGNhY2hlZC5kYXRhO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1NhdmluZyhmYWxzZSk7XG4gICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGFwaS5kZWxJdGVtID0gZnVuY3Rpb24gZGVsSXRlbShpdGVtSUQpIHtcbiAgICAgICAgXG4gICAgICAgIGFwaS5zdGF0ZS5pc0RlbGV0aW5nKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGluIHJlbW90ZSBmaXJzdFxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZShpdGVtSUQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlbW92ZWREYXRhKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgY2FjaGVcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtpdGVtSURdO1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbUZyb21Mb2NhbChpdGVtSUQpO1xuXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyhmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkRGF0YTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyhmYWxzZSk7XG4gICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKiBTb21lIFV0aWxzICoqL1xuICAgIHZhciBNb2RlbFZlcnNpb24gPSByZXF1aXJlKCcuLi91dGlscy9Nb2RlbFZlcnNpb24nKTtcbiAgICAvKipcbiAgICAgICAgR2V0cyBpbW1lZGlhdGVseSBhbiBvYmplY3QgYmFzZWQgb24gTW9kZWxWZXJzaW9uXG4gICAgICAgIHdpdGggdGhlIG9yaWdpbmFsIGFuZCB2ZXJzaW9uIGJlaW5nIHRoZSBjYWNoZWQgdmVyc2lvblxuICAgICAgICBpZiBhbnkgb3IgYW4gZW1wdHkgTW9kZWwgKGluc3RhbmNlIHdpdGhvdXQgZGF0YSkuXG4gICAgICAgIElmIHRoZXJlIGlzIG5vIGRhdGEsIGl0IHRyaWdnZXJzIGEgbG9hZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHNldHRpbmcgaXRzIHN0YXRlIGZsYWcgaXNMb2FkaW5nIHRvIHRydWUgdW50aWwgZW5kcy5cbiAgICAgICAgSWYgdGhlcmUgYXJlIGRhdGEgYnV0IGlzIG9ic29sZXRlLCBpdCB0cmlnZ2VycyBhIFxuICAgICAgICBsb2FkIGF1dG9tYXRpY2FsbHkgc2V0dGluZ3MgaXRzIHN0YXRlICBmbGFnIGlzU3luY2luZ1xuICAgICAgICB0byB0cnVlIHVudGlsIGVuZHMuXG4gICAgICAgIEl0IGFkZHMgYSBsb2FkIG1ldGhvZCB0byB0cmlnZ2VyIGxvYWRpbmcgb2YgdGhlIG9yaWdpbmFsXG4gICAgICAgIGZyb20gcmVtb3RlLCBhbmQgaXQgdHJpZ2dlcnMgTW9kZWxWZXJzaW9uLnN5bmMgb24gZmluaXNoaW5nXG4gICAgICAgIChpc1N5bmNpbmcgaXMgZmxhZ2dlZCk7IHJldHVybnMgUHJvbWlzZVxuICAgICAgICBJdCBhZGRzIGEgc2F2ZSBtZXRob2QgdG8gdHJpZ2dlciBzYXZpbmcgdGhlIHZlcnNpb25cbiAgICAgICAgdG8gcmVtb3RlLCBhbmQgaXQgcHVzaCB0aGUgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWwgb24gc3VjY2Vzc1xuICAgICAgICAoaXNTYXZpbmcgaXMgZmxhZ2dlZCk7IHJldHVybnMgUHJvbWlzZS5cbiAgICAqKi9cbiAgICBhcGkuZ2V0SXRlbVZlcnNpb24gPSBmdW5jdGlvbiBnZXRJdGVtVmVyc2lvbihpdGVtSUQpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBjYWNoZWQgPSBjYWNoZVtpdGVtSURdLFxuICAgICAgICAgICAgaW5pdGlhbE1vZGVsID0gY2FjaGVkICYmIGNhY2hlZC5kYXRhIHx8IG5ldyBzZXR0aW5ncy5Nb2RlbCgpLFxuICAgICAgICAgICAgdmVyc2lvbiA9IG5ldyBNb2RlbFZlcnNpb24oaW5pdGlhbE1vZGVsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEV4dGVuZCB3aXRoIHN0YXRlIGZsYWdzXG4gICAgICAgIHZlcnNpb24uc3RhdGUgPSB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgaXNTeW5jaW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgIGlzU2F2aW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgIC8vIE5vdCBqdXN0IGEgZmxhZywgaXQgY29udGFpbnMgYW55IGVycm9yXG4gICAgICAgICAgICAvLyBvbiBsb2FkaW5nL3NhdmluZy4gSXQgbm8gdmFsdWUvbnVsbCwgbm8gZXJyb3JcbiAgICAgICAgICAgIGxhc3RFcnJvcjoga28ub2JzZXJ2YWJsZShudWxsKVxuICAgICAgICAgICAgLy9pc0RlbGV0aW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZpcnN0IHRpbWUgbG9hZCwgaWYgbmVlZGVkOlxuICAgICAgICBpZiAoaXRlbUlEICYmICghY2FjaGVkIHx8IGNhY2hlZC5tdXN0UmV2YWxpZGF0ZSgpKSkge1xuICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICBhcGkuZ2V0SXRlbShpdGVtSUQpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgIHZlcnNpb24uc3RhdGUubGFzdEVycm9yKG51bGwpO1xuICAgICAgICAgICAgICAgIHZlcnNpb24uc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLm9yaWdpbmFsLm1vZGVsLnVwZGF0ZVdpdGgobW9kZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZlcnNpb24udmVyc2lvbi5tb2RlbC51cGRhdGVXaXRoKG1vZGVsLCB0cnVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5sYXN0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmVyc2lvbi5sb2FkID0gZnVuY3Rpb24gbG9hZChuZXdJdGVtSUQsIGZvcmNlUmVtb3RlTG9hZCkge1xuICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5pc1N5bmNpbmcodHJ1ZSk7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIG5ldyBpdGVtSUQsIE9SIHVzZSB0aGUgb25lIGF0IHRoZSBvcmlnaW5hbCBtb2RlbC5cbiAgICAgICAgICAgIC8vIFdoeSBub3QgdGhlIGNsb3N1cmUgaXRlbUlEP1xuICAgICAgICAgICAgLy8gVGhlIElEIGNvdWxkIGdldCB1cGRhdGVkIGluIGEgc2F2ZSBwcm9jZXNzLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBhdXRvZ2VuZXJhdGluZyBvbmUgZm9yIGEgbmV3IGl0ZW0uXG4gICAgICAgICAgICB2YXIgb0l0ZW1JRCA9IG5ld0l0ZW1JRCB8fCB2ZXJzaW9uLm9yaWdpbmFsW3NldHRpbmdzLml0ZW1JZEZpZWxkXSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5nZXRJdGVtKG9JdGVtSUQsIGZvcmNlUmVtb3RlTG9hZClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5sYXN0RXJyb3IobnVsbCk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHZlcnNpb24ub3JpZ2luYWwubW9kZWwudXBkYXRlV2l0aChtb2RlbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8vLyBUcnkgc3luYywgaWYgb3JpZ2luYWwgaXMgbmV3ZXIgd2lsbCByZXBsYWNlIHZlcnNpb25cbiAgICAgICAgICAgICAgICAvL3ZlcnNpb24uc3luYygpO1xuICAgICAgICAgICAgICAgIC8vIHB1bGwgY2hhbmdlcyBmcm9tIHRoZSBuZXcgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLnB1bGwoeyBldmVudElmTmV3ZXI6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLnN0YXRlLmxhc3RFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHZlcnNpb24uc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2ZXJzaW9uLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICB2ZXJzaW9uLm9yaWdpbmFsLm1vZGVsLnJlc2V0KCk7XG4gICAgICAgICAgICB2ZXJzaW9uLnZlcnNpb24ubW9kZWwucmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZlcnNpb24uc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICAgICAgICB2ZXJzaW9uLnN0YXRlLmlzU2F2aW5nKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5zZXRJdGVtKHZlcnNpb24udmVyc2lvbilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5sYXN0RXJyb3IobnVsbCk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5pc1NhdmluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi52ZXJzaW9uLm1vZGVsLnVwZGF0ZVdpdGgobW9kZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIHB1c2ggY2hhbmdlcyB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLnB1c2goeyBldmVuSWZPYnNvbGV0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHZlcnNpb24uc3RhdGUubGFzdEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi5zdGF0ZS5pc1NhdmluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH07XG4gICAgXG4gICAgYXBpLm5ld0l0ZW1WZXJzaW9uID0gZnVuY3Rpb24gbmV3SXRlbVZlcnNpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gYXBpLmdldEl0ZW1WZXJzaW9uKCk7XG4gICAgICAgIC8vIEluaXRpYWwgZGF0YVxuICAgICAgICBpZiAodmFsdWVzKVxuICAgICAgICAgICAgdmVyc2lvbi52ZXJzaW9uLm1vZGVsLnVwZGF0ZVdpdGgodmFsdWVzLCB0cnVlKTtcbiAgICAgICAgLy8gVG8gYmUgc3VyZSB0aGF0IHRoZSB2ZXJzaW9uIGFwcGVhciBhcyBzb21ldGhpbmcgJ25ldycsIHVuc2F2ZWQsXG4gICAgICAgIC8vIHdlIHVwZGF0ZSBpdHMgdGltZXN0YW1wIHRvIGJlIGRpZmZlcmVudCB0byB0aGUgb3JpZ2luYWwuXG4gICAgICAgIHZlcnNpb24udmVyc2lvbi5tb2RlbC50b3VjaCgpO1xuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwUmVtb3RlTW9kZWw7XG5cbkdyb3VwUmVtb3RlTW9kZWwucHJvdG90eXBlLmFkZExvY2FsZm9yYWdlU3VwcG9ydCA9IGZ1bmN0aW9uIGFkZExvY2FsZm9yYWdlU3VwcG9ydChiYXNlTmFtZSkge1xuICAgIHZhciBsb2NhbGZvcmFnZSA9IHJlcXVpcmUoJ2xvY2FsZm9yYWdlJyk7XG5cbiAgICB0aGlzLmZldGNoSXRlbUZyb21Mb2NhbCA9IGZ1bmN0aW9uIGZldGNoRnJvbUxvY2FsKGl0ZW1JRCkge1xuICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2UuZ2V0SXRlbShiYXNlTmFtZSArIGl0ZW1JRCk7XG4gICAgfTtcbiAgICB0aGlzLnB1c2hJdGVtVG9Mb2NhbCA9IGZ1bmN0aW9uIHB1c2hUb0xvY2FsKGl0ZW1JRCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gbG9jYWxmb3JhZ2Uuc2V0SXRlbShiYXNlTmFtZSArIGl0ZW1JRCwgZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLnJlbW90ZUl0ZW1Gcm9tTG9jYWwgPSBmdW5jdGlvbiByZW1vdGVGcm9tTG9jYWwoaXRlbUlEKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5yZW1vdmVJdGVtKGJhc2VOYW1lICsgaXRlbUlEKTtcbiAgICB9O1xufTtcblxuR3JvdXBSZW1vdGVNb2RlbC5wcm90b3R5cGUuYWRkUmVzdFN1cHBvcnQgPSBmdW5jdGlvbiBhZGRSZXN0U3VwcG9ydChyZXN0Q2xpZW50LCBiYXNlVXJsKSB7XG5cbiAgICB0aGlzLmZldGNoSXRlbUZyb21SZW1vdGUgPSBmdW5jdGlvbiBmZXRjaEZyb21SZW1vdGUoaXRlbUlEKSB7XG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50LmdldChiYXNlVXJsICsgaXRlbUlEKTtcbiAgICB9O1xuICAgIHRoaXMucHVzaEl0ZW1Ub1JlbW90ZSA9IGZ1bmN0aW9uIHB1c2hUb1JlbW90ZShpdGVtSUQsIGRhdGEpIHtcblxuICAgICAgICB2YXIgbWV0aG9kID0gaXRlbUlEID8gJ3B1dCcgOiAncG9zdCc7XG5cbiAgICAgICAgdmFyIHVybCA9IGJhc2VVcmwgKyAoXG4gICAgICAgICAgICBpdGVtSUQgPyAnLycgKyBpdGVtSUQgOiAnJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdENsaWVudFttZXRob2RdKHVybCwgZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tUmVtb3RlID0gZnVuY3Rpb24gcmVtb3ZlSXRlbUZyb21SZW1vdGUoaXRlbUlEKSB7XG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50LmRlbGV0ZShiYXNlVXJsICsgaXRlbUlEKTtcbiAgICB9O1xufTtcbiIsIi8qKlxuICAgIEluZGV4ZWRHcm91cExpc3RDYWNoZSBtYW5hZ2VzIGEgaW4tbWVtb3J5IGNhY2hlIGZvciBhIGxpc3RcbiAgICBvZiBvYmplY3RzLCBncm91cGVkIGJ5IGEgZmllbGQgYW5kIHdpdGggaW5kZXhlZCBhY2Nlc3MgdG8gZ3JvdXBzXG4gICAgYW5kIGl0ZW1zLCB3aXRoIGNhY2hlIGNvbnRyb2wuXG4gICAgXG4gICAgU2V0dGluZ3Mgb2JqZWN0IGFzIHVuaXF1ZSBwYXJhbWV0ZXI6XG4gICAgbGlzdFR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgZm9yIGVhY2ggZ3JvdXAgbGlzdCBjYWNoZS5cbiAgICBGVVRVUkU6IGl0ZW1UdGw6IHR0bCB0eXBlIGNvbnN0cnVjdG9yLiBUaW1lVG9MaWZlIGZvciBlYWNoIGl0ZW0gY2FjaGUuXG4gICAgdHRsOiB0dGwgdHlwZSBjb25zdHJ1Y3Rvci4gVGltZVRvTGlmZSB0byB1c2UgZm9yIGxpc3QgYW5kIGl0ZW0gY2FjaGUgaWYgdGhlcmUgaXMgbm8gYSBtb3JlIGV4cGxpY2l0IG9uZVxuICAgIGdyb3VwSWRGaWVsZDogc3RyaW5nIE5hbWUgb2YgdGhlIGZpZWxkIHVzZWQgdG8gZ3JvdXAgb2JqZWN0c1xuICAgIGl0ZW1JZEZpZWxkOiBzdHJpbmcgTmFtZSBvZiB0aGUgZmllbGQgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBlYWNoIGl0ZW1cbiAgICBGVVRVUkU6IE1vZGVsOiBjb25zdHJ1Y3RvciBvZiB0eXBlIE1vZGVsLlxuICAgIFxuICAgIE5vdGU6ICd0dGwgdHlwZSBjb25zdHJ1Y3RvcicgY2FuIGJlIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciBhIHZhbHVlIHRvIHBhc3MgdG8gbW9tZW50LmR1cmF0aW9uIGNvbnN0cnVjdG9yIChtb21lbnRqcyBtb2R1bGUpLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWNoZUNvbnRyb2wgPSByZXF1aXJlKCcuL0NhY2hlQ29udHJvbCcpO1xuXG5mdW5jdGlvbiBjcmVhdGVJbmRleChsaXN0LCBieUZpZWxkKSB7XG4gICAgdmFyIGluZGV4ID0ge307XG4gICAgXG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGl0ZW1JbmRleCkge1xuICAgICAgICBpbmRleFtpdGVtW2J5RmllbGRdXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpdGVtSW5kZXgsXG4gICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgICAgICAvLyBEaXJlY3QgcmVmZXJlbmMsIGNvdWxkIGJlIGEgcHJvcGVydHkgdG9vIGF1dG8gcmVzb2x2aW5nIGFzXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgbGlrZSBnZXQgaXRlbSgpIHsgcmV0dXJuIGxpc3RbaXRlbUluZGV4W2l0ZW1bYnlGaWVsZF1dXSB8fCBudWxsOyB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkKHZhbCwgbXNnKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YodmFsKSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ1JlcXVpcmVkIHBhcmFtZXRlcicpO1xuICAgIGVsc2UgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gSW5kZXhlZEdyb3VwTGlzdENhY2hlKHNldHRpbmdzKSB7XG4gICAgXG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICBzZXR0aW5ncy50dGwgPSBzZXR0aW5ncy50dGwgfHwgMDtcbiAgICBzZXR0aW5ncy5saXN0VHRsID0gc2V0dGluZ3MubGlzdFR0bCB8fCBzZXR0aW5ncy50dGwgfHwgMDtcbiAgICAvL0ZVVFVSRTogc2V0dGluZ3MuaXRlbVR0bCA9IHNldHRpbmdzLml0ZW1UdGwgfHwgc2V0dGluZ3MudHRsIHx8IDA7XG4gICAgc2V0dGluZ3MuZ3JvdXBJZEZpZWxkID0gcmVxdWlyZWQoc2V0dGluZ3MuZ3JvdXBJZEZpZWxkLCAnZ3JvdXBJZEZpZWxkIGlzIHJlcXVpcmVkJyk7XG4gICAgc2V0dGluZ3MuaXRlbUlkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5pdGVtSWRGaWVsZCwgJ2l0ZW1JZEZpZWxkIGlzIHJlcXVpcmVkJyk7XG4gICAgLy9GVVRVUkU6IHNldHRpbmdzLk1vZGVsID0gc2V0dGluZ3MuTW9kZWwgfHwgdGhyb3cgbmV3IEVycm9yKCdBIE1vZGVsIGlzIHJlcXVpcmVkJyk7XG4gICAgXG4gICAgdmFyIGNhY2hlID0gey8qXG4gICAgICAgIGdyb3VwSWRGaWVsZDoge1xuICAgICAgICAgICAgY29udHJvbDogQ2FjaGVDb250cm9sLFxuICAgICAgICAgICAgbGlzdDogQXJyYXksXG4gICAgICAgICAgICBpbmRleDoge1xuICAgICAgICAgICAgICAgIGl0ZW1JZEZpZWxkOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBJbnRlZ2VyIChpbmRleCBpbiB0aGUgbGlzdCBhcnJheSksXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IE9iamVjdCAocmVmZXJlbmNlIHRvIHRoZSBpdGVtIG9iamVjdCBpbiB0aGUgYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIGZ1dHVyZTogY29udHJvbDogQ2FjaGVDb250cm9sIHBlciBpdGVtXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLlxuICAgICovfTtcbiAgICBcbiAgICB0aGlzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgICBjYWNoZSA9IHt9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBuZXdDYWNoZUVudHJ5KGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRyb2w6IG5ldyBDYWNoZUNvbnRyb2woeyB0dGw6IHNldHRpbmdzLmxpc3RUdGwgfSksXG4gICAgICAgICAgICBsaXN0OiBsaXN0IHx8IG51bGwsXG4gICAgICAgICAgICBpbmRleDogbGlzdCAmJiBjcmVhdGVJbmRleChsaXN0LCBzZXR0aW5ncy5pdGVtSWRGaWVsZCkgfHwge31cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRHcm91cENhY2hlKGdyb3VwSUQsIGxpc3QpIHtcbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSBjYWNoZVtncm91cElEXTtcbiAgICAgICAgaWYgKGNhY2hlRW50cnkpIHtcbiAgICAgICAgICAgIGNhY2hlRW50cnkubGlzdCA9IGxpc3QgfHwgW107XG4gICAgICAgICAgICBjYWNoZUVudHJ5LmluZGV4ID0gY3JlYXRlSW5kZXgobGlzdCB8fCBbXSwgc2V0dGluZ3MuaXRlbUlkRmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVFbnRyeSA9IGNhY2hlW2dyb3VwSURdID0gbmV3Q2FjaGVFbnRyeShsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZUVudHJ5LmNvbnRyb2wubGF0ZXN0ID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXRHcm91cENhY2hlID0gc2V0R3JvdXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAgICBHZXQgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgR3JvdXBcbiAgICAqKi9cbiAgICBmdW5jdGlvbiBnZXRHcm91cENhY2hlKGdyb3VwSUQpIHtcbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSBjYWNoZVtncm91cElEXTtcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkgfHwgbmV3Q2FjaGVFbnRyeSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmdldEdyb3VwQ2FjaGUgPSBnZXRHcm91cENhY2hlO1xuXG4gICAgLyoqXG4gICAgICAgIEdldCB0aGUgY2FjaGUgZW50cnkgZnJvbSB0aGUgSXRlbVxuICAgICoqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZW1DYWNoZShncm91cElELCBpdGVtSUQpIHtcbiAgICAgICAgdmFyIGNhY2hlRW50cnkgPSBjYWNoZVtncm91cElEXTtcbiAgICAgICAgaWYgKGNhY2hlRW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZGV4W2l0ZW1JRF0gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZ2V0SXRlbUNhY2hlID0gZ2V0SXRlbUNhY2hlO1xuXG4gICAgZnVuY3Rpb24gc2V0SXRlbUNhY2hlKGdyb3VwSUQsIGl0ZW1JRCwgaXRlbSkge1xuICAgICAgICB2YXIgY2FjaGVFbnRyeSA9IGNhY2hlW2dyb3VwSURdIHx8IG5ld0NhY2hlRW50cnkoW10pO1xuICAgICAgICBcbiAgICAgICAgLy8gTG9vZiBmb3IgdGhlIGVudHJ5LCB0byB1cGRhdGUgb3IgaW5zZXJ0IGEgbmV3IG9uZVxuICAgICAgICB2YXIgaXRlbUVudHJ5ID0gY2FjaGVFbnRyeS5pbmRleFtpdGVtSURdO1xuICAgICAgICBpZiAoaXRlbUVudHJ5KSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZW50cnlcbiAgICAgICAgICAgIGNhY2hlRW50cnkubGlzdFtpdGVtRW50cnkuaW5kZXhdID0gaXRlbTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2UgaW4gdGhlIGluZGV4IHRvbyAoaXMgbm90IGNvbXB1dGVkIHJpZ2h0IG5vdylcbiAgICAgICAgICAgIGl0ZW1FbnRyeS5pdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgbGlzdFxuICAgICAgICAgICAgdmFyIGl0ZW1JbmRleCA9IGNhY2hlRW50cnkubGlzdC5wdXNoKGl0ZW0pIC0gMTtcbiAgICAgICAgICAgIGNhY2hlRW50cnkuaW5kZXhbaXRlbUlEXSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaXRlbUluZGV4LFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXRJdGVtQ2FjaGUgPSBzZXRJdGVtQ2FjaGU7XG5cbiAgICBmdW5jdGlvbiBkZWxJdGVtQ2FjaGUoZ3JvdXBJRCwgaXRlbUlEKSB7XG4gICAgICAgIHZhciBncm91cEVudHJ5ID0gY2FjaGVbZ3JvdXBJRF0gfHwgbnVsbDtcbiAgICAgICAgaWYgKGdyb3VwRW50cnkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtRW50cnkgPSBncm91cEVudHJ5LmluZGV4W2l0ZW1JRF07XG4gICAgICAgICAgICBpZiAoaXRlbUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxpc3QgcmVtb3ZpbmcgdGhlIGVsZW1lbnQgaW4gcGxhY2UsIHdpdGhvdXQgaG9sZXNcbiAgICAgICAgICAgICAgICBncm91cEVudHJ5Lmxpc3Quc3BsaWNlKGl0ZW1FbnRyeS5pbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGluZGV4IGJ5OlxuICAgICAgICAgICAgICAgIC8vIC0gUmVtb3ZlIGl0ZW1JRCBlbnRyeVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBncm91cEVudHJ5LmluZGV4W2l0ZW1JRF07XG4gICAgICAgICAgICAgICAgLy8gLSBVcGRhdGUgZXZlcnkgZW50cnkgd2l0aCBhbiBJRCBncmVhdGVyIHRoYW4gdGhlIHVwZGF0ZWQsXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgbm93IG9uZSBwb3NpdGlvbiBsZXNzIGluIHRoZSB1cGRhdGVkIGxpc3RcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhncm91cEVudHJ5LmluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBFbnRyeS5pbmRleFtrZXldLmluZGV4ID4gaXRlbUVudHJ5LmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbnRyeS5pbmRleFtrZXldLmluZGV4LS07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5kZWxJdGVtQ2FjaGUgPSBkZWxJdGVtQ2FjaGU7XG4gICAgXG4gICAgZnVuY3Rpb24gZGVsR3JvdXBDYWNoZShncm91cElEKSB7XG4gICAgICAgIHZhciBncm91cEVudHJ5ID0gY2FjaGVbZ3JvdXBJRF0gfHwgbnVsbDtcbiAgICAgICAgaWYgKGdyb3VwRW50cnkpIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgZW50cnkvcHJvcGVydHlcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtncm91cElEXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmRlbEdyb3VwQ2FjaGUgPSBkZWxHcm91cENhY2hlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWRHcm91cExpc3RDYWNoZTtcbiIsIi8qKlxuICAgIEluZGV4ZWRMaXN0Q2FjaGUgbWFuYWdlcyBhIGluLW1lbW9yeSBjYWNoZSBmb3IgYSBsaXN0XG4gICAgb2Ygb2JqZWN0cywgd2l0aCBpbmRleGVkIGFjY2VzcyB0byBpdGVtc1xuICAgIGFuZCBjYWNoZSBjb250cm9sLlxuICAgIFxuICAgIFNldHRpbmdzIG9iamVjdCBhcyB1bmlxdWUgcGFyYW1ldGVyOlxuICAgIGxpc3RUdGw6IHR0bCB0eXBlIGNvbnN0cnVjdG9yLiBUaW1lVG9MaWZlIGZvciBlYWNoIGdyb3VwIGxpc3QgY2FjaGUuXG4gICAgRlVUVVJFOiBpdGVtVHRsOiB0dGwgdHlwZSBjb25zdHJ1Y3Rvci4gVGltZVRvTGlmZSBmb3IgZWFjaCBpdGVtIGNhY2hlLlxuICAgIHR0bDogdHRsIHR5cGUgY29uc3RydWN0b3IuIFRpbWVUb0xpZmUgdG8gdXNlIGZvciBsaXN0IGFuZCBpdGVtIGNhY2hlIGlmIHRoZXJlIGlzIG5vIGEgbW9yZSBleHBsaWNpdCBvbmVcbiAgICBpdGVtSWRGaWVsZDogc3RyaW5nIE5hbWUgb2YgdGhlIGZpZWxkIHVzZWQgdG8gdW5pcXVlbHkgaWRlbnRpZnkgZWFjaCBpdGVtXG4gICAgTW9kZWw6IGNvbnN0cnVjdG9yIG9mIHR5cGUgTW9kZWwuXG4gICAgXG4gICAgTm90ZTogJ3R0bCB0eXBlIGNvbnN0cnVjdG9yJyBjYW4gYmUgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIGEgdmFsdWUgdG8gcGFzcyB0byBtb21lbnQuZHVyYXRpb24gY29uc3RydWN0b3IgKG1vbWVudGpzIG1vZHVsZSkuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIENhY2hlQ29udHJvbCA9IHJlcXVpcmUoJy4vQ2FjaGVDb250cm9sJyksXG4gICAganNQcm9wZXJ0aWVzVG9vbHMgPSByZXF1aXJlKCcuL2pzUHJvcGVydGllc1Rvb2xzJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVtSW5kZXhFbnRyeShsaXN0LCBpdGVtSW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogaXRlbUluZGV4LFxuICAgICAgICBnZXQgaXRlbSgpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0W3RoaXMuaW5kZXhdO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgobGlzdCwgYnlGaWVsZCkge1xuICAgIHZhciBpbmRleCA9IHt9O1xuICAgIFxuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpdGVtSW5kZXgpIHtcbiAgICAgICAgaW5kZXhba28udW53cmFwKGl0ZW1bYnlGaWVsZF0pXSA9IGNyZWF0ZUl0ZW1JbmRleEVudHJ5KGxpc3QsIGl0ZW1JbmRleCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkKHZhbCwgbXNnKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YodmFsKSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ1JlcXVpcmVkIHBhcmFtZXRlcicpO1xuICAgIGVsc2UgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gICAgQW4gaXRlbSBhZGFwdGVyIHJlY2VpdmVzIHRoZSBvbGQgYW5kIHRoZSBuZXcgaXRlbSBkYXRhIGFuZCByZXR1cm5zXG4gICAgdGhlIGl0ZW0gdG8gaG9sZCBpbiB0aGUgbGlzdC4gVGhlIHJldHVybmluZyBvYmplY3QgY2FuIGJlIGEgcmVmZXJlbmNlXG4gICAgdG8gdGhlIHNhbWUgZXhpc3RlbnQgb2JqZWN0IChvbGRJdGVtKSB0aGF0IGdldHMgdXBkYXRlZCB3aXRoIHRoZSBcbiAgICBuZXcgdmFsdWVzIChuZXdJdGVtKSwgb3IganVzdCB0aGUgbmV3SXRlbSBvciBhbnkgY29udmVyc2lvbiBvdmVyIHRoZVxuICAgIHJhdyBuZXdJdGVtIGRhdGEuXG4gICAgVGhpcyBhbGxvd3MgdG8gcGVyZm9ybSBjaGFuZ2VzLCBhZGQgcHJvcGVydGllcywgb3Iga2VlcCByZWZlcmVuY2VzLFxuICAgIGxpa2UgY3JlYXRpbmcgb2JzZXJ2YWJsZXMsIE1vZGVscy5cbiAgICBcbiAgICBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIHRoZSBuZXdJdGVtLlxuKiovXG5mdW5jdGlvbiBkZWZhdWx0SXRlbUFkYXB0ZXIob2xkSXRlbSwgbmV3SXRlbSkge1xuICAgIHJldHVybiBuZXdJdGVtO1xufVxuXG5mdW5jdGlvbiBJbmRleGVkTGlzdENhY2hlKHNldHRpbmdzKSB7XG4gICAgXG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICBzZXR0aW5ncy50dGwgPSBzZXR0aW5ncy50dGwgfHwgMDtcbiAgICBzZXR0aW5ncy5saXN0VHRsID0gc2V0dGluZ3MubGlzdFR0bCB8fCBzZXR0aW5ncy50dGwgfHwgMDtcbiAgICAvL0ZVVFVSRTogc2V0dGluZ3MuaXRlbVR0bCA9IHNldHRpbmdzLml0ZW1UdGwgfHwgc2V0dGluZ3MudHRsIHx8IDA7XG4gICAgc2V0dGluZ3MuaXRlbUlkRmllbGQgPSByZXF1aXJlZChzZXR0aW5ncy5pdGVtSWRGaWVsZCwgJ2l0ZW1JZEZpZWxkIGlzIHJlcXVpcmVkJyk7XG4gICAgc2V0dGluZ3MuaXRlbUFkYXB0ZXIgPSB0eXBlb2Yoc2V0dGluZ3MuaXRlbUFkYXB0ZXIpID09PSAnZnVuY3Rpb24nID8gc2V0dGluZ3MuaXRlbUFkYXB0ZXIgOiBkZWZhdWx0SXRlbUFkYXB0ZXI7XG5cbiAgICAvLyBJbnRlcm5hbCBmbGFnIHRvIG5vdGlmeSBpZiB0aGUgY2FjaGUgd2FzIG5vdCB1c2VkIHN0aWxsIChubyBkYXRhIHNldClcbiAgICAvLyBzaW5jZSBpdHMgaW5zdGFudGlhdGlvbi4gT24gZmlyc3Qgc2V0TGlzdCB3aWxsIGNoYW5nZSB0byBmYWxzZSBhbmQga2VlcCBpbiB0aGF0IHN0YXRlLlxuICAgIHZhciB1bnVzZWQgPSB0cnVlO1xuICAgIC8vIEludGVybmFsIGNhY2hlIG1hbmFnZW1lbnRcbiAgICB2YXIgY2FjaGUgPSB7XG4gICAgICAgIGNvbnRyb2w6IG5ldyBDYWNoZUNvbnRyb2woeyB0dGw6IHNldHRpbmdzLmxpc3RUdGwgfSksXG4gICAgICAgIGxpc3Q6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgIGluZGV4OiB7LypcbiAgICAgICAgICAgIGl0ZW1JZEZpZWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IEludGVnZXIgKGluZGV4IGluIHRoZSBsaXN0IGFycmF5KSxcbiAgICAgICAgICAgICAgICBpdGVtOiBPYmplY3QgKHByb3BlcnR5IHJlZmVyZW5jaW5nIHRvIHRoZSBpdGVtIG9iamVjdCBpbiB0aGUgYXJyYXkgYnkgaXRzIGluZGV4KVxuICAgICAgICAgICAgICAgIC8vIE1heWJlIGZ1dHVyZTogY29udHJvbDogQ2FjaGVDb250cm9sIHBlciBpdGVtXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi5cbiAgICAgICAgKi99XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgICBjYWNoZS5jb250cm9sLmxhdGVzdCA9IG51bGw7XG4gICAgICAgIGNhY2hlLmxpc3QoW10pO1xuICAgICAgICBjYWNoZS5pbmRleCA9IHt9O1xuICAgICAgICB1bnVzZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgR2V0IHRoZSBjYWNoZSBlbnRyeSBmcm9tIHRoZSBJdGVtXG4gICAgKiovXG4gICAgZnVuY3Rpb24gZ2V0SXRlbUNhY2hlKGl0ZW1JRCkge1xuICAgICAgICByZXR1cm4gY2FjaGUuaW5kZXhbaXRlbUlEXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0SXRlbUNhY2hlID0gZ2V0SXRlbUNhY2hlO1xuXG4gICAgLy8gQWRhcHQgYSBuZXcgaXRlbSB1c2luZyB0aGUgaXRlbUFkYXB0ZXIgYW5kIGdldHRpbmcgdGhlIG9sZCByZWZlcmVuY2UuXG4gICAgZnVuY3Rpb24gYWRhcHRJdGVtKG5ld0l0ZW0pIHtcbiAgICAgICAgdmFyIG9sZEl0ZW0gPSBnZXRJdGVtQ2FjaGUoa28udW53cmFwKG5ld0l0ZW1bc2V0dGluZ3MuaXRlbUlkRmllbGRdKSk7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5pdGVtQWRhcHRlcihvbGRJdGVtLCBuZXdJdGVtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRhcHQgdGhlIGVhY2ggZWxlbWVudCBpbiB0aGUgbGlzdCB3aXRoIHRoZSBpdGVtQWRhcHRlcixcbiAgICAvLyBwYXNzaW5nIGFuIG9sZCByZWZlcmVuY2UgYW5kIHRoZSBuZXcgaXRlbSBvbiBlYWNoLCBhbmQgZW5zdXJpbmdcbiAgICAvLyB0byByZXR1cm4gZXZlciBhbiBhcnJheSwgZXZlbiBpZiBlbXB0eS5cbiAgICBmdW5jdGlvbiBhZGFwdExpc3QobGlzdCkge1xuICAgICAgICByZXR1cm4gKGxpc3QgfHwgW10pLm1hcChhZGFwdEl0ZW0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldExpc3QobGlzdCkge1xuICAgICAgICBjYWNoZS5saXN0KGFkYXB0TGlzdChsaXN0KSk7XG4gICAgICAgIGNhY2hlLmluZGV4ID0gY3JlYXRlSW5kZXgoY2FjaGUubGlzdCgpLCBzZXR0aW5ncy5pdGVtSWRGaWVsZCk7XG4gICAgICAgIGNhY2hlLmNvbnRyb2wubGF0ZXN0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdW51c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUHVibGljLCByZWFkLW9ubHksIGFjY2VzcyB0byBjYWNoZSBpbmZvIChvYmplY3RzIGFyZSBtdXRhYmxlLCBidXQgYWxtb3N0IHRoZSByZWZlcmVuY2VcbiAgICAvLyBjYW5ub3QgYmUgYnJva2VuOyBhIGNoYW5nZSBpbiB0aGUgbGlzdCBpbnN0YW5jZSB1cGRhdGVzIHRoZSBjYWNoZSBwcm9wZXJseSkuXG4gICAganNQcm9wZXJ0aWVzVG9vbHMuZGVmaW5lR2V0dGVyKHRoaXMsICdjb250cm9sJywgZnVuY3Rpb24oKSB7IHJldHVybiBjYWNoZS5jb250cm9sOyB9KTtcbiAgICBqc1Byb3BlcnRpZXNUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ2xpc3QnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhY2hlLmxpc3Q7IH0pO1xuICAgIGpzUHJvcGVydGllc1Rvb2xzLmRlZmluZVNldHRlcih0aGlzLCAnbGlzdCcsIGZ1bmN0aW9uKGxpc3QpIHsgcmV0dXJuIHNldExpc3QobGlzdCk7IH0pO1xuICAgIGpzUHJvcGVydGllc1Rvb2xzLmRlZmluZUdldHRlcih0aGlzLCAnaW5kZXgnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhY2hlLmluZGV4OyB9KTtcbiAgICBqc1Byb3BlcnRpZXNUb29scy5kZWZpbmVHZXR0ZXIodGhpcywgJ3VudXNlZCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdW51c2VkOyB9KTtcblxuICAgIGZ1bmN0aW9uIHNldEl0ZW1DYWNoZShpdGVtKSB7XG4gICAgICAgIHZhciBpdGVtSUQgPSBrby51bndyYXAoaXRlbVtzZXR0aW5ncy5pdGVtSWRGaWVsZF0pO1xuICAgICAgICAvLyBMb29rIGZvciB0aGUgZW50cnksIHRvIHVwZGF0ZSBvciBpbnNlcnQgYSBuZXcgb25lXG4gICAgICAgIHZhciBpdGVtRW50cnkgPSBjYWNoZS5pbmRleFtpdGVtSURdO1xuICAgICAgICBpZiAoaXRlbUVudHJ5KSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZW50cnlcbiAgICAgICAgICAgIGNhY2hlLmxpc3QoKVtpdGVtRW50cnkuaW5kZXhdID0gYWRhcHRJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICB2YXIgaXRlbUluZGV4ID0gY2FjaGUubGlzdC5wdXNoKGFkYXB0SXRlbShpdGVtKSkgLSAxO1xuICAgICAgICAgICAgY2FjaGUuaW5kZXhbaXRlbUlEXSA9IGNyZWF0ZUl0ZW1JbmRleEVudHJ5KGNhY2hlLmxpc3QoKSwgaXRlbUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0SXRlbUNhY2hlID0gc2V0SXRlbUNhY2hlO1xuXG4gICAgZnVuY3Rpb24gZGVsSXRlbUNhY2hlKGl0ZW1JRCkge1xuICAgICAgICB2YXIgaXRlbUVudHJ5ID0gY2FjaGUuaW5kZXhbaXRlbUlEXTtcbiAgICAgICAgaWYgKGl0ZW1FbnRyeSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxpc3QgcmVtb3ZpbmcgdGhlIGVsZW1lbnQgaW4gcGxhY2UsIHdpdGhvdXQgaG9sZXNcbiAgICAgICAgICAgIGNhY2hlLmxpc3Quc3BsaWNlKGl0ZW1FbnRyeS5pbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgaW5kZXggYnk6XG4gICAgICAgICAgICAvLyAtIFJlbW92ZSBpdGVtSUQgZW50cnlcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZS5pbmRleFtpdGVtSURdO1xuICAgICAgICAgICAgLy8gLSBVcGRhdGUgZXZlcnkgZW50cnkgd2l0aCBhbiBJRCBncmVhdGVyIHRoYW4gdGhlIHVwZGF0ZWQsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSBub3cgb25lIHBvc2l0aW9uIGxlc3MgaW4gdGhlIHVwZGF0ZWQgbGlzdFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY2FjaGUuaW5kZXgpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlLmluZGV4W2tleV0uaW5kZXggPiBpdGVtRW50cnkuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmluZGV4W2tleV0uaW5kZXgtLTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZGVsSXRlbUNhY2hlID0gZGVsSXRlbUNhY2hlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWRMaXN0Q2FjaGU7XG4iLCIvKipcbiAgICBMaXN0UmVtb3RlTW9kZWxcbiAgICBVdGlsaXR5IGNsYXNzIGZvciBjb21tb24gY29kZSBmb3IgYSBkYXRhIGxpc3QgZW50aXR5IGZyb20gYSByZW1vdGUgc291cmNlLFxuICAgIHdpdGggbG9jYWwgY29weSBhbmQgY2FjaGUsIHdoZXJlIHRoZSBsaXN0IGlzIG1hbmFnZWQgd2lsbCBhbGwgdGhlIGRhdGEsXG4gICAgd2l0aG91dCBwYWdpbmcvY3Vyc29yLCB3aXRoIGluZGV4ZWQgYWNjZXNzIHRvIGVhY2ggaXRlbSBieSBpdHMgSUQuXG4gICAgSXMgZ29vZCBmb3IgbGlzdHMgdGhhdCBrZWVwIHNtYWxsIGluIHRoZSB0aW1lLlxuICAgIFxuICAgIFRPRE8gSU1QT1JUQU5UIFRoZSBnZXRMaXN0IG1ldGhvZCwgcmV1c2VkIGFzIHN5bmMsIGlzIHJldHVybmluZyBhbiBvYnNlcnZhYmxlIHJhdGhlclxuICAgIHRoYW4gZGlyZWN0IGRhdGEuIFRoZXJlIGFyZSB1c2VzIHJpZ2h0IG5vdywgZG91YmxlIGNoZWNrIGlmIHRoaXMgY2hhcyBhbnkgc2Vuc2UgYW5kIHVwZGF0ZVxuICAgIGFmZmVjdGVkIGNvZGUuXG4gICAgXG4gICAgVE9ETyBUbyBpbXBsZW1lbnQgc2luZ2xlIGl0ZW0gdXBkYXRlIG1vZGUsIG5vdCBmdWxsIGxpc3QgZWFjaCB0aW1lLCBieSBzZXQtdXAgb3IgbWV0aG9kXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBJbmRleGVkTGlzdENhY2hlID0gcmVxdWlyZSgnLi9JbmRleGVkTGlzdENhY2hlJyk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkKHZhbCwgbXNnKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YodmFsKSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ1JlcXVpcmVkIHBhcmFtZXRlcicpO1xuICAgIGVsc2UgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gTGlzdFJlbW90ZU1vZGVsKHNldHRpbmdzKSB7XG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czo1MCovXG5cbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgIHNldHRpbmdzLmxpc3RUdGwgPSByZXF1aXJlZChzZXR0aW5ncy5saXN0VHRsLCAnbGlzdFR0bCBpcyByZXF1aXJlZCcpO1xuICAgIHNldHRpbmdzLml0ZW1JZEZpZWxkID0gcmVxdWlyZWQoc2V0dGluZ3MuaXRlbUlkRmllbGQsICdpdGVtSWRGaWVsZCBpcyByZXF1aXJlZCcpO1xuICAgIC8vIE9wdGlvbmFsIG1vZGVsXG4gICAgc2V0dGluZ3MuTW9kZWwgPSBzZXR0aW5ncy5Nb2RlbCB8fCBudWxsO1xuICAgIC8vIFJlcXVpcmVkIGZvciBBUEkgYWRkaXRpb25zXG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaXNMb2FkaW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgaXNTeW5jaW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgaXNTYXZpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICBpc0RlbGV0aW5nOiBrby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgIH07XG4gICAgXG4gICAgLy8gSXRlbXMgYXJlIG1hbmFnZWQgYXMgcGxhaW4gb2JqZWN0IGJ5IGRlZmF1bHQsIGJ1dCBhcyBwZXJtYW5lbnQsIHVwZGF0ZWRcbiAgICAvLyBtb2RlbCBpbnN0YW5jZXMgaWYgdGhlIE1vZGVsIGNsYXNzIHdhcyBzcGVjaWZpZWQuXG4gICAgLy8gVGhpcyBhZGFwdGVyIGlzIHBhc3NlZCB0byB0aGUgY2FjaGUgY29uc3RydWN0b3IgdG9vIGtlZXAgdGhlIGluLW1lbW9yeVxuICAgIC8vIG9iamVjdHMgdXAgdG8gZGF0ZSB3aXRoIHRoZSBjb3JyZWN0IHN0cnVjdHVyZS5cbiAgICBmdW5jdGlvbiBpdGVtQWRhcHRlcihvbGRJdGVtLCBuZXdJdGVtKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5Nb2RlbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG1vZGVsIGl0ZW0gYWxyZWFkeSBleGlzdHMsIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChvbGRJdGVtICYmIG9sZEl0ZW0gaW5zdGFuY2VvZiBzZXR0aW5ncy5Nb2RlbCkge1xuICAgICAgICAgICAgICAgIG9sZEl0ZW0ubW9kZWwudXBkYXRlV2l0aChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkSXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5ldyBjcmVhdGVkIGl0ZW0uXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXMsIG5vLW1vZGVsLCB2YWx1ZSwgdGhleSBhcmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgLy8gKHRoYXQgc2l0dWF0aW9uIGNhbiBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgYXJlIGlycmVndWxhciBtb2RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIGludGVybmFsIGJlaGF2aW9yKS5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNldHRpbmdzLk1vZGVsKG5ld0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0l0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIGNhY2hlID0gbmV3IEluZGV4ZWRMaXN0Q2FjaGUoe1xuICAgICAgICBsaXN0VHRsOiBzZXR0aW5ncy5saXN0VHRsLFxuICAgICAgICBpdGVtSWRGaWVsZDogc2V0dGluZ3MuaXRlbUlkRmllbGQsXG4gICAgICAgIGl0ZW1BZGFwdGVyOiBpdGVtQWRhcHRlclxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuY2xlYXJDYWNoZSA9IGNhY2hlLmNsZWFyQ2FjaGU7XG5cbiAgICB0aGlzLnN0YXRlLmlzTG9ja2VkID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xvYWRpbmcoKSB8fCB0aGlzLmlzU2F2aW5nKCkgfHwgdGhpcy5pc0RlbGV0aW5nKCk7XG4gICAgfSwgdGhpcy5zdGF0ZSk7XG5cbiAgICAvKiogRGF0YSBTdG9yZXMgTWFuYWdlbWVudDogaW1wbGVtZW50YXRpb24gbXVzdCBiZSByZXBsYWNlZCwgd2l0aCBjdXN0b20gY29kZSBvciB1c2luZ1xuICAgICAgICB0aGUgaGVscGVycyBhZGRlZCB0byB0aGUgY2xhc3MgKHNlZSBhZGRYeFN1cHBvcnQgcHJvdG90eXBlIG1ldGhvZHMpLlxuICAgICoqL1xuICAgIGZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpOyB9XG4gICAgdGhpcy5mZXRjaExpc3RGcm9tTG9jYWwgPSBub3RJbXBsZW1lbnRlZDtcbiAgICB0aGlzLmZldGNoTGlzdEZyb21SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcbiAgICB0aGlzLnB1c2hMaXN0VG9Mb2NhbCA9IG5vdEltcGxlbWVudGVkO1xuICAgIHRoaXMucHVzaExpc3RUb1JlbW90ZSA9IG5vdEltcGxlbWVudGVkO1xuICAgIHRoaXMucmVtb3ZlSXRlbUZyb21SZW1vdGUgPSBub3RJbXBsZW1lbnRlZDtcbiAgICBcbiAgICAvKipcbiAgICAgICAgUmV0cmlldmVzIGEgcGxhaW4gYXJyYXktb2JqZWN0cyBmcm9tIHRoZSBjYWNoZWQgbGlzdFxuICAgICoqL1xuICAgIGZ1bmN0aW9uIGdldFBsYWluQ2FjaGVkTGlzdCgpIHtcbiAgICAgICAgdmFyIGFyciA9IGNhY2hlLmxpc3QoKTtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgc2V0dGluZ3MuTW9kZWwgJiYgaXRlbSBpbnN0YW5jZW9mIHNldHRpbmdzLk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubW9kZWwudG9QbGFpbk9iamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBBUEkgZGVmaW5pdGlvbiAqKi9cbiAgICB2YXIgYXBpID0gdGhpcztcbiAgICBcbiAgICAvLyBEaXJlY3QgYWNjZXNzIHRvIHRoZSBvYnNlcnZhYmxlIGNhY2hlZCBsaXN0LlxuICAgIGFwaS5saXN0ID0gY2FjaGUubGlzdDtcblxuICAgIC8vIEN1cnJlbnRseSwganVzdCBhIHdyYXBwZXIgZm9yIGdldExpc3QuXG4gICAgYXBpLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICByZXR1cm4gYXBpLmdldExpc3QoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICAgIFByb21pc2UgYmFzZWQgcmVxdWVzdCB0byBnZXQgdGhlIGxpc3QgKGZyb20gY2FjaGUsIGxvY2FsIG9yIHJlbW90ZSkuXG4gICAgICAgIEl0IHVwZGF0ZXMgdGhlIG9ic2VydmFibGUgbGlzdCBpZiBuZXcgZGF0YSBpcyBmZXRjaGVkLlxuICAgICAgICBBIGdlbmVyYWwgYXBwcm9hY2ggaXMgdG8gdXNlIHRoZSBvYnNlcnZhYmxlIGxpc3QgYW5kIGNhbGwgdGhlICdzeW5jJyBtZXRob2RcbiAgICAgICAgcmF0aGVyIHRoYW4gd2FpdCB0aGlzIHByb21pc2UgdG8gZmluaXNoICgnc3luYycgcGVyZm9ybXMgdGhpcyBsb2FkIHJlYWxseSkuXG4gICAgKiovXG4gICAgYXBpLmdldExpc3QgPSBmdW5jdGlvbiBnZXRMaXN0KCkge1xuXG4gICAgICAgIGlmIChjYWNoZS5jb250cm9sLm11c3RSZXZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIENhY2hlIHN0aWxsIG5vdCB1c2VkLCB0aGVuIGlzIGZpcnN0IGxvYWQsIHRyeSBsb2FkIGZyb20gbG9jYWxcbiAgICAgICAgICAgIGlmIChjYWNoZS51bnVzZWQpIHtcbiAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIEZyb20gbG9jYWxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaExpc3RGcm9tTG9jYWwoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGF1bmNoIHJlbW90ZSBmb3Igc3luY1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlUHJvbWlzZSA9IHRoaXMuZmV0Y2hMaXN0RnJvbVJlbW90ZSgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmxpc3QgPSBzZXJ2ZXJEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTGlzdFRvTG9jYWwoc2VydmVyRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBsb2NhbCBkYXRhLCBjYXRjaCBlcnJvciBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3luYyBzaW5jZSB0aGlzIHByb21pc2Ugd2lsbCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIGF2YWlsYWJsZSB0byBhbnkgY29uc3VtZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9nIHRvIGNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMaXN0UmVtb3RlTW9kZWw6IHJlbW90ZSBzeW5jaHJvbml6YXRpb24gZmFpbGVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvbWlzZSBpcyByZXR1cm5lZCBzbyB3aWxsIGJlIGNvbnN1bWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmV0aHJvdyBhbmQgbGV0IHRoZSBvdGhlciBjYXRjaC1ibG9ja3MgZG8gdGhlIGNvbW1vbiBzdHVmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdGUgZmFsbGJhY2s6IElmIG5vIGxvY2FsLCB3YWl0IGZvciByZW1vdGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhIDogcmVtb3RlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyIGEgbGlzdCwgZXZlbiBpZiBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUubGlzdCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaExpc3RUb0xvY2FsKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUubGlzdDtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzU3luY2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBGcm9tIHJlbW90ZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoTGlzdEZyb21SZW1vdGUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlciBhIGxpc3QsIGV2ZW4gaWYgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmxpc3QgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMaXN0VG9Mb2NhbChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnN0YXRlLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc1N5bmNpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5saXN0O1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5zdGF0ZS5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuc3RhdGUuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRnJvbSBjYWNoZVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZS5saXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgYXBpLmdldEl0ZW0gPSBmdW5jdGlvbiBnZXRJdGVtKGl0ZW1JRCkge1xuICAgICAgICAvLyBJTVBPUlRBTlQ6IFRvIHNpbXBsaWZ5LCBsb2FkIGFsbCB0aGUgbGlzdCAoaXMgYSBzaG9ydCBsaXN0KVxuICAgICAgICAvLyBhbmQgbG9vayBmcm9tIGl0cyBjYWNoZWQgaW5kZXhcbiAgICAgICAgLy8gVE9ETyBJbXBsZW1lbnQgaXRlbSBzZXJ2ZXIgbG9vay11cC4gQmUgY2FyZWZ1bCB3aXRoIGNhY2hlIHVwZGF0ZSxcbiAgICAgICAgLy8gbGlzdCBzb3J0aW5nIGFuZCBzdGF0ZSBmbGFncy5cbiAgICAgICAgcmV0dXJuIGFwaS5nZXRMaXN0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBHZXQgZnJvbSBjYWNoZWQgaW5kZXhcbiAgICAgICAgICAgIHZhciBjYWNoZUl0ZW0gPSBjYWNoZS5nZXRJdGVtQ2FjaGUoaXRlbUlEKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogRW5oYW5jZSBvbiBmdXR1cmUgd2l0aCBhY3R1YWwgbG9vay11cCBieSBBUEkgaXRlbUlEXG4gICAgICAgICAgICAvLyBpZiBub3QgY2FjaGVkLCB0aHJvd2luZyBub3QgZm91bmQgZnJvbSB0aGUgc2VydmVyIChqdXN0IHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBtaW5vciBjYXNlcyB3aGVuIGEgbmV3IGl0ZW0gaXMgbm90IHN0aWxsIGluIHRoZSBjYWNoZSBpZiBsaW5rZWRcbiAgICAgICAgICAgIC8vIGZyb20gb3RoZXIgYXBwIGRhdGEpLiBBbmQga2VlcCB1cGRhdGVkIGxpc3QgY2FjaGUgd2l0aCB0aGF0XG4gICAgICAgICAgICAvLyBpdGVtcyBsb29rdXBcbiAgICAgICAgICAgIGlmICghY2FjaGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMaXN0UmVtb3RlTW9kZWwgTm90IGZvdW5kJywgaXRlbUlELCBzZXR0aW5ncy5Nb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgRm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZUl0ZW0uaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgR2VuZXJhdGVzIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgaW5tZWRpYXRlbHksXG4gICAgICAgIHdpdGggdGhlIGNhY2hlZCB2YWx1ZSBvciB1bmRlZmluZWQsXG4gICAgICAgIGxhdW5jaGluZyBhbiBpdGVtIGxvYWQgdGhhdCB3aWxsIHVwZGF0ZSB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICBvbiByZWFkeSBpZiB0aGVyZSBpcyBubyBjYWNoZWQgdmFsdWUuXG4gICAgICAgIEEgbWV0aG9kICdzeW5jJyBpcyBhZGRlZCB0byB0aGUgb2JzZXJ2YWJsZSBzbyBjYW4gYmUgcmVxdWVzdGVkXG4gICAgICAgIGEgZGF0YSBzeW5jL3JlbG9hZCBvbiBkZW1hbmQuXG4gICAgKiovXG4gICAgYXBpLmdldE9ic2VydmFibGVJdGVtID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZUl0ZW0oaXRlbUlEKSB7XG4gICAgICAgIC8vIEdldCBmaXJzdCB2YWx1ZVxuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGNhY2hlLmdldEl0ZW1DYWNoZShpdGVtSUQpO1xuICAgICAgICBmaXJzdFZhbHVlID0gZmlyc3RWYWx1ZSAmJiBmaXJzdFZhbHVlLml0ZW0gfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgb2JzID0ga28ub2JzZXJ2YWJsZShmaXJzdFZhbHVlKTtcbiAgICAgICAgLy8gQ3JlYXRlIG1ldGhvZCAnc3luYydcbiAgICAgICAgb2JzLnN5bmMgPSBmdW5jdGlvbiBzeW5jT2JzZXJ2YWJsZUl0ZW0oKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW0oaXRlbUlEKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgb2JzKGl0ZW1Nb2RlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRmlyc3QgbG9hZCBpZiBubyBjYWNoZWQgdmFsdWVcbiAgICAgICAgaWYgKCFmaXJzdFZhbHVlKVxuICAgICAgICAgICAgb2JzLnN5bmMoKTtcbiAgICAgICAgLy8gUmV0dXJuXG4gICAgICAgIHJldHVybiBvYnM7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgU2ltaWxhciB0byBnZXRPYnNlcnZhYmxlSXRlbSwgaXQgYWxsb3dzIHRvIGdldFxuICAgICAgICBhbiBvYnNlcnZhYmxlIHRvIGFuIGl0ZW0gbW9kZWwgc3luY2hyb25vdXNseSB0aGF0XG4gICAgICAgIGl0IHRyaWdnZXJzIGFuIGl0ZW0gbG9hZCB3aGVuIGl0cyBtZXRob2QgJ3N5bmMnXG4gICAgICAgIGlzIGNhbGxlZC4gVGhlIGl0ZW1JRCBpcyBwYXNzZWQgdG8gdGhlIHN5bmMgaXRlbSxcbiAgICAgICAgc2luY2UgdGhlIG9ic2VydmFibGUgaXMgbWVhbnQgdG8gaG9sZCBhbnkgaXRlbS9pdGVtSURcbiAgICAgICAgKGl0cyBhIHdpbGRjYXJkKS5cbiAgICAgICAgVGhpcyB3YXksIGEgcmVmZXJlbmNlIHRvIGFuIG9ic2VydmFibGUgY2FuIGJlIGdldCBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICBldmVuIGlmIHRoZXJlIGlzIG5vIGRhdGEgc3RpbGwsIGV2ZW4gbm8gaXRlbUlELCBhbmQgbG9hZFxuICAgICAgICBpdCBsYXRlciBsYXppbHksIG9uIGRlbWFuZCwgd2hpbGUga2VlcGluZyB0aGUgY29udGVudCBvZiB0aGVcbiAgICAgICAgcHJldmlvdXMgb3V0ZGF0ZWQgb3IgZGlmZmVyZW50IGl0ZW0uXG5cbiAgICAgICAgTk9URTogQVBJIGFsdGVybmF0aXZlIG5hbWVzOiBnZXRMYXp5SXRlbSwgY3JlYXRlTXV0YWJsZUl0ZW1cbiAgICAgICAgTk9URTogTWF5YmUgY2FuIGdldCBzdGF0ZSBvYnNlcnZhYmxlcyAobG9hZGluZywgc3luY2luZy4uKT9cbiAgICAgICAgTk9URTogT24gdXBkYXRlIGEgc2FtZSBpdGVtSUQsIG1heWJlIHVwZGF0ZSB0aGUgbW9kZWwgd2l0aCB1cGRhdGVXaXRoXG4gICAgICAgICAgICAgICAgcmF0aGVyIHRoYW4gY2hhbmdlIHRoZSByZWZlcmVuY2UgbW9kZWw/PyAoZG91YmxlIGNoZWNrOlxuICAgICAgICAgICAgICAgIHNpbmNlIHRoZSBtb2RlbCBpcyB0aGUgc2FtZSBpbiBjYWNoZSwgYWxyZWFkeSB1cGRhdGVkXG4gICAgICAgICAgICAgICAgd2l0aCAndXBkYXRlV2l0aCcsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmUtYXBwbHkgYW5kIG5vXG4gICAgICAgICAgICAgICAgbmVlZCB0byBjaGFuZ2UgdGhlIGl0ZW0gb2JzZXJ2YWJsZSBiZWNhdXNlIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgdXBkYXRlZCBhbHJlYWR5LCByaWdodD9cbiAgICAqKi9cbiAgICBhcGkuY3JlYXRlV2lsZGNhcmRJdGVtID0gZnVuY3Rpb24gY3JlYXRlV2lsZGNhcmRJdGVtKCkge1xuICAgICAgICAvLyBVdGlsaXR5IGZvciByZXVzZSBpbiAnc3luYydcbiAgICAgICAgdmFyIGhhc0lEID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCAhPT0gbnVsbCAmJiB0eXBlb2YoaWQpICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBvYnNlcnZhYmxlLCB3aXRoIGluaXRpYWwgdW5kZWZpbmVkIHZhbHVlXG4gICAgICAgIHZhciBvYnMgPSBrby5vYnNlcnZhYmxlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG1ldGhvZCAnc3luYydcbiAgICAgICAgdmFyIGxhc3RJRDtcbiAgICAgICAgLyoqXG4gICAgICAgICAgICBTeW5jIG1ldGhvZCB0byBsb2FkIGFuIGl0ZW0sIGZyb20gY2FjaGUgQVNBUCBhbmRcbiAgICAgICAgICAgIGZyb20gbG9jYWwgb3IgcmVtb3RlIGlmIHJlcXVpcmVkIGJ5IHRoZSBjYWNoZSBjb250cm9sLlxuICAgICAgICAgICAgSXQgcmV0dXJucyB0aGUgUHJvbWlzZSBmb3IgZmV0Y2hpbmcgdGhlIHZhbHVlIChnZXRJdGVtKVxuICAgICAgICAgICAgc28gbG9hZC9zeW5jIGVuZGluZyBhbmQgZXJyb3IgY2FuIGJlIGNhdGNoZWQuXG4gICAgICAgICoqL1xuICAgICAgICBvYnMuc3luYyA9IGZ1bmN0aW9uIHN5bmNPYnNlcnZhYmxlSXRlbShpdGVtSUQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGlkQ2hhbmdlZCA9IGhhc0lEKGl0ZW1JRCkgJiYgaXRlbUlEICE9PSBsYXN0SUQ7XG4gICAgICAgICAgICBsYXN0SUQgPSBoYXNJRChpdGVtSUQpID8gaXRlbUlEIDogbGFzdElEO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBU0FQIEdldCBmcm9tIGNhY2hlIGlmIGFueSBhbmQgcmVxdWVzdGVkIGl0ZW0gY2hhbmdlZFxuICAgICAgICAgICAgaWYgKGlkQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRJdGVtID0gY2FjaGUuZ2V0SXRlbUNhY2hlKGxhc3RJRCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEl0ZW0gJiYgY2FjaGVkSXRlbS5pdGVtKVxuICAgICAgICAgICAgICAgICAgICBvYnMoY2FjaGVkSXRlbS5pdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVxdWVzdCB1cGRhdGVkIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gYXBpLmdldEl0ZW0obGFzdElEKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgb2JzKGl0ZW1Nb2RlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1Nb2RlbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAgICBTZXRzIHRoZSBvYnNlcnZhYmxlIHZhbHVlIHRvIGEgbmV3IGl0ZW0gaW5zdGFuY2VcbiAgICAgICAgKiovXG4gICAgICAgIG9icy5uZXdJdGVtID0gZnVuY3Rpb24gbmV3SXRlbShkZWZhdWx0cykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLk1vZGVsKVxuICAgICAgICAgICAgICAgIG9icyhuZXcgc2V0dGluZ3MuTW9kZWwoZGVmYXVsdHMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvYnMoZGVmYXVsdHMgfHwge30pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVyblxuICAgICAgICByZXR1cm4gb2JzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgU2F2ZSBhbiBpdGVtIGluIGNhY2hlLCBsb2NhbCBhbmQgcmVtb3RlLlxuICAgICAgICBDYW4gYmUgbmV3IG9yIHVwZGF0ZWQuXG4gICAgICAgIFRoZSBJRHMgZ29lcyB3aXRoIGFsbCB0aGUgb3RoZXIgZGF0YSwgYmVpbmdcbiAgICAgICAgZ3JvdXBJRCByZXF1aXJlZCwgaXRlbUlEIHJlcXVpcmVkIGZvciB1cGRhdGVzXG4gICAgICAgIGJ1dCBmYWxzeSBmb3IgaW5zZXJ0aW9ucy5cbiAgICAgICAgQHBhcmFtIGRhdGE6b2JqZWN0IFBsYWluIG9iamVjdFxuICAgICoqL1xuICAgIGFwaS5zZXRJdGVtID0gZnVuY3Rpb24gc2V0SXRlbShkYXRhKSB7XG4gICAgICAgIGFwaS5zdGF0ZS5pc1NhdmluZyh0cnVlKTtcbiAgICAgICAgLy8gU2VuZCB0byByZW1vdGUgZmlyc3RcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaExpc3RUb1JlbW90ZShkYXRhKVxuICAgICAgICAudGhlbihmdW5jdGlvbihzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAvLyBTdWNjZXNzISB1cGRhdGUgbG9jYWwgY29weSB3aXRoIHJldHVybmVkIGRhdGFcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogdG8gdXNlIHNlcnZlciBkYXRhIGhlcmUgc28gd2UgZ2V0IHZhbHVlcyBzZXRcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBzZXJ2ZXIsIGFzIHVwZGF0ZXMgZGF0ZXMgYW5kIGl0ZW1JRCB3aGVuIGNyZWF0aW5nXG4gICAgICAgICAgICAvLyBhIG5ldyBpdGVtLlxuICAgICAgICAgICAgaWYgKHNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGluIGNhY2hlXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0SXRlbUNhY2hlKHNlcnZlckRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgICAgIC8vIEluIGxvY2FsIG5lZWQgdG8gYmUgc2F2ZWQgYWxsIHRoZSBsaXN0LCBub3QganVzdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtOyBzaW5jZSB3ZSBoYXZlIHRoZSBjYWNoZSBsaXN0IHVwZGF0ZWQsIHVzZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZnVsbCBsaXN0IHRvIHNhdmUgbG9jYWxcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hMaXN0VG9Mb2NhbChnZXRQbGFpbkNhY2hlZExpc3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VydmVyRGF0YTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBhcGkuZGVsSXRlbSA9IGZ1bmN0aW9uIGRlbEl0ZW0oaXRlbUlEKSB7XG4gICAgICAgIFxuICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBpbiByZW1vdGUgZmlyc3RcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSXRlbUZyb21SZW1vdGUoaXRlbUlEKVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZW1vdmVkRGF0YSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGNhY2hlXG4gICAgICAgICAgICBjYWNoZS5kZWxJdGVtQ2FjaGUoaXRlbUlEKTtcbiAgICAgICAgICAgIC8vIFNhdmUgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgLy8gSW4gbG9jYWwgbmVlZCB0byBiZSBzYXZlZCBhbGwgdGhlIGxpc3Q7XG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBoYXZlIHRoZSBjYWNoZSBsaXN0IHVwZGF0ZWQsIHVzZSB0aGF0XG4gICAgICAgICAgICAvLyBmdWxsIGxpc3QgdG8gc2F2ZSBsb2NhbFxuICAgICAgICAgICAgdGhpcy5wdXNoTGlzdFRvTG9jYWwoZ2V0UGxhaW5DYWNoZWRMaXN0KCkpO1xuXG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyhmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkRGF0YTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBhcGkuc3RhdGUuaXNEZWxldGluZyhmYWxzZSk7XG4gICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKiBTb21lIFV0aWxzICoqL1xuXG4gICAgdmFyIE1vZGVsVmVyc2lvbiA9IHJlcXVpcmUoJy4uL3V0aWxzL01vZGVsVmVyc2lvbicpO1xuICAgIC8qKlxuICAgICAgICBJdCBjcmVhdGVzIGEgbmV3IE1vZGVsVmVyc2lvbiBmb3IgdGhlIHJlcXVlc3RlZCBpdGVtIElEXG4gICAgICAgIGFmdGVyIGxvYWQgdGhlIGl0ZW0uXG4gICAgICAgIFRoZSBwcm9taXNlIHJldHVybnMgdGhlIE1vZGVsVmVyc2lvbiByZWFkeSwgb3IgbnVsbFxuICAgICAgICBpZiB0aGUgaXRlbSBkb2VzIG5vdCBleGlzdHMuXG4gICAgKiovXG4gICAgYXBpLmNyZWF0ZUl0ZW1WZXJzaW9uID0gZnVuY3Rpb24gY3JlYXRlSXRlbVZlcnNpb24oaXRlbUlEKSB7XG4gICAgICAgIHJldHVybiBhcGkuZ2V0SXRlbShpdGVtSUQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwgPyBuZXcgTW9kZWxWZXJzaW9uKG1vZGVsKSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgSXQgY3JlYXRlcyBhIG5ldyBNb2RlbCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBpbml0aWFsIHZhbHVlcyxcbiAgICAgICAgcmV0dXJuaW5nIGEgTW9kZWxWZXJzaW9uIG9iamVjdC5cbiAgICAgICAgVGhlIHZlcnNpb25pbmcgYWxsb3dzIHRvIHRyYWNrIHRoZSBpbml0aWFsXG4gICAgICAgIHN0YXRlIChpZiBjb21lcyBmcm9tIGEgc2V0IG9mIGRlZmF1bHRzIG9yIGNsb25lKSB3aXRoXG4gICAgICAgIHRoZSBjaGFuZ2VzIGRvbmU7IHRoZSBpbnRlcm5hbCB2ZXJzaW9uIG5vdGlmaWVzIGl0c2VsZlxuICAgICAgICBhcyAndW5zYXZlZCcgZXZlci5cbiAgICAgICAgSXRzIHVzZWZ1bCB0byBrZWVwIHRoZSBzYW1lIE1vZGVsVmVyc2lvbiBhd2FyZSBjb2RlIGZvclxuICAgICAgICBlZGl0aW9ucyBhbmQgYWRkaXRpb25zLlxuICAgICoqL1xuICAgIGFwaS5uZXdJdGVtID0gZnVuY3Rpb24gbmV3SXRlbSh2YWx1ZXMpIHtcbiAgICAgICAgLy8gTmV3IG9yaWdpbmFsIGFuZCB2ZXJzaW9uIGZvciB0aGUgbW9kZWxcbiAgICAgICAgdmFyIHZlcnNpb24gPSBuZXcgTW9kZWxWZXJzaW9uKG5ldyBzZXR0aW5ncy5Nb2RlbCh2YWx1ZXMpKTtcbiAgICAgICAgLy8gVG8gYmUgc3VyZSB0aGF0IHRoZSB2ZXJzaW9uIGFwcGVhciBhcyBzb21ldGhpbmcgJ25ldycsIHVuc2F2ZWQsXG4gICAgICAgIC8vIHdlIHVwZGF0ZSBpdHMgdGltZXN0YW1wIHRvIGJlIGRpZmZlcmVudCB0byB0aGUgb3JpZ2luYWwuXG4gICAgICAgIHZlcnNpb24udmVyc2lvbi5tb2RlbC50b3VjaCgpO1xuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RSZW1vdGVNb2RlbDtcblxuTGlzdFJlbW90ZU1vZGVsLnByb3RvdHlwZS5hZGRMb2NhbGZvcmFnZVN1cHBvcnQgPSBmdW5jdGlvbiBhZGRMb2NhbGZvcmFnZVN1cHBvcnQoYmFzZU5hbWUpIHtcbiAgICB2YXIgbG9jYWxmb3JhZ2UgPSByZXF1aXJlKCdsb2NhbGZvcmFnZScpO1xuXG4gICAgdGhpcy5mZXRjaExpc3RGcm9tTG9jYWwgPSBmdW5jdGlvbiBmZXRjaExpc3RGcm9tTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGZvcmFnZS5nZXRJdGVtKGJhc2VOYW1lKTtcbiAgICB9O1xuICAgIHRoaXMucHVzaExpc3RUb0xvY2FsID0gZnVuY3Rpb24gcHVzaExpc3RUb0xvY2FsKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZm9yYWdlLnNldEl0ZW0oYmFzZU5hbWUsIGRhdGEpO1xuICAgIH07XG59O1xuXG5MaXN0UmVtb3RlTW9kZWwucHJvdG90eXBlLmFkZFJlc3RTdXBwb3J0ID0gZnVuY3Rpb24gYWRkUmVzdFN1cHBvcnQocmVzdENsaWVudCwgYmFzZVVybCkge1xuICAgIFxuICAgIHRoaXMuZmV0Y2hMaXN0RnJvbVJlbW90ZSA9IGZ1bmN0aW9uIGZldGNoTGlzdEZyb21SZW1vdGUoKSB7XG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50LmdldChiYXNlVXJsKTtcbiAgICB9O1xuICAgIHRoaXMucHVzaExpc3RUb1JlbW90ZSA9IGZ1bmN0aW9uIHB1c2hMaXN0VG9SZW1vdGUoZGF0YSkge1xuXG4gICAgICAgIHZhciBpdGVtSUQgPSBkYXRhW3RoaXMuc2V0dGluZ3MuaXRlbUlkRmllbGRdLFxuICAgICAgICAgICAgbWV0aG9kID0gaXRlbUlEID8gJ3B1dCcgOiAncG9zdCc7XG5cbiAgICAgICAgdmFyIHVybCA9IGJhc2VVcmwgKyAoXG4gICAgICAgICAgICBpdGVtSUQgPyAnLycgKyBpdGVtSUQgOiAnJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdENsaWVudFttZXRob2RdKHVybCwgZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tUmVtb3RlID0gZnVuY3Rpb24gcmVtb3ZlSXRlbUZyb21SZW1vdGUoaXRlbUlEKSB7XG4gICAgICAgIHJldHVybiByZXN0Q2xpZW50LmRlbGV0ZShiYXNlVXJsICsgJy8nICsgaXRlbUlEKTtcbiAgICB9O1xufTtcblxuLy8gRm9yIHRlc3RpbmcgcHVycG9zZXMsIGVtdWxhdGUgYSByZW1vdGUgcHJvdmlkaW5nIGEgc3RhdGljIGxpc3QgZm9yIHRoZSBkYXRhOlxuTGlzdFJlbW90ZU1vZGVsLnByb3RvdHlwZS5hZGRNb2NrZWRSZW1vdGUgPSBmdW5jdGlvbiBhZGRNb2NrZWRSZW1vdGUoZGF0YUxpc3QpIHtcbiAgICB0aGlzLmZldGNoTGlzdEZyb21SZW1vdGUgPSBmdW5jdGlvbiBmZXRjaExpc3RGcm9tUmVtb3RlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGFMaXN0KTtcbiAgICB9O1xuICAgIHRoaXMucHVzaExpc3RUb1JlbW90ZSA9IGZ1bmN0aW9uIHB1c2hMaXN0VG9SZW1vdGUoZGF0YSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVJdGVtRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tUmVtb3RlKGl0ZW1JRCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGl0ZW1JRCk7XG4gICAgfTtcbn07IiwiLyoqXG4gICAgVXRpbGl0eSB0aGF0IGFsbG93cyB0byBrZWVwIGFuIG9yaWdpbmFsIG1vZGVsIHVudG91Y2hlZFxuICAgIHdoaWxlIGVkaXRpbmcgYSB2ZXJzaW9uLCBoZWxwaW5nIHN5bmNocm9uaXplIGJvdGhcbiAgICB3aGVuIGRlc2lyZWQgYnkgcHVzaC9wdWxsL3N5bmMtaW5nLlxuICAgIFxuICAgIEl0cyB0aGUgdXN1YWwgd2F5IHRvIHdvcmsgb24gZm9ybXMsIHdoZXJlIGFuIGluIG1lbW9yeVxuICAgIG1vZGVsIGNhbiBiZSB1c2VkIGJ1dCBpbiBhIGNvcHkgc28gY2hhbmdlcyBkb2Vzbid0IGFmZmVjdHNcbiAgICBvdGhlciB1c2VzIG9mIHRoZSBpbi1tZW1vcnkgbW9kZWwgKGFuZCBhdm9pZHMgcmVtb3RlIHN5bmNpbmcpXG4gICAgdW50aWwgdGhlIGNvcHkgd2FudCB0byBiZSBwZXJzaXN0ZWQgYnkgcHVzaGluZyBpdCwgb3IgYmVpbmdcbiAgICBkaXNjYXJkZWQgb3IgcmVmcmVzaGVkIHdpdGggYSByZW1vdGVseSB1cGRhdGVkIG9yaWdpbmFsIG1vZGVsLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5mdW5jdGlvbiBNb2RlbFZlcnNpb24ob3JpZ2luYWwpIHtcbiAgICBcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLm9yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHZlcnNpb25cbiAgICAvLyAodXBkYXRlV2l0aCB0YWtlcyBjYXJlIHRvIHNldCB0aGUgc2FtZSBkYXRhVGltZXN0YW1wKVxuICAgIHRoaXMudmVyc2lvbiA9IG9yaWdpbmFsLm1vZGVsLmNsb25lKG51bGwsIHRydWUpO1xuICAgIFxuICAgIC8vIENvbXB1dGVkIHRoYXQgdGVzdCBlcXVhbGl0eSwgYWxsb3dpbmcgYmVpbmcgbm90aWZpZWQgb2YgY2hhbmdlc1xuICAgIC8vIEEgcmF0ZUxpbWl0IGlzIHVzZWQgb24gZWFjaCB0byBhdm9pZCBzZXZlcmFsIHN5bmNyaG9ub3VzIG5vdGlmaWNhdGlvbnMuXG4gICAgXG4gICAgLyoqXG4gICAgICAgIFJldHVybnMgdHJ1ZSB3aGVuIGJvdGggdmVyc2lvbnMgaGFzIHRoZSBzYW1lIHRpbWVzdGFtcFxuICAgICoqL1xuICAgIHRoaXMuYXJlRGlmZmVyZW50ID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uIGFyZURpZmZlcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWwubW9kZWwuZGF0YVRpbWVzdGFtcCgpICE9PSBcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5tb2RlbC5kYXRhVGltZXN0YW1wKClcbiAgICAgICAgKTtcbiAgICB9LCB0aGlzKS5leHRlbmQoeyByYXRlTGltaXQ6IDAgfSk7XG4gICAgLyoqXG4gICAgICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2ZXJzaW9uIGhhcyBuZXdlciBjaGFuZ2VzIHRoYW5cbiAgICAgICAgdGhlIG9yaWdpbmFsXG4gICAgKiovXG4gICAgdGhpcy5pc05ld2VyID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uIGlzTmV3ZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsLm1vZGVsLmRhdGFUaW1lc3RhbXAoKSA8IFxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uLm1vZGVsLmRhdGFUaW1lc3RhbXAoKVxuICAgICAgICApO1xuICAgIH0sIHRoaXMpLmV4dGVuZCh7IHJhdGVMaW1pdDogMCB9KTtcbiAgICAvKipcbiAgICAgICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZlcnNpb24gaGFzIG9sZGVyIGNoYW5nZXMgdGhhblxuICAgICAgICB0aGUgb3JpZ2luYWxcbiAgICAqKi9cbiAgICB0aGlzLmlzT2Jzb2xldGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gaXNDb21wdXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWwubW9kZWwuZGF0YVRpbWVzdGFtcCgpID4gXG4gICAgICAgICAgICB0aGlzLnZlcnNpb24ubW9kZWwuZGF0YVRpbWVzdGFtcCgpXG4gICAgICAgICk7XG4gICAgfSwgdGhpcykuZXh0ZW5kKHsgcmF0ZUxpbWl0OiAwIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsVmVyc2lvbjtcblxuTW9kZWxWZXJzaW9uLl9pbmhlcml0cyhFdmVudEVtaXR0ZXIpO1xuXG5Nb2RlbFZlcnNpb24ucHJvdG90eXBlLmdldFJvbGxiYWNrID0gZnVuY3Rpb24gZ2V0Um9sbGJhY2soZnJvbSkge1xuICAgIGlmIChmcm9tID09PSAndmVyc2lvbicpXG4gICAgICAgIHJldHVybiBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKHRoaXMudmVyc2lvbik7XG4gICAgZWxzZSBpZiAoZnJvbSA9PT0gJ29yaWdpbmFsJylcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJvbGxiYWNrRnVuY3Rpb24odGhpcy5vcmlnaW5hbCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tIHZhbHVlIG5vdCB2YWxpZCcpO1xufTtcblxuLyoqXG4gICAgRGlzY2FyZCB0aGUgdmVyc2lvbiBjaGFuZ2VzIGdldHRpbmcgdGhlIG9yaWdpbmFsXG4gICAgZGF0YS5cbiAgICBcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGV2ZW5JZk5ld2VyOiBmYWxzZVxuICAgIH1cbioqL1xuTW9kZWxWZXJzaW9uLnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24gcHVsbChvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBcbiAgICAvLyBCeSBkZWZhdWx0LCBub3RoaW5nIHRvIGRvLCBvciBhdm9pZCBvdmVyd3JpdGUgY2hhbmdlcy5cbiAgICB2YXIgcmVzdWx0ID0gZmFsc2UsXG4gICAgICAgIHJvbGxiYWNrID0gbnVsbDtcbiAgICBcbiAgICBpZiAob3B0aW9ucy5ldmVuSWZOZXdlciB8fCAhdGhpcy5pc05ld2VyKCkpIHtcbiAgICAgICAgLy8gVXBkYXRlIHZlcnNpb24gd2l0aCB0aGUgb3JpZ2luYWwgZGF0YSxcbiAgICAgICAgLy8gY3JlYXRpbmcgZmlyc3QgYSByb2xsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgcm9sbGJhY2sgPSBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKHRoaXMudmVyc2lvbik7XG4gICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIG9ubHkgcHJvcGVydGllcyBhbmQgZmllbGRzIGZyb20gbW9kZWxzXG4gICAgICAgIC8vIGFyZSBjb3BpZWQgYW5kIHRoYXQgbXVzdCBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgIC8vIFRoZSBtZXRob2QgdXBkYXRlV2l0aCB0YWtlcyBjYXJlIHRvIHNldCB0aGUgc2FtZSBkYXRhVGltZXN0YW1wOiAgICAgICAgXG4gICAgICAgIHRoaXMudmVyc2lvbi5tb2RlbC51cGRhdGVXaXRoKHRoaXMub3JpZ2luYWwsIHRydWUpO1xuICAgICAgICAvLyBEb25lXG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdwdWxsJywgcmVzdWx0LCByb2xsYmFjayk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICAgIFNlbmRzIHRoZSB2ZXJzaW9uIGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsXG4gICAgXG4gICAgb3B0aW9uczoge1xuICAgICAgICBldmVuSWZPYnNvbGV0ZTogZmFsc2VcbiAgICB9XG4qKi9cbk1vZGVsVmVyc2lvbi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2gob3B0aW9ucykge1xuICAgIFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIC8vIEJ5IGRlZmF1bHQsIG5vdGhpbmcgdG8gZG8sIG9yIGF2b2lkIG92ZXJ3cml0ZSBjaGFuZ2VzLlxuICAgIHZhciByZXN1bHQgPSBmYWxzZSxcbiAgICAgICAgcm9sbGJhY2sgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuZXZlbklmT2Jzb2xldGUgfHwgIXRoaXMuaXNPYnNvbGV0ZSgpKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBvcmlnaW5hbCwgY3JlYXRpbmcgZmlyc3QgYSByb2xsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgcm9sbGJhY2sgPSBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKHRoaXMub3JpZ2luYWwpO1xuICAgICAgICAvLyBFdmVyIGRlZXBDb3B5LCBzaW5jZSBvbmx5IHByb3BlcnRpZXMgYW5kIGZpZWxkcyBmcm9tIG1vZGVsc1xuICAgICAgICAvLyBhcmUgY29waWVkIGFuZCB0aGF0IG11c3QgYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAvLyBUaGUgbWV0aG9kIHVwZGF0ZVdpdGggdGFrZXMgY2FyZSB0byBzZXQgdGhlIHNhbWUgZGF0YVRpbWVzdGFtcC5cbiAgICAgICAgdGhpcy5vcmlnaW5hbC5tb2RlbC51cGRhdGVXaXRoKHRoaXMudmVyc2lvbiwgdHJ1ZSk7XG4gICAgICAgIC8vIERvbmVcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3B1c2gnLCByZXN1bHQsIHJvbGxiYWNrKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gICAgU2V0cyBvcmlnaW5hbCBhbmQgdmVyc2lvbiBvbiB0aGUgc2FtZSB2ZXJzaW9uXG4gICAgYnkgZ2V0dGluZyB0aGUgbmV3ZXN0IG9uZS5cbioqL1xuTW9kZWxWZXJzaW9uLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICBcbiAgICBpZiAodGhpcy5pc05ld2VyKCkpXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzT2Jzb2xldGUoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMucHVsbCgpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gICAgVXRpbGl0eSB0aGF0IGNyZWF0ZSBhIGZ1bmN0aW9uIGFibGUgdG8gXG4gICAgcGVyZm9ybSBhIGRhdGEgcm9sbGJhY2sgb24gZXhlY3V0aW9uLCB1c2VmdWxcbiAgICB0byBwYXNzIG9uIHRoZSBldmVudHMgdG8gYWxsb3cgcmVhY3QgdXBvbiBjaGFuZ2VzXG4gICAgb3IgZXh0ZXJuYWwgc3luY2hyb25pemF0aW9uIGZhaWx1cmVzLlxuKiovXG5mdW5jdGlvbiBjcmVhdGVSb2xsYmFja0Z1bmN0aW9uKG1vZGVsSW5zdGFuY2UpIHtcbiAgICAvLyBQcmV2aW91cyBmdW5jdGlvbiBjcmVhdGlvbiwgZ2V0IE5PVyB0aGUgaW5mb3JtYXRpb24gdG9cbiAgICAvLyBiZSBiYWNrZWQgZm9yIGxhdGVyLlxuICAgIHZhciBiYWNrZWREYXRhID0gbW9kZWxJbnN0YW5jZS5tb2RlbC50b1BsYWluT2JqZWN0KHRydWUpLFxuICAgICAgICBiYWNrZWRUaW1lc3RhbXAgPSBtb2RlbEluc3RhbmNlLm1vZGVsLmRhdGFUaW1lc3RhbXAoKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgZnVuY3Rpb24gdGhhdCAqbWF5KiBnZXQgZXhlY3V0ZWQgbGF0ZXIsIGFmdGVyXG4gICAgLy8gY2hhbmdlcyB3ZXJlIGRvbmUgaW4gdGhlIG1vZGVsSW5zdGFuY2UuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJvbGxiYWNrKCkge1xuICAgICAgICAvLyBTZXQgdGhlIGJhY2tlZCBkYXRhXG4gICAgICAgIG1vZGVsSW5zdGFuY2UubW9kZWwudXBkYXRlV2l0aChiYWNrZWREYXRhLCB0cnVlKTtcbiAgICAgICAgLy8gQW5kIHRoZSB0aW1lc3RhbXBcbiAgICAgICAgbW9kZWxJbnN0YW5jZS5tb2RlbC5kYXRhVGltZXN0YW1wKGJhY2tlZFRpbWVzdGFtcCk7XG4gICAgfTtcbn1cbiIsIi8qKlxuICAgIFJlbW90ZU1vZGVsIGNsYXNzLlxuICAgIFxuICAgIEl0IGhlbHBzIG1hbmFnaW5nIGEgbW9kZWwgaW5zdGFuY2UsIG1vZGVsIHZlcnNpb25zXG4gICAgZm9yIGluIG1lbW9yeSBtb2RpZmljYXRpb24sIGFuZCB0aGUgcHJvY2VzcyB0byBcbiAgICByZWNlaXZlIG9yIHNlbmQgdGhlIG1vZGVsIGRhdGFcbiAgICB0byBhIHJlbW90ZSBzb3VyY2VzLCB3aXRoIGdsdWUgY29kZSBmb3IgdGhlIHRhc2tzXG4gICAgYW5kIHN0YXRlIHByb3BlcnRpZXMuXG4gICAgXG4gICAgRXZlcnkgaW5zdGFuY2Ugb3Igc3ViY2xhc3MgbXVzdCBpbXBsZW1lbnRcbiAgICB0aGUgZmV0Y2ggYW5kIHB1bGwgbWV0aG9kcyB0aGF0IGtub3dzIHRoZSBzcGVjaWZpY3NcbiAgICBvZiB0aGUgcmVtb3Rlcy5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kZWxWZXJzaW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvTW9kZWxWZXJzaW9uJyksXG4gICAgQ2FjaGVDb250cm9sID0gcmVxdWlyZSgnLi4vdXRpbHMvQ2FjaGVDb250cm9sJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIGxvY2FsZm9yYWdlID0gcmVxdWlyZSgnbG9jYWxmb3JhZ2UnKSxcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbmZ1bmN0aW9uIFJlbW90ZU1vZGVsKG9wdGlvbnMpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIHZhciBmaXJzdFRpbWVMb2FkID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBNYXJrcyBhIGxvY2sgbG9hZGluZyBpcyBoYXBwZW5pbmcsIGFueSB1c2VyIGNvZGVcbiAgICAvLyBtdXN0IHdhaXQgZm9yIGl0XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICAvLyBNYXJrcyBhIGxvY2sgc2F2aW5nIGlzIGhhcHBlbmluZywgYW55IHVzZXIgY29kZVxuICAgIC8vIG11c3Qgd2FpdCBmb3IgaXRcbiAgICB0aGlzLmlzU2F2aW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgLy8gTWFya3MgYSBiYWNrZ3JvdW5kIHN5bmNocm9uaXphdGlvbjogbG9hZCBvciBzYXZlLFxuICAgIC8vIHVzZXIgY29kZSBrbm93cyBpcyBoYXBwZW5pbmcgYnV0IGNhbiBjb250aW51ZVxuICAgIC8vIHVzaW5nIGNhY2hlZCBkYXRhXG4gICAgdGhpcy5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICAvLyBVdGlsaXR5IHRvIGtub3cgd2hldGhlciBhbnkgbG9ja2luZyBvcGVyYXRpb24gaXNcbiAgICAvLyBoYXBwZW5pbmcuXG4gICAgLy8gSnVzdCBsb2FkaW5nIG9yIHNhdmluZ1xuICAgIHRoaXMuaXNMb2NrZWQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMb2FkaW5nKCkgfHwgdGhpcy5pc1NhdmluZygpO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIGlmICghb3B0aW9ucy5kYXRhKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbW90ZU1vZGVsIGRhdGEgbXVzdCBiZSBzZXQgb24gY29uc3RydWN0b3IgYW5kIG5vIGNoYW5nZWQgbGF0ZXInKTtcbiAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgXG4gICAgdGhpcy5jYWNoZSA9IG5ldyBDYWNoZUNvbnRyb2woe1xuICAgICAgICB0dGw6IG9wdGlvbnMudHRsXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5sYXRlc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEubW9kZWwucmVzZXQoKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIE9wdGlvbmFsIG5hbWUgdXNlZCB0byBwZXJzaXN0IGEgY29weSBvZiB0aGUgZGF0YSBhcyBwbGFpbiBvYmplY3RcbiAgICAvLyBpbiB0aGUgbG9jYWwgc3RvcmFnZSBvbiBldmVyeSBzdWNjZXNzZnVsbHkgbG9hZC9zYXZlIG9wZXJhdGlvbi5cbiAgICAvLyBXaXRoIG5vIG5hbWUsIG5vIHNhdmVkIChkZWZhdWx0KS5cbiAgICAvLyBJdCB1c2VzICdsb2NhbGZvcmFnZScsIHNvIG1heSBiZSBub3Qgc2F2ZWQgdXNpbmcgbG9jYWxTdG9yYWdlIGFjdHVhbGx5LFxuICAgIC8vIGJ1dCBhbnkgc3VwcG9ydGVkIGFuZCBpbml0aWFsaXplZCBzdG9yYWdlIHN5c3RlbSwgbGlrZSBXZWJTUUwsIEluZGV4ZWREQiBvciBMb2NhbFN0b3JhZ2UuXG4gICAgLy8gbG9jYWxmb3JhZ2UgbXVzdCBoYXZlIGEgc2V0LXVwIHByZXZpb3VzIHVzZSBvZiB0aGlzIG9wdGlvbi5cbiAgICB0aGlzLmxvY2FsU3RvcmFnZU5hbWUgPSBvcHRpb25zLmxvY2FsU3RvcmFnZU5hbWUgfHwgbnVsbDtcbiAgICBcbiAgICAvLyBSZWNvbW1lbmRlZCB3YXkgdG8gZ2V0IHRoZSBpbnN0YW5jZSBkYXRhXG4gICAgLy8gc2luY2UgaXQgZW5zdXJlcyB0byBsYXVuY2ggYSBsb2FkIG9mIHRoZVxuICAgIC8vIGRhdGEgZWFjaCB0aW1lIGlzIGFjY2Vzc2VkIHRoaXMgd2F5LlxuICAgIHRoaXMuZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH07XG5cbiAgICB0aGlzLm5ld1ZlcnNpb24gPSBmdW5jdGlvbiBuZXdWZXJzaW9uKCkge1xuICAgICAgICB2YXIgdiA9IG5ldyBNb2RlbFZlcnNpb24odGhpcy5kYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmVyc2lvbiBkYXRhIHdpdGggdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIGFmdGVyIGEgbG9jayBsb2FkIGZpbmlzaCwgbGlrZSB0aGUgZmlyc3QgdGltZSxcbiAgICAgICAgLy8gc2luY2UgdGhlIFVJIHRvIGVkaXQgdGhlIHZlcnNpb24gd2lsbCBiZSBsb2NrXG4gICAgICAgIC8vIGluIHRoZSBtaWRkbGUuXG4gICAgICAgIHRoaXMuaXNMb2FkaW5nLnN1YnNjcmliZShmdW5jdGlvbiAoaXNJdCkge1xuICAgICAgICAgICAgaWYgKCFpc0l0KSB7XG4gICAgICAgICAgICAgICAgdi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG5ldyBtZXRob2QgZm9yIHB1c2ggYW5kIHJlbW90ZSBzYW1lIHJldHVybmluZ1xuICAgICAgICAvLyB0aGUgc2F2ZSBwcm9taXNlIHRvIHRyYWNrIGltbWVkaWF0ZSBzdWNjZXNzIG9yIGVycm9yLFxuICAgICAgICAvLyB3aXRoIGVycm9yIGF1dG8gcmVjb3ZlcmluZyBvcmlnaW5hbCBkYXRhLlxuICAgICAgICB2LnB1c2hTYXZlID0gZnVuY3Rpb24gcHVzaFNhdmUoKSB7XG4gICAgICAgICAgICB2YXIgcm9sbGJhY2sgPSB2LmdldFJvbGxiYWNrKCdvcmlnaW5hbCcpO1xuICAgICAgICAgICAgdi5wdXNoKHsgZXZlbklmT2Jzb2xldGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2ZXJzaW9uIGRhdGEgd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIHJlbW90ZSwgdGhhdCBtYXkgaW5jbHVkZSByZW1vdGUgY29tcHV0ZWRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXM6XG4gICAgICAgICAgICAgICAgdi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybXMgYSByb2xsYmFjayBvZiB0aGUgb3JpZ2luYWwgbW9kZWxcbiAgICAgICAgICAgICAgICByb2xsYmFjaygpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2ZXJzaW9uIGRhdGEga2VlcHMgdW50b3VjaGVkLCB1c2VyIG1heSB3YW50IHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgLy8gb3IgbWFkZSBjaGFuZ2VzIG9uIGl0cyB1bi1zYXZlZCBkYXRhLlxuICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5mZXRjaCA9IG9wdGlvbnMuZmV0Y2ggfHwgZnVuY3Rpb24gZmV0Y2goKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgdGhpcy5wdXNoID0gb3B0aW9ucy5wdXNoIHx8IGZ1bmN0aW9uIHB1c2goKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGQnKTsgfTtcblxuICAgIHZhciBsb2FkRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIGxvYWRGcm9tUmVtb3RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICBpZiAoc2VydmVyRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIHBsYWluIGRhdGEgZnJvbSB0aGUgc2VydmVyIChhbmQgYW55XG4gICAgICAgICAgICAgICAgLy8gaW4gYmV0d2VlbiBjb252ZXJzaW9uIG9uICdmZWN0aCcpIGNhbm5vdCBoYXZlIGNpcmN1bGFyXG4gICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlczpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEubW9kZWwudXBkYXRlV2l0aChzZXJ2ZXJEYXRhLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIHBlcnNpc3RlbnQgbG9jYWwgY29weT9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2NhbFN0b3JhZ2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZm9yYWdlLnNldEl0ZW0odGhpcy5sb2NhbFN0b3JhZ2VOYW1lLCBzZXJ2ZXJEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbW90ZSBtb2RlbCBkaWQgbm90IHJldHVybmVkIGRhdGEsIHJlc3BvbnNlIG11c3QgYmUgYSBcIk5vdCBGb3VuZFwiJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV2ZW50XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgc2VydmVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIHNlcnZlckRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5hbGx5OiBjb21tb24gdGFza3Mgb24gc3VjY2VzcyBvciBlcnJvclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICB0aGlzLmNhY2hlLmxhdGVzdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcblxuICAgICAgICAgICAgdmFyIHdhc0xvYWQgPSB0aGlzLmlzTG9hZGluZygpO1xuXG4gICAgICAgICAgICAvLyBGaW5hbGx5OiBjb21tb24gdGFza3Mgb24gc3VjY2VzcyBvciBlcnJvclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBFdmVudFxuICAgICAgICAgICAgdmFyIGVyclBrZyA9IHtcbiAgICAgICAgICAgICAgICB0YXNrOiB3YXNMb2FkID8gJ2xvYWQnIDogJ3N5bmMnLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBCZSBjYXJlZnVsIHdpdGggJ2Vycm9yJyBldmVudCwgaXMgc3BlY2lhbCBhbmQgc3RvcHMgZXhlY3V0aW9uIG9uIGVtaXRcbiAgICAgICAgICAgIC8vIGlmIG5vIGxpc3RlbmVycyBhdHRhY2hlZDogb3ZlcndyaXR0aW5nIHRoYXQgYmVoYXZpb3IgYnkganVzdFxuICAgICAgICAgICAgLy8gcHJpbnQgb24gY29uc29sZSB3aGVuIG5vdGhpbmcsIG9yIGVtaXQgaWYgc29tZSBsaXN0ZW5lcjpcbiAgICAgICAgICAgIGlmIChFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyUGtnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvZyBpdCB3aGVuIG5vdCBoYW5kbGVkIChldmVuIGlmIHRoZSBwcm9taXNlIGVycm9yIGlzIGhhbmRsZWQpXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmVtb3RlTW9kZWwgRXJyb3InLCBlcnJQa2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXRocm93IGVycm9yXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5tdXN0UmV2YWxpZGF0ZSgpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWVMb2FkKVxuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGxvY2FsIHN0b3JhZ2UgaXMgc2V0IGZvciB0aGlzLCBsb2FkIGZpcnN0XG4gICAgICAgICAgICAvLyBmcm9tIGxvY2FsLCB0aGVuIGZvbGxvdyB3aXRoIHN5bmNpbmcgZnJvbSByZW1vdGVcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWVMb2FkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2VOYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbG9jYWxmb3JhZ2UuZ2V0SXRlbSh0aGlzLmxvY2FsU3RvcmFnZU5hbWUpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obG9jYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5tb2RlbC51cGRhdGVXaXRoKGxvY2FsRGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgZG9uZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYWwgbG9hZCBkb25lLCBkbyBhIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW90ZSBsb2FkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEZyb21SZW1vdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2F0Y2ggYW55IHByb21pc2UtZXJyb3Igb24gdGhlIHJlbW90ZSwgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgZXJyb3JzIGJlaW5nIHVuY2F0Y2gsIHRoZXkgc3RpbGwgY2FuIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXRjaCB1c2luZyB0aGUgJ2Vycm9yJyBldmVudCBvbiB0aGUgUmVtb3RlTW9kZWwgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBkb24ndCB3YWl0LCByZXR1cm4gY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gZGF0YSwgcGVyZm9ybSBhIHJlbW90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9hZCBhbmQgd2FpdCBmb3IgaXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZEZyb21SZW1vdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSByZW1vdGUgbG9hZDpcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbG9hZEZyb21SZW1vdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSwgYmxvY2tpbmcgbG9hZDpcbiAgICAgICAgICAgIC8vIGl0IHJldHVybnMgd2hlbiB0aGUgbG9hZCByZXR1cm5zXG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lTG9hZCkge1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZUxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIHRoZSBwcm9taXNlIGFuZCB3aWxsIHdhaXQgZm9yIHRoZSBmaXJzdCBsb2FkOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQmFja2dyb3VuZCBsb2FkOiBpcyBsb2FkaW5nIHN0aWxsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgY2FjaGVkIGRhdGEgc28gd2UgdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBmb3Igbm93LlxuICAgICAgICAgICAgICAgIC8vIENhdGNoIGFueSBwcm9taXNlLWVycm9yIG9uIHRoZSByZW1vdGUsIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBlcnJvcnMgYmVpbmcgdW5jYXRjaCwgdGhleSBzdGlsbCBjYW4gYmVcbiAgICAgICAgICAgICAgICAvLyBjYXRjaCB1c2luZyB0aGUgJ2Vycm9yJyBldmVudCBvbiB0aGUgUmVtb3RlTW9kZWwgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbigpIHsgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW55dGhpbmcgbmV3IGZyb20gb3V0c2lkZVxuICAgICAgICAgICAgICAgIC8vIHZlcnNpb25zIHdpbGwgZ2V0IG5vdGlmaWVkIHdpdGggaXNPYnNvbGV0ZSgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBkYXRhLCBubyBuZWVkIHRvIGxvYWQgYWdhaW4gZm9yIG5vdy5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgICB0aGlzLmlzU2F2aW5nKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJlc2VydmUgdGhlIHRpbWVzdGFtcCBhZnRlciBiZWluZyBzYXZlZFxuICAgICAgICAvLyB0byBhdm9pZCBmYWxzZSAnb2Jzb2xldGUnIHdhcm5pbmdzIHdpdGhcbiAgICAgICAgLy8gdGhlIHZlcnNpb24gdGhhdCBjcmVhdGVkIHRoZSBuZXcgb3JpZ2luYWxcbiAgICAgICAgdmFyIHRzID0gdGhpcy5kYXRhLm1vZGVsLmRhdGFUaW1lc3RhbXAoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgIC8vIEV2ZXIgZGVlcENvcHksIHNpbmNlIHBsYWluIGRhdGEgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAvLyBjYW5ub3QgaGF2ZSBjaXJjdWxhciByZWZlcmVuY2VzOlxuICAgICAgICAgICAgdGhpcy5kYXRhLm1vZGVsLnVwZGF0ZVdpdGgoc2VydmVyRGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmRhdGEubW9kZWwuZGF0YVRpbWVzdGFtcCh0cyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHBlcnNpc3RlbnQgbG9jYWwgY29weT9cbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsU3RvcmFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbGZvcmFnZS5zZXRJdGVtKHRoaXMubG9jYWxTdG9yYWdlTmFtZSwgc2VydmVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV2ZW50XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3NhdmVkJywgc2VydmVyRGF0YSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZpbmFsbHk6IGNvbW1vbiB0YXNrcyBvbiBzdWNjZXNzIG9yIGVycm9yXG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jYWNoZS5sYXRlc3QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAvLyBGaW5hbGx5OiBjb21tb24gdGFza3Mgb24gc3VjY2VzcyBvciBlcnJvclxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyhmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV2ZW50XG4gICAgICAgICAgICB2YXIgZXJyUGtnID0ge1xuICAgICAgICAgICAgICAgIHRhc2s6ICdzYXZlJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQmUgY2FyZWZ1bCB3aXRoICdlcnJvcicgZXZlbnQsIGlzIHNwZWNpYWwgYW5kIHN0b3BzIGV4ZWN1dGlvbiBvbiBlbWl0XG4gICAgICAgICAgICAvLyBpZiBubyBsaXN0ZW5lcnMgYXR0YWNoZWQ6IG92ZXJ3cml0dGluZyB0aGF0IGJlaGF2aW9yIGJ5IGp1c3RcbiAgICAgICAgICAgIC8vIHByaW50IG9uIGNvbnNvbGUgd2hlbiBub3RoaW5nLCBvciBlbWl0IGlmIHNvbWUgbGlzdGVuZXI6XG4gICAgICAgICAgICBpZiAoRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyclBrZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgaXQgd2hlbiBub3QgaGFuZGxlZCAoZXZlbiBpZiB0aGUgcHJvbWlzZSBlcnJvciBpcyBoYW5kbGVkKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlbW90ZU1vZGVsIEVycm9yJywgZXJyUGtnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmV0aHJvdyBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAgICBMYXVuY2ggYSBzeW5jaW5nIHJlcXVlc3QuIFJldHVybnMgbm90aGluZywgdGhlXG4gICAgICAgIHdheSB0byB0cmFjayBhbnkgcmVzdWx0IGlzIHdpdGggZXZlbnRzIG9yIFxuICAgICAgICB0aGUgaW5zdGFuY2Ugb2JzZXJ2YWJsZXMuXG4gICAgICAgIElNUE9SVEFOVDogcmlnaHQgbm93IGlzIGp1c3QgYSByZXF1ZXN0IGZvciAnbG9hZCdcbiAgICAgICAgdGhhdCBhdm9pZHMgcHJvbWlzZSBlcnJvcnMgZnJvbSB0aHJvd2luZy5cbiAgICAqKi9cbiAgICB0aGlzLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICAvLyBDYWxsIGZvciBhIGxvYWQsIHRoYXQgd2lsbCBiZSB0cmVhdGVkIGFzICdzeW5jaW5nJyBhZnRlciB0aGVcbiAgICAgICAgLy8gZmlyc3QgbG9hZFxuICAgICAgICB0aGlzLmxvYWQoKVxuICAgICAgICAvLyBBdm9pZCBlcnJvcnMgZnJvbSB0aHJvd2luZyBpbiB0aGUgY29uc29sZSxcbiAgICAgICAgLy8gdGhlICdlcnJvcicgZXZlbnQgaXMgdGhlcmUgdG8gdHJhY2sgYW55b25lLlxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVNb2RlbDtcblxuUmVtb3RlTW9kZWwuX2luaGVyaXRzKEV2ZW50RW1pdHRlcik7XG4iLCIvKipcbiAgICBSRVNUIEFQSSBhY2Nlc3NcbioqL1xuJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJ2pxdWVyeS5hamF4UXVldWUnKTtcblxuZnVuY3Rpb24gbG93ZXJGaXJzdExldHRlcihuKSB7XG4gICAgcmV0dXJuIG4gJiYgblswXSAmJiBuWzBdLnRvTG93ZXJDYXNlICYmIChuWzBdLnRvTG93ZXJDYXNlKCkgKyBuLnNsaWNlKDEpKSB8fCBuO1xufVxuXG5mdW5jdGlvbiBsb3dlckNhbWVsaXplT2JqZWN0KG9iaikge1xuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6OFxuICAgIFxuICAgIGlmICghb2JqIHx8IHR5cGVvZihvYmopICE9PSAnb2JqZWN0JykgcmV0dXJuIG9iajtcblxuICAgIHZhciByZXQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICAgIGZvcih2YXIgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgdmFyIG5ld2sgPSBsb3dlckZpcnN0TGV0dGVyKGspO1xuICAgICAgICAgICAgcmV0W25ld2tdID0gdHlwZW9mKG9ialtrXSkgPT09ICdvYmplY3QnID9cbiAgICAgICAgICAgICAgICBsb3dlckNhbWVsaXplT2JqZWN0KG9ialtrXSkgOlxuICAgICAgICAgICAgICAgIG9ialtrXVxuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIFJlc3Qob3B0aW9uc09yVXJsKSB7XG4gICAgXG4gICAgdmFyIHVybCA9IHR5cGVvZihvcHRpb25zT3JVcmwpID09PSAnc3RyaW5nJyA/XG4gICAgICAgIG9wdGlvbnNPclVybCA6XG4gICAgICAgIG9wdGlvbnNPclVybCAmJiBvcHRpb25zT3JVcmwudXJsO1xuXG4gICAgdGhpcy5iYXNlVXJsID0gdXJsO1xuICAgIC8vIE9wdGlvbmFsIGV4dHJhSGVhZGVycyBmb3IgYWxsIHJlcXVlc3RzLFxuICAgIC8vIHVzdWFsbHkgZm9yIGF1dGhlbnRpY2F0aW9uIHRva2Vuc1xuICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gbnVsbDtcbn1cblxuUmVzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGFwaVVybCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXBpVXJsLCAnZ2V0JywgZGF0YSk7XG59O1xuXG5SZXN0LnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBnZXQoYXBpVXJsLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcGlVcmwsICdwdXQnLCBkYXRhKTtcbn07XG5cblJlc3QucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiBnZXQoYXBpVXJsLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcGlVcmwsICdwb3N0JywgZGF0YSk7XG59O1xuXG5SZXN0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiBnZXQoYXBpVXJsLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcGlVcmwsICdkZWxldGUnLCBkYXRhKTtcbn07XG5cblJlc3QucHJvdG90eXBlLnB1dEZpbGUgPSBmdW5jdGlvbiBwdXRGaWxlKGFwaVVybCwgZGF0YSkge1xuICAgIC8vIE5PVEUgYmFzaWMgcHV0RmlsZSBpbXBsZW1lbnRhdGlvbiwgb25lIGZpbGUsIHVzZSBmaWxlVXBsb2FkP1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXBpVXJsLCAnZGVsZXRlJywgZGF0YSwgJ211bHRpcGFydC9mb3JtLWRhdGEnKTtcbn07XG5cblJlc3QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGFwaVVybCwgaHR0cE1ldGhvZCwgZGF0YSwgY29udGVudFR5cGUpIHtcbiAgICBcbiAgICB2YXIgdGhpc1Jlc3QgPSB0aGlzO1xuICAgIHZhciB1cmwgPSB0aGlzLmJhc2VVcmwgKyBhcGlVcmw7XG5cbiAgICAvLyBVc2luZyBhIHByb21pc2UgdG8gYXZvaWQgdGhlIGRpZmZlcmVuY2VzIGFuZCBwcm9ibGVtcyBvZiB0aGUgalF1ZXJ5IHRoZW5hYmxlXG4gICAgLy8gb2JqZWN0LCBidXQgYXR0YWNoaW5nIGl0cyBvcmlnaW5hbCB2YWx1ZSBhcyBhIG5ldyBwcm9wZXJ0eSAneGhyJyBvZiB0aGUgcHJvbWlzZVxuICAgIC8vIGNyZWF0ZWQgZm9yIGFkdmFuY2VkIHVzZS5cbiAgICB2YXIgeGhyID0gJC5hamF4UXVldWUoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgLy8gQXZvaWQgY2FjaGUgZm9yIGRhdGEuXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgbWV0aG9kOiBodHRwTWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICAgICAgLy8gVVJMRU5DT0RFRCBpbnB1dDpcbiAgICAgICAgLy8gQ29udmVydCB0byBKU09OIGFuZCBiYWNrIGp1c3QgdG8gZW5zdXJlIHRoZSB2YWx1ZXMgYXJlIGNvbnZlcnRlZC9lbmNvZGVkXG4gICAgICAgIC8vIHByb3Blcmx5IHRvIGJlIHNlbnQsIGxpa2UgRGF0ZXMgYmVpbmcgY29udmVydGVkIHRvIElTTyBmb3JtYXQuXG4gICAgICAgIGRhdGE6IGRhdGEgJiYgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSksXG4gICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAvLyBBbHRlcm5hdGU6IEpTT04gYXMgaW5wdXRcbiAgICAgICAgLy9kYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgLy9jb250ZW50VHlwZTogY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfSk7XG5cbiAgICB2YXIgcHJvbWlzZVhociA9IFByb21pc2UucmVzb2x2ZSh4aHIpXG4gICAgLnRoZW4obG93ZXJDYW1lbGl6ZU9iamVjdClcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIE9uIGF1dGhvcml6YXRpb24gZXJyb3IsIGdpdmUgb3BvcnR1bml0eSB0byByZXRyeSB0aGUgb3BlcmF0aW9uXG4gICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIHZhciByZXRyeSA9IHJlcXVlc3QuYmluZCh0aGlzLCBhcGlVcmwsIGh0dHBNZXRob2QsIGRhdGEsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIHZhciByZXRyeVByb21pc2UgPSB0aGlzUmVzdC5vbkF1dGhvcml6YXRpb25SZXF1aXJlZChyZXRyeSk7XG4gICAgICAgICAgICBpZiAocmV0cnlQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgcmV0dXJuZWQgc29tZXRoaW5nLCBleHBlY3RpbmcgaXMgYSBwcm9taXNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmV0cnlQcm9taXNlKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBlcnJvciBvbiByZXRyeSwganVzdCByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIGNhbGwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBieSBkZWZhdWx0LCBjb250aW51ZSBwcm9wYWdhdGluZyB0aGUgZXJyb3JcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9KTtcbiAgICBcbiAgICBwcm9taXNlWGhyLnhociA9IHhocjtcbiAgICByZXR1cm4gcHJvbWlzZVhocjtcbn07XG5cblJlc3QucHJvdG90eXBlLm9uQXV0aG9yaXphdGlvblJlcXVpcmVkID0gZnVuY3Rpb24gb25BdXRob3JpemF0aW9uUmVxdWlyZWQoLypyZXRyeSovKSB7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgb3V0c2lkZSwgaWYgY29udmVuaWVudCBleGVjdXRpbmc6XG4gICAgLy9yZXRyeSgpO1xuICAgIC8vIGJ5IGRlZmF1bHQgZG9uJ3Qgd2FpdCBmb3IgcmV0cnksIGp1c3QgcmV0dXJuIG5vdGhpbmc6XG4gICAgcmV0dXJuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXN0O1xuIiwiLyoqXG4gICAgVGltZSBjbGFzcyB1dGlsaXR5LlxuICAgIFNob3J0ZXIgd2F5IHRvIGNyZWF0ZSBhIERhdGUgaW5zdGFuY2VcbiAgICBzcGVjaWZ5aW5nIG9ubHkgdGhlIFRpbWUgcGFydCxcbiAgICBkZWZhdWx0aW5nIHRvIGN1cnJlbnQgZGF0ZSBvciBcbiAgICBhbm90aGVyIHJlYWR5IGRhdGUgaW5zdGFuY2UuXG4qKi9cbmZ1bmN0aW9uIFRpbWUoZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQpIHtcbiAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiBcbiAgICAgICAgc2Vjb25kID0gbWludXRlO1xuICAgICAgICBtaW51dGUgPSBob3VyO1xuICAgICAgICBob3VyID0gZGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpOyAgIFxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIGhvdXIgfHwgMCwgbWludXRlIHx8IDAsIHNlY29uZCB8fCAwKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gVGltZTtcbiIsIi8qKlxuICAgIENyZWF0ZSBhbiBBY2Nlc3MgQ29udHJvbCBmb3IgYW4gYXBwIHRoYXQganVzdCBjaGVja3NcbiAgICB0aGUgYWN0aXZpdHkgcHJvcGVydHkgZm9yIGFsbG93ZWQgdXNlciBsZXZlbC5cbiAgICBUbyBiZSBwcm92aWRlZCB0byBTaGVsbC5qcyBhbmQgdXNlZCBieSB0aGUgYXBwLmpzLFxuICAgIHZlcnkgdGllZCB0byB0aGF0IGJvdGggY2xhc3Nlcy5cbiAgICBcbiAgICBBY3Rpdml0aWVzIGNhbiBkZWZpbmUgb24gaXRzIG9iamVjdCBhbiBhY2Nlc3NMZXZlbFxuICAgIHByb3BlcnR5IGxpa2UgbmV4dCBleGFtcGxlc1xuICAgIFxuICAgIHRoaXMuYWNjZXNzTGV2ZWwgPSBhcHAuVXNlcnR5cGUudXNlcjsgLy8gYW55b25lXG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IGFwcC5Vc2VyVHlwZS5hbm9ueW1vdXM7IC8vIGFub255bW91cyB1c2VycyBvbmx5XG4gICAgdGhpcy5hY2Nlc3NMZXZlbCA9IGFwcC5Vc2VyVHlwZS5sb2dnZWRVc2VyOyAvLyBhdXRoZW50aWNhdGVkIHVzZXJzIG9ubHlcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBVc2VyVHlwZSBlbnVtZXJhdGlvbiBpcyBiaXQgYmFzZWQsIHNvIHNldmVyYWxcbi8vIHVzZXJzIGNhbiBoYXMgYWNjZXNzIGluIGEgc2luZ2xlIHByb3BlcnR5XG4vL3ZhciBVc2VyVHlwZSA9IHJlcXVpcmUoJy4uL21vZGVscy9Vc2VyJykuVXNlclR5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlQWNjZXNzQ29udHJvbChhcHApIHtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24gYWNjZXNzQ29udHJvbChyb3V0ZSkge1xuXG4gICAgICAgIHZhciBhY3Rpdml0eSA9IGFwcC5nZXRBY3Rpdml0eUNvbnRyb2xsZXJCeVJvdXRlKHJvdXRlKTtcblxuICAgICAgICB2YXIgdXNlciA9IGFwcC5tb2RlbC51c2VyKCk7XG4gICAgICAgIHZhciBjdXJyZW50VHlwZSA9IHVzZXIgJiYgdXNlci51c2VyVHlwZSgpO1xuXG4gICAgICAgIGlmIChhY3Rpdml0eSAmJiBhY3Rpdml0eS5hY2Nlc3NMZXZlbCkge1xuXG4gICAgICAgICAgICB2YXIgY2FuID0gYWN0aXZpdHkuYWNjZXNzTGV2ZWwgJiBjdXJyZW50VHlwZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFjYW4pIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgZXJyb3IsIHdoeSBjYW5ub3QgYWNjZXNzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRMZXZlbDogYWN0aXZpdHkuYWNjZXNzTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUeXBlOiBjdXJyZW50VHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvd1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufTtcbiIsIi8qKlxuICAgIFNldCBvZiBmdW5jdGlvbnMgdG8gbWFrZSBjYWxjdWxhdGlvbnMgb2YgYXZhaWxhYmlsaXR5XG4gICAgcGVyIGRhdGUgZ2l2ZW4gYSBsaXN0IG9mIGFwcG9pbnRtZW50cy5cbiAgICBJdCBhbGxvd3MgdG8gc29ydCB0aGVtLCBjcmVhdGUgYW5kIGluc2VydCBmcmVlL3VuYXZhaWxhYmxlIGFwcG9pbnRtZW50c1xuICAgIGZvbGxvd2luZyBhIGdpdmVuIGRheVNjaGVkdWxlIGFuZCBzdW1tYXJpemUgdGhlIGRhdGUgYXZhaWxhYmlsaXR5IHN0YXR1cy5cbiAgICBcbiAgICBJdCByZWxpZXMgKGRpcmVjdGx5IG9yIG5vdCkgaW4gbW9kZWxzIGxpa2UgQXBwb2ludG1lbnQsIFxuICAgIFNpbXBsaWZpZWRXZWVrbHlTY2hlZHVsZS5XZWVrRGF5U2NoZWR1bGUuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFwcG9pbnRtZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FwcG9pbnRtZW50JyksXG4gICAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbmV4cG9ydHMuc29ydEFwcG9pbnRtZW50cyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgYXMgPSBhLnN0YXJ0VGltZSgpLFxuICAgICAgICBhZSA9IGEuZW5kVGltZSgpLFxuICAgICAgICBicyA9IGIuc3RhcnRUaW1lKCksXG4gICAgICAgIGJlID0gYi5lbmRUaW1lKCk7XG5cbiAgICBpZiAoYXMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChicyA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIDE7XG5cbiAgICB2YXIgZXEgPSBhcy50b0lTT1N0cmluZygpID09PSBicy50b0lTT1N0cmluZygpO1xuICAgIGlmIChlcSkge1xuICAgICAgICBpZiAoYWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgaWYgKGJlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYWUgLSBiZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcyAtIGJzO1xuICAgIH1cbn07XG5cbi8qKlxuICAgIEl0IGFkZHMgYmVmb3JlIGV2ZXJ5IGJvb2tpbmcgYXB0L3Nsb3QgYSAncHJlcGFyYXRpb24gdGltZScgc2xvdCBmb3IgdGhlICdwcmVwYXJhdGlvbkhvdXJzJyAoQUtBICdiZXR3ZWVuVGltZScpLlxuICAgIFRoZSBnaXZlbiBzbG90cyBhcnJheSBNVVNUIEJFIFNPUlRFRC5cbiAgICBJdCB0YWtlcyBjYXJlIHRvOlxuICAgIC0gZG8gbm90IGFkZCBzbG90cyBvdXQgb2YgdGhlIGdpdmVuIGRhdGVcbiAgICAtIGRvIG5vdCBhZGQgc2xvdHMgdGhhdCBvdmVybGF5IG90aGVyIGJvb2tpbmdzIChpZiB0d28gYm9va2luZ3MgdG9vIGNsb3NlOyBiZWNhdXNlIG9mIG1hbnVhbCB0aW1pbmcgb3IgcHJlZmVyZW5jZVxuICAgICAgY2hhbmdlIG9mIHRoZSBwcmVwYXJhdGlvbkhvdXJzKVxuKiovXG5leHBvcnRzLmZpbGxQcmVwYXJhdGlvblRpbWVTbG90cyA9IGZ1bmN0aW9uIGZpbGxQcmVwYXJhdGlvblRpbWVTbG90cyhkYXRlLCBzbG90cywgcHJlcGFyYXRpb25Ib3Vycykge1xuICAgIFxuICAgIC8vIEluaXRpYWwgY2hlY2sgb2YgcHJldmlvdXMgc2xvdCBzdGFydCBhbmQgZW5kcyBpcyB0aGUgZ2l2ZW4gZGF0ZSAoYXQgbWlkbmlnaHQpXG4gICAgLy8gc28gd2UgYXZvaWQgdG8gaW5zZXJ0IHNsb3RzIG91dCBvZiB0aGUgZGF0ZS5cbiAgICB2YXIgcHJldkVuZCA9IGRhdGU7XG5cbiAgICBzbG90cy5mb3JFYWNoKGZ1bmN0aW9uKHNsb3QsIGluZGV4KSB7XG4gICAgICAgIC8vIGZvciBlYWNoIGJvb2tpbmdcbiAgICAgICAgaWYgKHNsb3QuaWQoKSA+IDAgJiZcbiAgICAgICAgICAgIHNsb3Quc291cmNlQm9va2luZygpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBlbmQgPSBzbG90LnN0YXJ0VGltZSgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbW9tZW50KGVuZCkuc3VidHJhY3QocHJlcGFyYXRpb25Ib3VycywgJ2hvdXJzJykudG9EYXRlKCk7XG4gICAgXG4gICAgICAgICAgICAvLyBhdm9pZGluZyB0aGUgcHJlcGFyYXRpb24gc2xvdCBpZiBpdCBlbmRzIGJlZm9yZSBvciBqdXN0IG9uXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgc2xvdCBlbmQgKG9yIGJlZm9yZSB0aGUgZGF0ZSkgdG8gYXZvaWQgdW5uZWVkZWQgc2xvdHNcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvIE5PVCBhIChlbmQgPD0gcHJldkVuZCByZXR1cm47KSBiZWNhdXNlIHdpbGwgaW50cm9kdWNlIGEgYnVnXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgcHJldkVuZCB3aWxsIG5vdCBiZSBjb2xsZWN0ZWQsIGZhaWxpbmcgd2hlbiB0aGVyZSBhcmUgXG4gICAgICAgICAgICAvLyBtb3JlIHRoYW4gMiBjb25zZWN1dGl2ZSBib29raW5nc1xuICAgICAgICAgICAgaWYgKGVuZCA+IHByZXZFbmQpIHtcbiAgICAgICAgICAgICAgICAvLyAuLm9yIGN1dHMgdGhlIGJlZ2dpbmluZyBvZiB0aGUgc2xvdCAoJ3N0YXJ0JykgYnlcbiAgICAgICAgICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBzbG90IChzbyBmaXRzIHBlcmZlY3RseSwgd2l0aG91dCBvdmVybGF5KVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgPCBwcmV2RW5kID8gcHJldkVuZCA6IHN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgLy8gaXRzIGFkZGVkIGJlZm9yZSB0aGUgY3VycmVudCBzbG90OlxuICAgICAgICAgICAgICAgIHNsb3RzLnNwbGljZShpbmRleCwgMCwgQXBwb2ludG1lbnQubmV3UHJlcGFyYXRpb25UaW1lU2xvdCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldkVuZCA9IHNsb3QuZW5kVGltZSgpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gICAgSW50cm9kdWNlIGZyZWUgb3IgdW5hdmFpbGFibGUgc2xvdHMgd2hlcmV2ZXIgbmVlZGVkIGluIHRoZSBnaXZlblxuICAgIGFycmF5IG9mIEFwcG9pbnRtZW50cywgdG8gZmlsbCBhbnkgZ2FwIGluIGEgbmF0dXJhbCBkYXlcbiAgICAoZnJvbSBNaWRuaWdodCB0byBNaWRuaWdodCBuZXh0IGRhdGUpIGFuZCBiYXNlZCBvbiB0aGVcbiAgICBnaXZlbiB3ZWVrIGRheSBzY2hlZHVsZS5cbiAgICBUaGUgaG91cnMgaW4gdGhlIHNjaGVkdWxlIGFyZSBhc3N1bWVkIGluIHRoZSBsb2NhbCB0aW1lLlxuICAgIEEgbmV3IGFycmF5IGlzIHJldHVybmVkLlxuICAgIEl0IGludHJvZHVjZSAncHJlcGFyYXRpb24gdGltZScgc2xvdHMgdG9vIGJlZm9yZSBvZiBib29raW5ncyB3aGVuIG5lZWRlZC5cbiAgICBcbiAgICBkYXRlIGlzIGEgRGF0ZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGRhdGUgYXMgdXNlZCBpblxuICAgIHRoZSBhcHBvaW50bWVudHNMaXN0OyBpdCdzIHVzZWQgd2hlbiBubyBhcHBvaW50bWVudHMgZXhpc3RzIChzb1xuICAgIGRhdGUgY2Fubm90IGJlIGV4dHJhY3RlZCBmcm9tIGZpcnN0IGFwcG9pbnRlbnQpIHRvIHJldHVybiBhbiBlbXB0eVxuICAgIGRhdGUgdW5hdmFpYWxhYmxlL2ZyZWUvdW5hdmFpbGFibGUgc2xvdHM7IGFuZCB3aGVuIGZpbGxpbmcgcHJlcGFyYXRpb24gc2xvdHMsIHRvXG4gICAgYXZvaWQgYWRkIGEgc2xvdCB3aXRoIHRpbWUgdGhhdCBzdGFydHMgaW4gYSBwcmV2aW91cyBkYXRlXG4gICAgXG4gICAgVE9ETzogTWFrZSBpdCBjb21wYXRpYmxlIHdpdGggYW4gaW5pdGlhbCBhcHBvaW50bWVudCB0aGF0IG1heSBzdGFydCBiZWZvcmUgdGhlIFxuICAgIGRhdGUgKGJ1dCBlbmRzIGluc2lkZSB0aGUgZGF0ZSkgYW5kIGEgZmluYWwgYXBwb2ludG1lbnQgdGhhdCBtYXkgZW5kXG4gICAgb24gdGhlIG5leHQgZGF0ZSAoYnV0IHN0YXJ0cyBpbnNpZGUgdGhlIGRhdGUpLlxuKiovXG5leHBvcnRzLmZpbGxEYXlBdmFpbGFiaWxpdHkgPSBmdW5jdGlvbiBmaWxsRGF5QXZhaWxhYmlsaXR5KGRhdGUsIGFwcG9pbnRtZW50c0xpc3QsIHdlZWtEYXlTY2hlZHVsZSwgc2NoZWR1bGluZ1ByZWZlcmVuY2VzKSB7XG5cbiAgICAvLyBTaGFkb3cgY2xvbmVcbiAgICB2YXIgc2xvdHMgPSBhcHBvaW50bWVudHNMaXN0LnNsaWNlKDApO1xuICAgIC8vIHNvcnQgdGhlIGxpc3RcbiAgICBzbG90cy5zb3J0KGV4cG9ydHMuc29ydEFwcG9pbnRtZW50cyk7XG4gICAgLy8gYWRkIHByZXBhcmF0aW9uIHRpbWUgZm9yIGVhY2ggYm9va2luZ1xuICAgIGV4cG9ydHMuZmlsbFByZXBhcmF0aW9uVGltZVNsb3RzKGRhdGUsIHNsb3RzLCBzY2hlZHVsaW5nUHJlZmVyZW5jZXMuYmV0d2VlblRpbWUoKSk7XG5cbiAgICB2YXIgZmlsbGVkU2xvdHMgPSBbXSxcbiAgICAgICAgemVyb1RpbWUgPSAnMDA6MDA6MDAnLFxuICAgICAgICBsYXN0ID0gemVyb1RpbWUsXG4gICAgICAgIGxhc3REYXRlVGltZSA9IG51bGwsXG4gICAgICAgIHRpbWVGb3JtYXQgPSAnSEg6bW06c3MnO1xuXG4gICAgaWYgKHNsb3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBObyBzbG90cywgZW1wdHkgZGF0ZSBzbyBjcmVhdGUgdGhlIHJlcXVpcmVkXG4gICAgICAgIC8vIHVuYXZhaWxhYmxlL2ZyZWUvdW5hdmFpbGFibGUgc2xvdHMgZm9yIHRoZSAnZGF0ZSdcbiAgICAgICAgdmFyIGZ1bGxTdGFydCA9IG1vbWVudChkYXRlKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZ1bGxFbmQgPSBmdWxsU3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcblxuICAgICAgICBmaWxsZWRTbG90cyA9IGV4cG9ydHMuY3JlYXRlU2NoZWR1bGVTbG90cyh7XG4gICAgICAgICAgICBzdGFydDogZnVsbFN0YXJ0LnRvRGF0ZSgpLFxuICAgICAgICAgICAgZW5kOiBmdWxsRW5kLnRvRGF0ZSgpXG4gICAgICAgIH0sIHdlZWtEYXlTY2hlZHVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBMb29rIGZvciB0aW1lIGdhcHMgaW4gdGhlIGxpc3RcbiAgICAgICAgc2xvdHMuZm9yRWFjaChmdW5jdGlvbihzbG90KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBzbG90LnN0YXJ0VGltZSgpLFxuICAgICAgICAgICAgICAgIHMgPSBtb21lbnQoc3RhcnQpLFxuICAgICAgICAgICAgICAgIGVuZCA9IHNsb3QuZW5kVGltZSgpLFxuICAgICAgICAgICAgICAgIGUgPSBtb21lbnQoZW5kKTtcblxuICAgICAgICAgICAgaWYgKHMuZm9ybWF0KHRpbWVGb3JtYXQpID4gbGFzdCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGxhc3REYXRlVGltZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBzbG90IG9mIHRoZSBkYXRlLCAxMkFNPTAwOjAwXG4gICAgICAgICAgICAgICAgICAgIGxhc3REYXRlVGltZSA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQuZ2V0RnVsbFllYXIoKSwgc3RhcnQuZ2V0TW9udGgoKSwgc3RhcnQuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgZ2FwLCBmaWxsIGl0XG4gICAgICAgICAgICAgICAgZmlsbGVkU2xvdHMucHVzaC5hcHBseShmaWxsZWRTbG90cywgZXhwb3J0cy5jcmVhdGVTY2hlZHVsZVNsb3RzKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3REYXRlVGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzdGFydFxuICAgICAgICAgICAgICAgIH0sIHdlZWtEYXlTY2hlZHVsZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWxsZWRTbG90cy5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgbGFzdERhdGVUaW1lID0gZW5kO1xuICAgICAgICAgICAgbGFzdCA9IGUuZm9ybWF0KHRpbWVGb3JtYXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBsYXRlc3QgdG8gc2VlIGEgZ2FwIGF0IHRoZSBlbmQ6XG4gICAgICAgIHZhciBsYXN0RW5kID0gbGFzdERhdGVUaW1lICYmIG1vbWVudChsYXN0RGF0ZVRpbWUpLmZvcm1hdCh0aW1lRm9ybWF0KTtcbiAgICAgICAgaWYgKGxhc3RFbmQgIT09IHplcm9UaW1lKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGdhcCwgZmlsbGVkIGl0XG4gICAgICAgICAgICB2YXIgbmV4dE1pZG5pZ2h0ID0gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgbGFzdERhdGVUaW1lLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbGFzdERhdGVUaW1lLmdldE1vbnRoKCksXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBkYXRlIVxuICAgICAgICAgICAgICAgIGxhc3REYXRlVGltZS5nZXREYXRlKCkgKyAxLFxuICAgICAgICAgICAgICAgIC8vIEF0IHplcm8gaG91cnMhXG4gICAgICAgICAgICAgICAgMCwgMCwgMFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZmlsbGVkU2xvdHMucHVzaC5hcHBseShmaWxsZWRTbG90cywgZXhwb3J0cy5jcmVhdGVTY2hlZHVsZVNsb3RzKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdERhdGVUaW1lLFxuICAgICAgICAgICAgICAgIGVuZDogbmV4dE1pZG5pZ2h0XG4gICAgICAgICAgICB9LCB3ZWVrRGF5U2NoZWR1bGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaWxsZWRTbG90cztcbn07XG5cbi8qKlxuICAgIEdpdmVuIGEgdGltZSByYW5nZSB3aXRob3V0IGFwcG9pbnRtZW50cywgYW5kIHRoZSBkYXkgc2NoZWR1bGUsXG4gICAgaXQgcmV0dXJucyBhbiBhcnJheSBvZiBhcHBvaW50bWVudHMgb2JqZWN0cyB0byBmdWxsZmlsbFxuICAgIHRoYXQgZW1wdHkgcmFuZ2Ugd2l0aCB1bmF2YWlsYWJsZS9mcmVlIGFwcG9pbnRtZW50cy5cbiAgICBcbiAgICBUaGUgcmFuZ2UgbXVzdCBiZSB0d28gdGltZXMgaW5zaWRlIHRoZSBzYW1lIGRhdGUgKGxvY2FsIHRpbWUpLCBmb3JtYXRcbiAgICByYW5nZSB7IHN0YXJ0OkRhdGUsIGVuZDpEYXRlIH1cbiAgICBcbiAgICB3ZWVrRGF5U2NoZWR1bGUgaXMgYW4gaW5zdGFuY2Ugb2YgV2Vla0RheVNjaGVkdWxlIE1vZGVsLCBiYXNpY2FsbHk6XG4gICAgeyBmcm9tOm9ic2VydmFibGUoRGF0ZSksIHRvOm9ic2VydmFibGUoRGF0ZSkgfVxuKiovXG5leHBvcnRzLmNyZWF0ZVNjaGVkdWxlU2xvdHMgPSBmdW5jdGlvbiBjcmVhdGVTY2hlZHVsZVNsb3RzKHJhbmdlLCB3ZWVrRGF5U2NoZWR1bGUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjEwKi9cbiAgICB2YXIgbGlzdCA9IFtdLFxuICAgICAgICBzdGFydCA9IHJhbmdlLnN0YXJ0LFxuICAgICAgICBlbmQgPSByYW5nZS5lbmQsXG4gICAgICAgIGRhdGUgPSBtb21lbnQoc3RhcnQpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICBmcm9tID0gbW9tZW50KGRhdGUpLmFkZCh7IG1pbnV0ZXM6IHdlZWtEYXlTY2hlZHVsZS5mcm9tKCkgfSkudG9EYXRlKCksXG4gICAgICAgIHRvID0gbW9tZW50KGRhdGUpLmFkZCh7IG1pbnV0ZXM6IHdlZWtEYXlTY2hlZHVsZS50bygpIH0pLnRvRGF0ZSgpO1xuXG4gICAgLy8gSXQgaGFwcGVucyBiZWZvcmUgdGhlIHdlZWsgZGF5IHNjaGVkdWxlIHN0YXJ0c1xuICAgIHZhciBiZWZvcmVTY2hlZHVsZSA9IFxuICAgICAgICBzdGFydCA8IGZyb20gJiZcbiAgICAgICAgZW5kIDw9IGZyb207XG4gICAgLy8gSXQgaGFwcGVucyBhZnRlciB0aGUgd2VlayBkYXkgc2NoZWR1bGUgZW5kc1xuICAgIHZhciBhZnRlclNjaGVkdWxlID0gXG4gICAgICAgIGVuZCA+IHRvICYmXG4gICAgICAgIHN0YXJ0ID49IHRvO1xuICAgIC8vIEl0IGhhcHBlbnMgaW5zaWRlIHRoZSB3ZWVrIGRheSBzY2hlZHVsZVxuICAgIHZhciBpbnNpZGVTY2hlZHVsZSA9XG4gICAgICAgIHN0YXJ0ID49IGZyb20gJiZcbiAgICAgICAgZW5kIDw9IHRvO1xuXG4gICAgaWYgKGJlZm9yZVNjaGVkdWxlIHx8IGFmdGVyU2NoZWR1bGUpIHtcbiAgICAgICAgbGlzdC5wdXNoKFxuICAgICAgICAgICAgQXBwb2ludG1lbnQubmV3VW5hdmFpbGFibGVTbG90KHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc2lkZVNjaGVkdWxlKSB7XG4gICAgICAgIGxpc3QucHVzaChcbiAgICAgICAgICAgIEFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90KHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJcyBpbiBhIGludGVybWVkaWF0ZSBwb3NpdGlvbiwgbmVlZHMgdHdvXG4gICAgICAgIC8vIG9yIHRocmVlIHNsb3RzXG4gICAgICAgIHZhciBjcm9zc1N0YXJ0ID1cbiAgICAgICAgICAgIHN0YXJ0IDwgZnJvbSAmJlxuICAgICAgICAgICAgZW5kID4gZnJvbTtcbiAgICAgICAgdmFyIGNyb3NzRW5kID0gXG4gICAgICAgICAgICBzdGFydCA8IHRvICYmXG4gICAgICAgICAgICBlbmQgPiB0bztcblxuICAgICAgICBpZiAoY3Jvc3NTdGFydCkge1xuICAgICAgICAgICAgLy8gVW5hdmFpbGFibGUgc2xvdCB1bnRpbCB0aGUgJ2Zyb20nXG4gICAgICAgICAgICBsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgQXBwb2ludG1lbnQubmV3VW5hdmFpbGFibGVTbG90KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGZyb21cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Jvc3NFbmQpIHtcbiAgICAgICAgICAgIC8vIFVuYXZhaWxhYmxlIGFmdGVyICd0bydcbiAgICAgICAgICAgIGxpc3QucHVzaChcbiAgICAgICAgICAgICAgICBBcHBvaW50bWVudC5uZXdVbmF2YWlsYWJsZVNsb3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogdG8sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3Jvc3NTdGFydCAmJiBjcm9zc0VuZCkge1xuICAgICAgICAgICAgLy8gRnVsbCBkYXkgZnJlZVxuICAgICAgICAgICAgbGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIEFwcG9pbnRtZW50Lm5ld0ZyZWVTbG90KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogdG9cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcm9zc1N0YXJ0KSB7XG4gICAgICAgICAgICAvLyBGcmVlIHNsb3QgdW50aWwgbWlkIHBvaW50XG4gICAgICAgICAgICBsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgQXBwb2ludG1lbnQubmV3RnJlZVNsb3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcm9zc0VuZCkge1xuICAgICAgICAgICAgLy8gRnJlZSBzbG90IGZyb20gbWlkIHBvaW50XG4gICAgICAgICAgICBsaXN0LnB1c2goXG4gICAgICAgICAgICAgICAgQXBwb2ludG1lbnQubmV3RnJlZVNsb3Qoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogdG9cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJbiB0aGUgY29tcGxleCBjYXNlcywgaXMgZWFzeSB0aGF0IHRoZSBcbiAgICAvLyBvcmRlciBnZXRzIGludmVyc2VkIGJlY2F1c2Ugb2YgdGhlIGlmLWVsc2UgbmF0dXJhbCBvcmRlclxuICAgIC8vIHNvIGVuc3VyZSBnb2VzIGNvcnJlY3RcbiAgICByZXR1cm4gbGlzdC5zb3J0KGV4cG9ydHMuc29ydEFwcG9pbnRtZW50cyk7XG59O1xuIiwiLyoqXG4gICAgQm9vdGtub2NrOiBTZXQgb2YgS25vY2tvdXQgQmluZGluZyBIZWxwZXJzIGZvciBCb290c3RyYXAganMgY29tcG9uZW50cyAoanF1ZXJ5IHBsdWdpbnMpXG4gICAgXG4gICAgRGVwZW5kZW5jaWVzOiBqcXVlcnlcbiAgICBJbmplY3RlZCBkZXBlbmRlbmNpZXM6IGtub2Nrb3V0XG4qKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gRGVwZW5kZW5jaWVzXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuLy8gREkgaTE4biBsaWJyYXJ5XG5leHBvcnRzLmkxOG4gPSBudWxsO1xuXG5mdW5jdGlvbiBjcmVhdGVIZWxwZXJzKGtvKSB7XG4gICAgdmFyIGhlbHBlcnMgPSB7fTtcblxuICAgIC8qKiBQb3BvdmVyIEJpbmRpbmcgKiovXG4gICAgaGVscGVycy5wb3BvdmVyID0ge1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBzcmNPcHRpb25zID0ga28udW53cmFwKHZhbHVlQWNjZXNzb3IoKSk7XG5cbiAgICAgICAgICAgIC8vIER1cGxpY2F0aW5nIG9wdGlvbnMgb2JqZWN0IHRvIHBhc3MgdG8gcG9wb3ZlciB3aXRob3V0XG4gICAgICAgICAgICAvLyBvdmVyd3JpdHRuZyBzb3VyY2UgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgc3JjT3B0aW9ucyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVud3JhcHBpbmcgY29udGVudCB0ZXh0XG4gICAgICAgICAgICBvcHRpb25zLmNvbnRlbnQgPSBrby51bndyYXAoc3JjT3B0aW9ucy5jb250ZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTG9jYWxpemU6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50ID0gXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuaTE4biAmJiBleHBvcnRzLmkxOG4udChvcHRpb25zLmNvbnRlbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGVudDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBUbyBnZXQgdGhlIG5ldyBvcHRpb25zLCB3ZSBuZWVkIGRlc3Ryb3kgaXQgZmlyc3Q6XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5wb3BvdmVyKCdkZXN0cm95JykucG9wb3ZlcihvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIFNlIG11ZXN0cmEgc2kgZWwgZWxlbWVudG8gdGllbmUgZWwgZm9jb1xuICAgICAgICAgICAgICAgIGlmICgkKGVsZW1lbnQpLmlzKCc6Zm9jdXMnKSlcbiAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KS5wb3BvdmVyKCdzaG93Jyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5wb3BvdmVyKCdkZXN0cm95Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBoZWxwZXJzO1xufVxuXG4vKipcbiAgICBQbHVnIGhlbHBlcnMgaW4gdGhlIHByb3ZpZGVkIEtub2Nrb3V0IGluc3RhbmNlXG4qKi9cbmZ1bmN0aW9uIHBsdWdJbihrbywgcHJlZml4KSB7XG4gICAgdmFyIG5hbWUsXG4gICAgICAgIGhlbHBlcnMgPSBjcmVhdGVIZWxwZXJzKGtvKTtcbiAgICBcbiAgICBmb3IodmFyIGggaW4gaGVscGVycykge1xuICAgICAgICBpZiAoaGVscGVycy5oYXNPd25Qcm9wZXJ0eSAmJiAhaGVscGVycy5oYXNPd25Qcm9wZXJ0eShoKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIG5hbWUgPSBwcmVmaXggPyBwcmVmaXggKyBoWzBdLnRvVXBwZXJDYXNlKCkgKyBoLnNsaWNlKDEpIDogaDtcbiAgICAgICAga28uYmluZGluZ0hhbmRsZXJzW25hbWVdID0gaGVscGVyc1toXTtcbiAgICB9XG59XG5cbmV4cG9ydHMucGx1Z0luID0gcGx1Z0luO1xuZXhwb3J0cy5jcmVhdGVCaW5kaW5nSGVscGVycyA9IGNyZWF0ZUhlbHBlcnM7XG4iLCIvKipcbiAgICBLbm9ja291dCBCaW5kaW5nIEhlbHBlciBmb3IgdGhlIEJvb3RzdHJhcCBTd2l0Y2ggcGx1Z2luLlxuICAgIFxuICAgIERlcGVuZGVuY2llczoganF1ZXJ5LCBib290c3RyYXAsIGJvb3RzdHJhcC1zd2l0Y2hcbiAgICBJbmplY3RlZCBkZXBlbmRlbmNpZXM6IGtub2Nrb3V0XG4gICAgXG4gICAgSU1QT1JUQU5UIE5PVEVTOlxuICAgIC0gQSBjb25zb2xlIGVycm9yIG9mIHR5cGUgXCJvYmplY3QgaGFzIG5vdCB0aGF0IHByb3BlcnR5XCIgd2lsbCBoYXBwZW4gaWYgc3BlY2lmaWVkXG4gICAgICAgIGEgbm9uIGV4aXN0YW50IG9wdGlvbiBpbiB0aGUgYmluZGluZy4gVGhlIGVycm9yIGxvb2tzIHN0cmFuZ2Ugd2hlbiB1c2luZyB0aGUgbWluaWZpZWQgZmlsZS5cbiAgICAtIFRoZSBvcmRlciBvZiBvcHRpb25zIGluIHRoZSBiaW5kaW5nIG1hdHRlcnMgd2hlbiBjb21iaW5pbmcgd2l0aCBkaXNhYmxlZCBhbmQgcmVhZG9ubHlcbiAgICAgICAgb3B0aW9uczogaWYgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQ6dHJ1ZSBvciByZWFkb25seTp0cnVlLCBhbnkgYXR0ZW1wdCB0byBjaGFuZ2UgdGhlXG4gICAgICAgIHZhbHVlIHdpbGwgZmFpbCBzaWxlbnRseSwgc28gaWYgdGhlIHNhbWUgYmluZGluZyB1cGRhdGUgY2hhbmdlcyBkaXNhYmxlZCB0byBmYWxzZVxuICAgICAgICBhbmQgdGhlIHN0YXRlLCB0aGUgJ2Rpc2FibGVkJyBjaGFuZ2UgbXVzdCBoYXBwZW5zIGJlZm9yZSB0aGUgJ3N0YXRlJyBjaGFuZ2Ugc28gYm90aFxuICAgICAgICBhcmUgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQuIEZvciB0aGF0LCBqdXN0IHNwZWNpZnkgJ2Rpc2FibGVkJyBiZWZvcmUgJ3N0YXRlJyBpbiB0aGUgYmluZGluZ3NcbiAgICAgICAgZGVmaW5pdGlvbi5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEZXBlbmRlbmNpZXNcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5yZXF1aXJlKCdib290c3RyYXAnKTtcbnJlcXVpcmUoJ2Jvb3RzdHJhcC1zd2l0Y2gnKTtcblxuLyoqXG4gICAgQ3JlYXRlIGFuZCBwbHVnLWluIHRoZSBCaW5kaW5nIGluIHRoZSBwcm92aWRlZCBLbm9ja291dCBpbnN0YW5jZVxuKiovXG5leHBvcnRzLnBsdWdJbiA9IGZ1bmN0aW9uIHBsdWdJbihrbywgcHJlZml4KSB7XG5cbiAgICBrby5iaW5kaW5nSGFuZGxlcnNbcHJlZml4ID8gcHJlZml4ICsgJ3N3aXRjaCcgOiAnc3dpdGNoJ10gPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwbHVnaW4gaW5zdGFuY2VcbiAgICAgICAgICAgICQoZWxlbWVudCkuYm9vdHN0cmFwU3dpdGNoKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N3aXRjaCBpbml0Jywga28udG9KUyh2YWx1ZUFjY2Vzc29yKCkpKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRpbmcgdmFsdWUgb24gcGx1Z2luIGNoYW5nZXNcbiAgICAgICAgICAgICQoZWxlbWVudCkub24oJ3N3aXRjaENoYW5nZS5ib290c3RyYXBTd2l0Y2gnLCBmdW5jdGlvbiAoZSwgc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZhbHVlQWNjZXNzb3IoKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzd2l0Y2hDaGFuZ2UnLCBrby50b0pTKHYpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VkP1xuICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9ICEha28udW53cmFwKHYuc3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9ICEhc3RhdGU7XG4gICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgb24gY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlICE9PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHYuc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHYuc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5zdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2LnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgICAgICAvLyBHZXQgb3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBwbHVnaW4gaW5zdGFuY2VcbiAgICAgICAgICAgIHZhciBzcmNPcHRpb25zID0gdmFsdWVBY2Nlc3NvcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNyY09wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIC8vIFVud3JhcHBpbmcgZXZlcnkgb3B0aW9uIHZhbHVlLCBnZXR0aW5nIGEgZHVwbGljYXRlZFxuICAgICAgICAgICAgLy8gcGxhaW4gb2JqZWN0XG4gICAgICAgICAgICBvcHRpb25zID0ga28udG9KUyhvcHRpb25zKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N3aXRjaCB1cGRhdGUnLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgdmFyICRlbCA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZXZlcnkgb3B0aW9uIGluIHRoZSBwbHVnaW5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgJGVsLmJvb3RzdHJhcFN3aXRjaChrZXksIG9wdGlvbnNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiLyoqXG4gICAgSXQgY3JlYXRlcyBzbG90cyBiZXR3ZWVuIHRoZSBnaXZlbiB0aW1lcyBhbmQgc2l6ZSBmb3IgZWFjaCBvbmUuXG4gICAgUGFzdCB0aW1lcyBhcmUgYXZvaWRlZCwgYmVjYXVzZSBhcmUgbm90IGF2YWlsYWJsZVxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxuLyoqXG4gICAgUmV0dXJucyBhIGxpc3Qgb2YgYmVnZ2luaW5nIHRpbWUgc2xvdHMgYmV0d2VlbiB0aGUgcmFuZ2Ugb2YgZ2l2ZW4gdGltZXMgKGZyb20tdG8pXG4gICAgd2l0aCBhIHNpemUgYW5kIHRoYXQgZml0IGluIGEgZ2l2ZW4gZHVyYXRpb24uXG4gICAgQHBhcmFtIGZyb20gRGF0ZSBvciBJU08gZGF0ZXRpbWUgc3RyaW5nXG4gICAgQHBhcmFtIHRvIERhdGUgb3IgSVNPIGRhdGV0aW1lIHN0cmluZ1xuKiovXG5leHBvcnRzLmZvclJhbmdlID0gZnVuY3Rpb24gZm9yUmFuZ2UoZnJvbSwgdG8sIHNpemUsIGR1cmF0aW9uKSB7XG4gICAgZnJvbSA9IG5ldyBEYXRlKGZyb20pO1xuICAgIHRvID0gbmV3IERhdGUodG8pO1xuICAgIHZhciBpID0gbW9tZW50KGZyb20pLFxuICAgICAgICBkLFxuICAgICAgICBzbG90cyA9IFtdLFxuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpLFxuICAgICAgICBlbm91Z2h0O1xuXG4gICAgLy8gU2hvcnRjdXQgaWYgYmFkICd0bycgKGF2b2lkIGluZmluaXRlIGxvb3ApXG4gICAgaWYgKHRvIDw9IGZyb20pXG4gICAgICAgIHJldHVybiBzbG90cztcblxuICAgIHdoaWxlKGkudG9EYXRlKCkgPCB0bykge1xuICAgICAgICBkID0gaS5jbG9uZSgpLnRvRGF0ZSgpO1xuICAgICAgICBlbm91Z2h0ID0gaS5jbG9uZSgpLmFkZChkdXJhdGlvbiwgJ21pbnV0ZXMnKS50b0RhdGUoKTtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdDpcbiAgICAgICAgLy8gLSBpcyBub3QgYSBwYXN0IGRhdGVcbiAgICAgICAgLy8gLSBpdCBoYXMgZW5vdWdodCB0aW1lIGluIGFkdmFuY2UgdG8gZmlsbCB0aGUgZXhwZWN0ZWQgZHVyYXRpb25cbiAgICAgICAgaWYgKGQgPj0gbm93ICYmXG4gICAgICAgICAgICBlbm91Z2h0IDw9IHRvKVxuICAgICAgICAgICAgc2xvdHMucHVzaChkKTtcbiAgICAgICAgLy8gTmV4dCBzbG90XG4gICAgICAgIGkuYWRkKHNpemUsICdtaW51dGVzJyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbG90cztcbn07XG5cbi8qKlxuICAgIFJldHVybnMgYSBsaXN0IG9mIGJlZ2dpbmluZyB0aW1lIHNsb3RzIHdpdGggYSBzaXplIGFuZCB0aGF0IGZpdHMgaW4gYSBnaXZlblxuICAgIGR1cmF0aW9uIGZvciBhbGwgdGhlIEF2YWlsYWJpbGl0U2xvdHMgaW4gdGhlIGxpc3Qgd2l0aCBhdmFpbGFiaWxpdHkgJ2ZyZWUnXG4gICAgU291cmNlIGxpc3QgYXMgYSBjb25zZWN1dGl2ZSwgc29ydGVkLCBub24tb3ZlcmxhcHBpbmcgbGlzdCBvZiBhdmFpbGFiaWxpdHlTbG90c1xuKiovXG5leHBvcnRzLmZvckxpc3QgPSBmdW5jdGlvbiBmb3JMaXN0KGxpc3QsIHNpemUsIGR1cmF0aW9uKSB7XG4gICAgdmFyIHNsb3RzID0gW107XG4gICAgLy8gSXRlcmF0ZSBldmVyeSBmcmVlIHRpbWUgcmFuZ2UvQXZhaWxhYmlsaXR5U2xvdFxuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5hdmFpbGFiaWxpdHkgPT09ICdmcmVlJykge1xuICAgICAgICAgICAgc2xvdHMucHVzaC5hcHBseShzbG90cywgZXhwb3J0cy5mb3JSYW5nZShpdGVtLnN0YXJ0VGltZSwgaXRlbS5lbmRUaW1lLCBzaXplLCBkdXJhdGlvbikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNsb3RzO1xufTtcblxuXG4vLy8gTmV4dCBNdWNoIG5lZWRlZCBVdGlsaXRpZXMgbWF5YmUgYXJlIGJldHRlciBpbiBhbm90aGVyIG1vZHVsZSwgb3IgYSBkaWZmZXJlbnQgbmFtZVxuLy8vIGZvciB0aGlzIG9uZS5cblxuZXhwb3J0cy5nZXRUb3RhbEZyZWVNaW51dGVzID0gZnVuY3Rpb24gZ2V0VG90YWxGcmVlTWludXRlcyhsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5hdmFpbGFiaWxpdHkgPT09ICdmcmVlJykge1xuICAgICAgICAgICAgdmFyIHMgPSBtb21lbnQoaXRlbS5zdGFydFRpbWUpLFxuICAgICAgICAgICAgICAgIGUgPSBtb21lbnQoaXRlbS5lbmRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudCArIGUuZGlmZihzLCAnbWludXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgcmV0dXJuIGNvdW50O1xuICAgIH0sIDApO1xufTtcblxuLyoqXG4gICAgR2V0IHRoZSBhdmFpbGFiaWxpdHkgdGFnIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBhdmFpbGFiaWxpdHlTbG90c1xuICAgIGJhc2VkIG9uIGEgd29ya2RheSBvZiA4IGhvdXJzLlxuKiovXG5leHBvcnRzLmdldEF2YWlsYWJpbGl0eVRhZyA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjExXG4gICAgaWYgKCFsaXN0IHx8IGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gJ25vbmUnO1xuICAgIFxuICAgIHZhciBtaW51dGVzID0gZXhwb3J0cy5nZXRUb3RhbEZyZWVNaW51dGVzKGxpc3QpO1xuICAgIFxuICAgIHZhciBwZXJjID0gKG1pbnV0ZXMgLyAoOCo2MCkpICogMTAwLFxuICAgICAgICBkYXRlID0gbW9tZW50KGxpc3RbMF0uc3RhcnRUaW1lKS5zdGFydE9mKCdkYXknKS50b0RhdGUoKSxcbiAgICAgICAgdG9kYXkgPSBtb21lbnQoKS5zdGFydE9mKCdkYXknKS50b0RhdGUoKTtcblxuICAgIGlmIChkYXRlIDwgdG9kYXkpXG4gICAgICAgIHJldHVybiAncGFzdCc7XG4gICAgZWxzZSBpZiAocGVyYyA+PSAxMDApXG4gICAgICAgIHJldHVybiAnZnVsbCc7XG4gICAgZWxzZSBpZiAocGVyYyA+PSA1MClcbiAgICAgICAgcmV0dXJuICdtZWRpdW0nO1xuICAgIGVsc2UgaWYgKHBlcmMgPiAwKVxuICAgICAgICByZXR1cm4gJ2xvdyc7XG4gICAgZWxzZSAvLyA8PSAwXG4gICAgICAgIHJldHVybiAnbm9uZSc7XG59O1xuXG4vKipcbiAgICBTb3VyY2UgbGlzdCBhcyBhIGNvbnNlY3V0aXZlLCBzb3J0ZWQsIG5vbi1vdmVybGFwcGluZyBsaXN0IG9mIGF2YWlsYWJpbGl0eVNsb3RzXG4gICAgQHBhcmFtIGxpc3QgQXZhaWxhYmlsaXR5U2xvdCBBcnJheSBmcm9tIHRoZSAvYXZhaWxhYmlsaXR5L3RpbWVzIEFQSSwgdGhlIHRpbWVzXG4gICAgICAgIGluY2x1ZGVkIChzdGFydFRpbWUsIGVuZFRpbWUpIGNvbWVzIGFzIHN0cmluZ3MgaW4gSVNPIGRhdGV0aW1lXG4qKi9cbmV4cG9ydHMuZmlsdGVyTGlzdEJ5ID0gZnVuY3Rpb24gZmlsdGVyTGlzdEJ5KGxpc3QsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbnN0YXJ0ID0gc3RhcnQudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbmVuZCA9IGVuZC50b0lTT1N0cmluZygpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGxpc3Quc29tZShmdW5jdGlvbih0aW1lUmFuZ2UpIHtcbiAgICAgICAgLy8gSXQncyBhZnRlciB0aGUgd2FudGVkIHJhbmdlLCBzdG9wIGl0ZXJhdGluZ1xuICAgICAgICBpZiAodGltZVJhbmdlLnN0YXJ0VGltZSA+PSBuZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEl0J3MgaW5zaWRlIHRoZSB3YW50ZWQgcmFuZ2UgYW5kIG5vdCBiZWZvcmUgaXQgc3RhcnRzXG4gICAgICAgIGlmICh0aW1lUmFuZ2UuZW5kVGltZSA+IG5zdGFydCkge1xuICAgICAgICAgICAgaWYgKHRpbWVSYW5nZS5zdGFydFRpbWUgPCBuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWdnaW5pbmcgbmVlZHMgdG8gYmUgY3V0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IG5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgLy8gQmUgY2FyZWZ1bGwgd2l0aCBsb29vbmcgdGltZVJhbmdlcywgdGhhdCBjYW4gZ28gZnJvbSBiZWZvcmUgc3RhcnRpbmcgdG8gYWZ0ZXIgZW5kaW5nOlxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lOiB0aW1lUmFuZ2UuZW5kVGltZSA+IG5lbmQgPyBuZW5kIDogdGltZVJhbmdlLmVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJpbGl0eTogdGltZVJhbmdlLmF2YWlsYWJpbGl0eVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGltZVJhbmdlLmVuZFRpbWUgPiBuZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5kaW5nIG5lZWRzIHRvIGJlIGN1dFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiB0aW1lUmFuZ2Uuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lOiBuZW5kLFxuICAgICAgICAgICAgICAgICAgICBhdmFpbGFiaWxpdHk6IHRpbWVSYW5nZS5hdmFpbGFiaWxpdHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRpbWVSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBjb250aW51ZSBpdGVyYXRpbmcgdW50aWwgcmVhY2ggc29tZXRoaW5nIGluIHRoZSB3YW50ZWQgcmFuZ2VcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gICAgQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBsb2NhbCBpc29kYXRlIGFzIGtleSBhbmQgaW5jbHVkaW5nXG4gICAgZWFjaCBvbmUgYSBmaWx0ZXJlZCBsaXN0IG9mIGF2YWlsYWJpbGl0eVNsb3RzIGZyb20gdGhlIHNvdXJjZSBsaXN0IGZvclxuICAgIHRoYXQgZGF0ZS5cbiAgICBTb3VyY2UgbGlzdCBhcyBhIGNvbnNlY3V0aXZlLCBzb3J0ZWQsIG5vbi1vdmVybGFwcGluZyBsaXN0IG9mIGF2YWlsYWJpbGl0eVNsb3RzXG4qKi9cbmV4cG9ydHMuc3BsaXRMaXN0SW5Mb2NhbERhdGVzID0gZnVuY3Rpb24gZmlsdGVyTGlzdEJ5KGxpc3QpIHtcbiAgICB2YXIgaXNvZGF0ZUZvcm1hdCA9ICdZWVlZLU1NLUREJztcbiAgICB2YXIgbGFzdElzb2RhdGUsXG4gICAgICAgIGdyb3VwO1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbih0aW1lUmFuZ2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50KHRpbWVSYW5nZS5zdGFydFRpbWUpO1xuICAgICAgICB2YXIgaXNvc3RhcnQgPSBzdGFydC5mb3JtYXQoaXNvZGF0ZUZvcm1hdCk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIG5ldyBncm91cFxuICAgICAgICBpZiAoaXNvc3RhcnQgIT09IGxhc3RJc29kYXRlKSB7XG4gICAgICAgICAgICBncm91cCA9IHJlc3VsdFtpc29zdGFydF0gPSBbXTtcbiAgICAgICAgICAgIGxhc3RJc29kYXRlID0gaXNvc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBlbmQgPSBtb21lbnQodGltZVJhbmdlLmVuZFRpbWUpLFxuICAgICAgICAgICAgZW5kSnVzdERhdGUgPSBlbmQuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBpc29lbmQgPSBlbmQuZm9ybWF0KGlzb2RhdGVGb3JtYXQpLFxuICAgICAgICAgICAgbmV4dERheVN0YXJ0ID0gc3RhcnQuY2xvbmUoKS5zdGFydE9mKCdkYXknKS5hZGQoMSwgJ2RheScpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2tzIGlmIGRpZmZlcmVudCBkYXRlcywgYnV0IGRpc2NhcmQgd2hlbiBlbmRpbmcgaXMganVzdFxuICAgICAgICAvLyB0aGUgYmVnZ2luaW5nIG9mIG5leHQgZGF0ZSBiZWNhdXNlIHRoYXQncyBjb3JyZWN0IGZvciBhIHJhbmdlXG4gICAgICAgIC8vIHRoYXQgZ29lcyB0byB0aGUgZW5kIG9mIHRoZSBkYXRlIChzdGFydCBvZiBuZXh0IGRhdGUsIHRvIGluY2x1ZGUgbGFzdCBtaW51dGVzKVxuICAgICAgICBpZiAoaXNvc3RhcnQgIT09IGlzb2VuZCAmJlxuICAgICAgICAgICAgZW5kLmZvcm1hdCgpICE9PSBuZXh0RGF5U3RhcnQuZm9ybWF0KCkpIHtcbiAgICAgICAgICAgIC8vIEJlbG9uZ3MgdG8gZGlmZmVyZW50IGRhdGVzLCBuZWVkcyB0byBiZSBzcGxpdHRlZFxuICAgICAgICAgICAgLy8gRmlyc3QgZnJhZ21lbnQsIGZyb20gc3RhcnQgdG8gdGhlIHN0YXJ0IG9mIG5leHQgZGF0ZS5cbiAgICAgICAgICAgIGdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnQuZm9ybWF0KCksXG4gICAgICAgICAgICAgICAgZW5kVGltZTogbmV4dERheVN0YXJ0LmZvcm1hdCgpLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJpbGl0eTogdGltZVJhbmdlLmF2YWlsYWJpbGl0eVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE5leHQgZnJhZ21lbnRzIG11c3QgYmUgYXdhcmUgdGhhdCB0aGUgZW5kIGNhbiBiZSBuZXh0IGRheSBvclxuICAgICAgICAgICAgLy8gYSBmdXJ0aGVyIGRhdGUsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBpbi1iZXR3ZWVuLCBmdWxsIGRheSxcbiAgICAgICAgICAgIC8vIHRpbWUgcmFuZ2VzLCB0aGF0IGNyZWF0ZXMgbmV3IGdyb3VwcyBmb3IgdGhlIGRhdGVzLlxuICAgICAgICAgICAgLy8gQW5kIGxhdGVseSwgdXBkYXRlIHRoZSBsYXN0SXNvZGF0ZSBhbmQgZ3JvdXAgdG8gdGhlIG9uZSBvZiB0aGUgZW5kIGRhdGUuXG4gICAgICAgICAgICB2YXIgaWRhdGUgPSBuZXh0RGF5U3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vIEJ5IGNvbXBhcmUgdGhpcyB3YXkgKG5leHQgZGF5IGxlc3MgdGhhbiBlbmRpbmcpIHdlIGl0ZXJhdGUgb25seVxuICAgICAgICAgICAgLy8gZnVsbCBkYXkgcmFuZ2VzIGFuZCBuZXZlciB0aGUgbmV4dCBkYXRlLCB0aGF0IGlzIG1hbmFnZWQgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAvLyBsb29wIHRoZSBzYW1lIHdheSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIG9yIG5vdCBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgd2hpbGUgKGlkYXRlIDwgZW5kSnVzdERhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRhdGVJc28gPSBpZGF0ZS5mb3JtYXQoaXNvZGF0ZUZvcm1hdCksXG4gICAgICAgICAgICAgICAgICAgIGlkYXRldGltZUlzbyA9IGlkYXRlLmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIC8vIE11dGF0ZSBpdGVyYXRpb24gZGF0ZSB0byBuZXh0IGRheVxuICAgICAgICAgICAgICAgIGlkYXRlLmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgICAgICAgLy8gTmV3IGRhdGUgZ3JvdXAgd2l0aCBzaW5nbGUgaXRlbSBsaXN0IG9mIGZ1bGwtZGF5IHJhbmdlOlxuICAgICAgICAgICAgICAgIHJlc3VsdFtpZGF0ZUlzb10gPSBbe1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGlkYXRldGltZUlzbyxcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZTogaWRhdGUuZm9ybWF0KCksXG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJpbGl0eTogdGltZVJhbmdlLmF2YWlsYWJpbGl0eVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGFzdCBmcmFnbWVudCwgZnJvbSBkYXkgYmVnaW5uaW5nIHRvIHRoZSByYW5nZSBlbmRpbmcgXG4gICAgICAgICAgICByZXN1bHRbaWRhdGUuZm9ybWF0KGlzb2RhdGVGb3JtYXQpXSA9IFt7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBpZGF0ZS5mb3JtYXQoKSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lOiBlbmQuZm9ybWF0KCksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmlsaXR5OiB0aW1lUmFuZ2UuYXZhaWxhYmlsaXR5XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSByYW5nZSBpcyBpbnNpZGUgc2FtZSBkYXRlLCBqdXN0IGFkZCBpdCB0byB0aGUgZ3JvdXAgbGlzdDpcbiAgICAgICAgICAgIGdyb3VwLnB1c2godGltZVJhbmdlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG59OyIsIi8qKlxuICAgIEFsbG93IGF0dGFjaCBhdmFpbGFiaWxpdHkgbG9hZGluZyBhbmQgZGlzcGxheWluZyBjYXBhYmlsaXRpZXNcbiAgICB0byBhIGRhdGVwaWNrZXIgY29tcG9uZW50IGFzIHBhcnQgb2YgYW4gYWN0aXZpdHkuXG4gICAgXG4gICAgSXQgYXR0YWNoZXMgaGFuZGxlcnMgc28gaXQgbG9hZHMgYW5kIHVwZGF0ZSBhdmFpbGFiaWxpdHkgd2hlbmV2ZXJcbiAgICB0aGUgZGlzcGxheWVkIG1vbnRoIGNoYW5nZSwgYnV0IGl0IHJldHVybnMgYSBtZXRob2QgdG8gZG8gaXRcbiAgICBvbiBkZW1hbmQsIGxpa2UgaW4gdGhlIGZpcnN0IGxvYWQgYWZ0ZXIgY2hvb3NlIGEgJ2N1cnJlbnQgZGF0ZSdcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxuICAgIGNyZWF0ZVRpbWVTbG90cyA9IHJlcXVpcmUoJy4vY3JlYXRlVGltZVNsb3RzJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlRGF0ZXBpY2tlckF2YWlsYWJpbGl0eShhcHAsICRkYXRlcGlja2VyLCBpc0xvYWRpbmcpIHtcbiAgICAvLyBDYWNoZSBET00gZWxlbWVudHNcbiAgICB2YXIgZGF5c0VsZW1lbnRzID0gJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignZ2V0RGF5c0VsZW1lbnRzJyk7XG4gICAgLy8gQ2FjaGUgbGFzdCBtb250aCBzaG93ZWQsIHRvIGRvdWJsZSBjaGVjayBsYXRlciBhbmQgZG9uJ3QgbG9hZCBhbiBhbHJlYWR5XG4gICAgLy8gZGlzcGxheWVkIG1vbnRoXG4gICAgdmFyIHByZXZNb250aCA9IG51bGw7XG4gICAgdmFyIHByZXZVc2VySUQgPSBudWxsO1xuICAgIFxuICAgIC8vIExpc3RlbiB0byBjYWNoZSBjaGFuZ2VzIGluIG9yZGVyIHRvIGZvcmNlIGEgZGF0YSBsb2FkICh0byBhdm9pZCBpbnZhbGlkXG4gICAgLy8gYXZhaWxhYmlsaXR5IGJlaW5nIGRpc3BsYXllZCBhZnRlciBhbiBhcHQgd2FzIG1vZGlmaWVkKVxuICAgIGFwcC5tb2RlbC5hdmFpbGFiaWxpdHkub24oJ2NsZWFyQ2FjaGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJldk1vbnRoID0gbnVsbDtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgSXQgdGFncywgaWYgdGhlIG1vbnRoIGNoYW5nZWQsIHRoZSBjYWxlbmRhciB3aXRoIHRoZSBEYXRlIEF2YWlsYWJpbGl0eS5cbiAgICAgICAgVGhlIHJlZnJlc2ggcGFyYW0gZm9yY2VzIHRoZSBwcm9jZXNzIGV2ZW4gaWYgdGhlIHNhbWUgbW9udGggdGhhbiBwcmV2aW91c2x5IHRhZ2dlZC9yZW5kZXJlZFxuICAgICoqL1xuICAgIHZhciB0YWdBdmFpbGFiaWxpdHkgPSBmdW5jdGlvbiB0YWdBdmFpbGFiaWxpdHkoZGF0ZSwgdXNlcklELCByZWZyZXNoKSB7XG4gICAgICAgIHZhciBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgLy8gQXZvaWQgZHVwZXMgYW5kIG5vbi1kYXRhXG4gICAgICAgIGlmICghdXNlcklEIHx8IG1vbnRoID09PSBwcmV2TW9udGggJiYgcHJldlVzZXJJRCA9PT0gdXNlcklEICYmICFyZWZyZXNoKSByZXR1cm47XG4gICAgICAgIHByZXZNb250aCA9IG1vbnRoO1xuICAgICAgICBwcmV2VXNlcklEID0gdXNlcklEO1xuICAgICAgICBcbiAgICAgICAgLy8gV2UgbmVlZCB0byBrbm93IHRoZSByYW5nZSBvZiBkYXRlcyBiZWluZyBkaXNwbGF5ZWQgb24gdGhlXG4gICAgICAgIC8vIG1vbnRobHkgY2FsZW5kYXIsIGZyb20gdGhlIGZpcnN0IHdlZWsgZGF5IG9mIGZpcnN0IG1vbnRoIHdlZWtcbiAgICAgICAgLy8gdG8gNiBmdWxsIHdlZWtzLlxuICAgICAgICB2YXIgc3RhcnQgPSBtb21lbnQoZGF0ZSkuY2xvbmUoKS5zdGFydE9mKCdtb250aCcpLnN0YXJ0T2YoJ3dlZWsnKSxcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKDYsICd3ZWVrcycpO1xuXG4gICAgICAgIC8vIFN3aXRjaCBsb2FkaW5nIGZsYWdcbiAgICAgICAgaWYgKGlzTG9hZGluZylcbiAgICAgICAgICAgIGlzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlcXVlc3QgdGhlIGRhdGFcbiAgICAgICAgLyphcHAubW9kZWwuY2FsZW5kYXIuZ2V0RGF0ZXNBdmFpbGFiaWxpdHkoc3RhcnQsIGVuZClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0QnlEYXRlcykge1xuICAgICAgICAgICAgLy8gV2UgYXJlIHN0aWxsIGluIHRoZSBzYW1lIHNob3dlZCBtb250aD8gKGxvYWRpbmcgaXMgYXN5bmMsIHNvIGNvdWxkIGhhdmUgY2hhbmdlZClcbiAgICAgICAgICAgIGlmIChtb250aCAhPT0gJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignZ2V0Vmlld0RhdGUnKS5nZXRNb250aCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIFdlIHJlY2VpdmVkIGEgc2V0IG9mIERhdGVBdmFpbGFiaWxpdHkgb2JqZWN0cyBwZXIgZGF0ZSAoaXNvIHN0cmluZyBrZXkpXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGV2ZXJ5IGRheSBlbGVtZW50LCBhbmQgdXNlIGl0cyBkYXRlIGF2YWlsIGZyb20gdGhlIHJlc3VsdFxuICAgICAgICAgICAgZGF5c0VsZW1lbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8ganNoaW50IG1heGNvbXBsZXhpdHk6MTBcbiAgICAgICAgICAgICAgICB2YXIgJGRhdGVUZCA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGlkID0gJGRhdGVUZC5kYXRhKCdkYXRlLXRpbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUF2YWlsID0gcmVzdWx0QnlEYXRlc1ttb21lbnQoaWQpLmZvcm1hdCgnWVlZWS1NTS1ERCcpXTsgICBcblxuICAgICAgICAgICAgICAgIC8vIEludGVncml0eSBjaGVjayB0byBhdm9pZCBlZGdlIGNhc2UgZXhjZXB0aW9ucyAobXVzdCBub3QgaGFwcGVucywgYnV0IHN0cm9uZ2VyIGNvZGUpXG4gICAgICAgICAgICAgICAgaWYgKCFpZCB8fCAhZGF0ZUF2YWlsKSByZXR1cm47XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBwcmV2aW91cyAndGFnLScgY2xhc3MgZnJvbSB0aGUgY2VsbCBjbGFzc05hbWVzIGFuZCBrZWVwIGZvciBsYXRlciBjaGFuZ2VcbiAgICAgICAgICAgICAgICB2YXIgY2VsbENsYXNzID0gJGRhdGVUZC5hdHRyKCdjbGFzcycpLnJlcGxhY2UoLyhefFxccyl0YWctW15cXHNdKy8sICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBhIGRhdGUgY2VsbCBjbGFzcyBiYXNlZCBvbiBpdHMgYXZhaWxhYmlsaXR5XG4gICAgICAgICAgICAgICAgdmFyIGNscyA9ICcnO1xuICAgICAgICAgICAgICAgIHN3aXRjaChkYXRlQXZhaWwuYXZhaWxhYmxlVGFnKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGFzdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSAndGFnLW11dGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9ICd0YWctYmxhbmsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSAndGFnLWRhcmsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvdyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSAndGFnLXdhcm5pbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gJ3RhZy1kYW5nZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRkYXRlVGQuYXR0cignY2xhc3MnLCBjZWxsQ2xhc3MgKyAnICcgKyBjbHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKi9cbiAgICAgICAgYXBwLm1vZGVsLmF2YWlsYWJpbGl0eS50aW1lcyh1c2VySUQsIHN0YXJ0LCBlbmQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIHN0aWxsIGluIHRoZSBzYW1lIHNob3dlZCBtb250aD8gKGxvYWRpbmcgaXMgYXN5bmMsIHNvIGNvdWxkIGhhdmUgY2hhbmdlZClcbiAgICAgICAgICAgIGlmIChtb250aCAhPT0gJGRhdGVwaWNrZXIuZGF0ZXBpY2tlcignZ2V0Vmlld0RhdGUnKS5nZXRNb250aCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBieURhdGUgPSBjcmVhdGVUaW1lU2xvdHMuc3BsaXRMaXN0SW5Mb2NhbERhdGVzKHJlc3VsdC50aW1lcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBsaXN0IG9yIHJhbmdlcyBwZXIgZGF0ZSAoaXNvIHN0cmluZyBrZXkpXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGV2ZXJ5IGRheSBlbGVtZW50LCBhbmQgdXNlIGl0cyBkYXRlIGF2YWlsIGZyb20gdGhlIHJlc3VsdFxuICAgICAgICAgICAgZGF5c0VsZW1lbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8ganNoaW50IG1heGNvbXBsZXhpdHk6MTBcbiAgICAgICAgICAgICAgICB2YXIgJGRhdGVUZCA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGlkID0gJGRhdGVUZC5kYXRhKCdkYXRlLXRpbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVJhbmdlTGlzdCA9IGJ5RGF0ZVttb21lbnQoaWQpLmZvcm1hdCgnWVlZWS1NTS1ERCcpXTtcblxuICAgICAgICAgICAgICAgIC8vIEludGVncml0eSBjaGVjayB0byBhdm9pZCBlZGdlIGNhc2UgZXhjZXB0aW9uc1xuICAgICAgICAgICAgICAgIC8vICgnbXVzdCcgbm90IGhhcHBlbnMsIGJ1dCBzdHJvbmdlciBjb2RlKVxuICAgICAgICAgICAgICAgIGlmICghaWQgfHwgIXRpbWVSYW5nZUxpc3QpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcHJldmlvdXMgJ3RhZy0nIGNsYXNzIGZyb20gdGhlIGNlbGwgY2xhc3NOYW1lcyBhbmQga2VlcCBmb3IgbGF0ZXIgY2hhbmdlXG4gICAgICAgICAgICAgICAgdmFyIGNlbGxDbGFzcyA9ICRkYXRlVGQuYXR0cignY2xhc3MnKS5yZXBsYWNlKC8oXnxcXHMpdGFnLVteXFxzXSsvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgYSBkYXRlIGNlbGwgY2xhc3MgYmFzZWQgb24gaXRzIGF2YWlsYWJpbGl0eVxuICAgICAgICAgICAgICAgIHZhciBjbHMgPSAnJztcbiAgICAgICAgICAgICAgICBzd2l0Y2goY3JlYXRlVGltZVNsb3RzLmdldEF2YWlsYWJpbGl0eVRhZyh0aW1lUmFuZ2VMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwYXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9ICd0YWctbXV0ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gJ3RhZy1ibGFuayc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9ICd0YWctZGFyayc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9ICd0YWctd2FybmluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSAndGFnLWRhbmdlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGRhdGVUZC5hdHRyKCdjbGFzcycsIGNlbGxDbGFzcyArICcgJyArIGNscyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgbG9hZGluZyBhdmFpbGFiaWxpdHknLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRmluYWxseVxuICAgICAgICAgICAgaWYgKGlzTG9hZGluZylcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgXG4gICAgLy8gSGFuZGxlciB0byBhdXRvIGxvYWQvdXBkYXRlIGF2YWlsYWJpbGl0eSBmb3IgZGlzcGxheWVkIGRheVxuICAgICRkYXRlcGlja2VyLm9uKCd2aWV3RGF0ZUNoYW5nZWQnLCBmdW5jdGlvbihlLCBkKSB7XG4gICAgICAgIGlmIChkLnZpZXdNb2RlID09PSAnZGF5cycpIHtcbiAgICAgICAgICAgIHRhZ0F2YWlsYWJpbGl0eShkLnZpZXdEYXRlLCBwcmV2VXNlcklEKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0YWdBdmFpbGFiaWxpdHk7XG59O1xuIiwiLyoqXG4gICAgQ29udmVydHMgYSBkdXJhdGlvbiBpbnRvIGEgdGV4dCB1c2luZyBsb25nXG4gICAgbGFuZ3VhZ2Ugd29yZHMuXG4gICAgRXhhbXBsZTogMjo0NSAtPiAyIGhvdXJzLCA0NSBtaW51dGVzXG4gICAgXG4gICAgQ2FuIHBhc3MgaW4gYSBtb21lbnQuZHVyYXRpb24gb2JqZWN0IG9yIGEgdmFsaWQgY29uc3RydWN0b3JcbiAgICBwYXJhbWV0ZXIuXG4gICAgRGlmZmVyZW5jZSB3aXRoIG1vbWVudC5kdXJhdGlvbi5odW1hbml6ZTogdGhpcyBzaG93cyBhIHByZWNpc2VcbiAgICByZXByZXNlbnRhdGlvbiwgcmV0dXJuaW5nIGV4YWN0IHZhbHVlIGZvciBhbnkgbm9uLXplcm8gdW5pdCxcbiAgICB3aGlsZSBodW1hbml6ZSBpcyBhbiBhcHByb3hpbWF0aW9uIGluIHRoZSBoaWdoZXIgdW5pdFxuICAgIChpbiB0aGUgZXhhbXBsZSBhYm92ZSwgaHVtYW5pemUgZGlzcGxheXM6ICczIGhvdXJzJylcbiAgICBcbiAgICBUT0RPOiBJMThOXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGR1cmF0aW9uMkxhbmd1YWdlKGR1cmF0aW9uKSB7XG4gICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eTozMFxuICAgIGR1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICB2YXIgeSA9IGR1cmF0aW9uLnllYXJzKCksXG4gICAgICAgIGQgPSBkdXJhdGlvbi5kYXlzKCksXG4gICAgICAgIGggPSBkdXJhdGlvbi5ob3VycygpLFxuICAgICAgICBtID0gZHVyYXRpb24ubWludXRlcygpLFxuICAgICAgICBzID0gZHVyYXRpb24uc2Vjb25kcygpLFxuICAgICAgICBsID0gZHVyYXRpb24ubWlsbGlzZWNvbmRzKCksXG4gICAgICAgIHBhcnRzID0gW107XG4gICAgXG4gICAgaWYgKHkgPT09IDEpIHBhcnRzLnB1c2goJ2EgeWVhcicpO1xuICAgIGVsc2UgaWYgKHkpIHBhcnRzLnB1c2goeSArICcgeWVhcnMnKTtcbiAgICBpZiAoZCA9PT0gMSkgcGFydHMucHVzaCgnYSBkYXknKTtcbiAgICBlbHNlIGlmIChkKSBwYXJ0cy5wdXNoKGQgKyAnIGRheXMnKTtcbiAgICBpZiAoaCA9PT0gMSkgcGFydHMucHVzaCgnYW4gaG91cicpO1xuICAgIGVsc2UgaWYgKGgpIHBhcnRzLnB1c2goaCArICcgaG91cnMnKTtcbiAgICBpZiAobSA9PT0gMSkgcGFydHMucHVzaCgnYSBtaW51dGUnKTtcbiAgICBlbHNlIGlmIChtKSBwYXJ0cy5wdXNoKG0gKyAnIG1pbnV0ZXMnKTtcbiAgICBpZiAocyA9PT0gMSkgcGFydHMucHVzaCgnYSBzZWNvbmQnKTtcbiAgICBlbHNlIGlmIChzKSBwYXJ0cy5wdXNoKHMgKyAnIHNlY29uZHMnKTtcbiAgICBpZiAobCA9PT0gMSkgcGFydHMucHVzaCgnYSBtaWxsaXNlY29uZCcpO1xuICAgIGVsc2UgaWYgKGwpIHBhcnRzLnB1c2gobCArICcgbWlsbGlzZWNvbmRzJyk7XG4gICAgXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJywgJyk7XG59OyIsIi8qKlxuICAgIEVzcGFjZSBhIHN0cmluZyBmb3IgdXNlIG9uIGEgUmVnRXhwLlxuICAgIFVzdWFsbHksIHRvIGxvb2sgZm9yIGEgc3RyaW5nIGluIGEgdGV4dCBtdWx0aXBsZSB0aW1lc1xuICAgIG9yIHdpdGggc29tZSBleHByZXNzaW9ucywgc29tZSBjb21tb24gYXJlIFxuICAgIGxvb2sgZm9yIGEgdGV4dCAnaW4gdGhlIGJlZ2lubmluZycgKF4pXG4gICAgb3IgJ2F0IHRoZSBlbmQnICgkKS5cbiAgICBcbiAgICBBdXRob3I6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xNTEzMTIvY29vbGFqODYgYW5kIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy85NDEwL2FyaXN0b3RsZS1wYWdhbHR6aXNcbiAgICBMaW5rOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2XG4qKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gUmVmZXJyaW5nIHRvIHRoZSB0YWJsZSBoZXJlOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvcmVnZXhwXG4vLyB0aGVzZSBjaGFyYWN0ZXJzIHNob3VsZCBiZSBlc2NhcGVkXG4vLyBcXCBeICQgKiArID8gLiAoICkgfCB7IH0gWyBdXG4vLyBUaGVzZSBjaGFyYWN0ZXJzIG9ubHkgaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW5zaWRlIG9mIGJyYWNrZXRzXG4vLyB0aGV5IGRvIG5vdCBuZWVkIHRvIGJlIGVzY2FwZWQsIGJ1dCB0aGV5IE1BWSBiZSBlc2NhcGVkXG4vLyB3aXRob3V0IGFueSBhZHZlcnNlIGVmZmVjdHMgKHRvIHRoZSBiZXN0IG9mIG15IGtub3dsZWRnZSBhbmQgY2FzdWFsIHRlc3RpbmcpXG4vLyA6ICEgLCA9IFxuLy8gbXkgdGVzdCBcIn4hQCMkJV4mKigpe31bXWAvPT8rXFx8LV87OidcXFwiLDwuPlwiLm1hdGNoKC9bXFwjXS9nKVxuXG52YXIgc3BlY2lhbHMgPSBbXG4gICAgLy8gb3JkZXIgbWF0dGVycyBmb3IgdGhlc2VcbiAgICAgIFwiLVwiXG4gICAgLCBcIltcIlxuICAgICwgXCJdXCJcbiAgICAvLyBvcmRlciBkb2Vzbid0IG1hdHRlciBmb3IgYW55IG9mIHRoZXNlXG4gICAgLCBcIi9cIlxuICAgICwgXCJ7XCJcbiAgICAsIFwifVwiXG4gICAgLCBcIihcIlxuICAgICwgXCIpXCJcbiAgICAsIFwiKlwiXG4gICAgLCBcIitcIlxuICAgICwgXCI/XCJcbiAgICAsIFwiLlwiXG4gICAgLCBcIlxcXFxcIlxuICAgICwgXCJeXCJcbiAgICAsIFwiJFwiXG4gICAgLCBcInxcIlxuICBdXG5cbiAgLy8gSSBjaG9vc2UgdG8gZXNjYXBlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoICdcXCdcbiAgLy8gZXZlbiB0aG91Z2ggb25seSBzb21lIHN0cmljdGx5IHJlcXVpcmUgaXQgd2hlbiBpbnNpZGUgb2YgW11cbiwgcmVnZXggPSBSZWdFeHAoJ1snICsgc3BlY2lhbHMuam9pbignXFxcXCcpICsgJ10nLCAnZycpXG47XG5cbnZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiAoc3RyKSB7XG5yZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIFwiXFxcXCQmXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XG5cbi8vIHRlc3QgZXNjYXBlUmVnRXhwKFwiL3BhdGgvdG8vcmVzP3NlYXJjaD10aGlzLnRoYXRcIilcbiIsIi8qKlxuKiBlc2NhcGVTZWxlY3RvclxuKlxuKiBzb3VyY2U6IGh0dHA6Ly9ranZhcmdhLmJsb2dzcG90LmNvbS5lcy8yMDA5LzA2L2pxdWVyeS1wbHVnaW4tdG8tZXNjYXBlLWNzcy1zZWxlY3Rvci5odG1sXG4qXG4qIEVzY2FwZSBhbGwgc3BlY2lhbCBqUXVlcnkgQ1NTIHNlbGVjdG9yIGNoYXJhY3RlcnMgaW4gKnNlbGVjdG9yKi5cbiogVXNlZnVsIHdoZW4geW91IGhhdmUgYSBjbGFzcyBvciBpZCB3aGljaCBjb250YWlucyBzcGVjaWFsIGNoYXJhY3RlcnNcbiogd2hpY2ggeW91IG5lZWQgdG8gaW5jbHVkZSBpbiBhIHNlbGVjdG9yLlxuKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHNwZWNpYWxzID0gW1xuICAnIycsICcmJywgJ34nLCAnPScsICc+JywgXG4gIFwiJ1wiLCAnOicsICdcIicsICchJywgJzsnLCAnLCdcbl07XG52YXIgcmVnZXhTcGVjaWFscyA9IFtcbiAgJy4nLCAnKicsICcrJywgJ3wnLCAnWycsICddJywgJygnLCAnKScsICcvJywgJ14nLCAnJCdcbl07XG52YXIgc1JFID0gbmV3IFJlZ0V4cChcbiAgJygnICsgc3BlY2lhbHMuam9pbignfCcpICsgJ3xcXFxcJyArIHJlZ2V4U3BlY2lhbHMuam9pbignfFxcXFwnKSArICcpJywgJ2cnXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKHNSRSwgJ1xcXFwkMScpO1xufTtcbiIsIi8qKlxuICAgIFNpbXBsaWZpbmcgc29tZSB1c2VzIG9mIHRoZSBGYWNlYm9vayBBUElcbiAgICBhbmQgdGhlIGxvYWRpbmcgb2YgaXRzIEFQSSB3aXRoIGEgJ3JlYWR5JyBmdW5jdGlvbi5cblxuICAgIE9mZmljaWFsIEFQSTogaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS9kb2NzL2ZhY2Vib29rLWxvZ2luL2xvZ2luLWZsb3ctZm9yLXdlYi92Mi4xXG4qKi9cbi8qZ2xvYmFsIHdpbmRvdyovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpLFxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLy8gRmFjZWJvb2sgQVBJIHNldHRpbmdzIGdhdGhlcmVkIGZyb20gdGhlIGN1cnJlbnQgcGFnZVxuLy8gb24gZmlyc3QgdXNlOlxudmFyIHNldHRpbmdzID0ge1xuICAgIGxhbmd1YWdlOiAnZW4tVVMnLFxuICAgIGFwcElkOiBudWxsXG59O1xuXG4vLyBQcml2YXRlIEFQSSBsb2FkaW5nL3JlYWR5IHN0YXR1c1xudmFyIGFwaVN0YXR1cyA9IHtcbiAgICByZWFkeTogZmFsc2UsXG4gICAgbG9hZGluZzogZmFsc2UsXG4gICAgLy8gUHJpdmF0ZSBzdGF0aWMgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgcmVnaXN0ZXJlZFxuICAgIHN0YWNrOiBbXVxufTtcblxuLyoqXG4gICAgUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICAgIEZhY2Vib29rIEFQSSBpcyByZWFkeS5cbiAgICBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgYXMgdW5pcXVlIHBhcmFtZXRlclxuICAgIHRoZSBGYWNlYm9vayBBUEkgb2JqZWN0ICgnRkInKVxuKiovXG5leHBvcnRzLnJlYWR5ID0gZnVuY3Rpb24gZmFjZWJvb2tSZWFkeShyZWFkeUNhbGxiYWNrKSB7XG5cbiAgICBpZiAoYXBpU3RhdHVzLnJlYWR5KSB7XG4gICAgICAgIC8vIERvdWJsZS1jaGVjayB0aGUgY2FsbGJhY2ssIGJlY2F1c2UgaXRzIG9wdGlvbmFsXG4gICAgICAgIC8vICh0aGF0J3MgYWxsb3cgdG8gdXNlIHRoaXMgZnVuY3Rpb24gZm9yY2UgdGhlIEFQSSBwcmUtbG9hZClcbiAgICAgICAgaWYgKHR5cGVvZihyZWFkeUNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJlYWR5Q2FsbGJhY2sod2luZG93LkZCKTtcbiAgICAgICAgLy8gUXVpayByZXR1cm5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFwaVN0YXR1cy5zdGFjay5wdXNoKHJlYWR5Q2FsbGJhY2spO1xuICAgIFxuICAgIGlmICghZmFjZWJvb2tSZWFkeS5pc0xvYWRpbmcpIHtcbiAgICAgICAgYXBpU3RhdHVzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIEdldCBzZXR0aW5ncyBmcm9tIHBhZ2UgYXR0cmlidXRlc1xuICAgICAgICBzZXR0aW5ncy5sYW5ndWFnZSA9ICQoJ1tkYXRhLWZhY2Vib29rLWxhbmd1YWdlXScpLmRhdGEoJ2ZhY2Vib29rLWxhbmd1YWdlJyk7XG4gICAgICAgIHNldHRpbmdzLmFwcElkID0gJCgnW2RhdGEtZmFjZWJvb2stYXBwaWRdJykuZGF0YSgnZmFjZWJvb2stYXBwaWQnKTtcblxuICAgICAgICBsb2FkZXIubG9hZCh7XG4gICAgICAgICAgICBzY3JpcHRzOiBbJy8vY29ubmVjdC5mYWNlYm9vay5uZXQvJyArIHNldHRpbmdzLmxhbmd1YWdlICsgJy9hbGwuanMnXSxcbiAgICAgICAgICAgIGNvbXBsZXRlVmVyaWZpY2F0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXdpbmRvdy5GQjsgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSAoRmFjZWJvb2sgcmVnaXN0ZXJzIGl0c2VsZiBhcyBnbG9iYWwgJ0ZCJylcbiAgICAgICAgICAgICAgICB3aW5kb3cuRkIuaW5pdCh7IGFwcElkOiBzZXR0aW5ncy5hcHBJZCwgc3RhdHVzOiB0cnVlLCBjb29raWU6IHRydWUsIHhmYm1sOiBmYWxzZSB9KTtcblxuICAgICAgICAgICAgICAgIC8vIElzIHJlYWR5XG4gICAgICAgICAgICAgICAgYXBpU3RhdHVzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhcGlTdGF0dXMubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFja3MgaW4gdGhlIHN0YWNrOlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXBpU3RhdHVzLnN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlTdGF0dXMuc3RhY2tbaV0od2luZG93LkZCKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihlKTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gICAgUmVxdWVzdCBhIEZhY2Vib29rIExvZ2luLCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICBTdWNjZXNzIGdldHMgdGhlICdhdXRoUmVzcG9uc2UnIGdpdmVuIGJ5IEZhY2Vib29rLFxuICAgIGFuZCBlcnJvciB0aGUgd2hvbGUgcmVzcG9uc2Ugb2JqZWN0LCBhbmQgYm90aFxuICAgIHRoZSBGQiBBUEkgYXMgc2Vjb25kIHBhcmFtZXRlci5cbioqL1xuZXhwb3J0cy5sb2dpbiA9IGZ1bmN0aW9uIGZhY2Vib29rTG9naW4ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAvLyBXaGVuIHRoZSBBUEkgaXMgcmVhZHlcbiAgICAgICAgZXhwb3J0cy5yZWFkeShmdW5jdGlvbiAoRkIpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gRmFjZWJvb2sgZ2l2ZXMgYSByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAvLyBMb2dpbiBSZXF1ZXN0XG4gICAgICAgICAgICBGQi5sb2dpbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF0dXM9PWNvbm5lY3RlZCBpZiB0aGVyZSBpcyBhbiBhdXRoUmVzcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuYXV0aFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoeyBhdXRoOiByZXNwb25zZS5hdXRoUmVzcG9uc2UsIEZCOiBGQiwgcmVzcG9uc2U6IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoeyByZXNwb25zZTogcmVzcG9uc2UsIEZCOiBGQiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuIiwiLyoqIGdldERhdGVXaXRob3V0VGltZSB1dGlsaXR5LlxuICAgIFJldHVybnMgYSBuZXcgRGF0ZSBpbnN0YW5jZSB3aXRoIHRpbWUgYXQgemVyb2VzXG4gICAgYW5kIHRoZSBzYW1lIGRhdGUgYXMgdGhlIGlucHV0LlxuICAgIEl0IHJldHVybnMgY3VycmVudCBkYXRlIGlmIG5vIHZhbGlkIGRhdGUgb3Igc3RyaW5nIHBhc3NlZC5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldERhdGVXaXRob3V0VGltZShkYXRlKSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXREYXRlKCksXG4gICAgICAgIDAsIDAsIDBcbiAgICApO1xufTtcbiIsIi8qKlxuICAgIEdldCBhIGdpdmVuIHZhbHVlIHdyYXBwZWQgaW4gYW4gb2JzZXJ2YWJsZSBvciByZXR1cm5zXG4gICAgaXQgaWYgaXRzIGFscmVhZHkgYW4gb2JzZXJ2YWJsZSBvciBqdXN0IGEgZnVuY3Rpb24uXG4qKi9cbid1c2Ugc3RyaWN0JztcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZShvYnNPclZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZihvYnNPclZhbHVlKSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIG9ic09yVmFsdWU7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4ga28ub2JzZXJ2YWJsZShvYnNPclZhbHVlKTtcbn07XG4iLCIvKipcbiAgICBSZWFkIGEgcGFnZSdzIEdFVCBVUkwgdmFyaWFibGVzIGFuZCByZXR1cm4gdGhlbSBhcyBhbiBhc3NvY2lhdGl2ZSBhcnJheS5cbioqL1xuJ3VzZXIgc3RyaWN0Jztcbi8vZ2xvYmFsIHdpbmRvd1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFVybFF1ZXJ5KHVybCkge1xuXG4gICAgdXJsID0gdXJsIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuXG4gICAgdmFyIHZhcnMgPSBbXSwgaGFzaCxcbiAgICAgICAgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuICAgICAgICB2YXIgaGFzaGVzID0gdXJsLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaGFzaGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBoYXNoID0gaGFzaGVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICB2YXJzLnB1c2goaGFzaFswXSk7XG4gICAgICAgICAgICB2YXJzW2hhc2hbMF1dID0gaGFzaFsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFycztcbn07XG4iLCIvLyBqUXVlcnkgcGx1Z2luIHRvIHNldCBtdWx0aWxpbmUgdGV4dCBpbiBhbiBlbGVtZW50LFxuLy8gYnkgcmVwbGFjaW5nIFxcbiBieSA8YnIvPiB3aXRoIGNhcmVmdWwgdG8gYXZvaWQgWFNTIGF0dGFja3MuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzA4MjAyOFxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4kLmZuLm11bHRpbGluZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB0aGlzLnRleHQodGV4dCk7XG4gICAgdGhpcy5odG1sKHRoaXMuaHRtbCgpLnJlcGxhY2UoL1xcbi9nLCc8YnIvPicpKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCIvKipcbiAgICBTZXQgb2YgdXRpbGl0aWVzIHRvIGRlZmluZSBKYXZhc2NyaXB0IFByb3BlcnRpZXNcbiAgICBpbmRlcGVuZGVudGx5IG9mIHRoZSBicm93c2VyLlxuICAgIFxuICAgIEFsbG93cyB0byBkZWZpbmUgZ2V0dGVycyBhbmQgc2V0dGVycy5cbiAgICBcbiAgICBBZGFwdGVkIGNvZGUgZnJvbSB0aGUgb3JpZ2luYWwgY3JlYXRlZCBieSBKZWZmIFdhbGRlblxuICAgIGh0dHA6Ly93aGVyZXN3YWxkZW4uY29tLzIwMTAvMDQvMTYvbW9yZS1zcGlkZXJtb25rZXktY2hhbmdlcy1hbmNpZW50LWVzb3RlcmljLXZlcnktcmFyZWx5LXVzZWQtc3ludGF4LWZvci1jcmVhdGluZy1nZXR0ZXJzLWFuZC1zZXR0ZXJzLWlzLWJlaW5nLXJlbW92ZWQvXG4qKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYWNjZXNzb3JEZXNjcmlwdG9yKGZpZWxkLCBmdW4pXG57XG4gICAgdmFyIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9O1xuICAgIGRlc2NbZmllbGRdID0gZnVuO1xuICAgIHJldHVybiBkZXNjO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVHZXR0ZXIob2JqLCBwcm9wLCBnZXQpXG57XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGFjY2Vzc29yRGVzY3JpcHRvcihcImdldFwiLCBnZXQpKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKVxuICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lR2V0dGVyX18ocHJvcCwgZ2V0KTtcblxuICAgIHRocm93IG5ldyBFcnJvcihcImJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBnZXR0ZXJzXCIpO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVTZXR0ZXIob2JqLCBwcm9wLCBzZXQpXG57XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGFjY2Vzc29yRGVzY3JpcHRvcihcInNldFwiLCBzZXQpKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKVxuICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgc2V0KTtcblxuICAgIHRocm93IG5ldyBFcnJvcihcImJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBzZXR0ZXJzXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWZpbmVHZXR0ZXI6IGRlZmluZUdldHRlcixcbiAgICBkZWZpbmVTZXR0ZXI6IGRlZmluZVNldHRlclxufTtcbiIsIi8qICBKYXZhc2NyaXB0IGxvYWRlciwgZm9yIGxhenkgbG9hZGluZyBzY3JpcHRzIG9yIGJ1bmRsZXMuXG4gICAgLy8gd2l0aCBNb2Rlcm5penI6IEFzc2V0cyBsb2FkZXIgd2l0aCBsb2FkaW5nIGNvbmZpcm1hdGlvbiAobWFpbmx5IGZvciBzY3JpcHRzKS5cbiAgICBcbiAgICBJdCB1c2VzIGpxdWVyeSBnZXRTY3JpcHQgQVBJXG4gICAgLy8gYmFzZWQgb24gTW9kZXJuaXpyL3llcG5vcGUgbG9hZGVyLlxuICAgIC8vIHZhciBNb2Rlcm5penIgPSByZXF1aXJlKCdtb2Rlcm5penInKTtcbiovXG4ndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vLyBVdGlsaXR5OiBwcm9taXNlIGJhc2VkIHRpbWVvdXQsIHJ1biB0YXNrIGFmdGVyIHRoZSByZXR1cm5lZCBwcm9taXNlLFxuLy8gYW5kIHRoYXQgdGFzayBjYW4gcmV0dXJuIGFub3RoZXIgcHJvbWlzZS5cbmZ1bmN0aW9uIHByb21pc2VUaW1lb3V0KG1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIG1pbGxpc2Vjb25kcyk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgLy8gRGVmaW5lIG9wdGlvbnMgZGVmYXVsdHMgYW5kIHVzZSBnaXZlbiB2YWx1ZXNcbiAgICBvcHRzID0gJC5leHRlbmQodHJ1ZSwge1xuICAgICAgICBzY3JpcHRzOiBbXSxcbiAgICAgICAgY29tcGxldGU6IG51bGwsXG4gICAgICAgIGNvbXBsZXRlVmVyaWZpY2F0aW9uOiBudWxsLFxuICAgICAgICBsb2FkRGVsYXk6IDAsXG4gICAgICAgIHRyaWFsc0ludGVydmFsOiA1MDBcbiAgICB9LCBvcHRzKTtcbiAgICAvLyBRdWljayByZXR1cm4sIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoIW9wdHMuc2NyaXB0cy5sZW5ndGgpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Db21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob3B0cy5jb21wbGV0ZVZlcmlmaWNhdGlvbikgIT09ICdmdW5jdGlvbicgfHwgb3B0cy5jb21wbGV0ZVZlcmlmaWNhdGlvbigpKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMQy5sb2FkLmNvbXBsZXRlVmVyaWZpY2F0aW9uIGZhaWxlZCBmb3IgJyArIG9wdHMuc2NyaXB0c1swXSArICcgcmV0cnlpbmcgaXQgaW4gJyArIG9wdHMudHJpYWxzSW50ZXJ2YWwgKyAnbXMnKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlVGltZW91dChvcHRzLnRyaWFsc0ludGVydmFsKS50aGVuKHBlcmZvcm1Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgICAgLypNb2Rlcm5penIubG9hZCh7XG4gICAgICAgICAgICBsb2FkOiBvcHRzLnNjcmlwdHMsXG4gICAgICAgICAgICBjb21wbGV0ZTogb3B0cy5jb21wbGV0ZSA/IHBlcmZvcm1Db21wbGV0ZSA6IG51bGxcbiAgICAgICAgfSk7Ki9cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdHMuc2NyaXB0cy5tYXAoZnVuY3Rpb24oc2MpIHsgcmV0dXJuICQuZ2V0U2NyaXB0KHNjKTsgfSkpXG4gICAgICAgIC50aGVuKG9wdHMuY29tcGxldGUgPyBwZXJmb3JtQ29tcGxldGUgOiBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2FkRGVsYXkpXG4gICAgICAgIHJldHVybiBwcm9taXNlVGltZW91dChvcHRzLmxvYWREZWxheSkudGhlbihsb2FkKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBsb2FkKCk7XG59O1xuIiwiLyoqXG4gICAgUmVtb3ZlIHRoZSBhY2NlbnQgYW5kIHNwZWNpYWwgY2hhcmFjdGVycyBmcm9tIGEgdGV4dFxuICAgIHJlcGxhY2luZyBlYWNoIGNoYXJhY3RlciBmb3IgaXRzIGJhc2ljIGVxdWl2YWxlbnQuXG4gICAgVXNlZnVsIHRvIHBlcmZvcm1zIHB1bmN0dWF0aW9uLWluc2Vuc2l0aXZlIHRleHQgc2VhcmNocy5cbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwID0geyfDgCc6J0EnLCfDgSc6J0EnLCfDgic6J0EnLCfDgyc6J0EnLCfDhCc6J0EnLCfDhSc6J0EnLCfDhic6J0FFJywnw4cnOidDJywnw4gnOidFJywnw4knOidFJywnw4onOidFJywnw4snOidFJywnw4wnOidJJywnw40nOidJJywnw44nOidJJywnw48nOidJJywnw5AnOidEJywnw5EnOidOJywnw5InOidPJywnw5MnOidPJywnw5QnOidPJywnw5UnOidPJywnw5YnOidPJywnw5gnOidPJywnw5knOidVJywnw5onOidVJywnw5snOidVJywnw5wnOidVJywnw50nOidZJywnw58nOidzJywnw6AnOidhJywnw6EnOidhJywnw6InOidhJywnw6MnOidhJywnw6QnOidhJywnw6UnOidhJywnw6YnOidhZScsJ8OnJzonYycsJ8OoJzonZScsJ8OpJzonZScsJ8OqJzonZScsJ8OrJzonZScsJ8OsJzonaScsJ8OtJzonaScsJ8OuJzonaScsJ8OvJzonaScsJ8OxJzonbicsJ8OyJzonbycsJ8OzJzonbycsJ8O0JzonbycsJ8O1JzonbycsJ8O2JzonbycsJ8O4JzonbycsJ8O5JzondScsJ8O6JzondScsJ8O7JzondScsJ8O8JzondScsJ8O9JzoneScsJ8O/JzoneScsJ8SAJzonQScsJ8SBJzonYScsJ8SCJzonQScsJ8SDJzonYScsJ8SEJzonQScsJ8SFJzonYScsJ8SGJzonQycsJ8SHJzonYycsJ8SIJzonQycsJ8SJJzonYycsJ8SKJzonQycsJ8SLJzonYycsJ8SMJzonQycsJ8SNJzonYycsJ8SOJzonRCcsJ8SPJzonZCcsJ8SQJzonRCcsJ8SRJzonZCcsJ8SSJzonRScsJ8STJzonZScsJ8SUJzonRScsJ8SVJzonZScsJ8SWJzonRScsJ8SXJzonZScsJ8SYJzonRScsJ8SZJzonZScsJ8SaJzonRScsJ8SbJzonZScsJ8ScJzonRycsJ8SdJzonZycsJ8SeJzonRycsJ8SfJzonZycsJ8SgJzonRycsJ8ShJzonZycsJ8SiJzonRycsJ8SjJzonZycsJ8SkJzonSCcsJ8SlJzonaCcsJ8SmJzonSCcsJ8SnJzonaCcsJ8SoJzonSScsJ8SpJzonaScsJ8SqJzonSScsJ8SrJzonaScsJ8SsJzonSScsJ8StJzonaScsJ8SuJzonSScsJ8SvJzonaScsJ8SwJzonSScsJ8SxJzonaScsJ8SyJzonSUonLCfEsyc6J2lqJywnxLQnOidKJywnxLUnOidqJywnxLYnOidLJywnxLcnOidrJywnxLknOidMJywnxLonOidsJywnxLsnOidMJywnxLwnOidsJywnxL0nOidMJywnxL4nOidsJywnxL8nOidMJywnxYAnOidsJywnxYEnOidMJywnxYInOidsJywnxYMnOidOJywnxYQnOiduJywnxYUnOidOJywnxYYnOiduJywnxYcnOidOJywnxYgnOiduJywnxYknOiduJywnxYwnOidPJywnxY0nOidvJywnxY4nOidPJywnxY8nOidvJywnxZAnOidPJywnxZEnOidvJywnxZInOidPRScsJ8WTJzonb2UnLCfFlCc6J1InLCfFlSc6J3InLCfFlic6J1InLCfFlyc6J3InLCfFmCc6J1InLCfFmSc6J3InLCfFmic6J1MnLCfFmyc6J3MnLCfFnCc6J1MnLCfFnSc6J3MnLCfFnic6J1MnLCfFnyc6J3MnLCfFoCc6J1MnLCfFoSc6J3MnLCfFoic6J1QnLCfFoyc6J3QnLCfFpCc6J1QnLCfFpSc6J3QnLCfFpic6J1QnLCfFpyc6J3QnLCfFqCc6J1UnLCfFqSc6J3UnLCfFqic6J1UnLCfFqyc6J3UnLCfFrCc6J1UnLCfFrSc6J3UnLCfFric6J1UnLCfFryc6J3UnLCfFsCc6J1UnLCfFsSc6J3UnLCfFsic6J1UnLCfFsyc6J3UnLCfFtCc6J1cnLCfFtSc6J3cnLCfFtic6J1knLCfFtyc6J3knLCfFuCc6J1knLCfFuSc6J1onLCfFuic6J3onLCfFuyc6J1onLCfFvCc6J3onLCfFvSc6J1onLCfFvic6J3onLCfFvyc6J3MnLCfGkic6J2YnLCfGoCc6J08nLCfGoSc6J28nLCfGryc6J1UnLCfGsCc6J3UnLCfHjSc6J0EnLCfHjic6J2EnLCfHjyc6J0knLCfHkCc6J2knLCfHkSc6J08nLCfHkic6J28nLCfHkyc6J1UnLCfHlCc6J3UnLCfHlSc6J1UnLCfHlic6J3UnLCfHlyc6J1UnLCfHmCc6J3UnLCfHmSc6J1UnLCfHmic6J3UnLCfHmyc6J1UnLCfHnCc6J3UnLCfHuic6J0EnLCfHuyc6J2EnLCfHvCc6J0FFJywnx70nOidhZScsJ8e+JzonTycsJ8e/Jzonbyd9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbW92ZUFjY2VudChzdHIpIHtcblxuICAgIHZhciByZXMgPSAnJywgYztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIHJlcyArPSBtYXBbY10gfHwgYztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG4iLCIvKipcbiAgICBJdCBzY3JvbGwgYWxsIG5lZWRlZCBlbGVtZW50cyBpbiB0aGUgcGFnZSB0byBtYWtlIHRoZVxuICAgIHRhcmdldCBlbGVtZW50IHRvIGFwcGVhciBpbiB0aGUgc2NyZWVuLCBpZiBwb3NzaWJsZS5cbiAgICBcbiAgICBJdCBzY3JvbGxzIGFsbCB0aGUgZWxlbWVudCBhbmNlc3RvcnMgKHRoYXQgbWF5IGhhdmVcbiAgICBvciBub3QgYSBzY3JvbGxpbmcgY29udGV4dCkuXG4gICAgXG4gICAgT25seSB2ZXJ0aWNhbGx5LlxuICAgIFRPRE86IG1ha2UgaXQgaG9yaXpvbnRhbCB0b28uXG4qKi9cbi8vZ2xvYmFsIHdpbmRvd1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vLyBAcGFyYW0gZWw6RE9NRWxlbWVudHxqUXVlcnlcbi8vIEBwYXJhbSBvcHRpb25zOk9iamVjdCB7XG4vLyAgICAgIHRvcE9mZnNldDppbnQgIE9mZnNldCBzY3JvbGwgZnJvbSB0aGUgdG9wXG4vLyB9XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNjcm9sbFRvRWxlbWVudChlbCwgb3B0aW9ucykge1xuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6MTBcbiAgICB2YXIgcGFyZW50ID0gJChlbCkucGFyZW50KCk7XG5cbiAgICB2YXIgdG9wT2Zmc2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRvcE9mZnNldCB8fCAwO1xuICAgIHZhciBhbmltYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIFxuICAgIHZhciBhdFJvb3QgPSBmYWxzZTtcblxuICAgIGRvIHtcbiAgICAgICAgLy8gR28gb3V0IG9uIGRldGFjaGVkIGVsZW1lbnRzOlxuICAgICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAvLyBDaGVjayBpZiByb290IGVsZW1lbnQgKGVuZHMgbG9vcCBhbmQgaGFzIGRpZmZlcmVudCBydWxlcyBmb3Igc2Nyb2xsaW5nKVxuICAgICAgICBhdFJvb3QgPSBwYXJlbnQuZ2V0KDApID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBpcyBjYWxjdWxhdGVkIGluIGEgZGlmZmVyZW50IHdheVxuICAgICAgICAvLyB3aGVuIGF0IHRoZSByb290LCBzbyB0YWtlIGNhcmUgb2YgdGhhdFxuICAgICAgICB2YXIgcmVsYXRpdmVUb3AgPSBhdFJvb3QgPyBlbC5wb3NpdGlvbigpLnRvcCA6IGVsLm9mZnNldCgpLnRvcDtcbiAgICAgICAgXG4gICAgICAgIC8vIElNUE9SVEFOVDogZWxlbWVudFRvcCB3aXRoIG9mZnNldCBpcyB1c2VkIGFzIGlzIHdoZW4gYXRSb290XG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIG5leHQgc2Nyb2xsaW5nVG9wIGNhbGN1bGF0aW5nIG1ha2UgaXQgZmFpbFxuICAgICAgICB2YXIgZWxlbWVudFRvcCA9IHJlbGF0aXZlVG9wIC0gdG9wT2Zmc2V0O1xuICAgICAgICB2YXIgc2Nyb2xsaW5nVG9wID0gZWxlbWVudFRvcCArIHBhcmVudC5zY3JvbGxUb3AoKSAtIHBhcmVudC5vZmZzZXQoKS50b3A7XG5cbiAgICAgICAgaWYgKGF0Um9vdCkge1xuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBzcGVjaWFsIGNhc2UsIG9uIHRoZSByb290XG4gICAgICAgICAgICAvLyB3ZSBjYW4ganVzdCB1c2Ugd2luZG93LnNjcm9sbCBvciBzY3JvbGxUb3AgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gQlVUIHdpdGggYSBkaWZmZXJlbnQgYW1vdW50LCB0aGUgZWxlbWVudFRvcFxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICAkKCdodG1sLGJvZHknKS5zdG9wKCkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogZWxlbWVudFRvcCB9LCBhbmltYXRpb24pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgZWxlbWVudFRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uKVxuICAgICAgICAgICAgICAgIHBhcmVudC5zdG9wKCkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsaW5nVG9wIH0sIGFuaW1hdGlvbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcChzY3JvbGxpbmdUb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpO1xuICAgIH0gd2hpbGUoIWF0Um9vdCk7XG59O1xuIiwiLyoqXG4gICAgRG9tSXRlbXNNYW5hZ2VyIGNsYXNzLCB0aGF0IG1hbmFnZSBhIGNvbGxlY3Rpb24gXG4gICAgb2YgSFRNTC9ET00gaXRlbXMgdW5kZXIgYSByb290L2NvbnRhaW5lciwgd2hlcmVcbiAgICBvbmx5IG9uZSBlbGVtZW50IGF0IHRoZSB0aW1lIGlzIHZpc2libGUsIHByb3ZpZGluZ1xuICAgIHRvb2xzIHRvIHVuaXF1ZXJseSBpZGVudGlmeSB0aGUgaXRlbXMsXG4gICAgdG8gY3JlYXRlIG9yIHVwZGF0ZSBuZXcgaXRlbXMgKHRocm91Z2ggJ2luamVjdCcpLFxuICAgIGdldCB0aGUgY3VycmVudCwgZmluZCBieSB0aGUgSUQgYW5kIG1vcmUuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBlc2NhcGVTZWxlY3RvciA9IHJlcXVpcmUoJy4uL2VzY2FwZVNlbGVjdG9yJyk7XG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuLi91c2VyQWdlbnRGbGFncycpO1xuXG5mdW5jdGlvbiBEb21JdGVtc01hbmFnZXIoc2V0dGluZ3MpIHtcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjEwXG5cbiAgICB0aGlzLmlkQXR0cmlidXRlTmFtZSA9IHNldHRpbmdzLmlkQXR0cmlidXRlTmFtZSB8fCAnaWQnO1xuICAgIHRoaXMuYWxsb3dEdXBsaWNhdGVzID0gISFzZXR0aW5ncy5hbGxvd0R1cGxpY2F0ZXMgfHwgZmFsc2U7XG4gICAgdGhpcy5yb290ID0gc2V0dGluZ3Mucm9vdCB8fCAnYm9keSc7XG4gICAgdGhpcy4kcm9vdCA9IG51bGw7XG4gICAgLy8gRGVmaW5lIGluIG1zIHRoZSBkZWxheSBpbiBhIHN3aXRjaCBvZiBpdGVtcyAocHJlcGFyZSBuZXh0IC0+ZGVsYXktPiBoaWRlIGN1cnJlbnQsIHNob3cgbmV4dClcbiAgICAvLyBOT1RFOiBhcyBvZiB0ZXN0aW5nIGluIGlPUyA4LjMgaVBhZDIgKHNsb3cpLCAxNDBtcyBlbmRlZCBiZWluZyBhIGdvb2QgZGVmYXVsdFxuICAgIC8vIHRvIGF2b2lkIHNvbWUgZmxpY2tlcmluZyBlZmZlY3RzLCBlbm91Z2ggdG8gbGV0IGluaXRpYWxpemF0aW9uIGxvZ2ljIHRvIGZpbmlzaCBiZWZvcmVcbiAgICAvLyBiZWluZyBzaG93ZWQsIGFsbG93IHNvbWUgY29tbW9uIGFzeW5jIHJlZGlyZWN0cyB3aGVuIGV4ZWN1dGluZyBhbiBpdGVtIGxvZ2ljIGJ1dFxuICAgIC8vIGVub3VnaCBxdWljayB0byBub3QgYmVpbmcgdmlzdWFsbHkgcGVyY2VpdmVkIHRoZSBkZWxheS5cbiAgICAvLyBOT1RFOiBvbiB0ZXN0cyBvbiBOZXh1cyA1IEFuZHJvaWQgNS4xIHdpdGggQ2hyb21lIGVuZ2luZSwgNDBtcyB3YXMgZW5vdWdodCB0byBoYXZlIGFsbCB0aGUgcHJldmlvdXNcbiAgICAvLyBiZW5lZml0cywgYnV0IHdhcyB0b28gcXVpY2sgZm9yIGlPUyAoZXZlbiAxMDBtcyB3YXMgdG9vIHF1aWNrIGZvciBpT1MgOC4zKS5cbiAgICB2YXIgZGVmYXVsdERlbGF5ID0gMTQwO1xuICAgIC8vIE5PVEU6VVBEQVRFOiBVc2luZyBXa1dlYlZpZXcgb24gaU9TICg4Lnggd2l0aCB1bm9mZmljaWFsIHBsdWdpbiB3aXRoIHdlYnNlcnZlciwgOS54IHdpbGwgYmUgd2l0aCBvZmZpY2lhbCBzdXBwb3J0IG5vLXdlYnNlcnZlcilcbiAgICAvLyBpdCdzIGZhc3Rlc3QsIHNvIHRyeWluZyB1c2VyLWFnZW50IHNuaWZmaW5nIHRvIHVzZSB0aGUgZmFzdGVzdCBkZWxheSBvbiB0aGlzIGVuZ2luZSwgY2hyb21lIGVuZ2luZSBvciBkZXNrdG9wIChub24tbW9iaWxlKVxuICAgIC8vIGFuZCBsZWZ0IGhlIGNvbnNlcnZhdGl2ZSBkZWxheSBmb3Igb3RoZXIgY2FzZXMgKG9sZCBpT1Mvd2Vidmlldywgb2xkIGFuZHJvaWQgd2Via2l0IGVuZ2luZSkuXG4gICAgdmFyIGZsYWdzID0gZ2V0RmxhZ3MoKTtcbiAgICAvLyBpZiBub3QgaXMgbW9iaWxlIE9SIGlzIENocm9tZSBPUiBpcyBXS1dlYnZpZXdcbiAgICBpZiAoIWZsYWdzLmlzTW9iaWxlIHx8IGZsYWdzLmlzQ2hyb21lIHx8IGZsYWdzLmlzV2tXZWJ2aWV3KVxuICAgICAgICBkZWZhdWx0RGVsYXkgPSA0MDtcbiAgICBcbiAgICB0aGlzLnN3aXRjaERlbGF5ID0gc2V0dGluZ3Muc3dpdGNoRGVsYXkgfHwgZGVmYXVsdERlbGF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvbUl0ZW1zTWFuYWdlcjtcblxuRG9tSXRlbXNNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxJdGVtcyA9IGZ1bmN0aW9uIGdldEFsbEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLiRyb290LmNoaWxkcmVuKCdbJyArIHRoaXMuaWRBdHRyaWJ1dGVOYW1lICsgJ10nKTtcbn07XG5cbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQoY29udGFpbmVyTmFtZSwgcm9vdCkge1xuICAgIHZhciAkcm9vdCA9ICQocm9vdCB8fCB0aGlzLiRyb290KTtcbiAgICByZXR1cm4gJHJvb3QuY2hpbGRyZW4oJ1snICsgdGhpcy5pZEF0dHJpYnV0ZU5hbWUgKyAnPVwiJyArIGVzY2FwZVNlbGVjdG9yKGNvbnRhaW5lck5hbWUpICsgJ1wiXScpO1xufTtcblxuRG9tSXRlbXNNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3RpdmUgPSBmdW5jdGlvbiBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuJHJvb3QuY2hpbGRyZW4oJ1snICsgdGhpcy5pZEF0dHJpYnV0ZU5hbWUgKyAnXTp2aXNpYmxlJyk7XG59O1xuXG4vKipcbiAgICBJdCBhZGRzIHRoZSBpdGVtIGluIHRoZSBodG1sIHByb3ZpZGVkIChjYW4gYmUgb25seSB0aGUgZWxlbWVudCBvciBcbiAgICBjb250YWluZWQgaW4gYW5vdGhlciBvciBhIGZ1bGwgaHRtbCBwYWdlKS5cbiAgICBSZXBsYWNlcyBhbnkgZXhpc3RhbnQgaWYgZHVwbGljYXRlcyBhcmUgbm90IGFsbG93ZWQuXG4qKi9cbkRvbUl0ZW1zTWFuYWdlci5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KG5hbWUsIGh0bWwpIHtcblxuICAgIC8vIEZpbHRlcmluZyBpbnB1dCBodG1sIChjYW4gYmUgcGFydGlhbCBvciBmdWxsIHBhZ2VzKVxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEyODQ4Nzk4XG4gICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXltcXHNcXFNdKjxib2R5Lio/Pnw8XFwvYm9keT5bXFxzXFxTXSokL2csICcnKTtcblxuICAgIC8vIENyZWF0aW5nIGEgd3JhcHBlciBhcm91bmQgdGhlIGh0bWxcbiAgICAvLyAoY2FuIGJlIHByb3ZpZGVkIHRoZSBpbm5lckh0bWwgb3Igb3V0ZXJIdG1sLCBkb2Vzbid0IG1hdHRlcnMgd2l0aCBuZXh0IGFwcHJvYWNoKVxuICAgIHZhciAkaHRtbCA9ICQoJzxkaXYvPicsIHsgaHRtbDogaHRtbCB9KSxcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgdGhlIGNvbnRhaW5lciBlbGVtZW50ICh3aGVuIHRoZSBvdXRlckh0bWwgaXMgcHJvdmlkZWQpXG4gICAgICAgICRjID0gdGhpcy5maW5kKG5hbWUsICRodG1sKTtcblxuICAgIGlmICgkYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSXRzIGlubmVySHRtbCwgc28gdGhlIHdyYXBwZXIgYmVjb21lcyB0aGUgY29udGFpbmVyIGl0c2VsZlxuICAgICAgICAkYyA9ICRodG1sLmF0dHIodGhpcy5pZEF0dHJpYnV0ZU5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgICAgLy8gTm8gbW9yZSB0aGFuIG9uZSBjb250YWluZXIgaW5zdGFuY2UgY2FuIGV4aXN0cyBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGFueSBleGlzdGVudCBvbmUgYW5kIGl0cyByZXBsYWNlZCB3aXRoIHRoZSBuZXdcbiAgICAgICAgdmFyICRwcmV2ID0gdGhpcy5maW5kKG5hbWUpO1xuICAgICAgICBpZiAoJHByZXYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJHByZXYucmVwbGFjZVdpdGgoJGMpO1xuICAgICAgICAgICAgJGMgPSAkcHJldjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0byB0aGUgZG9jdW1lbnRcbiAgICAvLyAob24gdGhlIGNhc2Ugb2YgZHVwbGljYXRlZCBmb3VuZCwgdGhpcyB3aWxsIGRvIG5vdGhpbmcsIG5vIHdvcnJ5KVxuICAgICRjLmFwcGVuZFRvKHRoaXMuJHJvb3QpO1xufTtcblxuLyoqIFxuICAgIFRoZSBzd2l0Y2ggbWV0aG9kIHJlY2VpdmUgdGhlIGl0ZW1zIHRvIGludGVyY2hhbmdlIGFzIGFjdGl2ZSBvciBjdXJyZW50LFxuICAgIHRoZSAnZnJvbScgYW5kICd0bycsIGFuZCB0aGUgc2hlbGwgaW5zdGFuY2UgdGhhdCBNVVNUIGJlIHVzZWRcbiAgICB0byBub3RpZnkgZWFjaCBldmVudCB0aGF0IGludm9sdmVzIHRoZSBpdGVtOlxuICAgIHdpbGxDbG9zZSwgd2lsbE9wZW4sIHJlYWR5LCBvcGVuZWQsIGNsb3NlZC5cbiAgICBJdCByZWNlaXZlcyBhcyBsYXRlc3QgcGFyYW1ldGVyIHRoZSAnbm90aWZpY2F0aW9uJyBvYmplY3QgdGhhdCBtdXN0IGJlXG4gICAgcGFzc2VkIHdpdGggdGhlIGV2ZW50IHNvIGhhbmRsZXJzIGhhcyBjb250ZXh0IHN0YXRlIGluZm9ybWF0aW9uLlxuICAgIFxuICAgIEl0J3MgZGVzaWduZWQgdG8gYmUgYWJsZSB0byBtYW5hZ2UgdHJhbnNpdGlvbnMsIGJ1dCB0aGlzIGRlZmF1bHRcbiAgICBpbXBsZW1lbnRhdGlvbiBpcyBhcyBzaW1wbGUgYXMgJ3Nob3cgdGhlIG5ldyBhbmQgaGlkZSB0aGUgb2xkJy5cbioqL1xuRG9tSXRlbXNNYW5hZ2VyLnByb3RvdHlwZS5zd2l0Y2ggPSBmdW5jdGlvbiBzd2l0Y2hBY3RpdmVJdGVtKCRmcm9tLCAkdG8sIHNoZWxsLCBzdGF0ZSkge1xuXG4gICAgdmFyIHRvTmFtZSA9IHN0YXRlLnJvdXRlLm5hbWU7XG4gICAgLy9jb25zb2xlLmxvZygnc3dpdGNoIHRvJywgdG9OYW1lKTtcbiAgICBcbiAgICB0aGlzLmRpc2FibGVBY2Nlc3MoKTtcbiAgICBcbiAgICBmdW5jdGlvbiBoaWRlaXQoKSB7XG4gICAgICAgIHZhciBmcm9tSXNIaWRkZW4gPSAkZnJvbS5pcygnW2hpZGRlbl0nKTtcbiAgICAgICAgaWYgKCRmcm9tLmxlbmd0aCA+IDAgJiYgIWZyb21Jc0hpZGRlbikge1xuICAgICAgICAgICAgc2hlbGwuZW1pdChzaGVsbC5ldmVudHMud2lsbENsb3NlLCAkZnJvbSwgc3RhdGUpO1xuICAgICAgICAgICAgLy8gRG8gJ3VuZm9jdXMnIG9uIHRoZSBoaWRkZW4gZWxlbWVudCBhZnRlciBub3RpZnkgJ3dpbGxDbG9zZSdcbiAgICAgICAgICAgIC8vIGZvciBiZXR0ZXIgVVg6IGhpZGRlbiBlbGVtZW50cyBhcmUgbm90IHJlYWNoYWJsZSBhbmQgaGFzIGdvb2RcbiAgICAgICAgICAgIC8vIHNpZGUgZWZmZWN0cyBsaWtlIGhpZGRpbmcgdGhlIG9uLXNjcmVlbiBrZXlib2FyZCBpZiBhbiBpbnB1dCB3YXNcbiAgICAgICAgICAgIC8vIGZvY3VzZWRcbiAgICAgICAgICAgICRmcm9tLmZpbmQoJzpmb2N1cycpLmJsdXIoKTtcbiAgICAgICAgICAgIC8vIGhpZGUgYW5kIG5vdGlmeSBpdCBlbmRlZFxuICAgICAgICAgICAgJGZyb21cbiAgICAgICAgICAgIC5hdHRyKCdoaWRkZW4nLCAnaGlkZGVuJylcbiAgICAgICAgICAgIC8vIEZvciBicm93c2VyIHRoYXQgZG9uJ3Qgc3VwcG9ydCBhdHRyXG4gICAgICAgICAgICAuY3NzKCdkaXNwbGF5JywgJ25vbmUnKVxuICAgICAgICAgICAgLy8gUmVzZXQgei1pbmRleCB0byBhdm9pZCBvdmVybGFwcGluZyBlZmZlY3RcbiAgICAgICAgICAgIC5jc3MoJ3otaW5kZXgnLCAnJyk7XG5cbiAgICAgICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLmNsb3NlZCwgJGZyb20sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEp1c3QgdW5mb2N1cyB0byBhdm9pZCBrZXlib2FyZCBwcm9ibGVtc1xuICAgICAgICAgICAgJGZyb20uZmluZCgnOmZvY3VzJykuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRvSXNIaWRkZW4gPSAkdG8uaXMoJ1toaWRkZW5dJyk7IC8vICEkdG8uaXMoJzp2aXNpYmxlJylcblxuICAgIGlmICh0b0lzSGlkZGVuKSB7XG4gICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLndpbGxPcGVuLCAkdG8sIHN0YXRlKTtcbiAgICAgICAgLy8gUHV0IG91dHNpZGUgc2NyZWVuXG4gICAgICAgIC8qIERPTkUgQUxSRUFEWSBpbiB0aGUgQ1NTIGNsYXNzIGFzc2lnbmVkIHRvIGl0ZW1zXG4gICAgICAgICR0by5jc3Moe1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwXG4gICAgICAgIH0pOyovXG4gICAgICAgICR0by5jc3MoJ3pJbmRleCcsIC0xKTtcblxuICAgICAgICAvLyBTaG93IGl0OlxuICAgICAgICAkdG9cbiAgICAgICAgLnJlbW92ZUF0dHIoJ2hpZGRlbicpXG4gICAgICAgIC8vIEZvciBicm93c2VyIHRoYXQgZG9uJ3Qgc3VwcG9ydCBhdHRyXG4gICAgICAgIC5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcblxuICAgICAgICAvLyBJdHMgZW5vdWdoIHZpc2libGUgYW5kIGluIERPTSB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHRhc2tzXG4gICAgICAgIC8vIHRoYXQgbWF5IGludm9sdmUgbGF5b3V0IGluZm9ybWF0aW9uXG4gICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLml0ZW1SZWFkeSwgJHRvLCBzdGF0ZSk7XG4gICAgICAgIFxuICAgICAgICAvL2NvbnNvbGUubG9nKCdTV0lUQ0ggcmVhZHkgZG9uZSwgd2FpdCcsIHRvTmFtZSk7XG5cbiAgICAgICAgLy8gRmluaXNoIGluIGEgc21hbGwgZGVsYXksIGVub3VnaCB0byBhbGxvdyBzb21lIGluaXRpYWxpemF0aW9uXG4gICAgICAgIC8vIHNldC11cCB0aGF0IHRha2Ugc29tZSB0aW1lIHRvIGZpbmlzaCBhdm9pZGluZyBmbGlja2VyaW5nIGVmZmVjdHNcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NXSVRDSCBlbnRlcmluZyBoaWRlLXNob3cgZm9yJywgdG9OYW1lLCBzaGVsbC5jdXJyZW50Um91dGUubmFtZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdlbmRpbmcgc3dpdGNoIHRvJywgdG9OYW1lLCAnYW5kIGN1cnJlbnQgaXMnLCBzaGVsbC5jdXJyZW50Um91dGUubmFtZSk7XG4gICAgICAgICAgICAvLyBSYWNlIGNvbmRpdGlvbiwgcmVkaXJlY3Rpb24gaW4gdGhlIG1pZGRsZSwgYWJvcnQ6XG4gICAgICAgICAgICBpZiAodG9OYW1lICE9PSBzaGVsbC5jdXJyZW50Um91dGUubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIGZyb21cbiAgICAgICAgICAgIGhpZGVpdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbmRzIG9wZW5pbmcsIHJlc2V0IHRyYW5zaXRpb25hbCBzdHlsZXNcbiAgICAgICAgICAgIC8qIFNFVFVQIElTIEFMUkVBRFkgQ09SUkVDVCBpbiB0aGUgQ1NTIGNsYXNzIGFzc2lnbmVkIHRvIGl0ZW1zXG4gICAgICAgICAgICAkdG8uY3NzKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgICAgICBib3R0b206ICcnLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICR0by5jc3MoJ3pJbmRleCcsIDIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUFjY2VzcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdTV0lUQ0ggZW5kZWQgZm9yJywgdG9OYW1lKTtcblxuICAgICAgICAgICAgLy8gV2hlbiBpdHMgY29tcGxldGVseSBvcGVuZWRcbiAgICAgICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLm9wZW5lZCwgJHRvLCBzdGF0ZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5zd2l0Y2hEZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZW5kaW5nIHN3aXRjaCB0bycsIHRvTmFtZSwgJ2FuZCBjdXJyZW50IGlzJywgc2hlbGwuY3VycmVudFJvdXRlLm5hbWUsICdJTlNUQU5UICh0byB3YXMgdmlzaWJsZSknKTtcbiAgICAgICAgLy8gUmFjZSBjb25kaXRpb24sIHJlZGlyZWN0aW9uIGluIHRoZSBtaWRkbGUsIGFib3J0OlxuICAgICAgICBpZiAodG9OYW1lICE9PSBzaGVsbC5jdXJyZW50Um91dGUubmFtZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIEl0cyByZWFkeTsgbWF5YmUgaXQgd2FzIGJ1dCBzdWItbG9jYXRpb25cbiAgICAgICAgLy8gb3Igc3RhdGUgY2hhbmdlIG5lZWQgdG8gYmUgY29tbXVuaWNhdGVkXG4gICAgICAgIHNoZWxsLmVtaXQoc2hlbGwuZXZlbnRzLml0ZW1SZWFkeSwgJHRvLCBzdGF0ZSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVuYWJsZUFjY2VzcygpO1xuICAgICAgICBcbiAgICAgICAgaGlkZWl0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gICAgSW5pdGlhbGl6ZXMgdGhlIGxpc3Qgb2YgaXRlbXMuIE5vIG1vcmUgdGhhbiBvbmVcbiAgICBtdXN0IGJlIG9wZW5lZC92aXNpYmxlIGF0IHRoZSBzYW1lIHRpbWUsIHNvIGF0IHRoZSBcbiAgICBpbml0IGFsbCB0aGUgZWxlbWVudHMgYXJlIGNsb3NlZCB3YWl0aW5nIHRvIHNldFxuICAgIG9uZSBhcyB0aGUgYWN0aXZlIG9yIHRoZSBjdXJyZW50IG9uZS5cbiAgICBcbiAgICBFeGVjdXRlIGFmdGVyIERPTSByZWFkeS5cbioqL1xuRG9tSXRlbXNNYW5hZ2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAvLyBPbiByZWFkeSwgZ2V0IHRoZSByb290IGVsZW1lbnQ6XG4gICAgdGhpcy4kcm9vdCA9ICQodGhpcy5yb290IHx8ICdib2R5Jyk7XG5cbiAgICB0aGlzLmdldEFsbEl0ZW1zKClcbiAgICAuYXR0cignaGlkZGVuJywgJ2hpZGRlbicpXG4gICAgLy8gRm9yIGJyb3dzZXIgdGhhdCBkb24ndCBzdXBwb3J0IGF0dHJcbiAgICAuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICBcbiAgICAvLyBBIGxheWVyIHRvIHZpc3VhbGx5IGhpZGUgYW4gb3BlbmluZyBpdGVtIHdoaWxlIG5vdCBjb21wbGV0ZWQgb3BlbmVkXG4gICAgJCgnPGRpdiBjbGFzcz1cIml0ZW1zLWJhY2tzdGFnZVwiLz4nKS5jc3Moe1xuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLiRyb290LmNzcygnYmFja2dyb3VuZC1jb2xvcicpIHx8ICd3aGl0ZScsXG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHpJbmRleDogMFxuICAgIH0pLmFwcGVuZFRvKHRoaXMuJHJvb3QpO1xuICAgIFxuICAgIC8vIEEgbGF5ZXIgdG8gZGlzYWJsZSBhY2Nlc3MgdG8gYW4gaXRlbSAoZGlzYWJsaW5nIGV2ZW50cylcbiAgICAvLyBOT1RFOiBUcmllZCBDU1MgcG9pbnRlci1ldmVudHM6bm9uZSBoYXMgc29tZSBzdHJhbmdlIHNpZGUtZWZmZWN0czogYXV0byBzY3JvbGwtdXAuXG4gICAgLy8gVE9ETzogQWZ0ZXIgc29tZSB0ZXN0aW5nIHdpdGggdGhpcywgc2Nyb2xsLXVwIGhhcHBlbnMgYWdhaW4gd2l0aCB0aGlzICg/PylcbiAgICB2YXIgJGRpc2FibGVMYXllciA9ICQoJzxkaXYgY2xhc3M9XCJpdGVtcy1kaXNhYmxlLWxheWVyXCIvPicpLmNzcyh7XG4gICAgICAgIGJhY2tncm91bmQ6ICdXaGl0ZScsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHpJbmRleDogLTFcbiAgICB9KS5hcHBlbmRUbyh0aGlzLiRyb290KTtcbiAgICB0aGlzLmRpc2FibGVBY2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJGRpc2FibGVMYXllci5jc3MoJ3pJbmRleCcsIDkwOTAwKTtcbiAgICB9O1xuICAgIHRoaXMuZW5hYmxlQWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICRkaXNhYmxlTGF5ZXIuY3NzKCd6SW5kZXgnLCAtMik7XG4gICAgfTtcbn07XG4iLCIvKipcbiAgICBKYXZhc2NyaXRwIFNoZWxsIGZvciBTUEFzLlxuKiovXG4vKmdsb2JhbCB3aW5kb3csIGRvY3VtZW50ICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBESSBlbnRyeSBwb2ludHMgZm9yIGRlZmF1bHQgYnVpbGRzLiBNb3N0IGRlcGVuZGVuY2llcyBjYW4gYmVcbiAgICBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHNldHRpbmdzIGZvciBwZXItaW5zdGFuY2Ugc2V0dXAuXG4qKi9cbnZhciBkZXBzID0gcmVxdWlyZSgnLi9kZXBlbmRlbmNpZXMnKTtcblxuLyoqIENvbnN0cnVjdG9yICoqL1xuXG5mdW5jdGlvbiBTaGVsbChzZXR0aW5ncykge1xuICAgIC8vanNoaW50IG1heGNvbXBsZXhpdHk6MTRcbiAgICBcbiAgICBkZXBzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy4kID0gc2V0dGluZ3MuanF1ZXJ5IHx8IGRlcHMuanF1ZXJ5O1xuICAgIHRoaXMuJHJvb3QgPSB0aGlzLiQoc2V0dGluZ3Mucm9vdCk7XG4gICAgdGhpcy5iYXNlVXJsID0gc2V0dGluZ3MuYmFzZVVybCB8fCAnJztcbiAgICAvLyBXaXRoIGZvcmNlSGFzaGJhbmc9dHJ1ZTpcbiAgICAvLyAtIGZyYWdtZW50cyBVUkxzIGNhbm5vdCBiZSB1c2VkIHRvIHNjcm9sbCB0byBhbiBlbGVtZW50IChkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IpLFxuICAgIC8vICAgdGhleSBhcmUgZGVmYXVsdFByZXZlbnRlZCB0byBhdm9pZCBjb25mdXNlIHRoZSByb3V0aW5nIG1lY2hhbmlzbSBhbmQgY3VycmVudCBVUkwuXG4gICAgLy8gLSBwcmVzc2VkIGxpbmtzIHRvIGZyYWdtZW50cyBVUkxzIGFyZSBub3Qgcm91dGVkLCB0aGV5IGFyZSBza2lwcGVkIHNpbGVudGx5XG4gICAgLy8gICBleGNlcHQgd2hlbiB0aGV5IGFyZSBhIGhhc2hiYW5nICgjISkuIFRoaXMgd2F5LCBzcGVjaWFsIGxpbmtzXG4gICAgLy8gICB0aGF0IHBlcmZvcm1uIGpzIGFjdGlvbnMgZG9lc24ndCBjb25mbGl0cy5cbiAgICAvLyAtIGFsbCBVUkxzIHJvdXRlZCB0aHJvdWdoIHRoZSBzaGVsbCBpbmNsdWRlcyBhIGhhc2hiYW5nICgjISksIHRoZSBzaGVsbCBlbnN1cmVzXG4gICAgLy8gICB0aGF0IGhhcHBlbnMgYnkgYXBwZW5kaW5nIHRoZSBoYXNoYmFuZyB0byBhbnkgVVJMIHBhc3NlZCBpbiAoZXhjZXB0IHRoZSBzdGFuZGFyZCBoYXNoXG4gICAgLy8gICB0aGF0IGFyZSBza2lwdCkuXG4gICAgdGhpcy5mb3JjZUhhc2hiYW5nID0gc2V0dGluZ3MuZm9yY2VIYXNoYmFuZyB8fCBmYWxzZTtcbiAgICB0aGlzLmxpbmtFdmVudCA9IHNldHRpbmdzLmxpbmtFdmVudCB8fCAnY2xpY2snO1xuICAgIHRoaXMucGFyc2VVcmwgPSAoc2V0dGluZ3MucGFyc2VVcmwgfHwgZGVwcy5wYXJzZVVybCkuYmluZCh0aGlzLCB0aGlzLmJhc2VVcmwpO1xuICAgIHRoaXMuYWJzb2x1dGl6ZVVybCA9IChzZXR0aW5ncy5hYnNvbHV0aXplVXJsIHx8IGRlcHMuYWJzb2x1dGl6ZVVybCkuYmluZCh0aGlzLCB0aGlzLmJhc2VVcmwpO1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gc2V0dGluZ3MuaGlzdG9yeSB8fCB3aW5kb3cuaGlzdG9yeTtcblxuICAgIHRoaXMuaW5kZXhOYW1lID0gc2V0dGluZ3MuaW5kZXhOYW1lIHx8ICdpbmRleCc7XG4gICAgXG4gICAgdGhpcy5pdGVtcyA9IHNldHRpbmdzLmRvbUl0ZW1zTWFuYWdlcjtcblxuICAgIC8vIGxvYWRlciBjYW4gYmUgZGlzYWJsZWQgcGFzc2luZyAnbnVsbCcsIHNvIHdlIG11c3RcbiAgICAvLyBlbnN1cmUgdG8gbm90IHVzZSB0aGUgZGVmYXVsdCBvbiB0aGF0IGNhc2VzOlxuICAgIHRoaXMubG9hZGVyID0gdHlwZW9mKHNldHRpbmdzLmxvYWRlcikgPT09ICd1bmRlZmluZWQnID8gZGVwcy5sb2FkZXIgOiBzZXR0aW5ncy5sb2FkZXI7XG4gICAgLy8gbG9hZGVyIHNldHVwXG4gICAgaWYgKHRoaXMubG9hZGVyKVxuICAgICAgICB0aGlzLmxvYWRlci5iYXNlVXJsID0gdGhpcy5iYXNlVXJsO1xuXG4gICAgLy8gRGVmaW5pdGlvbiBvZiBldmVudHMgdGhhdCB0aGlzIG9iamVjdCBjYW4gdHJpZ2dlcixcbiAgICAvLyBpdHMgdmFsdWUgY2FuIGJlIGN1c3RvbWl6ZWQgYnV0IGFueSBsaXN0ZW5lciBuZWVkc1xuICAgIC8vIHRvIGtlZXAgdXBkYXRlZCB0byB0aGUgY29ycmVjdCBldmVudCBzdHJpbmctbmFtZSB1c2VkLlxuICAgIC8vIFRoZSBpdGVtcyBtYW5pcHVsYXRpb24gZXZlbnRzIE1VU1QgYmUgdHJpZ2dlcmVkXG4gICAgLy8gYnkgdGhlICdpdGVtcy5zd2l0Y2gnIGZ1bmN0aW9uXG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgIHdpbGxPcGVuOiAnc2hlbGwtd2lsbC1vcGVuJyxcbiAgICAgICAgd2lsbENsb3NlOiAnc2hlbGwtd2lsbC1jbG9zZScsXG4gICAgICAgIGl0ZW1SZWFkeTogJ3NoZWxsLWl0ZW0tcmVhZHknLFxuICAgICAgICBjbG9zZWQ6ICdzaGVsbC1jbG9zZWQnLFxuICAgICAgICBvcGVuZWQ6ICdzaGVsbC1vcGVuZWQnXG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgICAgQSBmdW5jdGlvbiB0byBkZWNpZGUgaWYgdGhlXG4gICAgICAgIGFjY2VzcyBpcyBhbGxvd2VkIChyZXR1cm5zICdudWxsJylcbiAgICAgICAgb3Igbm90IChyZXR1cm4gYSBzdGF0ZSBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvblxuICAgICAgICB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSAnbm9uQWNjZXNzTmFtZScgaXRlbTtcbiAgICAgICAgdGhlICdyb3V0ZScgcHJvcGVydHkgb24gdGhlIHN0YXRlIGlzIGF1dG9tYXRpY2FsbHkgZmlsbGVkKS5cbiAgICAgICAgXG4gICAgICAgIFRoZSBkZWZhdWx0IGJ1aXQtaW4ganVzdCBhbGxvdyBldmVyeXRoaW5nIFxuICAgICAgICBieSBqdXN0IHJldHVybmluZyAnbnVsbCcgYWxsIHRoZSB0aW1lLlxuICAgICAgICBcbiAgICAgICAgSXQgcmVjZWl2ZXMgYXMgcGFyYW1ldGVyIHRoZSBzdGF0ZSBvYmplY3QsXG4gICAgICAgIHRoYXQgYWxtb3N0IGNvbnRhaW5zIHRoZSAncm91dGUnIHByb3BlcnR5IHdpdGhcbiAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIFVSTC5cbiAgICAqKi9cbiAgICB0aGlzLmFjY2Vzc0NvbnRyb2wgPSBzZXR0aW5ncy5hY2Nlc3NDb250cm9sIHx8IGRlcHMuYWNjZXNzQ29udHJvbDtcbiAgICAvLyBXaGF0IGl0ZW0gbG9hZCBvbiBub24gYWNjZXNzXG4gICAgdGhpcy5ub25BY2Nlc3NOYW1lID0gc2V0dGluZ3Mubm9uQWNjZXNzTmFtZSB8fCAnaW5kZXgnO1xuICAgIFxuICAgIC8vIEFjY2VzcyB0byB0aGUgY3VycmVudCByb3V0ZVxuICAgIHRoaXMuY3VycmVudFJvdXRlID0gbnVsbDtcbiAgICAvLyBBY2Nlc3MgdG8gcmVmZXJyZXIvcHJldmlvdXMgcm91dGVcbiAgICB0aGlzLnJlZmVycmVyUm91dGUgPSBudWxsO1xufVxuXG4vLyBTaGVsbCBpbmhlcml0cyBmcm9tIEV2ZW50RW1pdHRlclxuU2hlbGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShkZXBzLkV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogU2hlbGwsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2hlbGw7XG5cblxuLyoqIEFQSSBkZWZpbml0aW9uICoqL1xuXG5TaGVsbC5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyh1cmwsIHN0YXRlKSB7XG5cbiAgICBpZiAodGhpcy5mb3JjZUhhc2hiYW5nKSB7XG4gICAgICAgIGlmICghL14jIS8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgICB1cmwgPSAnIyEnICsgdXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgPSB0aGlzLmFic29sdXRpemVVcmwodXJsKTtcbiAgICB9XG4gICAgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdW5kZWZpbmVkLCB1cmwpO1xuICAgIC8vIHB1c2hTdGF0ZSBkbyBOT1QgdHJpZ2dlciB0aGUgcG9wc3RhdGUgZXZlbnQsIHNvXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZShzdGF0ZSk7XG59O1xuXG5TaGVsbC5wcm90b3R5cGUuZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKHN0YXRlLCBzdGVwcykge1xuICAgIHN0ZXBzID0gMCAtIChzdGVwcyB8fCAxKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBub3RoaW5nIHRvIGdvLWJhY2sgb3Igbm90IGVub3VnaHRcbiAgICAvLyAnYmFjaycgc3RlcHMsIGdvIHRvIHRoZSBpbmRleFxuICAgIGlmIChzdGVwcyA8IDAgJiYgTWF0aC5hYnMoc3RlcHMpID49IHRoaXMuaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5nbyh0aGlzLmluZGV4TmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPbiByZXBsYWNlLCB0aGUgcGFzc2VkIHN0YXRlIGlzIG1lcmdlZCB3aXRoXG4gICAgICAgIC8vIHRoZSBvbmUgdGhhdCBjb21lcyBmcm9tIHRoZSBzYXZlZCBoaXN0b3J5XG4gICAgICAgIC8vIGVudHJ5IChpdCAncG9wcycgd2hlbiBkb2luZyB0aGUgaGlzdG9yeS5nbygpKVxuICAgICAgICB0aGlzLl9wZW5kaW5nU3RhdGVVcGRhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5oaXN0b3J5LmdvKHN0ZXBzKTtcbiAgICB9XG59O1xuXG4vKipcbiAgICBQcm9jZXNzIHRoZSBnaXZlbiBzdGF0ZSBpbiBvcmRlciB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICBiYXNlZCBvbiB0aGF0IG9yIHRoZSBzYXZlZCBpbiBoaXN0b3J5LCBtZXJnZSBpdCB3aXRoXG4gICAgYW55IHVwZGF0ZWQgc3RhdGUgcGVuZGluZyBhbmQgYWRkcyB0aGUgcm91dGUgaW5mb3JtYXRpb24sXG4gICAgcmV0dXJuaW5nIGFuIHN0YXRlIG9iamVjdCBzdWl0YWJsZSB0byB1c2UuXG4qKi9cblNoZWxsLnByb3RvdHlwZS5nZXRVcGRhdGVkU3RhdGUgPSBmdW5jdGlvbiBnZXRVcGRhdGVkU3RhdGUoc3RhdGUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA4ICovXG4gICAgXG4gICAgLy8gRm9yIGN1cnJlbnQgdXNlcywgYW55IHBlbmRpbmdTdGF0ZVVwZGF0ZSBpcyB1c2VkIGFzXG4gICAgLy8gdGhlIHN0YXRlLCByYXRoZXIgdGhhbiB0aGUgcHJvdmlkZWQgb25lXG4gICAgc3RhdGUgPSB0aGlzLl9wZW5kaW5nU3RhdGVVcGRhdGUgfHwgc3RhdGUgfHwgdGhpcy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIFxuICAgIC8vIFRPRE86IG1vcmUgYWR2YW5jZWQgdXNlcyBtdXN0IGJlIHRvIHVzZSB0aGUgJ3N0YXRlJyB0b1xuICAgIC8vIHJlY292ZXIgdGhlIFVJIHN0YXRlLCB3aXRoIGFueSBtZXNzYWdlIGZyb20gb3RoZXIgVUlcbiAgICAvLyBwYXNzaW5nIGluIGEgd2F5IHRoYXQgYWxsb3cgdXBkYXRlIHRoZSBzdGF0ZSwgbm90XG4gICAgLy8gcmVwbGFjZSBpdCAoZnJvbSBwZW5kaW5nU3RhdGVVcGRhdGUpLlxuICAgIC8qXG4gICAgLy8gU3RhdGUgb3IgZGVmYXVsdCBzdGF0ZVxuICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIC8vIG1lcmdlIHBlbmRpbmcgdXBkYXRlZCBzdGF0ZVxuICAgIHRoaXMuJC5leHRlbmQoc3RhdGUsIHRoaXMuX3BlbmRpbmdTdGF0ZVVwZGF0ZSk7XG4gICAgLy8gZGlzY2FyZCB0aGUgdXBkYXRlXG4gICAgKi9cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVVcGRhdGUgPSBudWxsO1xuICAgIFxuICAgIC8vIERvZXNuJ3QgbWF0dGVycyBpZiBzdGF0ZSBpbmNsdWRlcyBhbHJlYWR5IFxuICAgIC8vICdyb3V0ZScgaW5mb3JtYXRpb24sIG5lZWQgdG8gYmUgb3ZlcndyaXR0ZW5cbiAgICAvLyB0byBtYXRjaCB0aGUgY3VycmVudCBvbmUuXG4gICAgLy8gTk9URTogcHJldmlvdXNseSwgYSBjaGVjayBwcmV2ZW50ZWQgdGhpcyBpZlxuICAgIC8vIHJvdXRlIHByb3BlcnR5IGV4aXN0cywgY3JlYXRpbmcgaW5maW5pdGUgbG9vcHNcbiAgICAvLyBvbiByZWRpcmVjdGlvbnMgZnJvbSBhY3Rpdml0eS5zaG93IHNpbmNlICdyb3V0ZScgZG9lc24ndFxuICAgIC8vIG1hdGNoIHRoZSBuZXcgZGVzaXJlZCBsb2NhdGlvblxuICAgIFxuICAgIC8vIERldGVjdCBpZiBpcyBhIGhhc2hiYW5nIFVSTCBvciBhbiBzdGFuZGFyZCBvbmUuXG4gICAgLy8gRXhjZXB0IGlmIHRoZSBhcHAgaXMgZm9yY2VkIHRvIHVzZSBoYXNoYmFuZy5cbiAgICB2YXIgaXNIYXNoQmFuZyA9IC8jIS8udGVzdChsb2NhdGlvbi5ocmVmKSB8fCB0aGlzLmZvcmNlSGFzaGJhbmc7XG4gICAgXG4gICAgdmFyIGxpbmsgPSAoXG4gICAgICAgIGlzSGFzaEJhbmcgP1xuICAgICAgICBsb2NhdGlvbi5oYXNoIDpcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICApO1xuICAgIC8vIElzIGJldHRlciB0byBkbyB0aGlzIGNoZWNrIGhlcmUsIGJlY2F1c2UgdGhlIGhhc2ggY2FuIGNvbnRhaW4gYSBxdWVyeSAoZXZlbiBpZlxuICAgIC8vIG5vdCB2YWxpZCBmb3IgVVJMIHF1ZXJ5LCBpcyB2YWxpZCBmb3IgaGFzaGJhbmcgcXVlcmllcylcbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICAgIHZhciBzZXAgPSBsaW5rLmluZGV4T2YoJz8nKSAhPT0gLTEgPyAnJicgOiAnPyc7XG4gICAgICAgIGxpbmsgKz0gc2VwICsgbG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IHRoZSByb3V0ZVxuICAgIHN0YXRlLnJvdXRlID0gdGhpcy5wYXJzZVVybChsaW5rKTtcbiAgICBcbiAgICByZXR1cm4gc3RhdGU7XG59O1xuXG5TaGVsbC5wcm90b3R5cGUuX2dldExvY2F0aW9uUm91dGVkVXJsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZyA9IC9eIyEvO1xuICAgIHJldHVybiByZWcudGVzdCh3aW5kb3cubG9jYXRpb24uaGFzaCkgPyB3aW5kb3cubG9jYXRpb24uaGFzaCA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaDtcbn07XG5cbi8qKlxuICAgIEludGVybmFsIHVzZSBvbmx5LlxuICAgIFVwZGF0ZSB0aGUgVVJML3JvdXRlIHNhdmVkIGFzIFJlZmVycmVyIHVzaW5nIHRoZSBjdXJyZW50IG9uZSBmcm9tIGxvY2F0aW9uLlxuKiovXG5TaGVsbC5wcm90b3R5cGUuX3JlZnJlc2hSZWZlcnJlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVmZXJyZXJSb3V0ZSA9IHRoaXMucGFyc2VVcmwodGhpcy5fZ2V0TG9jYXRpb25Sb3V0ZWRVcmwoKSk7XG59O1xuU2hlbGwucHJvdG90eXBlLl9yZWZyZXNoQ3VycmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3VycmVudFJvdXRlID0gdGhpcy5wYXJzZVVybCh0aGlzLl9nZXRMb2NhdGlvblJvdXRlZFVybCgpKTtcbn07XG5cbi8qKlxuICAgIFNob3J0Y3V0IHRvIGhpc3RvcnkucmVwbGFjZVN0YXRlIEFQSSB0aGF0IGtlZXBzIHNvbWUgaW50ZXJuYWwgU2hlbGwgc3RhdGUgY29ycmVjdC5cbioqL1xuU2hlbGwucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgIHRoaXMuX3JlZnJlc2hSZWZlcnJlcigpO1xuICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICAgIHRoaXMuX3JlZnJlc2hDdXJyZW50KCk7XG59O1xuXG4vKipcbiAgICBTaG9ydGN1dCB0byBoaXN0b3J5LnJlcGxhY2VTdGF0ZSBBUEkgdGhhdCBrZWVwcyBzb21lIGludGVybmFsIFNoZWxsIHN0YXRlIGNvcnJlY3QuXG4qKi9cblNoZWxsLnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgICB0aGlzLl9yZWZyZXNoUmVmZXJyZXIoKTtcbiAgICB0aGlzLmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICB0aGlzLl9yZWZyZXNoQ3VycmVudCgpO1xufTtcblxuU2hlbGwucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gICAgXG4gICAgc3RhdGUgPSB0aGlzLmdldFVwZGF0ZWRTdGF0ZShzdGF0ZSk7XG5cbiAgICAvLyBVc2UgdGhlIGluZGV4IG9uIHJvb3QgY2FsbHNcbiAgICBpZiAoc3RhdGUucm91dGUucm9vdCA9PT0gdHJ1ZSkge1xuICAgICAgICBzdGF0ZS5yb3V0ZSA9IHRoaXMucGFyc2VVcmwodGhpcy5pbmRleE5hbWUpO1xuICAgIH1cbiAgICB0aGlzLnJlZmVycmVyUm91dGUgPSB0aGlzLmN1cnJlbnRSb3V0ZTtcbiAgICB0aGlzLmN1cnJlbnRSb3V0ZSA9IHN0YXRlLnJvdXRlO1xuICAgIC8vY29uc29sZS5sb2coJ3NoZWxsIHJlcGxhY2UnLCBzdGF0ZS5yb3V0ZSk7XG5cbiAgICAvLyBBY2Nlc3MgY29udHJvbFxuICAgIHZhciBhY2Nlc3NFcnJvciA9IHRoaXMuYWNjZXNzQ29udHJvbChzdGF0ZS5yb3V0ZSk7XG4gICAgaWYgKGFjY2Vzc0Vycm9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdvKHRoaXMubm9uQWNjZXNzTmFtZSwgYWNjZXNzRXJyb3IpO1xuICAgIH1cblxuICAgIC8vIExvY2F0aW5nIHRoZSBjb250YWluZXJcbiAgICB2YXIgJGNvbnQgPSB0aGlzLml0ZW1zLmZpbmQoc3RhdGUucm91dGUubmFtZSk7XG4gICAgdmFyIHNoZWxsID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IG51bGw7XG5cbiAgICBpZiAoJGNvbnQgJiYgJGNvbnQubGVuZ3RoKSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgJG9sZENvbnQgPSBzaGVsbC5pdGVtcy5nZXRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAkb2xkQ29udCA9ICRvbGRDb250Lm5vdCgkY29udCk7XG4gICAgICAgICAgICAgICAgc2hlbGwuaXRlbXMuc3dpdGNoKCRvbGRDb250LCAkY29udCwgc2hlbGwsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzaGVsbCByZXBsYWNlIGFmdGVyIHN3aXRjaCcsIHN0YXRlLnJvdXRlKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTsgLy8/IHJlc29sdmUoYWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgICAgICAvLyBsb2FkIGFuZCBpbmplY3QgdGhlIGNvbnRlbnQgaW4gdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIHRoZW4gdHJ5IHRoZSByZXBsYWNlIGFnYWluXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy5sb2FkZXIubG9hZChzdGF0ZS5yb3V0ZSkudGhlbihmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBpdGVtcyAodGhlIG1hbmFnZXIgdGFrZXMgY2FyZSB5b3VcbiAgICAgICAgICAgICAgICAvLyBhZGQgb25seSB0aGUgaXRlbSwgaWYgdGhlcmUgaXMgb25lKVxuICAgICAgICAgICAgICAgIHNoZWxsLml0ZW1zLmluamVjdChzdGF0ZS5yb3V0ZS5uYW1lLCBodG1sKTtcbiAgICAgICAgICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCB0aGUgaXRlbSB3YXMgYWRkZWQgYW5kIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIGEgcmVxdWVzdCBub3QgcmV0dXJuaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW0gYW5kIHRoZSAncmVwbGFjZScgdHJ5aW5nIHRvIGxvYWQgaXQgYWdhaW4sIGFuZCBhZ2FpbiwgYW5kLi5cbiAgICAgICAgICAgICAgICBpZiAoc2hlbGwuaXRlbXMuZmluZChzdGF0ZS5yb3V0ZS5uYW1lKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGVsbC5yZXBsYWNlKHN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignUGFnZSBub3QgZm91bmQgKCcgKyBzdGF0ZS5yb3V0ZS5uYW1lICsgJyknKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU2hlbGwgUGFnZSBub3QgZm91bmQsIHN0YXRlOicsIHN0YXRlKTtcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBiZWluZyBpbiBhbiBpbmV4aXN0YW50IFVSTCAoZ2VuZXJhdGluZyBpbmNvbnNpc3RlbmN5IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGN1cnJlbnQgdmlldyBhbmQgVVJMLCBjcmVhdGluZyBiYWQgaGlzdG9yeSBlbnRyaWVzKSxcbiAgICAgICAgICAgIC8vIGEgZ29CYWNrIGlzIGV4ZWN1dGVkLCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IHBpcGUgZW5kc1xuICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHJlZGlyZWN0IHRoYXQgY3V0IGN1cnJlbnQgcHJvY2Vzc2luZyByYXRoZXIgdGhhbiBleGVjdXRlIGRlbGF5ZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nb0JhY2soKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIHRoaXNTaGVsbCA9IHRoaXM7XG4gICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKVxuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKGVycik7XG5cbiAgICAgICAgLy8gTG9nIGVycm9yLCBcbiAgICAgICAgY29uc29sZS5lcnJvcignU2hlbGwsIHVuZXhwZWN0ZWQgZXJyb3IuJywgZXJyKTtcbiAgICAgICAgLy8gbm90aWZ5IGFzIGFuIGV2ZW50XG4gICAgICAgIHRoaXNTaGVsbC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIC8vIGFuZCBjb250aW51ZSBwcm9wYWdhdGluZyB0aGUgZXJyb3JcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuU2hlbGwucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcblxuICAgIHZhciBzaGVsbCA9IHRoaXM7XG5cbiAgICAvLyBDYXRjaCBwb3BzdGF0ZSBldmVudCB0byB1cGRhdGUgc2hlbGwgcmVwbGFjaW5nIHRoZSBhY3RpdmUgY29udGFpbmVyLlxuICAgIC8vIEFsbG93cyBwb2x5ZmlsbHMgdG8gcHJvdmlkZSBhIGRpZmZlcmVudCBidXQgZXF1aXZhbGVudCBldmVudCBuYW1lXG4gICAgdGhpcy4kKHdpbmRvdykub24odGhpcy5oaXN0b3J5LnBvcHN0YXRlRXZlbnQgfHwgJ3BvcHN0YXRlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGF0ZSA9IGV2ZW50LnN0YXRlIHx8IFxuICAgICAgICAgICAgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5zdGF0ZSkgfHwgXG4gICAgICAgICAgICBzaGVsbC5oaXN0b3J5LnN0YXRlO1xuXG4gICAgICAgIC8vIGdldCBzdGF0ZSBmb3IgY3VycmVudC4gVG8gc3VwcG9ydCBwb2x5ZmlsbHMsIHdlIHVzZSB0aGUgZ2VuZXJhbCBnZXR0ZXJcbiAgICAgICAgLy8gaGlzdG9yeS5zdGF0ZSBhcyBmYWxsYmFjayAodGhleSBtdXN0IGJlIHRoZSBzYW1lIG9uIGJyb3dzZXJzIHN1cHBvcnRpbmcgSGlzdG9yeSBBUEkpXG4gICAgICAgIHNoZWxsLnJlcGxhY2Uoc3RhdGUpO1xuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogUmV2aWV3IGlmIGFsbCB0aGlzIG5leHQgc3RpbGwgaXMgdXNhYmxlIGFuZCBoYXMgdXNlIGNhc2VzLCBzaW5jZSB0aGUgcHJvamVjdFxuICAgIC8vIG5vdyB1c2VzIGZhc3RjbGljayBsaWJyYXJ5IHRvIGF2b2lkIHRoZSBpT1MgZGVsYXksIHVzaW5nIGFnYWluIGNsaWNrIGFnYWluc3QgdGFwIGV2ZW50LlxuICAgIC8vXG4gICAgLy8gQ2F0Y2ggYWxsIGxpbmtzIGluIHRoZSBwYWdlIChub3Qgb25seSAkcm9vdCBvbmVzKSBhbmQgbGlrZS1saW5rcy5cbiAgICAvLyBJTVBPUlRBTlQ6IHRoZSB0aW1lb3V0IGFuZCBsaW5rV29ya2luZyBpcyBhIGtpbmQgb2YgaGFjay93b3JrYXJvdW5kIGJlY2F1c2Ugb2Y6XG4gICAgLy8gLSBpT1MgY2xpY2sgZGVsYXk6IGNoYW5naW5nIGxpbmtFdmVudCB0byBiZSAndGFwIGNsaWNrJyAoanFtIHRhcCBldmVudCkgb3IgXG4gICAgLy8gICBtb3JlIHN0YW5kYXJkIGJ1dCBzaW1wbGlzdGljICd0b3VjaGVuZCBjbGljaycsIG9ubHkgb24gaU9TIGlmIHBvc3NpYmxlLCB0aGVcbiAgICAvLyAgIGlPUyBjbGljayBkZWxheSBjYW4gYmUgYXZvaWRlZCwgbGV0dGluZyB0aGUgdG91Y2ggZXZlbnQgdG8gdHJpZ2dlciB0aGlzIFNoZWxsIGhhbmRsZXJcbiAgICAvLyAgIGFuZCBwcmV2ZW50aW5nIHRoZSBjbGljayBmcm9tIGhhcHBlbmluZyB0byBhdm9pZCBkb3VibGUgZXhlY3V0aW9uXG4gICAgLy8gICAodGhhbmtzIHRvIGxpbmtXb3JraW5nIGFuZCBzZXRUaW1lb3V0KS5cbiAgICAvLyAgIEEgYnJva2VuIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIHVzZSBvbmx5IG9uZSBldmVudCwgbGlrZSAndGFwJyBvciAndG91Y2hlbmQnLCBidXRcbiAgICAvLyAgIHRoZXkgZmFsbCBkb3duIHdoZW4gYSB0b3VjaCBnZXN0dXJlIGhhcHBlbnMgaW4gdGhlIGxpbWl0IG9mIGEgbGluay9lbGVtZW50IGJlY2F1c2VcbiAgICAvLyAgIGEgdG91Y2hzdGFydCBoYXBwZW5zIG91dCBvZiBvdXIgdGFyZ2V0IGxpbmsgLWZhaWxpbmcgdG91Y2hlbmQgYW5kIHRhcCBzaW5jZSBkb24ndCBcbiAgICAvLyAgIGdldCB0cmlnZ2VyZWQgaW4gb3VyIGxpbmstIGJ1dCB0aGUgYnJvd3Nlci93ZWJ2aWV3IHN0aWxsIGV4ZWN1dGVzIChhbmQgaW5tZWRpYXRseSlcbiAgICAvLyAgIHRoZSAnY2xpY2snIGV2ZW50IG9uIHRoZSBsaW5rLiBJdCBzZWVtcyBhbiBlZGdlIGNhc2UgYnV0IGlzIGVhc2llciB0byBtYWtlIGl0IGhhcHBlbnNcbiAgICAvLyAgIHRoYW4gaXQgc2VlbXMuIEl0J3MgdGhlIGJ1ZyB0aGF0IGZvcmNlZCB0byBpbXBsZW1lbnQgdGhpcyB3b3JrYW91cm5kIDotL1xuICAgIC8vIC0gQW5kIGFkZGl0aW9uYWxseTogaXQgcHJldmVudHMgdHdvICdjbGlja3MnIGZyb20gaGFwcGVuaW5nIGV4Y2Vzc2l2ZSBmYXN0IGJlY2F1c2VcbiAgICAvLyAgIHNvbWUga2luZCBvZiBhIHNlY29uZCB1bndhbnRlZCB0b3VjaCBoYXBwZW5pbmcgdmVyeSBmYXN0LCBtYWtpbmdcbiAgICAvLyAgIGEgY2xpY2sgYnkgbWlzdGFrZSBvbiBhIGRpZmZlcmVudCBsaW5rIG9uIHRoZSBsb2FkZWQgbmV3IHBhZ2UuXG4gICAgdmFyIGxpbmtXb3JraW5nID0gbnVsbCxcbiAgICAgICAgLy8gT0xEOiBpT1MgMzAwbXMgZGVsYXksIGEgYml0IGluY3JlYXNlZCB0byBhdm9pZCBwcm9ibGVtcy5cbiAgICAgICAgLy8gTk9URTogYXMgb2YgaW5jbHVzaW9uIG9mIGZhc3RjbGljayBpbiB0aGUgbWFpbiBwcm9qZWN0LCByZWR1Y2VkXG4gICAgICAgIC8vIHRoaXMgZGVsYXkgdG8gYXZvaWQgYmVpbmcgbm90aWNlYWJsZSBvbiBzb21lIGVkZ2UgY2FzZXMsIGJ1dCBzdGlsbFxuICAgICAgICAvLyBwcmVzZXJ2aW5nIGJlY2F1c2Ugb3RoZXIgbm90IHZlcmlmaWVkIHVzZSBjYXNlcyAobGlrZSBvbiBhIHRvdWNoIG9uIGEgbGluayB0aGF0IGR5bmFtaWNhbGx5XG4gICAgICAgIC8vIGNoYW5nZXMgYmVpbmcgcGVyY2VpdmVkIGFzIHR3byBxdWljayBjb25zZWN1dGl2ZSBjbGlja3MsIGV4ZWN1dGluZyB0d28gYWN0aW9ucyBpbiBvbmUgYW5kIHRoYXQgYmVpbmcgdW53YW50ZWQpXG4gICAgICAgIGxpbmtXb3JraW5nRGVsYXkgPSA4MDsgLy8gMzQwOyAvLyBtc1xuICAgIC8vREVCVUcgdmFyIGxpbmtFdmVudCA9IHRoaXMubGlua0V2ZW50O1xuICAgIHRoaXMuJChkb2N1bWVudCkub24odGhpcy5saW5rRXZlbnQsICdbaHJlZl0sIFtkYXRhLWhyZWZdJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKCdTaGVsbCBvbiBldmVudCcsIGUudHlwZSwgbGlua1dvcmtpbmcpO1xuICAgICAgICAvLyBJZiB3b3JraW5nLCBhdm9pZCBldmVyeXRoaW5nOlxuICAgICAgICBpZiAobGlua1dvcmtpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGlua1dvcmtpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGlua1dvcmtpbmcgPSBudWxsO1xuICAgICAgICB9LCBsaW5rV29ya2luZ0RlbGF5KTtcblxuICAgICAgICB2YXIgJHQgPSBzaGVsbC4kKHRoaXMpLFxuICAgICAgICAgICAgaHJlZiA9ICR0LmF0dHIoJ2hyZWYnKSB8fCAkdC5kYXRhKCdocmVmJyk7XG4gICAgICAgIFxuICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKCdTaGVsbCBvbicsIGxpbmtFdmVudCwgZS50eXBlLCAnaHJlZicsIGhyZWYsICdlbGVtZW50JywgJHQpO1xuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIFVSTCBjb250YWlucyB0aGUgcHJvdG9jb2xcbiAgICAgICAgaWYgKC9eW2Etel0rOi9pLnRlc3QoaHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGVsbC5mb3JjZUhhc2hiYW5nICYmIC9eIyhbXiFdfCQpLy50ZXN0KGhyZWYpKSB7XG4gICAgICAgICAgICAvLyBTdGFuZGFyZCBoYXNoLCBidXQgbm90IGhhc2hiYW5nOiBhdm9pZCByb3V0aW5nIGFuZCBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHNwZWNpYWwgZXZlbnQgb24gdGhlIHNoZWxsLCBzbyBleHRlcm5hbCBzY3JpcHRzIGNhbiBkb1xuICAgICAgICAgICAgLy8gc29tZXRoaW5nLCBsaWtlIHRyeWluZyB0byBpbXBsZW1lbnQgc3RhbmRhcmQgc2Nyb2xsIGJlaGF2aW9yIG9yIGFueVxuICAgICAgICAgICAgLy8gUGFzcyBpbjogc291cmNlIGZyYWdtZW50IGxpbmssIGVsZW1lbnQgdGhhdCByZWNlaXZlIHRoZSBvcmlnaW5hbCBldmVudCBhbmRcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgICAgICAgIHNoZWxsLmVtaXQoJ2ZyYWdtZW50TmF2aWdhdGlvbicsIGhyZWYsIHRoaXMsIGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGVkIGRlbGF5ZWQgdG8gYXZvaWQgaGFuZGxlciBjb2xsaXNpb25zLCBiZWNhdXNlXG4gICAgICAgIC8vIG9mIHRoZSBuZXcgcGFnZSBtb2RpZnlpbmcgdGhlIGVsZW1lbnQgYW5kIG90aGVyIGhhbmRsZXJzXG4gICAgICAgIC8vIHJlYWRpbmcgaXQgYXR0cmlidXRlcyBhbmQgYXBwbHlpbmcgbG9naWMgb24gdGhlIHVwZGF0ZWQgbGlua1xuICAgICAgICAvLyBhcyBpZiB3YXMgdGhlIG9sZCBvbmUgKGV4YW1wbGU6IHNoYXJlZCBsaW5rcywgbGlrZSBpbiBhXG4gICAgICAgIC8vIGdsb2JhbCBuYXZiYXIsIHRoYXQgbW9kaWZpZXMgd2l0aCB0aGUgbmV3IHBhZ2UpLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2hlbGwuZ28oaHJlZik7XG4gICAgICAgIH0sIDEpO1xuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGxpemUgc3RhdGVcbiAgICB0aGlzLml0ZW1zLmluaXQoKTtcbiAgICAvLyBSb3V0ZSB0byB0aGUgY3VycmVudCB1cmwvc3RhdGVcbiAgICB0aGlzLnJlcGxhY2UoKTtcbn07XG4iLCIvKipcbiAgICBhYnNvbHV0aXplVXJsIHV0aWxpdHkgXG4gICAgdGhhdCBlbnN1cmVzIHRoZSB1cmwgcHJvdmlkZWRcbiAgICBiZWluZyBpbiB0aGUgcGF0aCBvZiB0aGUgZ2l2ZW4gYmFzZVVybFxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzYW5pdGl6ZVVybCA9IHJlcXVpcmUoJy4vc2FuaXRpemVVcmwnKSxcbiAgICBlc2NhcGVSZWdFeHAgPSByZXF1aXJlKCcuLi9lc2NhcGVSZWdFeHAnKTtcblxuZnVuY3Rpb24gYWJzb2x1dGl6ZVVybChiYXNlVXJsLCB1cmwpIHtcblxuICAgIC8vIHNhbml0aXplIGJlZm9yZSBjaGVja1xuICAgIHVybCA9IHNhbml0aXplVXJsKHVybCk7XG5cbiAgICAvLyBDaGVjayBpZiB1c2UgdGhlIGJhc2UgYWxyZWFkeVxuICAgIHZhciBtYXRjaEJhc2UgPSBuZXcgUmVnRXhwKCdeJyArIGVzY2FwZVJlZ0V4cChiYXNlVXJsKSwgJ2knKTtcbiAgICBpZiAobWF0Y2hCYXNlLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIGFuZCBzYW5pdGl6ZVxuICAgIHJldHVybiBzYW5pdGl6ZVVybChiYXNlVXJsICsgdXJsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhYnNvbHV0aXplVXJsO1xuIiwiLyoqXG4gICAgRXh0ZXJuYWwgZGVwZW5kZW5jaWVzIGZvciBTaGVsbCBpbiBhIHNlcGFyYXRlIG1vZHVsZVxuICAgIHRvIHVzZSBhcyBESSwgbmVlZHMgc2V0dXAgYmVmb3JlIGNhbGwgdGhlIFNoZWxsLmpzXG4gICAgbW9kdWxlIGNsYXNzXG4qKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VVcmw6IG51bGwsXG4gICAgYWJzb2x1dGl6ZVVybDogbnVsbCxcbiAgICBqcXVlcnk6IG51bGwsXG4gICAgbG9hZGVyOiBudWxsLFxuICAgIGFjY2Vzc0NvbnRyb2w6IGZ1bmN0aW9uIGFsbG93QWxsKC8qbmFtZSovKSB7XG4gICAgICAgIC8vIGFsbG93IGFjY2VzcyBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgRXZlbnRFbWl0dGVyOiBudWxsXG59O1xuIiwiLyoqXG4gICAgU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBIaXN0b3J5IEFQSSB1c2luZyBvbmx5IGhhc2hiYW5ncyBVUkxzLFxuICAgIGRvZXNuJ3QgbWF0dGVycyB0aGUgYnJvd3NlciBzdXBwb3J0LlxuICAgIFVzZWQgdG8gYXZvaWQgZnJvbSBzZXR0aW5nIFVSTHMgdGhhdCBoYXMgbm90IGFuIGVuZC1wb2ludCxcbiAgICBsaWtlIGluIGxvY2FsIGVudmlyb25tZW50cyB3aXRob3V0IGEgc2VydmVyIGRvaW5nIHVybC1yZXdyaXRpbmcsXG4gICAgaW4gcGhvbmVnYXAgYXBwcywgb3IgdG8gY29tcGxldGVseSBieS1wYXNzIGJyb3dzZXIgc3VwcG9ydCBiZWNhdXNlXG4gICAgaXMgYnVnZ3kgKGxpa2UgQW5kcm9pZCA8PSA0LjEpLlxuICAgIFxuICAgIE5PVEVTOlxuICAgIC0gQnJvd3NlciBtdXN0IHN1cHBvcnQgJ2hhc2hjaGFuZ2UnIGV2ZW50LlxuICAgIC0gQnJvd3NlciBtdXN0IGhhcyBzdXBwb3J0IGZvciBzdGFuZGFyZCBKU09OIGNsYXNzLlxuICAgIC0gUmVsaWVzIG9uIHNlc3Npb25zdG9yYWdlIGZvciBwZXJzaXN0YW5jZSwgc3VwcG9ydGVkIGJ5IGFsbCBicm93c2VycyBhbmQgd2Vidmlld3MgXG4gICAgICBmb3IgYSBlbm91Z2ggbG9uZyB0aW1lIG5vdy5cbiAgICAtIFNpbWlsYXIgYXBwcm9hY2ggYXMgSGlzdG9yeS5qcyBwb2x5ZmlsbCwgYnV0IHNpbXBsaWZpZWQsIGFwcGVuZGluZyBhIGZha2UgcXVlcnlcbiAgICAgIHBhcmFtZXRlciAnX3N1aWQ9MCcgdG8gdGhlIGhhc2ggdmFsdWUgKGFjdHVhbCBxdWVyeSBnb2VzIGJlZm9yZSB0aGUgaGFzaCwgYnV0XG4gICAgICB3ZSBuZWVkIGl0IGluc2lkZSkuXG4gICAgLSBGb3Igc2ltcGxpZmljYXRpb24sIG9ubHkgdGhlIHN0YXRlIGlzIHBlcnNpc3RlZCwgdGhlICd0aXRsZScgcGFyYW1ldGVyIGlzIG5vdFxuICAgICAgdXNlZCBhdCBhbGwgKHRoZSBzYW1lIGFzIG1ham9yIGJyb3dzZXJzIGRvLCBzbyBpcyBub3QgYSBwcm9ibGVtKTsgaW4gdGhpcyBsaW5lLFxuICAgICAgb25seSBoaXN0b3J5IGVudHJpZXMgd2l0aCBzdGF0ZSBhcmUgcGVyc2lzdGVkLlxuICAgICAgXG4gICAgVE9ETyByZXBsYWNlU3RhdGUgZG9lcyBub3Qgd29yayBhcyBleHBlY3RlZCwgaXQgY3JlYXRlcyBhIGhpc3RvcnkgZW50cnkgcmF0aGVyIHRoYW4gcmVwbGFjZSBpdFxuICAgICAgICBBIHNvbHV0aW9uIGlkZWEgaXMgdG8gcGVyZm9ybSBhIGJyb3dzZXIgZ28oLTEpIGFuZCB0aGUgdGhlbiBoYXNoIGNoYW5nZSAocHVzaCksIGJ1dCB0aGUgZ28gYmFja1xuICAgICAgICBtdXN0IGJ5cGFzcyB0aGUgZXZlbnRzIG5vdGlmaWNhdGlvbi5cbioqL1xuLy9nbG9iYWwgbG9jYXRpb25cbid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXG4gICAgc2FuaXRpemVVcmwgPSByZXF1aXJlKCcuL3Nhbml0aXplVXJsJyksXG4gICAgZ2V0VXJsUXVlcnkgPSByZXF1aXJlKCcuLi9nZXRVcmxRdWVyeScpO1xuXG4vLyBJbml0OiBMb2FkIHNhdmVkIGNvcHkgZnJvbSBzZXNzaW9uU3RvcmFnZVxudmFyIHNlc3Npb24gPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdoYXNoYmFuZ0hpc3Rvcnkuc3RvcmUnKTtcbi8vIE9yIGNyZWF0ZSBhIG5ldyBvbmVcbmlmICghc2Vzc2lvbikge1xuICAgIHNlc3Npb24gPSB7XG4gICAgICAgIC8vIFN0YXRlcyBhcnJheSB3aGVyZSBlYWNoIGluZGV4IGlzIHRoZSBTVUlEIGNvZGUgYW5kIHRoZVxuICAgICAgICAvLyB2YWx1ZSBpcyBqdXN0IHRoZSB2YWx1ZSBwYXNzZWQgYXMgc3RhdGUgb24gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZVxuICAgICAgICBzdGF0ZXM6IFtdXG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIHNlc3Npb24gPSBKU09OLnBhcnNlKHNlc3Npb24pO1xufVxuXG5cbi8qKlxuICAgIEdldCB0aGUgU1VJRCBudW1iZXJcbiAgICBmcm9tIGEgaGFzaCBzdHJpbmdcbioqL1xuZnVuY3Rpb24gZ2V0U3VpZChoYXNoKSB7XG4gICAgXG4gICAgdmFyIHN1aWQgPSArZ2V0VXJsUXVlcnkoaGFzaCkuX3N1aWQ7XG4gICAgaWYgKGlzTmFOKHN1aWQpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBzdWlkO1xufVxuXG5mdW5jdGlvbiBzZXRTdWlkKGhhc2gsIHN1aWQpIHtcbiAgICBcbiAgICAvLyBXZSBuZWVkIHRoZSBxdWVyeSwgc2luY2Ugd2UgbmVlZCBcbiAgICAvLyB0byByZXBsYWNlIHRoZSBfc3VpZCAobWF5IGV4aXN0KVxuICAgIC8vIGFuZCByZWNyZWF0ZSB0aGUgcXVlcnkgaW4gdGhlXG4gICAgLy8gcmV0dXJuZWQgaGFzaC11cmxcbiAgICB2YXIgcXMgPSBnZXRVcmxRdWVyeShoYXNoKTtcbiAgICBxcy5wdXNoKCdfc3VpZCcpO1xuICAgIHFzLl9zdWlkID0gc3VpZDtcblxuICAgIHZhciBxdWVyeSA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBxdWVyeS5wdXNoKHFzW2ldICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHFzW3FzW2ldXSkpO1xuICAgIH1cbiAgICBxdWVyeSA9IHF1ZXJ5LmpvaW4oJyYnKTtcbiAgICBcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaGFzaC5pbmRleE9mKCc/Jyk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgaGFzaCArPSAnPycgKyBxdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbn1cblxuLyoqXG4gICAgQXNrIHRvIHBlcnNpc3QgdGhlIHNlc3Npb24gZGF0YS5cbiAgICBJdCBpcyBkb25lIHdpdGggYSB0aW1lb3V0IGluIG9yZGVyIHRvIGF2b2lkXG4gICAgZGVsYXkgaW4gdGhlIGN1cnJlbnQgdGFzayBtYWlubHkgYW55IGhhbmRsZXJcbiAgICB0aGF0IGFjdHMgYWZ0ZXIgYSBIaXN0b3J5IGNoYW5nZS5cbioqL1xuZnVuY3Rpb24gcGVyc2lzdCgpIHtcbiAgICAvLyBFbm91Z2ggdGltZSB0byBhbGxvdyByb3V0aW5nIHRhc2tzLFxuICAgIC8vIG1vc3QgYW5pbWF0aW9ucyBmcm9tIGZpbmlzaCBhbmQgdGhlIFVJXG4gICAgLy8gYmVpbmcgcmVzcG9uc2l2ZS5cbiAgICAvLyBCZWNhdXNlIHNlc3Npb25TdG9yYWdlIGlzIHN5bmNocm9ub3VzLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2hhc2hiYW5nSGlzdG9yeS5zdG9yZScsIEpTT04uc3RyaW5naWZ5KHNlc3Npb24pKTtcbiAgICB9LCAxNTAwKTtcbn1cblxuLyoqXG4gICAgUmV0dXJucyB0aGUgZ2l2ZW4gc3RhdGUgb3IgbnVsbFxuICAgIGlmIGlzIGFuIGVtcHR5IG9iamVjdC5cbioqL1xuZnVuY3Rpb24gY2hlY2tTdGF0ZShzdGF0ZSkge1xuICAgIFxuICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAvLyBpcyBlbXB0eT9cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBOb1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0cyBlbXB0eVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQW55dGhpbmcgZWxzZVxuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gICAgR2V0IGEgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uXG4gICAgb2YgdGhlIFVSTCBzbyBjYW4gYmUgY29tcGFyZWRcbiAgICB3aXRoIHN1Y2Nlc3MuXG4qKi9cbmZ1bmN0aW9uIGNhbm5vbmljYWxVcmwodXJsKSB7XG4gICAgXG4gICAgLy8gQXZvaWQgc29tZSBiYWQgb3IgcHJvYmxlbWF0aWMgc3ludGF4XG4gICAgdXJsID0gc2FuaXRpemVVcmwodXJsIHx8ICcnKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGhhc2ggcGFydFxuICAgIHZhciBpaGFzaCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGloYXNoID4gLTEpIHtcbiAgICAgICAgdXJsID0gdXJsLnN1YnN0cihpaGFzaCArIDEpO1xuICAgIH1cbiAgICAvLyBNYXliZSBhIGhhc2hiYW5nIFVSTCwgcmVtb3ZlIHRoZVxuICAgIC8vICdiYW5nJyAodGhlIGhhc2ggd2FzIHJlbW92ZWQgYWxyZWFkeSlcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXiEvLCAnJyk7XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAgICBUcmFja3MgdGhlIGxhdGVzdCBVUkxcbiAgICBiZWluZyBwdXNoZWQgb3IgcmVwbGFjZWQgYnlcbiAgICB0aGUgQVBJLlxuICAgIFRoaXMgYWxsb3dzIGxhdGVyIHRvIGF2b2lkXG4gICAgdHJpZ2dlciB0aGUgcG9wc3RhdGUgZXZlbnQsXG4gICAgc2luY2UgbXVzdCBOT1QgYmUgdHJpZ2dlcmVkXG4gICAgYXMgYSByZXN1bHQgb2YgdGhhdCBBUEkgbWV0aG9kc1xuKiovXG52YXIgbGF0ZXN0UHVzaGVkUmVwbGFjZWRVcmwgPSBudWxsO1xuXG4vKipcbiAgICBIaXN0b3J5IFBvbHlmaWxsXG4qKi9cbnZhciBoYXNoYmFuZ0hpc3RvcnkgPSB7XG4gICAgcHVzaFN0YXRlOiBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpIHtcblxuICAgICAgICAvLyBjbGVhbnVwIHVybFxuICAgICAgICB1cmwgPSBjYW5ub25pY2FsVXJsKHVybCk7XG4gICAgICAgIFxuICAgICAgICAvLyBzYXZlIG5ldyBzdGF0ZSBmb3IgdXJsXG4gICAgICAgIHN0YXRlID0gY2hlY2tTdGF0ZShzdGF0ZSkgfHwgbnVsbDtcbiAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBzYXZlIHN0YXRlXG4gICAgICAgICAgICBzZXNzaW9uLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBzdWlkID0gc2Vzc2lvbi5zdGF0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBVUkwgd2l0aCB0aGUgc3VpZFxuICAgICAgICAgICAgdXJsID0gc2V0U3VpZCh1cmwsIHN1aWQpO1xuICAgICAgICAgICAgLy8gY2FsbCB0byBwZXJzaXN0IHRoZSB1cGRhdGVkIHNlc3Npb25cbiAgICAgICAgICAgIHBlcnNpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGF0ZXN0UHVzaGVkUmVwbGFjZWRVcmwgPSB1cmw7XG4gICAgICAgIFxuICAgICAgICAvLyB1cGRhdGUgbG9jYXRpb24gdG8gdHJhY2sgaGlzdG9yeTpcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjIScgKyB1cmw7XG4gICAgfSxcbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgICBcbiAgICAgICAgLy8gY2xlYW51cCB1cmxcbiAgICAgICAgdXJsID0gY2Fubm9uaWNhbFVybCh1cmwpO1xuICAgICAgICBcbiAgICAgICAgLy8gaXQgaGFzIHNhdmVkIHN0YXRlP1xuICAgICAgICB2YXIgc3VpZCA9IGdldFN1aWQodXJsKSxcbiAgICAgICAgICAgIGhhc09sZFN0YXRlID0gc3VpZCAhPT0gbnVsbDtcblxuICAgICAgICAvLyBzYXZlIG5ldyBzdGF0ZSBmb3IgdXJsXG4gICAgICAgIHN0YXRlID0gY2hlY2tTdGF0ZShzdGF0ZSkgfHwgbnVsbDtcbiAgICAgICAgLy8gaXRzIHNhdmVkIGlmIHRoZXJlIGlzIHNvbWV0aGluZyB0byBzYXZlXG4gICAgICAgIC8vIG9yIHNvbWV0aGluZyB0byBkZXN0cm95XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCB8fCBoYXNPbGRTdGF0ZSkge1xuICAgICAgICAgICAgLy8gc2F2ZSBzdGF0ZVxuICAgICAgICAgICAgaWYgKGhhc09sZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBleGlzdGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgIHNlc3Npb24uc3RhdGVzW3N1aWRdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHVybCByZW1haW5zIHRoZSBzYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgc3RhdGVcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBzdWlkID0gc2Vzc2lvbi5zdGF0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgVVJMIHdpdGggdGhlIHN1aWRcbiAgICAgICAgICAgICAgICB1cmwgPSBzZXRTdWlkKHVybCwgc3VpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsIHRvIHBlcnNpc3QgdGhlIHVwZGF0ZWQgc2Vzc2lvblxuICAgICAgICAgICAgcGVyc2lzdCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsYXRlc3RQdXNoZWRSZXBsYWNlZFVybCA9IHVybDtcblxuICAgICAgICAvLyB1cGRhdGUgbG9jYXRpb24gdG8gdHJhY2sgaGlzdG9yeTpcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjIScgKyB1cmw7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3VpZCA9IGdldFN1aWQobG9jYXRpb24uaGFzaCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzdWlkICE9PSBudWxsID9cbiAgICAgICAgICAgIHNlc3Npb24uc3RhdGVzW3N1aWRdIDpcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5sZW5ndGg7XG4gICAgfSxcbiAgICBnbzogZnVuY3Rpb24gZ28ob2Zmc2V0KSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmdvKG9mZnNldCk7XG4gICAgfSxcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfSxcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxufTtcblxuLy8gQXR0YWNoIGhhc2hjYW5nZSBldmVudCB0byB0cmlnZ2VyIEhpc3RvcnkgQVBJIGV2ZW50ICdwb3BzdGF0ZSdcbnZhciAkdyA9ICQod2luZG93KTtcbiR3Lm9uKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgIFxuICAgIHZhciB1cmwgPSBlLm9yaWdpbmFsRXZlbnQubmV3VVJMO1xuICAgIHVybCA9IGNhbm5vbmljYWxVcmwodXJsKTtcbiAgICBcbiAgICAvLyBBbiBVUkwgYmVpbmcgcHVzaGVkIG9yIHJlcGxhY2VkXG4gICAgLy8gbXVzdCBOT1QgdHJpZ2dlciBwb3BzdGF0ZVxuICAgIGlmICh1cmwgPT09IGxhdGVzdFB1c2hlZFJlcGxhY2VkVXJsKVxuICAgICAgICByZXR1cm47XG4gICAgXG4gICAgLy8gZ2V0IHN0YXRlIGZyb20gaGlzdG9yeSBlbnRyeVxuICAgIC8vIGZvciB0aGUgdXBkYXRlZCBVUkwsIGlmIGFueVxuICAgIC8vIChjYW4gaGF2ZSB2YWx1ZSB3aGVuIHRyYXZlcnNpbmdcbiAgICAvLyBoaXN0b3J5KS5cbiAgICB2YXIgc3VpZCA9IGdldFN1aWQodXJsKSxcbiAgICAgICAgc3RhdGUgPSBudWxsO1xuICAgIFxuICAgIGlmIChzdWlkICE9PSBudWxsKVxuICAgICAgICBzdGF0ZSA9IHNlc3Npb24uc3RhdGVzW3N1aWRdO1xuXG4gICAgJHcudHJpZ2dlcihuZXcgJC5FdmVudCgncG9wc3RhdGUnLCB7XG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgIH0pLCAnaGFzaGJhbmdIaXN0b3J5Jyk7XG59KTtcblxuLy8gRm9yIEhpc3RvcnlBUEkgY2FwYWJsZSBicm93c2Vycywgd2UgbmVlZFxuLy8gdG8gY2FwdHVyZSB0aGUgbmF0aXZlICdwb3BzdGF0ZScgZXZlbnQgdGhhdFxuLy8gZ2V0cyB0cmlnZ2VyZWQgb24gb3VyIHB1c2gvcmVwbGFjZVN0YXRlIGJlY2F1c2Vcbi8vIG9mIHRoZSBsb2NhdGlvbiBjaGFuZ2UsIGJ1dCB0b28gb24gdHJhdmVyc2luZ1xuLy8gdGhlIGhpc3RvcnkgKGJhY2svZm9yd2FyZCkuXG4vLyBXZSB3aWxsIGxvY2sgdGhlIGV2ZW50IGV4Y2VwdCB3aGVuIGlzXG4vLyB0aGUgb25lIHdlIHRyaWdnZXIuXG4vL1xuLy8gTk9URTogdG8gdGhpcyB0cmljayB0byB3b3JrLCB0aGlzIG11c3Rcbi8vIGJlIHRoZSBmaXJzdCBoYW5kbGVyIGF0dGFjaGVkIGZvciB0aGlzXG4vLyBldmVudCwgc28gY2FuIGJsb2NrIGFsbCBvdGhlcnMuXG4vLyBBTFRFUk5BVElWRTogaW5zdGVhZCBvZiB0aGlzLCBvbiB0aGVcbi8vIHB1c2gvcmVwbGFjZVN0YXRlIG1ldGhvZHMgZGV0ZWN0IGlmXG4vLyBIaXN0b3J5QVBJIGlzIG5hdGl2ZSBzdXBwb3J0ZWQgYW5kXG4vLyB1c2UgcmVwbGFjZVN0YXRlIHRoZXJlIHJhdGhlciB0aGFuXG4vLyBhIGhhc2ggY2hhbmdlLlxuJHcub24oJ3BvcHN0YXRlJywgZnVuY3Rpb24oZSwgc291cmNlKSB7XG4gICAgXG4gICAgLy8gRW5zdXJpbmcgaXMgdGhlIG9uZSB3ZSB0cmlnZ2VyXG4gICAgaWYgKHNvdXJjZSA9PT0gJ2hhc2hiYW5nSGlzdG9yeScpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICAvLyBJbiBvdGhlciBjYXNlLCBibG9jazpcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn0pO1xuXG4vLyBFeHBvc2UgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hiYW5nSGlzdG9yeTtcbiIsIi8qKlxuICAgIERlZmF1bHQgYnVpbGQgb2YgdGhlIFNoZWxsIGNvbXBvbmVudC5cbiAgICBJdCByZXR1cm5zIHRoZSBTaGVsbCBjbGFzcyBhcyBhIG1vZHVsZSBwcm9wZXJ0eSxcbiAgICBzZXR0aW5nIHVwIHRoZSBidWlsdC1pbiBtb2R1bGVzIGFzIGl0cyBkZXBlbmRlbmNpZXMsXG4gICAgYW5kIHRoZSBleHRlcm5hbCAnanF1ZXJ5JyBhbmQgJ2V2ZW50cycgKGZvciB0aGUgRXZlbnRFbWl0dGVyKS5cbiAgICBJdCByZXR1cm5zIHRvbyB0aGUgYnVpbHQtaXQgRG9tSXRlbXNNYW5hZ2VyIGNsYXNzIGFzIGEgcHJvcGVydHkgZm9yIGNvbnZlbmllbmNlLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZXBzID0gcmVxdWlyZSgnLi9kZXBlbmRlbmNpZXMnKSxcbiAgICBEb21JdGVtc01hbmFnZXIgPSByZXF1aXJlKCcuL0RvbUl0ZW1zTWFuYWdlcicpLFxuICAgIHBhcnNlVXJsID0gcmVxdWlyZSgnLi9wYXJzZVVybCcpLFxuICAgIGFic29sdXRpemVVcmwgPSByZXF1aXJlKCcuL2Fic29sdXRpemVVcmwnKSxcbiAgICAkID0gcmVxdWlyZSgnanF1ZXJ5JyksXG4gICAgbG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKSxcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbiQuZXh0ZW5kKGRlcHMsIHtcbiAgICBwYXJzZVVybDogcGFyc2VVcmwsXG4gICAgYWJzb2x1dGl6ZVVybDogYWJzb2x1dGl6ZVVybCxcbiAgICBqcXVlcnk6ICQsXG4gICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgRXZlbnRFbWl0dGVyOiBFdmVudEVtaXR0ZXJcbn0pO1xuXG4vLyBEZXBlbmRlbmNpZXMgYXJlIHJlYWR5LCB3ZSBjYW4gbG9hZCB0aGUgY2xhc3M6XG52YXIgU2hlbGwgPSByZXF1aXJlKCcuL1NoZWxsJyk7XG5cbmV4cG9ydHMuU2hlbGwgPSBTaGVsbDtcbmV4cG9ydHMuRG9tSXRlbXNNYW5hZ2VyID0gRG9tSXRlbXNNYW5hZ2VyO1xuIiwiLyoqXG4gICAgTG9hZGVyIHV0aWxpdHkgdG8gbG9hZCBTaGVsbCBpdGVtcyBvbiBkZW1hbmQgd2l0aCBBSkFYXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXG4gICAgYmFzZVVybDogJy8nLFxuICAgIFxuICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NoZWxsIGxvYWRpbmcgb24gZGVtYW5kJywgcm91dGUubmFtZSwgcm91dGUpO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IG1vZHVsZS5leHBvcnRzLmJhc2VVcmwgKyByb3V0ZS5uYW1lICsgJy5odG1sJyxcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2VcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgbG9hZGluZyB0aGUgcHJvZ3JhbSBhbmQgbm8gbG9hZGVyIHNjcmVlbiBpbiBwbGFjZSxcbiAgICAgICAgICAgICAgICAvLyBzbyBhbnkgaW4gYmV0d2VlbiBpbnRlcmFjdGlvbiB3aWxsIGJlIHByb2JsZW1hdGljLlxuICAgICAgICAgICAgICAgIC8vYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICB9KS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIvKipcbiAgICBwYXJzZVVybCBmdW5jdGlvbiBkZXRlY3RpbmdcbiAgICB0aGUgbWFpbiBwYXJ0cyBvZiB0aGUgVVJMIGluIGFcbiAgICBjb252ZW5pZW5jZSB3YXkgZm9yIHJvdXRpbmcuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldFVybFF1ZXJ5ID0gcmVxdWlyZSgnLi4vZ2V0VXJsUXVlcnknKSxcbiAgICBlc2NhcGVSZWdFeHAgPSByZXF1aXJlKCcuLi9lc2NhcGVSZWdFeHAnKTtcblxuZnVuY3Rpb24gcGFyc2VVcmwoYmFzZVVybCwgbGluaykge1xuXG4gICAgbGluayA9IGxpbmsgfHwgJyc7XG5cbiAgICB2YXIgcmF3VXJsID0gbGluaztcblxuICAgIC8vIGhhc2hiYW5nIHN1cHBvcnQ6IHJlbW92ZSB0aGUgIyEgb3Igc2luZ2xlICMgYW5kIHVzZSB0aGUgcmVzdCBhcyB0aGUgbGlua1xuICAgIGxpbmsgPSBsaW5rLnJlcGxhY2UoL14jIS8sICcnKS5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICBcbiAgICAvLyByZW1vdmUgb3B0aW9uYWwgaW5pdGlhbCBzbGFzaCBvciBkb3Qtc2xhc2hcbiAgICBsaW5rID0gbGluay5yZXBsYWNlKC9eXFwvfF5cXC5cXC8vLCAnJyk7XG5cbiAgICAvLyBVUkwgUXVlcnkgYXMgYW4gb2JqZWN0LCBlbXB0eSBvYmplY3QgaWYgbm8gcXVlcnlcbiAgICB2YXIgcXVlcnkgPSBnZXRVcmxRdWVyeShsaW5rIHx8ICc/Jyk7XG5cbiAgICAvLyByZW1vdmUgcXVlcnkgZnJvbSB0aGUgcmVzdCBvZiBVUkwgdG8gcGFyc2VcbiAgICBsaW5rID0gbGluay5yZXBsYWNlKC9cXD8uKiQvLCAnJyk7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGJhc2VVcmwgdG8gZ2V0IHRoZSBhcHAgYmFzZS5cbiAgICB2YXIgcGF0aCA9IGxpbmsucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGVzY2FwZVJlZ0V4cChiYXNlVXJsKSwgJ2knKSwgJycpO1xuXG4gICAgLy8gR2V0IGZpcnN0IHNlZ21lbnQgb3IgcGFnZSBuYW1lIChhbnl0aGluZyB1bnRpbCBhIHNsYXNoIG9yIGV4dGVuc2lvbiBiZWdnaW5pbmcpXG4gICAgdmFyIG1hdGNoID0gL15cXC8/KFteXFwvXFwuXSspW15cXC9dKihcXC8uKikqJC8uZXhlYyhwYXRoKTtcblxuICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgIHJvb3Q6IHRydWUsXG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIHNlZ21lbnRzOiBudWxsLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICB1cmw6IHJhd1VybCxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgfTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBwYXJzZWQucm9vdCA9IGZhbHNlO1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIHBhcnNlZC5uYW1lID0gbWF0Y2hbMV07XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRoID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlZ21lbnRzID0gbWF0Y2hbMl0ucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGggPSAnLyc7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVXJsOyIsIi8qKlxuICAgIHNhbml0aXplVXJsIHV0aWxpdHkgdGhhdCBlbnN1cmVzXG4gICAgdGhhdCBwcm9ibGVtYXRpYyBwYXJ0cyBnZXQgcmVtb3ZlZC5cbiAgICBcbiAgICBBcyBmb3Igbm93IGl0IGRvZXM6XG4gICAgLSByZW1vdmVzIHBhcmVudCBkaXJlY3Rvcnkgc3ludGF4XG4gICAgLSByZW1vdmVzIGR1cGxpY2F0ZWQgc2xhc2hlc1xuKiovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHNhbml0aXplVXJsKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFwuezIsfS9nLCAnJykucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbml0aXplVXJsOyIsIi8qKlxuICAgIHNuYXBQb2ludHMuXG4gICAgXG4gICAgQWxsb3dzIHRvIHJlZ2lzdGVyIGZvciBhIGpRdWVyeSBlbGVtZW50IGEgc2VyaWVzIG9mXG4gICAgc2Nyb2xsIHZlcnRpY2FsIHBvc2l0aW9ucyAoYWthICdzbmFwIHBvaW50cycpIHRoYXRcbiAgICB3aWxsIHRyaWdnZXIgYSBjdXN0b20gZXZlbnQgKHByb3ZpZGluZyBhIG5hbWUgcGVyIHNuYXAgcG9pbnQpXG4gICAgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB0aGVuIGEgc2Nyb2xsIGNoYW5nZXMgdGhlXG4gICAgY3VycmVudCByZWxhdGl2ZSBwb3NpdGlvbiB3aXRoIHRoYXQgcG9pbnQsIGJlaW5nXG4gICAgdGhlIHJlbGF0aW9uICdiZWZvcmUnLCAnYWZ0ZXInIG9yICd0aGVyZScuXG4gICAgT25seSB0cmlnZ2VycyB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlIChpdCByZW1lbWJlciBwcmV2aW91cyByZWdpc3RlcmVkXG4gICAgc3RhdGUpLlxuICAgIFxuICAgIFRoZSBleGVjdXRpb24gb2YgZWFjaCBjaGVjayBvbiBzY3JvbGxpbmcgaXMgdGhyb3R0bGUgdG8gYXZvaWQgYnVyc3QsXG4gICAgYmVpbmcgdGhlIHByZWNpc2lvbiBvZiB0aGF0IHRocm90dGxlIGNvbmZpZ3VyYWJsZSB0aHJvdWdodCB0aGUgdGhpcmRcbiAgICBwYXJhbWV0ZXIgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHQgaGFzIGEgdmFsdWUgdGhhdCAndGVvcmljYWxseSdcbiAgICBjYW4gZW5hYmxlIHJlYWN0aW9ucyBhdCA2MGZwcy5cbiAgICBDYW4gYmUgY29tcGxldGVseSBkaXNhYmxlZCBieSBwYXNzaW5nIDAgYXMgcHJlY2lzaW9uLCBhbmQgdGhlIGV2ZW50XG4gICAgd2lsbCBiZSB0cmlnZ2VyZWQgc3luY2hyb25vdXNseSB3aGVuIHNjcm9sbCBoYXBwZW5zLlxuICAgIFxuICAgIFRPRE8gQWxsb3cgaG9yaXpvbnRhbCBwb2ludHNcbioqL1xuXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpLFxuICAgIHRocm90dGxlID0gcmVxdWlyZSgnaWFnb3NybC90aHJvdHRsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNuYXBQb2ludHMoJHNjcm9sbGVyRWxlbWVudCwgcG9pbnRzLCBwcmVjaXNpb24pIHtcbiAgICAvL2pzaGludCBtYXhjb21wbGV4aXR5OjhcbiAgICBpZiAoIXBvaW50cyB8fCAhT2JqZWN0LmtleXMocG9pbnRzKS5sZW5ndGgpIHJldHVybjtcbiAgICAkc2Nyb2xsZXJFbGVtZW50ID0gJHNjcm9sbGVyRWxlbWVudCB8fCAkKHdpbmRvdyk7XG4gICAgLy8gNjBmcHMgcHJlY2lzaW9uIGJ5IGRlZmF1bHRcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT09IDAgPyAwIDogTWF0aC5hYnMocHJlY2lzaW9uIHwwKSB8fCAxNjtcbiAgICBcbiAgICB2YXIgcmVjb3JkID0ge307XG5cbiAgICB2YXIgY2hlY2tTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRvcCA9ICRzY3JvbGxlckVsZW1lbnQuc2Nyb2xsVG9wKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHBvaW50cykuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgLy9qc2hpbnQgbWF4Y29tcGxleGl0eTo4XG4gICAgICAgICAgICBwb2ludCA9IHBvaW50IHwwO1xuICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICBpZiAocG9pbnQgPT09IHRvcCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRbcG9pbnRdICE9PSAndGhlcmUnKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3RoZXJlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcCA+IHBvaW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZFtwb2ludF0gIT09ICdhZnRlcicpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYWZ0ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZFtwb2ludF0gIT09ICdiZWZvcmUnKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2JlZm9yZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICRzY3JvbGxlckVsZW1lbnQudHJpZ2dlcihwb2ludHNbcG9pbnRdLCBbdHlwZV0pO1xuICAgICAgICAgICAgICAgIHJlY29yZFtwb2ludF0gPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChwcmVjaXNpb24gPiAwKVxuICAgICAgICBjaGVja1Njcm9sbCA9IHRocm90dGxlKGNoZWNrU2Nyb2xsICwgcHJlY2lzaW9uKTtcblxuICAgICRzY3JvbGxlckVsZW1lbnQuc2Nyb2xsKGNoZWNrU2Nyb2xsKTtcbiAgICAvLyBGaXJzdCB0aW1lIGNoZWNrXG4gICAgY2hlY2tTY3JvbGwoKTtcbn07XG4iLCIvKipcbiAgICBTbWFsbCB1dGlsaXR5IHRvIHNlYXJjaCBhIHRleHQgZnJhZ21lbnQgdXNpbmdcbiAgICBjYXNlIGluc2Vuc2l0aXZlLCBhY2NlbnQvc3ltYm9sIGluc2Vuc2l0aXZlLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZW1vdmVBY2NlbnQgPSByZXF1aXJlKCcuL3JlbW92ZUFjY2VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHRTZWFyY2goc2VhcmNoLCB0ZXh0KSB7XG5cbiAgICB2YXIgcyA9IHJlbW92ZUFjY2VudChzZWFyY2ggfHwgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHQgPSByZW1vdmVBY2NlbnQodGV4dCB8fCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgIHJldHVybiB0LmluZGV4T2YocykgPiAtMTtcbn07XG4iLCIvKipcbiAgICBVc2VyIGFnZW50IHNuaWZmaW5nLiBCZWNhdXNlIHNvbWV0aW1lcyBpcyBuZWVkZWQuXG4qKi9cbi8vZ2xvYmFsIHdpbmRvd1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZsYWdzKCkge1xuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICB2YXIgaU9zV2VidmlldyA9IC9pT1N8aVBhZHxpUGhvbmV8aVBvZC8udGVzdCh1YSk7XG4gICAgICAgIHZhciBpT3NWZXJzaW9uID0gL09TICgoXFxkK18/KXsyLDN9KVxccy8uZXhlYyh1YSk7XG4gICAgICAgIGlmIChpT3NWZXJzaW9uICYmIGlPc1ZlcnNpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaU9zVmVyc2lvbiA9IHsgZnVsbDogaU9zVmVyc2lvblsxXSB8fCAnJyB9O1xuICAgICAgICAgICAgaU9zVmVyc2lvbi5wYXJ0cyA9IGlPc1ZlcnNpb24uZnVsbC5zcGxpdCgnXycpO1xuICAgICAgICAgICAgaU9zVmVyc2lvbi5tYWpvciA9IGlPc1ZlcnNpb24ucGFydHNbMF0gfDA7XG4gICAgICAgICAgICBpT3NWZXJzaW9uLm1pbm9yID0gaU9zVmVyc2lvbi5wYXJ0c1sxXSB8MDtcbiAgICAgICAgICAgIGlPc1ZlcnNpb24ucmV2aXNpb24gPSBpT3NWZXJzaW9uLnBhcnRzWzJdIHwwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PIFdBWSB0byBkZXRlY3Qgd2t3ZWJ2aWV3IHZlcnN1cyB1aXdlYnZpZXcsIHdlIGp1c3QgdXNlIHdrd2VidmlldyBvbiBpT1MgOSBhbmQgbGF0ZXJcbiAgICAgICAgLy8gc28gbmV4dCBhc3N1bXB0aW9uIHdvcmtzIGZvciB1czpcbiAgICAgICAgdmFyIGlzV2tXZWJ2aWV3ID0gaU9zVmVyc2lvbiAmJiBpT3NWZXJzaW9uLm1ham9yID49IDk7XG4gICAgICAgIHZhciBpc0FuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1YSk7XG4gICAgICAgIC8vIENocm9tZSwgYnJvd3NlciBvciB3ZWJ2aWV3IGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vbXVsdGlkZXZpY2UvdXNlci1hZ2VudCAgT2xkIHdlYmtpdCB3ZWJ2aWV3cyBnZXRzIGRpc2NhcmRlZFxuICAgICAgICB2YXIgaXNDaHJvbWUgPSAvQ2hyb21lXFwvLy50ZXN0KHVhKTtcbiAgICAgICAgdmFyIGlzTW9iaWxlID0gaU9zV2VidmlldyB8fCBpc0FuZHJvaWQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzSW9zOiBpT3NXZWJ2aWV3LFxuICAgICAgICAgICAgaU9zVmVyc2lvbjogaU9zVmVyc2lvbixcbiAgICAgICAgICAgIGlzV2tXZWJ2aWV3OiBpc1drV2VidmlldyxcbiAgICAgICAgICAgIGlzQW5kcm9pZDogaXNBbmRyb2lkLFxuICAgICAgICAgICAgaXNDaHJvbWU6IGlzQ2hyb21lLFxuICAgICAgICAgICAgaXNNb2JpbGU6IGlzTW9iaWxlXG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7fTtcbn07XG4iLCIvKiogQXBwb2ludG1lbnRDYXJkIHZpZXcgbW9kZWwuXG4gICAgSXQgcHJvdmlkZXMgZGF0YSBhbmQgbWV0aG9kIHRvIHZpc3VhbGl6ZSBhbmQgXG4gICAgZWRpdCBhbmQgYXBwb2ludG1lbnQgY2FyZCwgd2l0aCBib29raW5nLCBldmVudFxuICAgIG9yIHBsYWNlaG9sZGVyIGluZm9ybWF0aW9uXG4qKi9cblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcbiAgICBnZXRPYnNlcnZhYmxlID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0T2JzZXJ2YWJsZScpLFxuICAgIEFwcG9pbnRtZW50ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0FwcG9pbnRtZW50JyksXG4gICAgQXBwb2ludG1lbnRWaWV3ID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9BcHBvaW50bWVudFZpZXcnKSxcbiAgICBNb2RlbFZlcnNpb24gPSByZXF1aXJlKCcuLi91dGlscy9Nb2RlbFZlcnNpb24nKSxcbiAgICBnZXREYXRlV2l0aG91dFRpbWUgPSByZXF1aXJlKCcuLi91dGlscy9nZXREYXRlV2l0aG91dFRpbWUnKSxcbiAgICBQcmljaW5nU3VtbWFyeURldGFpbCA9IHJlcXVpcmUoJy4uL21vZGVscy9QcmljaW5nU3VtbWFyeURldGFpbCcpO1xuXG5mdW5jdGlvbiBBcHBvaW50bWVudENhcmRWaWV3TW9kZWwocGFyYW1zKSB7XG4gICAgLypqc2hpbnQgbWF4c3RhdGVtZW50czogNDAqL1xuXG4gICAgdGhpcy5zb3VyY2VJdGVtID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuc291cmNlSXRlbSk7XG4gICAgdmFyIGFwcCA9IHRoaXMuYXBwID0ga28udW53cmFwKHBhcmFtcy5hcHApO1xuXG4gICAgdGhpcy5lZGl0TW9kZSA9IGdldE9ic2VydmFibGUocGFyYW1zLmVkaXRNb2RlKTtcbiAgICB0aGlzLmVkaXRlZFZlcnNpb24gPSBrby5vYnNlcnZhYmxlKG51bGwpO1xuICAgIFxuICAgIHRoaXMuaXNTYXZpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGdldE9ic2VydmFibGUocGFyYW1zLmlzTG9hZGluZyk7XG4gICAgdGhpcy5pc0xvY2tlZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhdmluZygpIHx8IHRoaXMuaXNMb2FkaW5nKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5pdGVtID0ga28ub2JzZXJ2YWJsZShBcHBvaW50bWVudFZpZXcodGhpcy5zb3VyY2VJdGVtKCksIGFwcCkpO1xuICAgIFxuICAgIHRoaXMuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgXG4gICAgdGhpcy5jdXJyZW50SUQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdCA9IHRoaXMuaXRlbSgpO1xuICAgICAgICByZXR1cm4gaXQgJiYgaXQuaWQoKSB8fCAwO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuY3VycmVudERhdGV0aW1lID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtKCkgJiYgdGhpcy5pdGVtKCkuc3RhcnRUaW1lKCkgfHwgbmV3IERhdGUoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmN1cnJlbnREYXRlID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0RGF0ZVdpdGhvdXRUaW1lKHRoaXMuaXRlbSgpICYmIHRoaXMuaXRlbSgpLnN0YXJ0VGltZSgpKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmlzTmV3ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuY3VycmVudElEKCk7XG4gICAgICAgIHJldHVybiBpZCA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy5uZXdCb29raW5nIHx8IGlkID09PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLm5ld0V2ZW50O1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuaXNCb29raW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0oKSAmJiB0aGlzLml0ZW0oKS5zb3VyY2VCb29raW5nKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgLyogUmV0dXJuIHRydWUgaWYgaXMgYW4gZXZlbnQgb2JqZWN0IGJ1dCBub3QgYSBib29raW5nICovXG4gICAgdGhpcy5pc0V2ZW50ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW0oKSAmJiB0aGlzLml0ZW0oKS5zb3VyY2VFdmVudCgpICYmICF0aGlzLml0ZW0oKS5zb3VyY2VCb29raW5nKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5oZWFkZXJDbGFzcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNCb29raW5nKCkgPyAodGhpcy5lZGl0TW9kZSgpID8gJ0NhcmQtdGl0bGUtLXdhcm5pbmcnIDogJ0NhcmQtdGl0bGUtLXByaW1hcnknKSA6XG4gICAgICAgICAgICB0aGlzLmlzRXZlbnQoKSA/ICdDYXJkLXRpdGxlLS1kYW5nZXInIDpcbiAgICAgICAgICAgICcnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5uZXdBcHBvaW50bWVudFZpc2libGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuY3VycmVudElEKCk7XG4gICAgICAgIHJldHVybiBpZCA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy5mcmVlIHx8IGlkID09PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLmVtcHR5RGF0ZSB8fCBpZCA9PT0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy51bmF2YWlsYWJsZTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmVkaXRTY2hlZHVsZVZpc2libGUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJRCgpID09PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLnVuYXZhaWxhYmxlO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuc3VibWl0VGV4dCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmVkaXRlZFZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKCkgPyBcbiAgICAgICAgICAgICAgICAnTG9hZGluZy4uLicgOiBcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nKCkgPyBcbiAgICAgICAgICAgICAgICAgICAgJ1NhdmluZyBjaGFuZ2VzJyA6IFxuICAgICAgICAgICAgICAgICAgICB2ICYmIHYuYXJlRGlmZmVyZW50KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc05ldygpICYmIHRoaXMuaXNCb29raW5nKCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCb29rJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NhdmUgY2hhbmdlcydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ1NhdmVkJ1xuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICAgIElmIHRoZSBzb3VyY2VJdGVtIGNoYW5nZXMsIGlzIHNldCBhcyB0aGUgaXRlbSB2YWx1ZVxuICAgICAgICBkaXNjYXJkaW5nIGFueSBtb2RlbCB2ZXJzaW9uIGFuZCByZXZlcnRpbmdcbiAgICAgICAgZWRpdE1vZGUgdG8gZmFsc2VcbiAgICAqKi9cbiAgICB0aGlzLnNvdXJjZUl0ZW0uc3Vic2NyaWJlKGZ1bmN0aW9uKHNvdXJjZUl0ZW0pIHtcbiAgICAgICAgdGhpcy5pdGVtKEFwcG9pbnRtZW50Vmlldyhzb3VyY2VJdGVtLCBhcHApKTtcbiAgICAgICAgdGhpcy5lZGl0ZWRWZXJzaW9uKG51bGwpO1xuICAgICAgICB0aGlzLmVkaXRNb2RlKGZhbHNlKTtcblxuICAgICAgICAvLyBJZiB0aGUgbmV3IGl0ZW0gaXMgYSBuZXcgb25lLCBzZXQgZWRpdCBtb2RlXG4gICAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdE1vZGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAgICBFbnRlciBhbmQgZmluaXNoIGVkaXQ6XG4gICAgICAgIENyZWF0ZSB2ZXJzaW9uIGFuZCBzYXZlIGRhdGFcbiAgICAqKi9cbiAgICB0aGlzLmVkaXRNb2RlLnN1YnNjcmliZShmdW5jdGlvbihpc0VkaXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudElEKCkgPD0gMCAmJiAhdGhpcy5pc05ldygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRWRpdCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBzZXQgYSB2ZXJzaW9uIHRvIGJlIGVkaXRlZFxuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBuZXcgTW9kZWxWZXJzaW9uKHRoaXMuc291cmNlSXRlbSgpKTtcbiAgICAgICAgICAgIHZlcnNpb24udmVyc2lvbi5zb3VyY2VFdmVudCh0aGlzLnNvdXJjZUl0ZW0oKS5zb3VyY2VFdmVudCgpKTtcbiAgICAgICAgICAgIHZlcnNpb24udmVyc2lvbi5zb3VyY2VCb29raW5nKHRoaXMuc291cmNlSXRlbSgpLnNvdXJjZUJvb2tpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLmVkaXRlZFZlcnNpb24odmVyc2lvbik7XG4gICAgICAgICAgICB0aGlzLml0ZW0oQXBwb2ludG1lbnRWaWV3KHZlcnNpb24udmVyc2lvbiwgYXBwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV3KCkgJiYgdGhpcy5pc0V2ZW50KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21lIGRlZmF1bHRzIGZvciBldmVudHNcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW0oKS5zb3VyY2VFdmVudCgpLmF2YWlsYWJpbGl0eVR5cGVJRCgwKTsgLy8gVW5hdmFpbGFibGVcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW0oKS5pc0FsbERheShmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtKCkuc291cmNlRXZlbnQoKS5ldmVudFR5cGVJRCgzKTsgLy8gQXBwb2ludG1lbnQvYmxvY2stdGltZVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbSgpLnN1bW1hcnkoJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pdGVtKEFwcG9pbnRtZW50Vmlldyh0aGlzLnNvdXJjZUl0ZW0oKSwgYXBwKSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuZWRpdCA9IGZ1bmN0aW9uIGVkaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHJldHVybjtcblxuICAgICAgICAvLyBBIHN1YnNjcmliZWQgaGFuZGxlciBlbnN1cmUgdG8gZG8gdGhlIG5lZWRlZCB0YXNrc1xuICAgICAgICB0aGlzLmVkaXRNb2RlKHRydWUpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgYSB2ZXJzaW9uPyBQdXNoIGNoYW5nZXMhXG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy5lZGl0ZWRWZXJzaW9uKCk7XG5cbiAgICAgICAgaWYgKHZlcnNpb24gJiYgdmVyc2lvbi5hcmVEaWZmZXJlbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyh0cnVlKTtcbiAgICAgICAgICAgIGFwcC5tb2RlbC5jYWxlbmRhci5zZXRBcHBvaW50bWVudCh2ZXJzaW9uLnZlcnNpb24sIHRoaXMuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihzYXZlZEFwdCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBkbyBhIHZlcnNpb24gcHVzaCwganVzdCB1cGRhdGUgd2l0aCByZW1vdGVcbiAgICAgICAgICAgICAgICAvL3ZlcnNpb24ucHVzaCh7IGV2ZW5JZk9ic29sZXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB3aXRoIHJlbW90ZSBkYXRhLCB0aGUgb3JpZ2luYWwgYXBwb2ludG1lbnQgaW4gdGhlIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgLy8gbm90IHRoZSBjdXJyZW50QXBwb2ludG1lbnQgb3IgaW4gdGhlIGluZGV4IGluIHRoZSBsaXN0IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gcmFjZS1jb25kaXRpb25zXG4gICAgICAgICAgICAgICAgdmVyc2lvbi5vcmlnaW5hbC5tb2RlbC51cGRhdGVXaXRoKHNhdmVkQXB0KTtcbiAgICAgICAgICAgICAgICAvLyBEbyBhIHB1bGwgc28gb3JpZ2luYWwgYW5kIHZlcnNpb24gZ2V0cyB0aGUgZXhhY3Qgc2FtZSBkYXRhXG4gICAgICAgICAgICAgICAgdmVyc2lvbi5wdWxsKHsgZXZlbklmTmV3ZXI6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBHbyBvdXQgZWRpdCBtb2RlXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0TW9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNCb29raW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLml0ZW0oKS5jbGllbnQoKS5maXJzdE5hbWUoKSArICcgd2lsbCByZWNlaXZlIGFuIGUtbWFpbCBjb25maXJtYXRpb24uJztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd05vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NvbmZpcm1lZCEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdmVyc2lvbiBkYXRhIGtlZXBzIHVudG91Y2hlZCwgdXNlciBtYXkgd2FudCB0byByZXRyeVxuICAgICAgICAgICAgICAgIC8vIG9yIG1hZGUgY2hhbmdlcyBvbiBpdHMgdW4tc2F2ZWQgZGF0YS5cbiAgICAgICAgICAgICAgICAvLyBTaG93IGVycm9yXG4gICAgICAgICAgICAgICAgYXBwLm1vZGFscy5zaG93RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1RoZXJlIHdhcyBhbiBlcnJvciBzYXZpbmcgdGhlIGRhdGEuJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHJlcGxpY2F0ZSBlcnJvciwgYWxsb3cgYWx3YXlzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQUxXQVlTOlxuICAgICAgICAgICAgICAgIHRoaXMuaXNTYXZpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuZWRpdGVkVmVyc2lvbigpKSB7XG4gICAgICAgICAgICAvLyBEaXNjYXJkIHByZXZpb3VzIHZlcnNpb25cbiAgICAgICAgICAgIHRoaXMuZWRpdGVkVmVyc2lvbigpLnB1bGwoeyBldmVuSWZOZXdlcjogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdXQgb2YgZWRpdCBtb2RlXG4gICAgICAgIHRoaXMuZWRpdE1vZGUoZmFsc2UpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmNvbmZpcm1DYW5jZWwgPSBmdW5jdGlvbiBjb25maXJtQ2FuY2VsKCkge1xuICAgICAgICB0aGlzLmFwcC5tb2RhbHMuY29uZmlybSh7XG4gICAgICAgICAgICB0aXRsZTogJ0NhbmNlbCcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXJlIHlvdSBzdXJlPycsXG4gICAgICAgICAgICB5ZXM6ICdZZXMnLFxuICAgICAgICAgICAgbm86ICdObydcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDb25maXJtZWQgY2FuY2VsbGF0aW9uOlxuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgICAgRXh0ZXJuYWwgYWN0aW9uc1xuICAgICoqL1xuICAgIHZhciBlZGl0RmllbGRPbiA9IGZ1bmN0aW9uIGVkaXRGaWVsZE9uKGFjdGl2aXR5LCBkYXRhKSB7XG5cbiAgICAgICAgLy8gSW5jbHVkZSBhcHBvaW50bWVudCB0byByZWNvdmVyIHN0YXRlIG9uIHJldHVybjpcbiAgICAgICAgZGF0YS5hcHBvaW50bWVudCA9IHRoaXMuaXRlbSgpLm1vZGVsLnRvUGxhaW5PYmplY3QodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBkYXRhLmNhbmNlbExpbmsgPSB0aGlzLmNhbmNlbExpbms7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5wcm9ncmVzcyAmJlxuICAgICAgICAgICAgIXRoaXMucHJvZ3Jlc3MuZW5kZWQpIHtcbiAgICAgICAgICAgIGRhdGEucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBkYXRhLnByb2dyZXNzLnN0ZXAgfHwgMSxcbiAgICAgICAgICAgICAgICB0b3RhbCA9IGRhdGEucHJvZ3Jlc3MudG90YWwgfHwgMTtcbiAgICAgICAgICAgIC8vIFRPRE8gSTE4TlxuICAgICAgICAgICAgZGF0YS50aXRsZSA9IHN0ZXAgKyAnIG9mICcgKyB0b3RhbDtcbiAgICAgICAgICAgIGRhdGEubmF2VGl0bGUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8ga2VlcCBkYXRhLnByb2dyZXNzIHNvIGl0IGRvZXMgbm90IHJlc3RhcnQgdGhlIHByb2Nlc3MgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGFuIGVkaXRpb24uIFRoZSBwYXNzSW4gYWxyZWFkeSByZXNldHMgdGhhdCBvbiBuZXcgY2FsbHNcbiAgICAgICAgICAgIGRhdGEucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xuICAgICAgICAgICAgLy8gRWRpdGlvbiB0aXRsZTpcbiAgICAgICAgICAgIGRhdGEudGl0bGUgPSBudWxsO1xuICAgICAgICAgICAgZGF0YS5uYXZUaXRsZSA9IHRoaXMuaXNCb29raW5nKCkgPyAnQm9va2luZycgOiAnRXZlbnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwLnNoZWxsLmdvKGFjdGl2aXR5LCBkYXRhKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnBpY2tEYXRlVGltZSA9IGZ1bmN0aW9uIHBpY2tEYXRlVGltZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgIGVkaXRGaWVsZE9uKCdkYXRldGltZVBpY2tlcicsIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXRpbWU6IHRoaXMuaXRlbSgpLnN0YXJ0VGltZSgpLFxuICAgICAgICAgICAgZGF0ZXRpbWVGaWVsZDogJ3N0YXJ0VGltZScsXG4gICAgICAgICAgICBoZWFkZXJUZXh0OiAnU2VsZWN0IHRoZSBzdGFydCB0aW1lJyxcbiAgICAgICAgICAgIHJlcXVpcmVkRHVyYXRpb246IHRoaXMuaXRlbSgpLmdldFNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKVxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnBpY2tFbmREYXRlVGltZSA9IGZ1bmN0aW9uIHBpY2tFbmREYXRlVGltZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgIGVkaXRGaWVsZE9uKCdkYXRldGltZVBpY2tlcicsIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0ZXRpbWU6IHRoaXMuaXRlbSgpLmVuZFRpbWUoKSxcbiAgICAgICAgICAgIGRhdGV0aW1lRmllbGQ6ICdlbmRUaW1lJyxcbiAgICAgICAgICAgIGhlYWRlclRleHQ6ICdTZWxlY3QgdGhlIGVuZCB0aW1lJ1xuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnBpY2tDbGllbnQgPSBmdW5jdGlvbiBwaWNrQ2xpZW50KCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XG5cbiAgICAgICAgZWRpdEZpZWxkT24oJ2NsaWVudHMnLCB7XG4gICAgICAgICAgICBzZWxlY3RDbGllbnQ6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3RlZENsaWVudElEOiB0aGlzLml0ZW0oKS5zb3VyY2VCb29raW5nKCkuY2xpZW50VXNlcklEKClcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5waWNrU2VydmljZSA9IGZ1bmN0aW9uIHBpY2tTZXJ2aWNlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XG5cbiAgICAgICAgZWRpdEZpZWxkT24oJ3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlLycgKyB0aGlzLml0ZW0oKS5qb2JUaXRsZUlEKCksIHtcbiAgICAgICAgICAgIHNlbGVjdFByaWNpbmc6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3RlZFNlcnZpY2VzOiB0aGlzLml0ZW0oKS5wcmljaW5nKClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocHJpY2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQ6IGtvLnVud3JhcChwcmljaW5nLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlSUQpLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbFByaWNlOiBrby51bndyYXAocHJpY2luZy50b3RhbFByaWNlKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNoYW5nZVByaWNlID0gZnVuY3Rpb24gY2hhbmdlUHJpY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHJldHVybjtcbiAgICAgICAgLy8gVE9ET1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMucGlja0xvY2F0aW9uID0gZnVuY3Rpb24gcGlja0xvY2F0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSByZXR1cm47XG5cbiAgICAgICAgZWRpdEZpZWxkT24oJ3NlcnZpY2VBZGRyZXNzZXMvJyArIHRoaXMuaXRlbSgpLmpvYlRpdGxlSUQoKSwge1xuICAgICAgICAgICAgc2VsZWN0QWRkcmVzczogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzc0lEOiB0aGlzLml0ZW0oKS5hZGRyZXNzSUQoKVxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgdGV4dEZpZWxkc0hlYWRlcnMgPSB7XG4gICAgICAgIHByZU5vdGVzVG9DbGllbnQ6ICdOb3RlcyB0byBjbGllbnQnLFxuICAgICAgICBwb3N0Tm90ZXNUb0NsaWVudDogJ05vdGVzIHRvIGNsaWVudCAoYWZ0ZXJ3YXJkcyknLFxuICAgICAgICBwcmVOb3Rlc1RvU2VsZjogJ05vdGVzIHRvIHNlbGYnLFxuICAgICAgICBwb3N0Tm90ZXNUb1NlbGY6ICdCb29raW5nIHN1bW1hcnknLFxuICAgICAgICBzdW1tYXJ5OiAnV2hhdD8nXG4gICAgfTtcblxuICAgIHRoaXMuZWRpdFRleHRGaWVsZCA9IGZ1bmN0aW9uIGVkaXRUZXh0RmllbGQoZmllbGQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgIGVkaXRGaWVsZE9uKCd0ZXh0RWRpdG9yJywge1xuICAgICAgICAgICAgcmVxdWVzdDogJ3RleHRFZGl0b3InLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgdGl0bGU6IHRoaXMuaXNOZXcoKSA/ICdOZXcgYm9va2luZycgOiAnQm9va2luZycsXG4gICAgICAgICAgICBoZWFkZXI6IHRleHRGaWVsZHNIZWFkZXJzW2ZpZWxkXSxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuaXRlbSgpW2ZpZWxkXSgpXG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICAvLyBwYXNzIHRoaXMgcmVhZHkgbW9kZWwgdmlldyBhcyBhbiBBUEkgdG8gdGhlIG91dHNpZGVcbiAgICBpZiAodHlwZW9mKHBhcmFtcy5hcGkpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBhcmFtcy5hcGkodGhpcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZW5kVGltZSBnaXZlbiBhbiBhcHBvaW50bWVudCBkdXJhdGlvbiwgcmV0cmlldmVkXG4gICAgLy8gZnJvbSB0aGUgc2VsZWN0ZWQgc2VydmljZVxuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uIGNhbGN1bGF0ZUVuZFRpbWUoKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuaXRlbSgpLnNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gbW9tZW50KHRoaXMuaXRlbSgpLnN0YXJ0VGltZSgpKSxcbiAgICAgICAgICAgIGVuZDtcblxuICAgICAgICBpZiAodGhpcy5pc0Jvb2tpbmcoKSAmJlxuICAgICAgICAgICAgc3RhcnQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBlbmQgPSBzdGFydC5hZGQoZHVyYXRpb24sICdtaW51dGVzJykudG9EYXRlKCk7XG4gICAgICAgICAgICB0aGlzLml0ZW0oKS5lbmRUaW1lKGVuZCk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKVxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJywgdGltZW91dDogMjAgfSB9KTtcbn1cblxuLyoqXG4gICAgSXQgbWFuYWdlcyBpbmNvbWluZyBkYXRhIHByb3ZpZGVkIGJ5IGV4dGVybmFsIGFjdGl2aXRpZXMgZ2l2ZW5cbiAgICB0aGUgcmVxdWVzdERhdGEgcmVjZWl2ZWQgYnkgdGhlIGFjdGl2aXR5IGhvc3RpbmcgdGhpcyB2aWV3IGluc3RhbmNlLlxuICAgIFVzZWQgdG8gbWFuYWdlIHRoZSBkYXRhIHJldHVybmVkIGJ5IGNhbGxzIHRvIGVkaXQgZGF0YSBpblxuICAgIGV4dGVybmFsIGFjdGl2aXRpZXMuXG4qKi9cbkFwcG9pbnRtZW50Q2FyZFZpZXdNb2RlbC5wcm90b3R5cGUucGFzc0luID0gZnVuY3Rpb24gcGFzc0luKHJlcXVlc3REYXRhKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToyMCxtYXhzdGF0ZW1lbnRzOjQwICovXG4gICAgXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgaW5jbHVkZXMgYW4gYXBwb2ludG1lbnQgcGxhaW4gb2JqZWN0LCB0aGF0J3MgYW5cbiAgICAvLyBpbi1lZGl0aW5nIGFwcG9pbnRtZW50IHNvIHB1dCBpdCBpbiBwbGFjZSAodG8gcmVzdG9yZSBhIHByZXZpb3VzIGVkaXRpb24pXG4gICAgaWYgKHJlcXVlc3REYXRhLmFwcG9pbnRtZW50KSB7XG4gICAgICAgIC8vIFNldCB0aGUgZWRpdCBtb2RlIChpdCBwZXJmb3JtcyBhbnkgcmVxdWlyZWRcbiAgICAgICAgLy8gc2V0LXVwIGlmIHdlIGFyZSBub3Qgc3RpbGwgaW4gZWRpdCBtb2RlKS5cbiAgICAgICAgdGhpcy5lZGl0TW9kZSh0cnVlKTtcbiAgICAgICAgLy8gU2V0cyB0aGUgZGF0YVxuICAgICAgICB0aGlzLml0ZW0oKVxuICAgICAgICAubW9kZWwudXBkYXRlV2l0aChyZXF1ZXN0RGF0YS5hcHBvaW50bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgLy8gT24gYW55IG90aGVyIGNhc2UsIGFuZCB0byBwcmV2ZW50IGEgYmFkIGVkaXRNb2RlIHN0YXRlLFxuICAgICAgICAvLyBzZXQgb2ZmIGVkaXQgbW9kZSBkaXNjYXJkaW5nIHVuc2F2ZWQgZGF0YTpcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICB9XG5cbiAgICAvLy8gTWFuYWdlIHNwZWNpZmljIHNpbmdsZSBkYXRhIGZyb20gZXh0ZXJuYWxseSBwcm92aWRlZFxuICAgIFxuICAgIC8vIEl0IGNvbWVzIGJhY2sgZnJvbSB0aGUgdGV4dEVkaXRvci5cbiAgICBpZiAocmVxdWVzdERhdGEucmVxdWVzdCA9PT0gJ3RleHRFZGl0b3InKSB7XG4gICAgICAgIHRoaXMuaXRlbSgpW3JlcXVlc3REYXRhLmZpZWxkXShyZXF1ZXN0RGF0YS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3REYXRhLnNlbGVjdENsaWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLml0ZW0oKS5jbGllbnRVc2VySUQocmVxdWVzdERhdGEuc2VsZWN0ZWRDbGllbnRJRCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YocmVxdWVzdERhdGEuc2VsZWN0ZWREYXRldGltZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHJlcXVlc3REYXRhLmRhdGV0aW1lRmllbGQ7XG4gICAgICAgIHRoaXMuaXRlbSgpW2ZpZWxkXShyZXF1ZXN0RGF0YS5zZWxlY3RlZERhdGV0aW1lKTtcbiAgICAgICAgdGhpcy5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUocmVxdWVzdERhdGEuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3REYXRhLnNlbGVjdGVkSm9iVGl0bGVJRCkge1xuICAgICAgICB0aGlzLml0ZW0oKS5qb2JUaXRsZUlEKHJlcXVlc3REYXRhLnNlbGVjdGVkSm9iVGl0bGVJRCk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0RGF0YS5zZWxlY3RBZGRyZXNzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaXRlbSgpLmFkZHJlc3NJRChyZXF1ZXN0RGF0YS5zZWxlY3RlZEFkZHJlc3NJRCk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0RGF0YS5zZWxlY3RQcmljaW5nID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaXRlbSgpLnByaWNpbmcoXG4gICAgICAgICAgICByZXF1ZXN0RGF0YS5zZWxlY3RlZFNlcnZpY2VzLm1hcChmdW5jdGlvbihwcmljaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmljaW5nU3VtbWFyeURldGFpbChwcmljaW5nKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgaWYgKHJlcXVlc3REYXRhICYmIHJlcXVlc3REYXRhLmNhbmNlbExpbmspIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTGluayA9IHJlcXVlc3REYXRhLmNhbmNlbExpbms7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2luZyB0aGUgUmVmZXJyZXIgVVJMIGFzIHRoZSBsaW5rIHdoZW4gY2FuY2VsbGluZyB0aGUgdGFza1xuICAgICAgICAgICAgdmFyIHJlZmVycmVyVXJsID0gdGhpcy5hcHAuc2hlbGwucmVmZXJyZXJSb3V0ZTtcbiAgICAgICAgICAgIHJlZmVycmVyVXJsID0gcmVmZXJyZXJVcmwgJiYgcmVmZXJyZXJVcmwudXJsIHx8ICdjYWxlbmRhcic7XG5cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTGluayA9IHJlZmVycmVyVXJsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBiZWhhdmlvciBmb3IgYWRkaW5nIGEgYm9va2luZzogaXQgcmVxdWlyZXMgYSBndWlkZWQgY3JlYXRpb25cbiAgICAvLyB0aHJvdWdoIGEgcHJvZ3Jlc3MgcGF0aFxuICAgIGlmICh0aGlzLmN1cnJlbnRJRCgpID09PSBBcHBvaW50bWVudC5zcGVjaWFsSWRzLm5ld0Jvb2tpbmcpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0RGF0YS5wcm9ncmVzcykge1xuICAgICAgICAgICAgLy8gU3RhcnQhXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzID0ge1xuICAgICAgICAgICAgICAgIHN0ZXA6IDEsXG4gICAgICAgICAgICAgICAgdG90YWw6IDQsXG4gICAgICAgICAgICAgICAgZW5kZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gRmlyc3Qgc3RlcFxuICAgICAgICAgICAgdGhpcy5waWNrQ2xpZW50KCk7IC8vLl9kZWxheWVkKDUwKSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3REYXRhLnByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gcmVxdWVzdERhdGEucHJvZ3Jlc3M7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMucHJvZ3Jlc3Muc3RlcCB8fCAxO1xuICAgICAgICAgICAgaWYgKHN0ZXAgPCAyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kIHN0ZXBcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzLnN0ZXAgPSAyO1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1NlcnZpY2UoKTsvLy5fZGVsYXllZCg1MCkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ZXAgPCAzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyaWQgc3RlcFxuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhLnByb2dyZXNzLnN0ZXAgPSAzO1xuICAgICAgICAgICAgICAgIHRoaXMucGlja0RhdGVUaW1lKCk7Ly8uX2RlbGF5ZWQoNTApKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGVwIDwgNCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhLnByb2dyZXNzLnN0ZXAgPSA0O1xuICAgICAgICAgICAgICAgIHRoaXMucGlja0xvY2F0aW9uKCk7Ly8uX2RlbGF5ZWQoNTApKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdGVwcyBmaW5pc2hlZCwgbm90IGl0IGVudGVycyBpbiByZXZpc2lvbiBtb2RlIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGZpbmFsbHkgc2F2ZS9jcmVhdGUgdGhlIGJvb2tpbmcsIGJ1dCByZW1vdmUgdGhlIHByb2dyZXNzIGluZm9cbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBwcm9ibGVtcyBlZGl0aW5nIGZpZWxkcy5cbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc2V0IHByb2dyZXNzXG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBcHBvaW50bWVudENhcmRWaWV3TW9kZWw7XG4iLCIvKipcbiAgICBBcHBvaW50bWVudCBWaWV3IG1vZGVsIHRoYXQgd3JhcHMgYW4gQXBwb2ludG1lbnRcbiAgICBtb2RlbCBpbnN0YW5jZSBleHRlbmRlZCB3aXRoIGV4dHJhIG1ldGhvZHMgY29ubmVjdGVkXG4gICAgdG8gcmVsYXRlZCBkYXRhXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBBcHBvaW50bWVudFZpZXcoYXBwb2ludG1lbnQsIGFwcCkge1xuICAgIGlmIChhcHBvaW50bWVudC5faXNBcHBvaW50bWVudFZpZXcpIHJldHVybiBhcHBvaW50bWVudDtcbiAgICBhcHBvaW50bWVudC5faXNBcHBvaW50bWVudFZpZXcgPSB0cnVlO1xuXG4gICAgYXBwb2ludG1lbnQuY2xpZW50ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5zb3VyY2VCb29raW5nKCk7XG4gICAgICAgIGlmICghYikgcmV0dXJuIG51bGw7XG4gICAgICAgIFxuICAgICAgICB2YXIgY2lkID0gdGhpcy5jbGllbnRVc2VySUQoKTtcbiAgICAgICAgaWYgKGNpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5jbGllbnRzLmdldE9ic2VydmFibGVJdGVtKGNpZCwgdHJ1ZSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBhcHBvaW50bWVudClcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XG4gICAgXG4gICAgYXBwb2ludG1lbnQuYWRkcmVzcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWlkID0gdGhpcy5hZGRyZXNzSUQoKSxcbiAgICAgICAgICAgIGppZCA9IHRoaXMuam9iVGl0bGVJRCgpO1xuICAgICAgICBpZiAoYWlkICYmIGppZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcC5tb2RlbC5zZXJ2aWNlQWRkcmVzc2VzLmdldE9ic2VydmFibGVJdGVtKGppZCwgYWlkLCB0cnVlKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIGFwcG9pbnRtZW50KVxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJywgdGltZW91dDogMjAgfSB9KTtcblxuICAgIGFwcG9pbnRtZW50LmFkZHJlc3NTdW1tYXJ5ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudERhdGEgPSB0aGlzLnNvdXJjZUV2ZW50KCk7XG4gICAgICAgIHZhciBhZGQgPSB0aGlzLmFkZHJlc3MoKTtcbiAgICAgICAgcmV0dXJuIGFkZCAmJiBhZGQuc2luZ2xlTGluZSgpIHx8IGV2ZW50RGF0YSAmJiBldmVudERhdGEubG9jYXRpb24oKSB8fCAnJztcbiAgICB9LCBhcHBvaW50bWVudClcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XG4gICAgXG4gICAgLyogUHJvcGVydHkgd2l0aCB0aGUgcHJpY2luZyBhcnJheSBwbHVzIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgICAgICBzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZS5cbiAgICAqL1xuICAgIGFwcG9pbnRtZW50LnByaWNpbmdXaXRoSW5mbyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuc291cmNlQm9va2luZygpO1xuICAgICAgICBpZiAoIWIpIHJldHVybiBbXTtcblxuICAgICAgICB2YXIgamlkID0gdGhpcy5qb2JUaXRsZUlEKCksXG4gICAgICAgICAgICBkZXRhaWxzID0gdGhpcy5wcmljaW5nKCk7XG5cbiAgICAgICAgcmV0dXJuIGRldGFpbHMubWFwKGZ1bmN0aW9uKGRldCkge1xuICAgICAgICAgICAgcmV0dXJuIFByaWNpbmdTdW1tYXJ5RGV0YWlsVmlldyhkZXQsIGppZCwgYXBwKTtcbiAgICAgICAgfSk7XG4gICAgfSwgYXBwb2ludG1lbnQpXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiA2MCB9IH0pO1xuXG4gICAgYXBwb2ludG1lbnQuc2VydmljZXNTdW1tYXJ5ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaWNpbmdXaXRoSW5mbygpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2Uuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UoKS5uYW1lKCk7XG4gICAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgfSwgYXBwb2ludG1lbnQpXG4gICAgLmV4dGVuZCh7IHJhdGVMaW1pdDogeyBtZXRob2Q6ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnLCB0aW1lb3V0OiAyMCB9IH0pO1xuICAgIFxuICAgIC8vIFNlcnZpY2VEdXJhdGlvbiBhcyBmdW5jdGlvbiwgYmVjYXVzZSBpcyBuZWVkZWQgZm9yIGNhc2VzIHdoZW4gY2Fubm90IHdhaXQgZm9yIHRoZSBcbiAgICAvLyByYXRlZCBjb21wdXRlZFxuICAgIGFwcG9pbnRtZW50LmdldFNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByaWNpbmcgPSB0aGlzLnByaWNpbmdXaXRoSW5mbygpO1xuICAgICAgICB2YXIgc3VtID0gcHJpY2luZy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBzZXJ2aWNlLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlKCkuc2VydmljZUR1cmF0aW9uTWludXRlcygpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuICAgIC8vIFNlcnZpY2VEdXJhdGlvbiBhcyBjb21wdXRlZCBzbyBjYW4gYmUgb2JzZXJ2ZWQgZm9yIGNoYW5nZXNcbiAgICBhcHBvaW50bWVudC5zZXJ2aWNlRHVyYXRpb25NaW51dGVzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMoKTtcbiAgICB9LCBhcHBvaW50bWVudClcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XG4gICAgXG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmljaW5nID0gYXBwb2ludG1lbnQucHJpY2luZygpO1xuICAgICAgICB0aGlzLnByaWNlKHByaWNpbmcucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBjdXIucHJpY2UoKTtcbiAgICAgICAgfSwgMCkpO1xuICAgIH0sIGFwcG9pbnRtZW50KVxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJywgdGltZW91dDogMjAgfSB9KTtcblxuICAgIHJldHVybiBhcHBvaW50bWVudDtcbn07XG5cbmZ1bmN0aW9uIFByaWNpbmdTdW1tYXJ5RGV0YWlsVmlldyhwcmljaW5nU3VtbWFyeURldGFpbCwgam9iVGl0bGVJRCwgYXBwKSB7XG5cbiAgICBwcmljaW5nU3VtbWFyeURldGFpbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGlkID0gdGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKCk7XG4gICAgICAgIHJldHVybiBhcHAubW9kZWwuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzXG4gICAgICAgICAgICAuZ2V0T2JzZXJ2YWJsZUl0ZW0oam9iVGl0bGVJRCwgcGlkLCB0cnVlKSgpO1xuICAgIH0sIHByaWNpbmdTdW1tYXJ5RGV0YWlsKVxuICAgIC5leHRlbmQoeyByYXRlTGltaXQ6IHsgbWV0aG9kOiAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJywgdGltZW91dDogMjAgfSB9KTtcblxuICAgIHJldHVybiBwcmljaW5nU3VtbWFyeURldGFpbDtcbn1cbiIsIi8qKlxuICAgIEJvb2tpbmdQcm9ncmVzc1xuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9Nb2RlbCcpLFxuICAgIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZnVuY3Rpb24gQm9va2luZ1Byb2dyZXNzKHZhbHVlcykge1xuICAgIE1vZGVsKHRoaXMpO1xuXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgc3RlcDogMCxcbiAgICAgICAgc3RlcHNMaXN0OiBbXSxcbiAgICAgICAgZW5kZWQ6IGZhbHNlXG4gICAgfSwgdmFsdWVzKTtcbiAgICBcbiAgICB0aGlzLnRvdGFsU3RlcHMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzTGlzdCgpLmxlbmd0aDtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwc0xpc3QoKVt0aGlzLnN0ZXAoKV07XG4gICAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQm9va2luZ1Byb2dyZXNzO1xuXG5Cb29raW5nUHJvZ3Jlc3MucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RlcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuc3RlcCgpICsgMSwgdGhpcy50b3RhbFN0ZXBzKCkgLSAxKSk7XG4gICAgXG4gICAgdGhpcy5zdGVwKHN0ZXApO1xufTtcblxuQm9va2luZ1Byb2dyZXNzLnByb3RvdHlwZS5vYnNlcnZlU3RlcCA9IGZ1bmN0aW9uKHN0ZXBOYW1lKSB7XG4gICAgcmV0dXJuIGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdGVwKHN0ZXBOYW1lKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbkJvb2tpbmdQcm9ncmVzcy5wcm90b3R5cGUuaXNTdGVwID0gZnVuY3Rpb24oc3RlcE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwc0xpc3QoKVt0aGlzLnN0ZXAoKV0gPT09IHN0ZXBOYW1lO1xufTtcblxuLypcbkJvb2tpbmdQcm9ncmVzcy5wcm90b3R5cGUuZ2V0UmVxdWVzdERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICBcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgcHJvZ3Jlc3M6IHt9XG4gICAgfTtcbiAgICBcbiAgICBpZiAoIXRoaXMuZW5kZWQoKSkge1xuXG4gICAgICAgIHZhciBzdGVwID0gZGF0YS5zdGVwKCkgfHwgMSxcbiAgICAgICAgICAgIHRvdGFsID0gZGF0YS50b3RhbFN0ZXBzKCkgfHwgMTtcbiAgICAgICAgLy8gVE9ETyBJMThOXG4gICAgICAgIGRhdGEudGl0bGUgPSBzdGVwICsgJyBvZiAnICsgdG90YWw7XG4gICAgICAgIGRhdGEubmF2VGl0bGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVkaXRpb24gdGl0bGU6XG4gICAgICAgIGRhdGEudGl0bGUgPSBudWxsO1xuICAgICAgICBkYXRhLm5hdlRpdGxlID0gJ0Jvb2tpbmcnO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xufTtcbiovIiwiLyoqXG4gICAgVmlldyBtb2RlbCBmb3IgdGhlIGRhdGV0aW1lLXBpY2tlciBjb21wb25lbnQvdGVtcGxhdGVcbioqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcbiAgICBnZXREYXRlV2l0aG91dFRpbWUgPSByZXF1aXJlKCcuLi91dGlscy9nZXREYXRlV2l0aG91dFRpbWUnKSxcbiAgICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKSxcbiAgICBUaW1lID0gcmVxdWlyZSgnLi4vdXRpbHMvVGltZScpO1xuXG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL0RhdGVQaWNrZXInKTtcbnZhciBkYXRlcGlja2VyQXZhaWxhYmlsaXR5ID0gcmVxdWlyZSgnLi4vdXRpbHMvZGF0ZXBpY2tlckF2YWlsYWJpbGl0eScpO1xuXG5mdW5jdGlvbiBEYXRldGltZVBpY2tlclZNKGFwcCwgZWxlbWVudCkge1xuICAgIFxuICAgIHRoaXMuc2VsZWN0ZWREYXRlID0ga28ub2JzZXJ2YWJsZShnZXREYXRlV2l0aG91dFRpbWUoKSk7XG4gICAgdGhpcy51c2VySUQgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLnJlcXVpcmVkRHVyYXRpb25NaW51dGVzID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICBcbiAgICB0aGlzLmR1cmF0aW9uRGlzcGxheSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZ1bGxNaW51dGVzID0gdGhpcy5yZXF1aXJlZER1cmF0aW9uTWludXRlcygpO1xuICAgICAgICBpZiAoZnVsbE1pbnV0ZXMgPD0gMClcbiAgICAgICAgICAgIHJldHVybiAnJztcblxuICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKGZ1bGxNaW51dGVzIC8gNjApLFxuICAgICAgICAgICAgbWludXRlcyA9IGZ1bGxNaW51dGVzICUgNjAsXG4gICAgICAgICAgICB0ZXh0ID0gJyc7XG5cbiAgICAgICAgaWYgKGhvdXJzID4gMClcbiAgICAgICAgICAgIHRleHQgKz0gbW9tZW50LmR1cmF0aW9uKHsgaG91cnM6IGhvdXJzIH0pLmh1bWFuaXplKCkgKyAnICc7XG4gICAgICAgIGlmIChtaW51dGVzID4gMClcbiAgICAgICAgICAgIHRleHQgKz0gbW9tZW50LmR1cmF0aW9uKHsgbWludXRlczogbWludXRlcyB9KS5odW1hbml6ZSgpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5kYXRlQXZhaWwgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5ncm91cGVkU2xvdHMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpe1xuICAgICAgICBcbiAgICAgICAgdmFyIHJlcXVpcmVkRHVyYXRpb25NaW51dGVzID0gdGhpcy5yZXF1aXJlZER1cmF0aW9uTWludXRlcygpO1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICBiZWZvcmUgMTI6MDBwbSAobm9vbikgPSBtb3JuaW5nXG4gICAgICAgICAgYWZ0ZXJub29uOiAxMjowMHBtIHVudGlsIDU6MDBwbVxuICAgICAgICAgIGV2ZW5pbmc6IDU6MDBwbSAtIDExOjU5cG1cbiAgICAgICAgKi9cbiAgICAgICAgLy8gU2luY2Ugc2xvdHMgbXVzdCBiZSBmb3IgdGhlIHNhbWUgZGF0ZSxcbiAgICAgICAgLy8gdG8gZGVmaW5lIHRoZSBncm91cHMgcmFuZ2VzIHVzZSB0aGUgZmlyc3QgZGF0ZVxuICAgICAgICB2YXIgZGF0ZVBhcnQgPSB0aGlzLnNlbGVjdGVkRGF0ZSgpIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciBncm91cHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdNb3JuaW5nJyxcbiAgICAgICAgICAgICAgICBzbG90czogW10sXG4gICAgICAgICAgICAgICAgc3RhcnRzOiBuZXcgVGltZShkYXRlUGFydCwgMCwgMCksXG4gICAgICAgICAgICAgICAgZW5kczogbmV3IFRpbWUoZGF0ZVBhcnQsIDEyLCAwKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBncm91cDogJ0FmdGVybm9vbicsXG4gICAgICAgICAgICAgICAgc2xvdHM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0czogbmV3IFRpbWUoZGF0ZVBhcnQsIDEyLCAwKSxcbiAgICAgICAgICAgICAgICBlbmRzOiBuZXcgVGltZShkYXRlUGFydCwgMTcsIDApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdyb3VwOiAnRXZlbmluZycsXG4gICAgICAgICAgICAgICAgc2xvdHM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0czogbmV3IFRpbWUoZGF0ZVBhcnQsIDE3LCAwKSxcbiAgICAgICAgICAgICAgICBlbmRzOiBuZXcgVGltZShkYXRlUGFydCwgMjQsIDApXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gUG9wdWxhdGUgZ3JvdXBzIHdpdGggdGhlIHRpbWUgc2xvdHNcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5kYXRlQXZhaWwoKSAmJiB0aGlzLmRhdGVBdmFpbCgpLmdldEZyZWVUaW1lU2xvdHMocmVxdWlyZWREdXJhdGlvbk1pbnV0ZXMpIHx8IFtdO1xuICAgICAgICAvLyBJdGVyYXRlIHRvIG9yZ2FuaXplIGJ5IGdyb3VwXG4gICAgICAgIHNsb3RzLmZvckVhY2goZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZXZlcnkgZ3JvdXBcbiAgICAgICAgICAgIGdyb3Vwcy5zb21lKGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbWF0Y2hlcyB0aGUgZ3JvdXAsIHB1c2ggdG8gaXRcbiAgICAgICAgICAgICAgICAvLyBhbmQgZ28gb3V0IG9mIGdyb3VwcyBpdGVyYXRpb24gcXVpY2tseVxuICAgICAgICAgICAgICAgIGlmIChzbG90ID49IGdyb3VwLnN0YXJ0cyAmJlxuICAgICAgICAgICAgICAgICAgICBzbG90IDwgZ3JvdXAuZW5kcykge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5zbG90cy5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwcztcblxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuc2VsZWN0ZWREYXRldGltZSA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgXG4gICAgdGhpcy5zZWxlY3REYXRldGltZSA9IGZ1bmN0aW9uKHNlbGVjdGVkRGF0ZXRpbWUsIGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXRpbWUoc2VsZWN0ZWREYXRldGltZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLy8vXG4gICAgLy8vIFRpbWUgUGlja2VyXG5cbiAgICB0aGlzLnBpY2tlZFRpbWUgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLnVuYXZhaWxhYmxlVGltZUJ0bkVuYWJsZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICBcbiAgICB0aGlzLmdldFBpY2tlZERhdGV0aW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5waWNrZWRUaW1lKCk7XG4gICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgLy8gQnVpbGQgZGF0ZS10aW1lXG4gICAgICAgICAgICB2YXIgdGltZXNwYW4gPSBtb21lbnQuZHVyYXRpb24odCk7XG4gICAgICAgICAgICB0ID0gbW9tZW50KHRoaXMuc2VsZWN0ZWREYXRlKCkpLnN0YXJ0T2YoJ2RheScpLmFkZCh0aW1lc3BhbikudG9EYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldFBpY2tlZEFzU2VsZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hbGxvd0Jvb2tVbmF2YWlsYWJsZVRpbWUodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRldGltZSh0aGlzLmdldFBpY2tlZERhdGV0aW1lKCkpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnNob3dUaW1lUGlja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwcC5tb2RhbHMuc2hvd1RpbWVQaWNrZXIoe1xuICAgICAgICAgICAgdGl0bGU6ICdCb29rIGFuIHVuYXZhaWxhYmxlIHRpbWUnLFxuICAgICAgICAgICAgc2VsZWN0ZWRUaW1lOiBudWxsLFxuICAgICAgICAgICAgdW5zZXRMYWJlbDogJ0NhbmNlbCdcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihwaWNrZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHBpY2tlZFZhbHVlLnRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tlZFRpbWUocGlja2VkVmFsdWUudGltZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQaWNrZWRBc1NlbGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSnVzdCBtb2RhbCB3YXMgZGlzbWlzc2VkLCBzbyBwaWNrZXIgd2FzIHJlamVjdGVkIGJ1dCBub3QgYW4gZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGV0aW1lKG51bGwpO1xuICAgICAgICB0aGlzLnBpY2tlZFRpbWUobnVsbCk7XG4gICAgICAgIHRoaXMuYWxsb3dCb29rVW5hdmFpbGFibGVUaW1lKGZhbHNlKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5iaW5kRGF0ZURhdGEgPSBmdW5jdGlvbiBiaW5kRGF0ZURhdGEoZGF0ZSkge1xuXG4gICAgICAgIGlmICghZGF0ZSB8fCAhdGhpcy51c2VySUQoKSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgZGF0ZSA9IGdldERhdGVXaXRob3V0VGltZShkYXRlKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuaXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAvL3JldHVybiBhcHAubW9kZWwuY2FsZW5kYXIuZ2V0RGF0ZUF2YWlsYWJpbGl0eShkYXRlKVxuICAgICAgICByZXR1cm4gYXBwLm1vZGVsLmF2YWlsYWJpbGl0eS50aW1lcyh0aGlzLnVzZXJJRCgpLCBkYXRlKVxuICAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0ZUF2YWlsKGRhdGEpO1xuXG4gICAgICAgICAgICAvKnZhciBzZGF0ZSA9IG1vbWVudChkYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdHMoZGF0YS5zbG90cy5tYXAoZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICAgICAgICAgIC8vIEZyb20gc3RyaW5nIHRvIERhdGVcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZXNsb3QgPSBuZXcgRGF0ZShzZGF0ZSArICdUJyArIHNsb3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlc2xvdDtcbiAgICAgICAgICAgIH0pKTsqL1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0Vycm9yIGxvYWRpbmcgYXZhaWxhYmlsaXR5JyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEZpbmFsbHlcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBcbiAgICAvLy9cbiAgICAvLy8gSW5pdCBjb21wb25lbnQgYW5kIGhhbmRsZXJzXG4gICAgLy8gR2V0dGluZyBjb21wb25lbnQgZWxlbWVudFxuICAgIHZhciAkZGF0ZVBpY2tlciA9ICQoZWxlbWVudCkuZmluZCgnLmNhbGVuZGFyLXBsYWNlaG9sZGVyJyk7XG4gICAgJGRhdGVQaWNrZXIuc2hvdygpLmRhdGVwaWNrZXIoeyBleHRyYUNsYXNzZXM6ICdEYXRlUGlja2VyLS10YWdnZWQnIH0pO1xuICAgIHRoaXMudGFnQXZhaWxhYmlsaXR5ID0gZGF0ZXBpY2tlckF2YWlsYWJpbGl0eS5jcmVhdGUoYXBwLCAkZGF0ZVBpY2tlciwgdGhpcy5pc0xvYWRpbmcpO1xuICAgIFxuICAgICRkYXRlUGlja2VyLm9uKCdkYXRlQ2hhbmdlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUudmlld01vZGUgPT09ICdkYXlzJykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUoZS5kYXRlKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAvLyBBdXRvIGJpbmQgZGF0ZSBkYXRhIG9uIHNlbGVjdGVkIGRhdGUgY2hhbmdlOlxuICAgIHRoaXMuc2VsZWN0ZWREYXRlLnN1YnNjcmliZShmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHRoaXMuYmluZERhdGVEYXRhKGRhdGUpO1xuICAgICAgICB2YXIgZWxEYXRlID0gJGRhdGVQaWNrZXIuZGF0ZXBpY2tlcignZ2V0VmFsdWUnKTtcbiAgICAgICAgaWYgKGVsRGF0ZSAhPT0gZGF0ZSlcbiAgICAgICAgICAgICRkYXRlUGlja2VyLmRhdGVwaWNrZXIoJ3NldFZhbHVlJywgZGF0ZSwgdHJ1ZSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICBcbiAgICAvLyBPbiBTZXR0aW5nIHRoZSBkYXRhLCB3ZSBuZWVkIHRvIHJlZnJlc2ggdGFncyxcbiAgICAvLyBhbmQgb24gY2hhbmdlIHVzZXJJRC4gVGhpcyBydW5zIHRvbyB0aGUgZmlyc3QgdGltZVxuICAgIC8vIHVwZGF0ZS5cbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZUF2YWlsKCkgJiYgdGhpcy51c2VySUQoKSkge1xuICAgICAgICAgICAgLy8gT25jZSBmaW5pc2hlZCwgbG9hZCB0aGUgd2hvbGUgbW9udGhcbiAgICAgICAgICAgIHRoaXMudGFnQXZhaWxhYmlsaXR5KHRoaXMuc2VsZWN0ZWREYXRlKCksIHRoaXMudXNlcklEKCkpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcylcbiAgICAuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDYwIH0gfSk7XG4gICAgXG4gICAgLy8gRm9yY2UgZmlyc3QgcmVmcmVzaCBvbiBkYXRlcGlja2VyIHRvIGFsbG93XG4gICAgLy8gZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIG9uIGZpcnN0IHRpbWU6XG4gICAgJGRhdGVQaWNrZXIuZGF0ZXBpY2tlcignZmlsbCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGV0aW1lUGlja2VyVk07XG4iLCIvKipcbiAgICBTaW1wbGUgVmlldyBNb2RlbCB3aXRoIG1haW4gY3JlZGVudGlhbHMgZm9yXG4gICAgdXNlIGluIGEgZm9ybSwgd2l0aCB2YWxpZGF0aW9uLlxuICAgIFVzZWQgYnkgTG9naW4gYW5kIFNpZ251cCBhY3Rpdml0aWVzXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcblxuZnVuY3Rpb24gRm9ybUNyZWRlbnRpYWxzKCkge1xuXG4gICAgdGhpcy51c2VybmFtZSA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIHRoaXMucGFzc3dvcmQgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICBcbiAgICAvLyB2YWxpZGF0ZSB1c2VybmFtZSBhcyBhbiBlbWFpbFxuICAgIHZhciBlbWFpbFJlZ2V4cCA9IC9eWy0wLTlBLVphLXohIyQlJicqKy89P15fYHt8fX4uXStAWy0wLTlBLVphLXohIyQlJicqKy89P15fYHt8fX4uXSskLztcbiAgICB0aGlzLnVzZXJuYW1lLmVycm9yID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gICAgdGhpcy51c2VybmFtZS5zdWJzY3JpYmUoZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgaWYgKGVtYWlsUmVnZXhwLnRlc3QodikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJuYW1lLmVycm9yKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlcm5hbWUuZXJyb3IoJ0lzIG5vdCBhIHZhbGlkIGVtYWlsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJuYW1lLmVycm9yKCdSZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICBcbiAgICAvLyByZXF1aXJlZCBwYXNzd29yZFxuICAgIHRoaXMucGFzc3dvcmQuZXJyb3IgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICB0aGlzLnBhc3N3b3JkLnN1YnNjcmliZShmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBlcnIgPSAnJztcbiAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgZXJyID0gJ1JlcXVpcmVkJztcbiAgICAgICAgXG4gICAgICAgIHRoaXMucGFzc3dvcmQuZXJyb3IoZXJyKTtcbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1DcmVkZW50aWFscztcbiIsIi8qKiBOYXZBY3Rpb24gdmlldyBtb2RlbC5cbiAgICBJdCBhbGxvd3Mgc2V0LXVwIHBlciBhY3Rpdml0eSBmb3IgdGhlIEFwcE5hdiBhY3Rpb24gYnV0dG9uLlxuKiovXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvTW9kZWwnKTtcblxuZnVuY3Rpb24gTmF2QWN0aW9uKHZhbHVlcykge1xuICAgIFxuICAgIE1vZGVsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMubW9kZWwuZGVmUHJvcGVydGllcyh7XG4gICAgICAgIGxpbms6ICcnLFxuICAgICAgICBpY29uOiAnJyxcbiAgICAgICAgdGV4dDogJycsXG4gICAgICAgIC8vICdUZXN0JyBpcyB0aGUgaGVhZGVyIHRpdGxlIGJ1dCBwbGFjZWQgaW4gdGhlIGJ1dHRvbi9hY3Rpb25cbiAgICAgICAgaXNUaXRsZTogZmFsc2UsXG4gICAgICAgIC8vICdMaW5rJyBpcyB0aGUgZWxlbWVudCBJRCBvZiBhIG1vZGFsIChzdGFydHMgd2l0aCBhICMpXG4gICAgICAgIGlzTW9kYWw6IGZhbHNlLFxuICAgICAgICAvLyAnTGluaycgaXMgYSBTaGVsbCBjb21tYW5kLCBsaWtlICdnb0JhY2sgMidcbiAgICAgICAgaXNTaGVsbDogZmFsc2UsXG4gICAgICAgIC8vIFNldCBpZiB0aGUgZWxlbWVudCBpcyBhIG1lbnUgYnV0dG9uLCBpbiB0aGF0IGNhc2UgJ2xpbmsnXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIElEIG9mIHRoZSBtZW51IChjb250YWluZWQgaW4gdGhlIHBhZ2U7IHdpdGhvdXQgdGhlIGhhc2gpLCB1c2luZ1xuICAgICAgICAvLyB0aGUgdGV4dCBhbmQgaWNvbiBidXQgc3BlY2lhbCBtZWFuaW5nIGZvciB0aGUgdGV4dCB2YWx1ZSAnbWVudSdcbiAgICAgICAgLy8gb24gaWNvbiBwcm9wZXJ0eSB0aGF0IHdpbGwgdXNlIHRoZSBzdGFuZGFyZCBtZW51IGljb24uXG4gICAgICAgIGlzTWVudTogZmFsc2UsXG4gICAgICAgIC8vIEN1c3RvbSBmdW5jdGlvbiBhcyBldmVudCBoYW5kbGVyIGZvciBidXR0b24gY2xpY2suXG4gICAgICAgIC8vIFRoZSBzdGFuZGFyZCBsaW5rIGdldHMgZGlzYWJsZWQgd2l0aCB0aGlzXG4gICAgICAgIGhhbmRsZXI6IG51bGxcbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMucnVuSGFuZGxlciA9IGZ1bmN0aW9uIHJ1bkhhbmRsZXIob2JqLCBldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcigpO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCBvYmopO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdkFjdGlvbjtcblxuLy8gU2V0IG9mIHZpZXcgdXRpbGl0aWVzIHRvIGdldCB0aGUgbGluayBmb3IgdGhlIGV4cGVjdGVkIGh0bWwgYXR0cmlidXRlc1xuXG5OYXZBY3Rpb24ucHJvdG90eXBlLmdldEhyZWYgPSBmdW5jdGlvbiBnZXRIcmVmKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgICh0aGlzLmhhbmRsZXIoKSB8fCB0aGlzLmlzTWVudSgpIHx8IHRoaXMuaXNNb2RhbCgpIHx8IHRoaXMuaXNTaGVsbCgpKSA/XG4gICAgICAgICcjJyA6XG4gICAgICAgIHRoaXMubGluaygpXG4gICAgKTtcbn07XG5cbk5hdkFjdGlvbi5wcm90b3R5cGUuZ2V0TW9kYWxUYXJnZXQgPSBmdW5jdGlvbiBnZXRNb2RhbFRhcmdldCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5oYW5kbGVyKCkgfHwgdGhpcy5pc01lbnUoKSB8fCAhdGhpcy5pc01vZGFsKCkgfHwgdGhpcy5pc1NoZWxsKCkpID9cbiAgICAgICAgJycgOlxuICAgICAgICB0aGlzLmxpbmsoKVxuICAgICk7XG59O1xuXG5OYXZBY3Rpb24ucHJvdG90eXBlLmdldFNoZWxsQ29tbWFuZCA9IGZ1bmN0aW9uIGdldFNoZWxsQ29tbWFuZCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5oYW5kbGVyKCkgfHwgdGhpcy5pc01lbnUoKSB8fCAhdGhpcy5pc1NoZWxsKCkpID9cbiAgICAgICAgJycgOlxuICAgICAgICB0aGlzLmxpbmsoKVxuICAgICk7XG59O1xuXG5OYXZBY3Rpb24ucHJvdG90eXBlLmdldE1lbnVJRCA9IGZ1bmN0aW9uIGdldE1lbnVJRCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5oYW5kbGVyKCkgfHwgIXRoaXMuaXNNZW51KCkpID9cbiAgICAgICAgJycgOlxuICAgICAgICB0aGlzLmxpbmsoKVxuICAgICk7XG59O1xuXG5OYXZBY3Rpb24ucHJvdG90eXBlLmdldE1lbnVMaW5rID0gZnVuY3Rpb24gZ2V0TWVudUxpbmsoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKHRoaXMuaGFuZGxlcigpIHx8ICF0aGlzLmlzTWVudSgpKSA/XG4gICAgICAgICcnIDpcbiAgICAgICAgJyMnICsgdGhpcy5saW5rKClcbiAgICApO1xufTtcblxuLyoqIFN0YXRpYywgc2hhcmVkIGFjdGlvbnMgKiovXG5OYXZBY3Rpb24uZ29Ib21lID0gbmV3IE5hdkFjdGlvbih7XG4gICAgbGluazogJy8nLFxuICAgIGljb246ICdmYSBpb24gaW9uLXN0YXRzLWJhcnMnXG59KTtcblxuTmF2QWN0aW9uLmdvQmFjayA9IG5ldyBOYXZBY3Rpb24oe1xuICAgIGxpbms6ICdnb0JhY2snLFxuICAgIGljb246ICdmYSBpb24gaW9uLWlvcy1hcnJvdy1sZWZ0JyxcbiAgICBpc1NoZWxsOiB0cnVlXG59KTtcblxuTmF2QWN0aW9uLm1lbnVJbiA9IG5ldyBOYXZBY3Rpb24oe1xuICAgIGxpbms6ICdtZW51SW4nLFxuICAgIGljb246ICdtZW51JyxcbiAgICBpc01lbnU6IHRydWVcbn0pO1xuXG5OYXZBY3Rpb24ubWVudU91dCA9IG5ldyBOYXZBY3Rpb24oe1xuICAgIGxpbms6ICdtZW51T3V0JyxcbiAgICBpY29uOiAnbWVudScsXG4gICAgaXNNZW51OiB0cnVlXG59KTtcblxuTmF2QWN0aW9uLm1lbnVOZXdJdGVtID0gbmV3IE5hdkFjdGlvbih7XG4gICAgbGluazogJ21lbnVOZXdJdGVtJyxcbiAgICBpY29uOiAnZmEgaW9uIGlvbi1pb3MtcGx1cy1lbXB0eScsXG4gICAgaXNNZW51OiB0cnVlXG59KTtcblxuTmF2QWN0aW9uLmdvSGVscEluZGV4ID0gbmV3IE5hdkFjdGlvbih7XG4gICAgbGluazogJy9jb250YWN0Rm9ybS9nZW5lcmFsP211c3RSZXR1cm49dHJ1ZScsXG4gICAgdGV4dDogJ2hlbHAnLFxuICAgIGlzTW9kYWw6IGZhbHNlXG59KTtcblxuTmF2QWN0aW9uLmdvTG9naW4gPSBuZXcgTmF2QWN0aW9uKHtcbiAgICBsaW5rOiAnL2xvZ2luJyxcbiAgICB0ZXh0OiAnbG9nLWluJ1xufSk7XG5cbk5hdkFjdGlvbi5nb0xvZ291dCA9IG5ldyBOYXZBY3Rpb24oe1xuICAgIGxpbms6ICcvbG9nb3V0JyxcbiAgICB0ZXh0OiAnbG9nLW91dCdcbn0pO1xuXG5OYXZBY3Rpb24uZ29TaWdudXAgPSBuZXcgTmF2QWN0aW9uKHtcbiAgICBsaW5rOiAnL3NpZ251cCcsXG4gICAgdGV4dDogJ3NpZ24tdXAnXG59KTtcbiIsIi8qKiBOYXZCYXIgdmlldyBtb2RlbC5cbiAgICBJdCBhbGxvd3MgY3VzdG9taXplIHRoZSBOYXZCYXIgcGVyIGFjdGl2aXR5LlxuKiovXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvTW9kZWwnKSxcbiAgICBOYXZBY3Rpb24gPSByZXF1aXJlKCcuL05hdkFjdGlvbicpO1xuXG5mdW5jdGlvbiBOYXZCYXIodmFsdWVzKSB7XG4gICAgXG4gICAgTW9kZWwodGhpcyk7XG4gICAgXG4gICAgdGhpcy5tb2RlbC5kZWZQcm9wZXJ0aWVzKHtcbiAgICAgICAgLy8gVGl0bGUgc2hvd2VkIGluIHRoZSBjZW50ZXJcbiAgICAgICAgLy8gV2hlbiB0aGUgdGl0bGUgaXMgJ251bGwnLCB0aGUgYXBwIGxvZ28gaXMgc2hvd2VkIGluIHBsYWNlLFxuICAgICAgICAvLyBvbiBlbXB0eSB0ZXh0LCB0aGUgZW1wdHkgdGV4dCBpcyBzaG93ZWQgYW5kIG5vIGxvZ28uXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgbGVmdEFjdGlvbjoge1xuICAgICAgICAgICAgTW9kZWw6IE5hdkFjdGlvblxuICAgICAgICB9LFxuICAgICAgICByaWdodEFjdGlvbjoge1xuICAgICAgICAgICAgTW9kZWw6IE5hdkFjdGlvblxuICAgICAgICB9LFxuICAgICAgICBoaWRkZW46IGZhbHNlXG4gICAgfSwgdmFsdWVzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOYXZCYXI7XG4iLCIvKiogT25ib2FyZGluZ1Byb2dyZXNzIHZpZXcgbW9kZWwuXG4gICAgSXQgdHJhY2tzIHRoZSBvbmJvYXJkaW5nIGluZm9ybWF0aW9uIGFuZCBtZXRob2RzXG4gICAgdG8gdXBkYXRlIHZpZXdzIHRvIHRoYXQgc3RhdGVcbioqL1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL01vZGVsJyksXG4gICAga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG5mdW5jdGlvbiBPbmJvYXJkaW5nUHJvZ3Jlc3ModmFsdWVzKSB7XG5cbiAgICBNb2RlbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLm1vZGVsLmRlZlByb3BlcnRpZXMoe1xuICAgICAgICBncm91cDogJycsXG4gICAgICAgIHN0ZXBOdW1iZXI6IC0xLFxuICAgICAgICBzdGVwczogW11cbiAgICB9LCB2YWx1ZXMpO1xuICAgIFxuICAgIHRoaXMudG90YWxTdGVwcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gJ1plcm8nIHN0ZXAgaXMgYSB3ZWxjb21lLCBub3QgYWNjb3VudGVkOlxuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcygpLmxlbmd0aCAtIDE7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5zdGVwTmFtZSA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bSA9IHRoaXMuc3RlcE51bWJlcigpLFxuICAgICAgICAgICAgdG90ID0gdGhpcy5zdGVwcygpLmxlbmd0aDtcblxuICAgICAgICBpZiAodG90ID4gMCAmJlxuICAgICAgICAgICAgbnVtID4gLTEgJiZcbiAgICAgICAgICAgIG51bSA8IHRvdCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnN0ZXBzKClbbnVtXSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLnN0ZXBVcmwgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnN0ZXBOYW1lKCk7XG4gICAgICAgIGlmICh1cmwgJiYgIS9eXFwvLy50ZXN0KHVybCkpXG4gICAgICAgICAgICB1cmwgPSAnLycgKyB1cmw7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLnN0ZXBSZWZlcmVuY2UgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwKCkgKyAnOicgKyB0aGlzLnN0ZXBOYW1lKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5wcm9ncmVzc1RleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE8gTDE4TlxuICAgICAgICByZXR1cm4gdGhpcy5zdGVwTnVtYmVyKCkgKyAnIG9mICcgKyB0aGlzLnRvdGFsU3RlcHMoKTtcbiAgICB9LCB0aGlzKTtcbiAgICBcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3RlcFVybCgpO1xuICAgIH0sIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9uYm9hcmRpbmdQcm9ncmVzcztcblxuT25ib2FyZGluZ1Byb2dyZXNzLnByb3RvdHlwZS5zZXRTdGVwQnlOYW1lID0gZnVuY3Rpb24gc2V0U3RlcEJ5TmFtZShuYW1lKSB7XG4gICAgdmFyIHN0ZXBJbmRleCA9IHRoaXMuc3RlcHMoKS5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChzdGVwSW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnN0ZXBOdW1iZXIoc3RlcEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICAgIFN0YXRpYyBsaXN0IG9mIGFsbCB0aGUgc3RlcHMgZ3JvdXBzIGZvciB0aGUgYXBwXG4qKi9cbk9uYm9hcmRpbmdQcm9ncmVzcy5wcmVkZWZpbmVkU3RlcEdyb3VwcyA9IHtcbiAgICAvLyBTY2hlZHVsaW5nIG9uYm9hcmRpbmcsIGFrYSB3ZWxjb21lXG4gICAgd2VsY29tZTogW1xuICAgICAgICAnd2VsY29tZScsXG4gICAgICAgICdhZGRKb2JUaXRsZXMnLFxuICAgICAgICAvLyBkaXNhYmxlZCBvbiAyMDE1LTA2LTE2IGFzIG9mICM1NzUgY29tbWVudHNcbiAgICAgICAgLy8nc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2UnLFxuICAgICAgICAvLydzZXJ2aWNlQWRkcmVzc2VzJyxcbiAgICAgICAgJ3dlZWtseVNjaGVkdWxlJyxcbiAgICAgICAgJ2NvbnRhY3RJbmZvJ1xuICAgIF0sXG4gICAgbWFya2V0cGxhY2U6IFtcbiAgICBdLFxuICAgIHBheW1lbnQ6IFtcbiAgICBdXG59O1xuIiwiLyoqXG4gICAgU2VydmljZUFkZHJlc3Nlc1ZpZXdNb2RlbFxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbmZ1bmN0aW9uIFNlcnZpY2VBZGRyZXNzZXNWaWV3TW9kZWwoKSB7XG4gICAgXG4gICAgLy8gRXNwZWNpYWwgbW9kZSB3aGVuIGluc3RlYWQgb2YgcGljayBhbmQgZWRpdCB3ZSBhcmUganVzdCBzZWxlY3RpbmdcbiAgICAvLyAod2hlbiBlZGl0aW5nIGFuIGFwcG9pbnRtZW50KVxuICAgIHRoaXMuaXNTZWxlY3Rpb25Nb2RlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cbiAgICB0aGlzLnNvdXJjZUFkZHJlc3NlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgdGhpcy5hZGRyZXNzZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnNvdXJjZUFkZHJlc3NlcygpO1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHNlcnZpY2UgYWRkcmVzc2VzIChleGNsdWRpbmcgc2VydmljZSBhcmVhKVxuICAgICAgICAgICAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uKGFkZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGQuaXNTZXJ2aWNlTG9jYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0ga28ub2JzZXJ2YWJsZShudWxsKTtcblxuICAgIHRoaXMuc2VsZWN0QWRkcmVzcyA9IGZ1bmN0aW9uKHNlbGVjdGVkQWRkcmVzcywgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHRoaXMub2JzZXJ2ZXJTZWxlY3RlZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIHRoaXMuc2VsZWN0ZWRBZGRyZXNzKCkgPT09IGl0ZW07XG4gICAgICAgICAgICB2YXIgc2lkID0gdGhpcy5zZWxlY3RlZEFkZHJlc3MoKSAmJiBrby51bndyYXAodGhpcy5zZWxlY3RlZEFkZHJlc3MoKS5hZGRyZXNzSUQpLFxuICAgICAgICAgICAgICAgIGlpZCA9IGl0ZW0gJiYga28udW53cmFwKGl0ZW0uYWRkcmVzc0lEKTtcbiAgICAgICAgICAgIHJldHVybiBzaWQgPT09IGlpZDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2VBZGRyZXNzZXNWaWV3TW9kZWw7XG4iLCIvKipcbiAgICBTZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZVZpZXdNb2RlbFxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0JyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuZnVuY3Rpb24gU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VWaWV3TW9kZWwoYXBwKSB7XG5cbiAgICB0aGlzLmlzTG9hZGluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMubGlzdCA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgdGhpcy5qb2JUaXRsZUlEID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgICAvLyAwIHRvIGxvYWQgY3VycmVudCB1c2VyIHByaWNpbmcgYW5kIGFsbG93IGVkaXRcbiAgICB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxJRCA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5qb2JUaXRsZSA9IGtvLm9ic2VydmFibGUobnVsbCk7XG4gICAgdGhpcy5pc0FkZGl0aW9uTW9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIC8vIEVzcGVjaWFsIG1vZGUgd2hlbiBpbnN0ZWFkIG9mIHBpY2sgYW5kIGVkaXQgd2UgYXJlIGp1c3Qgc2VsZWN0aW5nXG4gICAgdGhpcy5pc1NlbGVjdGlvbk1vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICAvLyBDdXJyZW50bHkgc2VsZWN0ZWQgcHJpY2luZ1xuICAgIHRoaXMuc2VsZWN0ZWRTZXJ2aWNlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgLy8gUHJlc2V0IHNlbGVjdGlvbiwgZnJvbSBhIHByZXZpb3VzIHN0YXRlIChsb2FkZWQgZGF0YSkgb3IgaW5jb21pbmcgc2VsZWN0aW9uOlxuICAgIHRoaXMucHJlU2VsZWN0ZWRTZXJ2aWNlcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgLy8gQWRkIGFjdGl2aXR5IHJlcXVlc3REYXRhIHRvIGtlZXAgcHJvZ3Jlc3MvbmF2aWdhdGlvbiBvbiBsaW5rc1xuICAgIHRoaXMucmVxdWVzdERhdGEgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5jYW5jZWxMaW5rID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICBcbiAgICB0aGlzLmFsbG93QWRkU2VydmljZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VQcm9mZXNzaW9uYWxJRCgpID09PSBudWxsO1xuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIC8vIEdyb3VwZWQgbGlzdCBvZiBwcmljaW5nczpcbiAgICAvLyBEZWZpbmVkIGdyb3VwcyBieSBwcmljaW5nIHR5cGVcbiAgICB0aGlzLmdyb3VwZWRTZXJ2aWNlcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmxpc3QoKTtcbiAgICAgICAgdmFyIGlzU2VsZWN0aW9uID0gdGhpcy5pc1NlbGVjdGlvbk1vZGUoKTtcbiAgICAgICAgdmFyIGdyb3VwTmFtZVByZWZpeCA9IGlzU2VsZWN0aW9uID8gJ1NlbGVjdCAnIDogJyc7XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdLFxuICAgICAgICAgICAgZ3JvdXBzTGlzdCA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMuaXNBZGRpdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgZ3JvdXBzID0gXy5ncm91cEJ5KGxpc3QsIGZ1bmN0aW9uKHNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmljZS5wcmljaW5nVHlwZUlEKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgaW5kZXhlZCBvYmplY3QgaW50byBhbiBhcnJheSB3aXRoIHNvbWUgbWV0YS1kYXRhXG4gICAgICAgICAgICBncm91cHNMaXN0ID0gT2JqZWN0LmtleXMoZ3JvdXBzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlczogZ3JvdXBzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIHByaWNpbmcgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRPYnNlcnZhYmxlSXRlbShrZXkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBnci5ncm91cCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBOYW1lUHJlZml4ICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlKCkgJiYgdGhpcy50eXBlKCkucGx1cmFsTmFtZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VydmljZXMnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgZ3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBncjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBncm91cHNMaXN0IGlzIGJ1aWx0IGZyb20gdGhlIGV4aXN0ZW50IHByaWNpbmcgaXRlbXNcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyByZWNvcmRzIGZvciBzb21lIHByaWNpbmcgdHlwZSAob3Igbm90aGluZyB3aGVuXG4gICAgICAgICAgICAvLyBqdXN0IGNyZWF0ZWQgdGhlIGpvYiB0aXRsZSksIHRoYXQgdHlwZXMvZ3JvdXBzIGFyZSBub3QgaW5jbHVkZWQsXG4gICAgICAgICAgICAvLyBzbyByZXZpZXcgYW5kIGluY2x1ZGUgbm93LlxuICAgICAgICAgICAgLy8gTk9URTogYXMgYSBnb29kIHNpZGUgZWZmZWN0IG9mIHRoaXMgYXBwcm9hY2gsIHByaWNpbmcgdHlwZXMgd2l0aFxuICAgICAgICAgICAgLy8gc29tZSBwcmljaW5nIHdpbGwgYXBwZWFyIGZpcnN0IGluIHRoZSBsaXN0IChuZWFyZXN0IHRvIHRoZSB0b3ApXG4gICAgICAgICAgICB2YXIgcHJpY2luZ1R5cGVzID0gdGhpcy5qb2JUaXRsZSgpICYmIHRoaXMuam9iVGl0bGUoKS5wcmljaW5nVHlwZXMoKTtcbiAgICAgICAgICAgIGlmIChwcmljaW5nVHlwZXMgJiYgcHJpY2luZ1R5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByaWNpbmdUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChqb2JUeXBlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVJRCA9IGpvYlR5cGUucHJpY2luZ1R5cGVJRCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaWYgYWxyZWFkeSBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzLmhhc093blByb3BlcnR5KHR5cGVJRCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmljZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXBwLm1vZGVsLnByaWNpbmdUeXBlcy5nZXRPYnNlcnZhYmxlSXRlbSh0eXBlSUQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGdyLmdyb3VwID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBOYW1lUHJlZml4ICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSgpICYmIHRoaXMudHlwZSgpLnBsdXJhbE5hbWUoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTZXJ2aWNlcydcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGdyKTtcblxuICAgICAgICAgICAgICAgICAgICBncm91cHNMaXN0LnB1c2goZ3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyb3Vwc0xpc3Q7XG5cbiAgICB9LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAgICBUb2dnbGUgdGhlIHNlbGVjdGlvbiBzdGF0dXMgb2YgYSBzaW5nbGUgcHJpY2luZywgYWRkaW5nXG4gICAgICAgIG9yIHJlbW92aW5nIGl0IGZyb20gdGhlICdzZWxlY3RlZFNlcnZpY2VzJyBhcnJheS5cbiAgICAqKi9cbiAgICB0aGlzLnRvZ2dsZVNlcnZpY2VTZWxlY3Rpb24gPSBmdW5jdGlvbihzZXJ2aWNlKSB7XG5cbiAgICAgICAgdmFyIGluSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkU2VydmljZXMoKS5zb21lKGZ1bmN0aW9uKHNlbGVjdGVkU2VydmljZXMsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRTZXJ2aWNlcyA9PT0gc2VydmljZSkge1xuICAgICAgICAgICAgICAgIGluSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VydmljZS5pc1NlbGVjdGVkKCFpc1NlbGVjdGVkKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTZXJ2aWNlcy5zcGxpY2UoaW5JbmRleCwgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTZXJ2aWNlcy5wdXNoKHNlcnZpY2UpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmVkaXRTZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSkge1xuICAgICAgICBhcHAuc2hlbGwuZ28oJ3NlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlRWRpdG9yLycgKyB0aGlzLmpvYlRpdGxlSUQoKSArICcvJyArIHNlcnZpY2Uuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCgpKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgXG4gICAgLyoqXG4gICAgICAgIEhhbmRsZXIgZm9yIHRoZSBsaXN0dmlldyBpdGVtcywgbWFuYWdpbmcgZWRpdGlvbiBhbmQgc2VsZWN0aW9uIGRlcGVuZGluZyBvbiBjdXJyZW50IG1vZGVcbiAgICAqKi9cbiAgICB0aGlzLnRhcFNlcnZpY2UgPSBmdW5jdGlvbihzZXJ2aWNlLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVTZXJ2aWNlU2VsZWN0aW9uKHNlcnZpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGl0U2VydmljZShzZXJ2aWNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnRhcE5ld1NlcnZpY2UgPSBmdW5jdGlvbihncm91cCwgZXZlbnQpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciB1cmwgPSAnIyFzZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUVkaXRvci8nICsgdGhpcy5qb2JUaXRsZUlEKCkgKyAnL25ldy8nICsgKGdyb3VwLnR5cGUoKSAmJiBncm91cC50eXBlKCkucHJpY2luZ1R5cGVJRCgpKTtcblxuICAgICAgICAvLyBQYXNzaW5nIG9yaWdpbmFsIGRhdGEsIGZvciBpbi1wcm9ncmVzcyBwcm9jZXNzIChhcyBuZXctYm9va2luZylcbiAgICAgICAgLy8gYW5kIHRoZSBzZWxlY3RlZCB0aXRsZSBzaW5jZSB0aGUgVVJMIGNvdWxkIG5vdCBiZSB1cGRhdGVkIHByb3Blcmx5XG4gICAgICAgIC8vIChzZWUgdGhlIGFub3RhdGVkIGNvbW1lbnQgYWJvdXQgcmVwbGFjZVN0YXRlIGJ1ZyBvbiB0aGlzIGZpbGUpXG4gICAgICAgIHZhciByZXF1ZXN0ID0gJC5leHRlbmQoe30sIHRoaXMucmVxdWVzdERhdGEoKSwge1xuICAgICAgICAgICAgc2VsZWN0ZWRKb2JUaXRsZUlEOiB0aGlzLmpvYlRpdGxlSUQoKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNhbmNlbExpbmspIHtcbiAgICAgICAgICAgICQuZXh0ZW5kKHJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxMaW5rOiB0aGlzLmNhbmNlbExpbmsoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gaW4gc2VsZWN0aW9uIG1vZGU6XG4gICAgICAgIC8vIEFkZCBjdXJyZW50IHNlbGVjdGlvbiBhcyBwcmVzZWxlY3Rpb24sIHNvIGNhbiBiZSByZWNvdmVyZWQgbGF0ZXIgYW5kIFxuICAgICAgICAvLyB0aGUgZWRpdG9yIGNhbiBhZGQgdGhlIG5ldyBwcmljaW5nIHRvIHRoZSBsaXN0XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNlbGVjdGVkU2VydmljZXMgPSB0aGlzLnNlbGVjdGVkU2VydmljZXMoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwcmljaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRDoga28udW53cmFwKHByaWNpbmcuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCksXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUHJpY2U6IGtvLnVud3JhcChwcmljaW5nLnRvdGFsUHJpY2UpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwLnNoZWxsLmdvKHVybCwgcmVxdWVzdCk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIHZhciBsb2FkRGF0YUZvciA9IGZ1bmN0aW9uIGxvYWREYXRhRm9yKHNlcnZpY2VQcm9mZXNzaW9uYWxJRCwgam9iVGl0bGVJRCkge1xuICAgICAgICBpZiAoam9iVGl0bGVJRCkge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICAvLyBHZXQgZGF0YSBmb3IgdGhlIEpvYiB0aXRsZSBJRCBhbmQgcHJpY2luZyB0eXBlcy5cbiAgICAgICAgICAgIC8vIFRoZXkgYXJlIGVzc2VudGlhbCBkYXRhXG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgYXBwLm1vZGVsLmpvYlRpdGxlcy5nZXRKb2JUaXRsZShqb2JUaXRsZUlEKSxcbiAgICAgICAgICAgICAgICBhcHAubW9kZWwucHJpY2luZ1R5cGVzLmdldExpc3QoKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgam9iVGl0bGUgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgZm9yIHVzZSBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgIHRoaXMuam9iVGl0bGUoam9iVGl0bGUpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBzZXJ2aWNlc1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlUHJvZmVzc2lvbmFsSUQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHAubW9kZWwudXNlcnMuZ2V0U2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VzKHNlcnZpY2VQcm9mZXNzaW9uYWxJRCwgam9iVGl0bGVJRCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwLm1vZGVsLnNlcnZpY2VQcm9mZXNzaW9uYWxTZXJ2aWNlcy5nZXRMaXN0KGpvYlRpdGxlSUQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obGlzdCkge1xuXG4gICAgICAgICAgICAgICAgbGlzdCA9IGFwcC5tb2RlbC5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZXMuYXNNb2RlbChsaXN0KTtcblxuICAgICAgICAgICAgICAgIC8vIFJlYWQgcHJlc2V0cyBzZWxlY3Rpb24gZnJvbSByZXF1ZXN0RGF0YVxuICAgICAgICAgICAgICAgIHZhciBwcmVzZXQgPSB0aGlzLnByZVNlbGVjdGVkU2VydmljZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3RlZFNlcnZpY2VzO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBpc1NlbGVjdGVkIHByb3BlcnR5IHRvIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVTZWxlY3RlZCA9IHByZXNldC5zb21lKGZ1bmN0aW9uKHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHIuc2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VJRCA9PT0gaXRlbS5zZXJ2aWNlUHJvZmVzc2lvbmFsU2VydmljZUlEKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaXNTZWxlY3RlZCA9IGtvLm9ic2VydmFibGUocHJlU2VsZWN0ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3QobGlzdCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xuXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhcHAubW9kYWxzLnNob3dFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGlzdChbXSk7XG4gICAgICAgICAgICB0aGlzLmpvYlRpdGxlKG51bGwpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gQVVUTyBMT0FEIG9uIGpvYiB0aXRsZSBjaGFuZ2VcbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZERhdGFGb3IodGhpcy5zZXJ2aWNlUHJvZmVzc2lvbmFsSUQoKSwgdGhpcy5qb2JUaXRsZUlEKCkpO1xuICAgIH0uYmluZCh0aGlzKSkuZXh0ZW5kKHsgcmF0ZUxpbWl0OiB7IG1ldGhvZDogJ25vdGlmeVdoZW5DaGFuZ2VzU3RvcCcsIHRpbWVvdXQ6IDIwIH0gfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmljZVByb2Zlc3Npb25hbFNlcnZpY2VWaWV3TW9kZWw7XG4iLCIvKipcbiAgICBWaWV3IG1vZGVsIGZvciB0aGUgc2lnbnVwIGZvcm0vY29udGFpbmVyLFxuICAgIHNoYXJlZCBhY3Jvc3MgYWN0aXZpdHkgYW5kIGNsaWVudCBib29raW5nLlxuKiovXG4ndXNlIHN0cmljdCc7XG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLy92YXIgRm9ybUNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi4vdmlld21vZGVscy9Gb3JtQ3JlZGVudGlhbHMnKTtcbnZhciBuZXdGaWVsZE9icyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYnMgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICBvYnMuZXJyb3IgPSBrby5vYnNlcnZhYmxlKCcnKTtcbiAgICAvLyBSZXNldCBlcnJvciBhZnRlciBhIGNoYW5nZTpcbiAgICBvYnMuc3Vic2NyaWJlKGZ1bmN0aW9uKCkge1xuICAgICAgICBvYnMuZXJyb3IoJycpO1xuICAgIH0pO1xuICAgIHJldHVybiBvYnM7XG59O1xuXG5mdW5jdGlvbiBTaWdudXBWTShhcHApIHtcbiAgICBcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLmZpcnN0TmFtZSA9IG5ld0ZpZWxkT2JzKCk7XG4gICAgdGhpcy5sYXN0TmFtZSA9IG5ld0ZpZWxkT2JzKCk7XG4gICAgdGhpcy5waG9uZSA9IG5ld0ZpZWxkT2JzKCk7XG4gICAgdGhpcy5wb3N0YWxDb2RlID0gbmV3RmllbGRPYnMoKTtcbiAgICB0aGlzLnJlZmVycmFsQ29kZSA9IG5ld0ZpZWxkT2JzKCk7XG4gICAgdGhpcy5kZXZpY2UgPSBuZXdGaWVsZE9icygpO1xuICAgIFxuICAgIHRoaXMuZmFjZWJvb2tVc2VySUQgPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5mYWNlYm9va0FjY2Vzc1Rva2VuID0ga28ub2JzZXJ2YWJsZSgpO1xuXG4gICAgLy92YXIgY3JlZGVudGlhbHMgPSBuZXcgRm9ybUNyZWRlbnRpYWxzKCk7ICAgIFxuICAgIC8vdGhpcy5lbWFpbCA9IGNyZWRlbnRpYWxzLnVzZXJuYW1lO1xuICAgIC8vdGhpcy5wYXNzd29yZCA9IGNyZWRlbnRpYWxzLnBhc3N3b3JkO1xuICAgIHRoaXMuZW1haWwgPSBuZXdGaWVsZE9icygpO1xuICAgIHRoaXMucGFzc3dvcmQgPSBuZXdGaWVsZE9icygpO1xuXG4gICAgdGhpcy5zaWdudXBFcnJvciA9IGtvLm9ic2VydmFibGUoJycpO1xuICAgIFxuICAgIHRoaXMuaXNTaWduaW5nVXAgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzU2lnbmluZ1VwKCkgPyAnU2lnbmluZyB1cC4uLicgOlxuICAgICAgICAgICAgdGhpcy5mYWNlYm9va1VzZXJJRCgpID8gJ1NpZ24gdXAgd2l0aCBGYWNlYm9vaycgOlxuICAgICAgICAgICAgJ1NpZ24gdXAnXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5wZXJmb3JtU2lnbnVwID0gZnVuY3Rpb24gcGVyZm9ybVNpZ251cCgpIHtcblxuICAgICAgICB0aGlzLmlzU2lnbmluZ1VwKHRydWUpO1xuXG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGVycm9yIHNvIG1ha2VzIGNsZWFyIHdlXG4gICAgICAgIC8vIGFyZSBhdHRlbXB0aW5nXG4gICAgICAgIHRoaXMuc2lnbnVwRXJyb3IoJycpO1xuXG4gICAgICAgIHZhciBlbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICAgICAgdGhpcy5pc1NpZ25pbmdVcChmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB2YXIgcGxhaW5EYXRhID0ge1xuICAgICAgICAgICAgZW1haWw6IHRoaXMuZW1haWwoKSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnBhc3N3b3JkKCksXG4gICAgICAgICAgICBmaXJzdE5hbWU6IHRoaXMuZmlyc3ROYW1lKCksXG4gICAgICAgICAgICBsYXN0TmFtZTogdGhpcy5sYXN0TmFtZSgpLFxuICAgICAgICAgICAgcGhvbmU6IHRoaXMucGhvbmUoKSxcbiAgICAgICAgICAgIHBvc3RhbENvZGU6IHRoaXMucG9zdGFsQ29kZSgpLFxuICAgICAgICAgICAgcmVmZXJyYWxDb2RlOiB0aGlzLnJlZmVycmFsQ29kZSgpLFxuICAgICAgICAgICAgZGV2aWNlOiB0aGlzLmRldmljZSgpLFxuICAgICAgICAgICAgZmFjZWJvb2tVc2VySUQ6IHRoaXMuZmFjZWJvb2tVc2VySUQoKSxcbiAgICAgICAgICAgIGZhY2Vib29rQWNjZXNzVG9rZW46IHRoaXMuZmFjZWJvb2tBY2Nlc3NUb2tlbigpLFxuICAgICAgICAgICAgcHJvZmlsZVR5cGU6IHRoaXMucHJvZmlsZSgpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhcHAubW9kZWwuc2lnbnVwKHBsYWluRGF0YSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2lnbnVwRGF0YSkge1xuXG4gICAgICAgICAgICB0aGlzLnNpZ251cEVycm9yKCcnKTtcbiAgICAgICAgICAgIGVuZGVkKCk7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG9uYm9hcmRpbmdcbiAgICAgICAgICAgIGlmIChhcHAubW9kZWwub25ib2FyZGluZylcbiAgICAgICAgICAgICAgICBhcHAubW9kZWwub25ib2FyZGluZy5zZXRTdGVwKHNpZ251cERhdGEub25ib2FyZGluZ1N0ZXApO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZm9ybSBkYXRhXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc2lnbmVkdXAnLCBzaWdudXBEYXRhKTtcblxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcblxuICAgICAgICAgICAgZXJyID0gZXJyICYmIGVyci5yZXNwb25zZUpTT047XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdmFsaWRhdGlvbiBlcnJvcnMsIHRhZ2dpbmcgZmllbGRzIG9yIGdlbmVyYWwgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmVycm9yU291cmNlID09PSAndmFsaWRhdGlvbicgJiYgZXJyLmVycm9ycykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVyci5lcnJvcnMpLmZvckVhY2goZnVuY3Rpb24oZmllbGRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbZmllbGRLZXldICYmIHRoaXNbZmllbGRLZXldLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkS2V5XS5lcnJvcihlcnIuZXJyb3JzW2ZpZWxkS2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGVyciAmJiBlcnIuZXJyb3JNZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgIGVyciAmJiBlcnIuc3RhdHVzVGV4dCB8fFxuICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCB1c2VybmFtZSBvciBwYXNzd29yZCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNpZ251cEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWFpbC5lcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbmRlZCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVc2UgZXZlbnQgdG8gY2F0Y2ggdXAgdGhlIGVycm9yLCBzaW5jZSB0aGUgcHJvbWlzZSBjYXRjaCBpdFxuICAgICAgICAgICAgLy8gc2luY2UgdGhpcyB3aWxsIGJlIHRyaWdnZXJlZCBieSBhIGJ1dHRvbiBhbmQgbmV2ZXIgd2lsbCBoYXZlIGNoYW5nZVxuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoZSBwcm9taXNlLCBzaG93aW5nIHVwIHVua25vdyBlcnJvcnMgaW4gY29uc29sZVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdzaWdudXBlcnJvcicsIGVycik7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIFxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMucHJvZmlsZSA9IGtvLm9ic2VydmFibGUoJycpOyAvLyBjbGllbnQsIHNlcnZpY2UtcHJvZmVzc2lvbmFsXG4gICAgdGhpcy5mb3JTZXJ2aWNlUHJvZmVzc2lvbmFsID0ga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9maWxlKCkgPT09ICdzZXJ2aWNlLXByb2Zlc3Npb25hbCc7XG4gICAgfSwgdGhpcyk7XG4gICAgXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpcnN0TmFtZSgnJyk7XG4gICAgICAgIHRoaXMubGFzdE5hbWUoJycpO1xuICAgICAgICB0aGlzLnBob25lKCcnKTtcbiAgICAgICAgdGhpcy5wb3N0YWxDb2RlKCcnKTtcbiAgICAgICAgdGhpcy5yZWZlcnJhbENvZGUoJycpO1xuICAgICAgICB0aGlzLmRldmljZSgnJyk7XG4gICAgICAgIHRoaXMuZmFjZWJvb2tVc2VySUQoJycpO1xuICAgICAgICB0aGlzLmZhY2Vib29rQWNjZXNzVG9rZW4oJycpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5mYWNlYm9vayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmIgPSByZXF1aXJlKCcuLi91dGlscy9mYWNlYm9va1V0aWxzJyk7XG4gICAgICAgIHZhciB2bSA9IHRoaXM7XG5cbiAgICAgICAgLy8gZW1haWwsdXNlcl9hYm91dF9tZVxuICAgICAgICBmYi5sb2dpbih7IHNjb3BlOiAnZW1haWwnIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGF1dGggPSByZXN1bHQuYXV0aCxcbiAgICAgICAgICAgICAgICBGQiA9IHJlc3VsdC5GQjtcbiAgICAgICAgICAgIC8vIFNldCBGYWNlYm9va0lkIHRvIGxpbmsgYWNjb3VudHM6XG4gICAgICAgICAgICB2bS5mYWNlYm9va1VzZXJJRChhdXRoLnVzZXJJRCk7XG4gICAgICAgICAgICB2bS5mYWNlYm9va0FjY2Vzc1Rva2VuKGF1dGguYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgLy8gUmVxdWVzdCBtb3JlIHVzZXIgZGF0YVxuICAgICAgICAgICAgRkIuYXBpKCcvbWUnLCBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICAgICAgICAgIC8vRmlsbCBEYXRhXG4gICAgICAgICAgICAgICAgdm0uZW1haWwodXNlci5lbWFpbCk7XG4gICAgICAgICAgICAgICAgdm0uZmlyc3ROYW1lKHVzZXIuZmlyc3RfbmFtZSk7XG4gICAgICAgICAgICAgICAgdm0ubGFzdE5hbWUodXNlci5sYXN0X25hbWUpO1xuICAgICAgICAgICAgICAgIC8vKHVzZXIuZ2VuZGVyKTtcbiAgICAgICAgICAgICAgICAvLyh1c2VyLmFib3V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5TaWdudXBWTS5faW5oZXJpdHMoRXZlbnRFbWl0dGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWdudXBWTTtcbiIsIi8qKlxuICAgIFRpbWVTbG90IHZpZXcgbW9kZWwgKGFrYTogQ2FsZW5kYXJTbG90KSBmb3IgdXNlXG4gICAgYXMgcGFydCBvZiB0aGUgdGVtcGxhdGUvY29tcG9uZW50IHRpbWUtc2xvdC10aWxlIG9yIGFjdGl2aXRpZXNcbiAgICBwcm92aWRpbmcgZGF0YSBmb3IgdGhlIHRlbXBsYXRlLlxuKiovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRPYnNlcnZhYmxlID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0T2JzZXJ2YWJsZScpO1xuXG5mdW5jdGlvbiBUaW1lU2xvdFZpZXdNb2RlbChwYXJhbXMpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OjkqL1xuXG4gICAgdGhpcy5zdGFydFRpbWUgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5zdGFydFRpbWUgfHwgbnVsbCk7XG4gICAgdGhpcy5lbmRUaW1lID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuZW5kVGltZSB8fCBudWxsKTtcbiAgICB0aGlzLnN1YmplY3QgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5zdWJqZWN0IHx8IG51bGwpO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5kZXNjcmlwdGlvbiB8fCBudWxsKTtcbiAgICB0aGlzLmxpbmsgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5saW5rIHx8IG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSWNvbiA9IGdldE9ic2VydmFibGUocGFyYW1zLmFjdGlvbkljb24gfHwgbnVsbCk7XG4gICAgdGhpcy5hY3Rpb25UZXh0ID0gZ2V0T2JzZXJ2YWJsZShwYXJhbXMuYWN0aW9uVGV4dCB8fCBudWxsKTtcbiAgICB0aGlzLmNsYXNzTmFtZXMgPSBnZXRPYnNlcnZhYmxlKHBhcmFtcy5jbGFzc05hbWVzIHx8IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVTbG90Vmlld01vZGVsO1xuXG52YXIgbnVtZXJhbCA9IHJlcXVpcmUoJ251bWVyYWwnKSxcbiAgICBBcHBvaW50bWVudCA9IHJlcXVpcmUoJy4uL21vZGVscy9BcHBvaW50bWVudCcpO1xuXG4vKipcbiAgICBTdGF0aWMgY29uc3RydWN0b3IgdG8gY29udmVydCBhbiBBcHBvaW50bWVudCBtb2RlbCBpbnRvIFxuICAgIGEgVGltZVNsb3QgaW5zdGFuY2UgZm9sbG93aW5nIFVJIGNyaXRlcmlhIGZvciBwcmVzZXQgdmFsdWVzL3NldHVwLlxuKiovXG5UaW1lU2xvdFZpZXdNb2RlbC5mcm9tQXBwb2ludG1lbnQgPSBmdW5jdGlvbiBmcm9tQXBwb2ludG1lbnQoYXB0KSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eToxMCAqL1xuICAgIFxuICAgIC8vIENvbW1lbnRlZCB0aGUgb3B0aW9uIHRvIGRldGVjdCBhbmQgbm90IGxpbmsgdW5hdmFpbCBzbG90czpcbiAgICAvL3ZhciB1bmF2YWlsID0gQXBwb2ludG1lbnQuc3BlY2lhbElkcy51bmF2YWlsYWJsZSA9PT0gYXB0LmlkKCk7XG4gICAgLy92YXIgbGluayA9IG51bGw7XG4gICAgLy9pZiAoIXVuYXZhaWwpXG4gICAgdmFyIGxpbmsgPSAnIyFhcHBvaW50bWVudC8nICsgYXB0LnN0YXJ0VGltZSgpLnRvSVNPU3RyaW5nKCkgKyAnLycgKyBhcHQuaWQoKTtcbiAgICBcbiAgICBpZiAoYXB0LmlkKCkgPT09IEFwcG9pbnRtZW50LnNwZWNpYWxJZHMucHJlcGFyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgbGluayBjYXNlOiBpdCBnb2VzIHRvIHNjaGVkdWxpbmcgcHJlZmVyZW5jZXMgdG8gYWxsb3cgcXVpY2sgZWRpdFxuICAgICAgICAvLyB0aGUgcHJlcGFyYXRpb24gdGltZSBzbG90c1xuICAgICAgICBsaW5rID0gJyMhc2NoZWR1bGluZ1ByZWZlcmVuY2VzP211c3RSZXR1cm49MSc7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZXMgPSBudWxsO1xuICAgIGlmIChBcHBvaW50bWVudC5zcGVjaWFsSWRzLmZyZWUgPT09IGFwdC5pZCgpKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgPSAnVGlsZS0tdGFnLWdyYXktbGlnaHRlciAnO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcHQuaWQoKSA+IDAgJiYgYXB0LnNvdXJjZUJvb2tpbmcoKSkge1xuICAgICAgICBpZiAoYXB0LnNvdXJjZUJvb2tpbmcoKS5zZXJ2aWNlRGF0ZUlEKCkpXG4gICAgICAgICAgICBjbGFzc05hbWVzID0gJ1RpbGUtLXRhZy1wcmltYXJ5ICcgO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAvLyBpcyBhIHJlcXVlc3Q6XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gJ1RpbGUtLXRhZy13YXJuaW5nICc7XG4gICAgICAgIFxuICAgICAgICBjbGFzc05hbWVzICs9ICdJdGVtQWRkb25UaWxlLS1sYXJnZXJDb250ZW50ICc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhbnkgYmxvY2sgZXZlbnQsIHByZXBhcmF0aW9uIHRpbWUgc2xvdHNcbiAgICAgICAgY2xhc3NOYW1lcyA9ICdUaWxlLS10YWctZGFuZ2VyICc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUaW1lU2xvdFZpZXdNb2RlbCh7XG4gICAgICAgIHN0YXJ0VGltZTogYXB0LnN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogYXB0LmVuZFRpbWUsXG4gICAgICAgIHN1YmplY3Q6IGFwdC5zdW1tYXJ5LFxuICAgICAgICBkZXNjcmlwdGlvbjogYXB0LmRlc2NyaXB0aW9uLFxuICAgICAgICBsaW5rOiBsaW5rLFxuICAgICAgICBhY3Rpb25JY29uOiAoYXB0LnNvdXJjZUJvb2tpbmcoKSA/IG51bGwgOiBhcHQuc291cmNlRXZlbnQoKSA/ICdmYSBpb24gaW9uLWlvcy1hcnJvdy1yaWdodCcgOiAhYXB0LmlkKCkgPyAnZmEgaW9uIGlvbi1wbHVzJyA6IG51bGwpLFxuICAgICAgICBhY3Rpb25UZXh0OiAoXG4gICAgICAgICAgICBhcHQuc291cmNlQm9va2luZygpICYmIFxuICAgICAgICAgICAgYXB0LnNvdXJjZUJvb2tpbmcoKS5wcmljaW5nU3VtbWFyeSgpID8gXG4gICAgICAgICAgICBudW1lcmFsKGFwdC5zb3VyY2VCb29raW5nKCkucHJpY2luZ1N1bW1hcnkoKS50b3RhbFByaWNlKCkgfHwgMCkuZm9ybWF0KCckMC4wMCcpIDpcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKSxcbiAgICAgICAgY2xhc3NOYW1lczogY2xhc3NOYW1lc1xuICAgIH0pO1xufTtcbiIsIi8qKlxuICAgIFVzZXJKb2JQcm9maWxlVmlld01vZGVsOiBsb2FkcyBkYXRhIGFuZCBrZWVwIHN0YXRlXG4gICAgdG8gZGlzcGxheSB0aGUgbGlzdGluZyBvZiBqb2IgdGl0bGVzIGZyb20gdGhlIFxuICAgIHVzZXIgam9iIHByb2ZpbGUuXG4qKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKSxcbiAgICBVc2VySm9iVGl0bGUgPSByZXF1aXJlKCcuLi9tb2RlbHMvVXNlckpvYlRpdGxlJyk7XG5cbmZ1bmN0aW9uIFVzZXJKb2JQcm9maWxlVmlld01vZGVsKGFwcCkge1xuICAgIFxuICAgIHRoaXMuc2hvd01hcmtldHBsYWNlSW5mbyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIFxuICAgIC8vIExvYWQgYW5kIHNhdmUgam9iIHRpdGxlIGluZm9cbiAgICB2YXIgam9iVGl0bGVzSW5kZXggPSB7fTtcbiAgICBmdW5jdGlvbiBzeW5jSm9iVGl0bGUoam9iVGl0bGVJRCkge1xuICAgICAgICByZXR1cm4gYXBwLm1vZGVsLmpvYlRpdGxlcy5nZXRKb2JUaXRsZShqb2JUaXRsZUlEKVxuICAgICAgICAudGhlbihmdW5jdGlvbihqb2JUaXRsZSkge1xuICAgICAgICAgICAgam9iVGl0bGVzSW5kZXhbam9iVGl0bGVJRF0gPSBqb2JUaXRsZTtcblxuICAgICAgICAgICAgLy8gVE9ETzogZXJyb3JzPyBub3QtZm91bmQgam9iIHRpdGxlP1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhICdqb2JUaXRsZScgb2JzZXJ2YWJsZSBvbiB0aGUgdXNlckpvYlRpdGxlXG4gICAgLy8gbW9kZWwgdG8gaGF2ZSBhY2Nlc3MgdG8gYSBjYWNoZWQgam9iVGl0bGUgbW9kZWwuXG4gICAgZnVuY3Rpb24gYXR0YWNoSm9iVGl0bGUodXNlckpvYlRpdGxlKSB7XG4gICAgICAgIHVzZXJKb2JUaXRsZS5qb2JUaXRsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gam9iVGl0bGVzSW5kZXhbdGhpcy5qb2JUaXRsZUlEKCldO1xuICAgICAgICB9LCB1c2VySm9iVGl0bGUpO1xuICAgICAgICAvLyBTaG9ydGN1dCB0byBzaW5ndWxhciBuYW1lXG4gICAgICAgIHVzZXJKb2JUaXRsZS5kaXNwbGF5ZWRTaW5ndWxhck5hbWUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmpvYlRpdGxlKCkgJiYgdGhpcy5qb2JUaXRsZSgpLnNpbmd1bGFyTmFtZSgpIHx8ICdVbmtub3cnO1xuICAgICAgICB9LCB1c2VySm9iVGl0bGUpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBhdHRhY2hNYXJrZXRwbGFjZVN0YXR1cyh1c2VySm9idGl0bGUpIHtcbiAgICAgICAgdXNlckpvYnRpdGxlLm1hcmtldHBsYWNlU3RhdHVzSHRtbCA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXR1c0lEKCk7XG4gICAgICAgICAgICAvLyBMMThOXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSBVc2VySm9iVGl0bGUuc3RhdHVzLm9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNYXJrZXRwbGFjZSBwcm9maWxlOiA8c3Ryb25nIGNsYXNzPVwidGV4dC1zdWNjZXNzXCI+T048L3N0cm9uZz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSBVc2VySm9iVGl0bGUuc3RhdHVzLm9mZikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTWFya2V0cGxhY2UgcHJvZmlsZTogPHN0cm9uZyBjbGFzcz1cInRleHQtZGFuZ2VyXCI+T0ZGPC9zdHJvbmc+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlYWQgbnVtYmVyIG9mIHN0ZXBzIGxlZnQgdG8gYWN0aXZhdGUgZnJvbSByZXF1aXJlZCBhbGVydHMgZm9yIHRoZSBqb2J0aXRsZVxuICAgICAgICAgICAgICAgIC8vICdfX2NvdW50X18gc3RlcHMgbGVmdCB0byBhY3RpdmF0ZSdcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwidGV4dC1kYW5nZXJcIj5UaGVyZSBhcmUgc3RlcHMgbGVmdCB0byBhY3RpdmF0ZTwvc3Bhbj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB1c2VySm9idGl0bGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dGFjaEV4dHJhcyh1c2VySm9idGl0bGUpIHtcbiAgICAgICAgYXR0YWNoSm9iVGl0bGUodXNlckpvYnRpdGxlKTtcbiAgICAgICAgYXR0YWNoTWFya2V0cGxhY2VTdGF0dXModXNlckpvYnRpdGxlKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy51c2VySm9iUHJvZmlsZSA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG4gICAgLy8gVXBkYXRlZCB1c2luZyB0aGUgbGl2ZSBsaXN0LCBmb3IgYmFja2dyb3VuZCB1cGRhdGVzXG4gICAgYXBwLm1vZGVsLnVzZXJKb2JQcm9maWxlLmxpc3Quc3Vic2NyaWJlKGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgam9iIHRpdGxlcyBpbmZvIGJlZm9yZSBlbmRcbiAgICAgICAgUHJvbWlzZS5hbGwobGlzdC5tYXAoZnVuY3Rpb24odXNlckpvYlRpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3luY0pvYlRpdGxlKHVzZXJKb2JUaXRsZS5qb2JUaXRsZUlEKCkpO1xuICAgICAgICB9KSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBOZWVkcyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSB2aWV3XG4gICAgICAgICAgICBsaXN0LmZvckVhY2goYXR0YWNoRXh0cmFzKTtcblxuICAgICAgICAgICAgdGhpcy51c2VySm9iUHJvZmlsZShsaXN0KTtcblxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy50aGVyZUlzRXJyb3IoZmFsc2UpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaChzaG93TG9hZGluZ0Vycm9yKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaXNGaXJzdFRpbWUgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuICAgIHRoaXMuaXNMb2FkaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gICAgdGhpcy5pc1N5bmNpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgICB0aGlzLnRoZXJlSXNFcnJvciA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICAgIHRoaXMuYmFzZVVybCA9IGtvLm9ic2VydmFibGUoJy9qb2J0aXRsZXMnKTtcbiAgICBcbiAgICB0aGlzLnNlbGVjdEpvYlRpdGxlID0gZnVuY3Rpb24oam9iVGl0bGUpIHtcbiAgICAgICAgLy8gR29sbG93IHRoZSBuZXh0IGxpbms6XG4gICAgICAgIGFwcC5zaGVsbC5nbyh0aGlzLmJhc2VVcmwoKSArICcvJyArIGpvYlRpdGxlLmpvYlRpdGxlSUQoKSk7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHJlcGxhY2VkIGJ5IGN1c3RvbSBoYW5kbGluZy5cbiAgICAgICAgLy8gU3RvcCBldmVudHNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBcbiAgICB2YXIgc2hvd0xvYWRpbmdFcnJvciA9IGZ1bmN0aW9uIHNob3dMb2FkaW5nRXJyb3IoZXJyKSB7XG4gICAgICAgIGFwcC5tb2RhbHMuc2hvd0Vycm9yKHtcbiAgICAgICAgICAgIHRpdGxlOiAnQW4gZXJyb3IgaGFwcGVuaW5nIHdoZW4gbG9hZGluZyB5b3VyIGpvYiBwcm9maWxlLicsXG4gICAgICAgICAgICBlcnJvcjogZXJyICYmIGVyci5lcnJvciB8fCBlcnJcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmlzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHRoaXMuaXNTeW5jaW5nKGZhbHNlKTtcbiAgICAgICAgdGhpcy50aGVyZUlzRXJyb3IodHJ1ZSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gTG9hZGluZyBhbmQgc3luYyBvZiBkYXRhXG4gICAgdGhpcy5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRoaXMuaXNGaXJzdFRpbWUoKTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0VGltZShmYWxzZSk7XG5cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzU3luY2luZyh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgZGF0YSB1cGRhdGVkOlxuICAgICAgICBhcHAubW9kZWwudXNlckpvYlByb2ZpbGUuc3luY0xpc3QoKVxuICAgICAgICAuY2F0Y2goc2hvd0xvYWRpbmdFcnJvcik7XG5cbiAgICB9LmJpbmQodGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlckpvYlByb2ZpbGVWaWV3TW9kZWw7XG4iXX0=
